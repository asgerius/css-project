[{"tags": ["string", "reference", "rust", "borrowing"], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 6, "creation_date": 1476311212, "post_id": 40006220, "comment_id": 67296882, "body": "How about a <b>tl;dr</b> in the beginning? This answer is already somewhat long. Something like &quot;<code>&amp;str</code> is more general (as in: imposes less restrictions) without reduced capabilities&quot;? Also: point 3 is often not that important I think. Usually <code>Vec</code>s and <code>String</code>s will live on the stack and often even somewhere near the current stack frame. The stack is usually hot and the dereference will be served from a CPU cache."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 3, "creation_date": 1476341790, "post_id": 40006220, "comment_id": 67305764, "body": "@Shepmaster: Regarding the allocation cost, it might be worth mentioning the particular issue of substrings/slices when talking about mandatory allocation. <code>total_price(&amp;prices[0..4])</code> does not require allocating a new vector for the slice."}, {"owner": {"reputation": 9079, "user_id": 7867968, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/c6976c101b7e5d81ad398cedf6a2ab9b?s=128&d=identicon&r=PG&f=1", "display_name": "C.Nivs", "link": "https://stackoverflow.com/users/7867968/c-nivs"}, "edited": false, "score": 5, "creation_date": 1537754966, "post_id": 40006220, "comment_id": 91885760, "body": "This is a great answer. I&#39;m just getting started in Rust and was getting tied up figuring out when I should use a <code>&amp;str</code> and <i>why</i> (coming from Python, so I usually don&#39;t explicitly deal with types). Cleared all of that up perfectly"}, {"owner": {"reputation": 325758, "user_id": 415784, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/2WX9Z.jpg?s=128&g=1", "display_name": "Nawaz", "link": "https://stackoverflow.com/users/415784/nawaz"}, "edited": false, "score": 2, "creation_date": 1538484887, "post_id": 40006220, "comment_id": 92151563, "body": "Awesome tips on parameters. Just need one doubt: <i>&quot;Accepting a &amp;String, &amp;Vec or &amp;Box also requires an allocation before you can call the method. &quot;</i> ... Why is that so? Could you please point out the part in the docs where I can read this in detail? (I&#39;m a begginner). Also, can we have similar tips on the return types?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 325758, "user_id": 415784, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/2WX9Z.jpg?s=128&g=1", "display_name": "Nawaz", "link": "https://stackoverflow.com/users/415784/nawaz"}, "edited": false, "score": 1, "creation_date": 1538927915, "post_id": 40006220, "comment_id": 92307441, "body": "@Nawaz <a href=\"https://doc.rust-lang.org/std/boxed/struct.Box.html\" rel=\"nofollow noreferrer\"><code>Box</code></a> \u2014 &quot;for heap allocation&quot;. <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" rel=\"nofollow noreferrer\"><code>String</code></a> \u2014 &quot;This buffer is always stored on the heap&quot;. <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html\" rel=\"nofollow noreferrer\"><code>Vec</code></a> \u2014 &quot;the memory it points to is on the heap&quot;"}, {"owner": {"reputation": 898, "user_id": 771405, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/bdf0bf75e96fa18e57769865ebeb9a6e?s=128&d=identicon&r=PG", "display_name": "cjohansson", "link": "https://stackoverflow.com/users/771405/cjohansson"}, "edited": false, "score": 3, "creation_date": 1554194101, "post_id": 40006220, "comment_id": 97651430, "body": "I&#39;m missing information about why extra allocation is required. String is stored on the heap, when accepting &amp;String as argument, why doesn&#39;t just Rust pass a pointer stored on the stack that points to the heap space, I don&#39;t understand why passing a &amp;String would need additional allocation, passing a string slice should also require sending a pointer stored on the stack that points to the heap space?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 898, "user_id": 771405, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/bdf0bf75e96fa18e57769865ebeb9a6e?s=128&d=identicon&r=PG", "display_name": "cjohansson", "link": "https://stackoverflow.com/users/771405/cjohansson"}, "edited": false, "score": 1, "creation_date": 1554203328, "post_id": 40006220, "comment_id": 97657028, "body": "@cjohansson the storage on the heap that you mention <i>is</i> the extra allocation. The reference itself is passed as you describe. <code>awesome_greeting(&amp;String::from(\u201cAnna\u201d))</code> has an unneeded allocation from creating the string at all; <code>awesome_greeting(\u201cAnna\u201d)</code> does not. A string literal like that is not stored on the heap at all."}, {"owner": {"reputation": 462, "user_id": 5452170, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/16bfc7d23c7bad37f5832e8e01cf849d?s=128&d=identicon&r=PG&f=1", "display_name": "Xiao-Feng Li", "link": "https://stackoverflow.com/users/5452170/xiao-feng-li"}, "edited": false, "score": 0, "creation_date": 1569461682, "post_id": 40006220, "comment_id": 102607143, "body": "It is probably easier to understand on the heap allocation part that, Vec and String can dynamically change their contents (size) at runtime, therefore are (almost) impossible to allocate on the stack; and Box is designed for heap allocation. So for function parameter types, it is better to use compatible types for them while not having the implication of mandatory heap allocation."}, {"owner": {"reputation": 2675, "user_id": 545475, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/zl64v.jpg?s=128&g=1", "display_name": "Arnavion", "link": "https://stackoverflow.com/users/545475/arnavion"}, "edited": false, "score": 4, "creation_date": 1577738709, "post_id": 40006220, "comment_id": 105242909, "body": "For completeness, it should be noted that the only time it makes sense to accept <code>&amp;String</code> or <code>&amp;Vec</code> is when you need access to <code>&amp;self</code>-taking methods that only exist on those, namely <code>capacity</code>.  Furthermore, none of this applies to <i>mutable</i> borrows, ie <code>&amp;mut Vec</code> or <code>&amp;mut String</code>, which are legitimately needed when you want to grow or shrink the collection."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 199, "last_activity_date": 1610399920, "last_edit_date": 1610399920, "creation_date": 1476298250, "answer_id": 40006220, "question_id": 40006219, "link": "https://stackoverflow.com/questions/40006219/why-is-it-discouraged-to-accept-a-reference-to-a-string-string-vec-vec-o/40006220#40006220", "title": "Why is it discouraged to accept a reference to a String (&amp;String), Vec (&amp;Vec), or Box (&amp;Box) as a function argument?", "body": "<p><strong>TL;DR: One can instead use <code>&amp;str</code>, <code>&amp;[T]</code> or <code>&amp;T</code> to allow for more generic code.</strong></p>\n<hr />\n<ol>\n<li><p>One of the main reasons to use a <code>String</code> or a <code>Vec</code> is because they allow increasing or decreasing the capacity. However, when you accept an immutable reference, you cannot use any of those interesting methods on the <code>Vec</code> or <code>String</code>.</p>\n</li>\n<li><p>Accepting a <code>&amp;String</code>, <code>&amp;Vec</code> or <code>&amp;Box</code> also <strong>requires</strong> the argument to be allocated on the heap before you can call the function. Accepting a <code>&amp;str</code> allows a string literal (saved in the program data) and accepting a <code>&amp;[T]</code> or <code>&amp;T</code> allows a stack-allocated array or variable. Unnecessary allocation is a performance loss. This is usually exposed right away when you try to call these methods in a test or a <code>main</code> method:</p>\n<pre><code>awesome_greeting(&amp;String::from(&quot;Anna&quot;));\n</code></pre>\n<pre><code>total_price(&amp;vec![42, 13, 1337])\n</code></pre>\n<pre><code>is_even(&amp;Box::new(42))\n</code></pre>\n</li>\n<li><p>Another performance consideration is that <code>&amp;String</code>, <code>&amp;Vec</code> and <code>&amp;Box</code> introduce an unnecessary layer of indirection as you have to dereference the <code>&amp;String</code> to get a <code>String</code> and then perform a second dereference to end up at <code>&amp;str</code>.</p>\n</li>\n</ol>\n<p>Instead, you should accept a <em>string slice</em> (<code>&amp;str</code>), a <em>slice</em> (<code>&amp;[T]</code>), or just a reference (<code>&amp;T</code>). A <code>&amp;String</code>, <code>&amp;Vec&lt;T&gt;</code> or <code>&amp;Box&lt;T&gt;</code> will be automatically coerced (via <a href=\"https://doc.rust-lang.org/stable/reference/type-coercions.html#coercion-types\" rel=\"noreferrer\"><em>deref coercion</em></a>) to a <code>&amp;str</code>, <code>&amp;[T]</code> or <code>&amp;T</code>, respectively.</p>\n<pre><code>fn awesome_greeting(name: &amp;str) {\n    println!(&quot;Wow, you are awesome, {}!&quot;, name);\n}\n</code></pre>\n<pre><code>fn total_price(prices: &amp;[i32]) -&gt; i32 {\n    prices.iter().sum()\n}\n</code></pre>\n<pre><code>fn is_even(value: &amp;i32) -&gt; bool {\n    *value % 2 == 0\n}\n</code></pre>\n<p>Now you can call these methods with a broader set of types. For example, <code>awesome_greeting</code> can be called with a string literal (<code>&quot;Anna&quot;</code>) <em>or</em> an allocated <code>String</code>. <code>total_price</code> can be called with a reference to an array (<code>&amp;[1, 2, 3]</code>) <em>or</em> an allocated <code>Vec</code>.</p>\n<hr />\n<p>If you'd like to add or remove items from the <code>String</code> or <code>Vec&lt;T&gt;</code>, you can take a <em>mutable reference</em> (<code>&amp;mut String</code> or <code>&amp;mut Vec&lt;T&gt;</code>):</p>\n<pre><code>fn add_greeting_target(greeting: &amp;mut String) {\n    greeting.push_str(&quot;world!&quot;);\n}\n</code></pre>\n<pre><code>fn add_candy_prices(prices: &amp;mut Vec&lt;i32&gt;) {\n    prices.push(5);\n    prices.push(25);\n}\n</code></pre>\n<p>Specifically for slices, you can also accept a <code>&amp;mut [T]</code> or <code>&amp;mut str</code>. This allows you to mutate a specific value inside the slice, but you cannot change the number of items inside the slice (which means it's very restricted for strings):</p>\n<pre><code>fn reset_first_price(prices: &amp;mut [i32]) {\n    prices[0] = 0;\n}\n</code></pre>\n<pre><code>fn lowercase_first_ascii_character(s: &amp;mut str) {\n    if let Some(f) = s.get_mut(0..1) {\n        f.make_ascii_lowercase();\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "is_accepted": false, "score": 29, "last_activity_date": 1539450252, "last_edit_date": 1539450252, "creation_date": 1536742903, "answer_id": 52291346, "question_id": 40006219, "link": "https://stackoverflow.com/questions/40006219/why-is-it-discouraged-to-accept-a-reference-to-a-string-string-vec-vec-o/52291346#52291346", "title": "Why is it discouraged to accept a reference to a String (&amp;String), Vec (&amp;Vec), or Box (&amp;Box) as a function argument?", "body": "<p>In addition to <a href=\"https://stackoverflow.com/a/40006220/493729\">Shepmaster's answer</a>, another reason to accept a <code>&amp;str</code> (and similarly <code>&amp;[T]</code> etc) is because of all of the other types <em>besides</em> <code>String</code> and <code>&amp;str</code> that also satisfy <code>Deref&lt;Target = str&gt;</code>. One of the most notable examples is <code>Cow&lt;str&gt;</code>, which lets you be very flexible about whether you are dealing with owned or borrowed data.</p>\n\n<p>If you have:</p>\n\n<pre><code>fn awesome_greeting(name: &amp;String) {\n    println!(\"Wow, you are awesome, {}!\", name);\n}\n</code></pre>\n\n<p>But you need to call it with a <code>Cow&lt;str&gt;</code>, you'll have to do this:</p>\n\n<pre><code>let c: Cow&lt;str&gt; = Cow::from(\"hello\");\n// Allocate an owned String from a str reference and then makes a reference to it anyway!\nawesome_greeting(&amp;c.to_string());\n</code></pre>\n\n<p>When you change the argument type to <code>&amp;str</code>, you can use <code>Cow</code> seamlessly, without any unnecessary allocation, just like with <code>String</code>:</p>\n\n<pre><code>let c: Cow&lt;str&gt; = Cow::from(\"hello\");\n// Just pass the same reference along\nawesome_greeting(&amp;c);\n\nlet c: Cow&lt;str&gt; = Cow::from(String::from(\"hello\"));\n// Pass a reference to the owned string that you already have\nawesome_greeting(&amp;c);\n</code></pre>\n\n<p>Accepting <code>&amp;str</code> makes calling your function more uniform and convenient, and the \"easiest\" way is now also the most efficient. These examples will also work with <code>Cow&lt;[T]&gt;</code> etc.</p>\n"}], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 11987, "favorite_count": 42, "accepted_answer_id": 40006220, "answer_count": 2, "score": 154, "last_activity_date": 1610399920, "creation_date": 1476298250, "last_edit_date": 1547603524, "question_id": 40006219, "link": "https://stackoverflow.com/questions/40006219/why-is-it-discouraged-to-accept-a-reference-to-a-string-string-vec-vec-o", "title": "Why is it discouraged to accept a reference to a String (&amp;String), Vec (&amp;Vec), or Box (&amp;Box) as a function argument?", "body": "<p>I wrote some Rust code that takes a <code>&amp;String</code> as an argument: </p>\n\n<pre><code>fn awesome_greeting(name: &amp;String) {\n    println!(\"Wow, you are awesome, {}!\", name);\n}\n</code></pre>\n\n<p>I've also written code that takes in a reference to a <code>Vec</code> or <code>Box</code>:</p>\n\n<pre><code>fn total_price(prices: &amp;Vec&lt;i32&gt;) -&gt; i32 {\n    prices.iter().sum()\n}\n\nfn is_even(value: &amp;Box&lt;i32&gt;) -&gt; bool {\n    **value % 2 == 0\n}\n</code></pre>\n\n<p>However, I received some feedback that doing it like this isn't a good idea. Why not?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1476240631, "post_id": 39989581, "comment_id": 67258019, "body": "I don&#39;t exactly know how to do it all in one. Without knowing exactly what you&#39;re after though, you might be able to get away with moving the duplicate code into a helper function via the use of the <code>Borrow</code> trait? <a href=\"https://play.rust-lang.org/?gist=296e500aa94741cb59af262454f5f413&amp;backtrace=0\" rel=\"nofollow noreferrer\">This playpen might provide a possible solution</a>."}], "answers": [{"comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1476240823, "post_id": 39989783, "comment_id": 67258066, "body": "I had to quickly test this at my C# job at work in the playpen while on my lunch break.. so I couldn&#39;t think quick enough to figure out the syntax exactly. I am glad I was on the right path somewhat though!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 1, "creation_date": 1476241040, "post_id": 39989783, "comment_id": 67258124, "body": "@SimonWhitehead you&#39;ll get to the point where you can bash out Rust code while your integration tests run. Then while the unit tests run. Then while Intellisense draws squiggles. ;-)"}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1476242064, "post_id": 39989783, "comment_id": 67258387, "body": "@Shepmaster haha - I hope so. The context switching between Rust and .NET in the middle of the day is a bit jarring; even when I have 5 minutes to context switch while my integration tests run :P"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 7, "last_activity_date": 1476240917, "last_edit_date": 1476240917, "creation_date": 1476240764, "answer_id": 39989783, "question_id": 39989581, "link": "https://stackoverflow.com/questions/39989581/is-there-a-way-to-implement-a-trait-for-iterators-over-all-reference-types-gener/39989783#39989783", "title": "Is there a way to implement a trait for iterators over all reference types generically?", "body": "<p>You can use the <a href=\"https://doc.rust-lang.org/stable/std/borrow/trait.Borrow.html\"><code>Borrow</code></a> trait for this. If you look at the implementors in the documentation page, the first three are relevant here: it means that <code>f64</code>, <code>&amp;'a f64</code> and <code>&amp;'a mut f64</code> all implement <code>Borrow&lt;f64&gt;</code>. You'll have to call the <a href=\"https://doc.rust-lang.org/stable/std/borrow/trait.Borrow.html#tymethod.borrow\"><code>borrow</code></a> method on each value produced by the iterator to obtain a <code>&amp;f64</code>.</p>\n\n<pre><code>use std::borrow::Borrow;\n\nimpl&lt;T&gt; Foo&lt;T::Item&gt; for T\n    where T: Iterator,\n          T::Item: Borrow&lt;f64&gt;\n{\n    fn bar(&amp;mut self) -&gt; f64 {\n        unimplemented!()\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>By the way, it doesn't really make sense to define a type parameter on the trait and at the same time put a constraint between that type parameter and a supertrait's associated type. A type <code>T</code> can only have one implementation of <code>Iterator</code>, therefore it can only have one implementation of <code>Foo</code> as well, despite the type parameter suggesting that it could implement many different <code>Foo&lt;T&gt;</code> traits. Therefore, the type parameter on <code>Foo</code> is completely redundant (you can just use the supertrait's associated types instead of the type parameter). Thus the code should look more like this:</p>\n\n<pre><code>use std::borrow::Borrow;\n\ntrait Foo: Iterator {\n    fn bar(&amp;mut self) -&gt; f64;\n}\n\nimpl&lt;T&gt; Foo for T\n    where T: Iterator,\n          T::Item: Borrow&lt;f64&gt;\n{\n    fn bar(&amp;mut self) -&gt; f64 {\n        unimplemented!()\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 397, "user_id": 992058, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/aef573436082d96d0e5a9a9335800e93?s=128&d=identicon&r=PG", "display_name": "michael60612", "link": "https://stackoverflow.com/users/992058/michael60612"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 269, "favorite_count": 0, "accepted_answer_id": 39989783, "answer_count": 1, "score": 10, "last_activity_date": 1476240917, "creation_date": 1476239395, "last_edit_date": 1476240802, "question_id": 39989581, "link": "https://stackoverflow.com/questions/39989581/is-there-a-way-to-implement-a-trait-for-iterators-over-all-reference-types-gener", "title": "Is there a way to implement a trait for iterators over all reference types generically?", "body": "<p>I have a trait</p>\n\n<pre><code>trait Foo&lt;T&gt; : Iterator&lt;Item=T&gt; {\n    fn bar(&amp;mut self) -&gt; f64;\n}\n</code></pre>\n\n<p>I want to implement this trait once for a type <code>T</code> (in my case <code>f64</code>) over all its reference types (<code>f64</code>, <code>&amp;'a f64</code>, and <code>&amp;'a mut f64</code>) since logically it doesn't matter.</p>\n\n<p>I currently have</p>\n\n<pre><code>impl&lt;T: Iterator&lt;Item = f64&gt;&gt; Foo&lt;f64&gt; for T {\n    fn bar(&amp;mut self) -&gt; f64 {\n        // duplicated code\n    }\n}\n\nimpl&lt;'a, T: Iterator&lt;Item = &amp;'a f64&gt;&gt; Foo&lt;&amp;'a f64&gt; for T {\n    fn bar(&amp;mut self) -&gt; f64 {\n        // duplicated code\n    }\n}\n\nimpl&lt;'a, T: Iterator&lt;Item = &amp;'a mut f64&gt;&gt; Foo&lt;&amp;'a mut f64&gt; for T {\n    fn bar(&amp;mut self) -&gt; f64 {\n        // duplicated code\n    }\n}\n</code></pre>\n\n<p>Is there a good way to accomplish this without duplication? </p>\n"}, {"tags": ["macros", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476219501, "post_id": 39986539, "comment_id": 67252026, "body": "You can&#39;t do the first <a href=\"http://stackoverflow.com/a/36259524/155423\">because you have to expand to syntactically valid code</a>. Also, there&#39;s no <code>[</code> or <code>]</code> that I can see..."}, {"owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476219672, "post_id": 39986539, "comment_id": 67252131, "body": "Well, for the first macro, you would need to use <code>let array = [create_array!(     fn test() -&gt; i32 { }     fn test1() { } )];</code> if it was possible."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476219803, "post_id": 39986539, "comment_id": 67252193, "body": "You probably should include the intended usage of each macro for completeness."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 1, "creation_date": 1476220387, "post_id": 39986539, "comment_id": 67252473, "body": "<code>[test, test1]</code> \u2192 this wouldn&#39;t compile, the two functions have different types."}, {"owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1476221294, "post_id": 39986539, "comment_id": 67252952, "body": "@mcarton The macro does not generate the functions, so the identifiers will have to come from somewhere else."}, {"owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476221514, "post_id": 39986539, "comment_id": 67253050, "body": "@Shepmaster It is a bit complicated, so I&#39;ll post a brief description here. It is used to generate a proxy object for dbus. The macro generate <code>const</code> objects that represent the dbus methods; these const objects are named by the function name. I need to create another <code>const</code> object that holds an array of these methods: hence my need for this macro. If there is another way to achieve the desired result, that would be appreciated too."}], "answers": [{"tags": [], "owner": {"reputation": 6357, "user_id": 6086311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cb99289473f6393b89474785f2d294d1?s=128&d=identicon&r=PG", "display_name": "dtolnay", "link": "https://stackoverflow.com/users/6086311/dtolnay"}, "is_accepted": true, "score": 3, "last_activity_date": 1538960876, "creation_date": 1538960876, "answer_id": 52694239, "question_id": 39986539, "link": "https://stackoverflow.com/questions/39986539/how-can-i-use-a-macro-to-create-an-array-of-function-names-starting-from-a-colle/52694239#52694239", "title": "How can I use a macro to create an array of function names starting from a collection of function definitions?", "body": "<p>The parsing ambiguity of <code>-&gt;</code> vs <code>$:block</code> has been resolved as of Rust 1.20, so the second version you tried will now work as intended.</p>\n\n<pre><code>macro_rules! create_array {\n    ($(fn $func_name:ident () $(-&gt; $return_type:ty)* $block:block)*) =&gt; {\n        [$($func_name),*]\n    };\n}\n\nfn main() {\n    let test = \"TEST\";\n    let test1 = \"TEST1\";\n\n    let array = create_array! {\n        fn test() -&gt; i32 {}\n        fn test1() {}\n    };\n\n    println!(\"{:?}\", array);\n}\n</code></pre>\n"}], "owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 630, "favorite_count": 0, "accepted_answer_id": 52694239, "answer_count": 1, "score": 1, "last_activity_date": 1538962317, "creation_date": 1476219201, "last_edit_date": 1538962317, "question_id": 39986539, "link": "https://stackoverflow.com/questions/39986539/how-can-i-use-a-macro-to-create-an-array-of-function-names-starting-from-a-colle", "title": "How can I use a macro to create an array of function names starting from a collection of function definitions?", "body": "<p>I would like to create an array in a macro to transform something like:</p>\n\n<pre><code>let array = create_array!(\n    fn test() -&gt; i32 { }\n    fn test1() { }\n);\n</code></pre>\n\n<p>into</p>\n\n<pre><code>let array = [test, test1];\n</code></pre>\n\n<p>I tried this:</p>\n\n<pre><code>macro_rules! create_array {\n    () =&gt; {\n    };\n    (fn $func_name:ident () -&gt; $return_type:ty $block:block $($rest:tt)*) =&gt; {\n        $func_name,\n        create_array!($($rest)*);\n    };\n    (fn $func_name:ident () $block:block $($rest:tt)*) =&gt; {\n        $func_name,\n        create_array!($($rest)*);\n    };\n}\n</code></pre>\n\n<p>but it fails with the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: macro expansion ignores token `,` and any following\n  --&gt; src/main.rs:11:19\n   |\n11 |         $func_name,\n   |                   ^\n   |\nnote: caused by the macro expansion here; the usage of `create_array!` is likely invalid in expression context\n  --&gt; src/main.rs:27:18\n   |\n27 |     let array = [create_array!(\n   |\n</code></pre>\n\n<p>I also tried this:</p>\n\n<pre><code>macro_rules! create_array {\n    ($(fn $func_name:ident () $( -&gt; $return_type:ty )* $block:block)*) =&gt; {\n        [$($func_name),*]\n    };\n}\n</code></pre>\n\n<p>but it fails with:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: local ambiguity: multiple parsing options: built-in NTs block ('block') or 1 other option.\n  --&gt; src/main.rs:22:19\n   |\n22 |         fn test() -&gt; i32 { }\n   |\n</code></pre>\n\n<p>So how can I create an array in such a case?</p>\n"}, {"tags": ["unit-testing", "rust", "rust-cargo"], "answers": [{"comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1476192298, "post_id": 39977557, "comment_id": 67235285, "body": "Keep the regular <code>fn</code> syntax, that makes it even easier to use. Also allow multiple test functions to be bracketed at the same time."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1476229076, "post_id": 39977557, "comment_id": 67255543, "body": "Great find. I will certainly use this!"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 8, "last_activity_date": 1476190187, "last_edit_date": 1476190187, "creation_date": 1476189877, "answer_id": 39977557, "question_id": 39977556, "link": "https://stackoverflow.com/questions/39977556/is-there-a-way-to-make-it-easier-to-debug-failing-non-terminating-tests/39977557#39977557", "title": "Is there a way to make it easier to debug failing, non-terminating, tests?", "body": "<p>I've come across <a href=\"https://libraries.io/cargo/timebomb\">timebomb</a> which looks like close to what I need, but does mean manually wrapping every test; i.e. instead of:</p>\n\n<pre><code>#[test]\nfn test() {\n    assert!(true);\n}\n</code></pre>\n\n<p>I need to do:</p>\n\n<pre><code>extern crate timebomb;\nuse timebomb::timeout_ms;\n\n#[test]\nfn test() {\n    timeout_ms(|| {\n        assert!(true);\n    }, 1000);\n}\n</code></pre>\n\n<p>which is a pain (but admittedly one-time) for dozens of tests.\nBut wait; Rust has macros!  This actually seems like a reasonable solution:</p>\n\n<pre><code>extern crate timebomb;\nuse timebomb::timeout_ms;\n\nmacro_rules! timeout_test {\n    ( $name:ident() $code:block ) =&gt; {\n        #[test]\n        fn $name() {\n            timeout_ms(|| $code, 1000);\n        }\n    }\n}\n\n// the hard way\n#[test]\nfn foo() {\n    timeout_ms(|| {\n        loop {}\n    }, 1000);\n}\n\n// the now easy way\ntimeout_test!(bar() {\n   loop {}\n});\n</code></pre>\n"}], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 87, "favorite_count": 0, "accepted_answer_id": 39977557, "answer_count": 1, "score": 3, "last_activity_date": 1476190187, "creation_date": 1476189877, "last_edit_date": 1476190134, "question_id": 39977556, "link": "https://stackoverflow.com/questions/39977556/is-there-a-way-to-make-it-easier-to-debug-failing-non-terminating-tests", "title": "Is there a way to make it easier to debug failing, non-terminating, tests?", "body": "<p>If a <code>#[test]</code> function accidentally loops forever, the test suite doesn't finish.  If you kill it (eg <kbd>ctrl</kbd>-<kbd>c</kbd>), <code>cargo test</code> seems to exit silently, so you get neither a stack trace (if enabled) or a report of which tests passed or failed.</p>\n\n<p>Is there a way to make it easier to debug failing, non-terminating, tests?</p>\n"}, {"tags": ["rust", "typing"], "answers": [{"tags": [], "owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "is_accepted": true, "score": 9, "last_activity_date": 1476188907, "last_edit_date": 1476188907, "creation_date": 1476188388, "answer_id": 39977114, "question_id": 39976890, "link": "https://stackoverflow.com/questions/39976890/how-to-return-any-from-a-function/39977114#39977114", "title": "How to return Any from a function?", "body": "<p><a href=\"https://doc.rust-lang.org/std/any/trait.Any.html\"><code>Any</code></a> is a trait, which means that it is unsized and thus cannot be returned by a function as is.</p>\n\n<p>However, you can try boxing it:</p>\n\n<pre><code>fn get_val (id:i32, mem_ptr: usize) -&gt; Option&lt;Box&lt;Any&gt;&gt; {\n     match id {\n         $(\n             $id =&gt; Some(Box::new($io::read(mem_ptr))),\n         )*\n         _ =&gt; None,\n     }\n}\n</code></pre>\n\n<p>An example <a href=\"https://play.rust-lang.org/?code=use%20std%3A%3Aany%3A%3AAny%3B%0A%0Astatic%20DATA%3A%20%5Bu8%3B%202%5D%20%3D%20%5B1%2C%202%5D%3B%0A%0Afn%20fun(numbers%3A%20bool)%20-%3E%20Box%3CAny%3E%20%7B%0A%20%20%20%20if%20numbers%20%7B%0A%20%20%20%20%20%20%20%20Box%3A%3Anew(%26DATA)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Box%3A%3Anew(String%3A%3Afrom(%22Heya!%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20smth%20%3D%20fun(true)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20smth.downcast_ref%3A%3A%3C%26%5Bu8%3B%202%5D%3E())%3B%0A%20%20%20%20let%20smth%20%3D%20fun(false)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20smth.downcast_ref%3A%3A%3CString%3E())%3B%0A%7D&amp;version=stable&amp;backtrace=0\">playpen</a>.</p>\n"}], "owner": {"reputation": 3861, "user_id": 590967, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/88ccc433efa17e12844762353ce93b8c?s=128&d=identicon&r=PG", "display_name": "Shisoft", "link": "https://stackoverflow.com/users/590967/shisoft"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 985, "favorite_count": 0, "accepted_answer_id": 39977114, "answer_count": 1, "score": 3, "last_activity_date": 1476189412, "creation_date": 1476187659, "last_edit_date": 1476189412, "question_id": 39976890, "link": "https://stackoverflow.com/questions/39976890/how-to-return-any-from-a-function", "title": "How to return Any from a function?", "body": "<p>I am working on type system for a database project. One problem is mapping a type id to a reader that given an type id and address, a function can return given any data type from built in <code>u32</code>, <code>String</code>, to defined structs. </p>\n\n<p>I don't have any problem on writers, like such macro</p>\n\n<pre><code>    fn set_val (data: &amp;Any, id:i32, mem_ptr: usize) {\n         match id {\n             $(\n                 $id =&gt; $io::write(*data.downcast_ref::&lt;$t&gt;().unwrap(), mem_ptr),\n             )*\n             _ =&gt; (),\n         }\n    }\n</code></pre>\n\n<p>But for the reader <code>Any</code> seems not comfortable to be used as return value because the <code>the trait bound \"std::any::Any + 'static: std::marker::Sized\" is not satisfied</code>. I also tried to return as a reference, but I am stuck at a lifetime</p>\n\n<pre><code>    fn get_val (id:i32, mem_ptr: usize) -&gt; Option&lt;&amp; Any&gt; {\n         match id {\n             $(\n                 $id =&gt; Some(&amp;$io::read(mem_ptr)),\n             )*\n             _ =&gt; None,\n         }\n    }\n</code></pre>\n\n<p>which complains <code>missing lifetime specifier</code>. If <code>'static</code> won't work here due to the return value not live long enough, how can I specify the lifetime here?</p>\n\n<p>PS. The read function from $io returns any kinds of types.</p>\n"}, {"tags": ["function", "memory", "rust", "runtime"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1476166875, "post_id": 39971343, "comment_id": 67222066, "body": "You could find it yourself by running some benchmarks or checking the MIR/assembly output as I did."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1476168847, "post_id": 39971343, "comment_id": 67222808, "body": "@ljedrz: Benchmarks are fickle beasts, best check the unoptimized and optimized MIR/LLVM IR/assembly."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1476169091, "post_id": 39971343, "comment_id": 67222899, "body": "@MatthieuM. agreed - benchmarks are better suited for more complex cases where the other ways are no longer practical."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1476189302, "post_id": 39971419, "comment_id": 67233350, "body": "I&#39;m pretty sure the optimizer is removing everything in the program, as it has no observable side effects. <code>res</code> is completely unused, so I think you&#39;d see the same for <code>fn main() {}</code>."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476189499, "post_id": 39971419, "comment_id": 67233452, "body": "@Shepmaster TIL :). I&#39;ll add this to the answer."}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": true, "score": 6, "last_activity_date": 1476190146, "last_edit_date": 1476190146, "creation_date": 1476166625, "answer_id": 39971419, "question_id": 39971343, "link": "https://stackoverflow.com/questions/39971343/is-there-any-negative-performance-implication-to-using-local-functions-in-rust/39971419#39971419", "title": "Is there any negative performance implication to using local functions in Rust?", "body": "<p>There is no impact; I checked the assembly generated for both variants and it is identical.</p>\n\n<p>The two versions I compared:</p>\n\n<p>\"external\":</p>\n\n<pre><code>fn main() {\n    let x = 2i64;\n    let y = 5i64;\n\n    let external_res = external_plus(x,y);\n}\n\nfn external_plus(x: i64, y: i64)  -&gt; i64 {\n    x + y\n}\n</code></pre>\n\n<p>\"local\":</p>\n\n<pre><code>fn main() {\n    fn local_plus(x: i64, y: i64) -&gt; i64 {\n        x + y\n    }\n    let x = 2i64;\n    let y = 5i64;\n\n    let local_res = local_plus(x, y);\n}\n</code></pre>\n\n<p>And both yield the same asm result (release mode in today's nightly):</p>\n\n<pre><code>    .text\n    .file   \"rust_out.cgu-0.rs\"\n    .section    .text._ZN8rust_out4main17hb497928495d48c40E,\"ax\",@progbits\n    .p2align    4, 0x90\n    .type   _ZN8rust_out4main17hb497928495d48c40E,@function\n_ZN8rust_out4main17hb497928495d48c40E:\n    .cfi_startproc\n    retq\n.Lfunc_end0:\n    .size   _ZN8rust_out4main17hb497928495d48c40E, .Lfunc_end0-_ZN8rust_out4main17hb497928495d48c40E\n    .cfi_endproc\n\n    .section    .text.main,\"ax\",@progbits\n    .globl  main\n    .p2align    4, 0x90\n    .type   main,@function\nmain:\n    .cfi_startproc\n    movq    %rsi, %rax\n    movq    %rdi, %rcx\n    leaq    _ZN8rust_out4main17hb497928495d48c40E(%rip), %rdi\n    movq    %rcx, %rsi\n    movq    %rax, %rdx\n    jmp _ZN3std2rt10lang_start17h14cbded5fe3cd915E@PLT\n.Lfunc_end1:\n    .size   main, .Lfunc_end1-main\n    .cfi_endproc\n\n\n    .section    \".note.GNU-stack\",\"\",@progbits\n</code></pre>\n\n<p>Which means there will be zero difference (not only performance-wise) in the generated binary.</p>\n\n<p>What is more, it doesn't even matter if you use a function; the following approach:</p>\n\n<pre><code>fn main() {\n    let x = 2i64;\n    let y = 5i64;\n\n    let res = x + y;\n}\n</code></pre>\n\n<p>Also yields the same assembly.</p>\n\n<p>The bottom line is that, in general, the functions get inlined regardless of whether you declare them in <code>main()</code> or outside it.</p>\n\n<p><strong>Edit</strong>: as Shepmaster pointed out, in this program there are no side effects, so the generated assembly for both variants is actually the same as the one for:</p>\n\n<pre><code>fn main() {}\n</code></pre>\n\n<p>However, the MIR output for both is the same, too (and different than one for a blank <code>main()</code>), so there shouldn't be any difference coming from the function location even if side effects were present.</p>\n"}, {"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1476172198, "post_id": 39972019, "comment_id": 67224324, "body": "Great answer! Minor nitpick though: maybe you want to stress that there are no <i>direct</i> effects. For example, in Java there are a some kinds of &quot;inner classes&quot; that automatically have a reference to the outer one. The same with Rust closures (simply speaking). So I&#39;d say it&#39;s important to make clear that inner functions do not reference anything from their enclosing function and do not take up stack-space of the enclosing function. Only <i>indirect</i> effects on inlining."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1476173775, "post_id": 39972019, "comment_id": 67225141, "body": "@LukasKalbertodt: I added some bold here. I am reluctant to start a list of what it does NOT affect as I fear it could lead people to think that maybe if it&#39;s not in the list it&#39;s affected, so instead I emphasized (more) that it only affected scope and nothing else."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 7, "last_activity_date": 1476173703, "last_edit_date": 1476173703, "creation_date": 1476169687, "answer_id": 39972019, "question_id": 39971343, "link": "https://stackoverflow.com/questions/39971343/is-there-any-negative-performance-implication-to-using-local-functions-in-rust/39972019#39972019", "title": "Is there any negative performance implication to using local functions in Rust?", "body": "<blockquote>\n  <p>As a bit of an aside, any tips on how I could have found out the answer for myself (either through reading any specific set of documents, or tooling I could use) would be welcome.</p>\n</blockquote>\n\n<p>Do you know of <a href=\"https://play.rust-lang.org/\" rel=\"noreferrer\">the Rust playground</a>?</p>\n\n<p>Enter your code, click on \"LLVM IR\", \"Assembly\" or \"MIR\" instead of \"Run\", and you get to see what is the low-level representation emitted for said code.</p>\n\n<p>I personally prefer LLVM IR (I'm used to reading it from C++), which is still quite higher level than assembly whilst still being <em>post</em> language.</p>\n\n<blockquote>\n  <p>I was wondering if there is any negative performance implication of doing this?</p>\n</blockquote>\n\n<p>That's a very complicated question; actually.</p>\n\n<p>The <strong>only difference</strong> between declaring a function locally or externally in Rust <strong>is one of scope</strong>. Declaring it locally simply reduces its scope. <strong>Nothing else</strong>.</p>\n\n<p>However... scope, and usage, can have drastic effects on compilation.</p>\n\n<p>A function that is used only once, for example, is much more likely to be inlined than a function that is used 10 times. A compiler cannot easily estimate the number of uses of a <code>pub</code> function (unbounded), but has perfect knowledge for local or non-<code>pub</code> functions. And whether a function is inlined or not can drastically affect the performance profile (for worse or better).</p>\n\n<p>So, by reducing the scope, and thereby limiting the usage, you are encouraging the compiler to consider your function for inlining (unless your mark it \"cold\").</p>\n\n<p>On the other hand, since the scope is reduced, it cannot be shared (obviously).</p>\n\n<blockquote>\n  <p>So... what?</p>\n</blockquote>\n\n<p>Follow the usage: define an item in the tightest scope possible.</p>\n\n<p>This is <strong>encapsulation</strong>: now, the next time you need to modify this piece, you will know exactly the impacted scope.</p>\n\n<p>Have some trust in Rust, it won't be introducing overhead if it can avoid it.</p>\n"}], "owner": {"reputation": 1725, "user_id": 537028, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/8a215a6c1e1fcef0635918a0e2d08e66?s=128&d=identicon&r=PG", "display_name": "chamakits", "link": "https://stackoverflow.com/users/537028/chamakits"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 236, "favorite_count": 0, "accepted_answer_id": 39971419, "answer_count": 2, "score": 8, "last_activity_date": 1476190146, "creation_date": 1476166240, "last_edit_date": 1476168819, "question_id": 39971343, "link": "https://stackoverflow.com/questions/39971343/is-there-any-negative-performance-implication-to-using-local-functions-in-rust", "title": "Is there any negative performance implication to using local functions in Rust?", "body": "<p>I recently realized that I could create local functions in Rust (a function within a function).  Seems like a good way to clean up my code without polluting the function space of a file.  Small sample of what I mean below by local function vs an 'external' function:</p>\n\n<pre><code>fn main() {\n    fn local_plus(x: i64, y: i64) -&gt; i64 {\n        x + y\n    }\n    let x = 2i64;\n    let y = 5i64;\n\n    let local_res = local_plus(x, y);\n    let external_res = external_plus(x,y);\n    assert_eq!(local_res, external_res);\n}\n\nfn external_plus(x: i64, y: i64)  -&gt; i64 {\n    x + y\n}\n</code></pre>\n\n<p>I was wondering if there is any negative performance implication of doing this?  Like does Rust re-declare the function or take up some undesired amount of function space each time the containing function runs?  Or does it have literally no performance implication?</p>\n\n<p>As a bit of an aside, any tips on how I could have found out the answer for myself (either through reading any specific set of documents, or tooling I could use) would be welcome.</p>\n"}, {"tags": ["iterator", "rust", "tuples"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 4, "last_activity_date": 1476150544, "creation_date": 1476150544, "answer_id": 39969320, "question_id": 39969287, "link": "https://stackoverflow.com/questions/39969287/strange-type-error-when-producing-new-sequence-in-map-closure/39969320#39969320", "title": "Strange type error when producing new sequence in map closure", "body": "<p><a href=\"https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.unzip\" rel=\"nofollow\"><code>Iterator::unzip</code></a> only supports 2-tuples. You can tell this from the trait bound <code>Self: Iterator&lt;Item=(A, B)&gt;</code> that appears in the <code>where</code> clause.</p>\n"}, {"comments": [{"owner": {"reputation": 5006, "user_id": 2023432, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/89ZPT.png?s=128&g=1", "display_name": "bright-star", "link": "https://stackoverflow.com/users/2023432/bright-star"}, "edited": false, "score": 0, "creation_date": 1476153973, "post_id": 39969324, "comment_id": 67218901, "body": "I don&#39;t know why I didn&#39;t think to just look at the signature. I just assumed it could handle any tuple length."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 5006, "user_id": 2023432, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/89ZPT.png?s=128&g=1", "display_name": "bright-star", "link": "https://stackoverflow.com/users/2023432/bright-star"}, "edited": false, "score": 2, "creation_date": 1476168572, "post_id": 39969324, "comment_id": 67222716, "body": "@TrevorAlexander: Unfortunately... no. Rust does not have variadics, so a number of useful methods are &quot;stuck&quot; until someone figures out how to implement them without variadics or variadics (maybe in a limited form) make it into the language."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1476150558, "creation_date": 1476150558, "answer_id": 39969324, "question_id": 39969287, "link": "https://stackoverflow.com/questions/39969287/strange-type-error-when-producing-new-sequence-in-map-closure/39969324#39969324", "title": "Strange type error when producing new sequence in map closure", "body": "<p><a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.unzip\" rel=\"nofollow\"><code>Iterator::unzip</code></a> is only defined to return a tuple of two items:</p>\n\n<pre><code>fn unzip&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB) \n    where FromA: Default + Extend&lt;A&gt;, \n          FromB: Default + Extend&lt;B&gt;,\n          Self: Iterator&lt;Item=(A, B)&gt;,\n</code></pre>\n\n<p>Note how the return type is <code>(FromA, FromB)</code> - a tuple with two values.</p>\n"}, {"tags": [], "owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "is_accepted": false, "score": 5, "last_activity_date": 1476168870, "last_edit_date": 1476168870, "creation_date": 1476164170, "answer_id": 39971052, "question_id": 39969287, "link": "https://stackoverflow.com/questions/39969287/strange-type-error-when-producing-new-sequence-in-map-closure/39971052#39971052", "title": "Strange type error when producing new sequence in map closure", "body": "<p>You can create custom <code>unzip3</code> implementation based on the <a href=\"https://doc.rust-lang.org/src/core/up/src/libcore/iter/iterator.rs.html#1743-1757\" rel=\"nofollow\">standard <code>unzip</code></a>:</p>\n\n<pre><code>trait IteratorUnzip3 {\n    fn unzip3&lt;A, B, C, FromA, FromB, FromC&gt;(self) -&gt; (FromA, FromB, FromC) where\n        FromA: Default + Extend&lt;A&gt;,\n        FromB: Default + Extend&lt;B&gt;,\n        FromC: Default + Extend&lt;C&gt;,\n        Self: Sized + Iterator&lt;Item=(A, B, C)&gt;,\n    {\n        let mut ts: FromA = Default::default();\n        let mut us: FromB = Default::default();\n        let mut vs: FromC = Default::default();\n\n        for (t, u, v) in self {\n            ts.extend(Some(t));\n            us.extend(Some(u));\n            vs.extend(Some(v));\n        }\n\n        (ts, us, vs)\n    }\n}\n\nimpl&lt;A, B, C, T: Iterator&lt;Item=(A, B, C)&gt;&gt; IteratorUnzip3 for T{}\n\nfn main() { \n    let freq: f64 = 440.0; \n\n    let (sine_440, sine_100, summed_signal): (Vec&lt;f64&gt;, Vec&lt;f64&gt;, Vec&lt;f64&gt;) = \n        [1.0, 2.0, 3.0].iter().cloned()\n            .map(|time_sample| { \n                let sample_440 = (freq * &amp;time_sample).sin(); \n                let sample_100 = (100.0 * &amp;time_sample).sin(); \n                let summed_sample = &amp;sample_440 + &amp;sample_100; \n                (sample_440, sample_100, summed_sample) \n            }).unzip3(); \n\n    println!(\"{:?}\\n{:?}\\n{:?}\", sine_440, sine_100, summed_signal);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=c242838ff2d550404a37b34e08e9f149&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">Playground</a></p>\n"}], "owner": {"reputation": 5006, "user_id": 2023432, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/89ZPT.png?s=128&g=1", "display_name": "bright-star", "link": "https://stackoverflow.com/users/2023432/bright-star"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 125, "favorite_count": 0, "accepted_answer_id": 39969324, "answer_count": 3, "score": 2, "last_activity_date": 1476168870, "creation_date": 1476150262, "last_edit_date": 1495540113, "question_id": 39969287, "link": "https://stackoverflow.com/questions/39969287/strange-type-error-when-producing-new-sequence-in-map-closure", "title": "Strange type error when producing new sequence in map closure", "body": "<p>I was using the strategy from <a href=\"https://stackoverflow.com/a/39954484/2023432\">this question's answer</a>, and I was interested in producing another sequence that is a function of the two being created by the iterator map:</p>\n\n<pre><code>extern crate itertools_num;\n\nuse itertools_num::linspace;\n\nfn main() {\n    // 440Hz as wave frequency (middle A)\n    let freq: f64 = 440.0;\n    // Time vector sampled at 880 times/s (~Nyquist), over 1s\n    let delta: f64 = 1.0 / freq / 2.0;\n    let time_1s = linspace(0.0, 1.0, (freq / 2.0) as usize)\n        .map(|sample| { sample * delta});\n\n\n    let (sine_440,\n         sine_100,\n         summed_signal): (Vec&lt;f64&gt;, Vec&lt;f64&gt;, Vec&lt;f64&gt;) =\n        time_1s.map(|time_sample| {\n            let sample_440 = (freq * &amp;time_sample).sin();\n            let sample_100 = (100.0 * &amp;time_sample).sin();\n            let summed_sample = &amp;sample_440 + &amp;sample_100;\n\n            (sample_440, sample_100, summed_sample)\n        }).unzip();\n}\n</code></pre>\n\n<p>Like the closure indicates, the third signal is the sum of the previous two. What's baffling is the error I get:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0271]: type mismatch resolving `&lt;[closure@src/main.rs:17:21: 23:10 freq:_] as std::ops::FnOnce&lt;(f64,)&gt;&gt;::Output == (_, _)`\n  --&gt; src/main.rs:23:12\n   |\n23 |         }).unzip();\n   |            ^^^^^ expected a tuple with 3 elements, found one with 2 elements\n   |\n   = note: expected type `(f64, f64, f64)`\n   = note:    found type `(_, _)`\n   = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Map&lt;std::iter::Map&lt;itertools_num::Linspace&lt;f64&gt;, [closure@src/main.rs:11:14: 11:40 delta:_]&gt;, [closure@src/main.rs:17:21: 23:10 freq:_]&gt;`\n\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:17:9\n   |\n17 |         time_1s.map(|time_sample| {\n   |         ^ expected a tuple with 3 elements, found one with 2 elements\n   |\n   = note: expected type `(std::vec::Vec&lt;f64&gt;, std::vec::Vec&lt;f64&gt;, std::vec::Vec&lt;f64&gt;)`\n   = note:    found type `(_, _)`\n</code></pre>\n\n<p>I could understand a type error, but why should the third tuple item just be completely ignored?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1476169485, "post_id": 39969113, "comment_id": 67223069, "body": "It&#39;s a side point, but as described you have a module <code>iter_statistics::iter_statistics</code>, which probably isn&#39;t what you meant; no need for the <code>mod {}</code> inside the file named after it."}, {"owner": {"reputation": 397, "user_id": 992058, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/aef573436082d96d0e5a9a9335800e93?s=128&d=identicon&r=PG", "display_name": "michael60612", "link": "https://stackoverflow.com/users/992058/michael60612"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1476203455, "post_id": 39969113, "comment_id": 67242876, "body": "@ChrisEmerson Yup that was a redundancy from when I was formulating the sample code :)"}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476149806, "post_id": 39969216, "comment_id": 67217888, "body": "Related: <a href=\"http://stackoverflow.com/q/34438755/155423\">Why would I implement methods on a trait instead of as part of the trait?</a>"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 6, "last_activity_date": 1476149711, "creation_date": 1476149711, "answer_id": 39969216, "question_id": 39969113, "link": "https://stackoverflow.com/questions/39969113/no-method-found-when-extending-the-iterator-trait-in-rust/39969216#39969216", "title": "No method found when extending the Iterator trait in Rust", "body": "<p>The <code>impl</code> you have written will only apply to trait objects (e.g. <code>&amp;mut Iterator&lt;Item=f64&gt;</code>), not for all types that implement <code>Iterator&lt;Item=f64&gt;</code>. You want to write a generic <code>impl</code> like this:</p>\n\n<pre><code>impl&lt;T: Iterator&lt;Item=f64&gt;&gt; IterStatistics for T {}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 3, "last_activity_date": 1476168405, "creation_date": 1476168405, "answer_id": 39971746, "question_id": 39969113, "link": "https://stackoverflow.com/questions/39969113/no-method-found-when-extending-the-iterator-trait-in-rust/39971746#39971746", "title": "No method found when extending the Iterator trait in Rust", "body": "<p>Your implementation is backward. When programming in Rust, you have to forget about OO-inheritance and reason in terms of capabilities.</p>\n\n<blockquote>\n  <p>What does <code>trait D: B</code> means in Rust?</p>\n</blockquote>\n\n<p>This means that <code>D</code> can only be implemented for types that already implement <code>B</code>. It's not <em>inheritance</em>, it's a <em>constraint</em>.</p>\n\n<blockquote>\n  <p>When to use <code>trait D: B</code> then?</p>\n</blockquote>\n\n<p>The main reason to use this constraint is when you wish to provide a default implementation of <code>D</code> methods that will require associated items (traits, constants, methods) from <code>B</code>.</p>\n\n<p>In general, you do not want to add more constraints than strictly necessary, as your clients may wish to use this trait in ways you did not foresee.</p>\n\n<p>The one exception is when creating a trait as a \"bundle of constraints\", so that you do not have type <code>T: SomeTrait + SomeOtherTrait + Send</code> for all the methods your are implementing. This \"bundle of constraints\" should be empty, then; it's not a functional trait after all, just an \"alias\".</p>\n\n<blockquote>\n  <p>So, how to extend <code>Iterator</code>?</p>\n</blockquote>\n\n<p>First declare a new trait:</p>\n\n<pre><code>pub trait IterStatistics {\n    fn foo(&amp;mut self) -&gt; f64;\n}\n</code></pre>\n\n<p>Then implement it for all types already implementing <code>Iterator&lt;Item = f64&gt;</code>:</p>\n\n<pre><code>impl&lt;T&gt; IterStatistics for T\n    where T: Iterator&lt;Item = f64&gt;\n{\n    fn foo(&amp;mut self) -&gt; f64 {\n        0.0\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 397, "user_id": 992058, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/aef573436082d96d0e5a9a9335800e93?s=128&d=identicon&r=PG", "display_name": "michael60612", "link": "https://stackoverflow.com/users/992058/michael60612"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 577, "favorite_count": 0, "accepted_answer_id": 39969216, "answer_count": 2, "score": 0, "last_activity_date": 1476168405, "creation_date": 1476148797, "last_edit_date": 1476149870, "question_id": 39969113, "link": "https://stackoverflow.com/questions/39969113/no-method-found-when-extending-the-iterator-trait-in-rust", "title": "No method found when extending the Iterator trait in Rust", "body": "<p>I am trying to extend the functionality of the <code>Iterator</code> trait.</p>\n\n<p>My <code>statistics/iter_statistics.rs</code>:</p>\n\n<pre><code>mod iter_statistics {\n    pub trait IterStatistics: Iterator&lt;Item = f64&gt; {\n        fn foo(&amp;mut self) -&gt; f64 {\n            0.0\n        }\n    }\n\n    impl IterStatistics for Iterator&lt;Item = f64&gt; {}\n}\n</code></pre>\n\n<p>And <code>statistics/mod.rs</code>:</p>\n\n<pre><code>pub use self::iter_statistics::*;\nmod iter_statistics;\n</code></pre>\n\n<p>And finally in my test code I have</p>\n\n<pre><code>use statistics::IterStatistics;\n\nfn main() {\n    let z: Vec&lt;f64&gt; = vec![0.0, 3.0, -2.0];\n    assert_eq!(z.into_iter().foo(), 0.0);\n}\n</code></pre>\n\n<p>When I run the test, I get:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: no method name `foo` found for type `std::vec::IntoIter&lt;f64&gt;` in the current scope\nassert_eq!(z.into_iter().foo(), 0.0);\n                         ^~~\n</code></pre>\n\n<p>which is strange to me since the <a href=\"https://doc.rust-lang.org/std/vec/struct.IntoIter.html\" rel=\"nofollow\">docs</a> for <code>IntoIter&lt;T&gt;</code> say it implements <code>Iterator&lt;Item=T&gt;</code>.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1476112418, "post_id": 39960385, "comment_id": 67202563, "body": "@Shepmaster: Ah right. I usually put the tests in the same file, which bypasses this <code>pub</code> thing :) I do think though that once the <code>rle</code> module is located the rest should be more explicit. I wonder if the compiler could give hints as to how bringing <code>rle</code> into scope as the message for now is cryptic and does not hint at a solution at all."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476112549, "post_id": 39960385, "comment_id": 67202629, "body": "Yeah, the organization shown in the OP is a bit... non-traditional ^_^. That&#39;s why we are here though, to learn better ways!"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 5, "last_activity_date": 1476112469, "last_edit_date": 1476112469, "creation_date": 1476108964, "answer_id": 39960385, "question_id": 39959956, "link": "https://stackoverflow.com/questions/39959956/error-e0433-use-of-undeclared-type-or-module-when-accessing-a-module-from-a-te/39960385#39960385", "title": "Error E0433 - Use of undeclared type or module when accessing a module from a test", "body": "<p>You have an error in the use of <code>#[cfg(test)]</code>.</p>\n\n<p>Rust has two ways of applying attributes:</p>\n\n<ul>\n<li><code>#[...]</code> applies to the next item</li>\n<li><code>#![...]</code> applies to the enclosing item</li>\n</ul>\n\n<p>This means that here, <code>#[cfg(test)]</code> is applying to the next item (<code>mod rle;</code>) which will thus only be compiled in test mode. On the other hand, your <code>tests</code> module will always be compiled.</p>\n\n<p>As a result, when NOT running in test mode, you have:</p>\n\n<ul>\n<li>no <code>rle</code> module</li>\n<li>a <code>tests</code> module referring to a <code>rle</code> module</li>\n</ul>\n\n<p>The fix is simple: move the attribute so it applies to <code>mod tests</code>, not <code>mod rle</code>.</p>\n\n<hr>\n\n<p>Note:</p>\n\n<ul>\n<li>as mentioned by Chris, you ALSO need to use <code>super::rle</code> to refer to the <code>rle</code> module.</li>\n<li>as mentioned by ljedrz, you ALSO need to declare the fields of <code>Rle</code> public to be able to name them from outside the file (a problem you should not have if the tests are in the same file).</li>\n</ul>\n"}, {"comments": [{"owner": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "edited": false, "score": 0, "creation_date": 1476111058, "post_id": 39960397, "comment_id": 67201689, "body": "Why would anyone need <code>#![cfg(test)]</code> at top level of the crate?"}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "edited": false, "score": 0, "creation_date": 1476111750, "post_id": 39960397, "comment_id": 67202128, "body": "If they only wanted to run a test, like in this case :). But you&#39;re right, it&#39;s somewhat exotic. I&#39;ll amend my answer."}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 4, "last_activity_date": 1476112057, "last_edit_date": 1476112057, "creation_date": 1476108999, "answer_id": 39960397, "question_id": 39959956, "link": "https://stackoverflow.com/questions/39959956/error-e0433-use-of-undeclared-type-or-module-when-accessing-a-module-from-a-te/39960397#39960397", "title": "Error E0433 - Use of undeclared type or module when accessing a module from a test", "body": "<p>You first need to make <code>Rle</code> fields public to be able to access them:</p>\n\n<pre><code>pub struct Rle {\n    pub lengths: Vec&lt;i32&gt;,\n    pub values: Vec&lt;i32&gt;,\n}\n</code></pre>\n\n<p>And then, in the <code>lib.rs</code> file you should use it like so:</p>\n\n<pre><code>mod rle; // you probably don't want #[cfg(test)] to apply to rle\n\n#[cfg(test)] // this makes the tests module run only during cargo test\nmod tests {\n    use super::rle::Rle; // now Rle is applicable in the tests module\n\n    #[test]\n    fn it_works() {\n        let rle1 = Rle {\n            lengths: vec![1, 4, 2],\n            values: vec![1, 2, 1],\n        };\n    }\n\n}\n</code></pre>\n\n<p>Note that I changed <code>let rle1 = rle::Rle {</code> to <code>let rle1 = Rle {</code>, because I imported <code>super::rle::Rle</code> and not just <code>super::rle</code>.</p>\n\n<p>This compiles without issues.</p>\n"}], "owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4879, "favorite_count": 0, "accepted_answer_id": 39960385, "answer_count": 2, "score": 4, "last_activity_date": 1476112469, "creation_date": 1476107647, "last_edit_date": 1476109141, "question_id": 39959956, "link": "https://stackoverflow.com/questions/39959956/error-e0433-use-of-undeclared-type-or-module-when-accessing-a-module-from-a-te", "title": "Error E0433 - Use of undeclared type or module when accessing a module from a test", "body": "<p>As a first project in Rust, I'm trying to create a run length encoding library.</p>\n\n<p>This is my <code>src/lib.rs</code> (initially created by cargo):</p>\n\n<pre><code>#[cfg(test)]\n\nmod rle;\nmod tests {\n\n    #[test]\n\n    fn it_works() {\n        let rle1 = rle::Rle {\n            lengths: vec![1, 4, 2],\n            values: vec![1, 2, 1],\n        };\n    }\n\n}\n</code></pre>\n\n<p>This is my <code>src/rle.rs</code>:</p>\n\n<pre><code>pub struct Rle {\n    lengths: Vec&lt;i32&gt;,\n    values: Vec&lt;i32&gt;,\n}\n</code></pre>\n\n<p>Using this layout, I get an <code>error[E0433]: failed to resolve. Use of undeclared type or module 'rle'</code></p>\n\n<p>I have tried to follow the guidelines in the Rust Docs called <a href=\"https://doc.rust-lang.org/book/crates-and-modules.html\" rel=\"nofollow\">Crates and Modules</a>.</p>\n\n<p>What am I doing wrong?</p>\n\n<p>In case the layout was not obvious:</p>\n\n<pre><code>$ ls src\nlib.rs rle.rs\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1476097202, "post_id": 39955953, "comment_id": 67192972, "body": "I do not think your issue is linked to lifetimes. What rustc is telling you is that when instantiating the function <code>write_end</code> it got into an infinite loop in the recursive call. Is there a reason you use recursion and not iteration here?"}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 7, "last_activity_date": 1476098459, "creation_date": 1476098459, "answer_id": 39957092, "question_id": 39955953, "link": "https://stackoverflow.com/questions/39955953/rust-recursive-type-difficulty/39957092#39957092", "title": "Rust recursive type difficulty", "body": "<p>You have a ping-pong going on here, with no end in sight.</p>\n\n<ul>\n<li>call <code>TSW&lt;E&gt;::write_end&lt;W&gt;(&amp;mut self, w : &amp;mut W)</code></li>\n<li>which calls <code>MCW&lt;W, TSW&lt;E&gt;&gt;::write_end_all(&amp;mut self)</code></li>\n<li>which calls <code>TSW&lt;E&gt;::write_end&lt;MCW&lt;W, TCW&lt;E&gt;&gt;&gt;(&amp;mut self, w: &amp;mut )</code></li>\n<li>which calls ...</li>\n</ul>\n\n<p>Each new level of recursion piles on a new type there, which is why the type in the error message is so big. The rustc compiler, rather than entering in an infinite loop, is telling you that you probably don't want to instantiate an infinite number of functions.</p>\n\n<p>There's something wrong with your logic, here. And that's not lifetime.</p>\n\n<p>When starting a recursion, you need a plan for an exit strategy: it should end, predictably.</p>\n\n<p>In the particular case of a recursion in generic types, it should end, predictably, whatever the run-time values of the arguments.</p>\n\n<hr>\n\n<p>Not knowing what the correct logic should be, I present you an iterative solution:</p>\n\n<pre><code>fn write_end_all(&amp;mut self) {\n    for ew in self.1.iter_mut().rev() {\n        ew.write_end(self.0);\n        // do on current el.write_end();\n    }\n}\n</code></pre>\n\n<p>it is much simpler, does not cause an attempt to instantiate an infinite number of functions, and may not be the functionality you were looking for at all :)</p>\n"}], "owner": {"reputation": 238, "user_id": 4737839, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/38e2332cf448b64ced7498653324adcd?s=128&d=identicon&r=PG&f=1", "display_name": "cheme", "link": "https://stackoverflow.com/users/4737839/cheme"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 815, "favorite_count": 0, "accepted_answer_id": 39957092, "answer_count": 1, "score": 2, "last_activity_date": 1476104468, "creation_date": 1476094267, "last_edit_date": 1476104468, "question_id": 39955953, "link": "https://stackoverflow.com/questions/39955953/rust-recursive-type-difficulty", "title": "Rust recursive type difficulty", "body": "<p>This code is a simplification of more complex code to isolate the issue:</p>\n\n<pre><code>use std::marker::PhantomData;\n\npub trait ExtWrite {\n    fn write_end&lt;W&gt;(&amp;mut self, &amp;mut W);\n}\n\npub struct ST;\n\nimpl ExtWrite for ST {\n    fn write_end&lt;W&gt;(&amp;mut self, _: &amp;mut W) {}\n}\n\nstruct MCW&lt;'a, 'b, W: 'a, EW: 'b + ExtWrite&gt;(&amp;'a mut W, &amp;'b mut [EW]);\n\nimpl&lt;'a, 'b, W: 'a, EW: 'b + ExtWrite&gt; MCW&lt;'a, 'b, W, EW&gt; {\n    fn write_end_all(&amp;mut self) {\n        if let Some((f, last)) = self.1.split_first_mut() {\n            let mut el = MCW(self.0, last);\n            f.write_end(&amp;mut el);\n            // do on current el.write_end();\n        }\n    }\n}\n\npub fn rec_test() {\n    let mut buff = ();\n    let v: Vec&lt;TSW&lt;ST&gt;&gt; = Vec::new();\n    let mut el: TSW&lt;ST&gt; = TSW(Box::new(v), PhantomData);\n    el.write_end(&amp;mut buff);\n}\n\npub struct TSW&lt;E: ExtWrite&gt;(Box&lt;Vec&lt;TSW&lt;E&gt;&gt;&gt;, PhantomData&lt;E&gt;);\n\nimpl&lt;E: ExtWrite&gt; ExtWrite for TSW&lt;E&gt; {\n    fn write_end&lt;W&gt;(&amp;mut self, w: &amp;mut W) {\n        let mut el = MCW(w, &amp;mut self.0[..]);\n        el.write_end_all();\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>Leads to the following error: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: reached the recursion limit while instantiating `&lt;TSW&lt;E&gt; as ExtWrite&gt;&lt;ST&gt;::write_end::&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;MCW&lt;(), TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;, TSW&lt;ST&gt;&gt;&gt;`\n  --&gt; &lt;anon&gt;:40:3\n   |\n40 |   fn write_end&lt;W&gt;(&amp;mut self, w: &amp;mut W) {\n   |   ^\n</code></pre>\n\n<p>I am using Rust nightly (9c31d76e9 2016-10-03).</p>\n\n<p>The code is a struct containing a pointer to a <code>Vec</code> of an array of the same struct kind. Those imbricated arrays are called recursively to apply some writing in a writer (the <code>W</code> trait constraint was removed because it is not relevant for the issue), and in the real code the <code>ExtWrite</code> becomes <code>Writer</code> in some cases.</p>\n\n<p>There is some place where trait resolution goes funky leading to the recursion on type, the recursion seems fairly logical when considering monomorphism in the resolution of the <code>W</code> trait. <code>MCW</code>, depending on the depth of the recursion, will contain an infinite number of possible types, but this is really related to the usage of <code>MCW</code> (needed in original code), and the fact that <code>W</code> parameters of <code>read_end</code> functions are not linked to the struct definition but with the infinite possible variation of this function.</p>\n\n<p>Yet, in this snippet, <code>W</code> is always <code>()</code> and <code>MCW</code> should always be <code>MCW&lt;(),TSW&lt;ST&gt;&gt;</code>.</p>\n\n<p>A similar case that I encountered when looking for simplification:</p>\n\n<pre><code>struct IntSt&lt;'a, W: 'a&gt;(&amp;'a W);\n\npub fn comp_err() {\n    let w: u8 = 0;\n    rec(true, &amp;w);\n}\n\npub struct A(bool);\n\nfn rec&lt;W&gt;(b: bool, w: &amp;W) {\n    if (b) {\n        rec(false, &amp;IntSt(w).0);\n        //      rec(false, w)\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>Resulting in:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: reached the recursion limit while instantiating `rec::&lt;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;u8&gt;`\n  --&gt; &lt;anon&gt;:14:1\n   |\n14 | fn rec&lt;W&gt;(b: bool, w: &amp;W) {\n   | ^\n</code></pre>\n\n<p>It behaves correctly with this, but I do not really see how to make this kind of change in my previous case: </p>\n\n<pre><code>struct IntSt&lt;'a, W: 'a&gt;(&amp;'a W);\n\npub fn comp_err() {\n    let w: u8 = 0;\n    rec(true, &amp;w);\n}\n\npub struct A(bool);\n\nfn rec&lt;W&gt;(b: bool, w: &amp;W) {\n    if (b) {\n        rec(false, IntSt(w).0);\n        //      rec(false, w)\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>It looks like <code>MCW</code>, a light structure used as a temporary writer, leads to complication with its lifetime. This only happens with the recursive case. This seems really borderline and I do not know if its more a bug or a expected limitation. I also tried to use higher-ranked trait bounds but in this case we really work on structs and my few attempts were unsuccessful.</p>\n\n<p>I could simply redesign <code>TSW</code> (in my real case I only have optional pointer to a struct containing the <code>Vec</code> of <code>TSW</code> on one level) and introduce a <code>TSW_2</code> without a pointer to the <code>Vec</code>, but it would really feel bad (unsatisfying at least) as a solution.</p>\n\n<p>-- Edit</p>\n\n<p>Yes, thanks Matthieu, that's the right diagnostic (MCW misleaded me (when testing I removed it and all ran fine but it did not do the same thing) : </p>\n\n<pre><code>- TSW&lt;ST&gt;::write_end&lt;()&gt; (&amp;mut sel, w : &amp;mut ())\n- MCW&lt;(), TSW&lt;ST&gt;&gt;::write_end_all(&amp;mut self)\n- (f from slipt_first mut ) \n        TSW&lt;ST&gt;::write_end&lt;MCW&lt;(),TSW&lt;ST&gt;&gt;\n        MCW&lt;MCW&lt;(),TSW&lt;ST&gt;, &gt; ...\n</code></pre>\n\n<p>In fact when thinking about the original problem the type should exactly be \n...MCW&lt;MCW&lt;(),TSW, > imbricated N times, N being the size of the vector.\n(the elements in the vec are Writers extension which should apply over the previous elements of the Vec (kind of layered writer)).</p>\n\n<p>Retrospectively I remember first having this issue for chaining my W and then solving it by using a vec to store them (then I got single Type with iterative multiple layer of writing), but then I need to use this Vec to write some payload in previous Vec and here I should have use the same reasonning and a double array). But the way I did it was to simply try it with a fat pointer over an optional struct. That did not go smoothly because I did something like \"Option&lt;Box&lt;otherstructcontainingvec>>\"  but the other struct containing vec is no trait, and similarily in this sample code Vec is also no trait.</p>\n\n<p>So I hope I finally got my solution : use Vec&lt;TSW&lt;E>> (my struct containing it in real code) as a trait and have a real fat pointer (more optimized solution would be double dimension vec (but my use case is in fact a single imbrication).</p>\n"}, {"tags": ["iterator", "rust", "clone", "type-inference"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476103421, "post_id": 39951381, "comment_id": 67196590, "body": "The important error is the fact that the closure isn&#39;t clonable. <a href=\"http://stackoverflow.com/q/27883509/155423\">stackoverflow.com/q/27883509/155423</a>; <a href=\"http://stackoverflow.com/q/21933892/155423\">stackoverflow.com/q/21933892/155423</a>; <a href=\"http://stackoverflow.com/q/39803231/155423\">stackoverflow.com/q/39803231/155423</a>; <a href=\"http://stackoverflow.com/q/28011803/155423\">stackoverflow.com/q/28011803/155423</a>."}], "answers": [{"tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 3, "last_activity_date": 1476088779, "last_edit_date": 1476088779, "creation_date": 1476084381, "answer_id": 39953178, "question_id": 39951381, "link": "https://stackoverflow.com/questions/39951381/cloning-a-stditermap-with-inferred-type/39953178#39953178", "title": "Cloning a std::iter::Map with inferred (?) type", "body": "<p>My original answer caused 3 enumerations of the iterator. Ideally you were looking for 2 iterations.</p>\n\n<p>Since <code>map</code> consumes the iterator, it seems like the easier and more efficient way to do this without causing more iterations or clones than necessary is to just loop over it yourself only once:</p>\n\n<pre><code>let time_1s = linspace(0.0, 1.0, (freq / 2.0) as usize)\n    .map(|sample| { sample * delta});\n\nlet mut sine_100 = Vec::new();\nlet mut sine_440 = Vec::new();\n\nfor time_sample in time_1s {\n    sine_100.push((100.0 * time_sample).sin());\n    sine_440.push((freq * time_sample).sin());\n}\n\nprintln!(\"{:?}\", sine_100);\nprintln!(\"{:?}\", sine_440);\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1476089983, "post_id": 39954484, "comment_id": 67189032, "body": "This is nice, I hadn&#39;t considered <code>unzip</code> at all. I wonder what allocations happen with this set up? I imagine it does not make a very big impact at all but I am still curious - I am not well versed on the internals of Rust iterators/enumerables."}, {"owner": {"reputation": 5006, "user_id": 2023432, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/89ZPT.png?s=128&g=1", "display_name": "bright-star", "link": "https://stackoverflow.com/users/2023432/bright-star"}, "edited": false, "score": 0, "creation_date": 1476113026, "post_id": 39954484, "comment_id": 67202954, "body": "Accepting this answer because it has the functional formulation I was looking for. (Also it has more dots.)"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 7, "last_activity_date": 1476089215, "creation_date": 1476089215, "answer_id": 39954484, "question_id": 39951381, "link": "https://stackoverflow.com/questions/39951381/cloning-a-stditermap-with-inferred-type/39954484#39954484", "title": "Cloning a std::iter::Map with inferred (?) type", "body": "<p>One way to use <code>time_1s</code> twice is to do both together and unzip at the end:</p>\n\n<pre><code>extern crate itertools_num;\n\nuse itertools_num::linspace;\n\nfn main() {\n    // 440Hz as wave frequency (middle A)\n    let freq: f64 = 440.0;\n    // Time vector sampled at 880 times/s (~Nyquist), over 1s\n    let delta: f64 = 1.0 / freq / 2.0;\n    let time_1s = linspace(0.0, 1.0, (freq / 2.0) as usize)\n            .map(|sample| { sample * delta});\n\n    let (sine_440, sine_100): (Vec&lt;f64&gt;, Vec&lt;f64&gt;) = time_1s.map(|time_sample| {\n        ((freq * time_sample).sin(),\n         (100.0 * time_sample).sin())\n    }).unzip();\n}\n</code></pre>\n"}], "owner": {"reputation": 5006, "user_id": 2023432, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/89ZPT.png?s=128&g=1", "display_name": "bright-star", "link": "https://stackoverflow.com/users/2023432/bright-star"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 115, "favorite_count": 0, "accepted_answer_id": 39954484, "answer_count": 2, "score": 3, "last_activity_date": 1476089215, "creation_date": 1476074348, "last_edit_date": 1476074856, "question_id": 39951381, "link": "https://stackoverflow.com/questions/39951381/cloning-a-stditermap-with-inferred-type", "title": "Cloning a std::iter::Map with inferred (?) type", "body": "<p>I'm having trouble cloning a Map in a compact way:</p>\n\n<pre><code>extern crate itertools_num;\n\nuse itertools_num::linspace;\n\nfn main() {\n    // 440Hz as wave frequency (middle A)\n    let freq: f64 = 440.0;\n    // Time vector sampled at 880 times/s (~Nyquist), over 1s\n    let delta: f64 = 1.0 / freq / 2.0;\n    let time_1s = linspace(0.0, 1.0, (freq / 2.0) as usize)\n        .map(|sample| { sample * delta});\n\n    let sine_440: Vec&lt;f64&gt; = time_1s.map(|time_sample| {\n        (freq * time_sample).sin()\n    }).collect();\n\n    let sine_100: Vec&lt;f64&gt; = time_1s.map(|time_sample| {\n        (100.0 * time_sample).sin()\n    }).collect();\n}\n</code></pre>\n\n<p>The error I get with this code is </p>\n\n<pre><code>`time_1s` moved here because it has type `std::iter::Map&lt;itertools_num::Linspace&lt;f64&gt;, [closure@examples/linear_dft.rs:12:14: 12:40 delta:&amp;f64]&gt;`, which is non-copyable\n</code></pre>\n\n<p>which is understandable, but if I try to use <code>time_1s.clone()</code> instead, I get</p>\n\n<pre><code>note: the method `clone` exists but the following trait bounds were not satisfied: `[closure@examples/linear_dft.rs:12:14: 12:40 delta:_] : std::clone::Clone`\nerror: the type of this value must be known in this context\n     (freq * time_sample).sin()\n</code></pre>\n\n<p>which is also understandable, but storing <code>(freq * time_sample).sin()</code> in a <code>let foo: f64</code> inside the closure before returning it doesn't have any effect.</p>\n\n<p>What am I supposed to do in a situation like this? All I wanted to do was use the time vector more than once.</p>\n"}, {"tags": ["rust", "min-heap"], "comments": [{"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1476061680, "post_id": 39949939, "comment_id": 67180486, "body": "Please show how do you insert and pop from the BinaryHeap&lt;MinNonNan&gt;."}, {"owner": {"reputation": 2199, "user_id": 1542038, "user_type": "registered", "accept_rate": 63, "profile_image": "https://i.stack.imgur.com/sq0X6.png?s=128&g=1", "display_name": "maxcountryman", "link": "https://stackoverflow.com/users/1542038/maxcountryman"}, "reply_to_user": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1476061825, "post_id": 39949939, "comment_id": 67180523, "body": "@kennytm <code>minheap.push(MinNonNan(42.0))</code> and <code>if let Some(MinNonNan(root)) = minheap.pop() ...</code>"}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 1, "creation_date": 1476062077, "post_id": 39949939, "comment_id": 67180570, "body": "On a hunch, I&#39;d try implementing <code>PartialOrd</code> to agree with <code>Ord</code>. They aren&#39;t really meant to contradict each other -- the compiler may make optimizations based on the assumption that they are effectively the same."}], "answers": [{"comments": [{"owner": {"reputation": 2199, "user_id": 1542038, "user_type": "registered", "accept_rate": 63, "profile_image": "https://i.stack.imgur.com/sq0X6.png?s=128&g=1", "display_name": "maxcountryman", "link": "https://stackoverflow.com/users/1542038/maxcountryman"}, "edited": false, "score": 1, "creation_date": 1476112819, "post_id": 39950148, "comment_id": 67202827, "body": "It&#39;s worth pointing out that this is for a small script and I do not want to use external libs if it can be avoided. However thank you for pointing out those crates!"}, {"owner": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "reply_to_user": {"reputation": 2199, "user_id": 1542038, "user_type": "registered", "accept_rate": 63, "profile_image": "https://i.stack.imgur.com/sq0X6.png?s=128&g=1", "display_name": "maxcountryman", "link": "https://stackoverflow.com/users/1542038/maxcountryman"}, "edited": false, "score": 0, "creation_date": 1525186213, "post_id": 39950148, "comment_id": 87254555, "body": "@maxcountryman Rust is done to easily use extern crates, just like in javascript for example."}], "tags": [], "owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "is_accepted": true, "score": 11, "last_activity_date": 1544676015, "last_edit_date": 1544676015, "creation_date": 1476062219, "answer_id": 39950148, "question_id": 39949939, "link": "https://stackoverflow.com/questions/39949939/how-can-i-implement-a-min-heap-of-f64-with-rusts-binaryheap/39950148#39950148", "title": "How can I implement a min-heap of f64 with Rust&#39;s BinaryHeap?", "body": "<p>Instead of writing your own <code>MinNonNan</code>, consider using the <a href=\"https://docs.rs/ordered-float/1.0.1/ordered_float/struct.NotNan.html\" rel=\"nofollow noreferrer\">ordered-float</a> crate + the <a href=\"https://doc.rust-lang.org/std/cmp/struct.Reverse.html\" rel=\"nofollow noreferrer\">std::cmp::Reverse</a> type.</p>\n\n<pre><code>type MinNonNan = Reverse&lt;NotNan&lt;f64&gt;&gt;;\n</code></pre>\n\n<hr>\n\n<p>Since you are <code>#[derive]</code>ing <code>PartialOrd</code>, the <code>.gt()</code>, <code>.lt()</code> etc methods still compare normally, i.e. <code>MinNonNan(42.0) &lt; MinNonNan(47.0)</code> is still true. The <code>Ord</code> bound only restricts you to provide strictly-ordered types, it doesn't mean the implementation will use <code>.cmp()</code> instead of <code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code> everywhere, nor the compiler will suddenly change those operators to use the <code>Ord</code> implementation.</p>\n\n<p>If you want to flip the order, you need to reimplement <code>PartialOrd</code> as well.</p>\n\n<pre><code>#[derive(PartialEq)]\nstruct MinNonNan(f64);\n\nimpl PartialOrd for MinNonNan {\n    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {\n        other.0.partial_cmp(&amp;self.0)\n    }\n}\n\nimpl Ord for MinNonNan {\n    fn cmp(&amp;self, other: &amp;MinNonNan) -&gt; Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 7544, "user_id": 2750743, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/sJOzq.png?s=128&g=1", "display_name": "Klesun", "link": "https://stackoverflow.com/users/2750743/klesun"}, "edited": false, "score": 0, "creation_date": 1618669906, "post_id": 39985950, "comment_id": 118674852, "body": "Is it just me, or does this solution ignore decimal part during comparison?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 7544, "user_id": 2750743, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/sJOzq.png?s=128&g=1", "display_name": "Klesun", "link": "https://stackoverflow.com/users/2750743/klesun"}, "edited": false, "score": 1, "creation_date": 1619113148, "post_id": 39985950, "comment_id": 118813158, "body": "@Klesun <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4cd979ce0abca6b970fe1608d9cce88a\" rel=\"nofollow noreferrer\">just you</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 7, "last_activity_date": 1546299222, "last_edit_date": 1546299222, "creation_date": 1476216879, "answer_id": 39985950, "question_id": 39949939, "link": "https://stackoverflow.com/questions/39949939/how-can-i-implement-a-min-heap-of-f64-with-rusts-binaryheap/39985950#39985950", "title": "How can I implement a min-heap of f64 with Rust&#39;s BinaryHeap?", "body": "<h2>Working Example</h2>\n\n<pre><code>use std::cmp::Ordering;\nuse std::collections::BinaryHeap;\n\n#[derive(PartialEq)]\nstruct MinFloat(f64);\n\nimpl Eq for MinFloat {}\n\nimpl PartialOrd for MinFloat {\n    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {\n        other.0.partial_cmp(&amp;self.0)\n    }\n}\n\nimpl Ord for MinFloat {\n    fn cmp(&amp;self, other: &amp;MinFloat) -&gt; Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nfn main() {\n    let mut minheap = BinaryHeap::new();\n    minheap.push(MinFloat(2.0));\n    minheap.push(MinFloat(1.0));\n    minheap.push(MinFloat(42.0));\n    if let Some(MinFloat(root)) = minheap.pop() {\n        println!(\"{:?}\", root);\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 2199, "user_id": 1542038, "user_type": "registered", "accept_rate": 63, "profile_image": "https://i.stack.imgur.com/sq0X6.png?s=128&g=1", "display_name": "maxcountryman", "link": "https://stackoverflow.com/users/1542038/maxcountryman"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3710, "favorite_count": 4, "accepted_answer_id": 39950148, "answer_count": 2, "score": 14, "last_activity_date": 1546299222, "creation_date": 1476059930, "last_edit_date": 1526947162, "question_id": 39949939, "link": "https://stackoverflow.com/questions/39949939/how-can-i-implement-a-min-heap-of-f64-with-rusts-binaryheap", "title": "How can I implement a min-heap of f64 with Rust&#39;s BinaryHeap?", "body": "<p>I want to populate a binary heap with floats--more specifically, I'd like to implement a min-heap.</p>\n\n<p>It seems that floats do not support <code>Ord</code> and thus aren't usable out of the box. My attempts to wrap them have so far failed. However it seems that if I could wrap them then I could also implement <code>Ord</code> in such a way that it would effectively make <code>BinaryHeap</code> a min-heap.</p>\n\n<p>Here's an example of a wrapper I tried:</p>\n\n<pre><code>#[derive(PartialEq, PartialOrd)]\nstruct MinNonNan(f64);\n\nimpl Eq for MinNonNan {}\n\nimpl Ord for MinNonNan {\n    fn cmp(&amp;self, other: &amp;MinNonNan) -&gt; Ordering {\n        let ord = self.partial_cmp(other).unwrap();\n        match ord {\n            Ordering::Greater =&gt; Ordering::Less,\n            Ordering::Less =&gt; Ordering::Greater,\n            Ordering::Equal =&gt; ord\n        }\n    }\n}\n</code></pre>\n\n<p>The problem is <code>pop</code> returns the values as though it were a max-heap.</p>\n\n<p>What exactly do I need to do to populate a <code>BinaryHeap</code> with <code>f64</code> values as a min-heap?</p>\n"}, {"tags": ["c", "node.js", "asynchronous", "rust", "node-ffi"], "answers": [{"comments": [{"owner": {"reputation": 186, "user_id": 472486, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/c5e99d5ecfaab30b92d9a7cdb34e0e33?s=128&d=identicon&r=PG", "display_name": "Zac", "link": "https://stackoverflow.com/users/472486/zac"}, "edited": false, "score": 0, "creation_date": 1476093390, "post_id": 39954962, "comment_id": 67190937, "body": "Thank you! I guess I should note that I am the author of this upstream <code>comm</code> library. It looks like using <code>std::mem::forget(string)</code> before returning the <code>const *char</code> pointing to it does indeed solve the problem."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 186, "user_id": 472486, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/c5e99d5ecfaab30b92d9a7cdb34e0e33?s=128&d=identicon&r=PG", "display_name": "Zac", "link": "https://stackoverflow.com/users/472486/zac"}, "edited": false, "score": 2, "creation_date": 1476096911, "post_id": 39954962, "comment_id": 67192814, "body": "@Zac: You&#39;re welcome :) I would note that normally you should leak the <code>CString</code> instance, not <code>string</code>. You might want to run your Rust tests under valgrind to spot those issues ahead of time."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1476100843, "post_id": 39954962, "comment_id": 67194970, "body": "See also <a href=\"http://jakegoulding.com/rust-ffi-omnibus/string_return/\" rel=\"nofollow noreferrer\">returning strings in the Rust FFI Omnibus</a>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476104289, "post_id": 39954962, "comment_id": 67197212, "body": "So, what do you think is the reason that introducing a thread allowed it to &quot;work&quot;?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1476104610, "post_id": 39954962, "comment_id": 67197433, "body": "@Shepmaster: Well, UB and all... but if I would have to take a shot I would bet on thread-local arenas. Freshly freed memory is hot in the cache, so it&#39;s the best memory to use for an allocation. In the synchronous case, it means re-using it immediately (corrupting it), whereas in the asynchronous case, if all the work is done on another thread, it&#39;ll be using another thread-local arena to allocate from which gives the freshly freed memory a bit more time."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 3, "last_activity_date": 1476090896, "creation_date": 1476090896, "answer_id": 39954962, "question_id": 39949389, "link": "https://stackoverflow.com/questions/39949389/node-ffi-wrapper-function-fails-when-used-synchronously-but-works-asynchronousl/39954962#39954962", "title": "Node FFI wrapper function fails when used synchronously, but works asynchronously", "body": "<p>The problem, I am afraid, comes from the <code>comm</code> library, and specifically the <a href=\"https://github.com/zacstewart/comm/blob/master/c_api/src/comm.rs#L45\" rel=\"nofollow\"><code>comm_address_to_str</code></a> function:</p>\n\n<pre><code>#[no_mangle]\npub extern \"C\" fn comm_address_to_str(address: *const Address) -&gt; *const c_char {\n    let string = unsafe { *address }.to_str();\n    CString::new(string).unwrap().as_ptr()\n}\n</code></pre>\n\n<p>The <a href=\"https://doc.rust-lang.org/std/ffi/struct.CString.html#method.as_ptr\" rel=\"nofollow\">documentation of <code>CString::as_ptr</code></a> specifically calls out this pattern:</p>\n\n<pre><code>use std::ffi::{CString};\n\nlet ptr = CString::new(\"Hello\").unwrap().as_ptr();\nunsafe {\n    // `ptr` is dangling\n    *ptr;\n}\n</code></pre>\n\n<p>The <code>CString</code> created on the last line is immediately destructed after taking a pointer into its internals, leading to a dangling pointer.</p>\n\n<p>The <code>comm</code> library that you are using will need to be fixed, and it might be worth auditing the other functions as well.</p>\n\n<p>The fix here would be to leak the <code>CString</code>, and then provide another function to be called with the leaked pointer which will take care of freeing it.</p>\n"}], "owner": {"reputation": 186, "user_id": 472486, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/c5e99d5ecfaab30b92d9a7cdb34e0e33?s=128&d=identicon&r=PG", "display_name": "Zac", "link": "https://stackoverflow.com/users/472486/zac"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 189, "favorite_count": 0, "accepted_answer_id": 39954962, "answer_count": 1, "score": 1, "last_activity_date": 1476090896, "creation_date": 1476054098, "last_edit_date": 1476090893, "question_id": 39949389, "link": "https://stackoverflow.com/questions/39949389/node-ffi-wrapper-function-fails-when-used-synchronously-but-works-asynchronousl", "title": "Node FFI wrapper function fails when used synchronously, but works asynchronously", "body": "<p>I'm trying to wrap a Rust library (that exposes a C API) with Node FFI. I have the following code wrapping two functions. One is a \"constructor\" that returns a pointer. The other takes a pointer and returns C string.</p>\n\n<pre><code>var libcomm = ffi.Library('lib/c_api/target/debug/libcomm', {\n  'comm_address_for_content': ['pointer', ['string']],\n  'comm_address_to_str': ['string', ['pointer']]\n});\n</code></pre>\n\n<p>When I use the asynchronous invocation of <code>comm_address_to_str</code> the response is correct. However, when I try to call the function using the synchronous style, it returns garbage, or very very rarely, the correct result. The following nodeunit test exercises the scenario:</p>\n\n<pre><code>const comm = require(\"../\").libcomm;\n\nexports.testAddressForContent = function (test) {\n  const ptr = comm.comm_address_for_content('test');\n\n  const result = comm.comm_address_to_str(ptr);\n  test.equal(result, 'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3'); // always fails\n  console.log('sync', result); // random garbage\n\n  comm.comm_address_to_str.async(ptr, function(err, result) {\n    test.equal(result, 'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3'); // always passes\n    console.log('async', result); // 'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3'\n    test.done();\n  });\n}\n</code></pre>\n\n<p>I can't figure out what causes this, but I need to be able to use the sync invocation style. The C API of the Rust library I am wrapping is <a href=\"https://github.com/zacstewart/comm/blob/master/c_api/src/comm.rs\" rel=\"nofollow\">here</a>.</p>\n"}, {"tags": ["rust", "lifetime", "borrow-checker"], "comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1476034357, "post_id": 39946430, "comment_id": 67173136, "body": "\u201cno reference to <code>line</code> can be kept, right?\u201d \u2192 right. But how does the borrowck knows that?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1476034503, "post_id": 39946430, "comment_id": 67173176, "body": "I would note that <code>line</code> is an allocated <code>String</code>: each iteration would <i>still</i> requires a fresh memory allocation even if the <code>Vec</code> caching worked."}, {"owner": {"reputation": 10115, "user_id": 695591, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/9f1ad3bbb9e54c249c7a3bccd72951a7?s=128&d=identicon&r=PG", "display_name": "Cl&#233;ment", "link": "https://stackoverflow.com/users/695591/cl%c3%a9ment"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1476034643, "post_id": 39946430, "comment_id": 67173221, "body": "@mcarton: Exactly: that&#39;s why I&#39;m asking how I can tell the borrow checker about it :)"}, {"owner": {"reputation": 10115, "user_id": 695591, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/9f1ad3bbb9e54c249c7a3bccd72951a7?s=128&d=identicon&r=PG", "display_name": "Cl&#233;ment", "link": "https://stackoverflow.com/users/695591/cl%c3%a9ment"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1476034707, "post_id": 39946430, "comment_id": 67173247, "body": "@MatthieuM. I&#39;d be curious to know a way to reuse that string&#39;s memory as well :) But it might be better as a separate question."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 3, "creation_date": 1476035749, "post_id": 39946430, "comment_id": 67173596, "body": "@Cl&#233;ment to avoid reallocating <code>line</code> every time, you should use <code>read_line</code> instead of <code>lines</code>"}, {"owner": {"reputation": 10115, "user_id": 695591, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/9f1ad3bbb9e54c249c7a3bccd72951a7?s=128&d=identicon&r=PG", "display_name": "Cl&#233;ment", "link": "https://stackoverflow.com/users/695591/cl%c3%a9ment"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1476035942, "post_id": 39946430, "comment_id": 67173669, "body": "@mcarton Ooh, great idea :) Thanks!"}, {"owner": {"reputation": 10115, "user_id": 695591, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/9f1ad3bbb9e54c249c7a3bccd72951a7?s=128&d=identicon&r=PG", "display_name": "Cl&#233;ment", "link": "https://stackoverflow.com/users/695591/cl%c3%a9ment"}, "edited": false, "score": 0, "creation_date": 1476037295, "post_id": 39946430, "comment_id": 67174181, "body": "Although interestingly, using read_line is measurably slower.  I wonder why."}], "answers": [{"comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1476054528, "post_id": 39946610, "comment_id": 67179117, "body": "This should have a safe abstraction I think, but I can&#39;t think of any existing one. For example <a href=\"https://github.com/frankmcsherry/recycler/issues/3#issue-74243434\" rel=\"nofollow noreferrer\">recycler</a> probably has the same lifetime restriction."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 10, "last_activity_date": 1476035136, "creation_date": 1476035136, "answer_id": 39946610, "question_id": 39946430, "link": "https://stackoverflow.com/questions/39946430/borrow-checker-doesnt-realize-that-clear-drops-reference-to-local-variable/39946610#39946610", "title": "Borrow checker doesn&#39;t realize that `clear` drops reference to local variable", "body": "<p>The only way to do this is to use <a href=\"https://doc.rust-lang.org/stable/std/mem/fn.transmute.html\" rel=\"noreferrer\"><code>transmute</code></a> to change the <code>Vec&lt;&amp;'a str&gt;</code> into a <code>Vec&lt;&amp;'b str&gt;</code>. <code>transmute</code> is unsafe and Rust will not raise an error if you forget the call to <code>clear</code> here. You might want to extend the <code>unsafe</code> block up to after the call to <code>clear</code> to make it clear (no pun intended) where the code returns to \"safe land\".</p>\n\n<pre><code>use std::io::BufRead;\nuse std::mem;\n\nfn main() {\n    let stdin = std::io::stdin();\n    let mut cache = Vec::&lt;&amp;str&gt;::new();\n    for line in stdin.lock().lines().map(|x| x.unwrap()) {\n        let cache: &amp;mut Vec&lt;&amp;str&gt; = unsafe { mem::transmute(&amp;mut cache) };\n        cache.extend(line.split(' '));\n        println!(\"{}\", cache.join(\",\"));\n        cache.clear();\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "is_accepted": false, "score": 9, "last_activity_date": 1476195849, "last_edit_date": 1476195849, "creation_date": 1476037754, "answer_id": 39947064, "question_id": 39946430, "link": "https://stackoverflow.com/questions/39946430/borrow-checker-doesnt-realize-that-clear-drops-reference-to-local-variable/39947064#39947064", "title": "Borrow checker doesn&#39;t realize that `clear` drops reference to local variable", "body": "<p>In this case Rust doesn't know what you're trying to do. Unfortunately, <code>.clear()</code> does not affect how <code>.extend()</code> is checked. </p>\n\n<p>The <code>cache</code> is a \"vector of strings that live as long as the main function\", but in <code>extend()</code> calls you're appending \"strings that live only as long as one loop iteration\", so that's a type mismatch. The call to <code>.clear()</code> doesn't change the types.</p>\n\n<p>Usually such limited-time uses are expressed by making a long-lived opaque object that enables access to its memory by borrowing a temporary object with the right lifetime, like <code>RefCell.borrow()</code> gives a temporary <code>Ref</code> object. Implementation of that would be a bit involved and would require unsafe methods for recycling <code>Vec</code>'s internal memory.</p>\n\n<p>In this case an alternative solution could be to avoid any allocations at all (<code>.join()</code> allocates too) and stream the printing thanks to <code>Peekable</code> iterator wrapper:</p>\n\n<pre><code>for line in stdin.lock().lines().map(|x| x.unwrap()) {\n    let mut fields = line.split(' ').peekable();\n    while let Some(field) = fields.next() {\n        print!(\"{}\", field);\n        if fields.peek().is_some() {\n            print!(\",\");\n        }\n    }\n    print!(\"\\n\");\n}\n</code></pre>\n\n<p>BTW: Francis' answer with <code>transmute</code> is good too. You can use <code>unsafe</code> to say you know what you're doing and override the lifetime check.</p>\n"}, {"tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": false, "score": 5, "last_activity_date": 1587498722, "last_edit_date": 1587498722, "creation_date": 1476054288, "answer_id": 39949409, "question_id": 39946430, "link": "https://stackoverflow.com/questions/39946430/borrow-checker-doesnt-realize-that-clear-drops-reference-to-local-variable/39949409#39949409", "title": "Borrow checker doesn&#39;t realize that `clear` drops reference to local variable", "body": "<p>Itertools has <a href=\"https://docs.rs/itertools/0.5.2/itertools/trait.Itertools.html#method.format\" rel=\"nofollow noreferrer\"><code>.format()</code></a> for the purpose of lazy formatting, which skips allocating a string too.</p>\n\n<pre><code>use std::io::BufRead;\nuse itertools::Itertools;\n\nfn main() {\n    let stdin = std::io::stdin();\n    for line in stdin.lock().lines().map(|x| x.unwrap()) {\n        println!(\"{}\", line.split(' ').format(\",\"));\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>A digression, something like this is a \u201csafe abstraction\u201d in the littlest sense of the solution in another answer here:</p>\n\n<pre><code>fn repurpose&lt;'a, T: ?Sized&gt;(mut v: Vec&lt;&amp;T&gt;) -&gt; Vec&lt;&amp;'a T&gt; {\n    v.clear();\n    unsafe {\n        transmute(v)\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 1267, "user_id": 473359, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/uDUQE.jpg?s=128&g=1", "display_name": "Mykola Bogdiuk", "link": "https://stackoverflow.com/users/473359/mykola-bogdiuk"}, "is_accepted": false, "score": -1, "last_activity_date": 1582926782, "creation_date": 1582926782, "answer_id": 60459730, "question_id": 39946430, "link": "https://stackoverflow.com/questions/39946430/borrow-checker-doesnt-realize-that-clear-drops-reference-to-local-variable/60459730#60459730", "title": "Borrow checker doesn&#39;t realize that `clear` drops reference to local variable", "body": "<p>The safe solution is to use <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.drain\" rel=\"nofollow noreferrer\"><code>.drain(..)</code></a> instead of <code>.clear()</code> where <code>..</code> is a \"full range\". It returns an iterator, so drained elements can be processed in a loop. It is also available for other collections (<code>String</code>, <code>HashMap</code>, etc.)</p>\n\n<pre><code>fn main() {\n    let mut cache = Vec::&lt;&amp;str&gt;::new();\n    for line in [\"first line allocates for\", \"second\"].iter() {\n        println!(\"Size and capacity: {}/{}\", cache.len(), cache.capacity());\n        cache.extend(line.split(' '));\n        println!(\"    {}\", cache.join(\",\"));\n        cache.drain(..);\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 126, "user_id": 2244348, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5916af78e93bafb71823f03c3605e62e?s=128&d=identicon&r=PG", "display_name": "ErikWeitenberg", "link": "https://stackoverflow.com/users/2244348/erikweitenberg"}, "is_accepted": false, "score": 2, "last_activity_date": 1587492073, "creation_date": 1587492073, "answer_id": 61350062, "question_id": 39946430, "link": "https://stackoverflow.com/questions/39946430/borrow-checker-doesnt-realize-that-clear-drops-reference-to-local-variable/61350062#61350062", "title": "Borrow checker doesn&#39;t realize that `clear` drops reference to local variable", "body": "<p>Another approach is to refrain from storing references altogether, and to store indices instead. This trick can also be useful in other data structure contexts, so this might be a nice opportunity to try it out.</p>\n\n<pre><code>use std::io::BufRead;\n\nfn main() {\n    let stdin = std::io::stdin();\n    let mut cache = Vec::new();\n    for line in stdin.lock().lines().map(|x| x.unwrap()) {\n        cache.push(0);\n        cache.extend(line.match_indices(' ').map(|x| x.0 + 1));\n        // cache now contains the indices where new words start\n\n        // do something with this information\n        for i in 0..(cache.len() - 1) {\n            print!(\"{},\", &amp;line[cache[i]..(cache[i + 1] - 1)]);\n        }\n        println!(\"{}\", &amp;line[*cache.last().unwrap()..]);\n        cache.clear();\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>Though you made the remark yourself in the question, I feel the need to point out that there are more elegant methods to do this using iterators, that might avoid the allocation of a vector altogether.</p>\n\n<p>The approach above was inspired by a <a href=\"https://stackoverflow.com/questions/61339014/how-to-tell-the-borrow-checker-that-a-cleared-vec-contains-no-borrows\">similar question here</a>, and becomes more useful if you need to do something more complicated than printing.</p>\n"}, {"tags": [], "owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "is_accepted": false, "score": 0, "last_activity_date": 1587550887, "creation_date": 1587550887, "answer_id": 61362695, "question_id": 39946430, "link": "https://stackoverflow.com/questions/39946430/borrow-checker-doesnt-realize-that-clear-drops-reference-to-local-variable/61362695#61362695", "title": "Borrow checker doesn&#39;t realize that `clear` drops reference to local variable", "body": "<p>Elaborating on Francis's answer about using <code>transmute()</code>, this could be safely abstracted, I think, with this simple function:</p>\n\n<pre><code>pub fn zombie_vec&lt;'a, 'b, T: ?Sized&gt;(mut data: Vec&lt;&amp;'a T&gt;) -&gt; Vec&lt;&amp;'b T&gt; {\n    data.clear();\n    unsafe {\n        std::mem::transmute(data)\n    }\n}\n</code></pre>\n\n<p>Using this, the original code would be:</p>\n\n<pre><code>fn main() {\n    let stdin = std::io::stdin();\n    let mut cache0 = Vec::&lt;&amp;str&gt;::new();\n    for line in stdin.lock().lines().map(|x| x.unwrap()) {\n        let mut cache = cache0; // into the loop\n        cache.extend(line.split(' '));\n        println!(\"{}\", cache.join(\",\"));\n        cache0 = zombie_vec(cache); // out of the loop\n    }\n}\n</code></pre>\n\n<p>You need to move the outer vector into every loop iteration, and restore it back to before you finish, while safely erasing the local lifetime.</p>\n"}], "owner": {"reputation": 10115, "user_id": 695591, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/9f1ad3bbb9e54c249c7a3bccd72951a7?s=128&d=identicon&r=PG", "display_name": "Cl&#233;ment", "link": "https://stackoverflow.com/users/695591/cl%c3%a9ment"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 749, "favorite_count": 2, "accepted_answer_id": 39946610, "answer_count": 6, "score": 16, "last_activity_date": 1587550887, "creation_date": 1476034049, "last_edit_date": 1476054737, "question_id": 39946430, "link": "https://stackoverflow.com/questions/39946430/borrow-checker-doesnt-realize-that-clear-drops-reference-to-local-variable", "title": "Borrow checker doesn&#39;t realize that `clear` drops reference to local variable", "body": "<p>The following code reads space-delimited records from stdin, and writes comma-delimited records to stdout.  Even with optimized builds it's rather slow (about twice as slow as using, say, awk).</p>\n\n<pre><code>use std::io::BufRead;\n\nfn main() {\n    let stdin = std::io::stdin();\n    for line in stdin.lock().lines().map(|x| x.unwrap()) {\n        let fields: Vec&lt;_&gt; = line.split(' ').collect();\n        println!(\"{}\", fields.join(\",\"));\n    }\n}\n</code></pre>\n\n<p>One obvious improvement would be to use <code>itertools</code> to join without allocating a vector (the <code>collect</code> call causes an allocation).  However, I tried a different approach:</p>\n\n<pre><code>fn main() {\n    let stdin = std::io::stdin();\n    let mut cache = Vec::&lt;&amp;str&gt;::new();\n    for line in stdin.lock().lines().map(|x| x.unwrap()) {\n        cache.extend(line.split(' '));\n        println!(\"{}\", cache.join(\",\"));\n        cache.clear();\n    }\n}\n</code></pre>\n\n<p>This version tries to reuse the same vector over and over.  Unfortunately, the compiler complains:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `line` does not live long enough\n --&gt; src/main.rs:7:22\n  |\n7 |         cache.extend(line.split(' '));\n  |                      ^^^^\n  |\nnote: reference must be valid for the block suffix following statement 1 at 5:39...\n --&gt; src/main.rs:5:40\n  |\n5 |     let mut cache = Vec::&lt;&amp;str&gt;::new();\n  |                                        ^\nnote: ...but borrowed value is only valid for the for at 6:4\n --&gt; src/main.rs:6:5\n  |\n6 |     for line in stdin.lock().lines().map(|x| x.unwrap()) {\n  |     ^\n\nerror: aborting due to previous error\n</code></pre>\n\n<p>Which of course makes sense: the <code>line</code> variable is only alive in the body of the <code>for</code> loop, whereas <code>cache</code> keeps a pointer into it across iterations.  But that error still looks spurious to me: since the cache is <code>clear</code>ed after each iteration, no reference to <code>line</code> can be kept, right?</p>\n\n<p>How can I tell the borrow checker about this?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1476033465, "post_id": 39945901, "comment_id": 67172813, "body": "Possible duplicate of <a href=\"http://stackoverflow.com/questions/38396104/macro-undefined-when-reading-u8-using-scan\">&quot;macro undefined&quot; when reading u8 using scan!()</a>"}], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 2, "last_activity_date": 1476030986, "creation_date": 1476030986, "answer_id": 39945929, "question_id": 39945901, "link": "https://stackoverflow.com/questions/39945901/how-do-i-use-a-macro-defined-in-another-crate/39945929#39945929", "title": "How do I use a macro defined in another crate?", "body": "<p>You must add the <a href=\"https://doc.rust-lang.org/reference.html#macro-related-attributes\" rel=\"nofollow\"><code>#[macro_use]</code></a> attribute on the <code>extern crate</code> declaration to ask the compiler to bring the macros exported by the crate into your crate's namespace.</p>\n\n<pre><code>#[macro_use]\nextern crate cpython;\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": true, "score": 4, "last_activity_date": 1476031010, "creation_date": 1476031010, "answer_id": 39945932, "question_id": 39945901, "link": "https://stackoverflow.com/questions/39945901/how-do-i-use-a-macro-defined-in-another-crate/39945932#39945932", "title": "How do I use a macro defined in another crate?", "body": "<p>You probably need to declare <code>cpython</code> as follows:</p>\n\n<pre><code>#[macro_use] extern crate cpython;\n</code></pre>\n\n<p>To be able to use <code>cpython</code>'s macros. You can consult <a href=\"http://dgrunwald.github.io/rust-cpython/doc/cpython/macro.py_module_initializer!.html\" rel=\"nofollow\">the example in its docs</a>.</p>\n"}], "owner": {"reputation": 15070, "user_id": 388427, "user_type": "registered", "accept_rate": 84, "profile_image": "https://www.gravatar.com/avatar/a43a07bc90818154ff9c8d4af7c23502?s=128&d=identicon&r=PG", "display_name": "Sergey", "link": "https://stackoverflow.com/users/388427/sergey"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 361, "favorite_count": 0, "accepted_answer_id": 39945932, "answer_count": 2, "score": 2, "last_activity_date": 1476033933, "creation_date": 1476030726, "last_edit_date": 1476033933, "question_id": 39945901, "link": "https://stackoverflow.com/questions/39945901/how-do-i-use-a-macro-defined-in-another-crate", "title": "How do I use a macro defined in another crate?", "body": "<p>I've seen a couple tutorials to create a Python module using the <code>cpython</code> crate but still have errors when building:</p>\n\n<pre><code>extern crate cpython;\n\nuse cpython::{PyObject, PyResult, Python, PyTuple, PyDict, ToPyObject, PythonObject};\n\nfn add_two(py: Python, args: &amp;PyTuple, _: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;PyObject&gt; {\n    match args.as_slice() {\n        [ref a_obj, ref b_obj] =&gt; {\n            let a = a_obj.extract::&lt;i32&gt;(py).unwrap();\n            let b = b_obj.extract::&lt;i32&gt;(py).unwrap();\n            let mut acc:i32 = 0;\n\n            for _ in 0..1000 {\n                acc += a + b;\n            }\n\n            Ok(acc.to_py_object(py).into_object())\n        },\n        _ =&gt; Ok(py.None())\n    }\n}\n\npy_module_initializer!(example, |py, module| {\n    try!(module.add(py, \"add_two\", py_fn!(add_two)));\n    Ok(())\n});\n</code></pre>\n\n<p>I get:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: macro undefined: 'py_module_initializer!'\n</code></pre>\n\n<p>Where do I get it? I am using Rust 1.12.</p>\n\n<hr>\n\n<p><strong>UPD</strong></p>\n\n<ol>\n<li>Need to add <code>#[macro_use]</code> (as in answers)</li>\n<li>For other errors - see <a href=\"http://dgrunwald.github.io/rust-cpython/doc/cpython/macro.py_module_initializer!.html\" rel=\"nofollow\">examples here</a></li>\n</ol>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 1, "last_activity_date": 1476031379, "last_edit_date": 1476031379, "creation_date": 1476030772, "answer_id": 39945906, "question_id": 39945698, "link": "https://stackoverflow.com/questions/39945698/mutable-and-immutable-data-access/39945906#39945906", "title": "Mutable and Immutable Data Access", "body": "<p>The simple answer: <strong>no</strong>.</p>\n\n<hr>\n\n<p>Rust can reason about disjoint fields when borrowing, so you can mutably borrow a field and then borrow <em>another</em> field and it'll work, so long as both occur in the same context (function/method).</p>\n\n<p>In this case what <code>next_node</code> does is opaque to the compiler, and it may actually be using the children for all we know.</p>\n\n<p>Thus, it is required that when calling <code>next_node</code> no mutable borrow be outstanding.</p>\n\n<hr>\n\n<blockquote>\n  <p>In particular in this implementation I only do <code>.children()</code> once, which in this case isn't a very complicated method, but could be.</p>\n</blockquote>\n\n<p>True... but what's the responsibility of this method. Why would it perform <em>both</em> an extensive computation <em>and</em> a borrow?</p>\n\n<p>The simpler organization of this code would be:</p>\n\n<ul>\n<li>do the expensive computation once (not borrowing)</li>\n<li>borrow for as a small a scope as possible</li>\n</ul>\n\n<p>and it would work:</p>\n\n<pre><code>self.expensive_computation();\n\nif self.children.len() &gt; K {\n    let mut next_node = self.next_node();\n    let list = self.children;\n    // Something involving next_node and list\n}\n</code></pre>\n"}], "owner": {"reputation": 2560, "user_id": 46842, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/3a5acbe9f67bdc96d5901946aa87d619?s=128&d=identicon&r=PG", "display_name": "psycotica0", "link": "https://stackoverflow.com/users/46842/psycotica0"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 58, "favorite_count": 0, "accepted_answer_id": 39945906, "answer_count": 1, "score": 1, "last_activity_date": 1476031379, "creation_date": 1476029480, "question_id": 39945698, "link": "https://stackoverflow.com/questions/39945698/mutable-and-immutable-data-access", "title": "Mutable and Immutable Data Access", "body": "<p>This question will likely be really basic, but I don't even know what to search for.\nI didn't see anything that jumped out at me in The Book, and I'm a Rust beginner:</p>\n\n<pre><code>struct Node;\nimpl Node {\n    fn children(&amp;mut self) -&gt; &amp;mut Vec&lt;Node&gt; {\n        // Pulls a field out of Node, to be mutated\n    }\n    fn next_node(&amp;self) -&gt; Node {\n        // Produces a new value using values computed from self.\n        // Doesn't hold a reference to self\n    }\n}\n[...]\nif self.children().len() &gt; K {\n    let mut next_node = self.next_node();\n    let list = self.children();\n    // something involving next_node and list\n}\n</code></pre>\n\n<p>This is what I eventually got to convince Rust that what I was doing was ok.\nWhat I found more straight-forward was:</p>\n\n<pre><code>let list = self.children();\nif list.len() &gt; K {\n    let mut next_node = self.next_node();\n    // Something involving next_node and list\n}\n</code></pre>\n\n<p>But it complained because I couldn't get an immutable reference to <code>self</code> in <code>next_node</code> because there was already a mutable one held up in <code>self.children</code>, which is true.</p>\n\n<p>In particular in this implementation I only do <code>.children()</code> once, which in this case isn't a very complicated method, but could be.</p>\n\n<p>Is there a way to do this that doesn't compute <code>children</code> more than once, and doesn't construct <code>next_node</code> when it's not required?</p>\n"}, {"tags": ["string", "rust", "slice"], "answers": [{"comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1476028867, "post_id": 39945600, "comment_id": 67171326, "body": "Beat me by seconds :D."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1476029198, "post_id": 39945600, "comment_id": 67171427, "body": "Argh, so it is.  It&#39;s hard to see that when there are so many methods, and I keep being confused by there being two doc pages for <code>str</code>, for the primitive <code>str</code> and the module."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 8, "last_activity_date": 1476028833, "creation_date": 1476028833, "answer_id": 39945600, "question_id": 39945532, "link": "https://stackoverflow.com/questions/39945532/why-is-stringfind-not-a-method-on-str/39945600#39945600", "title": "Why is String::find not a method on &amp;str?", "body": "<p>Apparently, the documentation confused you. This method is listed under this section:</p>\n\n<p><a href=\"https://i.stack.imgur.com/xZqwu.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/xZqwu.png\" alt=\"Methods from Deref&lt;Target=str&gt;\"></a></p>\n\n<p>So it is not even implemented for <code>String</code>, but indeed just <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.find\" rel=\"nofollow noreferrer\">for <code>&amp;str</code></a>.</p>\n"}, {"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 5, "last_activity_date": 1476028849, "creation_date": 1476028849, "answer_id": 39945602, "question_id": 39945532, "link": "https://stackoverflow.com/questions/39945532/why-is-stringfind-not-a-method-on-str/39945602#39945602", "title": "Why is String::find not a method on &amp;str?", "body": "<p>Actually it's only available for <code>String</code> because it <code>Deref</code>s to <code>str</code>:</p>\n\n<pre><code>Methods from Deref&lt;Target=str&gt;\n</code></pre>\n\n<p>You won't find it in <a href=\"https://doc.rust-lang.org/src/collections/up/src/libcollections/string.rs.html\" rel=\"noreferrer\">the source for String</a>, but in <a href=\"https://doc.rust-lang.org/src/collections/up/src/libcollections/str.rs.html#749-752\" rel=\"noreferrer\">the source for <code>str</code></a>.</p>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 5, "last_activity_date": 1476030271, "last_edit_date": 1476030271, "creation_date": 1476028860, "answer_id": 39945604, "question_id": 39945532, "link": "https://stackoverflow.com/questions/39945532/why-is-stringfind-not-a-method-on-str/39945604#39945604", "title": "Why is String::find not a method on &amp;str?", "body": "<p>Actually... you are wrong: it is not a <code>String</code> method.</p>\n\n<p>What you are looking at is <a href=\"https://doc.rust-lang.org/beta/std/primitive.str.html#method.find\" rel=\"nofollow\"><code>str::find</code></a>.</p>\n\n<p>It just so happens that the Rust documentation automatically includes on the <code>String</code> page the methods brought in by the fact that <code>String</code> implements <code>Deref&lt;Target=str&gt;</code> as <a href=\"https://doc.rust-lang.org/std/string/struct.String.html#method.len-1\" rel=\"nofollow\">can be seen here</a>.</p>\n\n<hr>\n\n<p>Why does the documentation includes the methods that can be called on the target of <code>Deref</code>?</p>\n\n<p>Because you can actually call them directly on a <code>String</code> object, since the compiler will automatically follow <code>Deref</code> if it does not find the method you are calling, recursively.</p>\n"}], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 220, "favorite_count": 0, "accepted_answer_id": 39945600, "answer_count": 3, "score": 3, "last_activity_date": 1476030271, "creation_date": 1476028445, "question_id": 39945532, "link": "https://stackoverflow.com/questions/39945532/why-is-stringfind-not-a-method-on-str", "title": "Why is String::find not a method on &amp;str?", "body": "<p>I recently noticed that <a href=\"https://doc.rust-lang.org/std/string/struct.String.html#method.find\" rel=\"nofollow\"><code>String::find</code></a> is actually a method on an owned <code>String</code>.</p>\n\n<p>But I can't see why it wouldn't just be a method on <code>&amp;str</code> instead, making it useful in more cases (and still being just as useful for <code>String</code>).  Am I missing a reason for why it's like this, or is it just a historical accident?</p>\n"}, {"tags": ["rust", "slice"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476028603, "post_id": 39945487, "comment_id": 67171251, "body": "Thanks @Shepmaster; I tried things like &quot;subslice&quot; but not &quot;subsequence&quot;."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476028665, "post_id": 39945487, "comment_id": 67171266, "body": "Haha, me too! I <i>knew</i> there was a question about it already though, so I eventually found it. Now this question will get the all-important <code>subslice</code> keyword for search engines ;-)"}], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 31, "favorite_count": 0, "closed_date": 1476028288, "answer_count": 0, "score": 0, "last_activity_date": 1476028854, "creation_date": 1476028230, "last_edit_date": 1476028854, "question_id": 39945487, "link": "https://stackoverflow.com/questions/39945487/searching-for-a-matching-subslice", "closed_reason": "Duplicate", "title": "Searching for a matching subslice?", "body": "<p><a href=\"https://doc.rust-lang.org/std/string/struct.String.html#method.find\" rel=\"nofollow\"><code>std::String::find</code></a> searches for a pattern in a <code>String</code>, and in particular can search for a substring.</p>\n\n<p>I can't see an equivalent for general slices, or even (as I'm interested in) specifically <code>&amp;[u8]</code> or <code>Vec&lt;u8&gt;</code>.  Have I missed something obvious?  It seems it would be an even easier thing to provide for <code>&amp;[u8]</code> than for <code>String</code> when you don't need to worry about UTF-8.  :-)</p>\n"}, {"tags": ["swift", "rust", "automatic-ref-counting"], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 4, "creation_date": 1476016393, "post_id": 39943624, "comment_id": 67167681, "body": "One question remains: is Swift&#39;s reference counting atomic? (I guess it has to be ... ?)"}, {"owner": {"reputation": 415, "user_id": 6094906, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e585526af864f66039864bfc16e2a08d?s=128&d=identicon&r=PG&f=1", "display_name": "Jon Flow", "link": "https://stackoverflow.com/users/6094906/jon-flow"}, "edited": false, "score": 0, "creation_date": 1476016454, "post_id": 39943624, "comment_id": 67167696, "body": "Given that they are totally different I&#39;m glad I asked! Thank you :)"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1476019030, "post_id": 39943624, "comment_id": 67168405, "body": "@LukasKalbertodt: I hope so! But we&#39;ll need a Swift expert to answer this."}, {"owner": {"reputation": 801, "user_id": 6453879, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/7a79b61195d4ef910b83f047c02c3b8a?s=128&d=identicon&r=PG&f=1", "display_name": "J. Cocoe", "link": "https://stackoverflow.com/users/6453879/j-cocoe"}, "edited": false, "score": 3, "creation_date": 1476031171, "post_id": 39943624, "comment_id": 67172051, "body": "It is threadsafe, if that&#39;s the question: <a href=\"http://stackoverflow.com/questions/13942226\">stackoverflow.com/questions/13942226</a>"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 7, "last_activity_date": 1532505759, "last_edit_date": 1532505759, "creation_date": 1476016107, "answer_id": 39943624, "question_id": 39943375, "link": "https://stackoverflow.com/questions/39943375/whats-the-difference-between-atomic-reference-counting-and-automatic-reference/39943624#39943624", "title": "What&#39;s the difference between atomic reference counting and automatic reference counting?", "body": "<p>This is actually... totally different.</p>\n\n<ul>\n<li><strong>atomic</strong>: comes from <a href=\"https://en.wikipedia.org/wiki/Atomicity_(database_systems)\" rel=\"nofollow noreferrer\">atomicity</a>, it describes an operation that is executed <em>in one step</em>, that is an external observer cannot see any intermediate step: they only see the state before or after.</li>\n<li><strong>automatic</strong>: means <a href=\"http://www.merriam-webster.com/dictionary/automatic\" rel=\"nofollow noreferrer\">done or produced as if by a machine</a>.</li>\n</ul>\n\n<hr>\n\n<p>On the Rust side, we have <code>Arc</code> and <code>Rc</code> which are reference counting pointers:</p>\n\n<ul>\n<li><code>Rc</code> is the bare-bone reference-counting pointer: cloning it just increments a counter, and when the last <code>Rc</code> pointing to a particular piece of data is dropped, the counter falls down to 0 and that piece of data is dropped too.</li>\n<li><code>Arc</code> is the atomic version of it, which means it is thread-safe and can be shared across threads (unlike <code>Rc</code>).</li>\n</ul>\n\n<hr>\n\n<p>On the Swift side, <code>ARC</code> refers to Automatic Reference Counting, Swift's Garbage Collection mechanism which as the name implies is automatic (and invisible in the code).</p>\n"}], "owner": {"reputation": 415, "user_id": 6094906, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e585526af864f66039864bfc16e2a08d?s=128&d=identicon&r=PG&f=1", "display_name": "Jon Flow", "link": "https://stackoverflow.com/users/6094906/jon-flow"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 662, "favorite_count": 0, "accepted_answer_id": 39943624, "answer_count": 1, "score": 5, "last_activity_date": 1532505759, "creation_date": 1476014482, "question_id": 39943375, "link": "https://stackoverflow.com/questions/39943375/whats-the-difference-between-atomic-reference-counting-and-automatic-reference", "title": "What&#39;s the difference between atomic reference counting and automatic reference counting?", "body": "<p>I see ARC as an acronym used every now and then, but for example in Rust it's \"atomic reference counting\", and in Swift or ObjC they call it \"automatic reference counting\". What exactly is the difference? As far as I know they seem to behave the same way.</p>\n"}, {"tags": ["rust", "mio"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 2, "creation_date": 1476007809, "post_id": 39942263, "comment_id": 67165323, "body": "Have you seen <a href=\"http://hermanradtke.com/2015/07/12/my-basic-understanding-of-mio-and-async-io.html\" rel=\"nofollow noreferrer\">this series by Herman J. Radtke</a>? It contains useful information on error-handling in <code>mio</code>."}, {"owner": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1476210914, "post_id": 39942263, "comment_id": 67247193, "body": "Thanks, that read was interesting. Unfortunately he doesn&#39;t talk about error handling much :)"}], "answers": [{"tags": [], "owner": {"reputation": 3376, "user_id": 134409, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/e1ec6b4e77bfbae1b992957792572630?s=128&d=identicon&r=PG", "display_name": "dpc.pw", "link": "https://stackoverflow.com/users/134409/dpc-pw"}, "is_accepted": true, "score": 1, "last_activity_date": 1477515975, "creation_date": 1477515975, "answer_id": 40272111, "question_id": 39942263, "link": "https://stackoverflow.com/questions/39942263/how-to-handle-errors-in-mio/40272111#40272111", "title": "How to handle errors in mio?", "body": "<p>All things that you mention have very precise meaning and map directly to POSIX/BSD Socket API. It's up to you to decide.</p>\n\n<p><code>is_hup</code> on Read mean the other side hanged-up it's sending side. Meaning it won't send you anything again. However it might have kept the reading open, and you might still want to send some data to it.</p>\n\n<p><code>shutdown</code> closes Reading/Writing/Both <a href=\"https://doc.rust-lang.org/std/net/enum.Shutdown.html\" rel=\"nofollow\">https://doc.rust-lang.org/std/net/enum.Shutdown.html</a> , so it's up to you what and when you want to do.</p>\n\n<p><code>TcpStream</code> internally holds <code>FileDesc</code> and that will <code>close</code> the <code>fd</code> when you drop it, so if you don't <code>shutdown</code> manually everything will be closed anyway, as soon as you remove given <code>TcpStream</code> from usage. <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/sys/unix/fd.rs#L217\" rel=\"nofollow\">https://github.com/rust-lang/rust/blob/master/src/libstd/sys/unix/fd.rs#L217</a></p>\n"}], "owner": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 142, "favorite_count": 0, "accepted_answer_id": 40272111, "answer_count": 1, "score": 1, "last_activity_date": 1477515975, "creation_date": 1476007085, "last_edit_date": 1476019751, "question_id": 39942263, "link": "https://stackoverflow.com/questions/39942263/how-to-handle-errors-in-mio", "title": "How to handle errors in mio?", "body": "<p>I am building a multithreaded async HTTP server on top of mio.</p>\n\n<p>How should I handle events on client <code>TcpStream</code> connections? </p>\n\n<ul>\n<li>For <code>is_readable</code> it's pretty straightforward: I read the request and write the response. </li>\n<li>For other kinds I am not sure. Should I <code>shutdown()</code> the stream if I get <code>is_error</code> or <code>is_hup</code>? What about <code>is_none()</code>?</li>\n</ul>\n"}, {"tags": ["rust", "traits"], "comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1476000358, "post_id": 39939664, "comment_id": 67163676, "body": "Relaxing the generic constraints on this and directly implementing it on f64 should work? Is that not an option for you? I don&#39;t think its possible to add the trait bounds to an open generic across crates like you have (which should be the error you are getting if you implement <i>just</i> <code>From</code>)"}], "answers": [{"comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1476000237, "post_id": 39940621, "comment_id": 67163652, "body": "I think the OP tried each individually. The issue is attempting to implement a trait where the generic type has trait bounds that aren&#39;t declared in the current crate. I don&#39;t think this is possible. Its possible in the standard library because thats where the original traits live."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 1, "creation_date": 1476001827, "post_id": 39940621, "comment_id": 67163928, "body": "I expanded my answer with a solution to a case where there is only one <code>impl</code> in place."}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": true, "score": 5, "last_activity_date": 1476002470, "last_edit_date": 1495542797, "creation_date": 1475993929, "answer_id": 39940621, "question_id": 39939664, "link": "https://stackoverflow.com/questions/39939664/implementing-from-into-for-struct-with-constraints/39940621#39940621", "title": "Implementing From/Into for struct with constraints", "body": "<p>You can't have both <code>From</code> and <code>Into</code> implemented for a single type, i.e. you can't <code>impl From&lt;ForceOrd&lt;X&gt;&gt; for X</code> if you also <code>impl Into&lt;X&gt; for ForceOrd&lt;X&gt;</code>. You only need one, too. As the docs for <a href=\"https://doc.rust-lang.org/std/convert/trait.Into.html\" rel=\"nofollow noreferrer\"><code>Into</code></a> and <a href=\"https://doc.rust-lang.org/std/convert/trait.From.html\" rel=\"nofollow noreferrer\"><code>From</code></a> both state:</p>\n\n<pre><code>From&lt;T&gt; for U implies Into&lt;U&gt; for T\n</code></pre>\n\n<p>You should probably go with just a <code>From</code> implementation. You can see the following question for information on which to pick in general: <a href=\"https://stackoverflow.com/questions/29812530/when-should-i-implement-stdconvertfrom-vs-stdconvertinto\">When should I implement std::convert::From vs std::convert::Into?</a></p>\n\n<p><strong>Edit</strong>: as implementing <code>From</code> is not (in this case) as trivial as just removing the <code>impl Into</code>, below you can see how this can be achieved for <code>f64</code>:</p>\n\n<pre><code>#[derive(PartialEq, PartialOrd, Debug)]\npub struct ForceOrd&lt;X: PartialEq + PartialOrd&gt;(pub X);\n\nimpl&lt;X: PartialEq + PartialOrd&gt; Eq for ForceOrd&lt;X&gt; { }\n\nimpl&lt;X: PartialEq + PartialOrd&gt; Ord for ForceOrd&lt;X&gt; {\n    fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering {\n        self.0.partial_cmp(&amp;other.0).unwrap()\n    }\n}\n\nimpl&lt;X: PartialEq + PartialOrd&gt; From&lt;X&gt; for ForceOrd&lt;X&gt; {\n    fn from(x: X) -&gt; ForceOrd&lt;X&gt; {\n        ForceOrd(x)\n    }\n}\n\nfn main() {\n    let xs = vec![1.1f64, 3.5, 2.2];\n\n    let max = xs.iter().map(|&amp;f| &lt;ForceOrd&lt;f64&gt;&gt;::from(f)).max().unwrap();\n\n    println!(\"{:?}\", max); // prints \"ForceOrd(3.5)\"\n}\n</code></pre>\n\n<p>Unfortunately I'm afraid this is as far as you can get; you won't be able to implement:</p>\n\n<pre><code>impl&lt;X: PartialEq + PartialOrd&gt; From&lt;ForceOrd&lt;X&gt;&gt; for X\n</code></pre>\n\n<p>to be able to do a final</p>\n\n<pre><code>&lt;f64&gt;::from(xs.iter().map(|&amp;f| &lt;ForceOrd&lt;f64&gt;&gt;::from(f)).max().unwrap())\n</code></pre>\n\n<p>because <code>f64</code> is not local to this crate. You can read more about this limitation in <a href=\"http://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/\" rel=\"nofollow noreferrer\">this very detailed blog entry by Niko Matsakis</a> and see <a href=\"https://stackoverflow.com/questions/29789877/can-not-implement-trait-from-another-crate-for-generic-type-from-another-crate-p\">this question in StackOverflow</a>.</p>\n"}], "owner": {"reputation": 3333, "user_id": 3859566, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a7c4c1c9ad9bd41f49004d32884bc680?s=128&d=identicon&r=PG&f=1", "display_name": "yong", "link": "https://stackoverflow.com/users/3859566/yong"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 148, "favorite_count": 1, "accepted_answer_id": 39940621, "answer_count": 1, "score": 3, "last_activity_date": 1476019684, "creation_date": 1475983138, "last_edit_date": 1476019684, "question_id": 39939664, "link": "https://stackoverflow.com/questions/39939664/implementing-from-into-for-struct-with-constraints", "title": "Implementing From/Into for struct with constraints", "body": "<p>Since <code>.max()</code> doesn't work for <code>f64</code>s, I'm writing a <code>ForceOrd</code> struct that asserts that the argument isn't a <code>NaN</code>. The intended usage is something like:</p>\n\n<pre><code>let m = xs.iter().map(|&amp;x| ForceOrd(x)).max().unwrap().into();\n</code></pre>\n\n<p>However, I can't get the <code>Into</code> trait implementation to compile with the error: </p>\n\n<pre><code>conflicting implementations of trait `std::convert::Into&lt;_&gt;` for type `ForceOrd&lt;_&gt;`\n</code></pre>\n\n<p>The code (<a href=\"https://play.rust-lang.org/?gist=fdb1c292814a80ca3bb911f76247e4f4&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">playground</a>):</p>\n\n<pre><code>#[derive(PartialEq, PartialOrd)]\npub struct ForceOrd&lt;X: PartialEq + PartialOrd&gt;(pub X);\nimpl&lt;X: PartialEq + PartialOrd&gt; Eq for ForceOrd&lt;X&gt; { }\nimpl&lt;X: PartialEq + PartialOrd&gt; Ord for ForceOrd&lt;X&gt; {\n    fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering {\n        self.0.partial_cmp(&amp;other.0).unwrap()\n    }\n}\n/// doesn't work\nimpl&lt;X: PartialEq + PartialOrd&gt; Into&lt;X&gt; for ForceOrd&lt;X&gt; {\n    fn into(x: Self) -&gt; X { x.0 }\n}\n/// doesn't work either\nimpl&lt;X: PartialEq + PartialOrd&gt; From&lt;ForceOrd&lt;X&gt;&gt; for X {\n    fn from(x: ForceOrd&lt;X&gt;) -&gt; Self { x.0 }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 13635, "user_id": 547365, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/ddefbca930fdd39846b698bab7ac3146?s=128&d=identicon&r=PG", "display_name": "w.brian", "link": "https://stackoverflow.com/users/547365/w-brian"}, "edited": false, "score": 0, "creation_date": 1475983857, "post_id": 39939633, "comment_id": 67160789, "body": "Excellent! I don&#39;t want my struct to have copy semantics so the first solution is exactly what I&#39;m looking for."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 6, "last_activity_date": 1602166097, "last_edit_date": 1602166097, "creation_date": 1475982763, "answer_id": 39939633, "question_id": 39939534, "link": "https://stackoverflow.com/questions/39939534/what-is-the-most-efficient-way-to-clone-a-fixed-sized-array/39939633#39939633", "title": "What is the most efficient way to clone a fixed-sized array?", "body": "<h2>Since Rust 1.21</h2>\n<p>Arrays of items that are <code>Clone</code> always implement <code>Clone</code>, so you can simply call <code>.clone()</code> on the array, or <code>#[derive(Clone)]</code> on the struct.</p>\n<h2>Before Rust 1.21</h2>\n<p>As of Rust 1.12, arrays only implement <code>Clone</code> for up to 32 items. However, arrays implement <code>Copy</code> for any number of items (despite <code>Copy</code> requiring <code>Clone</code>!). We can therefore make an implicit copy of the array in our implementation of <code>Clone</code>.</p>\n<pre><code>struct Foo {\n    b: [u8; 65536],\n}\n\nimpl Clone for Foo {\n    fn clone(&amp;self) -&gt; Self {\n        Foo {\n            b: self.b\n        }\n    }\n}\n</code></pre>\n<p>If you also want your struct to implement <code>Copy</code>, then you can also implement <code>Clone::clone</code> by just making a copy of <code>self</code>:</p>\n<pre><code>#[derive(Copy)]\nstruct Foo {\n    b: [u8; 65536],\n}\n\nimpl Clone for Foo {\n    fn clone(&amp;self) -&gt; Self {\n        *self\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 13635, "user_id": 547365, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/ddefbca930fdd39846b698bab7ac3146?s=128&d=identicon&r=PG", "display_name": "w.brian", "link": "https://stackoverflow.com/users/547365/w-brian"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 454, "favorite_count": 0, "accepted_answer_id": 39939633, "answer_count": 1, "score": 3, "last_activity_date": 1602166097, "creation_date": 1475981664, "question_id": 39939534, "link": "https://stackoverflow.com/questions/39939534/what-is-the-most-efficient-way-to-clone-a-fixed-sized-array", "title": "What is the most efficient way to clone a fixed-sized array?", "body": "<p>I have a struct that consists of a fixed-size byte array with 65536 elements.  </p>\n\n<p>I've implemented <code>Clone</code> on my struct naively \u2014 I create a new array and loop through the original, copying each element one-at-a-time.  Is there a more efficient or idiomatic way of doing this that would essentially boil down to a <code>memcpy</code>?  </p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 0, "creation_date": 1475990621, "post_id": 39939386, "comment_id": 67161806, "body": "Without good reason not to I&#39;d prefer the minimal size, but there shouldn&#39;t be much of a difference if they&#39;re just local variables."}, {"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 1, "creation_date": 1475995047, "post_id": 39939386, "comment_id": 67162516, "body": "(Off-topic: pH should be a <code>f32</code>/<code>f64</code>, and it is valid to be &lt;0 or &gt;14.)"}, {"owner": {"reputation": 788, "user_id": 1391782, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/cb4614f0b19bb2ec2a35fd3c065ba8c5?s=128&d=identicon&r=PG", "display_name": "Abdillah", "link": "https://stackoverflow.com/users/1391782/abdillah"}, "reply_to_user": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1475995877, "post_id": 39939386, "comment_id": 67162672, "body": "@kennytm You&#39;re right! I&#39;ll edit it. But it also applied with <code>f</code> too :D"}], "answers": [{"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": true, "score": 4, "last_activity_date": 1475995345, "last_edit_date": 1475995345, "creation_date": 1475994957, "answer_id": 39940745, "question_id": 39939386, "link": "https://stackoverflow.com/questions/39939386/is-u32-i32-suggested-even-on-limited-range-number-case/39940745#39940745", "title": "Is `u32`/`i32` suggested even on limited range number case?", "body": "<p><strong>A no-answer answer</strong>: I doubt you would see any difference in benchmarks, unless you do <strong>A LOT</strong> of arithmetic or process <strong>HUGE</strong> arrays of numbers.</p>\n\n<p>You should probably just go with the type which makes more sense (no reason to use negatives or have an upper bound in millions for a day of month) and provides the methods you need (e.g. you can't perform <code>abs()</code> directly on an unsigned integer).</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1476015335, "post_id": 39942668, "comment_id": 67167362, "body": "+1 for introducing new types. As for the boilerplate, I would like to point out that generally multiplying scores together, or dividing them, does not produce a score! Strong typing not only enforces valid values, it also enforces valid <i>operations</i>, so that you don&#39;t actually divide two scores together to get another score."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1476017922, "post_id": 39942668, "comment_id": 67168103, "body": "@MatthieuM. Excellent point! I edited my answer to include it."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 7, "last_activity_date": 1476017852, "last_edit_date": 1492085956, "creation_date": 1476009647, "answer_id": 39942668, "question_id": 39939386, "link": "https://stackoverflow.com/questions/39939386/is-u32-i32-suggested-even-on-limited-range-number-case/39942668#39942668", "title": "Is `u32`/`i32` suggested even on limited range number case?", "body": "<h2>Summary</h2>\n\n<p>Correctness should be prioritized over performance and correctness-wise (for ranges like 1\u2013100), all solutions (<code>u8</code>, <code>u32</code>, ...) are equally bad. The best solution would be to create a <strong>new type</strong> to benefit from <em>strong typing</em>. </p>\n\n<p>The rest of my answer tries to justify this claim and discusses different ways of creating the new type.</p>\n\n<h2>More explanation</h2>\n\n<p>Let's take a look at the \"score of subject\" example: the only legal values are 0\u2013100. I'd argue that correctness-wise, using <code>u8</code> and <code>u32</code> is equally bad: in both cases, your variable can hold values that are <em>not</em> legal in your semantic context; that's bad! </p>\n\n<p>And arguing that the <code>u8</code> is better, because there are less illegal values, is like arguing that wrestling a bear is better than walking through New York, because you only have one possibility of dying (blood loss by bear attack) as opposed to the many possibilities of death (car accident, knife attack, drowning, ...) in New York. </p>\n\n<p>So what we want is a type that guarantees to hold only legal values. We want to create a new type that does exactly this. However, there are multiple ways to proceed; each with different advantages and disadvantages.</p>\n\n<hr>\n\n<h3>(A) Make the inner value public</h3>\n\n<pre><code>struct ScoreOfSubject(pub u8);\n</code></pre>\n\n<p><strong>Advantage</strong>: at least APIs are more easy to understand, because the parameter is already explained by the type. What is easier to understand: </p>\n\n<ul>\n<li><code>add_record(\"peter\", 75, 47)</code> <strong>or</strong> </li>\n<li><code>add_record(\"peter\", StudentId(75), ScoreOfSubject(47))</code>?</li>\n</ul>\n\n<p>I'd say the latter one ;-)</p>\n\n<p><strong>Disadvantage</strong>: we don't actually do any range checking and illegal values can still occur; bad!.</p>\n\n<hr>\n\n<h3>(B) Make inner value private and supply a range checking constructor</h3>\n\n<pre><code>struct ScoreOfSubject(pub u8);\n\nimpl ScoreOfSubject {\n    pub fn new(value: u8) -&gt; Self {\n        assert!(value &lt;= 100);\n        ScoreOfSubject(value)\n    }\n    pub fn get(&amp;self) -&gt; u8 { self.0 }\n}\n</code></pre>\n\n<p><strong>Advantage</strong>: we enforce legal values with very little code, yeah :)</p>\n\n<p><strong>Disadvantage</strong>: working with the type can be annoying. Pretty much every operation requires the programmer to pack &amp; unpack the value.</p>\n\n<hr>\n\n<h3>(C) Add a bunch of implementations (in addition to (B))</h3>\n\n<p>(the code would <code>impl Add&lt;_&gt;</code>, <code>impl Display</code> and so on)</p>\n\n<p><strong>Advantage</strong>: the programmer can use the type and do all useful operations on it directly -- with range checking! This is pretty optimal.</p>\n\n<p>Please take a look at Matthieu M.'s comment:</p>\n\n<blockquote>\n  <p>[...] generally multiplying scores together, or dividing them, does not produce a score! Strong typing not only enforces valid values, it also enforces valid operations, so that you don't actually divide two scores together to get another score.</p>\n</blockquote>\n\n<p>I think this is a very important point I failed to make clear before. Strong typing prevents the programmer from executing illegal operations on values (operations that don't make any sense). A good example is the crate <a href=\"https://github.com/brendanzab/cgmath\" rel=\"nofollow noreferrer\"><code>cgmath</code></a> which distinguishes between point and direction vectors, because both support different operations on them. You can find additional explanation <a href=\"https://math.stackexchange.com/questions/645672/what-is-the-difference-between-a-point-and-a-vector\">here</a>.</p>\n\n<p><strong>Disadvantage</strong>: a lot of code :(</p>\n\n<p>Luckily the disadvantage can be reduced by the Rust macro/compiler plugin system. There are crates like <a href=\"https://crates.io/crates/newtype_derive\" rel=\"nofollow noreferrer\"><code>newtype_derive</code></a> or <a href=\"https://crates.io/crates/bounded-integer\" rel=\"nofollow noreferrer\"><code>bounded_integer</code></a> that do this kind of code generation for you (disclaimer: I never worked with them). </p>\n\n<hr>\n\n<p>But now you say: \"you can't be serious? Am I supposed to spend my time writing new types?\".</p>\n\n<p>Not necessarily, but if you are working on production code (== at least somewhat important), then my answer is: <em>yes, you should</em>.</p>\n"}, {"tags": [], "owner": {"reputation": 2796, "user_id": 6121044, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/d36000b5ea58961acf50354041457af9?s=128&d=identicon&r=PG&f=1", "display_name": "Andreas", "link": "https://stackoverflow.com/users/6121044/andreas"}, "is_accepted": false, "score": 1, "last_activity_date": 1476011824, "creation_date": 1476011824, "answer_id": 39942968, "question_id": 39939386, "link": "https://stackoverflow.com/questions/39939386/is-u32-i32-suggested-even-on-limited-range-number-case/39942968#39942968", "title": "Is `u32`/`i32` suggested even on limited range number case?", "body": "<p>There could be major benefits using smaller types but you would have to benchmark your application on your target platform to be sure.</p>\n\n<p>The first and most easily realized benefit from the lower memory footprint is better caching. Not only is your data more likely to fit into the cache, but it is also less likely to discard other data in the cache, potentially improving a completely different part of your application. Whether or not this is triggered depends on what memory your application touches and in what order. Do the benchmarks!</p>\n\n<p>Network data transfers have an obvious benefit from using smaller types.</p>\n\n<p>Smaller data allows \"larger\" instructions. A 128-bit SIMD unit can handle 4 32-bit data OR 16 8-bit data, making certain operations 4 times faster. In benchmarks I\u00b4ve made these instructions do execute 4 times faster indeed BUT the whole application improved by less than 1%, and the code became more of a mess. Shaping your program into making better use of SIMD can be tricky.</p>\n\n<p>As of signed/unsigned discussions unsigned has slightly better properties which a compiler may or may not take advantage of.</p>\n"}], "owner": {"reputation": 788, "user_id": 1391782, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/cb4614f0b19bb2ec2a35fd3c065ba8c5?s=128&d=identicon&r=PG", "display_name": "Abdillah", "link": "https://stackoverflow.com/users/1391782/abdillah"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1023, "favorite_count": 0, "accepted_answer_id": 39940745, "answer_count": 3, "score": 6, "last_activity_date": 1476017852, "creation_date": 1475980159, "last_edit_date": 1475996508, "question_id": 39939386, "link": "https://stackoverflow.com/questions/39939386/is-u32-i32-suggested-even-on-limited-range-number-case", "title": "Is `u32`/`i32` suggested even on limited range number case?", "body": "<p>Should we use <code>u32</code>/<code>i32</code> or it's lower variant (<code>u8</code>/<code>i8</code>, <code>u16</code>/<code>i16</code>) when dealing with limited  range number like \"days in month\" which ranged from 1-30 or \"score of a subject\" which ranged from 0 to 100? Or why we shouldn't?</p>\n\n<p>Is there any optimization or benefit on the lower variant (i.e. memory efficient)?</p>\n"}, {"tags": ["rust", "traits"], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 10, "last_activity_date": 1475948270, "last_edit_date": 1475948270, "creation_date": 1475947935, "answer_id": 39935314, "question_id": 39935158, "link": "https://stackoverflow.com/questions/39935158/cannot-use-moved-bufreader-after-for-loop-with-bufreader-lines/39935314#39935314", "title": "Cannot use moved BufReader after for loop with bufreader.lines()", "body": "<p>In order to avoid the move, use the <a href=\"https://doc.rust-lang.org/std/io/trait.Read.html#method.by_ref\" rel=\"noreferrer\"><code>Read::by_ref()</code> method</a>. That way, you only <em>borrow</em> the <code>BufReader</code>:</p>\n\n<pre><code>for (index, line) in buffer.by_ref().lines().enumerate() { ... }\n//                         ^^^^^^^^^\n// you can still use `buffer` here\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 10, "last_activity_date": 1579699381, "last_edit_date": 1579699381, "creation_date": 1475948345, "answer_id": 39935386, "question_id": 39935158, "link": "https://stackoverflow.com/questions/39935158/cannot-use-moved-bufreader-after-for-loop-with-bufreader-lines/39935386#39935386", "title": "Cannot use moved BufReader after for loop with bufreader.lines()", "body": "<p>As <a href=\"https://stackoverflow.com/a/39935314/155423\">Lukas Kalbertodt says</a>, use <a href=\"https://doc.rust-lang.org/std/io/trait.Read.html#method.by_ref\" rel=\"nofollow noreferrer\"><code>Read::by_ref</code></a>.</p>\n\n<p>This prevents <code>lines</code> from consuming the <code>BufReader</code> and instead it consumes a <code>&amp;mut BufReader</code>. The same logic <a href=\"https://stackoverflow.com/q/31374051/155423\">applies to iterators</a>.</p>\n\n<p>Instead of implementing <code>skip</code> yourself, you can use <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take\" rel=\"nofollow noreferrer\"><code>Iterator::take</code></a>. This has to be driven to completion with a for loop though:</p>\n\n<pre><code>use std::{\n    fs::File,\n    io::{self, BufRead, BufReader, Read},\n    path::Path,\n};\n\nfn skip_and_print_file(skip: usize, path: impl AsRef&lt;Path&gt;) {\n    if let Ok(file) = File::open(path) {\n        let mut buffer = BufReader::new(file);\n\n        for _ in buffer.by_ref().lines().take(skip) {}\n        // Or: buffer.by_ref().lines().take(skip).for_each(drop);\n\n        print_to_stdout(buffer);\n    }\n}\n\nfn print_to_stdout(mut input: impl Read) {\n    let mut stdout = io::stdout();\n    io::copy(&amp;mut input, &amp;mut stdout).expect(\"Unable to copy\");\n}\n\nfn main() {\n    skip_and_print_file(2, \"/etc/hosts\");\n}\n</code></pre>\n\n<p>Note that there's no reason to make the <code>skip</code> variable mutable or even to pass in a reference. You can also take in <code>AsRef&lt;Path&gt;</code> and then callers of <code>skip_and_print_file</code> can just pass in a string literal.</p>\n"}], "owner": {"reputation": 305, "user_id": 1993365, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0e37ab60f3cf32904a05f0b71e762377?s=128&d=identicon&r=PG", "display_name": "awesomefireduck", "link": "https://stackoverflow.com/users/1993365/awesomefireduck"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2615, "favorite_count": 1, "answer_count": 2, "score": 8, "last_activity_date": 1579699381, "creation_date": 1475947063, "last_edit_date": 1531151478, "question_id": 39935158, "link": "https://stackoverflow.com/questions/39935158/cannot-use-moved-bufreader-after-for-loop-with-bufreader-lines", "title": "Cannot use moved BufReader after for loop with bufreader.lines()", "body": "<p>I'm trying to read some lines from a file, skipping the first few and printing the rest, but I keep getting errors about used value after move:</p>\n\n<pre><code>use std::fs::File;\nuse std::io::{self, BufRead, BufReader, Read};\nuse std::path::Path;\n\nfn skip_and_print_file(skip: &amp;usize, path: &amp;Path) {\n    let mut skip: usize = *skip;\n\n    if let Ok(file) = File::open(path) {\n        let mut buffer = BufReader::new(file);\n        for (index, line) in buffer.lines().enumerate() {\n            if index &gt;= skip {\n                break;\n            }\n        }\n        print_to_stdout(&amp;mut buffer);\n    }\n}\n\nfn print_to_stdout(mut input: &amp;mut Read) {\n    let mut stdout = io::stdout();\n    io::copy(&amp;mut input, &amp;mut stdout);\n}\n\nfn main() {}\n</code></pre>\n\n<p>This is the error I'm getting:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of moved value: `buffer`\n  --&gt; src/main.rs:15:30\n   |\n10 |         for (index, line) in buffer.lines().enumerate() {\n   |                              ------ value moved here\n...\n15 |         print_to_stdout(&amp;mut buffer);\n   |                              ^^^^^^ value used here after move\n   |\n   = note: move occurs because `buffer` has type `std::io::BufReader&lt;std::fs::File&gt;`, which does not implement the `Copy` trait\n</code></pre>\n"}, {"tags": ["python", "rust", "ctypes", "ffi"], "comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 1, "creation_date": 1475946660, "post_id": 39935030, "comment_id": 67151996, "body": "<code>&amp;str</code> and <code>Result</code> or <code>Vec</code> are not ffi-safe types."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1475947567, "post_id": 39935030, "comment_id": 67152325, "body": "You may wish to check out <a href=\"http://jakegoulding.com/rust-ffi-omnibus/\" rel=\"nofollow noreferrer\">The Rust FFI Omnibus</a>. While I don&#39;t currently have returning a collection of items, there&#39;s lot&#39;s simpler things that you need to do before that point."}, {"owner": {"reputation": 1534, "user_id": 4148612, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/5287f1dbe0edc17ea630bbb5f475976d?s=128&d=identicon&r=PG", "display_name": "Nicolas Joseph", "link": "https://stackoverflow.com/users/4148612/nicolas-joseph"}, "edited": false, "score": 1, "creation_date": 1475947672, "post_id": 39935030, "comment_id": 67152373, "body": "Looks super useful, thx !"}], "owner": {"reputation": 1534, "user_id": 4148612, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/5287f1dbe0edc17ea630bbb5f475976d?s=128&d=identicon&r=PG", "display_name": "Nicolas Joseph", "link": "https://stackoverflow.com/users/4148612/nicolas-joseph"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 346, "favorite_count": 0, "answer_count": 0, "score": 3, "last_activity_date": 1475946388, "creation_date": 1475946261, "last_edit_date": 1475946388, "question_id": 39935030, "link": "https://stackoverflow.com/questions/39935030/how-to-get-a-list-of-custom-objects-from-rust-to-python-with-ctypes", "title": "How to get a list of custom objects from Rust to Python with Ctypes?", "body": "<p>I am trying to send an array of custom objects from Rust to Python as a result of a function call:</p>\n\n<pre><code>pub struct Item {\n    name: String,\n    description: String,\n    tags: Vec&lt;String&gt;\n}\n\npub struct SearchResults {\n    count: usize,\n    results: Vec&lt;Item&gt;\n}\n\nfn get_content(url: &amp;str) -&gt; hyper::Result&lt;String&gt; {\n    let client = Client::new();\n    let mut response = try!(client.get(url).send());\n    let mut buf = String::new();\n    try!(response.read_to_string(&amp;mut buf));\n    Ok(buf)\n}\n\n#[no_mangle]\npub unsafe extern fn get_search_results(search: &amp;str) -&gt; SearchResults {\n\n    let mut url = String::from(\"http://localhost:8080/search?q=\");\n    url.push_str(&amp;search);\n\n    let content = get_content(&amp;url).unwrap();\n    let j: Vec&lt;SearchResult&gt; = json::decode(&amp;content).unwrap();\n    return SearchResults {count: j.len(), results: j};\n}\n</code></pre>\n\n<p>And my Python code:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>from ctypes import cdll, Structure, c_wchar_p, c_int, POINTER\n\n\nclass SearchResult(Structure):\n    _fields_ = [(\"name\", c_wchar_p), (\"description\", c_wchar_p), (\"tags\", POINTER(c_wchar_p))]\n\n\nclass SearchResults(Structure):\n    _fields_ = [(\"count\", c_int), (\"results\", POINTER(SearchResult))]\n\nlib = cdll.LoadLibrary(\"target/release/libplugin_core.dylib\")\n\nget_search_results = lib.get_search_results\nget_search_results.restype = SearchResults\n\nprint(get_search_results(\"test\"))\n</code></pre>\n\n<p>When I run the Python code I get a malloc exception:</p>\n\n<pre><code>malloc: *** mach_vm_map(size=140734736883712) failed (error code=3)\n</code></pre>\n\n<p>Probably missing a bunch of stuff in there.</p>\n"}, {"tags": ["macros", "rust"], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 1, "last_activity_date": 1475920010, "last_edit_date": 1495542789, "creation_date": 1475920010, "answer_id": 39930954, "question_id": 39930124, "link": "https://stackoverflow.com/questions/39930124/how-to-create-a-macro-to-create-an-array-of-structs/39930954#39930954", "title": "How to create a macro to create an array of structs?", "body": "<p>Currently, to the best of my knowledge, <strong>it's impossible</strong> to create a macro which works <em>exactly</em> as you wish. It's only <em>kind of</em> possible. I'll explain:</p>\n\n<ul>\n<li>First, there is <a href=\"https://stackoverflow.com/questions/33751796/is-there-a-way-to-count-with-macros\">no way to count with macros</a>, so you can't do the \"repeat this n-times\" on your own. This is the reason why you can't generate the strings <code>\"test 1\"</code>, <code>\"test 2\"</code> and so on. It's just <strong>not possible</strong>. You can, however, create an array of structs with only <code>\"test\"</code> as string by using the standard array initializer <code>[val; n]</code>.</li>\n<li>Second, in order to use the array initializer, the type inside the array has to be <code>Copy</code>. But in your case that's not a big problem, since your struct can just derive it.</li>\n</ul>\n\n<hr>\n\n<p>So let's see, what we can do (<a href=\"https://play.rust-lang.org/?gist=5db14d8160e637244a93dd9e8f4ede9c&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">playground</a>):</p>\n\n<pre><code>#[derive(Clone, Copy, PartialEq, Debug)]\nstruct Foo&lt;'a&gt; {\n    info: &amp;'a str\n}\n\nmacro_rules! make_foo {\n    ($info:expr; $num:expr) =&gt; {\n        [Foo { info: $info }; $num]\n    }\n}\n</code></pre>\n\n<p>First, we need to derive a few traits for your struct:</p>\n\n<ul>\n<li><code>Copy</code>, see above</li>\n<li><code>Clone</code> is required by <code>Copy</code></li>\n<li><code>PartialEq</code> and <code>Debug</code> are required by <code>assert_eq!()</code></li>\n</ul>\n\n<p>I think the macro itself is fairly easy to understand: it's just using the array initializer internally.</p>\n\n<hr>\n\n<blockquote>\n  <p><strong>But how to get exactly the behavior asked in the question?</strong></p>\n</blockquote>\n\n<p>Don't use a macro and don't use fixed size arrays. A normal function and <code>Vec&lt;T&gt;</code> is probably fine. You <em>could</em>, of course, also write a compiler plugin, but those are unstable right now and it's probably not worth the hassle anyway.</p>\n"}], "owner": {"reputation": 305, "user_id": 827024, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/124f73bb21e1b10a7fb1c2bbced2be11?s=128&d=identicon&r=PG", "display_name": "Vignesh", "link": "https://stackoverflow.com/users/827024/vignesh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 217, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1475933899, "creation_date": 1475913599, "last_edit_date": 1475933899, "question_id": 39930124, "link": "https://stackoverflow.com/questions/39930124/how-to-create-a-macro-to-create-an-array-of-structs", "title": "How to create a macro to create an array of structs?", "body": "<p>Given a <code>struct</code> <code>Foo</code>:</p>\n\n<pre><code>struct Foo&lt;'a&gt; {\n    info: &amp;'a str\n}\n</code></pre>\n\n<p>To create an <code>array</code> of <code>Foo</code>s with different strings inside, I would like to have a macro, which could be used like:</p>\n\n<pre><code>assert_eq!(make_foo!(\"test\"; 2), [Foo { info: \"test 1\" }, Foo { info: \"test 2\" }]);\n</code></pre>\n\n<p>What I am confused about specifically is how to iterate over the specific number of times as specified in the second argument.</p>\n"}, {"tags": ["scope", "rust"], "comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 1, "creation_date": 1475913211, "post_id": 39929816, "comment_id": 67142817, "body": "Related / possible duplicate: <a href=\"http://stackoverflow.com/questions/26908383/rust-borrow-mutable-self-inside-match-expression\">Rust borrow mutable self inside match expression</a>. You can work around this with <code>if let</code>, like <a href=\"https://play.rust-lang.org/?gist=45e1cf8d65c9c25b9a0630de91f6f2bb&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">this</a>."}, {"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 4, "creation_date": 1475917837, "post_id": 39929816, "comment_id": 67143860, "body": "Note that by the <a href=\"https://doc.rust-lang.org/style/style/naming/README.html\" rel=\"nofollow noreferrer\">Rust naming conventions</a> the method should be called <code>find_user</code>."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1475917992, "post_id": 39929816, "comment_id": 67143887, "body": "Another possible duplicate: <a href=\"http://stackoverflow.com/questions/36667241/cannot-borrow-variable-as-mutable-because-it-is-also-borrowed-as-immutable-while\">Cannot borrow variable as mutable because it is also borrowed as immutable while refactoring a parser</a>."}], "answers": [{"comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 1, "creation_date": 1475928308, "post_id": 39931181, "comment_id": 67146356, "body": "Non-lexical lifetimes solve only the problem that crops up when you inline the <code>findUser</code> method or otherwise replace it with code that doesn&#39;t call a method on <code>self</code> to find the user. Which is still nice but not the only aspect of the question."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 1, "last_activity_date": 1475921764, "creation_date": 1475921764, "answer_id": 39931181, "question_id": 39929816, "link": "https://stackoverflow.com/questions/39929816/how-to-use-fine-grained-methods-in-a-struct/39931181#39931181", "title": "How to use fine-grained methods in a struct?", "body": "<p>This is an old problem, which is someday solved by <em>non-lexical lifetimes</em>. Your program is safe, the compiler just is not able to see that (yet!). </p>\n\n<p>There are many ways to work around this problem; here is one possibility (<a href=\"https://play.rust-lang.org/?gist=5aa721bc88dee7bfb45f53ee25d6d8b6&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">playground</a>):</p>\n\n<pre><code>fn add_user(&amp;mut self, user: User) {\n    let user_pos = self.users.iter().position(|u| u.user_id == user.user_id);\n    match user_pos {\n        Some(pos) =&gt; {\n            let u = &amp;self.users[pos];  // get the user like that\n            println!(\"User exists!\");\n        }\n        None =&gt; self.users.push(user),\n    }\n}\n</code></pre>\n\n<p><strong>The key insight</strong>: we find the <em>position</em> in the vector first and use that position <em>later</em> to index the vector. This <em>delays</em> referencing something inside the vector.</p>\n\n<hr>\n\n<p>A few additional notes:</p>\n\n<ul>\n<li>I got rid of the <code>findUser</code> method: it's a super common algorithm, so there are shortcuts already. I recommend you getting familiar with the <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\" rel=\"nofollow\"><code>Iterator</code> API</a> to write very brief and easy to read algorithms.</li>\n<li>I changed the names to match the idiomatic naming in Rust: <code>snake_case</code>.</li>\n<li>Searching through the vector every time is in O(n); it takes linear time. Inserting n users into your register has a time complexity of O(n\u00b2). This is probably not what you want. Why not use a set data structure, like <a href=\"https://doc.rust-lang.org/std/collections/struct.HashSet.html\" rel=\"nofollow\"><code>HashSet</code></a> or <a href=\"https://doc.rust-lang.org/std/collections/struct.BTreeSet.html\" rel=\"nofollow\"><code>BTreeSet</code></a>?</li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 889, "user_id": 1879192, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/54f9ed64051a86b03fe99f82805ac6d5?s=128&d=identicon&r=PG", "display_name": "Thierry", "link": "https://stackoverflow.com/users/1879192/thierry"}, "is_accepted": true, "score": 1, "last_activity_date": 1475922439, "creation_date": 1475922439, "answer_id": 39931282, "question_id": 39929816, "link": "https://stackoverflow.com/questions/39929816/how-to-use-fine-grained-methods-in-a-struct/39931282#39931282", "title": "How to use fine-grained methods in a struct?", "body": "<h1>Why the <code>rustc</code> complains</h1>\n\n<p>The first thing to do in this case is of course understand why <code>rustc</code> thinks what you're doing is not allowed. So let's look at what you're trying to do:</p>\n\n<p>A <code>Register</code> contains a vector of <code>User</code>s. <code>findUser</code> returns a reference into that vector. <code>addUser</code> pushes a new <code>User</code> into that vector. So far so good. <code>addUser</code> uses <code>findUser</code> to find an <code>Option&lt;&amp;User&gt;</code>. That (optional) reference to a <code>User</code> refers to a <code>User</code> inside the <code>users</code> vector. If a matching <code>User</code> is found, the reference in <code>u</code> points to a valid <code>User</code>, but you ignore it. If no matching <code>User</code> is found, no reference exists, but you mutate the vector. Pushing onto the vector, of course, potentially requires a reallocation, which would invalidate references into the vector. However, this is not a problem, as no reference into the vector exists at that point.</p>\n\n<p>But this is where <code>rustc</code> (or more concretely: the borrowchecker) falls short: when the borrowchecker sees</p>\n\n<pre><code>    match self.findUser(user.userId){\n        // ...\n    };\n</code></pre>\n\n<p>it concludes that the <code>Option&lt;&amp;User&gt;</code> must be live for the entire <code>match</code> body, and concludes from that that the <code>&amp;User</code> must be live for the entire <code>match</code> body. Hence, when you try to push onto <code>self.users</code> inside the <code>match</code> body, it complains.</p>\n\n<h1>Solutions</h1>\n\n<p>One solution is to wait for the borrowchecker to become smarter and figure out that matching an <code>Option&lt;T&gt;</code> can ignore <code>T</code>'s lifetime in the <code>None</code> branch.</p>\n\n<p>A better short-term solution is to painstakingly explain to the borrowchecker that it's fine, by splitting up the checking and the pushing, e.g. as follows:</p>\n\n<pre><code>    let is_found = match self.findUser(user.userId){\n        Some(u) =&gt; { println!(\"User exists!\"); true},\n        None =&gt; false\n    };\n    if !is_found {\n        self.users.push(user)\n    }\n</code></pre>\n\n<p>Another solution uses the fact that you really don't use the <code>&amp;User</code> at all here, so that you can just write the following:</p>\n\n<pre><code>    if self.findUser(user.userId) // At this point there is still a `&amp;User`\n           .is_some() { // Here, it's lifetime is over and there's a `bool` instead\n        println!(\"User exists!\")\n    } else {\n        // No live references into `self.user` exist, mutation is trivially allowed\n        self.users.push(user)\n    }\n</code></pre>\n\n<p>Yet another solution would be to change the API of <code>Register</code> to reflect that you don't want to do anything with that matching user: just make a <code>fn contains_user(&amp;self, userId: u8) -&gt; bool</code>.</p>\n\n<h3>Footnote</h3>\n\n<p>By the way, as @starblue already mentioned in comments, the <a href=\"https://doc.rust-lang.org/style/style/naming/README.html\" rel=\"nofollow\">Rust naming convention</a> is to use <code>snake_case</code> for method names. Also, <code>init</code> should probably just be called <code>new</code>.</p>\n"}], "owner": {"reputation": 111, "user_id": 6940553, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dc5bc23aacbf15cbb492bf854c4fbdab?s=128&d=identicon&r=PG&f=1", "display_name": "Steve", "link": "https://stackoverflow.com/users/6940553/steve"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 83, "favorite_count": 0, "accepted_answer_id": 39931282, "answer_count": 2, "score": 1, "last_activity_date": 1475934028, "creation_date": 1475911309, "last_edit_date": 1475934028, "question_id": 39929816, "link": "https://stackoverflow.com/questions/39929816/how-to-use-fine-grained-methods-in-a-struct", "title": "How to use fine-grained methods in a struct?", "body": "<p>I have created a small program where I add users to a register. When I take an object oriented approach in Java, it is quite common to decompose functionality into smaller methods, so I have created <code>addUser</code> and <code>findUser</code> methods for <code>Register</code>. When I compile this program I get the following compilation errors. I have read about borrowing, but could not find a way to fix this.</p>\n\n<pre><code>struct User {\n    userId: u8,\n    age: u8,\n}\nstruct Register {\n    users: Vec&lt;User&gt;,\n}\n\nimpl Register {\n    // Initialize\n    fn init() -&gt; Register {\n        Register {\n            users: Vec::new()\n        }\n    }\n\n    // Add user to register, if user does not exist in register\n    fn addUser(&amp;mut self, user: User) {\n        match self.findUser(user.userId) {\n            Some(u) =&gt; println!(\"User exists!\"),\n            None =&gt; self.users.push(user),\n        };\n    }\n\n    // If user exists, return user, else return None\n    fn findUser(&amp;self, userId: u8) -&gt; Option&lt;&amp;User&gt; {\n        for user in &amp;self.users {\n            if user.userId == userId {\n                return Some(&amp;user);\n            }\n        }\n        None\n    }\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=e82fc16c96e5d1c44584d39c2f8b6dbe&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">playground</a>)</p>\n\n<p>Compilation error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `self.users` as mutable because `*self` is also borrowed as immutable\n  --&gt; src/main.rs:18:21\n   |\n16 |         match self.findUser(user.userId) {\n   |               ---- immutable borrow occurs here\n17 |             Some(u) =&gt; println!(\"User exists!\"),\n18 |             None =&gt; self.users.push(user),\n   |                     ^^^^^^^^^^ mutable borrow occurs here\n19 |         };\n   |         - immutable borrow ends here\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 0, "creation_date": 1475910877, "post_id": 39929383, "comment_id": 67142353, "body": "Take a look at <a href=\"https://doc.rust-lang.org/stable/book/conditional-compilation.html\" rel=\"nofollow noreferrer\">the chapter on conditional compilation</a>. I&#39;m not sure it can use the compiler version as a condition, though."}, {"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 2, "creation_date": 1475913360, "post_id": 39929383, "comment_id": 67142843, "body": "The &#39;proper&#39; solution, as far as I know, is to say &#39;requires Rust &gt;= 1.11&#39;; there is very little use in keeping old versions around because backwards compatibility is never broken (but forwards compatibility is not guaranteed)."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 2, "creation_date": 1475930745, "post_id": 39929383, "comment_id": 67147108, "body": "A tip: Your title is asking a different question than the body, don&#39;t do that :D"}], "owner": {"reputation": 11, "user_id": 6940423, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/774c4ffe6013b127b306d4d0dc50ddc3?s=128&d=identicon&r=PG&f=1", "display_name": "Aaron Chan", "link": "https://stackoverflow.com/users/6940423/aaron-chan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 61, "favorite_count": 1, "closed_date": 1475934202, "answer_count": 0, "score": 1, "last_activity_date": 1475934256, "creation_date": 1475907803, "last_edit_date": 1475934256, "question_id": 39929383, "link": "https://stackoverflow.com/questions/39929383/how-can-i-use-a-preprocessor-in-rust-to-detect-the-version-number", "closed_reason": "Duplicate", "title": "How can I use a preprocessor in Rust to detect the version number?", "body": "<p>In C, I can do</p>\n\n<pre class=\"lang-c prettyprint-override\"><code>#if GCC_VERSION &gt; 5\n    ...\n#else\n    ...\n#endif\n</code></pre>\n\n<p>How to do this in Rust?</p>\n\n<p>I want to write portable code that uses <code>BTreeMap::append()</code> if Rust is at least 1.11 and use something else otherwise.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1475943665, "post_id": 39928051, "comment_id": 67151086, "body": "A search on the Internet for &quot;rust vec thread&quot; leads to <a href=\"http://stackoverflow.com/q/28599334/155423\">stackoverflow.com/q/28599334/155423</a>; <a href=\"http://stackoverflow.com/q/31644152/155423\">stackoverflow.com/q/31644152/155423</a>; <a href=\"http://stackoverflow.com/q/33818141/155423\">stackoverflow.com/q/33818141/155423</a>; and many others. Please make sure to do your own <a href=\"http://meta.stackoverflow.com/q/261592/155423\">effort and show that effort when asking a question</a>."}, {"owner": {"reputation": 9601, "user_id": 1937197, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/cg7w6.jpg?s=128&g=1", "display_name": "bobcat", "link": "https://stackoverflow.com/users/1937197/bobcat"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1475952895, "post_id": 39928051, "comment_id": 67154137, "body": "@Shepmaster thanks"}], "answers": [{"tags": [], "owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "is_accepted": true, "score": 11, "last_activity_date": 1475933814, "last_edit_date": 1475933814, "creation_date": 1475895066, "answer_id": 39928205, "question_id": 39928051, "link": "https://stackoverflow.com/questions/39928051/can-different-threads-write-to-different-sections-of-the-same-vec/39928205#39928205", "title": "Can different threads write to different sections of the same Vec?", "body": "<p>Yes, you can. You asked about the mutable case, but I'll preface by saying that if the <code>Vec</code> is read only (e.g. for a reduction) you can safely send an immutable reference to the specific slice you want in each thread. You can do this by simply using something like <code>&amp;my_vec[idx1..idx2]</code> in a loop.</p>\n\n<p>For the mutable case it's a bit trickier since the borrow tracker is not sophisticated enough to allow non-overlapping borrows of a <code>Vec</code>. However, there are a number of methods, notably <code>split_at_mut</code> you can call to get these subslices. By far the easiest is the <code>chunks_mut</code> iterator documented <a href=\"https://doc.rust-lang.org/std/primitive.slice.html\" rel=\"noreferrer\">here</a>. (Note that there is a matching <code>chunks</code> iterator for the immutable case so you only need to make minor changes when writing either case).</p>\n\n<p>Be aware that the <code>chunks</code> and <code>chunks_mut</code> functions take the <strong>size</strong> of each chunk, not the number of chunks. However, deriving one from the other is fairly straightforward.</p>\n\n<p>I would like to give a few words of caution with the mutable case, however. If you split the data evenly you may get abysmal performance. The reason is that the CPU doesn't work on individual addresses, instead it works on blocks of memory known as cache lines which are 64-bytes long. If multiple threads work on a single cache line, they have to write and read slower memory in order to ensure consistency between threads.</p>\n\n<p>Unfortunately, in safe Rust there's no easy way to determine where on a cache line a <code>Vec</code>'s buffer starts (because the buffer's start may have been allocated in the middle of a CPU cache line), most of the methods I know of to detect this involve twiddling with the lower bytes of the actual pointer address. The easiest way to handle this is to simply add a 64-byte pad of nonsense-data between each chunk you want to use. So, for instance, if you have a <code>Vec</code> containing 1000 32-bit floats and 10 threads, you simply add 16 floats with a dummy value (since 32-bits = 4-bytes, 16*4=64=1 cache line) between each 100 of your \"real\" floats and ignore the dummies during computation.</p>\n\n<p>This is known as false sharing, and I encourage you to look up other references to learn other methods of dealing with this.</p>\n\n<p>Note that the 64-byte line size is guaranteed on x86 architectures. If you're compiling for ARM, PowerPC, MIPS, or something else this value can and will vary.</p>\n"}], "owner": {"reputation": 9601, "user_id": 1937197, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/cg7w6.jpg?s=128&g=1", "display_name": "bobcat", "link": "https://stackoverflow.com/users/1937197/bobcat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 788, "favorite_count": 0, "closed_date": 1475943689, "accepted_answer_id": 39928205, "answer_count": 1, "score": 3, "last_activity_date": 1475933814, "creation_date": 1475893234, "last_edit_date": 1475933728, "question_id": 39928051, "link": "https://stackoverflow.com/questions/39928051/can-different-threads-write-to-different-sections-of-the-same-vec", "closed_reason": "Duplicate", "title": "Can different threads write to different sections of the same Vec?", "body": "<p>I have 10 threads and a <code>Vec</code> of length 100.</p>\n\n<p>Can I have thread 0 work on elements 0-9 (sort them, for example), while thread 1 is working on elements 10-19, etc.?</p>\n\n<p>Or do I have to use a <code>Vec&lt;Vec&lt;&gt;&gt;</code> for this? (Which I would rather avoid, because the elements would no longer be contiguous in memory)</p>\n"}, {"tags": ["arrays", "struct", "rust"], "comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 2, "creation_date": 1475870727, "post_id": 39924909, "comment_id": 67133777, "body": "Did you see the error from the compiler? It says, &quot;the trait bound <code>_TmoveP: std::marker::Copy</code> is not satisfied [...] note: the <code>Copy</code> trait is required because the repeated element will be copied&quot;. Does that make it clearer?"}, {"owner": {"reputation": 395, "user_id": 4264914, "user_type": "registered", "accept_rate": 0, "profile_image": "https://i.stack.imgur.com/uMKfB.png?s=128&g=1", "display_name": "gekomad", "link": "https://stackoverflow.com/users/4264914/gekomad"}, "reply_to_user": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 0, "creation_date": 1475871868, "post_id": 39924909, "comment_id": 67134255, "body": "adding  #[derive(Copy)] at two structs the error is:     error[E0204]: the trait <code>Copy</code> may not be implemented for this type      --&gt; src/main.rs:8:10       |     8 | #[derive(Copy)]       |          ^^^^ field <code>data4</code> does not implement <code>Copy</code>     src/main.rs:8:10: 8:14 note: in this expansion of #[derive(Copy)]     (defined in src/main.rs)"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1475873093, "post_id": 39924909, "comment_id": 67134734, "body": "X-posted here: <a href=\"https://www.reddit.com/r/rust/comments/56a91d/struct_of_structs_with_array/\" rel=\"nofollow noreferrer\">reddit.com/r/rust/comments/56a91d/struct_of_structs_with_arr&zwnj;&#8203;ay</a>"}], "answers": [{"comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 1, "creation_date": 1475872426, "post_id": 39925309, "comment_id": 67134488, "body": "Interestingly enough, I found that <code>[T; N]</code> is <b>always</b> <code>Copy</code> as long as <code>T</code> is <code>Copy</code>, but it&#39;s only <code>Clone</code> up to N = 32."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 0, "creation_date": 1475873025, "post_id": 39925309, "comment_id": 67134705, "body": "@Aurora0001: Right! It&#39;s not <code>Clone</code> however, which means that <code>_TmoveP</code> cannot be <code>Clone</code>, and it thus cannot be <code>Copy</code>. Stupid... Stupid... :("}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 1, "creation_date": 1475889573, "post_id": 39925309, "comment_id": 67138937, "body": "If you can derive <code>Copy</code> on a type, you can trivially implement <code>Clone</code> by returning <code>*self</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1475923446, "post_id": 39925309, "comment_id": 67145181, "body": "@FrancisGagn&#233;: Oh! I remember reading about that, but I completely missed it here. SO much simpler."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 3, "last_activity_date": 1475923618, "last_edit_date": 1495541802, "creation_date": 1475872084, "answer_id": 39925309, "question_id": 39924909, "link": "https://stackoverflow.com/questions/39924909/how-to-create-an-array-of-structs-containing-large-arrays/39925309#39925309", "title": "How to create an array of structs containing large arrays?", "body": "<p>In order to benefit from the initialization syntax: <code>[expr; N]</code>, the result of <code>expr</code> need to be <code>Copy</code> (as copies need be made).</p>\n\n<pre><code>#[derive(Copy, Clone)]\nstruct _Tmove {\n    data1: usize,\n    data2: u64,\n    data3: bool,\n}\n\n#[derive(Copy, Clone)]\nstruct _TmoveP {\n    data4: Box&lt;[_Tmove]&gt;,\n    data5: isize,\n}\n</code></pre>\n\n<p>However, in this case, <code>_TmoveP</code> <em>cannot</em> be <code>Copy</code> because it contains a <code>Box</code> which is not <code>Copy</code>.</p>\n\n<p>Alright, let's get rid of <code>Box</code>:</p>\n\n<pre><code>#[derive(Copy, Clone)]\nstruct _TmoveP {\n    data4: [_Tmove; 300],\n    data5: isize,\n}\n</code></pre>\n\n<p>Sounds great?</p>\n\n<p>But unfortunately, <code>[_Tmove; 300]</code> is not <code>Clone</code> either :( We are unfortunately hitting a limitation of the Rust compiler (it works for size less than 32).</p>\n\n<p>The <code>Copy</code> is easy enough... but first we have to implement <code>Clone</code> manually. The naive way is no fun, but it's easy enough:</p>\n\n<pre><code>impl Clone for _TmoveP {\n    fn clone(&amp;self) -&gt; _TmoveP {\n        unsafe {\n            let mut res = _TmoveP {\n                data4: std::mem::uninitialized(),\n                data5: self.data5,\n            };\n\n            std::ptr::copy_nonoverlapping(\n                &amp;self.data4 as *const _Tmove,\n                std::mem::transmute(&amp;mut res.data4),\n                300\n            );\n\n            res\n        }\n    }\n}\n</code></pre>\n\n<p><em>Note: for some reason <code>&amp;mut res.data4 as *mut _</code> would not compile... whatever :x</em></p>\n\n<p>However, <a href=\"https://stackoverflow.com/users/234590/francis-gagn%c3%a9\">@Francis Gagn\u00e9</a> reminded me in the comments, there is a weird trick with <code>Copy</code> types:</p>\n\n<pre><code>impl Clone for _TmoveP {\n    fn clone(&amp;self) -&gt; _TmoveP { *self }\n}\n</code></pre>\n\n<p>This works, for some reason, and is handy in those situations.</p>\n\n<p>And, finally, this works... oh wait, there's an issue in <code>main</code>!</p>\n\n<pre><code>fn main() {\n    let gen_list = Box::new([\n        _TmoveP {\n            data5: 1,\n            data4: [_Tmove { data1: 5, data2: 1, data3: true }; 300],\n        }\n        ; 100000]);\n\n    assert!(gen_list[0].data4[0].data1==5);\n}\n</code></pre>\n\n<p>Alright, <a href=\"https://play.rust-lang.org/?gist=e052d83bb94ba1dbb9543cc407ae7501&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">here we go</a>.</p>\n\n<hr>\n\n<p>What's the deal with arrays only really working for sizes smaller than 32?</p>\n\n<p>Simply put: Rust does not have (yet?) support for non-type generic parameters.</p>\n\n<p>Arrays are special-cased, to an extent, but require implementing traits for each size independently... so the standard library implements its traits for arrays up to size 32, because it seemed a good trade-off.</p>\n"}, {"comments": [{"owner": {"reputation": 395, "user_id": 4264914, "user_type": "registered", "accept_rate": 0, "profile_image": "https://i.stack.imgur.com/uMKfB.png?s=128&g=1", "display_name": "gekomad", "link": "https://stackoverflow.com/users/4264914/gekomad"}, "edited": false, "score": 0, "creation_date": 1475873392, "post_id": 39925343, "comment_id": 67134848, "body": "with rust 1.11 cargo build generates a very big executable witch 1.12 generares a small executable but goes in Segmentation fault"}, {"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "reply_to_user": {"reputation": 395, "user_id": 4264914, "user_type": "registered", "accept_rate": 0, "profile_image": "https://i.stack.imgur.com/uMKfB.png?s=128&g=1", "display_name": "gekomad", "link": "https://stackoverflow.com/users/4264914/gekomad"}, "edited": false, "score": 0, "creation_date": 1475912997, "post_id": 39925343, "comment_id": 67142774, "body": "That&#39;s odd; it seems to work fine in the playground. Be aware that you are allocating ~16 bytes for each <code>_Tmove</code> struct, then storing 300 of those and another 8 bytes for an <code>isize</code>, so about 4,800 bytes per <code>_TmoveP</code>. You&#39;re then copying that <b>100,000</b> times, which allocates about <b>450MB</b> of space. I wonder if that causes some issues; LLVM might be statically generating the array contents which would cause your executable to blow up in size."}], "tags": [], "owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "is_accepted": false, "score": 2, "last_activity_date": 1475872226, "last_edit_date": 1495540895, "creation_date": 1475872226, "answer_id": 39925343, "question_id": 39924909, "link": "https://stackoverflow.com/questions/39924909/how-to-create-an-array-of-structs-containing-large-arrays/39925343#39925343", "title": "How to create an array of structs containing large arrays?", "body": "<p>You are receiving this error because you're trying to initialise an array with the <em>default initialisation</em> syntax, but your struct does not implement the <code>Copy</code> trait, so this is not allowed. You can see the reasons <a href=\"https://stackoverflow.com/questions/27876588/why-is-the-copy-trait-needed-for-default-struct-valued-array-initialization\">here</a>, but, in a nutshell, the default initialisation syntax will create one copy of your struct, then try to copy it 100,000 times. Obviously, this isn't allowed if your struct isn't marked <code>Copy</code>, so an error is raised.</p>\n\n<p>Normally, this could be solved by marking both your structs as <code>Copy</code>, like so:</p>\n\n<pre><code>#[derive(Clone, Copy)]\nstruct _Tmove {\n    data1: usize,\n    data2: u64,\n    data3: bool,\n}\n\n#[derive(Clone, Copy)]\nstruct _TmoveP {\n    data4: Box&lt;[_Tmove]&gt;,\n    data5: isize,\n}\n</code></pre>\n\n<p>However, you'll notice that this still doesn't compile, because you've not actually got an array here. You've actually used the type for a slice (<a href=\"https://stackoverflow.com/questions/30262970/array-as-a-struct-field\">take a look at this similar issue</a>). Slices <strong>don't</strong> implement <code>Copy</code>, so your code cannot compile because the <code>_TmoveP</code> struct can only derive <code>Copy</code> if all its fields are <code>Copy</code>.</p>\n\n<p>It's unclear whether the array will <strong>always</strong> have a fixed size. If it will, then you need to use the type <code>[T; N]</code>, where <code>T</code> is your type and <code>N</code> is the number of elements (e.g. <code>[i32; 300]</code>). If not, you need a <code>Vec&lt;T&gt;</code>.</p>\n\n<p>If you use an array, you hit <em>yet another problem</em>. Arrays implement <code>Copy</code> (up to 32), but not <code>Clone</code>, and we need to implement <code>Clone</code> for <code>_TmoveP</code> before we can implement <code>Copy</code>. So, let's do it ourselves:</p>\n\n<pre><code>impl Clone for _TmoveP {\n    fn clone(&amp;self) -&gt; _TmoveP {\n        _TmoveP {\n            data4: self.data4,\n            data5: self.data5\n        }\n    }\n}\n</code></pre>\n\n<p>You can then remove the <code>#[derive(Clone)]</code> from <code>_TmoveP</code> (just leaving <code>Copy</code>), and we finally reach a working solution! <a href=\"https://play.rust-lang.org/?gist=f0467818bb4ce5202e545d78e148311a&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Here</a> is the playground link for my solution.</p>\n"}], "owner": {"reputation": 395, "user_id": 4264914, "user_type": "registered", "accept_rate": 0, "profile_image": "https://i.stack.imgur.com/uMKfB.png?s=128&g=1", "display_name": "gekomad", "link": "https://stackoverflow.com/users/4264914/gekomad"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 980, "favorite_count": 0, "answer_count": 2, "score": 2, "last_activity_date": 1475934137, "creation_date": 1475870331, "last_edit_date": 1475934137, "question_id": 39924909, "link": "https://stackoverflow.com/questions/39924909/how-to-create-an-array-of-structs-containing-large-arrays", "title": "How to create an array of structs containing large arrays?", "body": "<p>How could I create an array of structs containing big arrays with a fixed size? I want to use arrays and not vectors.</p>\n\n<p>This code is an example but doesn't compile </p>\n\n<pre><code>struct _Tmove {\n    data1: usize,\n    data2: u64,\n    data3: bool,\n}\n\nstruct _TmoveP {\n    data4: Box&lt;[_Tmove]&gt;,\n    data5: isize,\n}\n\nfn main() {\n    let mut gen_list = Box::new([\n        _TmoveP {\n            data5: 1,\n            data4: Box::new([_Tmove { data1: 5, data2: 1, data3: true }; 300]),\n        }\n        ; 100000]);\n\n    assert!(gen_list[0].data4[0].data1==5);\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `_Tmove: std::marker::Copy` is not satisfied\n--&gt; src/main.rs:16:29\n       |\n    16 |             data4: Box::new([_Tmove { data1: 5, data2: 1, data3: true }; 300]),\n                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the `Copy` trait is required because the repeated element will be copied\n\nerror[E0277]: the trait bound `_TmoveP: std::marker::Copy` is not     satisfied\n--&gt; src/main.rs:13:33\n    |\n13  |     let mut gen_list = Box::new([\n    |                                 ^\n    |\n    = note: the `Copy` trait is required because the repeated element will be copied\n</code></pre>\n\n<p>I am using Rust 1.12.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1475858497, "post_id": 39922155, "comment_id": 67127883, "body": "And to be clear, it can&#39;t be a <i>specific</i> trait object? Cause <code>fn f(t: &amp;SomeTrait)</code> would always be a trait object."}, {"owner": {"reputation": 208848, "user_id": 46642, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/wjb79.jpg?s=128&g=1", "display_name": "R. Martinho Fernandes", "link": "https://stackoverflow.com/users/46642/r-martinho-fernandes"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1475858547, "post_id": 39922155, "comment_id": 67127907, "body": "@Shepmaster Correct. Without the generics, everything is dandy."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1475858808, "creation_date": 1475858808, "answer_id": 39922271, "question_id": 39922155, "link": "https://stackoverflow.com/questions/39922155/can-i-have-a-generic-type-bound-that-requires-that-type-to-be-a-trait/39922271#39922271", "title": "Can I have a generic type bound that requires that type to be a trait?", "body": "<p>I <em>believe</em> <a href=\"https://doc.rust-lang.org/std/raw/struct.TraitObject.html\" rel=\"nofollow\">the answer is \"no\"</a>:</p>\n\n<blockquote>\n  <p>There is <strong>no way</strong> to refer to all trait objects generically</p>\n</blockquote>\n\n<p>(emphasis mine)</p>\n"}, {"comments": [{"owner": {"reputation": 208848, "user_id": 46642, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/wjb79.jpg?s=128&g=1", "display_name": "R. Martinho Fernandes", "link": "https://stackoverflow.com/users/46642/r-martinho-fernandes"}, "edited": false, "score": 0, "creation_date": 1475859656, "post_id": 39922275, "comment_id": 67128527, "body": "I&#39;ve just realized that using <code>transmute_copy</code>  instead of <code>transmute</code> is enough to have the function compile, and it seems to work properly (as long as T is a trait, of course) <a href=\"https://play.rust-lang.org/?gist=072c6e41e3887b81062c5e2672baefc3&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>. Is that the kind of low-level memory tricks you were thinking of?"}, {"owner": {"reputation": 208848, "user_id": 46642, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/wjb79.jpg?s=128&g=1", "display_name": "R. Martinho Fernandes", "link": "https://stackoverflow.com/users/46642/r-martinho-fernandes"}, "edited": false, "score": 0, "creation_date": 1475859713, "post_id": 39922275, "comment_id": 67128562, "body": "(On a side note: JESUS I have 100k+ rep and I cannot post a shortened playground link in a comment for some ungodly reason)"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 208848, "user_id": 46642, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/wjb79.jpg?s=128&g=1", "display_name": "R. Martinho Fernandes", "link": "https://stackoverflow.com/users/46642/r-martinho-fernandes"}, "edited": false, "score": 0, "creation_date": 1475860798, "post_id": 39922275, "comment_id": 67129082, "body": "@R.MartinhoFernandes: No it wasn&#39;t; it&#39;s much better actually. I am surprised it works with unsized types though since there is not <code>?Sized</code> bound <a href=\"https://doc.rust-lang.org/std/mem/fn.transmute_copy.html\" rel=\"nofollow noreferrer\">in the documentation</a>. I encourage you to post this as an answer, it&#39;s much better than fiddling around with pointers. I also encourage you to use a size check to check that at run-time that the passed-in data is <i>really</i> 128 bits (and not 64) since <code>transmute_copy</code> doesn&#39;t check (and has undefined behavior if it needs to read past the bounds of the source object)."}, {"owner": {"reputation": 208848, "user_id": 46642, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/wjb79.jpg?s=128&g=1", "display_name": "R. Martinho Fernandes", "link": "https://stackoverflow.com/users/46642/r-martinho-fernandes"}, "edited": false, "score": 0, "creation_date": 1475860876, "post_id": 39922275, "comment_id": 67129124, "body": "Yeah, I would add the size check if I take this approach. I just didn&#39;t do it in the test."}, {"owner": {"reputation": 208848, "user_id": 46642, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/wjb79.jpg?s=128&g=1", "display_name": "R. Martinho Fernandes", "link": "https://stackoverflow.com/users/46642/r-martinho-fernandes"}, "edited": false, "score": 0, "creation_date": 1475862134, "post_id": 39922275, "comment_id": 67129678, "body": "Also note that it doesn&#39;t work with unsized types. <code>Foo</code> is a trait, hence unsized, but <code>&amp;Foo</code> is a trait object and thus sized. The thing <code>transmute_copy</code> copies is <code>&amp;Foo</code> not <code>Foo</code>. (I.e. the argument is actually <code>&amp;&amp;Foo</code> in my example)"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 208848, "user_id": 46642, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/wjb79.jpg?s=128&g=1", "display_name": "R. Martinho Fernandes", "link": "https://stackoverflow.com/users/46642/r-martinho-fernandes"}, "edited": false, "score": 0, "creation_date": 1475867835, "post_id": 39922275, "comment_id": 67132421, "body": "@R.MartinhoFernandes: Ah! That must be the error I made: I must have forgotten the <code>&amp;</code> in front of the reference (called <code>transmute_copy(r)</code> instead of <code>transmute_copy(&amp;r)</code>), thus getting the compiler to complain about an unsized <code>T</code>..."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 3, "last_activity_date": 1475858814, "creation_date": 1475858814, "answer_id": 39922275, "question_id": 39922155, "link": "https://stackoverflow.com/questions/39922155/can-i-have-a-generic-type-bound-that-requires-that-type-to-be-a-trait/39922275#39922275", "title": "Can I have a generic type bound that requires that type to be a trait?", "body": "<p>It is impossible to prove a negative... but as far as I know the answer is no, sorry.</p>\n\n<p>The representation of <code>TraitObject</code> is unstable, notably because in the future Rust might be able to tack on multiple virtual pointers to a single data pointer (representing <code>&amp;(Display + Eq)</code> for example).</p>\n\n<p>In the mean time, I usually use low-level memory tricks to read the virtual pointer and data pointer then build the <code>TraitObject</code> myself; guarded by a call to <code>mem::size_of</code> to ensure that <code>&amp;T</code> has the right size for 2 <code>*mut ()</code> because <code>?Sized</code> means <code>Sized</code> or not (and not <code>!Sized</code>).</p>\n"}, {"tags": [], "owner": {"reputation": 208848, "user_id": 46642, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/wjb79.jpg?s=128&g=1", "display_name": "R. Martinho Fernandes", "link": "https://stackoverflow.com/users/46642/r-martinho-fernandes"}, "is_accepted": true, "score": 3, "last_activity_date": 1475862197, "last_edit_date": 1475862197, "creation_date": 1475861272, "answer_id": 39922880, "question_id": 39922155, "link": "https://stackoverflow.com/questions/39922155/can-i-have-a-generic-type-bound-that-requires-that-type-to-be-a-trait/39922880#39922880", "title": "Can I have a generic type bound that requires that type to be a trait?", "body": "<p>If you <a href=\"https://play.rust-lang.org/?code=%23!%5Bfeature(raw)%5D%0A%0Ause%20std%3A%3Araw%3A%3ATraitObject%3B%0Ause%20std%3A%3Amem%3B%0A%0Atrait%20Foo%20%7B%0A%20%20%20%20fn%20f(%26self)%3B%0A%7D%0A%0Astruct%20Bar%3B%0A%0Aimpl%20Foo%20for%20Bar%20%7B%0A%20%20%20%20fn%20f(%26self)%20%7B%20println!(%22ok%22)%20%7D%0A%7D%0A%0Afn%20erase%3C%27a%2C%20T%3A%20%3FSized%3E(r%3A%20%26%27a%20T)%20-%3E%20TraitObject%20%7B%20unsafe%20%7B%20mem%3A%3Atransmute_copy(%26r)%20%7D%20%7D%0Afn%20recover%3C%27a%2C%20T%3A%20%3FSized%3E(r%3A%20TraitObject)%20-%3E%20%26%27a%20T%20%7B%20unsafe%20%7B%20mem%3A%3Atransmute_copy(%26r)%20%7D%20%7D%20%0A%0Afn%20erase_foo%3C%27a%3E(r%3A%20%26%27a%20Foo)%20-%3E%20TraitObject%20%7B%20unsafe%20%7B%20mem%3A%3Atransmute(r)%20%7D%20%7D%0Afn%20recover_foo%3C%27a%3E(r%3A%20TraitObject)%20-%3E%20%26%27a%20Foo%20%7B%20unsafe%20%7B%20mem%3A%3Atransmute(r)%20%7D%20%7D%20%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20r%3A%20%26Foo%20%3D%20%26Bar%3B%0A%20%20%20%20let%20x%20%3D%20erase(r)%3B%0A%20%20%20%20let%20xf%20%3D%20erase_foo(r)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%20%7B%3A%3F%7D%22%2C%20x.data%2C%20x.vtable)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%20%7B%3A%3F%7D%22%2C%20xf.data%2C%20xf.vtable)%3B%0A%20%20%20%20let%20y%3A%20%26Foo%20%3D%20recover(x)%3B%0A%20%20%20%20let%20yf%20%3D%20recover_foo(xf)%3B%0A%20%20%20%20y.f()%3B%0A%20%20%20%20yf.f()%3B%0A%7D&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow\">use <code>transmute_copy</code> instead</a>, you can have the compiler ignore the size mismatches. This, however, means you have to handle such issues yourself, by e.g. checking the size yourself and perhaps panicking if there's a mismatch. Not doing so can result in undefined behaviour.</p>\n\n<pre><code>fn f&lt;T: ?Sized&gt;(t: &amp;T) -&gt; std::raw::TraitObject {\n    assert!(std::mem::size_of::&lt;&amp;T&gt;() == std::mem::size_of::&lt;std::raw::TraitObject&gt;());\n    unsafe { std::mem::transmute_copy(&amp;r) }\n}\n</code></pre>\n"}], "owner": {"reputation": 208848, "user_id": 46642, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/wjb79.jpg?s=128&g=1", "display_name": "R. Martinho Fernandes", "link": "https://stackoverflow.com/users/46642/r-martinho-fernandes"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 208, "favorite_count": 0, "accepted_answer_id": 39922880, "answer_count": 3, "score": 3, "last_activity_date": 1475862197, "creation_date": 1475858406, "question_id": 39922155, "link": "https://stackoverflow.com/questions/39922155/can-i-have-a-generic-type-bound-that-requires-that-type-to-be-a-trait", "title": "Can I have a generic type bound that requires that type to be a trait?", "body": "<p>I want to declare a generic function that accepts trait objects <em>and only trait objects</em>. I want this because I want to type erase these and pass them as <code>TraitObject</code> objects across an ABI boundary.</p>\n\n<p>A function written like this will fail to compile...</p>\n\n<pre><code>fn f&lt;T: ?Sized&gt;(t: &amp;T) -&gt; std::raw::TraitObject {\n    unsafe { std::mem::transmute(t) }\n}\n</code></pre>\n\n<p>... with the following error:</p>\n\n<pre><code>error[E0512]: transmute called with differently sized types: &amp;T (pointer to T) to std::raw::TraitObject (128 bits)\n</code></pre>\n\n<p>I understand why the compiler complains of different sizes: <code>&amp;T</code> can be a pointer to a concrete type (like <code>&amp;i32</code>), which is a single pointer (64 bits), or a trait object (like <code>&amp;Display</code>), which is going to be two pointers with the same layout as <code>std::raw::TraitObject</code> (128 bits).</p>\n\n<p>This function should be fine as long as <code>&amp;T</code> is a trait object, i.e. <code>T</code> is a trait. Is there a way to express this requirement?</p>\n"}, {"tags": ["nested", "rust"], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 1, "creation_date": 1475851979, "post_id": 39920073, "comment_id": 67123949, "body": "<code>cfg.ssl.as_ref().map(|ssl| &amp;ssl.key).unwrap()</code> is shorter... I&#39;m not sure if it&#39;s a <i>better</i> thing to write here, though."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1475853049, "post_id": 39920073, "comment_id": 67124645, "body": "@LukasKalbertodt: Looks a bit complicated... though of course the issue here is <code>unwrapping</code> nilly willy."}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1475854142, "post_id": 39920073, "comment_id": 67125367, "body": "Arguably you could avoid the first unwrap with <code>as_ref().and_then()</code> instead of <code>unwrap</code>, but at <i>some</i> point you have to either assert the Option is Some or reasonably handle the error."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1475863730, "post_id": 39920073, "comment_id": 67130507, "body": "@Jsor Thanks for pointing that out: my code snippet is wrong, of course. It should say <code>and_then</code> instead of <code>map</code>..."}, {"owner": {"reputation": 732, "user_id": 1787919, "user_type": "registered", "accept_rate": 67, "profile_image": "https://i.stack.imgur.com/eVgXC.jpg?s=128&g=1", "display_name": "bam", "link": "https://stackoverflow.com/users/1787919/bam"}, "reply_to_user": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1476081849, "post_id": 39920073, "comment_id": 67185058, "body": "@Jsor If we assume that some code before <code>as_ref().and_then()</code> already checks for correctness, what difference would it make to use <code>.and_then()</code>. Or the other way: What would be improved by it?"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 13, "last_activity_date": 1475888925, "last_edit_date": 1475888925, "creation_date": 1475851723, "answer_id": 39920073, "question_id": 39919780, "link": "https://stackoverflow.com/questions/39919780/access-nested-structures-without-moving/39920073#39920073", "title": "Access nested structures without moving", "body": "<p>What is the definition of <code>Option::unwrap</code>? <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap\" rel=\"noreferrer\">From the documentation</a>:</p>\n\n<pre><code>fn unwrap(self) -&gt; T\n</code></pre>\n\n<p>it consumes its input (<code>cfg.ssl</code> here).</p>\n\n<p>This is not what you want, you instead want to go from <code>Option&lt;T&gt;</code> to <code>&amp;T</code>, which will start by consuming <code>&amp;self</code> (by reference, not value)... or you want to <code>clone</code> the <code>Option</code> before calling <code>unwrap</code>.</p>\n\n<p>Cloning is rarely the solution... the alternative here is <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref\" rel=\"noreferrer\"><code>as_ref</code></a>:</p>\n\n<pre><code>fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;\n</code></pre>\n\n<p>And therefore you can write:</p>\n\n<pre><code>let keypath /*: &amp;String*/ = cfg.ssl.as_ref().unwrap().key.as_ref().unwrap();\n                                    ^~~~~~~               ^~~~~~~~\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 732, "user_id": 1787919, "user_type": "registered", "accept_rate": 67, "profile_image": "https://i.stack.imgur.com/eVgXC.jpg?s=128&g=1", "display_name": "bam", "link": "https://stackoverflow.com/users/1787919/bam"}, "edited": false, "score": 0, "creation_date": 1476081682, "post_id": 39920125, "comment_id": 67184990, "body": "Thanks for you explanation. Helped me a lot to understand the problem I had!"}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 5, "last_activity_date": 1475851878, "creation_date": 1475851878, "answer_id": 39920125, "question_id": 39919780, "link": "https://stackoverflow.com/questions/39919780/access-nested-structures-without-moving/39920125#39920125", "title": "Access nested structures without moving", "body": "<blockquote>\n  <p>So the result of <code>key.unwrap()</code> should get moved?</p>\n</blockquote>\n\n<p>Yes, but not only that. The key insight here is, that a variable get's moved into of <code>unwrap()</code>. Let's look at <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap\" rel=\"noreferrer\">the function signature</a>:</p>\n\n<pre><code>fn unwrap(self) -&gt; T { ... }\n</code></pre>\n\n<p>It takes <code>self</code>, so the object is <em>moved into the function</em>. But this applies to <code>ssl.unwrap()</code>, too!</p>\n\n<p>So when writing:</p>\n\n<pre><code>cfg.ssl.unwrap().key.unwrap();\n</code></pre>\n\n<p>You first move <code>cfg.ssl</code> into <code>unwrap()</code>, then you access one field of the result and move that field into <code>unwrap()</code> again. So yes, <code>cfg.ssl</code> is moved. In order to solve this, you can save the temporary result of the first <code>unwrap()</code> call, like so:</p>\n\n<pre><code>let ssl = cfg.ssl.unwrap();\nlet keypath = ssl.key.unwrap();\nlet certpath = ssl.cert.unwrap();\n</code></pre>\n\n<p>Or you can look at the <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref\" rel=\"noreferrer\"><code>as_ref()</code> method</a>, if you don't want to move (which is probably the case).</p>\n"}], "owner": {"reputation": 732, "user_id": 1787919, "user_type": "registered", "accept_rate": 67, "profile_image": "https://i.stack.imgur.com/eVgXC.jpg?s=128&g=1", "display_name": "bam", "link": "https://stackoverflow.com/users/1787919/bam"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1887, "favorite_count": 0, "accepted_answer_id": 39920073, "answer_count": 2, "score": 10, "last_activity_date": 1475888925, "creation_date": 1475850762, "last_edit_date": 1475852026, "question_id": 39919780, "link": "https://stackoverflow.com/questions/39919780/access-nested-structures-without-moving", "title": "Access nested structures without moving", "body": "<p>I've got these structs:</p>\n\n<pre><code>#[derive(Debug, RustcDecodable)]\nstruct Config {\n    ssl: Option&lt;SslConfig&gt;,\n}\n\n#[derive(Debug, RustcDecodable)]\nstruct SslConfig {\n    key: Option&lt;String&gt;,\n    cert: Option&lt;String&gt;,\n}\n</code></pre>\n\n<p>They get filled from a <code>toml</code> file. This works perfectly fine. Since I got an <code>Option&lt;T&gt;</code> in it I either have to call <code>unwrap()</code> or do a <code>match</code>.</p>\n\n<p>But if I want to do the following:</p>\n\n<pre><code>let cfg: Config = read_config(); // Reads a File, parses it and returns the Config-Struct\nlet keypath = cfg.ssl.unwrap().key.unwrap();\nlet certpath = cfg.ssl.unwrap().cert.unwrap();\n</code></pre>\n\n<p>It won't work because <code>cfg.ssl</code> gets moved to <code>keypath</code>. But why does it get moved? I call <code>unwrap()</code> on <code>ssl</code> to get the key (and <code>unwrap()</code> it to). So the result of <code>key.unwrap()</code> should get moved?</p>\n\n<p>Or am I missing a point? Whats the best way to make these structs accessible like this (or in a other neat way)? I tried to implement <code>#[derive(Debug, RustcDecodable, Copy, Clone)]</code> but this won't work because I have to implement <code>Copy</code> to <code>String</code> as well. Then I have to implement <code>Copy</code> to <code>Vec&lt;u8&gt;</code> and so on. There must be a more convenient solution?</p>\n"}, {"tags": ["enums", "rust"], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 14, "last_activity_date": 1526316769, "last_edit_date": 1526316769, "creation_date": 1475847543, "answer_id": 39918669, "question_id": 39918574, "link": "https://stackoverflow.com/questions/39918574/cannot-change-one-value-of-an-enum-because-its-a-re-assignment-of-an-immutable/39918669#39918669", "title": "Cannot change one value of an enum because it&#39;s a re-assignment of an immutable variable", "body": "<p>Thanks to \"match ergonomics\" (introduced in Rust 1.26, <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md\" rel=\"nofollow noreferrer\">proposed here</a>), you can write your code like this:</p>\n\n<pre><code>fn foo(baa: &amp;mut Asymmetric) {\n    match baa {\n        Asymmetric::Two(x0, _) =&gt; {\n            *x0 = 6;\n        }\n        _ =&gt; {}\n    }\n}\n</code></pre>\n\n<p>Since <code>baa</code> is a mutable reference, but your pattern you're matching against (<code>Asymmetric::Two(x0, _)</code>) is not, the name <code>x0</code> is automatically bound as mutable reference. </p>\n\n<p>You can also do it manually by using <code>ref mut</code>. See this working code (<a href=\"https://play.rust-lang.org/?gist=9d01020d7d2f3eb1b807d10c266f2606&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">playground</a>):</p>\n\n<pre><code>fn foo(baa: &amp;mut Asymmetric) {\n    match *baa {\n        Asymmetric::Two(ref mut x0, _) =&gt; {\n            *x0 = 6;\n        }\n        _ =&gt; {}\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>Some minor changes that are not related to your error, but which increase your code quality:</p>\n\n<ul>\n<li>usually you deref (with <code>*</code>) the <code>match</code>ed-on value instead of adding <code>&amp;</code> or <code>&amp;mut</code> to every pattern in the match</li>\n<li>you should use <code>_</code> as a name placeholder if you don't need to bind to that name</li>\n</ul>\n\n<p>In your case, you can simplify the code even further by using <code>if let</code>. Whenever you are only interested in one <code>match</code>-case, you should use <code>if let</code> instead:</p>\n\n<pre><code>fn foo(baa: &amp;mut Asymmetric) {\n    if let Asymmetric::Two(x0, _) = baa {\n        *x0 = 6;\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 330, "favorite_count": 1, "accepted_answer_id": 39918669, "answer_count": 1, "score": 4, "last_activity_date": 1526316769, "creation_date": 1475847268, "last_edit_date": 1475847737, "question_id": 39918574, "link": "https://stackoverflow.com/questions/39918574/cannot-change-one-value-of-an-enum-because-its-a-re-assignment-of-an-immutable", "title": "Cannot change one value of an enum because it&#39;s a re-assignment of an immutable variable", "body": "<p>I have enums that contain variables:</p>\n\n<pre><code>enum Asymmetric {\n    One(i32),\n    Two(i32, i32),\n}\n</code></pre>\n\n<p>I want to change just one field of an already existing enum, without reassigning the entire enum. My code (<a href=\"https://play.rust-lang.org/?gist=acbbeea223f17e16af5c36eda32c1295&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">playground</a>):</p>\n\n<pre><code>// Does not compile\nfn main() {\n    let two = Asymmetric::Two(4, 5);\n    let mut vec = vec![two];\n    foo(&amp;mut vec[0]);\n}\n\nfn foo(baa: &amp;mut Asymmetric) {\n    match baa {\n        &amp;mut Asymmetric::Two(x0, x1) =&gt; {\n            x0 = 6;\n        }\n        _ =&gt; {}\n    }\n}\n</code></pre>\n\n<p>This results in this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0384]: re-assignment of immutable variable `x0`\n  --&gt; src/main.rs:16:13\n   |\n15 |         &amp;mut Asymmetric::Two(x0, x1) =&gt; {\n   |                              -- first assignment to `x0`\n16 |             x0 = 6;\n   |             ^^^^^^ re-assignment of immutable variable\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1475846609, "post_id": 39917173, "comment_id": 67120533, "body": "And to be clear, it&#39;s <a href=\"http://stackoverflow.com/q/30154541/155423\"><b>absolutely possible to concatenate two Strings without Deref coercion</b></a>."}], "answers": [{"tags": [], "owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "is_accepted": false, "score": 3, "last_activity_date": 1475843497, "creation_date": 1475843497, "answer_id": 39917385, "question_id": 39917173, "link": "https://stackoverflow.com/questions/39917173/why-is-it-not-possible-to-concatenate-two-strings-in-rust-without-taking-a-refer/39917385#39917385", "title": "Why is it not possible to concatenate two Strings in Rust without taking a reference to one of them?", "body": "<p>The <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" rel=\"nofollow\">standard library</a> implements the following:</p>\n\n<pre><code>impl&lt;'a&gt; Add&lt;&amp;'a str&gt; for String\n</code></pre>\n\n<p>Which is exactly what you have noticed, you can only add a <code>&amp;str</code> to a <code>String</code>.</p>\n\n<p>This has these Advantages:</p>\n\n<ul>\n<li>Use a <code>&amp;str</code> slice</li>\n<li>Use a <code>&amp;String</code> (as it dereferences to &amp;str)</li>\n<li>Keep the old String (that has been added)</li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 11, "last_activity_date": 1475844088, "last_edit_date": 1475844088, "creation_date": 1475843520, "answer_id": 39917395, "question_id": 39917173, "link": "https://stackoverflow.com/questions/39917173/why-is-it-not-possible-to-concatenate-two-strings-in-rust-without-taking-a-refer/39917395#39917395", "title": "Why is it not possible to concatenate two Strings in Rust without taking a reference to one of them?", "body": "<p>The answer is in two parts.</p>\n\n<hr>\n\n<p>The first part is that <code>+</code> involves using <a href=\"https://doc.rust-lang.org/std/ops/trait.Add.html\">an <code>Add</code> trait implementation</a>. It is implemented only for:</p>\n\n<pre><code>impl&lt;'a&gt; Add&lt;&amp;'a str&gt; for String\n</code></pre>\n\n<p>Therefore, string concatenation only works when:</p>\n\n<ul>\n<li>the Left Hand Side is a <code>String</code></li>\n<li>the Right Hand Side is coercible to a <code>&amp;str</code></li>\n</ul>\n\n<p><em>Note: unlike many other languages, addition will consume the Left Hand Side argument.</em></p>\n\n<hr>\n\n<p>The second part, therefore, is what kind of arguments can be used when a <code>&amp;str</code> is expected?</p>\n\n<p>Obviously, a <code>&amp;str</code> can be used as is:</p>\n\n<pre><code>let hello = \"Hello \".to_string();\nlet hello_world = hello + \"world!\";\n</code></pre>\n\n<p>Otherwise, a reference to a type implementing <code>Deref&lt;&amp;str&gt;</code> will work, and it turns out that <code>String</code> does so <code>&amp;String</code> works:</p>\n\n<pre><code>let hello = \"Hello \".to_string();\nlet world = \"world!\".to_string();\n\nlet hello_world = hello + &amp;world;\n</code></pre>\n\n<hr>\n\n<p>And what of other implementations? They all have issues.</p>\n\n<ul>\n<li><code>impl&lt;'a&gt; Add&lt;String&gt; for &amp;'a str</code> requires prepending, which is not as efficient as appending</li>\n<li><code>impl Add&lt;String&gt; for String</code> needlessly consume two arguments when one is sufficient</li>\n<li><code>impl&lt;'a, 'b&gt; Add&lt;&amp;'a str&gt; for &amp;'b str</code> hides an unconditional memory allocation</li>\n</ul>\n\n<p>In the end, the asymmetric choice is explained by Rust philosophy of being explicit as much as possible.</p>\n\n<p>Or to be more explicit, we can explain the choice by checking the algorithmic complexity of the operation. Assuming that the left-hand side has size M and the right-hand side has size N, then:</p>\n\n<ul>\n<li><code>impl&lt;'a&gt; Add&lt;&amp;'a str&gt; for String</code> is O(N) (amortized)</li>\n<li><code>impl&lt;'a&gt; Add&lt;String&gt; for &amp;'a str</code> is O(M+N)</li>\n<li><code>impl&lt;'a, 'b&gt; Add&lt;&amp;'a str&gt; for &amp;'b str</code> is O(M+N)</li>\n<li><code>impl Add&lt;String&gt; for String</code> is O(N) (amortized)... but requires allocating/cloning the right-hand side for nothing.</li>\n</ul>\n"}], "owner": {"reputation": 794, "user_id": 969501, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5036fe7c0d0093c868efa588bf7bda21?s=128&d=identicon&r=PG", "display_name": "dnshio", "link": "https://stackoverflow.com/users/969501/dnshio"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2326, "favorite_count": 1, "accepted_answer_id": 39917395, "answer_count": 2, "score": 4, "last_activity_date": 1566086594, "creation_date": 1475842825, "last_edit_date": 1566086594, "question_id": 39917173, "link": "https://stackoverflow.com/questions/39917173/why-is-it-not-possible-to-concatenate-two-strings-in-rust-without-taking-a-refer", "title": "Why is it not possible to concatenate two Strings in Rust without taking a reference to one of them?", "body": "<p>This works:</p>\n\n<pre><code>let hello = \"Hello \".to_string();\nlet world = \"world!\";\n\nlet hello_world = hello + world;\n</code></pre>\n\n<p>But this doesn't:</p>\n\n<pre><code>let hello = \"Hello \".to_string();\nlet world = \"world!\".to_string();\n\nlet hello_world = hello + world;\n</code></pre>\n\n<p>But this does:</p>\n\n<pre><code>let hello = \"Hello \".to_string();\nlet world = \"world!\".to_string();\n\nlet hello_world = hello + &amp;world;\n</code></pre>\n\n<p>Is that because the <code>String</code> needs a pointer to the original string slice of the second <code>String</code>? If so, why?</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1475808953, "post_id": 39907955, "comment_id": 67102348, "body": "You can find a somewhat similar case (though with a hidden leak due to the same lifetime of both affected objects) in <a href=\"http://stackoverflow.com/q/39827244/1870153\">this question</a>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1475822736, "post_id": 39907955, "comment_id": 67106599, "body": "See also <a href=\"http://stackoverflow.com/questions/28108689/how-to-initialize-a-variable-with-a-lifetime\">How to initialize a variable with a lifetime?</a> =&gt; you cannot, a lifetime <i>annotation</i> does not enforce a lifetime, it merely documents it."}], "answers": [{"tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": true, "score": 6, "last_activity_date": 1475804391, "last_edit_date": 1475804391, "creation_date": 1475803880, "answer_id": 39908023, "question_id": 39907955, "link": "https://stackoverflow.com/questions/39907955/declaring-lifetime-on-a-test-function/39908023#39908023", "title": "Declaring lifetime on a test function", "body": "<p>What this is telling you is.. </p>\n\n<p>Everything is dropped in reverse order.. <code>cost_1</code> will be dropped before <code>queue</code>.. because its declared after <code>queue</code>. So <code>queue</code> has a reference to <code>cost_1</code> and because the values are now being dropped at the end of the method <code>queue</code> now has a reference to... nothing? <code>cost_1</code> has been dropped while <code>queue</code> is still \"alive\" - even though its about to be dropped as well.</p>\n\n<p>To be clear, the sequence of events matters because the <code>BinaryHeap</code> instance is storing <em>references</em>. It does not own its contents.</p>\n\n<p>The sequence of events will be:</p>\n\n<ul>\n<li>Declare a <code>BinaryHeap</code> instance that stores <em>references</em>.</li>\n<li>Declare <code>cost_1</code>, <code>cost_2</code> and <code>cost_3</code>, whose <em>references</em> will be inserted into the <code>BinaryHeap</code>.</li>\n<li>Add references into <code>BinaryHeap</code>.</li>\n<li>Perform assertion.</li>\n<li>Drop <code>cost_3</code>.</li>\n<li>Drop <code>cost_2</code>.</li>\n<li>Drop <code>cost_1</code>.</li>\n<li><strong>What do the <code>BinaryHeap</code> references point to now? The items are dropped.</strong></li>\n<li>Drop <code>BinaryHeap</code>.</li>\n</ul>\n\n<p>The bolded item in the above list is what the compiler is protecting you from. Potentially invalid pointers.</p>\n\n<p>The easy fix.. is to reverse the declaration order such that any references to <code>cost_1</code> outlive <code>queue</code>:</p>\n\n<pre><code>let cost_1: NodeCost = NodeCost::new(1, 50, 0);\nlet cost_2: NodeCost = NodeCost::new(2, 30, 0);\nlet cost_3: NodeCost = NodeCost::new(3, 80, 0);\nlet mut queue: BinaryHeap&lt;&amp;NodeCost&gt; = BinaryHeap::new();\n</code></pre>\n\n<p>Here is a working <a href=\"https://play.rust-lang.org/?gist=6782814780e3f22c0891ed221cede677&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">example on the playground</a></p>\n\n<p>The order of events will now be:</p>\n\n<ul>\n<li>Declare <code>cost_1</code>, <code>cost_2</code> and <code>cost_3</code>, whose <em>references</em> will be inserted into the <code>BinaryHeap</code>.</li>\n<li>Declare a <code>BinaryHeap</code> instance that stores <em>references</em>.</li>\n<li>Add references into <code>BinaryHeap</code>.</li>\n<li>Perform assertion.</li>\n<li><strong>Drop <code>BinaryHeap</code>.</strong> The references can go away because the items they reference are still alive.</li>\n<li>Drop <code>cost_3</code>.</li>\n<li>Drop <code>cost_2</code>.</li>\n<li>Drop <code>cost_1</code>.</li>\n</ul>\n"}], "owner": {"reputation": 33796, "user_id": 45525, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/TKzgD.png?s=128&g=1", "display_name": "Synesso", "link": "https://stackoverflow.com/users/45525/synesso"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 130, "favorite_count": 0, "accepted_answer_id": 39908023, "answer_count": 1, "score": 1, "last_activity_date": 1475804391, "creation_date": 1475803165, "question_id": 39907955, "link": "https://stackoverflow.com/questions/39907955/declaring-lifetime-on-a-test-function", "title": "Declaring lifetime on a test function", "body": "<p>I have a test in progress that does not compile:</p>\n\n<pre><code>#[test]\nfn node_cost_dequeue() {\n    let mut queue: BinaryHeap&lt;&amp;NodeCost&gt; = BinaryHeap::new();\n    let cost_1: NodeCost = NodeCost::new(1, 50, 0);\n    let cost_2: NodeCost = NodeCost::new(2, 30, 0);\n    let cost_3: NodeCost = NodeCost::new(3, 80, 0);\n    queue.push(&amp;cost_1);\n    queue.push(&amp;cost_2);\n    queue.push(&amp;cost_3);\n    assert_eq!(2, (*queue.pop().unwrap()).id);\n}\n</code></pre>\n\n<p>Results in <code>error: cost_1 does not live long enough</code></p>\n\n<p>With the additional info that \"borrowed value dropped before borrower\".</p>\n\n<p>So I attempt to add explicit lifetime annotations.</p>\n\n<pre><code>#[test]\nfn node_cost_dequeue() {\n    let mut queue: BinaryHeap&lt;&amp;'a NodeCost&gt; = BinaryHeap::new();\n    let cost_1: NodeCost&lt;'a&gt; = NodeCost::new(1, 50, 0);\n    let cost_2: NodeCost&lt;'a&gt; = NodeCost::new(2, 30, 0);\n    let cost_3: NodeCost&lt;'a&gt; = NodeCost::new(3, 80, 0);\n    queue.push(&amp;cost_1);\n    queue.push(&amp;cost_2);\n    queue.push(&amp;cost_3);\n    assert_eq!(2, (*queue.pop().unwrap()).id);\n}\n</code></pre>\n\n<p>This results in <code>use of undeclared lifetime name 'a</code>.</p>\n\n<p>So, I attempt to declare it on the function</p>\n\n<pre><code>fn node_cost_dequeue&lt;'a&gt;() -&gt; () {\n</code></pre>\n\n<p>But this results in <code>error: functions used as tests must have signature fn() -&gt; ()</code></p>\n\n<p>Am I on the right track? How do I declare this lifetime?</p>\n"}, {"tags": ["rust", "closures"], "answers": [{"comments": [{"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 1, "creation_date": 1475795462, "post_id": 39906306, "comment_id": 67099402, "body": "Your first two have a (potential) runtime cost, too, since they involve dynamic dispatch. AFAIK the only solution is to use <code>impl Trait</code>."}, {"owner": {"reputation": 4257, "user_id": 3347227, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/160c472b1c6c43b47cc98cc01d3ce317?s=128&d=identicon&r=PG", "display_name": "Erik Vesteraas", "link": "https://stackoverflow.com/users/3347227/erik-vesteraas"}, "edited": false, "score": 0, "creation_date": 1475796320, "post_id": 39906306, "comment_id": 67099628, "body": "You should probably mention that your first example won&#39;t work directly as the closure doesn&#39;t last long enough (unless I am missing something)."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "reply_to_user": {"reputation": 4257, "user_id": 3347227, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/160c472b1c6c43b47cc98cc01d3ce317?s=128&d=identicon&r=PG", "display_name": "Erik Vesteraas", "link": "https://stackoverflow.com/users/3347227/erik-vesteraas"}, "edited": false, "score": 1, "creation_date": 1475799666, "post_id": 39906306, "comment_id": 67100339, "body": "@ErikVesteraas TIL borrowck runs after the \u201cmain function not found\u201d which is a fatal error"}, {"owner": {"user_type": "does_not_exist", "display_name": "user6157733"}, "edited": false, "score": 0, "creation_date": 1476369267, "post_id": 39906306, "comment_id": 67324988, "body": "@mcarton by runtime cost, do you mean the cost of heap allocation? Or is there something more involved with rust&#39;s Box?"}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 1, "creation_date": 1476376822, "post_id": 39906306, "comment_id": 67330439, "body": "@JeffQuick the cost is a heap allocation once + dynamic dispatch every time the function is called. As @veedrac mentioned, <code>-&gt; impl Trait</code> is also a solution if working on a nightly is acceptable."}], "tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": true, "score": 3, "last_activity_date": 1476377123, "last_edit_date": 1476377123, "creation_date": 1475791385, "answer_id": 39906306, "question_id": 39906215, "link": "https://stackoverflow.com/questions/39906215/can-a-function-return-a-closure-taking-string-arguments-and-return-values/39906306#39906306", "title": "Can a function return a closure taking String arguments and return values?", "body": "<p><code>Fn</code> is a trait. You can't return a trait. You can return a function pointer though:</p>\n\n<pre><code>fn closure_thing() -&gt; (fn(String) -&gt; String) {\n    fn foo(thing: String) -&gt; String {\n        \u2026\n    }\n\n    foo\n}\n</code></pre>\n\n<p>You can also return a <code>Box</code>:</p>\n\n<pre><code>fn closure_thing() -&gt; Box&lt;Fn(String) -&gt; String&gt; {\n    Box::new(|thing| {\n        \u2026\n    })\n}\n</code></pre>\n\n<p>But that one has a runtime cost, so should be considered as a last resort.</p>\n\n<p>As mentioned by @Veedrac, you can also use <code>impl Trait</code>:</p>\n\n<pre><code>#![feature(conservative_impl_trait)]\n\nfn closure_thing() -&gt; impl Fn(String) -&gt; String {\n    |thing| {\n        \u2026\n    }\n}\n</code></pre>\n\n<p>But as of Rust 1.12 this is not stable yet and requires a nightly compiler. It allows you to return any trait, without the runtime cost of the previous solution.</p>\n"}, {"tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 2, "last_activity_date": 1475791924, "last_edit_date": 1475791924, "creation_date": 1475791423, "answer_id": 39906313, "question_id": 39906215, "link": "https://stackoverflow.com/questions/39906215/can-a-function-return-a-closure-taking-string-arguments-and-return-values/39906313#39906313", "title": "Can a function return a closure taking String arguments and return values?", "body": "<blockquote>\n  <p>the return type of a function must have a statically known size</p>\n</blockquote>\n\n<p>One way to achieve that is to box the closure...</p>\n\n<pre><code>fn closure_thing() -&gt; Box&lt;Fn(String) -&gt; String&gt; {\n    Box::new(|thing| {\n        (&amp;thing[1..4]).to_string()\n    })\n}\n</code></pre>\n\n<p>Note that I also converted the result to a <code>String</code>.. since slicing it will return a <code>str</code>.</p>\n\n<p>As noted by mcarton, boxing will incur a runtime cost for the heap allocation.</p>\n"}], "owner": {"reputation": 2324, "user_id": 2272652, "user_type": "registered", "accept_rate": 87, "profile_image": "https://i.stack.imgur.com/vKcw7.jpg?s=128&g=1", "display_name": "Christian Grabowski", "link": "https://stackoverflow.com/users/2272652/christian-grabowski"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 345, "favorite_count": 0, "accepted_answer_id": 39906306, "answer_count": 2, "score": 2, "last_activity_date": 1593112863, "creation_date": 1475790975, "last_edit_date": 1593112863, "question_id": 39906215, "link": "https://stackoverflow.com/questions/39906215/can-a-function-return-a-closure-taking-string-arguments-and-return-values", "title": "Can a function return a closure taking String arguments and return values?", "body": "<p>If I'm returning a closure defined as such:</p>\n<pre><code>fn closure_thing() -&gt; (Fn(String) -&gt; String) {\n    |thing| {\n        thing[1..4]\n    }\n}\n</code></pre>\n<p>I receive an error of:</p>\n<pre><code>= note: `std::ops::Fn(std::string::String) -&gt; std::string::String + 'static` does not have a constant size known at compile-time\n= note: the return type of a function must have a statically known size`\n</code></pre>\n<p>I have tried <code>Fn(&amp;String) -&gt; &amp;String</code> as well.  Is there an easy way for a closure to take a string as an argument and return a string?</p>\n"}, {"tags": ["ubuntu", "rust", "rust-cargo"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 2, "creation_date": 1475778958, "post_id": 39903276, "comment_id": 67092043, "body": "Can you show us the output of <code>cargo build --verbose</code>?"}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 1, "creation_date": 1475779008, "post_id": 39903276, "comment_id": 67092070, "body": "That step clones the repository <code>https:&#47;&#47;github.com&#47;rust-lang&#47;crates.io-index</code>. What happens when you try to do that yourself?"}, {"owner": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "edited": false, "score": 4, "creation_date": 1475785742, "post_id": 39903276, "comment_id": 67095654, "body": "This is probably a silly question but are you connected to the internet?"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1475806927, "post_id": 39903276, "comment_id": 67101871, "body": "Also, stuck on for <i>how long?</i>  I&#39;ve had cases where updating the registry took over half an hour, with no visible progress.  It <i>was</i> working... just unfathomably slowly."}, {"owner": {"reputation": 3377, "user_id": 3405842, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/iiJWf.jpg?s=128&g=1", "display_name": "GrvTyagi", "link": "https://stackoverflow.com/users/3405842/grvtyagi"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1475821655, "post_id": 39903276, "comment_id": 67106086, "body": "@ljedrz it just show me &gt;&gt; Updating registry <code>https:&#47;&#47;github.com&#47;rust-lang&#47;crates.io-index</code> and wait."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1475821917, "post_id": 39903276, "comment_id": 67106198, "body": "@GrvTyagi I was hoping for something more informative; what is your Internet connection speed? How long have you let this command run? Does it break at any point in time?"}, {"owner": {"reputation": 3377, "user_id": 3405842, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/iiJWf.jpg?s=128&g=1", "display_name": "GrvTyagi", "link": "https://stackoverflow.com/users/3405842/grvtyagi"}, "edited": false, "score": 0, "creation_date": 1475822446, "post_id": 39903276, "comment_id": 67106458, "body": "yah my internet was too slow last night, now it is working fine. sorry for time."}, {"owner": {"reputation": 1600, "user_id": 771071, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/79354d20a5c400b2a8c31341fc7a3d39?s=128&d=identicon&r=PG", "display_name": "Joseph Callaars", "link": "https://stackoverflow.com/users/771071/joseph-callaars"}, "edited": false, "score": 0, "creation_date": 1476192627, "post_id": 39903276, "comment_id": 67235549, "body": "Consider removing your question."}], "owner": {"reputation": 3377, "user_id": 3405842, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/iiJWf.jpg?s=128&g=1", "display_name": "GrvTyagi", "link": "https://stackoverflow.com/users/3405842/grvtyagi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 377, "favorite_count": 0, "answer_count": 0, "score": 2, "last_activity_date": 1486295194, "creation_date": 1475778709, "last_edit_date": 1477322210, "question_id": 39903276, "link": "https://stackoverflow.com/questions/39903276/cargo-build-stuck-when-add-rand-0-3-0-in-cargo-toml-file", "title": "cargo build stuck when add rand = &quot;0.3.0&quot; in Cargo.toml file", "body": "<p>I am trying the Rust guessing game</p>\n\n<p>My <code>Cargo.toml</code>:</p>\n\n<pre><code>[package]\nname = \"guessing_game\"\nversion = \"0.1.0\"\nauthors = [\"grv07\"]\n[dependencies]\nrand = \"0.3.0\"\n</code></pre>\n\n<p>Now when I run <code>cargo build</code>, it is stuck on:</p>\n\n<pre><code>Updating registry `https://github.com/rust-lang/crates.io-index`\n</code></pre>\n"}, {"tags": ["rust", "rust-cargo"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1475737604, "post_id": 39888534, "comment_id": 67065296, "body": "I would probably go with a <a href=\"http://doc.crates.io/build-script.html\" rel=\"nofollow noreferrer\">build script</a> and a couple of <code>include</code> macros; I don&#39;t think there is a better option available at the moment."}, {"owner": {"reputation": 5005, "user_id": 573149, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/Wn0FW.jpg?s=128&g=1", "display_name": "Andrew Mackenzie", "link": "https://stackoverflow.com/users/573149/andrew-mackenzie"}, "edited": false, "score": 0, "creation_date": 1517779064, "post_id": 39888534, "comment_id": 84222802, "body": "I&#39;m trying to solve the same problem. Looks like installing a platform specific bundle with resource files maybe the only way. I&#39;ve looked at cargo-bundle but not really working for me yet."}], "answers": [{"tags": [], "owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "is_accepted": false, "score": 5, "last_activity_date": 1517761687, "last_edit_date": 1517761687, "creation_date": 1475740195, "answer_id": 39890448, "question_id": 39888534, "link": "https://stackoverflow.com/questions/39888534/how-do-i-access-assets-included-in-a-rust-cargo-project-installed-via-cargo-ins/39890448#39890448", "title": "How do I access assets included in a Rust/Cargo project installed via `cargo install`?", "body": "<p>Depending on how you want it structured, you could try a mix of <a href=\"https://doc.rust-lang.org/std/env/fn.current_dir.html\" rel=\"nofollow noreferrer\"><code>env::current_dir</code></a> to get the current directory, and if that doesn't find anything you can try using the executable path and load things from there. You get that with <a href=\"https://doc.rust-lang.org/std/env/fn.current_exe.html\" rel=\"nofollow noreferrer\"><code>env::current_exe</code></a>.</p>\n\n<hr>\n\n<p>I see the difficulty, which is that <code>cargo install</code> <em>only</em> copies the binary into <code>.cargo/bin</code> which means that additional resources stay in the source folder located at <code>.cargo/registry/src/...</code>.</p>\n\n<p>In this case, I <a href=\"https://stackoverflow.com/questions/39888534/assets-included-in-a-rust-cargo-project#comment67065296_39888534\">agree with @ljedrz</a> that <a href=\"https://doc.rust-lang.org/nightly/std/macro.include.html\" rel=\"nofollow noreferrer\"><code>include!</code></a> seems to be the only way.</p>\n"}, {"tags": [], "owner": {"reputation": 2093, "user_id": 912757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/b38d27249794c92de5cb131b848cdd89?s=128&d=identicon&r=PG", "display_name": "Nil", "link": "https://stackoverflow.com/users/912757/nil"}, "is_accepted": false, "score": 0, "last_activity_date": 1517761720, "last_edit_date": 1517761720, "creation_date": 1513695814, "answer_id": 47889785, "question_id": 39888534, "link": "https://stackoverflow.com/questions/39888534/how-do-i-access-assets-included-in-a-rust-cargo-project-installed-via-cargo-ins/47889785#47889785", "title": "How do I access assets included in a Rust/Cargo project installed via `cargo install`?", "body": "<p>In my private project, I had to replace a \"open, seek, read\" by a <code>include_bytes!</code> because, as you wrote, <code>cargo install</code> doesn't handle assets. Here's an example:</p>\n\n<p><strong><code>File::open</code></strong> version</p>\n\n<pre><code>let mut f = File::open(\"examples/vertices.npy\")\n    .expect(\"Can't read file 'examples/vertices.npy'\");\nf.seek(SeekFrom::Start(80)).unwrap();\nlet mut reader = BufReader::new(f);\n</code></pre>\n\n<p><strong><code>include_bytes!</code></strong> version</p>\n\n<pre><code>let vertices_bytes = include_bytes!(\"vertices.npy\");\nlet mut reader = BufReader::new(&amp;vertices_bytes[80..]);\n</code></pre>\n\n<p>I still prefer the normal reader and I'll change it when Rust supports it, but it's still a good solution while we wait.</p>\n"}], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1758, "favorite_count": 2, "answer_count": 2, "score": 15, "last_activity_date": 1517761720, "creation_date": 1475733450, "last_edit_date": 1517761629, "question_id": 39888534, "link": "https://stackoverflow.com/questions/39888534/how-do-i-access-assets-included-in-a-rust-cargo-project-installed-via-cargo-ins", "title": "How do I access assets included in a Rust/Cargo project installed via `cargo install`?", "body": "<p>I have a project which includes some associated assets (Lua scripts), which I need to find at runtime.  This can mean two things:</p>\n\n<ul>\n<li>During development (e.g. <code>cargo run</code>), I want to find it relative to the source</li>\n<li>When installed via <code>cargo install</code>, the assets should be installed somewhere as well, and the installed version of the executable should find the installed assets.</li>\n</ul>\n\n<p>I know about the option to use something like <code>include_str!()</code> to compile text files into the binary, but I don't want to do that in this case.</p>\n\n<p>As far as I can tell, <code>cargo install</code> <a href=\"https://github.com/rust-lang/cargo/issues/2729\" rel=\"nofollow noreferrer\">doesn't have any support for installing anything other than the executable at the moment</a>, which is the first problem, though I don't mind having a wrapper install script to help.</p>\n"}, {"tags": ["struct", "rust", "mutability"], "comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 2, "creation_date": 1475733010, "post_id": 39888301, "comment_id": 67063102, "body": "It&#39;s not mutable because you specifically said that it shouldn&#39;t be mutable.  Is there some reason you can&#39;t just use <code>&amp;&#39;name mut Name</code>?  <b>Edit</b>: also, you don&#39;t make fields mutable; a field is mutable or not depending on how you reach it, and in this case, you reach it via <code>Person.name</code>, which is an immutable pointer."}], "answers": [{"tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 2, "last_activity_date": 1475761053, "last_edit_date": 1475761053, "creation_date": 1475732860, "answer_id": 39888382, "question_id": 39888301, "link": "https://stackoverflow.com/questions/39888301/how-to-make-this-field-mutable/39888382#39888382", "title": "How to make this field mutable?", "body": "<p>By marking the field as a mutable reference:</p>\n\n<pre><code>pub struct Person&lt;'name&gt;{\n    name:&amp;'name mut Name\n} //            ^^^ mutable\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=64501a5c02e7caa05c183ff3afc0818f&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">Playground</a></p>\n"}, {"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 7, "last_activity_date": 1475733308, "last_edit_date": 1475733308, "creation_date": 1475732873, "answer_id": 39888384, "question_id": 39888301, "link": "https://stackoverflow.com/questions/39888301/how-to-make-this-field-mutable/39888384#39888384", "title": "How to make this field mutable?", "body": "<p>Looking at your <code>Person</code> struct:</p>\n\n<pre><code>pub struct Person&lt;'name&gt;{\n    name:&amp;'name Name\n}\n</code></pre>\n\n<p>The <code>name</code> field is an <em>immutable</em> reference, so you can't write through it.  Simply make it a mutable reference:</p>\n\n<pre><code>pub struct Person&lt;'name&gt;{\n    name:&amp;'name mut Name\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=be4b757bd880d46f2ec2b7aff5b9a187&amp;version=stable&amp;backtrace=0\">playground</a>)</p>\n"}, {"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 1, "last_activity_date": 1475761685, "last_edit_date": 1475761685, "creation_date": 1475759004, "answer_id": 39896785, "question_id": 39888301, "link": "https://stackoverflow.com/questions/39888301/how-to-make-this-field-mutable/39896785#39896785", "title": "How to make this field mutable?", "body": "<p>I think you expected <code>person.name</code> to be mutable due to the way you implemented the <code>new()</code> method for <code>Person</code>, where the <code>name</code> argument is a mutable reference to a <code>Name</code> struct:</p>\n\n<pre><code>fn new(name: &amp;'name mut Name)\n</code></pre>\n\n<p>But this only means the function argument needs to be one - it doesn't result in the fact that the target <code>Person</code>'s field can be mutated. You can pass a mutable reference to a target expecting an immutable reference, but you can't do it the other way round; you would get a <code>values differ in mutability</code> error.</p>\n\n<p>As the others correctly pointed out, the field needs to be explicitly marked as <code>mut</code>able in order to allow its mutability:</p>\n\n<pre><code>struct Person&lt;'name&gt;{\n    name: &amp;'name mut Name\n}\n</code></pre>\n"}], "owner": {"reputation": 4354, "user_id": 5967828, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/fJ7P2.jpg?s=128&g=1", "display_name": "xetra11", "link": "https://stackoverflow.com/users/5967828/xetra11"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 126, "favorite_count": 0, "answer_count": 3, "score": 1, "last_activity_date": 1475761685, "creation_date": 1475732426, "last_edit_date": 1475733447, "question_id": 39888301, "link": "https://stackoverflow.com/questions/39888301/how-to-make-this-field-mutable", "title": "How to make this field mutable?", "body": "<p>I'm stuck here for some time now and cannot figure out how to make the field <code>word</code> mutable. Can somebody please point me out the issue here.</p>\n\n<pre><code>pub struct Person&lt;'name&gt;{\n    name:&amp;'name Name\n}\n\npub struct Name{\n     word: String\n}\n\nimpl&lt;'name&gt; Person&lt;'name&gt;{\n    pub fn new(name:&amp;'name mut Name)-&gt; Person&lt;'name&gt;{\n        Person {\n            name: name\n        }\n    }\n}\n\nfn main(){\n    let mut name: Name = Name {\n        word: String::from(\"Petre\")\n    };\n    let mut person: Person = Person::new(&amp;mut name);\n    first(&amp;mut person);\n\n}\n\npub fn first(person:&amp;mut Person){\n    person.name.word = String::from(\"Wurst\");\n    second(person);\n}\n\npub fn second(person:&amp;mut Person){\n    println!(\"{}\",person.name.word)\n}\n</code></pre>\n\n<p><strong>Output</strong></p>\n\n<blockquote>\n<pre><code>error: cannot assign to immutable field `person.name.word`\n  --&gt; main.rs:27:5\n   |\n27 |     person.name.word = String::from(\"Wurst\");\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre>\n</blockquote>\n"}]