[{"tags": ["rust", "copy-on-write"], "comments": [{"owner": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "edited": false, "score": 3, "creation_date": 1485382663, "post_id": 41862596, "comment_id": 70909147, "body": "I think you might be interested in the <code>Into</code> trait. You can then constraint generic types in your function."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 3, "creation_date": 1485416174, "post_id": 41863579, "comment_id": 70919418, "body": "Note: This is one place where the shadowing is really interesting, if you rename the argument <code>x</code> then after shadowing it you can&#39;t accidentally reference it any longer."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 5, "last_activity_date": 1485387027, "last_edit_date": 1485387027, "creation_date": 1485386867, "answer_id": 41863579, "question_id": 41862596, "link": "https://stackoverflow.com/questions/41862596/is-it-possible-to-coerce-slices-vectors-into-cowtype-in-function-arguments/41863579#41863579", "title": "Is it possible to coerce slices/vectors into &#39;Cow&lt;[type]&gt;&#39; in function arguments?", "body": "<p>The <a href=\"https://doc.rust-lang.org/std/convert/trait.Into.html\" rel=\"nofollow noreferrer\"><code>Into</code></a> trait is what you want.  Declare the function to take <code>Into&lt;Cow&lt;'a, [T]&gt;&gt;</code> and call the <code>into()</code> method in the function:</p>\n\n<pre><code>use std::borrow::Cow;\n\nfn foo&lt;'a, T: Into&lt;Cow&lt;'a, [u8]&gt;&gt;&gt;(v: T) {\n    let x = v.into();\n    println!(\"{:?}\", x);\n}\n\nfn main() {\n    let v = vec![0,1,2];\n    let s = &amp;[3,4,5];\n    foo(v);\n    foo(&amp;s[..]);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=325cf69d37a76c65b368f024dd1fe797&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 298, "favorite_count": 0, "accepted_answer_id": 41863579, "answer_count": 1, "score": 2, "last_activity_date": 1485387027, "creation_date": 1485382246, "last_edit_date": 1485386951, "question_id": 41862596, "link": "https://stackoverflow.com/questions/41862596/is-it-possible-to-coerce-slices-vectors-into-cowtype-in-function-arguments", "title": "Is it possible to coerce slices/vectors into &#39;Cow&lt;[type]&gt;&#39; in function arguments?", "body": "<p>When moving an API to use <code>Cow&lt;[sometype]&gt;</code>, having to replace:</p>\n\n<pre><code>some_func(arg1, arg2, arg3);\n</code></pre>\n\n<p>With:</p>\n\n<pre><code>some_func(Cow::from(&amp;arg1[..]), Cow::from(&amp;arg2[..]), Cow::from(&amp;arg3[..]));\n</code></pre>\n\n<p>Is fairly dense syntax.</p>\n\n<p>Is there a way that vectors or slices can be coerced into their <code>Cow</code> equivalents when passed as function arguments?</p>\n\n<hr>\n\n<p>There might be good reason <strong>not</strong> to do this, for example if you used the same argument to a function many times, the explicit syntax is a hint the <code>Cow&lt;[]&gt;</code> version should be assigned a variable and kept. However, I'm interested to know if this is possible.</p>\n"}, {"tags": ["rust", "type-safety", "borrow-checker"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485352538, "post_id": 41852283, "comment_id": 70890462, "body": "You should review the source of <a href=\"https://github.com/bluss/petgraph\" rel=\"nofollow noreferrer\">petgraph</a>."}, {"owner": {"reputation": 1552, "user_id": 3145469, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/40ef74077e497553ad7a6ce20a1fc38b?s=128&d=identicon&r=PG&f=1", "display_name": "MrMobster", "link": "https://stackoverflow.com/users/3145469/mrmobster"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485420485, "post_id": 41852283, "comment_id": 70921458, "body": "I have posted a follow up question here: <a href=\"http://stackoverflow.com/questions/41869672/destructuring-a-struct-containing-a-borrow-in-function-argument-rust\" title=\"destructuring a struct containing a borrow in function argument rust\">stackoverflow.com/questions/41869672/&hellip;</a> I though that the question was sufficiently different to warrant opening a new one."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485352744, "post_id": 41853407, "comment_id": 70890616, "body": "Note: the second request is slightly more subtle; it&#39;s not about preventing the creation of <code>edge2</code>, but enforcing that <code>edge2</code> be dropped before <code>edge1</code>."}, {"owner": {"reputation": 1552, "user_id": 3145469, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/40ef74077e497553ad7a6ce20a1fc38b?s=128&d=identicon&r=PG&f=1", "display_name": "MrMobster", "link": "https://stackoverflow.com/users/3145469/mrmobster"}, "edited": false, "score": 0, "creation_date": 1485353554, "post_id": 41853407, "comment_id": 70891215, "body": "The problem with this solution is that it only allows one edge index to exist. However, this limitation is too severe. Example: <code>graph.join(edge1, edge2)</code>"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1485354273, "post_id": 41853407, "comment_id": 70891726, "body": "Actually, that only applies to mutable edges. You can create arbitrary numbers of immutable edges and use them for the <code>join</code> method."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1485354325, "post_id": 41853407, "comment_id": 70891752, "body": "Rust has lexical borrows, you need to use scopes to ensure the lifetimes, all my solution does is force you to adhere to Rust&#39;s rules and thus force you to use a scope."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 1, "last_activity_date": 1485352519, "last_edit_date": 1485352519, "creation_date": 1485352396, "answer_id": 41853407, "question_id": 41852283, "link": "https://stackoverflow.com/questions/41852283/safe-non-trivial-data-dependencies-custom-references/41853407#41853407", "title": "Safe non-trivial data dependencies/custom references?", "body": "<p>You can add lifetimes to your <code>Edge</code> struct, and borrow the <code>Graph</code> in the <code>get_random_edge</code> method:</p>\n\n<pre><code>struct Graph;\n\nimpl Graph {\n    fn get_random_edge&lt;'a&gt;(&amp;'a self) -&gt; Edge&lt;'a&gt; {\n        Edge(self)\n    }\n    fn get_random_edge_mut&lt;'a&gt;(&amp;'a mut self) -&gt; MutEdge&lt;'a&gt; {\n        MutEdge(self)\n    }\n}\n\nstruct MutEdge&lt;'a&gt;(&amp;'a mut Graph);\n\nimpl&lt;'a&gt; MutEdge&lt;'a&gt; {\n    fn split(self) {}\n    fn next(&amp;'a mut self) -&gt; MutEdge&lt;'a&gt; {\n        MutEdge(self.0)\n    }\n}\n\nstruct Edge&lt;'a&gt;(&amp;'a Graph);\n\nimpl&lt;'a&gt; Edge&lt;'a&gt; {\n    fn split(self) {}\n    fn next(&amp;'a self) -&gt; Edge&lt;'a&gt; {\n        Edge(self.0)\n    }\n}\n</code></pre>\n\n<p>This will give the following errors:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>37 |         edge.split();\n   |         ---- value moved here\n38 |         edge.next(); // this will be a compile-time error as the edge is gone!\n   |         ^^^^ value used here after move\n</code></pre>\n\n<p>And</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0499]: cannot borrow `graph` as mutable more than once at a time\n  --&gt; &lt;anon&gt;:43:17\n   |\n42 |     let edge1 = graph.get_random_edge_mut();\n   |                 ----- first mutable borrow occurs here\n43 |     let edge2 = graph.get_random_edge_mut();\n   |                 ^^^^^ second mutable borrow occurs here\n</code></pre>\n\n<p>If you don't want to store a reference to the <code>Graph</code> in the edge, but just the index, you can simply replace the <code>&amp;'a mut Graph</code> with <code>PhantomData&lt;&amp;'a mut Graph&gt;</code>, which doesn't take up memory, but has the same semantics.</p>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 4, "last_activity_date": 1485353052, "last_edit_date": 1485353052, "creation_date": 1485352671, "answer_id": 41853504, "question_id": 41852283, "link": "https://stackoverflow.com/questions/41852283/safe-non-trivial-data-dependencies-custom-references/41853504#41853504", "title": "Safe non-trivial data dependencies/custom references?", "body": "<p><strong>Yes</strong></p>\n\n<hr>\n\n<p>It is perfectly possible to leverage ownership and borrow-checking to build your own safety checks, and this is actually a very exciting area of exploration that is opened to us.</p>\n\n<p>I'd like to start with existing cool things:</p>\n\n<ul>\n<li><p><a href=\"https://github.com/Munksgaard/session-types\" rel=\"nofollow noreferrer\">Sessions Types</a> are about encoding state machines in the type system:</p>\n\n<ul>\n<li>The \"state\" is encoded as a type</li>\n<li>The \"transition\" is encoded as a method consuming one value and producing another of a possibly different type</li>\n<li>As a result: (1) transitions are checked at runtime and (2) it's impossible to use an old state</li>\n</ul></li>\n<li><p>There are tricks to use borrowing to forge a guaranteed valid index for a particular collection (related to branding):</p>\n\n<ul>\n<li>The index borrows the collection, guaranteeing the collection cannot be modified</li>\n<li>The index is forged with an <em>invariant</em> lifetime, which ties it to <em>this</em> instance of the collection, and no other</li>\n<li>As a result: the index can be used only with this collection, and without bounds checking</li>\n</ul></li>\n</ul>\n\n<hr>\n\n<p>Let's get to your examples:</p>\n\n<pre><code>// get a reference to an edge\nlet edge = graph.get_random_edge()\n// the next statement yields the ownership of the edge reference\n// back to the graph, which can invalidate it \nedge.split() \nedge.next() // this will be a compile-time error as the edge is gone!\n</code></pre>\n\n<p>This is actually trivial.</p>\n\n<p>In Rust you can define a method to <em>take ownership</em> of its receiver:</p>\n\n<pre><code>impl Edge {\n   fn split(self) { ... }\n         // ^~~~ Look, no \"&amp;\"\n}\n</code></pre>\n\n<p>Once the value is consumed, it cannot be used any longer, and therefore the call to <code>next</code> is invalid.</p>\n\n<p>I suppose that you would want <code>Edge</code> to keep a reference to the graph, to prevent the graph from being modified whilst you have an outstanding edge:</p>\n\n<pre><code>struct Edge&lt;'a&gt; {\n    graph: &amp;'a Graph,  // nobody modifies the graph while I live!\n}\n</code></pre>\n\n<p>will do the trick.</p>\n\n<hr>\n\n<p>Moving on:</p>\n\n<pre><code>// another example\nlet edge1 = graph.get_random_edge()\nlet edge2 = graph.get_random_edge()\n// this will be a compile-time error because the potentially invalid\n// edge2 reference is still owned by the code and has not been\n// yielded to the graph \nedge1.split() \n</code></pre>\n\n<p>This is not possible, as is.</p>\n\n<p>To enforce order, the values must be linked together, and here <code>edge1</code> and <code>edge2</code> are not.</p>\n\n<p>A simple solution is to require that <code>edge1</code> act as mandatory proxy for the graph:</p>\n\n<pre><code>struct Edge&lt;'a&gt; {\n    graph: &amp;'a mut Graph,  // MY PRECIOUS!\n                           // You'll only get that graph over my dead body!\n}\n</code></pre>\n\n<p>Then, we implement a getter, to get access to the graph temporarily:</p>\n\n<pre><code>impl&lt;'a&gt; Edge&lt;'a&gt; {\n    fn get_graph&lt;'me&gt;(&amp;'me mut edge) -&gt; &amp;'me mut Graph;\n}\n</code></pre>\n\n<p>And uses that result (named <code>graph2</code> for convenience) to obtain <code>edge2</code>.</p>\n\n<p>This creates a chain of obligations:</p>\n\n<ul>\n<li>Nobody can touch <code>graph</code> until <code>edge1</code> dies</li>\n<li>Nobody can touch <code>edge1</code> until <code>graph2</code> dies</li>\n<li>Nobody can touch <code>graph2</code> until <code>edge2</code> dies</li>\n</ul>\n\n<p>which enforces that the objects are released in the correct order.</p>\n\n<p>At compile time.</p>\n\n<p>\\o/</p>\n\n<hr>\n\n<p><em>Safety Note: An important event early after Rust release was the LeakPocalypse (<a href=\"https://www.reddit.com/r/rust/comments/32jmf8/stdthreadscoped_found_to_be_unsound/\" rel=\"nofollow noreferrer\"><code>scoped_thread</code></a> being found to be unsound), which led Gankro (who wrote and shepherded <code>std::collections</code>) to write <a href=\"http://cglab.ca/~abeinges/blah/everyone-poops/\" rel=\"nofollow noreferrer\">Pre-pooping Your Pants with Rust</a> which I encourage you to read. The short of it is that you should NEVER rely on a destructor being executed for safety, because there's no guarantee it will (the object could be leaked and then the thread unwind by panic). Pre-Pooping Your Pants is the strategy proposed by Gankro to work around that: put the element in a valid and safe (if semantically wrong) state, do your stuff, restore the real semantics on destruction, and is what is used by the <code>Drain</code> iterator.</em></p>\n"}], "owner": {"reputation": 1552, "user_id": 3145469, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/40ef74077e497553ad7a6ce20a1fc38b?s=128&d=identicon&r=PG&f=1", "display_name": "MrMobster", "link": "https://stackoverflow.com/users/3145469/mrmobster"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 106, "favorite_count": 1, "answer_count": 2, "score": 4, "last_activity_date": 1485353052, "creation_date": 1485349243, "last_edit_date": 1485352496, "question_id": 41852283, "link": "https://stackoverflow.com/questions/41852283/safe-non-trivial-data-dependencies-custom-references", "title": "Safe non-trivial data dependencies/custom references?", "body": "<p>One of the central features of Rust is the compile-time enforced safety of references, which is achieved though ownership mechanics and explicit lifetimes. Is it possible to implement 'custom' references that would benefit from the same? </p>\n\n<p>Consider the following example. We have an object that represents a graph. Assume that we can traverse the graph by referencing its edges, however, these references are implemented as custom indices rather then pointers to some memory. Such an index could be simply an offset into an array (or three), but it also could be a struct that combines some flags etc. </p>\n\n<p>Besides traversing the graph, we can also modify it, which means that references to its internal state (edges) get invalidated. Ideally, we would want the compiler to catch any of these invalid references. Can we do this in Rust? E.g.:</p>\n\n<pre><code>// get a reference to an edge\nlet edge = graph.get_random_edge()\n// the next statement yields the ownership of the edge reference\n// back to the graph, which can invalidate it \nedge.split() \nedge.next() // this will be a compile-time error as the edge is gone!\n\n// another example\nlet edge1 = graph.get_random_edge()\nlet edge2 = graph.get_random_edge()\n// this will be a compile-time error because the potentially invalid\n// edge2 reference is still owned by the code and has not been\n// yielded to the graph \nedge1.split() \n</code></pre>\n\n<p>P.S. Sorry for the non-informative title, I was not sure how to phrase it...</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485344176, "post_id": 41849854, "comment_id": 70885049, "body": "Uh! That&#39;s a fun one. Sometimes I really wish I could use <code>&#39;provider</code> to say &quot;the lifetime of that guy, there&quot;."}, {"owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "edited": false, "score": 0, "creation_date": 1485348287, "post_id": 41849854, "comment_id": 70887533, "body": "not sure how to make it work. As a workaround, maybe you could let the closure capture s from the environment too instead of passing it in as a parameter. Like <a href=\"https://play.rust-lang.org/?gist=e7fd2f4ee7c58b9e592a1f060b2d396b&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">this</a>"}, {"owner": {"reputation": 11593, "user_id": 2494803, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/58b4b1d0d8887426a51330a990936ac1?s=128&d=identicon&r=PG", "display_name": "bennofs", "link": "https://stackoverflow.com/users/2494803/bennofs"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485355201, "post_id": 41849854, "comment_id": 70892401, "body": "@Shepmaster I&#39;ve since found that as well. That is the solution that also works for the real problem :) Still, I&#39;m quite surprised that&#39;s impossible to manually specify the type of <code>s</code> here."}], "answers": [{"comments": [{"owner": {"reputation": 11593, "user_id": 2494803, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/58b4b1d0d8887426a51330a990936ac1?s=128&d=identicon&r=PG", "display_name": "bennofs", "link": "https://stackoverflow.com/users/2494803/bennofs"}, "edited": false, "score": 0, "creation_date": 1485350802, "post_id": 41852581, "comment_id": 70889213, "body": "This answer is certainly interesting and provided me some new infos about lifetimes, but unfortunately, in my problem, <code>Provider</code> is an <code>Arena</code> which does not have any data that it owns :( So the reference really does not live any longer than the provider itself."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 11593, "user_id": 2494803, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/58b4b1d0d8887426a51330a990936ac1?s=128&d=identicon&r=PG", "display_name": "bennofs", "link": "https://stackoverflow.com/users/2494803/bennofs"}, "edited": false, "score": 0, "creation_date": 1485350892, "post_id": 41852581, "comment_id": 70889271, "body": "What determins how long the result of <code>get_string</code> lives in your case?"}, {"owner": {"reputation": 11593, "user_id": 2494803, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/58b4b1d0d8887426a51330a990936ac1?s=128&d=identicon&r=PG", "display_name": "bennofs", "link": "https://stackoverflow.com/users/2494803/bennofs"}, "edited": false, "score": 0, "creation_date": 1485351078, "post_id": 41852581, "comment_id": 70889411, "body": "It lives exactly as long as the <code>provider</code> does"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 11593, "user_id": 2494803, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/58b4b1d0d8887426a51330a990936ac1?s=128&d=identicon&r=PG", "display_name": "bennofs", "link": "https://stackoverflow.com/users/2494803/bennofs"}, "edited": false, "score": 0, "creation_date": 1485351233, "post_id": 41852581, "comment_id": 70889514, "body": "In which case does the <code>PhantomData</code> not do what you want as in the answer?"}, {"owner": {"reputation": 11593, "user_id": 2494803, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/58b4b1d0d8887426a51330a990936ac1?s=128&d=identicon&r=PG", "display_name": "bennofs", "link": "https://stackoverflow.com/users/2494803/bennofs"}, "edited": false, "score": 0, "creation_date": 1485351419, "post_id": 41852581, "comment_id": 70889648, "body": "Consider the case where the <code>String</code> owned by <code>Provider</code> (through an attribute for example). Example (edited wrong link): <a href=\"https://play.rust-lang.org/?gist=4c97845847bbda978b41f30b26a0f7db&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 3, "last_activity_date": 1485350101, "creation_date": 1485350101, "answer_id": 41852581, "question_id": 41849854, "link": "https://stackoverflow.com/questions/41849854/lifetime-annotation-for-closure-argument/41852581#41852581", "title": "Lifetime annotation for closure argument", "body": "<p>Here's a version which compiles:</p>\n\n<pre><code>use std::marker::PhantomData;\n\nstruct Provider&lt;'a&gt; {\n    _dummy: PhantomData&lt;&amp;'a ()&gt;,\n}\n\nimpl&lt;'a&gt; Provider&lt;'a&gt; {\n    fn get_string(&amp;self) -&gt; &amp;'a str {\n        \"this is a string\"\n    }\n}\n\nfn f&lt;'b&gt;() {\n    let provider = Provider { _dummy: PhantomData };\n    let mut vec: Vec&lt;&amp;str&gt; = Vec::new();\n\n    // PROBLEM: how do I say that this reference s here\n    // needs to live as long as vec?\n    let mut fun = |s: &amp;'b str| { vec.push(s); };\n\n    fun(provider.get_string());\n}\n\nfn main() {\n    f()\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=ae8183a207a28d17557334c57d00739a&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground link</a></p>\n\n<p>I made the following changes:</p>\n\n<ul>\n<li>Add a lifetime to <code>Provider</code> (I added a <code>PhantomData</code>, but I guess your provider already owns some data it'll provide).</li>\n<li>Update the <code>get_string</code> method to show that it returns something with the provider's lifetime, not the input lifetime (ie based on the <code>Provider</code>'s lifetime parameter).</li>\n<li>Add a new lifetime parameter <code>'b</code> to the function (which I renamed to <code>f()</code>, since <code>main()</code> can't have one), which I use to name the lifetime of the closure parameter.</li>\n</ul>\n\n<p>The last one is slightly confusing, as apparently merely adding a name to a lifetime (without apparently adding any constraints) has made it work.</p>\n\n<p>I <em>think</em> (but I'd love some documentation for this) that this is because of lifetime elision.  A closure is really a hidden <code>struct</code> with a <code>fn call(&amp;self, s: &amp;str)</code> (in this case) method.  According to the <a href=\"https://doc.rust-lang.org/book/lifetimes.html#lifetime-elision\" rel=\"nofollow noreferrer\">lifetime elision rules</a>, the <code>s</code> parameter gains the same lifetime as <code>&amp;self</code>, which is the closure itself.  In this case, the closure is declared after <code>vec</code>, so the lifetime is too short.  The explicit lifetime means that it is decoupled from the closure's own lifetime.</p>\n"}, {"comments": [{"owner": {"reputation": 11593, "user_id": 2494803, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/58b4b1d0d8887426a51330a990936ac1?s=128&d=identicon&r=PG", "display_name": "bennofs", "link": "https://stackoverflow.com/users/2494803/bennofs"}, "edited": false, "score": 0, "creation_date": 1485355512, "post_id": 41854380, "comment_id": 70892610, "body": "Is there any work/proposal to make it possible to specify the type of <code>s</code> explictly in a future rust version? I guess what would be needed for that is some kind lifetime specification that says that the reference has the same lifetime as &lt;other reference&gt;, so I could write <code>|s: &amp;&#39;liftime_of(provider) str</code>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 11593, "user_id": 2494803, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/58b4b1d0d8887426a51330a990936ac1?s=128&d=identicon&r=PG", "display_name": "bennofs", "link": "https://stackoverflow.com/users/2494803/bennofs"}, "edited": false, "score": 0, "creation_date": 1485355941, "post_id": 41854380, "comment_id": 70892928, "body": "@bennofs I know of no such way or proposal to allow explicitly referring to the lifetime of a local variable."}, {"owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "edited": false, "score": 0, "creation_date": 1485359109, "post_id": 41854380, "comment_id": 70895189, "body": "today I learned that inference can be more powerful (vs just more convenient) than manually specifying lifetimes... Thanks for that!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "edited": false, "score": 1, "creation_date": 1485359222, "post_id": 41854380, "comment_id": 70895270, "body": "@PaoloFalabella it was pretty confusing to me at first, because I always strive to remove any explicit lifetimes / types. At some point, I hit strange problems because a question asker had explicit lifetimes and I didn&#39;t, so I couldn&#39;t figure out what was broken. Now I remember."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1485360515, "post_id": 41854380, "comment_id": 70896251, "body": "Can you explain why the original annotations stopped things from working? None of them look different to me to what I&#39;d expect the compiler to de-elide or infer."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 8, "last_activity_date": 1505307861, "last_edit_date": 1505307861, "creation_date": 1485355308, "answer_id": 41854380, "question_id": 41849854, "link": "https://stackoverflow.com/questions/41849854/lifetime-annotation-for-closure-argument/41854380#41854380", "title": "Lifetime annotation for closure argument", "body": "<p>Your code works just fine if remove all the lifetime annotations and let the compiler inference do its job:</p>\n\n<pre><code>struct Provider;\n\nimpl Provider {\n    fn get_string(&amp;self) -&gt; &amp;str { \"this is a string\" }\n}\n\nfn main() {\n    let provider = Provider;\n    let mut vec = Vec::new();\n\n    let mut fun = |s| {\n        vec.push(s);\n    };\n\n    fun(provider.get_string());\n}\n</code></pre>\n\n<p>In short, there's no way to explicitly refer to the lifetime of a local variable, only function arguments. The compiler knows how to do it, though.</p>\n\n<p>If you truly needed it, you could create a function to allow annotating the lifetimes:</p>\n\n<pre><code>fn thing&lt;'a&gt;(provider: &amp;'a Provider) -&gt; Vec&lt;&amp;'a str&gt; {\n    let mut vec: Vec&lt;&amp;'a str&gt; = Vec::new();\n\n    {\n        let mut fun = |s: &amp;'a str| vec.push(s);\n\n        fun(provider.get_string());\n    } // End mutable borrow of `vec`\n\n    vec\n}\n\nfn main() {\n    let provider = Provider;\n    thing(&amp;provider);\n}\n</code></pre>\n\n<blockquote>\n  <p>why did the original annotations stop things from working?</p>\n</blockquote>\n\n<p>Specifically, it's this bit:</p>\n\n<pre><code>let fun = |s: &amp;str| {\n    vec.push(s);\n};\n</code></pre>\n\n<p>This declares a new lifetime on the closure. Using a <strong>made-up syntax</strong> (you <a href=\"https://stackoverflow.com/q/31403723/155423\">can't declare lifetimes on closure arguments</a>), it would be equivalent to:</p>\n\n<pre><code>let fun = &lt;'a&gt; |s: &amp;'a str| {\n    vec.push(s);\n};\n</code></pre>\n\n<p>Which is why the compiler has the error:</p>\n\n<blockquote>\n  <p>the lifetime cannot outlive the anonymous lifetime #1 defined on [the closure's block]</p>\n</blockquote>\n\n<p>There's no connection between that generated lifetime and that of the <code>Provider</code>. Leaving it out allows the compiler to insert the desired but unnamable lifetime.</p>\n"}], "owner": {"reputation": 11593, "user_id": 2494803, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/58b4b1d0d8887426a51330a990936ac1?s=128&d=identicon&r=PG", "display_name": "bennofs", "link": "https://stackoverflow.com/users/2494803/bennofs"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1602, "favorite_count": 3, "accepted_answer_id": 41854380, "answer_count": 2, "score": 8, "last_activity_date": 1505307861, "creation_date": 1485342055, "last_edit_date": 1485352606, "question_id": 41849854, "link": "https://stackoverflow.com/questions/41849854/lifetime-annotation-for-closure-argument", "title": "Lifetime annotation for closure argument", "body": "<p>I'd like to make the following code compile:</p>\n\n<pre><code>struct Provider {}\n\nimpl Provider {\n    fn get_string&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str { \"this is a string\" }\n}\n\nfn main() {\n    let provider = Provider{};\n    let mut vec: Vec&lt;&amp;str&gt; = Vec::new();\n\n    // PROBLEM: how do I say that this reference s here\n    // needs to live as long as vec?\n    let fun = |s: &amp;str| {\n        vec.push(s);\n    };\n\n    fun(provider.get_string());\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=0d8e97b3ef5eaea8f58e03372b9f03bb&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Playground link</a></p>\n\n<p>This is the compile error that I get:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n --&gt; src/main.rs:9:22\n  |\n9 |     let mut vec: Vec&lt;&amp;str&gt; = Vec::new();\n  |                      ^^^^\n  |\nnote: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the block at 11:24...\n --&gt; src/main.rs:11:25\n  |\n11|     let fun = |s: &amp;str| {\n  |                         ^\nnote: ...so that reference does not outlive borrowed content\n --&gt; src/main.rs:12:18\n  |\n12|         vec.push(s);\n  |                  ^\nnote: but, the lifetime must be valid for the block suffix following statement 2 at 13:6...\n --&gt; src/main.rs:13:7\n  |\n13|     };\n  |       ^\nnote: ...so that variable is valid at time of its declaration\n --&gt; src/main.rs:11:9\n  |\n11|     let fun = |s: &amp;str| {\n  |         ^^^\n</code></pre>\n"}, {"tags": ["ssl", "rust", "hyper", "nickel"], "answers": [{"comments": [{"owner": {"reputation": 13, "user_id": 5841027, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c5deea0ab217c8ea8728612fc77e779f?s=128&d=identicon&r=PG&f=1", "display_name": "f4bi4n", "link": "https://stackoverflow.com/users/5841027/f4bi4n"}, "edited": false, "score": 0, "creation_date": 1485513040, "post_id": 41884486, "comment_id": 70965633, "body": "Thanks for your answer! You are right, I tried it with hyper_openssl and hyper 0.10 and then the rustls connection is ok now and Chrome shows me no more &quot;obsolete key exchange (RSA)&quot;! Should i report it to nickel as bug? I&#39;m not so sure if there will be day an version with hyper 0.10..."}], "tags": [], "owner": {"reputation": 16, "user_id": 7476316, "user_type": "registered", "profile_image": "https://lh6.googleusercontent.com/-3_2h2WFq840/AAAAAAAAAAI/AAAAAAAAALc/wQP0JIyCovI/photo.jpg?sz=128", "display_name": "ctz", "link": "https://stackoverflow.com/users/7476316/ctz"}, "is_accepted": true, "score": 0, "last_activity_date": 1485471494, "creation_date": 1485471494, "answer_id": 41884486, "question_id": 41846521, "link": "https://stackoverflow.com/questions/41846521/nickel-server-using-lets-encrypt-certificate-has-a-handshake-error-when-accesse/41884486#41884486", "title": "Nickel server using Let&#39;s Encrypt certificate has a handshake error when accessed with rustls", "body": "<p>It looks like hyper's <code>Openssl::with_cert_and_key</code> tells openssl to use the <code>DEFAULT</code> cipher suite list, which is pretty awful. rustls in this case is failing to handshake for the same reason that chrome says \"obsolete key exchange (RSA)\".  If you run your server and point ssllabs.com at it, you should get more information.</p>\n\n<p>I think more recent hyper releases have removed this code in favour getting TLS support from other crates.  Could you try that?</p>\n"}], "owner": {"reputation": 13, "user_id": 5841027, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c5deea0ab217c8ea8728612fc77e779f?s=128&d=identicon&r=PG&f=1", "display_name": "f4bi4n", "link": "https://stackoverflow.com/users/5841027/f4bi4n"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 232, "favorite_count": 0, "accepted_answer_id": 41884486, "answer_count": 1, "score": 0, "last_activity_date": 1485471494, "creation_date": 1485332384, "last_edit_date": 1485352277, "question_id": 41846521, "link": "https://stackoverflow.com/questions/41846521/nickel-server-using-lets-encrypt-certificate-has-a-handshake-error-when-accesse", "title": "Nickel server using Let&#39;s Encrypt certificate has a handshake error when accessed with rustls", "body": "<p>I'm trying to create a small REST-like API that should be secured with HTTPS. I want to use the nickel crate for the server and hyper_rustls and hyper for the client.</p>\n\n<p>The server is running great as long as I use a browser, curl or a REST client to access it, but when I start to use hyper_rustls I always get a handshake error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>TLS error: AlertReceived(HandshakeFailure)\nConnection closed\n</code></pre>\n\n<p>To localize the error, I set up a minimal server:</p>\n\n<pre><code>#[macro_use]\nextern crate nickel;\nextern crate hyper;\nuse hyper::net::Openssl;\n\n\nuse nickel::Nickel;\n\nfn main() {\n    let mut server = Nickel::new();\n\n    server.utilize(router! {\n        get \"**\" =&gt; |_req, _res| {\n            \"Hello world!\"\n        }\n    });\n\n    // FIXME: Add Match Error and OK instead of unwreap and add a propper error handling\n    let ssl = Openssl::with_cert_and_key(\"/etc/letsencrypt/live/www.example.de/fullchain.\\\n                                          pem\",\n                                         \"/etc/letsencrypt/live/www.example.de/privkey.pem\")\n        .unwrap();\n\n    server.listen_https(\"0.0.0.0:6767\", ssl).expect(\"Failed to launch server\");\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=c82087f2100377590be6c0556fb53fb7&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">On the Rust Playground</a></p>\n\n<ul>\n<li><p>The valid certificate in Chrome: </p>\n\n<p><a href=\"https://i.stack.imgur.com/WQKM9.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/WQKM9.png\" alt=\"valid certificate in Chrome\"></a></p></li>\n<li><a href=\"http://pastebin.com/7eKhgMWG\" rel=\"nofollow noreferrer\">The complete output of tlsclient when accessing the nickel server</a></li>\n<li><a href=\"http://pastebin.com/DXKd1LvS\" rel=\"nofollow noreferrer\">The complete output of tlsclient when accessing badssl.com</a></li>\n</ul>\n\n<p>To avoid errors in hyper_rustls, I used the <a href=\"https://github.com/ctz/rustls/blob/master/examples/tlsclient.rs\" rel=\"nofollow noreferrer\">rustls tlsclient example</a> but the error still appears.</p>\n\n<p>The Let's Encrypt certificate isn't the problem as I can connect to an Apache2 server with these certs using tlsclient.</p>\n\n<p>Have I made a mistake with my thinking how this works?</p>\n"}, {"tags": ["multithreading", "rust"], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 4, "last_activity_date": 1485332890, "creation_date": 1485332890, "answer_id": 41846658, "question_id": 41846177, "link": "https://stackoverflow.com/questions/41846177/this-slightly-modified-rc-is-sync-but-not-send-right/41846658#41846658", "title": "This slightly modified Rc&lt;()&gt; is Sync, but not Send, right?", "body": "<blockquote>\n  <p>I know that the compiler won't automatically implement <code>Send</code> nor <code>Sync</code> for my type.</p>\n</blockquote>\n\n<p>Indeed, the compiler automatically implements <code>Send</code> and <code>Sync</code> for you, only when it can determine it is safe to do so.</p>\n\n<p>This little program:</p>\n\n<pre><code>use std::cell::Cell;\nuse std::sync::atomic::AtomicUsize;\n\nfn ensure_sync&lt;T: Sync&gt;(_: T) {}\n\nstruct Automatic(AtomicUsize);\n\nimpl Automatic {\n    fn new() -&gt; Automatic { Automatic(AtomicUsize::new(0)) }\n}\n\nfn main() {\n    ensure_sync(AtomicUsize::new(0));\n    ensure_sync(Automatic::new());\n    ensure_sync(Cell::new(0));\n}\n</code></pre>\n\n<p>Only errors out on the <code>Cell::new(0)</code> line, <code>Automatic</code> is <code>Sync</code> because all its fields are <code>Sync</code>.</p>\n\n<hr>\n\n<p>Regarding <code>Foo</code>, <code>Rc</code> is neither <code>Sync</code> nor <code>Send</code>, so indeed the compiler will not implement either for you.</p>\n\n<p>Can <code>Foo</code> be <code>Sync</code>?</p>\n\n<p>I <em>believe</em><sup>1</sup> so. As long as NO other operation is added to the module that operate on immutable references. Now or in the future.</p>\n\n<p>Can <code>Foo</code> be <code>Send</code>?</p>\n\n<p>I agree with your conclusion, but I think you missed another method that modifies the <code>Cell</code>: <code>drop</code>.</p>\n\n<p>So, indeed, you seem to have come up with a type that is <code>Sync</code> and not <code>Send</code>, by using an underlying type that is <code>Send</code> and not <code>Sync</code>. It may be my nerd sense, I find it quite amusing :)</p>\n\n<p><sup>1</sup> <em>When dealing with <code>unsafe</code> code, I am never sure of anything. It's very easy to fool oneself into thinking something is safe, simply because a tiny little detail escaped attention.</em></p>\n"}], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 127, "favorite_count": 0, "accepted_answer_id": 41846658, "answer_count": 1, "score": 6, "last_activity_date": 1485332890, "creation_date": 1485330905, "last_edit_date": 1495541808, "question_id": 41846177, "link": "https://stackoverflow.com/questions/41846177/this-slightly-modified-rc-is-sync-but-not-send-right", "title": "This slightly modified Rc&lt;()&gt; is Sync, but not Send, right?", "body": "<p>I've searched for types that are <code>Sync</code>, but not <code>Send</code>, because it often looks like one trait is a superset of the other one (\u201cevery type that implements <code>Sync</code> also implements <code>Send</code>\u201d). I've found <a href=\"https://stackoverflow.com/questions/28387421/what-are-examples-of-types-that-implement-only-one-of-send-and-sync\">this question</a>, but the only real answer is really complicated. </p>\n\n<p>So I've come up with this code:</p>\n\n<pre><code>struct Foo(Rc&lt;()&gt;);  // &lt;-- private field\n\nimpl Foo {\n    fn my_clone(&amp;mut self) -&gt; Self {  // &lt;-- mutable borrow\n        Foo(self.0.clone())\n    }\n}\n</code></pre>\n\n<p>I know that the compiler won't automatically implement <code>Send</code> nor <code>Sync</code> for my type; but I'm interested in what I <em>could</em> safely implement manually. I think:</p>\n\n<ul>\n<li><p><strong>It should be able to implement <code>Sync</code></strong>: having an <em>immutable</em> reference to <code>Foo</code> won't let us do anything with it (because we can only call <code>my_clone()</code> via mutable/exclusive reference). And without doing anything, nothing can go wrong, right?</p></li>\n<li><p><strong>It should <em>not</em> be able to implement <code>Send</code></strong>: we can clone our <code>Foo</code> in the main thread (before starting another thread) to get a second object. Now both objects share some memory (the reference count, stored in a <code>Cell&lt;usize&gt;</code>). If I now could send one of those objects to another thread, both threads would have ownership of a <code>Foo</code>, referencing the same memory. Thus both objects could call <code>my_clone()</code> at the same time, leading to simultaneous, unsynchronized, mutable access to the reference count (a data race).</p></li>\n</ul>\n\n<p>Is this reasoning correct or am I missing something?</p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485330332, "post_id": 41844072, "comment_id": 70876140, "body": "The compiler could indeed try and introduce temporaries as needed, but that can be quite fragile... Rust tends to prefer erring on the side of explicitness regarding lifetimes."}, {"owner": {"reputation": 1907, "user_id": 3625843, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/sXmwj.png?s=128&g=1", "display_name": "Evan Conrad", "link": "https://stackoverflow.com/users/3625843/evan-conrad"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485363946, "post_id": 41844072, "comment_id": 70898664, "body": "What do you mean by that? What temporaries need to be made? How should I explicitly define a lifetime in this case?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1485367736, "post_id": 41844072, "comment_id": 70901061, "body": "If you look at what <a href=\"https://doc.rust-lang.org/std/path/struct.Path.html#method.join\" rel=\"nofollow noreferrer\"><code>join</code></a> does, it returns a <code>PathBuf</code>. You then borrow from <code>PathBuf</code> with <code>as_path</code> which creates a reference into <code>PathBuf</code>, but <code>PathBuf</code> here is a temporary (a value not bound to any variable) which disappears at the semi-colon, so that <code>path</code> would refer into a non-existing buffer. I advise you to read the duplicate, it has the same problem with <code>as_slice</code> instead of <code>as_path</code>."}, {"owner": {"reputation": 1907, "user_id": 3625843, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/sXmwj.png?s=128&g=1", "display_name": "Evan Conrad", "link": "https://stackoverflow.com/users/3625843/evan-conrad"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485370831, "post_id": 41844072, "comment_id": 70902887, "body": "I did read the duplicate, but it was not clear that they were similar problems. It&#39;s hard to see any similarity as a new user. That is the correct answer however. I had the function return <code>Path::new(&quot;container_folder&quot;).join(Path::new(&amp;name)).as_path&zwnj;&#8203;().exists()</code> and it compiled fine. Thanks for the help!"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1485371138, "post_id": 41844072, "comment_id": 70903059, "body": "Yes, understanding ownership is a significant challenge the first time you&#39;re exposed to it; the good news is that it becomes easier once you grok it. Here <code>PathBuf</code> is a value and <code>Path</code> is a reference; you (generally) cannot reference a value that is not named, so an easy fix is <code>let path_buf = Path::new(&quot;container_folder&quot;).join(Path::new(&amp;name)); path_buf.as_path().exists();</code>. The &quot;generally&quot; is that Rust allows creating unnamed values, aka temporaries, however they get cleaned up at the end of the expression/statement. Thus your solution: using a single expression to extend the lifetime."}], "owner": {"reputation": 1907, "user_id": 3625843, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/sXmwj.png?s=128&g=1", "display_name": "Evan Conrad", "link": "https://stackoverflow.com/users/3625843/evan-conrad"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 47, "favorite_count": 0, "closed_date": 1485330264, "answer_count": 0, "score": 0, "last_activity_date": 1485363708, "creation_date": 1485322100, "last_edit_date": 1485363708, "question_id": 41844072, "link": "https://stackoverflow.com/questions/41844072/why-does-the-borrow-checker-care-if-my-function-uses-something-that-its-not-ret", "closed_reason": "Duplicate", "title": "Why does the borrow checker care if my function uses something that it&#39;s not returning?", "body": "<p>In the function: </p>\n\n<pre><code>fn check_path(name : &amp;String) -&gt; bool {\n    let path = Path::new(\"container_folder\").join(Path::new(&amp;name)).as_path();\n    path.exists()\n}\n</code></pre>\n\n<p>I am simply returning a <code>bool</code>. However, when I try to compile this, the compiler references <code>Path::new(\"container_folder\").join(Path::new(&amp;name))</code> and says that the <code>borrowed value does not live long enough</code>. </p>\n\n<p>Why? </p>\n\n<p>Shouldn't the borrow checker not care if the path is being popped off the stack since I'm not actually referencing it outside of the function?</p>\n\n<p>EDIT:</p>\n\n<p>If this is a duplicate, please explain how. </p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 3039, "user_id": 2851815, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/37MCt.png?s=128&g=1", "display_name": "\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438", "link": "https://stackoverflow.com/users/2851815/%d0%bd%d0%b0%d0%b1%d0%b8%d1%8f%d1%87%d0%bb%d1%8d%d0%b2%d1%8d%d0%bb%d0%b8"}, "edited": false, "score": 0, "creation_date": 1485640587, "post_id": 41911995, "comment_id": 71011866, "body": "&quot;Note that the strings BLUE, RED, RESET will still be sent&quot;, so if I use an instance of a thing that implements <code>Display</code>, will that still call <code>Display::fmt</code> on it? &quot;forget a {reset} the rest &quot; because I have multiple colours arbitrarily mixed per line, the simple strings are just for demonstration purposes."}, {"owner": {"reputation": 3039, "user_id": 2851815, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/37MCt.png?s=128&g=1", "display_name": "\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438", "link": "https://stackoverflow.com/users/2851815/%d0%bd%d0%b0%d0%b1%d0%b8%d1%8f%d1%87%d0%bb%d1%8d%d0%b2%d1%8d%d0%bb%d0%b8"}, "edited": false, "score": 0, "creation_date": 1485641559, "post_id": 41911995, "comment_id": 71012174, "body": "Thanks for the answer, lead me to update the supporting library and learn some new things about Rust&#39;s <code>Display::fmt</code>"}, {"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "reply_to_user": {"reputation": 3039, "user_id": 2851815, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/37MCt.png?s=128&g=1", "display_name": "\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438", "link": "https://stackoverflow.com/users/2851815/%d0%bd%d0%b0%d0%b1%d0%b8%d1%8f%d1%87%d0%bb%d1%8d%d0%b2%d1%8d%d0%bb%d0%b8"}, "edited": false, "score": 0, "creation_date": 1485668914, "post_id": 41911995, "comment_id": 71017135, "body": "@\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438: It must still call <code>Display::fmt</code>, the library is not yet smart enough to know <code>.0</code> is special (the <code>.N</code> stuff is handled in <code>Display::fmt</code> IIRC)."}, {"owner": {"reputation": 3039, "user_id": 2851815, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/37MCt.png?s=128&g=1", "display_name": "\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438", "link": "https://stackoverflow.com/users/2851815/%d0%bd%d0%b0%d0%b1%d0%b8%d1%8f%d1%87%d0%bb%d1%8d%d0%b2%d1%8d%d0%bb%d0%b8"}, "edited": false, "score": 1, "creation_date": 1485720908, "post_id": 41911995, "comment_id": 71031345, "body": "Yep, I figured that, so I specialcase on <code>f.precision() == Some(0)</code> in my implementation of <code>Display::fmt()</code> to prevent that."}, {"owner": {"reputation": 632, "user_id": 2204326, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/TyLFa.jpg?s=128&g=1", "display_name": "ratijas", "link": "https://stackoverflow.com/users/2204326/ratijas"}, "edited": false, "score": 0, "creation_date": 1540076816, "post_id": 41911995, "comment_id": 92732471, "body": "Apparently, this trick does not work for <code>Debug</code> types, i.e. if <code>red=SomeNonDisplayType</code>. As a workaround: <code>format!(concat!($fmt, &quot;{red:.0}&quot;), args..., red=format!(&quot;{:?}&quot;, red))</code>"}], "tags": [], "owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "is_accepted": true, "score": 3, "last_activity_date": 1485620335, "creation_date": 1485620335, "answer_id": 41911995, "question_id": 41841400, "link": "https://stackoverflow.com/questions/41841400/allow-unused-named-arguments-in-rusts-format-family/41911995#41911995", "title": "Allow unused named arguments in Rust&#39;s format!() family", "body": "<p>If the set of colors are all known, you could \"consume\" them with zero-length arguments:</p>\n\n<pre><code>macro_rules! log {\n    ($fmt:expr, $($arg:tt)*) =&gt; {\n        println!(concat!($fmt, \"{blue:.0}{red:.0}{reset:.0}\"),  // &lt;--\n                 $($arg)*,\n                 blue=\"BLUE\", \n                 red=\"RED\", \n                 reset=\"RESET\")\n    }\n}\n\nfn main() {\n    log!(\"{red}{}{reset}\", \"&lt;!&gt;\");\n    // prints: RED&lt;!&gt;RESET\n}\n</code></pre>\n\n<p>(<a href=\"https://doc.rust-lang.org/std/macro.concat.html\" rel=\"nofollow noreferrer\">Docs for <code>concat!</code> macro</a>)</p>\n\n<p>Note that the strings <code>BLUE</code>, <code>RED</code>, <code>RESET</code> will still be sent to the formatting function, so it will incur a minor overhead even nothing will be printed.</p>\n\n<hr>\n\n<p>I think this is quite error prone, since if you forget a <code>{reset}</code> the rest of your console will become red. I wonder why not write something like:</p>\n\n<pre><code>macro_rules! log_red {\n    ($fmt:expr, $($arg:tt)*) =&gt; {\n        println!(concat!(\"RED\", $fmt, \"RESET\"), $($arg)*);\n    }\n}\n// also define `log_blue!`.\n\nlog_red!(\"{}\", \"text\");\n</code></pre>\n"}], "owner": {"reputation": 3039, "user_id": 2851815, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/37MCt.png?s=128&g=1", "display_name": "\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438", "link": "https://stackoverflow.com/users/2851815/%d0%bd%d0%b0%d0%b1%d0%b8%d1%8f%d1%87%d0%bb%d1%8d%d0%b2%d1%8d%d0%bb%d0%b8"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1129, "favorite_count": 2, "accepted_answer_id": 41911995, "answer_count": 1, "score": 10, "last_activity_date": 1485620335, "creation_date": 1485304031, "last_edit_date": 1485304907, "question_id": 41841400, "link": "https://stackoverflow.com/questions/41841400/allow-unused-named-arguments-in-rusts-format-family", "title": "Allow unused named arguments in Rust&#39;s format!() family", "body": "<p>Given:</p>\n\n<pre><code>format!(\"{red}{}{reset}\", \"text\", red = \"RED\", blue = \"BLUE\", reset = \"RESET\");\n</code></pre>\n\n<p>The compilers exits with an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: named argument never used\n  --&gt; example.rs:1:47\n   |\n 1 |         format!(\"{red}{}{reset}\", \"text\", red = \"RED\", blue = \"BLUE\", reset = \"RESET\");\n   |                                                        ^^^^^^^^^^^^^\n</code></pre>\n\n<p>Normally, this wouldn't be a problem as <code>blue</code> should be removed, but my usecase is a wrapper macro (simplified):</p>\n\n<pre><code>macro_rules! log {\n    ($fmt:expr, $($arg:tt)*) =&gt; {\n        println!($fmt, $($arg)*, blue = \"BLUE\", red = \"RED\", reset = \"RESET\");\n    };\n}\n</code></pre>\n\n<p>Sometimes, it is used like this (simplified), but other times with different colours, you get the gist:</p>\n\n<pre><code>log!(\"{red}{}{reset}\", \"text\");\n</code></pre>\n\n<p>The compiler exits with an analogous error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: named argument never used\n  --&gt; example.rs:3:26\n   |\n3  |         println!($fmt, $($arg)*, blue = \"BLUE\", red = \"RED\", reset = \"RESET\");\n   |                                  ^^^^^^^^^^^^^\n</code></pre>\n\n<p>Is it possible to just <em>ignore</em> the unused arguments, instead of erroring on them?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485300346, "post_id": 41840372, "comment_id": 70866793, "body": "Duplicate of <a href=\"http://stackoverflow.com/q/35806568/155423\">Is there a way to detect the compiler version from within a Rust program</a>?"}, {"owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485302865, "post_id": 41840372, "comment_id": 70867552, "body": "I&#39;m not sure it is the same. On this other question, the answers point at one crate for build scripts and the other crate to get the version at runtime. I want to output different code at compile time depending on the version. To put it another way: I want to use a function available at a specific rust version and fallback to another one if using an older compiler."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485303253, "post_id": 41840372, "comment_id": 70867662, "body": "Are you aware that build scripts are run when the crate is compiled (a.k.a. compile time)? The <a href=\"https://github.com/Kimundi/rustc-version-rs\" rel=\"nofollow noreferrer\">README for rustc-version</a> literally has your example in it (search for <code>compiler_has_important_bugfix</code>) \u2014 testing to see if it is compiling against a specific version or better and setting a configuration flag that your code can then use."}, {"owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485364023, "post_id": 41840372, "comment_id": 70898727, "body": "Yeah, I know. But I don&#39;t like having a more complicated build just because I wanted to test my crate on an older Rust version."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485303547, "post_id": 41841282, "comment_id": 70867744, "body": "This forces <i>every downstream consumer</i> to set the flag as appropriate."}, {"owner": {"reputation": 4257, "user_id": 3347227, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/160c472b1c6c43b47cc98cc01d3ce317?s=128&d=identicon&r=PG", "display_name": "Erik Vesteraas", "link": "https://stackoverflow.com/users/3347227/erik-vesteraas"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485303670, "post_id": 41841282, "comment_id": 70867781, "body": "Do downstream consumers run your tests? If not they don&#39;t have to as far as I know. For non-test code I would do it the other way around. (I.e. &quot;newstuff&quot; feature, not &quot;legacy&quot;)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485303878, "post_id": 41841282, "comment_id": 70867839, "body": "Questions on Stack Overflow (especially with generic titles such as this one) are going to be found by people with a wide set of requirements, and they usually don&#39;t read past the title of the question before jumping to the first answer."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485303925, "post_id": 41841282, "comment_id": 70867853, "body": "Besides, if OP wants to maintain compatibility with $OLDVERSION, then they should be testing in CI with both $OLDVERSION and $NEWVERSION, so at the very least OP has to deal with setting the flags appropriately."}, {"owner": {"reputation": 4257, "user_id": 3347227, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/160c472b1c6c43b47cc98cc01d3ce317?s=128&d=identicon&r=PG", "display_name": "Erik Vesteraas", "link": "https://stackoverflow.com/users/3347227/erik-vesteraas"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485303954, "post_id": 41841282, "comment_id": 70867867, "body": "Good point (regarding googlers), I&#39;ll add the general case <i>before</i> the specific one instead of after like I was going to. As for CI I think manually disabling tests to get them to pass is actually preferrable instead of having to do something akin to <code>cargo test --features &quot;alltests&quot;</code> which makes it very easy to accidentally not run all the tests."}], "tags": [], "owner": {"reputation": 4257, "user_id": 3347227, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/160c472b1c6c43b47cc98cc01d3ce317?s=128&d=identicon&r=PG", "display_name": "Erik Vesteraas", "link": "https://stackoverflow.com/users/3347227/erik-vesteraas"}, "is_accepted": true, "score": 2, "last_activity_date": 1485306288, "last_edit_date": 1485306288, "creation_date": 1485303371, "answer_id": 41841282, "question_id": 41840372, "link": "https://stackoverflow.com/questions/41840372/how-to-add-code-only-for-specific-rust-version-without-using-a-build-script/41841282#41841282", "title": "How to add code only for specific Rust version without using a build script?", "body": "<p>While there is no way except build scripts (and in the future procedural macros) to check compiler versions, you can use feature flags to manually enable and disable code.</p>\n\n<p>Usually you want to use some new compiler feature to provide new functionality which you could not do with the old compiler. In that case you use the <code>cfg</code> attribute with feature flags which you define to enable code. E.g.</p>\n\n<pre><code>#[cfg(feature = \"foo\")]\npub fn foo() {\n    cool_new_compiler_function();\n}\n</code></pre>\n\n<p>And in your <code>Cargo.toml</code>:</p>\n\n<pre><code>[features]\nfoo = []\n</code></pre>\n\n<p>Hiding code behind feature flags like this also works in test code. In your specific case you could alternately introduce a <code>legacy</code> feature and disable tests using modern code like this:</p>\n\n<pre><code>#[test]\n#[cfg(not(feature = \"legacy\"))]\nfn test_foo() {\n    Foo::foo();\n}\n</code></pre>\n\n<p>And then to run tests in legacy mode you run:</p>\n\n<pre><code>cargo test --features \"legacy\"\n</code></pre>\n\n<p>Note that doing it the latter way means that your tests will not compile by default on older compilers. For normal (non-test) code, adding such a legacy flag would be a very bad, breaking change.</p>\n"}], "owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 323, "favorite_count": 0, "accepted_answer_id": 41841282, "answer_count": 1, "score": 2, "last_activity_date": 1485368460, "creation_date": 1485298155, "last_edit_date": 1485368460, "question_id": 41840372, "link": "https://stackoverflow.com/questions/41840372/how-to-add-code-only-for-specific-rust-version-without-using-a-build-script", "title": "How to add code only for specific Rust version without using a build script?", "body": "<p>I use a method that appeared in Rust 1.10 for my tests but I want my crate to also work with version 1.7.</p>\n\n<p>Is there a way (something like attribute <code>#[cfg(min_version=\"1.10\")]</code>) to specify code that should only run in Rust 1.10 or newer?</p>\n\n<p>I could use a build script, but I don't want a more complicated build just because I wanted to test my crate on an older Rust version.</p>\n"}, {"tags": ["rust", "borrow-checker"], "owner": {"reputation": 409, "user_id": 2970121, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/d0b21cede510b0bbf986847693a9e075?s=128&d=identicon&r=PG&f=1", "display_name": "njaard", "link": "https://stackoverflow.com/users/2970121/njaard"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 21, "favorite_count": 0, "closed_date": 1485288233, "answer_count": 0, "score": 1, "last_activity_date": 1485288107, "creation_date": 1485287708, "last_edit_date": 1485288107, "question_id": 41837805, "link": "https://stackoverflow.com/questions/41837805/how-do-i-create-an-iterator-that-invalidates-the-previous-result-each-time-next", "closed_reason": "Duplicate", "title": "How do I create an iterator that invalidates the previous result each time `next` is called?", "body": "<p>I'm using FFI to access data from elsewhere. My FFI API returns pointers to data allocated and owned by the C API. I don't have the option to have the C implementation use memory allocated by Rust.</p>\n\n<p>When implementing my API, I want to create an <code>Iterator</code> that produces a <code>&amp;[u8]</code> per <code>next()</code>, but the catch is that every time I call <code>next()</code>, the <code>&amp;[u8]</code> generated by the previous call to <code>next()</code> becomes invalidated.</p>\n\n<p>Here's my C API:</p>\n\n<pre><code>extern {\n  // open an iterator, return a \"ctx\" void*\n  fn read_open() -&gt; *mut libc::c_void;\n  // read the next value of the iterator. The return value is\n  // invalidated when read_next or read_free is called\n  fn read_next(ctx : *mut libc::c_void, data_len : *mut libc::size_t) -&gt; *const libc::void_t;\n  fn read_free(ctx : *mut libc::c_void);\n}\n</code></pre>\n\n<p>How would you create a safe Rusty wrapper around this API such that the data returned by <code>read_next</code> doesn't need to be copied? I would like the object to be <code>Iterator</code>-able.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485272051, "post_id": 41832050, "comment_id": 70850939, "body": "See also <a href=\"http://stackoverflow.com/q/30026893/155423\">Using map with Vectors</a>."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1485272286, "post_id": 41832050, "comment_id": 70851095, "body": "You should change the signature of <code>transform()</code> to accept mutable references instead of consuming <code>SomeType</code>."}, {"owner": {"reputation": 73, "user_id": 7463496, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b8d314ffcabe8e325329bd5dd7e0da61?s=128&d=identicon&r=PG&f=1", "display_name": "Michael", "link": "https://stackoverflow.com/users/7463496/michael"}, "edited": false, "score": 0, "creation_date": 1485272835, "post_id": 41832050, "comment_id": 70851508, "body": "Yes it would be easy with a mutable reference, but <code>transform()</code> does some really complicated transformation, in particular re-using parts of the passed in <code>x</code> in order to produce the result and this is much easier to do in a &quot;functional&quot; style like this (if possible at all, using a mutable reference)."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 10, "last_activity_date": 1485272407, "creation_date": 1485272407, "answer_id": 41832250, "question_id": 41832050, "link": "https://stackoverflow.com/questions/41832050/is-it-possible-to-map-a-function-over-a-vec-without-allocating-a-new-vec/41832250#41832250", "title": "Is it possible to map a function over a Vec without allocating a new Vec?", "body": "<p>Your first problem is not <code>map</code>, it's <code>transform</code>.</p>\n\n<p><code>transform</code> takes ownership of its argument, while <code>Vec</code> has ownership of its arguments. Either one has to give, and poking a hole in the <code>Vec</code> would be a bad idea: what if <code>transform</code> panics?</p>\n\n<hr>\n\n<p>The best fix, thus, is to change the signature of <code>transform</code> to:</p>\n\n<pre><code>fn transform(x: &amp;mut SomeType) { ... }\n</code></pre>\n\n<p>then you can just do:</p>\n\n<pre><code>for x in &amp;mut data { transform(x) }\n</code></pre>\n\n<hr>\n\n<p>Other solutions will be clunky, as they will need to deal with the fact that <code>transform</code> might panic.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1559668219, "last_edit_date": 1559668219, "creation_date": 1485273084, "answer_id": 41832494, "question_id": 41832050, "link": "https://stackoverflow.com/questions/41832050/is-it-possible-to-map-a-function-over-a-vec-without-allocating-a-new-vec/41832494#41832494", "title": "Is it possible to map a function over a Vec without allocating a new Vec?", "body": "<p>No, it is not possible in general because the size of each element might change as the mapping is performed (<code>fn transform(u8) -&gt; u32</code>). </p>\n\n<p>Even when the sizes are the same, it's non-trivial.</p>\n\n<p>In <em>this case</em>, you don't need to create a <code>Dummy</code> variant because creating an empty <code>String</code> is cheap; only 3 pointer-sized values and no heap allocation:</p>\n\n<pre><code>impl SomeType {\n    fn transform(&amp;mut self) {\n        use SomeType::*;\n\n        let old = std::mem::replace(self, VariantA(String::new()));\n\n        // Note this line for the detailed explanation\n\n        *self = match old {\n            VariantA(s) =&gt; VariantB(s, 0),\n            VariantB(s, i) =&gt; VariantB(s, 2 * i),\n        };\n    }\n}\n</code></pre>\n\n<pre><code>for x in &amp;mut data {\n    x.transform();\n}\n</code></pre>\n\n<p>An alternate implementation that just replaces the <code>String</code>:</p>\n\n<pre><code>impl SomeType {\n    fn transform(&amp;mut self) {\n        use SomeType::*;\n\n        *self = match self {\n            VariantA(s) =&gt; {\n                let s = std::mem::replace(s, String::new());\n                VariantB(s, 0)\n            }\n            VariantB(s, i) =&gt; {\n                let s = std::mem::replace(s, String::new());\n                VariantB(s, 2 * *i)\n            }\n        };\n    }\n}\n</code></pre>\n\n<p>In general, yes, you have to create <strong>some</strong> dummy value to do this generically and with safe code. Many times, you can wrap your whole element in <code>Option</code> and call <code>Option::take</code> to achieve the same effect . </p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/36557412/155423\">Change enum variant while moving the field to the new variant</a></li>\n</ul>\n\n<h1>Why is it so complicated?</h1>\n\n<p>See this <a href=\"https://github.com/rust-lang/rfcs/pull/1736\" rel=\"nofollow noreferrer\">proposed and now-closed RFC</a> for lots of related discussion. My understanding of that RFC (and the complexities behind it) is that there's an time period where your value would have an undefined value, which is <strong>not safe</strong>. If a panic were to happen at that exact second, then when your value is dropped, you might trigger undefined behavior, a bad thing.</p>\n\n<p>If your code were to panic at the commented line, then the value of <code>self</code> is a concrete, known value. If it were some unknown value, dropping that string would try to drop that unknown value, and we are back in C. This is the purpose of the <code>Dummy</code> value - to always have a known-good value stored.</p>\n\n<p>You even hinted at this (emphasis mine):</p>\n\n<blockquote>\n  <p>I have to deal with <code>SomeType::Dummy</code> everywhere else in the code, although it <strong>should</strong> never be visible outside of this loop</p>\n</blockquote>\n\n<p>That \"should\" is the problem. During a panic, that dummy value <em>is</em> visible.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/27098694/155423\">How can I swap in a new value for a field in a mutable reference to a structure?</a></li>\n<li><a href=\"https://stackoverflow.com/q/29570781/155423\">Temporarily move out of borrowed content</a></li>\n<li><a href=\"https://stackoverflow.com/q/52031002/155423\">How do I move out of a struct field that is an Option?</a></li>\n</ul>\n\n<p>The <a href=\"https://github.com/rust-lang/rust/blob/1.3.0/src/libcollections/vec.rs#L787-L961\" rel=\"nofollow noreferrer\">now-removed implementation of <code>Vec::map_in_place</code></a> spans almost 175 lines of code, most of having to deal with unsafe code and reasoning why it is actually safe! Some crates have re-implemented this concept and attempted to make it safe; you can see an example in <a href=\"https://stackoverflow.com/a/56448220/155423\">Sebastian Redl's answer</a>.</p>\n"}, {"tags": [], "owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "is_accepted": false, "score": 2, "last_activity_date": 1559667119, "last_edit_date": 1559667119, "creation_date": 1559667033, "answer_id": 56448220, "question_id": 41832050, "link": "https://stackoverflow.com/questions/41832050/is-it-possible-to-map-a-function-over-a-vec-without-allocating-a-new-vec/56448220#56448220", "title": "Is it possible to map a function over a Vec without allocating a new Vec?", "body": "<p>You can write a <code>map_in_place</code> in terms of the <a href=\"https://github.com/Sgeo/take_mut\" rel=\"nofollow noreferrer\"><code>take_mut</code></a> or <a href=\"https://github.com/alecmocatta/replace_with\" rel=\"nofollow noreferrer\"><code>replace_with</code></a> crates:</p>\n\n<pre><code>fn map_in_place&lt;T, F&gt;(v: &amp;mut [T], f: F)\nwhere\n    F: Fn(T) -&gt; T,\n{\n    for e in v {\n        take_mut::take(e, f);\n    }\n}\n</code></pre>\n\n<p>However, if this panics in the supplied function, the program aborts completely; you cannot recover from the panic.</p>\n\n<p>Alternatively, you could supply a placeholder element that sits in the empty spot while the inner function executes:</p>\n\n<pre><code>use std::mem;\n\nfn map_in_place_with_placeholder&lt;T, F&gt;(v: &amp;mut [T], f: F, mut placeholder: T)\nwhere\n    F: Fn(T) -&gt; T,\n{\n    for e in v {\n        let mut tmp = mem::replace(e, placeholder);\n        tmp = f(tmp);\n        placeholder = mem::replace(e, tmp);\n    }\n}\n</code></pre>\n\n<p>If this panics, the placeholder you supplied will sit in the panicked slot.</p>\n\n<p>Finally, you could produce the placeholder on-demand; basically replace <code>take_mut::take</code> with <code>take_mut::take_or_recover</code> in the first version.</p>\n"}], "owner": {"reputation": 73, "user_id": 7463496, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b8d314ffcabe8e325329bd5dd7e0da61?s=128&d=identicon&r=PG&f=1", "display_name": "Michael", "link": "https://stackoverflow.com/users/7463496/michael"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 960, "favorite_count": 1, "accepted_answer_id": 41832494, "answer_count": 3, "score": 7, "last_activity_date": 1559668219, "creation_date": 1485271838, "last_edit_date": 1559667896, "question_id": 41832050, "link": "https://stackoverflow.com/questions/41832050/is-it-possible-to-map-a-function-over-a-vec-without-allocating-a-new-vec", "title": "Is it possible to map a function over a Vec without allocating a new Vec?", "body": "<p>I have the following:</p>\n\n<pre><code>enum SomeType {\n    VariantA(String),\n    VariantB(String, i32),\n}\n\nfn transform(x: SomeType) -&gt; SomeType {\n    // very complicated transformation, reusing parts of x in order to produce result:\n    match x {\n        SomeType::VariantA(s) =&gt; SomeType::VariantB(s, 0),\n        SomeType::VariantB(s, i) =&gt; SomeType::VariantB(s, 2 * i),\n    }\n}\n\nfn main() {\n    let mut data = vec![\n        SomeType::VariantA(\"hello\".to_string()),\n        SomeType::VariantA(\"bye\".to_string()),\n        SomeType::VariantB(\"asdf\".to_string(), 34),\n    ];\n}\n</code></pre>\n\n<p>I would now like to call <code>transform</code> on each element of <code>data</code> and store the resulting value back in <code>data</code>. I could do something like <code>data.into_iter().map(transform).collect()</code>, but this will allocate a new <code>Vec</code>. Is there a way to do this in-place, reusing the allocated memory of <code>data</code>? There once was <code>Vec::map_in_place</code> in Rust but it has been removed some time ago.</p>\n\n<p>As a work-around, I've added a <code>Dummy</code> variant to <code>SomeType</code> and then do the following:</p>\n\n<pre><code>for x in &amp;mut data {\n    let original = ::std::mem::replace(x, SomeType::Dummy);\n    *x = transform(original);\n}\n</code></pre>\n\n<p>This does not feel right, and I have to deal with <code>SomeType::Dummy</code> everywhere else in the code, although it should never be visible outside of this loop. Is there a better way of doing this?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 13883, "user_id": 2883245, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/NPpPG.jpg?s=128&g=1", "display_name": "erip", "link": "https://stackoverflow.com/users/2883245/erip"}, "edited": false, "score": 1, "creation_date": 1485262038, "post_id": 41828287, "comment_id": 70843938, "body": "@erip: That&#39;s exactly the difference between a literal and a NOT literal."}, {"owner": {"reputation": 13883, "user_id": 2883245, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/NPpPG.jpg?s=128&g=1", "display_name": "erip", "link": "https://stackoverflow.com/users/2883245/erip"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485262194, "post_id": 41828287, "comment_id": 70844035, "body": "@MatthieuM. Whoops, overlooked that bit, hehe."}, {"owner": {"reputation": 239269, "user_id": 464709, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0ab3363d257d780bd4c1f0c844b020a2?s=128&d=identicon&r=PG", "display_name": "Fr&#233;d&#233;ric Hamidi", "link": "https://stackoverflow.com/users/464709/fr%c3%a9d%c3%a9ric-hamidi"}, "edited": false, "score": 0, "creation_date": 1485262372, "post_id": 41828287, "comment_id": 70844145, "body": "Very interesting. It appears that you will need a literal format string -- everything seems to revolve around <code>format_args!()</code>, which imposes this limitation. It actually makes sense because the compiler ensures the validity of the formatting operation, it cannot be delayed to run-time."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 1, "creation_date": 1485264689, "post_id": 41828287, "comment_id": 70845735, "body": "I <a href=\"https://github.com/vitiral/strfmt\" rel=\"nofollow noreferrer\">used this a while ago</a> while playing around with string formatting."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 3, "last_activity_date": 1485262603, "creation_date": 1485262603, "answer_id": 41828817, "question_id": 41828287, "link": "https://stackoverflow.com/questions/41828287/how-to-format-a-string-object-in-rust/41828817#41828817", "title": "How to format a String object in Rust?", "body": "<p>The <code>format!</code> macro expects a literal because it invokes compiler magic (<a href=\"https://doc.rust-lang.org/std/macro.format_args.html\" rel=\"nofollow noreferrer\"><code>format_args!</code></a>) to check the format at compile and ensure that its arguments implement the necessary trait. For example <code>{}</code> requires that the argument implements <code>Display</code>, as described in <a href=\"https://doc.rust-lang.org/std/fmt/#formatting-traits\" rel=\"nofollow noreferrer\">Formatting traits</a>.</p>\n\n<p>You <em>might</em> be able to cobble something together by reaching to <a href=\"https://doc.rust-lang.org/std/fmt/struct.Formatter.html\" rel=\"nofollow noreferrer\"><code>Formatter</code></a> directly, but it means parsing the <code>str</code> yourself.</p>\n\n<hr>\n\n<p><em>Note: Rust does not feature reflection, so checking whether a type implements a given trait at runtime is not easy...</em></p>\n"}], "owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "delete_vote_count": 1, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1388, "favorite_count": 1, "closed_date": 1485267196, "accepted_answer_id": 41828817, "answer_count": 1, "score": 0, "last_activity_date": 1485262603, "creation_date": 1485260992, "last_edit_date": 1485262232, "question_id": 41828287, "link": "https://stackoverflow.com/questions/41828287/how-to-format-a-string-object-in-rust", "closed_reason": "Duplicate", "title": "How to format a String object in Rust?", "body": "<p>I have a <code>HashMap</code> with endpoints:</p>\n\n<pre><code>#[derive(Debug, Clone, Copy, Ord, Eq, PartialOrd, PartialEq, Hash)]\nenum Endpoint {\n    OauthToken,\n    Disciplines,\n    PublicTournaments,\n    MyTournaments,\n    Matches,\n}\n\nlazy_static! {\n    static ref API_EP: HashMap&lt;Endpoint, &amp;'static str&gt; = {\n        let mut m: HashMap&lt;Endpoint, &amp;'static str&gt; = HashMap::new();\n        m.insert(Endpoint::OauthToken, \"/oauth/v2/token\");\n        m.insert(Endpoint::Disciplines, \"/v1/disciplines\");\n        m.insert(Endpoint::PublicTournaments, \"/v1/tournaments\");\n        m.insert(Endpoint::MyTournaments, \"/v1/me/tournaments\");\n        m.insert(Endpoint::Matches, \"/v1/tournaments/{}/matches\");\n        m\n    };\n}\n</code></pre>\n\n<p>As you may see, the map item which is accessible by <code>Endpoint::Matches</code> key returns a string which needs to be formatted, however, I don't see a way of doing this.</p>\n\n<p>I've tried to use <code>format!</code> macro but it needs string literals but not an object so it does not work. I tried to search the solution over the internet and rust std library but I was unable to find it. Is there any way to do this?</p>\n\n<p>For clarification why <code>format!</code> does not work:</p>\n\n<pre><code>error: format argument must be a string literal.\n   --&gt; src/lib.rs:249:31\n    |\n249 |         let address = format!(get_ep_address(Endpoint::Matches)?, id.0);\n</code></pre>\n\n<p><code>get_ep_address(Endpoint::Matches)?</code> is not a string literal so it can't work.</p>\n\n<p>I would also like to know how to format both <code>&amp;str</code> and <code>String</code> types.</p>\n"}, {"tags": ["pointers", "rust"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 3, "creation_date": 1485253292, "post_id": 41823321, "comment_id": 70838291, "body": "Why do you need to do this?  It seems like a strange thing to want other than through curiosity."}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1485256576, "post_id": 41823321, "comment_id": 70840460, "body": "To access the struct that contains the enum. Its used directly in a struct that has some general information, would be handy to include in debug/warning messages, otherwise not essential. (the struct is read-only so should be safe in this context)."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1485257993, "post_id": 41823321, "comment_id": 70841370, "body": "So you start off with a reference to the enum or a reference to the variant member? If it&#39;s the first, then you don&#39;t need this at all."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 2, "creation_date": 1485264966, "post_id": 41823321, "comment_id": 70845963, "body": "And if it&#39;s the latter I&#39;d first try to find a different way around it."}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1485290239, "post_id": 41823321, "comment_id": 70862270, "body": "@ker, its variant member, updated questions."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485249830, "post_id": 41824023, "comment_id": 70835965, "body": "I think you&#39;ve got a missing <code>std::mem::forget</code> in your macro to discard <code>base</code>; wouldn&#39;t want <code>Drop</code> to be executed on uninitialized memory. An easy way to test this is put a <code>String</code> in <code>A</code> and scramble the memory of <code>base</code> (memset it with <code>0x8F</code> for example)."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485253967, "post_id": 41824023, "comment_id": 70838765, "body": "It doesn&#39;t appear to be working for enums with multiple fields. I added <code>, ..</code> in the match and this works both single and multiple fields, however the initialization fails for multiple fields and it&#39;s not obvious how to deal with that :("}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485257534, "post_id": 41824023, "comment_id": 70841084, "body": "yes, you need to give a hint in the macro invocation as to how many fields the enum variant has. This is impossible to work around to the best of my knowledge."}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1485294479, "post_id": 41824023, "comment_id": 70864367, "body": "Just tested this for real-world use, works well. Also double-checked and this compiles down to a constant with optimized builds (no actual <code>std::mem</code> use). Would have assumed so, but nice to confirm."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 4, "last_activity_date": 1485253458, "last_edit_date": 1485253458, "creation_date": 1485248700, "answer_id": 41824023, "question_id": 41823321, "link": "https://stackoverflow.com/questions/41823321/how-to-get-pointer-offset-of-an-enum-member-in-bytes/41824023#41824023", "title": "How to get pointer offset of an enum member in bytes?", "body": "<p>Enum variants differ heavily from struct fields. An enum variant does not have a unique type that's different from the enum's type. Even internally in the Rust compiler enum variants are represented including the discriminant of the enum. This means that an enum variant's offset to the enum itself is zero.</p>\n\n<p>More likely you want the offset of an enum variant's field. Since the only way to obtain a reference to an enum variant's field is to match on a value of an enum, you'd need a valid enum value to match on, so you can't use the nullpointer trick used in the struct field offset calculation.</p>\n\n<pre><code>macro_rules! offset_of {\n    ($($tt:tt)*) =&gt; {\n        {\n            let base = $($tt)*(unsafe { ::std::mem::uninitialized() });\n            let offset = match base {\n                $($tt)*(ref inner) =&gt; (inner as *const _ as usize) - (&amp;base as *const _ as usize),\n                _ =&gt; unreachable!(),\n            };\n            ::std::mem::forget(base);\n            offset\n        }\n    }\n}\nenum Foo {\n    A(i32),\n    B(u8),\n}\nlet offset = offset_of!(Foo::A);\n</code></pre>\n\n<p>It is left to the reader to implement this macro for enum struct variants and enum tuple variants with more than one field.</p>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1074, "favorite_count": 1, "accepted_answer_id": 41824023, "answer_count": 1, "score": 3, "last_activity_date": 1485291001, "creation_date": 1485246427, "last_edit_date": 1495540902, "question_id": 41823321, "link": "https://stackoverflow.com/questions/41823321/how-to-get-pointer-offset-of-an-enum-member-in-bytes", "title": "How to get pointer offset of an enum member in bytes?", "body": "<p>For a struct member its possible to calculate the <a href=\"https://stackoverflow.com/questions/40310483/how-to-get-pointer-offset-in-bytes/40310851#40310851\"><code>offsetof</code></a> in Rust, similar to C's <code>offsetof</code>.</p>\n\n<p>While this works for struct fields, I couldn't find an equivalent of how to do this for enums and their variant members.</p>\n\n<p>From talking to developers on IRC its not guaranteed that all members of an enum are aligned:</p>\n\n<p>How to calculate the offset of an enum member?</p>\n\n<hr>\n\n<p>With instances it could work like this:</p>\n\n<pre><code>enum Test { A(u8), B(f64) };\n\nfn test_me(a: Test) {\n    if let Test::A(b) = a {\n        // we could find the offset between 'a' and 'b' here.\n        // but how to do this without instantiating variables?\n        println(\"{}\", (b as *const _) as usize - (a as *const _) as usize);\n    }\n}\n</code></pre>\n\n<p>However the aim is to be able to do this by inspecting only the type, so it could compile down to a constant, eg:</p>\n\n<pre><code>println(\"{}\", offset_of_enum!(Test, A));\n</code></pre>\n\n<hr>\n\n<p><em>While attempting to write a macro for this I ran into problems joining the arguments by <code>::</code> so I wasn't sure how to resolve that part.</em></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 2, "creation_date": 1485238132, "post_id": 41820891, "comment_id": 70830012, "body": "Can I ask why you can&#39;t change the function signature? That seems like you&#39;re shutting the door on potential solutions and creates something of an <a href=\"http://xyproblem.info/\" rel=\"nofollow noreferrer\">XY problem</a> in my opinion. I understand your example is stripped down to the basics but without knowing more, it seems strange to require the mutability of both a child and its parent in the same function signature (in this particular small example). Perhaps you could pass the parent or just the child with a <code>Result</code> that the caller can act on?"}, {"owner": {"reputation": 53, "user_id": 882682, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b58a6f61b13d15a4d01a128d06f66c39?s=128&d=identicon&r=PG", "display_name": "on_pwogram&#232;", "link": "https://stackoverflow.com/users/882682/on-pwogram%c3%a8"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1485260024, "post_id": 41820891, "comment_id": 70842689, "body": "In order to push for rust, I decided to rewrite a library of which the design has already been decided (<a href=\"https://github.com/xmedius/\" rel=\"nofollow noreferrer\">sendsecure-*</a>) and I wanted to keep kind of the same homogeneity than in the other languages. I&#39;m doing something similar than <a href=\"https://github.com/xmedius/sendsecure-java/blob/master/src/main/java/com/xmedius/sendsecure/Client.java#L234\" rel=\"nofollow noreferrer\">this</a> in Java. Here, <code>uploadAttachment()</code> is the <code>bar()</code> function I wrote in the above example."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1485263076, "post_id": 41820891, "comment_id": 70844645, "body": "If I may make a bold claim (having looked quickly at the Java sample you linked to) - your <i>actual</i> use case does not require that the parent be mutable. <code>uploadAttachment</code> in your linked GitHub source only ever calls <code>getUploadUrl</code> on the <code>safebox</code>. I would say translating this to Rust should be straight forward, in that you can pass the URL in separately without doubling the mutable reference."}], "answers": [{"comments": [{"owner": {"reputation": 53, "user_id": 882682, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b58a6f61b13d15a4d01a128d06f66c39?s=128&d=identicon&r=PG", "display_name": "on_pwogram&#232;", "link": "https://stackoverflow.com/users/882682/on-pwogram%c3%a8"}, "edited": false, "score": 0, "creation_date": 1485272858, "post_id": 41829162, "comment_id": 70851536, "body": "Yes, I understand this is a bad idea to try to port the code line-for-line. But with the &quot;inside-of-the-box&quot; being different, the goal was for me to try to provide the same API for homogeinity. The reason why the signature of <code>uploadAttachment()</code> was as is, is because of <code>submitSafebox(&amp;mut safebox)</code> which require a mutable borrow because of the [call to] (<a href=\"https://github.com/xmedius/sendsecure-java/blob/master/src/main/java/com/xmedius/sendsecure/Client.java#L232\" rel=\"nofollow noreferrer\">github.com/xmedius/sendsecure-java/blob/master/src/main/jav&zwnj;&#8203;a/&hellip;</a>) <code>initializeSafebox(&amp;mut safebox)</code>. But you&#39;re right, giving <code>uploadAttachment</code> the url may be the most normal thing to do."}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 0, "last_activity_date": 1485267758, "last_edit_date": 1485267758, "creation_date": 1485263662, "answer_id": 41829162, "question_id": 41820891, "link": "https://stackoverflow.com/questions/41820891/another-interrogation-about-cannot-borrow-x-as-mutable-more-than-once-at-a-tim/41829162#41829162", "title": "Another interrogation about cannot borrow `x` as mutable more than once at a time error", "body": "<p>The GitHub Java example you linked to doesn't actually require that the parent and child both be mutable. In fact, the parent (in your Java, this is the <code>safebox</code>) only ever calls <code>getUploadUrl()</code>.</p>\n\n<p>As such, I have translated it slightly into Rust for you with similar type names to your Java example. The idea being that the method itself only cares about the URL ... so pass it in directly rather than taking a mutable reference:</p>\n\n<pre><code>struct Attachment {\n    guid: String,\n}\n\nimpl Attachment {\n    fn new&lt;S&gt;(guid: S) -&gt; Attachment\n        where S: Into&lt;String&gt;\n    {\n        Attachment { guid: guid.into() }\n    }\n\n    fn set_guid&lt;S&gt;(&amp;mut self, guid: S)\n        where S: Into&lt;String&gt;\n    {\n        self.guid = guid.into();\n    }\n}\n\nstruct SafeBox {\n    attachments: Vec&lt;Attachment&gt;,\n    upload_url: &amp;'static str,\n}\n\nimpl SafeBox {\n    fn get_upload_url(&amp;self) -&gt; &amp;str {\n        self.upload_url\n    }\n}\n\nfn uploadAttachment(upload_url: &amp;str, attachment: &amp;mut Attachment) {\n    attachment.set_guid(\"12345\");\n}\n\nfn main() {\n    let mut safebox = SafeBox {\n        attachments: vec![Attachment::new(\"12345\"), Attachment::new(\"67890\")],\n        upload_url: \"http://upload.com/upload\",\n    };\n\n    for mut attachment in &amp;mut safebox.attachments {\n        uploadAttachment(safebox.upload_url, &amp;mut attachment);\n    }\n}\n</code></pre>\n\n<p>Here it is <a href=\"http://play.integer32.com/?gist=dc55c96d4aec6577c715c660a0106a3b&amp;version=stable\" rel=\"nofollow noreferrer\">running in the playground</a>.</p>\n\n<p>As someone who has tried porting a simple C# library to Rust, I can tell you from experience it is a bad idea to try and port it line-for-line, type-for-type. The Rust Way (tm) is very different and C# (or Java) simply can't be ported directly.</p>\n"}], "owner": {"reputation": 53, "user_id": 882682, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b58a6f61b13d15a4d01a128d06f66c39?s=128&d=identicon&r=PG", "display_name": "on_pwogram&#232;", "link": "https://stackoverflow.com/users/882682/on-pwogram%c3%a8"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 120, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1485267758, "creation_date": 1485237023, "question_id": 41820891, "link": "https://stackoverflow.com/questions/41820891/another-interrogation-about-cannot-borrow-x-as-mutable-more-than-once-at-a-tim", "title": "Another interrogation about cannot borrow `x` as mutable more than once at a time error", "body": "<p>Considering the following code :</p>\n\n<pre><code>struct Foo {\n    x: i32,\n}\n\nstruct Test {\n    foos: Vec&lt;Foo&gt;,\n    v: i32,\n}\n\nfn bar(test: &amp;mut Test, foo: &amp;mut Foo){\n    // make something with test\n    foo.x = 42;\n}\n\nfn main() {\n    let test = &amp;mut Test {\n        foos: vec![\n            Foo {x: 3}, \n            Foo {x: 4},\n        ], \n        v: 55\n    };\n\n    // First time test got borrowed\n    let iterator = test.foos.iter_mut();\n\n    for elem in iterator {\n        // !!Error second time test got borrowed as mutable\n        bar(test, elem);\n    }\n\n}\n</code></pre>\n\n<p>Supposing I can't change its signature, Is there a way to call <code>bar</code> in the loop for each element of <code>test.foos</code> without violating the only one <code>&amp;mut</code> at a time rule?</p>\n\n<p>The ony solution I can think of is to clone test before it got borrowed as mutable the first time, as in:</p>\n\n<pre><code>let mut tutu = test.to_owned();\nlet iterator = test.foos.iter_mut();\n\nfor elem in iterator {\n    bar(&amp;mut tutu, elem);\n}\n</code></pre>\n\n<p>but cloning a struct feels like possibly expensive operation depending of the struct.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1485239483, "post_id": 41821049, "comment_id": 70830578, "body": "Just a note: this also words with ordinals: <code>println!(&quot;{:01$}&quot;, x, width)</code>.  Also, might be worth linking to the <a href=\"https://doc.rust-lang.org/std/fmt/index.html#syntax\" rel=\"nofollow noreferrer\"><code>std::fmt</code> docs</a> that spell all this out."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1485240098, "post_id": 41821049, "comment_id": 70830839, "body": "Thanks @DK. I have added your suggested improvements."}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": true, "score": 24, "last_activity_date": 1485240043, "last_edit_date": 1485240043, "creation_date": 1485237778, "answer_id": 41821049, "question_id": 41820818, "link": "https://stackoverflow.com/questions/41820818/how-can-i-0-pad-a-number-by-a-variable-amount-when-formatting-with-stdfmt/41821049#41821049", "title": "How can I 0-pad a number by a variable amount when formatting with std::fmt?", "body": "<p>You can use the <code>:0_</code> format specifier with a variable:</p>\n\n<pre><code>println!(\"{:0width$}\", x, width = width); // prints 001234\n</code></pre>\n\n<p><a href=\"http://play.integer32.com/?gist=c2a09c2ead5466278422b8b2e8d7cb71&amp;version=stable\" rel=\"noreferrer\">Here it is running in the playground</a></p>\n\n<p>Likewise, if <code>width &lt;= 4</code>, it just prints <code>1234</code>. If <code>width = 60</code>, it prints:</p>\n\n<pre><code>000000000000000000000000000000000000000000000000000000001234\n</code></pre>\n\n<p>The format arguments also support ordinals, thus this also works:</p>\n\n<pre><code>println!(\"{:01$}\", x, width);\n</code></pre>\n\n<p>The <a href=\"https://doc.rust-lang.org/std/fmt/index.html#syntax\" rel=\"noreferrer\">documentation for std::fmt</a> has a rundown of the various parameters and modifiers the <code>print_!</code> macros support.</p>\n"}], "owner": {"reputation": 1131, "user_id": 871288, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d9c9fe5e31a460ddce0ee8e4cd0fb13e?s=128&d=identicon&r=PG", "display_name": "Fitzsimmons", "link": "https://stackoverflow.com/users/871288/fitzsimmons"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5368, "favorite_count": 2, "accepted_answer_id": 41821049, "answer_count": 1, "score": 11, "last_activity_date": 1485240043, "creation_date": 1485236670, "question_id": 41820818, "link": "https://stackoverflow.com/questions/41820818/how-can-i-0-pad-a-number-by-a-variable-amount-when-formatting-with-stdfmt", "title": "How can I 0-pad a number by a variable amount when formatting with std::fmt?", "body": "<p>I'm looking to 0-pad a string before I display it to the user, e.g.</p>\n\n<pre><code>let x = 1234;\nprintln!(\"{:06}\", x); // \"001234\"\n</code></pre>\n\n<p>However, I'd like the length of the output string to be variable, e.g. it could be set by a command line parameter from the user:</p>\n\n<pre><code>let x = 1234;\nlet width = 6;\nprintln!(\"{:0*}\", width, x); //fails to compile\n// error: invalid format string: expected `'}'`, found `'*'`\n</code></pre>\n\n<p>Unlike precision, it doesn't seem that 0-padding supports the <code>*</code> for specifying a width.</p>\n\n<p>I'm not looking for solutions that involve manually padding, because it seems awkward to re-implement part of <code>std::fmt</code>.</p>\n"}, {"tags": ["enums", "casting", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485215532, "post_id": 41817718, "comment_id": 70823608, "body": "FWIW, your second ` unreachable!()` shouldn&#39;t be required, as <code>_</code> should match all the other possibilities."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485216346, "post_id": 41817718, "comment_id": 70823902, "body": "And then it can be something like <code>match self.data { MyEnum::EnumKind(ref value) =&gt; value, _ =&gt; unreachable!() }</code> which isn&#39;t terrible. Or the <code>if let</code> from the duplicate."}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 41, "favorite_count": 0, "closed_date": 1485215490, "answer_count": 0, "score": 0, "last_activity_date": 1485215643, "creation_date": 1485215292, "last_edit_date": 1485215643, "question_id": 41817718, "link": "https://stackoverflow.com/questions/41817718/get-value-from-an-enum-when-its-known", "closed_reason": "Duplicate", "title": "Get value from an enum when its known?", "body": "<p>When the type of an enum is known, getting its value seems overly verbose, compared to getting the value from a box for example.</p>\n\n<p>Given this function which gets <code>self.data</code> 's value when its type of enum is known:</p>\n\n<pre><code>fn enum_known_type_cast(&amp;self) -&gt; &amp;SomeValue {\n    match self.data {\n        MyEnum::EnumKind(ref value) =&gt; {\n            return value;\n        }\n        _ =&gt; {\n            unreachable!();\n        }\n    }\n}\n</code></pre>\n\n<p>Can it be simplified to something like this?</p>\n\n<pre><code>fn enum_known_type_cast(&amp;self) -&gt; &amp;SomeValue {\n    match self.data.enum_unwrap_mut&lt;MyEnum::EnumKind&gt;();\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1485217509, "post_id": 41815619, "comment_id": 70824223, "body": "I don&#39;t know the answer, but I think I&#39;d bite the bullet and add an explicit variable, if only to make the code as clear to understand as possible. <code>unsafe</code> requires enough brain power as it is."}], "answers": [{"tags": [], "owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "is_accepted": true, "score": 4, "last_activity_date": 1485330992, "last_edit_date": 1485330992, "creation_date": 1485247213, "answer_id": 41823541, "question_id": 41815619, "link": "https://stackoverflow.com/questions/41815619/are-raw-pointers-to-temporaries-ok-in-rust/41823541#41823541", "title": "Are raw pointers to temporaries ok in Rust?", "body": "<p>You are right. In this case, <code>foo</code> is called first and <code>RawLayout</code> is dropped afterwards. This is explained in <a href=\"https://doc.rust-lang.org/reference.html#temporary-lifetimes\" rel=\"nofollow noreferrer\">The Rust Reference</a> (follow the link to see concrete examples of how this works out in practice):</p>\n\n<blockquote>\n  <p>The lifetime of temporary values is typically the innermost enclosing\n  statement</p>\n</blockquote>\n\n<p>However, I would rather follow Shepmaster's advice. Explicitly introducing a local variable would help the reader of the code concentrate in more important things, like ensuring that the unsafe code is correct (instead of having to figure out the exact semantics of temporary variables).</p>\n\n<h3>How to check this</h3>\n\n<p>You can use the code below to check this behavior:</p>\n\n<pre><code>struct Layout;\nstruct RawLayout;\n\nimpl Into&lt;RawLayout&gt; for Layout {\n    fn into(self) -&gt; RawLayout {\n        RawLayout\n    }\n}\n\nimpl Drop for RawLayout {\n    fn drop(&amp;mut self) {\n        println!(\"Dropping RawLayout\");\n    }\n}\n\nunsafe fn foo(layout: *const RawLayout) -&gt; u8 {\n    println!(\"foo called\");\n    1\n}\n\nfn bar(layout: Layout) -&gt; bool {\n    unsafe {\n        foo(&amp;layout.into() as *const _) != 0\n    }\n}\n\nfn main() {\n    bar(Layout);    \n}\n</code></pre>\n\n<p>The output is:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>foo called\nDropping RawLayout\n</code></pre>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 298, "favorite_count": 1, "accepted_answer_id": 41823541, "answer_count": 1, "score": 12, "last_activity_date": 1485330992, "creation_date": 1485205553, "last_edit_date": 1485217769, "question_id": 41815619, "link": "https://stackoverflow.com/questions/41815619/are-raw-pointers-to-temporaries-ok-in-rust", "title": "Are raw pointers to temporaries ok in Rust?", "body": "<p>I have a function like this:</p>\n\n<pre><code>extern {\n    fn foo(layout: *const RawLayout) -&gt; libc::uint8_t;\n}\n\nfn bar(layout: Layout) -&gt; bool {\n    unsafe {\n        foo(&amp;layout.into() as *const _) != 0\n    }\n}\n</code></pre>\n\n<p>Where <code>Layout</code> is a copyable type that can be converted <code>.into()</code> a <code>RawLayout</code>.</p>\n\n<p>I want to make sure I understand what is happening as it is unsafe. As I understand it, <code>layout.into()</code> creates a temporary <code>RawLayout</code>, then <code>&amp;</code> takes a reference to it, and <code>as *const _</code> converts it to a raw pointer (<code>*const RawLayout</code>). Then the <code>foo()</code> function is called and returns, and finally the temporary <code>RawLayout</code> is dropped.</p>\n\n<p>Is that correct? Or is there some tricky reason why I shouldn't do this?</p>\n"}, {"tags": ["generics", "rust"], "answers": [{"comments": [{"owner": {"reputation": 959, "user_id": 6779010, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/i7Jj0.png?s=128&g=1", "display_name": "torkleyy", "link": "https://stackoverflow.com/users/6779010/torkleyy"}, "edited": false, "score": 0, "creation_date": 1485589025, "post_id": 41812785, "comment_id": 70996705, "body": "I&#39;m not sure if I fully understand your <code>fn foo</code>. Isn&#39;t there always an implicit bound on <code>Sized</code>?"}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "reply_to_user": {"reputation": 959, "user_id": 6779010, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/i7Jj0.png?s=128&g=1", "display_name": "torkleyy", "link": "https://stackoverflow.com/users/6779010/torkleyy"}, "edited": false, "score": 1, "creation_date": 1485605275, "post_id": 41812785, "comment_id": 71000537, "body": "@torkleyy On the function argument, yes. That is ok because what we&#39;re providing is indeed always sized, in either case. The second function takes <code>&amp;T</code>, which is sized, even if T is not."}], "tags": [], "owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "is_accepted": true, "score": 6, "last_activity_date": 1485195812, "last_edit_date": 1485195812, "creation_date": 1485194705, "answer_id": 41812785, "question_id": 41812293, "link": "https://stackoverflow.com/questions/41812293/implement-function-for-trait-implementor-with-dynamic-and-static-dispatch/41812785#41812785", "title": "Implement function for trait implementor with dynamic and static dispatch", "body": "<p>That is indeed possible. One option is to explicitly implement <code>A</code> for its reference types:</p>\n\n<pre><code>impl&lt;'a, T: A + ?Sized&gt; A for &amp;'a T {}\n</code></pre>\n\n<p>The argument becomes a trait object when <code>T = &amp;A</code>, while still doing static dispatch for known implementors of <code>A</code>. The following code should now compile:</p>\n\n<pre><code>fn foo&lt;T: A&gt;(a: T) {}\n\nstruct MyA;\nimpl A for MyA {}\n\nfn main() {\n    foo(MyA{});\n    foo(&amp;MyA{});\n    foo(&amp;MyA{} as &amp;A);\n}\n</code></pre>\n\n<p>If you are willing to always pass a borrowed argument, you can also do this instead:</p>\n\n<pre><code>fn foo&lt;T: A + ?Sized&gt;(a: &amp;T) {}\n</code></pre>\n\n<p>The argument becomes a trait object when <code>T = A</code>.</p>\n"}], "owner": {"reputation": 959, "user_id": 6779010, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/i7Jj0.png?s=128&g=1", "display_name": "torkleyy", "link": "https://stackoverflow.com/users/6779010/torkleyy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 83, "favorite_count": 0, "accepted_answer_id": 41812785, "answer_count": 1, "score": 5, "last_activity_date": 1485195812, "creation_date": 1485192995, "question_id": 41812293, "link": "https://stackoverflow.com/questions/41812293/implement-function-for-trait-implementor-with-dynamic-and-static-dispatch", "title": "Implement function for trait implementor with dynamic and static dispatch", "body": "<p>I want to have a function <code>foo</code> taking an instance of a type which implements a trait <code>A</code>. I always prefer to use generics in order to have static dispatch:</p>\n\n<pre><code>trait A {}\n\nfn foo&lt;T: A&gt;(t: T) {}\n</code></pre>\n\n<hr>\n\n<p>However, this approach introduces some inflexibility, I can't pass a trait object like here:</p>\n\n<pre><code>trait A {}\n\nfn foo(t: &amp;A) {}\n</code></pre>\n\n<p>The thing is, sometimes I know the type and sometimes not. Is there a way to have both dynamic dispatch for trait objects and static dispatch for compile time known types while not implementing things twice?</p>\n"}, {"tags": ["rust", "future"], "comments": [{"owner": {"reputation": 26154, "user_id": 5436257, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/iGuaK.jpg?s=128&g=1", "display_name": "Joe Clay", "link": "https://stackoverflow.com/users/5436257/joe-clay"}, "edited": false, "score": 2, "creation_date": 1485189407, "post_id": 41811075, "comment_id": 70810416, "body": "<i>&quot;The following clearly doesn&#39;t work</i>&quot; - how so? Can you include the error, or describe what behavior you&#39;re seeing?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1485189448, "post_id": 41811075, "comment_id": 70810445, "body": "Please produce a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a> when asking questions on Stack Overflow."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1485189562, "post_id": 41811075, "comment_id": 70810529, "body": "I bet that the <b>missing error message</b> says something about <i>expected a <code>T</code>, found a <code>&amp;T</code></i>. If that&#39;s the case, I&#39;d strongly recommend that you go back and re-read through <a href=\"https://doc.rust-lang.org/stable/book/\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i></a>, as this would not be a problem regarding Tokio, but rather basic Rust ownership."}, {"owner": {"reputation": 263, "user_id": 1754145, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0b090e29c500ad1ae5f477c9f1b2b6c8?s=128&d=identicon&r=PG", "display_name": "Benjamin Reed", "link": "https://stackoverflow.com/users/1754145/benjamin-reed"}, "edited": false, "score": 0, "creation_date": 1485230049, "post_id": 41811075, "comment_id": 70827424, "body": "sorry, i added code that doesn&#39;t work to express conceptually what i wanted, but it doesn&#39;t work for many reasons including ownership and lifetime problems. i see that it is a distraction rather than conceptually illustrative, so i&#39;ll delete it."}], "answers": [{"comments": [{"owner": {"reputation": 263, "user_id": 1754145, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0b090e29c500ad1ae5f477c9f1b2b6c8?s=128&d=identicon&r=PG", "display_name": "Benjamin Reed", "link": "https://stackoverflow.com/users/1754145/benjamin-reed"}, "edited": false, "score": 2, "creation_date": 1485291166, "post_id": 41831216, "comment_id": 70862766, "body": "great answer! <a href=\"https://tokio.rs\" rel=\"nofollow noreferrer\">tokio.rs</a> is also a fantastic pointer. it definitely needs to be upranked in google. i&#39;ve been using the sources and docs and a couple of blogs to figure out tokio."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 263, "user_id": 1754145, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0b090e29c500ad1ae5f477c9f1b2b6c8?s=128&d=identicon&r=PG", "display_name": "Benjamin Reed", "link": "https://stackoverflow.com/users/1754145/benjamin-reed"}, "edited": false, "score": 0, "creation_date": 1485293464, "post_id": 41831216, "comment_id": 70863926, "body": "I&#39;m sure that the Google rankings will steadily climb; Tokio 0.1 was only released 2 weeks ago after all!"}, {"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "edited": false, "score": 0, "creation_date": 1485366867, "post_id": 41831216, "comment_id": 70900521, "body": "Thanks for this detailed answer. It made something click for me, about why you would intentionally design an API to take advantage of Rust&#39;s move semantics."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "edited": false, "score": 0, "creation_date": 1485368393, "post_id": 41831216, "comment_id": 70901433, "body": "@PeterHall great! I&#39;m not 100% sure, but I think that in this case, the move semantics also help with the &quot;zero-additional-cost&quot; aspect of futures."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 14, "last_activity_date": 1581969128, "last_edit_date": 1581969128, "creation_date": 1485269482, "answer_id": 41831216, "question_id": 41811075, "link": "https://stackoverflow.com/questions/41811075/how-do-i-send-a-list-of-items-through-a-futuressink/41831216#41831216", "title": "How do I send a list of items through a futures::Sink?", "body": "<p>When using a new piece of software, I find it very useful to read the documentation before diving in too deep. The Rust community has, in general, provided pretty great resources.</p>\n\n<p>For example, the Tokio project has an <a href=\"https://tokio.rs/docs/getting-started/hello-world/\" rel=\"nofollow noreferrer\">entire site of documentation</a> which includes a <a href=\"https://tokio.rs/docs/getting-started/echo/\" rel=\"nofollow noreferrer\">selection of working examples</a>. The <a href=\"https://docs.rs/futures/0.3.4/futures/sink/trait.Sink.html\" rel=\"nofollow noreferrer\">generated API documentation for <code>Sink</code></a> is also invaluable here.</p>\n\n<p>Another thing that I recommend all programmers learn to do is to create a <a href=\"/help/mcve\">MCVE</a> of the problem. This allows them to focus on the core of the problem while also removing cruft and honing the words behind the problem. Here's one for this case:</p>\n\n<pre><code>use futures::{Sink, SinkExt}; // 0.3.4\n\nfn thing(mut sink: impl Sink&lt;i32&gt;) {\n    let mut all_the_things = vec![1, 2, 3, 4, 5];\n\n    while let Some(v) = all_the_things.pop() {\n        sink.send(v);\n    }\n}\n</code></pre>\n\n<p>We get the error message </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `impl Sink&lt;i32&gt;: std::marker::Unpin` is not satisfied\n --&gt; src/lib.rs:7:14\n  |\n3 | fn thing(mut sink: impl Sink&lt;i32&gt;) {\n  |                    -------------- help: consider further restricting this bound: `impl Sink&lt;i32&gt; + std::marker::Unpin`\n...\n7 |         sink.send(v);\n  |              ^^^^ the trait `std::marker::Unpin` is not implemented for `impl Sink&lt;i32&gt;`\n</code></pre>\n\n<p>Let's turn back to the API documentation for <a href=\"https://docs.rs/futures/0.3.4/futures/sink/trait.SinkExt.html#method.send\" rel=\"nofollow noreferrer\"><code>SinkExt::send</code></a>...</p>\n\n<pre><code>fn send(&amp;mut self, item: Item) -&gt; Send&lt;Self, Item&gt;\nwhere\n    Self: Unpin, \n</code></pre>\n\n<p>From this, we can see that <code>send</code> requires that the type implement <code>Unpin</code>, so let's change that:</p>\n\n<pre><code>use futures::{Sink, SinkExt}; // 0.3.4\nuse std::marker::Unpin;\n\nfn thing(mut sink: impl Sink&lt;i32&gt; + Unpin) {\n    let mut all_the_things = vec![1, 2, 3, 4, 5];\n\n    while let Some(v) = all_the_things.pop() {\n        sink.send(v);\n    }\n}\n</code></pre>\n\n<p>This compiles, but has a warning:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>warning: unused `futures_util::sink::send::Send` that must be used\n --&gt; src/lib.rs:8:9\n  |\n8 |         sink.send(v);\n  |         ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_must_use)]` on by default\n  = note: futures do nothing unless you `.await` or poll them\n</code></pre>\n\n<p>Reviewing the API again, we see it returns a <a href=\"https://docs.rs/futures/0.3.4/futures/sink/struct.Send.html\" rel=\"nofollow noreferrer\"><code>Send</code></a> value. That's strange, isn't it? It's actually not <em>that</em> strange, once you see that <code>Send</code> implements <code>Future</code> - pushing something into the stream might block if the stream is full; this is the concept of <em>back pressure</em>. Having the result be a <code>Future</code> is how you can know when the item has actually been added to the stream. </p>\n\n<p>One solution is to drive that future to completion with <code>.await</code> and making out function <code>async</code>:</p>\n\n<pre><code>use futures::{Sink, SinkExt}; // 0.3.4\nuse std::marker::Unpin;\n\nasync fn thing(mut sink: impl Sink&lt;i32&gt; + Unpin) {\n    let mut all_the_things = vec![1, 2, 3, 4, 5];\n\n    while let Some(v) = all_the_things.pop() {\n        sink.send(v)\n            .await\n            .unwrap_or_else(|_| panic!(\"Unable to send item\"));\n    }\n}\n</code></pre>\n\n<p>This compiles, but isn't super pretty. Turning back to the documentation, we can also see <a href=\"https://docs.rs/futures/0.3.4/futures/sink/trait.SinkExt.html#method.send_all\" rel=\"nofollow noreferrer\"><code>Sink::send_all</code></a>, which takes a <a href=\"https://docs.rs/futures/0.3.4/futures/stream/trait.TryStream.html\" rel=\"nofollow noreferrer\"><code>TryStream</code></a>. We can create a <code>Stream</code> from an iterator by using <a href=\"https://docs.rs/futures/0.3.4/futures/stream/fn.iter.html\" rel=\"nofollow noreferrer\"><code>stream::iter</code></a> and driving the future returned by <code>send_all</code> to completion:</p>\n\n<pre><code>use futures::{stream, Sink, SinkExt}; // 0.3.4\nuse std::marker::Unpin;\n\nasync fn thing(mut sink: impl Sink&lt;i32&gt; + Unpin) {\n    let all_the_things = vec![1, 2, 3, 4, 5];\n    let mut stream = stream::iter(all_the_things.into_iter().map(Ok));\n\n    sink.send_all(&amp;mut stream)\n        .await\n        .unwrap_or_else(|_| panic!(\"Unable to send item\"));\n}\n</code></pre>\n"}], "owner": {"reputation": 263, "user_id": 1754145, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0b090e29c500ad1ae5f477c9f1b2b6c8?s=128&d=identicon&r=PG", "display_name": "Benjamin Reed", "link": "https://stackoverflow.com/users/1754145/benjamin-reed"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3307, "favorite_count": 2, "accepted_answer_id": 41831216, "answer_count": 1, "score": 3, "last_activity_date": 1581969128, "creation_date": 1485189016, "last_edit_date": 1485267879, "question_id": 41811075, "link": "https://stackoverflow.com/questions/41811075/how-do-i-send-a-list-of-items-through-a-futuressink", "title": "How do I send a list of items through a futures::Sink?", "body": "<p>I have a list of items to send through a futures::<code>Sink</code>:</p>\n\n<pre><code>let mut list = VecDeque::new();\n/* add a bunch of Packet items to list */\nlet (sink, stream) = tcp_stream.framed(PacketCodec).split();\n</code></pre>\n\n<p>I can send one packet using</p>\n\n<pre><code>if let Some(first) = list.pop_front() {\n    sink.send(first);\n}\n</code></pre>\n\n<p>How do I send the whole list?</p>\n"}, {"tags": ["asynchronous", "rust", "future"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485188362, "post_id": 41810686, "comment_id": 70809705, "body": "There&#39;s a 99.9% chance that you do <b>not</b> want to use atomic variables in that manner. Instead, you want <code>fetch_add</code> and the vast majority of people do not want <code>Relaxed</code> ordering."}, {"owner": {"reputation": 29, "user_id": 7458511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fadf3e85a3a9f567dae157b07c3292f0?s=128&d=identicon&r=PG&f=1", "display_name": "Phil D", "link": "https://stackoverflow.com/users/7458511/phil-d"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485204957, "post_id": 41810686, "comment_id": 70819132, "body": "Your right, I just copy / paste some code to show that I want to get a result from the future execution that depends on the execution of the other futures."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485267450, "post_id": 41810686, "comment_id": 70847719, "body": "It is <a href=\"http://meta.stackoverflow.com/q/309237/155423\"><i>extremely bad form</i> to change your question <b>after you received answers</b>, especially when the change invalidates those answers</a>. It is on the question asker to ask a good question that includes any pertinent details from the beginning."}, {"owner": {"reputation": 29, "user_id": 7458511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fadf3e85a3a9f567dae157b07c3292f0?s=128&d=identicon&r=PG&f=1", "display_name": "Phil D", "link": "https://stackoverflow.com/users/7458511/phil-d"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485274339, "post_id": 41810686, "comment_id": 70852643, "body": "So I can&#39;t change my question (I understand why), I can&#39;t reply to the answer. My reply was deleted. So How can I add  deeper explanation to the initial question, specially when they refer to the answers , use the comment? I&#39;am really not used to the stackaverflow way to process. Usually the flow of discution allow to follow the evolution. Next time when I&#39;ll have a complexe question I will use Reddit or other forums. Thanks for your remarks and your help to improve my use of stackoverflow."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485275205, "post_id": 41810686, "comment_id": 70853283, "body": "You absolutely <b>can</b> reply to an answer. That&#39;s what the comments below each answer are for (just like the comments below this question). Stack Overflow is a question and answer site. That doesn&#39;t fit everyone&#39;s style, and that&#39;s OK. <a href=\"https://www.reddit.com/r/rust/\" rel=\"nofollow noreferrer\">/r/rust</a>, <a href=\"https://users.rust-lang.org/\" rel=\"nofollow noreferrer\">the user&#39;s forum</a> or <a href=\"https://www.rust-lang.org/en-US/community.html\" rel=\"nofollow noreferrer\">IRC</a> are great places to have actual discussions about your Rust code."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485275560, "post_id": 41810686, "comment_id": 70853547, "body": "One thing to recall is that answering <i>an individual&#39;s</i> question isn&#39;t the main purpose of SO. Answering a question that many people may have (which the original formation seemed to fit) once so that it can be found and used again and again is. Building up a library of good answers allows us to move forward as an industry and avoid having to repeat ourselves over and over."}, {"owner": {"reputation": 29, "user_id": 7458511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fadf3e85a3a9f567dae157b07c3292f0?s=128&d=identicon&r=PG&f=1", "display_name": "Phil D", "link": "https://stackoverflow.com/users/7458511/phil-d"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485278344, "post_id": 41810686, "comment_id": 70855377, "body": "I didn&#39;t know. Now I&#39;m aware thanks to your help. I understand stackoverflow&#39;s positioning, so I hope I will use it on purpose know."}, {"owner": {"reputation": 29, "user_id": 7458511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fadf3e85a3a9f567dae157b07c3292f0?s=128&d=identicon&r=PG&f=1", "display_name": "Phil D", "link": "https://stackoverflow.com/users/7458511/phil-d"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485278411, "post_id": 41810686, "comment_id": 70855420, "body": "Any idea if future.rs will propose future state access during processing?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485295820, "post_id": 41810686, "comment_id": 70864979, "body": "I&#39;m not even sure I understand what you mean by that. However, you may want to jump into <a href=\"https://gitter.im/tokio-rs/tokio\" rel=\"nofollow noreferrer\">gitter.im/tokio-rs/tokio</a> to ask tokio- / future-related questions about long-term planning."}, {"owner": {"reputation": 29, "user_id": 7458511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fadf3e85a3a9f567dae157b07c3292f0?s=128&d=identicon&r=PG&f=1", "display_name": "Phil D", "link": "https://stackoverflow.com/users/7458511/phil-d"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485331914, "post_id": 41810686, "comment_id": 70876918, "body": "My last comment after I repost my question on a forum to allow a better discussion(I don&#39;t have access to the chat). What I think is in Pytgon: <a href=\"https://docs.python.org/3/library/asyncio-task.html#asyncio.Future.done\" rel=\"nofollow noreferrer\">Done</a> or in Java <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html\" rel=\"nofollow noreferrer\">isDone</a>. I&#39;ll investigate a little more to have a better understanding."}], "answers": [{"tags": [], "owner": {"reputation": 183, "user_id": 1478094, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ae146805f7ab3b42f216117263b710ae?s=128&d=identicon&r=PG", "display_name": "Euan Rochester", "link": "https://stackoverflow.com/users/1478094/euan-rochester"}, "is_accepted": false, "score": 2, "last_activity_date": 1485199353, "last_edit_date": 1485199353, "creation_date": 1485198815, "answer_id": 41813881, "question_id": 41810686, "link": "https://stackoverflow.com/questions/41810686/how-to-poll-future-state-without-waiting/41813881#41813881", "title": "How to poll Future state without waiting?", "body": "<p>To poll a <code>Future</code> you must have a <code>Task</code>. To get a <code>Task</code> you can poll in a <code>Future</code> passed to <code>futures::executor::spawn()</code>. If you re-write the <code>loop</code> of your example like so:</p>\n\n<pre><code>futures::executor::spawn(futures::lazy(|| {\n    // existing loop goes here\n})).wait_future();\n</code></pre>\n\n<p>It runs.</p>\n\n<p>As to <em>why</em> a <code>Future</code> can only be polled in a task, I believe it's so that polling can call <code>Task::Unpark</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 0, "last_activity_date": 1485215977, "last_edit_date": 1495542252, "creation_date": 1485215247, "answer_id": 41817709, "question_id": 41810686, "link": "https://stackoverflow.com/questions/41810686/how-to-poll-future-state-without-waiting/41817709#41817709", "title": "How to poll Future state without waiting?", "body": "<blockquote>\n  <p>I want to do something during the future processing</p>\n</blockquote>\n\n<p>As I understand it, that's what futures <em>are</em> - things that can happen in parallel. If you want to do something else, then make another future and throw it in!</p>\n\n<p>You are basically already doing this - each of your threads is \"doing something else\".</p>\n\n<blockquote>\n  <p>poll the future and when it's ready get the result</p>\n</blockquote>\n\n<p>Using <code>future::select_all</code>, you can combine multiple futures and get whichever finishes first. It is then up to you decide to wait for the next one.</p>\n\n<p>One potential implementation:</p>\n\n<pre><code>extern crate rand;\nextern crate futures;\nextern crate futures_cpupool;\n\nuse rand::Rng;\nuse futures::{future, Future};\nuse futures_cpupool::CpuPool;\n\nuse std::{thread, time};\n\nfn main() {\n    let thread_pool = CpuPool::new(4);\n\n    let futures = (0..10).map(|i| {\n        thread_pool.spawn_fn(move || -&gt; Result&lt;usize, ()&gt; {\n            let mut rng = rand::thread_rng();\n            // Simulate long processing\n            let sleep_time = rng.gen_range(10, 100);\n            let sleep_time = time::Duration::from_millis(sleep_time);\n            for _ in 0..10 {\n                println!(\"Thread {} sleeping\", i);\n                thread::sleep(sleep_time);\n            }\n            Ok(i)\n        })\n    });\n\n    let mut one = future::select_all(futures);\n    while let Ok((value, _idx, remaining)) = one.wait() {\n        println!(\"Future #{} finished\", value);\n        if remaining.is_empty() {\n            break;\n        }\n        one = future::select_all(remaining);\n    }\n}\n</code></pre>\n\n<p>During the call to <code>wait</code>, multiple things are happening concurrently! This can be seen by the interleaved output:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Thread 2 sleeping\nThread 0 sleeping\nThread 3 sleeping\nThread 1 sleeping\nThread 3 sleeping\nThread 0 sleeping\nThread 1 sleeping\nThread 2 sleeping\nThread 3 sleeping\n</code></pre>\n\n<p>You can verify that things are happening in parallel by setting the sleep time to 1 second for each thread and timing the overall program. Since there are 10 futures, taking 1 second, with a parallelism of 4, the overall program takes 3 seconds to run.</p>\n\n<hr>\n\n<p>Bonus code review:</p>\n\n<ol>\n<li>Don't split loading and setting an atomic variable to implement incrementing - <strong>the stored value might have been changed by another thread between the two calls</strong>. Use <code>fetch_add</code>.</li>\n<li>You <em>really, really</em> should know <a href=\"https://stackoverflow.com/q/30407121/155423\">what the orderings mean</a> before using them. I do not know them, so I always use <code>SeqCst</code>.</li>\n<li>Since it wasn't important for this example, I removed the atomic variable completely.</li>\n<li>Always prefer collecting into a <code>Vec</code> instead of pushing into it inside a loop. This allows for more optimized allocation.</li>\n<li>In this case, there's no need for a <code>Vec</code> at all as <code>select_all</code> accepts anything that can be turned into an iterator. </li>\n</ol>\n"}], "owner": {"reputation": 29, "user_id": 7458511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fadf3e85a3a9f567dae157b07c3292f0?s=128&d=identicon&r=PG&f=1", "display_name": "Phil D", "link": "https://stackoverflow.com/users/7458511/phil-d"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1891, "favorite_count": 1, "answer_count": 2, "score": 2, "last_activity_date": 1485274577, "creation_date": 1485187777, "last_edit_date": 1485274577, "question_id": 41810686, "link": "https://stackoverflow.com/questions/41810686/how-to-poll-future-state-without-waiting", "title": "How to poll Future state without waiting?", "body": "<p>I'm trying to use Future.rs to manage some tasks in a separate process. I see how to wait for each created future and how to process them one after the other, but I wasn't able to poll the future during its execution to know its state. I always have the error: </p>\n\n<blockquote>\n  <p>thread 'main' panicked at 'no Task is currently running'</p>\n</blockquote>\n\n<p>I want to do something during the future processing until it finishes. Perhaps I'm not using it the right way? I managed to make it work by using a channel, but I think it should be possible to poll the future and when it's ready get the result.\nThe code I use to test it is:</p>\n\n<pre><code>fn main() {\n    println!(\"test future\");\n    let thread_pool = CpuPool::new(4);\n    let mut future_execution_list = vec![];\n    let mutex = Arc::new(AtomicUsize::new(0));\n    //create the future to process\n    for _ in 0..10 {\n        let send_mutex = mutex.clone();\n        let future = thread_pool.spawn_fn(move || {\n            //Simulate long processing\n            thread::sleep(time::Duration::from_millis(10));\n            let num = send_mutex.load(Ordering::Relaxed);\n            send_mutex.store(num + 1, Ordering::Relaxed);\n            let res: Result&lt;usize, ()&gt; = Ok(num);\n            res\n\n        });\n        future_execution_list.push(future);\n    }\n    // do the job\n    loop {\n        for future in &amp;mut future_execution_list {\n            match future.poll() {\n                Ok(Async::NotReady) =&gt; (), //do nothing\n                Ok(Async::Ready(num)) =&gt; {\n                    //update task status\n                    println!(\" future {:?}\", num);\n                }\n                Err(_) =&gt; {\n                    //log error and set task status to err\n                    ()\n                }\n            };\n        }\n        //do something else\n    }\n}\n</code></pre>\n\n<p>So I complete my question after Shepmaster answer. Your remarks are very interesting but I still can't find a solutin to my problem. I'll add some informations about my problem. I want to schedule tasks on a automate that can manage several tasks at a time. There is a loop where event are managed and tasks scheduling is calculated. When a task is scheduled, it's spawn. When a task ends a new scheduling is done. During task execution, event are managed. A speudo code can be:</p>\n\n<pre><code>loop {\n   event.try_recv() { ...} //manage user command for exemple\n   if (schedule) {\n      let tasks_to_spawn = schedule_task();\n      let futures = tasks_to_spawn.map(|task| {\n           thread_pool.spawn_fn( ....)}); \n      let mut one = future::select_all(futures);\n      while let Ok((value, _idx, remaining)) = one.wait() {..} //wait here\n   }\n   //depend on task end state and event  set schedule to true or false.\n\n}\n</code></pre>\n\n<p>I can joint the scheduling and the task in a future like :</p>\n\n<pre><code>let future = schedule.and_them(|task| execute_task);\n</code></pre>\n\n<p>But I still need to wait the end of the execution of the first task.\nI can put everything in a future (event management, schedule, task) and wait the first one that end like you propose. I try but I didn't see how to make a vec of future with different Item and Error type. And with this conception I have to manage more data between thread. Event management and scheduling doesn't have to be executed in a different thread.</p>\n\n<p>I see another problem,  select_all take the ownership of the vec. If a new task has to be sheduled during the execution of the other how can I change the vec and add the new future? </p>\n\n<p>Don't know if you have a simple solution. I was thinking that it was simple to get the state of the future during its execution with a method like isDone() without to wait. Perhaps it's planned, I didn't see a PR about that. \nIf you have a simple solution it would be great otherwise I'll rethink my conception. </p>\n"}, {"tags": ["string", "rust", "std", "ownership-semantics"], "answers": [{"comments": [{"owner": {"reputation": 949, "user_id": 1219515, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/64ce0ac7d44d2076d23b21ac62214970?s=128&d=identicon&r=PG", "display_name": "Maciej Goszczycki", "link": "https://stackoverflow.com/users/1219515/maciej-goszczycki"}, "edited": false, "score": 0, "creation_date": 1485192566, "post_id": 41810115, "comment_id": 70812380, "body": "Neat. I thought there would be no way without moving ownership outside of the function. Just my C ways shining through."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 949, "user_id": 1219515, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/64ce0ac7d44d2076d23b21ac62214970?s=128&d=identicon&r=PG", "display_name": "Maciej Goszczycki", "link": "https://stackoverflow.com/users/1219515/maciej-goszczycki"}, "edited": false, "score": 0, "creation_date": 1485195095, "post_id": 41810115, "comment_id": 70813767, "body": "@mgoszcz2 I&#39;m not sure I&#39;m following you - in the first and third examples, new data is allocated, and in the second example, ownership <i>is</i> outside of the function."}, {"owner": {"reputation": 949, "user_id": 1219515, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/64ce0ac7d44d2076d23b21ac62214970?s=128&d=identicon&r=PG", "display_name": "Maciej Goszczycki", "link": "https://stackoverflow.com/users/1219515/maciej-goszczycki"}, "edited": false, "score": 0, "creation_date": 1485226902, "post_id": 41810115, "comment_id": 70826616, "body": "No it&#39;s just in C I would just return a pointer to <code>argv[0] + offset</code>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 949, "user_id": 1219515, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/64ce0ac7d44d2076d23b21ac62214970?s=128&d=identicon&r=PG", "display_name": "Maciej Goszczycki", "link": "https://stackoverflow.com/users/1219515/maciej-goszczycki"}, "edited": false, "score": 0, "creation_date": 1485227365, "post_id": 41810115, "comment_id": 70826724, "body": "@mgoszcz2 ah, yes, that&#39;s closest to the second example. <code>argv[0]</code>, in the name of <code>exe</code>, is passed into the function, and then the string is offset and terminated and returned, just with more error handling."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1485187261, "last_edit_date": 1495542257, "creation_date": 1485186004, "answer_id": 41810115, "question_id": 41809913, "link": "https://stackoverflow.com/questions/41809913/is-there-a-way-to-avoid-cloning-when-converting-a-pathbuf-to-a-string/41810115#41810115", "title": "Is there a way to avoid cloning when converting a PathBuf to a String?", "body": "<blockquote>\n  <p>Is there a way to avoid cloning when converting a <code>PathBuf</code> to a <code>String</code>?</p>\n</blockquote>\n\n<p>Absolutely. However, that's not what you are doing. You are taking a <strong>part</strong> of the <code>PathBuf</code> via <code>file_name</code> and converting that. You cannot take ownership of a part of a string.</p>\n\n<p>If you weren't taking a subset, then converting an entire <code>PathBuf</code> can be done by converting to an <code>OsString</code> and then to a <code>String</code>. Here, I ignore the specific errors and just return success or failure:</p>\n\n<pre><code>use std::path::PathBuf;\n\nfn exe_name() -&gt; Option&lt;String&gt; {\n    std::env::current_exe()\n        .ok()\n        .map(PathBuf::into_os_string)\n        .and_then(|exe| exe.into_string().ok())\n}\n</code></pre>\n\n<blockquote>\n  <p>Is there any way to avoid this <code>&amp;OsStr -&gt; &amp;str -&gt; String -&gt; &amp;str</code> cycle?</p>\n</blockquote>\n\n<p>No, because you are creating the <code>String</code> (or <code>OsString</code> or <code>PathBuf</code>, whichever holds ownership depending on the variant of code) inside your method. Check out <a href=\"https://stackoverflow.com/q/29428227/155423\">Return local String as a slice (&amp;str)</a> for why you cannot return a reference to a stack-allocated item (including a string).</p>\n\n<p>As stated in that Q&amp;A, if you want to have references, the thing owning the data has to outlive the references:</p>\n\n<pre><code>use std::env;\nuse std::path::Path;\nuse std::ffi::OsStr;\n\nfn binary_name(path: &amp;Path) -&gt; Option&lt;&amp;str&gt; {\n    path.file_name().and_then(OsStr::to_str)\n}\n\nfn main() {\n    let exe = env::current_exe().ok();\n    match exe.as_ref().and_then(|e| binary_name(e)) {\n        Some(\"cat\") =&gt; println!(\"Called as cat\"),\n        Some(\"dog\") =&gt; println!(\"Called as dog\"),\n        Some(other) =&gt; println!(\"Why did you call me {}?\", other),\n        None =&gt; println!(\"Not able to figure out what I was called as\"),\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>Your original code can be written to not crash on errors easily enough</p>\n\n<pre><code>fn binary_name() -&gt; Option&lt;String&gt; {\n    let exe = std::env::current_exe();\n    exe.ok()\n        .as_ref()\n        .and_then(|p| p.file_name())\n        .and_then(|s| s.to_str())\n        .map(String::from)\n}\n</code></pre>\n"}], "owner": {"reputation": 949, "user_id": 1219515, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/64ce0ac7d44d2076d23b21ac62214970?s=128&d=identicon&r=PG", "display_name": "Maciej Goszczycki", "link": "https://stackoverflow.com/users/1219515/maciej-goszczycki"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1835, "favorite_count": 1, "accepted_answer_id": 41810115, "answer_count": 1, "score": 2, "last_activity_date": 1485187261, "creation_date": 1485185413, "last_edit_date": 1485186848, "question_id": 41809913, "link": "https://stackoverflow.com/questions/41809913/is-there-a-way-to-avoid-cloning-when-converting-a-pathbuf-to-a-string", "title": "Is there a way to avoid cloning when converting a PathBuf to a String?", "body": "<p>I need to simply (and dangerously - error handling omitted for brevity) get the current executable name. I made it work, but my function converts a <code>&amp;str</code> to <code>String</code> only to call <code>as_str()</code> on it later for pattern matching.</p>\n\n<pre><code>fn binary_name() -&gt; String {\n    std::env::current_exe().unwrap().file_name().unwrap().to_str().unwrap().to_string()\n}\n</code></pre>\n\n<p>As I understand it, <code>std::env::current_exe()</code> gives me ownership of the <code>PathBuf</code> which I could transfer by returning it. As it stands, I borrow it to convert it to <code>&amp;str</code>. From there, the only way to return the string is to clone it before the <code>PathBuf</code> is dropped.</p>\n\n<p>Is there any way to avoid this <code>&amp;OsStr -&gt; &amp;str -&gt; String -&gt; &amp;str</code> cycle?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 2, "creation_date": 1485135884, "post_id": 41798160, "comment_id": 70784607, "body": "Have you considered keeping track of the length as you push/pull items? Then your function simply becomes: <code>fn len(&amp;self) -&gt; usize { self.item_count }</code> ... ? This has the benefit of making your <code>len</code> function <i>much</i> quicker."}, {"owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 1, "creation_date": 1485136031, "post_id": 41798160, "comment_id": 70784633, "body": "Well, that would be way better perform-wise, but I&#39;m not doing this for the performance, I wanted to know how I could do this by going through every node, if possible of course."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485168539, "post_id": 41798160, "comment_id": 70796580, "body": "Note: <code>push_back</code> is actually pushing to the front, no?"}, {"owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485201863, "post_id": 41798160, "comment_id": 70817411, "body": "@MatthieuM. Well, I was kind of unsure how to name it, it makes sense that the last element is the front yeah, I&#39;ll change it to push_front, thanks!"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1485244770, "post_id": 41798160, "comment_id": 70833062, "body": "@DavidFrickert: I&#39;ve unfortunately seen many implementations of linked list with an &quot;append&quot; function, which involves walking to the end each time. Shortest way to quadratic complexity."}], "answers": [{"comments": [{"owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "edited": false, "score": 1, "creation_date": 1485137696, "post_id": 41798335, "comment_id": 70784971, "body": "That makes a lot of sense... I&#39;m really dumb... It was actually not hard. I&#39;ll need to really understand references and borrowing and all that rust-specific behaviour. Since I come from Java I kind of miss those simple things. Thanks."}, {"owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "edited": false, "score": 0, "creation_date": 1485137838, "post_id": 41798335, "comment_id": 70785017, "body": "Actually, I partially read that, the beginning. But they don&#39;t implement a len() method, so that&#39;s why I kind of lost interest, but will do when I get better at grasping the basics!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "edited": false, "score": 4, "creation_date": 1485137849, "post_id": 41798335, "comment_id": 70785023, "body": "@DavidFrickert yup, having to deal with some of these details takes some getting used to. However, after a little practice, you will find that these details fade into the background and help you think about your code (in all languages) a little bit better."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "edited": false, "score": 0, "creation_date": 1485137939, "post_id": 41798335, "comment_id": 70785049, "body": "@DavidFrickert in that case, there&#39;s no <i>need</i> to implement <code>len</code> because it would just be <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.count\" rel=\"nofollow noreferrer\"><code>Iterator::count</code></a> on the <code>iter()</code> - by implementing an iterator, you get all those features for free."}, {"owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "edited": false, "score": 0, "creation_date": 1485138151, "post_id": 41798335, "comment_id": 70785100, "body": "Oh, I did not know that, since <code>std::collections::LinkedList</code> has a <code>len()</code> I did not even consider that possibility. That should be quite useful."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "edited": false, "score": 0, "creation_date": 1485138368, "post_id": 41798335, "comment_id": 70785160, "body": "@DavidFrickert of course, you could then implement <code>len</code> as <code>self.iter().count()</code> to provide a nicer API."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1485168707, "post_id": 41798335, "comment_id": 70796692, "body": "Don&#39;t put yourself down; I struggled with C++ back then because of this pointers and <code>const</code> for the very same reason, it takes some time to line the dots. The good news is that after a while it&#39;s just intuitive."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1485137976, "last_edit_date": 1495540897, "creation_date": 1485137514, "answer_id": 41798335, "question_id": 41798160, "link": "https://stackoverflow.com/questions/41798160/how-can-i-implement-a-len-function-for-linked-list/41798335#41798335", "title": "How can I implement a len() function for linked list?", "body": "<p>You appear to be confusing a mutable <em>variable binding</em> with a mutable <em>reference</em>. I'd recommend reading <a href=\"https://stackoverflow.com/q/28587698/155423\">What&#39;s the difference in `mut` before a variable name and after the `:`?</a></p>\n\n<p>In short, you do not want any mutable references to the list here; you are not modifying the list. You do need to be able to mutate the variable holding the immutable reference to the head of the list.</p>\n\n<pre><code>fn len(&amp;self) -&gt; usize {\n    let mut list = &amp;self.head;\n    let mut count = 0;\n\n    while let Some(ref rest) = *list {\n        count += 1;\n        list = &amp;rest.next;\n    }\n\n    count\n}\n</code></pre>\n\n<p>I'd also recommend reading <a href=\"http://cglab.ca/~abeinges/blah/too-many-lists/book/\" rel=\"nofollow noreferrer\">Learning Rust With Entirely Too Many Linked Lists</a>.</p>\n"}, {"comments": [{"owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "edited": false, "score": 0, "creation_date": 1485137747, "post_id": 41798343, "comment_id": 70784990, "body": "Yeah I see that makes sense, I probably was kind of trying all the stuff possible to make it work and I didn&#39;t even realise it was so simple... Thanks!"}], "tags": [], "owner": {"reputation": 148712, "user_id": 19750, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/13b41b2620da0b1e630715e0c91a0b03?s=128&d=identicon&r=PG", "display_name": "Josh Lee", "link": "https://stackoverflow.com/users/19750/josh-lee"}, "is_accepted": false, "score": 3, "last_activity_date": 1485137540, "creation_date": 1485137540, "answer_id": 41798343, "question_id": 41798160, "link": "https://stackoverflow.com/questions/41798160/how-can-i-implement-a-len-function-for-linked-list/41798343#41798343", "title": "How can I implement a len() function for linked list?", "body": "<p>Use a mutable local variable (not a mutable borrow):</p>\n\n<pre><code>let mut list = &amp;self.head;\nwhile let Some(ref rest) = *list {\n    count += 1;\n    list = &amp;rest.next;\n}\n</code></pre>\n\n<p>Here we need the binding to be mutable (<code>let mut</code>), not the data (<code>&amp;mut</code>). See <a href=\"https://doc.rust-lang.org/book/mutability.html\" rel=\"nofollow noreferrer\">Mutability</a>.</p>\n"}], "owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 258, "favorite_count": 0, "accepted_answer_id": 41798335, "answer_count": 2, "score": 0, "last_activity_date": 1485137976, "creation_date": 1485135826, "last_edit_date": 1485137188, "question_id": 41798160, "link": "https://stackoverflow.com/questions/41798160/how-can-i-implement-a-len-function-for-linked-list", "title": "How can I implement a len() function for linked list?", "body": "<p>I implemented some basic linked list operations:</p>\n\n<pre><code>use std::mem;\n\n//Generic List\nstruct LinkedList&lt;T&gt; {\n    head: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\nstruct Node&lt;T&gt; {\n    element: T,\n    next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\n\n//List functions\nimpl&lt;T&gt; LinkedList&lt;T&gt; {\n    //Create empty list\n    fn new() -&gt; LinkedList&lt;T&gt; {\n        LinkedList { head: None }\n    }\n\n    //push element\n    fn push_back(&amp;mut self, t: T) {\n        let new_node = Box::new(Node {\n            element: t,\n            next: mem::replace(&amp;mut self.head, None),\n        });\n\n        self.head = Some(new_node);\n\n    }\n}        \n</code></pre>\n\n<p>I could not implement a <code>len</code> method:</p>\n\n<pre><code>//length calculator\nfn len(&amp;self) -&gt; usize {\n    let ref mut list = self.head;\n    let mut count = 0;\n\n    while let &amp;mut Some(ref rest) = list {\n        count += 1;\n        list = &amp;mut rest.next;\n    }\n    count\n}\n</code></pre>\n\n<p>My idea was to loop while I could be sure I had a <code>Some</code>, and stop when I had a <code>None</code> in my variable <code>list</code>.</p>\n\n<p>Though this doesn't work, I can't make a mutable reference to a non-mutable variable, and apparently I can't re-assign the list variable:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: cannot borrow immutable field `self.head` as mutable\n  --&gt; 8_generics.rs:54:13\n   |\n54 |         let ref mut list = self.head;\n   |             ^^^^^^^^^^^^\n\nerror: cannot borrow immutable field `rest.next` as mutable\n  --&gt; 8_generics.rs:59:25\n   |\n59 |             list = &amp;mut rest.next;\n   |                         ^^^^^^^^^\n\nerror[E0506]: cannot assign to `list` because it is borrowed\n  --&gt; 8_generics.rs:59:13\n   |\n 57|         while let &amp;mut Some(ref rest) = list {\n   |                             -------- borrow of `list` occurs here\n58 |             count += 1;\n59 |             list = &amp;mut rest.next;\n|             ^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `list` occurs     here\n\nerror[E0384]: re-assignment of immutable variable `list`\n  --&gt; 8_generics.rs:59:13\n   |\n54 |         let ref mut list = self.head;\n   |             ------------ first assignment to `list`\n...\n59 |             list = &amp;mut rest.next;\n   |             ^^^^^^^^^^^^^^^^^^^^^ re-assignment of immutable variable\n</code></pre>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1485114778, "post_id": 41794800, "comment_id": 70778980, "body": "I asked on #rust and it seems that <a href=\"https://github.com/rust-lang/rust/issues/24622#issuecomment-94761287\" rel=\"nofollow noreferrer\">this code</a> would break things, if the <code>T: &#39;a</code> requirement was lifted. But I don&#39;t really understand that code yet and I will stop trying for now. Hopefully someone who understands the issue answers in the meantime ^_^"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1502274769, "post_id": 41794800, "comment_id": 78135041, "body": "<a href=\"https://github.com/rust-lang/rfcs/pull/2093\" rel=\"nofollow noreferrer\">Related RFC from August 2017</a>"}], "answers": [{"tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": true, "score": 23, "last_activity_date": 1485117570, "creation_date": 1485117570, "answer_id": 41795887, "question_id": 41794800, "link": "https://stackoverflow.com/questions/41794800/why-is-the-bound-t-a-required-in-order-to-store-a-reference-a-t/41795887#41795887", "title": "Why is the bound `T: &#39;a` required in order to store a reference `&amp;&#39;a T`?", "body": "<p>This is part of the well-formedness rules. The type <code>&amp;'a T</code> is only well-formed if <code>T: 'a</code> (\u201cT outlives 'a\u201d; it is required because we have a reference which we can access during the scope <code>'a</code>; the pointed-to value in <code>T</code> needs to be valid for at least that scope, too).</p>\n\n<p><code>struct RefWrapper&lt;'a, T&gt;</code> is a generic type and it says you can input a lifetime <code>'x</code> and a type <code>U</code> and get a <code>RefWrapper&lt;'x, U&gt;</code> type back. However, this type is not necessarily well-formed or even implemented unless the requirement <code>T: 'a</code> is respected.</p>\n\n<p>This requirement comes from an implementation detail; it's not necessarily so that <code>T</code> and <code>'a</code> are used together like <code>&amp;'a T</code> in the struct's internals. The well formedness requirement needs to be promoted to the public interface of the <code>RefWrapper</code> struct, so that the requirements of forming a <code>RefWrapper&lt;'_, _&gt;</code> type are public, even if the internal implementation is not.</p>\n\n<p>(There are other places where the same requirement <code>T: 'a</code> comes back but is implict:</p>\n\n<pre><code>pub fn foo&lt;'a, T&gt;(x: &amp;'a T) { }\n</code></pre>\n\n<p>we spot a difference: here the type <code>&amp;'a T</code> is part of the public api, too.)</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 11, "last_activity_date": 1542748377, "last_edit_date": 1542748377, "creation_date": 1530195687, "answer_id": 51085291, "question_id": 41794800, "link": "https://stackoverflow.com/questions/41794800/why-is-the-bound-t-a-required-in-order-to-store-a-reference-a-t/51085291#51085291", "title": "Why is the bound `T: &#39;a` required in order to store a reference `&amp;&#39;a T`?", "body": "<p>Congratulations, you were right! As of Rust 1.31, thanks to <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2093-infer-outlives.md\" rel=\"noreferrer\">RFC 2093, Infer <code>T: 'x</code> outlives requirements on structs</a>, the requirement on the user to type out this restriction has been removed:</p>\n\n<blockquote>\n  <p>Remove the need for explicit <code>T: 'x</code> annotations on structs. We will infer their presence based on the fields of the struct. In short, if the struct contains a reference, directly or indirectly, to <code>T</code> with lifetime <code>'x</code>, then we will infer that <code>T: 'x</code> is a requirement</p>\n</blockquote>\n\n<p>Basically, there wasn't a case where this wasn't required, so there wasn't much value in forcing the programmer to write it out.</p>\n"}], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 670, "favorite_count": 4, "accepted_answer_id": 41795887, "answer_count": 2, "score": 30, "last_activity_date": 1542748377, "creation_date": 1485110728, "last_edit_date": 1485114203, "question_id": 41794800, "link": "https://stackoverflow.com/questions/41794800/why-is-the-bound-t-a-required-in-order-to-store-a-reference-a-t", "title": "Why is the bound `T: &#39;a` required in order to store a reference `&amp;&#39;a T`?", "body": "<p>Given this code:</p>\n\n<pre><code>struct RefWrapper&lt;'a, T&gt; {\n    r: &amp;'a T,\n}\n</code></pre>\n\n<p>... the compiler complains:</p>\n\n<blockquote>\n  <p>error: the parameter type <code>T</code> may not live long enough</p>\n  \n  <p>consider adding an explicit lifetime bound <code>T: 'a</code> so that the reference type <code>&amp;'a T</code> does not outlive the data it points at.</p>\n</blockquote>\n\n<p>I've seen this error multiple times already and so far I just listened to the compiler and everything worked out fine. However, thinking more about it, I don't understand <em>why</em> I have to write <code>T: 'a</code>.</p>\n\n<p>As far as I understand, it is <em>already</em> impossible to get such a reference. Having <code>&amp;'a T</code> implies that there is an object of type <code>T</code> that lives for at least <code>'a</code>. But we can't store any references in said object which point to data having a shorter lifetime than <code>'a</code>. This would <em>already</em> result in a compiler error. </p>\n\n<p>In that sense it is already impossible to get a <code>&amp;'a T</code> where <code>T</code> does not outlive <code>'a</code>. Thus the additional annotation (<code>T: 'a</code>) shouldn't be necessary.</p>\n\n<p>Am I right? Am I wrong and if yes: how could I break code, if <code>T: 'a</code> would not be required?</p>\n\n<hr>\n\n<p>Links:</p>\n\n<ul>\n<li><a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0192-bounds-on-object-and-generic-types.md\">RFC introducing the syntax</a></li>\n<li><a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1214-projections-lifetimes-and-wf.md\">Another maybe related RFC</a></li>\n</ul>\n"}, {"tags": ["rust", "mutable"], "answers": [{"comments": [{"owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "edited": false, "score": 1, "creation_date": 1485182617, "post_id": 41794667, "comment_id": 70805868, "body": "the strange thing is that <code>x.add(1)</code> works in all cases though... In that case probably coercion kicks in?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "edited": false, "score": 0, "creation_date": 1485185015, "post_id": 41794667, "comment_id": 70807418, "body": "@PaoloFalabella I&#39;m not sure when <i>coercion</i> is the right term; but yes, I&#39;d assume that <a href=\"http://stackoverflow.com/q/28519997/155423\">automatic dereferencing</a> is coming into play there."}, {"owner": {"reputation": 2966, "user_id": 3022310, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/7f10ec2b45320ee843e539d705c31d08?s=128&d=identicon&r=PG", "display_name": "turbulencetoo", "link": "https://stackoverflow.com/users/3022310/turbulencetoo"}, "edited": false, "score": 0, "creation_date": 1485276423, "post_id": 41794667, "comment_id": 70854129, "body": "So in this case an <code>&amp;T</code> is behaving just like a <code>T</code>. In general though should I be dereferencing all my immutable references before using them?  Or is it exceedingly common to implement most all of <code>T</code>s methods for <code>&amp;T</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2966, "user_id": 3022310, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/7f10ec2b45320ee843e539d705c31d08?s=128&d=identicon&r=PG", "display_name": "turbulencetoo", "link": "https://stackoverflow.com/users/3022310/turbulencetoo"}, "edited": false, "score": 0, "creation_date": 1485276732, "post_id": 41794667, "comment_id": 70854339, "body": "@turbulencetoo I&#39;m not sure I follow you. If you have a value, you can call <i>methods</i> of that type that accept <code>&amp;self</code> or <code>self</code> with no ceremony. Whether or not you implement the method as taking <code>self</code> or <code>&amp;self</code> boils down to what the function needs to do. I would wager that a majority of methods take <code>&amp;self</code> because they don&#39;t need the power granted by <code>&amp;mut self</code> or <code>self</code>. I find it reasonably rare to have to add an explicit <code>*</code> and generally wait until the compiler tells me to add it."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1485185329, "last_edit_date": 1485185329, "creation_date": 1485109895, "answer_id": 41794667, "question_id": 41794464, "link": "https://stackoverflow.com/questions/41794464/whats-the-difference-between-immutable-and-mutable-references-to-an-i32-when-ad/41794667#41794667", "title": "What&#39;s the difference between immutable and mutable references to an i32 when adding?", "body": "<p>As the error message says:</p>\n\n<blockquote>\n  <p>binary operation + cannot be applied to type '&amp;mut i32'</p>\n</blockquote>\n\n<p>That's because it's not implemented. Reviewing <a href=\"https://doc.rust-lang.org/std/primitive.i32.html\" rel=\"nofollow noreferrer\">the documentation for <code>i32</code></a>, you will see these implementations of <code>Add</code>:</p>\n\n<ul>\n<li><code>impl Add&lt;i32&gt; for i32</code></li>\n<li><code>impl&lt;'a&gt; Add&lt;i32&gt; for &amp;'a i32</code></li>\n<li><code>impl&lt;'a&gt; Add&lt;&amp;'a i32&gt; for i32</code></li>\n<li><code>impl&lt;'a, 'b&gt; Add&lt;&amp;'a i32&gt; for &amp;'b i32</code></li>\n</ul>\n\n<p>You need to dereference <code>&amp;mut i32</code> to get to <code>i32</code>, which does have an <code>Add</code> implementation.</p>\n\n<p>Why does it not have that implementation? I'm not sure. Perhaps you can submit a PR to Rust to add it... Personally, I've can't recall ever needing it. Usually if you have a <code>&amp;mut T</code> it's because you <em>want</em> to update it, so you would have something like <code>*foo += 1</code>.</p>\n"}], "owner": {"reputation": 2966, "user_id": 3022310, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/7f10ec2b45320ee843e539d705c31d08?s=128&d=identicon&r=PG", "display_name": "turbulencetoo", "link": "https://stackoverflow.com/users/3022310/turbulencetoo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 212, "favorite_count": 0, "accepted_answer_id": 41794667, "answer_count": 1, "score": 3, "last_activity_date": 1485185329, "creation_date": 1485108843, "last_edit_date": 1485109933, "question_id": 41794464, "link": "https://stackoverflow.com/questions/41794464/whats-the-difference-between-immutable-and-mutable-references-to-an-i32-when-ad", "title": "What&#39;s the difference between immutable and mutable references to an i32 when adding?", "body": "<p>I have </p>\n\n<pre><code>fn plus_one(x: &amp;i32) -&gt; i32 {\n    x + 1\n}\n\nfn plus_one_star(x: &amp;i32) -&gt; i32 {\n    *x + 1\n}\n\nfn plus_one_mut(x: &amp;mut i32) -&gt; i32 {\n    x + 1\n}\n\nfn plus_one_mut_star(x: &amp;mut i32) -&gt; i32 {\n    *x + 1\n}\n\nfn main() {\n    let a: i32 = 5;\n    let mut b: i32 = 5;\n\n    println!(\"{:?}\", plus_one(&amp;a));\n    println!(\"{:?}\", plus_one_star(&amp;a));\n    println!(\"{:?}\", plus_one_mut(&amp;mut b));\n    println!(\"{:?}\", plus_one_mut_star(&amp;mut b));\n    // I expect all to print '6' as I never actually mutate b\n}\n</code></pre>\n\n<p>The third function, <code>plus_one_mut</code>, fails to compile with: <code>error[E0369]: binary operation `+` cannot be applied to type '&amp;mut i32'</code></p>\n\n<p>Why does this function with the mutable reference fail to compile?</p>\n"}, {"tags": ["enums", "rust", "alias"], "answers": [{"comments": [{"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1485106952, "post_id": 41792347, "comment_id": 70776382, "body": "Yes I&#39;m trying to create aliases. Rust already has type aliases with no problems. Can you given an example of a way that supporting enum variant aliases would break something because I can&#39;t see any."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1485172283, "post_id": 41792347, "comment_id": 70798892, "body": "@Timmmm: The problem is pattern matching. Which arm is taken in case you have <code>match x { One =&gt; {}, Two =&gt; {} }</code>?"}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 1, "creation_date": 1485172768, "post_id": 41792347, "comment_id": 70799188, "body": "That&#39;s not a problem. It would behave exactly as if you wrote <code>match x { One =&gt; {}, One =&gt; {} }</code>, i.e. print an error. (The error it actually prints is <code>This is an unreachable pattern</code>.)"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 0, "last_activity_date": 1527006450, "last_edit_date": 1527006450, "creation_date": 1485096654, "answer_id": 41792347, "question_id": 41791969, "link": "https://stackoverflow.com/questions/41791969/is-there-a-way-to-create-an-alias-of-an-enum-value/41792347#41792347", "title": "Is there a way to create an alias of an enum value?", "body": "<p>Your implementation doesn't make any sense. Look at a simpler version:</p>\n\n<pre><code>enum MyType {\n    One,\n    Two = One,\n}\n</code></pre>\n\n<p>Said another way:</p>\n\n<pre><code>enum MyType {\n    One = 1,\n    Two = 1,\n}\n</code></pre>\n\n<p>You are asking the compiler to create two enum variants that are the same, but the whole point of enums is that they are <em>exclusive</em> of each other.</p>\n\n<p>Instead, create a constant (associated or otherwise):</p>\n\n<pre><code>enum MyType {\n    One,\n}\n\nconst TWO: MyType = MyType::One;\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485178506, "post_id": 41806553, "comment_id": 70803054, "body": "I was thinking about recommending a secondary enum. It seems like there are times where you&#39;d want one representation or the other, but not both concurrently."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1485179473, "post_id": 41806553, "comment_id": 70803713, "body": "C &quot;supports&quot; enum and struct field aliases using through preprocessor. I&#39;m only half-joking here - the classic Unix implementations of e.g. <code>struct stat</code> use this feature <i>a lot</i>, and it is part of the reason why struct and union fields are prefixed (the other part being that it protects the standard library from <i>application</i> #defining something that happens to match a struct field)."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 2, "last_activity_date": 1485178452, "last_edit_date": 1485178452, "creation_date": 1485174934, "answer_id": 41806553, "question_id": 41791969, "link": "https://stackoverflow.com/questions/41791969/is-there-a-way-to-create-an-alias-of-an-enum-value/41806553#41806553", "title": "Is there a way to create an alias of an enum value?", "body": "<p>Not as far as I know.</p>\n\n<p>Enums in Rust are not \"bundle of constant values\" like they are in C. There is support for associating a numeric value to the constants, but that's it. Of course, you could create constants of any name, but they would not allow you to pattern match an enum value.</p>\n\n<p>In a sense, an alias on a enum variant is a bit like an alias on a type field. I've never seen any occurrence of a single field identified by two names; I wonder if there's any language that supports it.</p>\n\n<hr>\n\n<p>The solution I would propose it to bite the bullet and create two separate enums with a conversion between them:</p>\n\n<pre><code>use std::convert::From;\n\nenum Side {\n    Left,\n    Right,\n}\n\nenum PortSide {\n    Port,\n    Starboard,\n}\n\n#[cfg(not(universe = \"mirror\"))]\nimpl From&lt;Side&gt; for PortSide {\n    fn from(s: Side) -&gt; PortSide {\n        match s {\n            Side::Left =&gt; PortSide::Port,\n            Side::Right =&gt; PortSide::Starboard,\n        }\n    }\n}\n\n#[cfg(universe = \"mirror\")]\nimpl From&lt;Side&gt; for PortSide {\n    fn from(s: Side) -&gt; PortSide {\n        match s {\n            Side::Left =&gt; PortSide::Starboard,\n            Side::Right =&gt; PortSide::Port,\n        }\n    }\n}\n</code></pre>\n\n<p>Also, I'd advise you to not require a feature to be specified, but instead allow a default behavior in the absence of this feature. In your case, \"normal\" seems like it should be the default behavior.</p>\n"}, {"tags": [], "owner": {"reputation": 99643, "user_id": 445517, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/57e2ba76e6290c4e9e19821a068bc8c1?s=128&d=identicon&r=PG", "display_name": "CodesInChaos", "link": "https://stackoverflow.com/users/445517/codesinchaos"}, "is_accepted": true, "score": 8, "last_activity_date": 1527006636, "last_edit_date": 1527006636, "creation_date": 1527006326, "answer_id": 50472444, "question_id": 41791969, "link": "https://stackoverflow.com/questions/41791969/is-there-a-way-to-create-an-alias-of-an-enum-value/50472444#50472444", "title": "Is there a way to create an alias of an enum value?", "body": "<p>You can use an associated constant to get a constant that looks very similar to an enum variant:</p>\n\n<pre><code>#[derive(PartialEq, Eq)]\npub enum X {\n    A,\n    B,\n}\n\nimpl X {\n    pub const A1: X = X::A;\n}\n</code></pre>\n\n<p>The associated constant is namespaced inside the enum, just like normal variants. It is compatible with pattern matching \u2014 even the unreachable warning and exhaustive matching rules work.</p>\n\n<pre><code>match x {\n    X::A1 =&gt; ...,\n    X::B =&gt; ...,\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=eb364d9da2c5470e3c72794116dbff7a&amp;version=stable\" rel=\"noreferrer\">playground</a></p>\n\n<p>There are some limitations: most importantly you can't have any data associated with that value. You also need to <code>#[derive(PartialEq, Eq)]</code> on your struct.</p>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1406, "favorite_count": 0, "accepted_answer_id": 50472444, "answer_count": 3, "score": 3, "last_activity_date": 1527006636, "creation_date": 1485094651, "last_edit_date": 1485108636, "question_id": 41791969, "link": "https://stackoverflow.com/questions/41791969/is-there-a-way-to-create-an-alias-of-an-enum-value", "title": "Is there a way to create an alias of an enum value?", "body": "<p>Is there a way to do something like this?</p>\n\n<pre><code>enum MyType {\n    Left,\n    Right,\n\n    #[cfg(universe = \"normal\")]\n    Port = Left,\n    #[cfg(universe = \"normal\")]\n    Starboard = Right,\n\n    #[cfg(universe = \"mirror\")]\n    Port = Right,\n    #[cfg(universe = \"mirror\")]\n    Starboard = Left,\n\n}\n</code></pre>\n\n<p>If you actually try it, you get this error (I had to add <code>MyType::</code>):</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0080]: constant evaluation error\n --&gt; &lt;anon&gt;:9:12\n  |\n9 |     Port = MyType::Left,\n  |            ^^^^^^^^^^^^ unimplemented constant expression: enum variants\n</code></pre>\n\n<p><a href=\"https://github.com/rust-lang/rust/blob/93e70ecb7fbe05caa74dfb2bf3c29315edc2b3e6/src/librustc_const_eval/eval.rs#L681\" rel=\"nofollow noreferrer\">Here</a> is where that error is triggered.</p>\n"}, {"tags": ["iterator", "rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485053509, "post_id": 41786816, "comment_id": 70763427, "body": "<code>!self.vals.is_some()</code> =&gt; <code>self.vals.is_none()</code> and some <code>map</code> on the last line would make it prettier as well."}, {"owner": {"reputation": 6604, "user_id": 318206, "user_type": "registered", "accept_rate": 65, "profile_image": "https://www.gravatar.com/avatar/f30e68fd58551b03172a66098e37db95?s=128&d=identicon&r=PG", "display_name": "Bosh", "link": "https://stackoverflow.com/users/318206/bosh"}, "edited": false, "score": 0, "creation_date": 1485067161, "post_id": 41786816, "comment_id": 70765723, "body": "This is starting to make sense\u2014thanks for the detailed answer! But I seem to have trouble generalizing this approach: my real scenario is more like <a href=\"https://play.rust-lang.org/?gist=c43e28b29426cbc50982242f222599f8&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>, where I&#39;m not just grabbing a field but *calling a function on self that returns (a value derived from) the field. Is there an approach that works in this situation?"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 6604, "user_id": 318206, "user_type": "registered", "accept_rate": 65, "profile_image": "https://www.gravatar.com/avatar/f30e68fd58551b03172a66098e37db95?s=128&d=identicon&r=PG", "display_name": "Bosh", "link": "https://stackoverflow.com/users/318206/bosh"}, "edited": false, "score": 0, "creation_date": 1485098414, "post_id": 41786816, "comment_id": 70773500, "body": "@Bosh: If you remove the <code>&#39;a</code> in <code>&amp;&#39;a self</code> in <code>look_for_details</code>, it compiles."}, {"owner": {"reputation": 6604, "user_id": 318206, "user_type": "registered", "accept_rate": 65, "profile_image": "https://www.gravatar.com/avatar/f30e68fd58551b03172a66098e37db95?s=128&d=identicon&r=PG", "display_name": "Bosh", "link": "https://stackoverflow.com/users/318206/bosh"}, "edited": false, "score": 0, "creation_date": 1485100934, "post_id": 41786816, "comment_id": 70774278, "body": "Hmm\u2014so it does. But now I&#39;m more confused than ever: what does it mean for a function to take a <code>&amp;self</code> with no specified lifetime and return a <code>&amp;&#39;a str</code>? I would have thought <code>&#39;a</code> in this context only made sense when there was a <code>StatefulCounter</code> associated with it, and here we&#39;re saying the <code>StatefulCoutner</code> does <i>not</i> have lifetime <code>&#39;a</code>."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1485124473, "post_id": 41786816, "comment_id": 70782087, "body": "But it does. You were trying to make <code>self</code> of type <code>&amp;&#39;a StatefulCounter&lt;&#39;a&gt;</code> (note <code>&#39;a</code> appears twice here, the second one comes from the <code>impl</code>), and that&#39;s what was causing the problem (it was forcing the compiler to try to resolve an impossible lifetime, due to the active mutable borrow). All you need is a <code>&amp;&#39;b StatefulCounter&lt;&#39;a&gt;</code> (where <code>&#39;b</code> can be elided)."}, {"owner": {"reputation": 6604, "user_id": 318206, "user_type": "registered", "accept_rate": 65, "profile_image": "https://www.gravatar.com/avatar/f30e68fd58551b03172a66098e37db95?s=128&d=identicon&r=PG", "display_name": "Bosh", "link": "https://stackoverflow.com/users/318206/bosh"}, "edited": false, "score": 0, "creation_date": 1485131730, "post_id": 41786816, "comment_id": 70783722, "body": "And how should I read that? Do I think of this as  &quot;a reference with lifetime &#39;b to a StatefulCounter with lifetime &#39;a&quot;? It seems strange to me to have an <code>impl</code> defined <code>for &amp;&#39; a StatefulCounter</code>that takes a <code>self</code> parameter with a different lifetime."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1485136091, "post_id": 41786816, "comment_id": 70784645, "body": "In <code>&amp;&#39;b StatefulCounter&lt;&#39;a&gt;</code>, <code>&#39;a</code> refers to the lifetime of the <code>display</code> field and <code>&#39;b</code> refers to the lifetime of the <code>StatefulCounter&lt;&#39;a&gt;</code>."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 3, "last_activity_date": 1485055737, "last_edit_date": 1495540375, "creation_date": 1485053395, "answer_id": 41786816, "question_id": 41786651, "link": "https://stackoverflow.com/questions/41786651/trying-to-implement-an-iterator-cannot-infer-an-appropriate-lifetime-due-to-con/41786816#41786816", "title": "Trying to implement an iterator: cannot infer an appropriate lifetime due to conflicting requirements", "body": "<p>The problem is that the closure you pass to <code>filter</code> needs to borrow <code>self</code>, but <a href=\"https://stackoverflow.com/a/32300133/234590\">you can't store a reference to <code>self</code> in the struct itself</a>.</p>\n\n<p>In this case, we can work around it by storing a copy of the value in the closure instead. This is done in two steps:</p>\n\n<ol>\n<li>Assign <code>self.look_for</code> to a local variable, and use the local variable in the closure instead. This way, the closure is not tied to <code>self</code>.</li>\n<li>Add <code>move</code> to the closure. The closure will thus capture the local variable by value.</li>\n</ol>\n\n<p>Here's the final code:</p>\n\n<pre><code>impl&lt;'a&gt; Iterator for StatefulCounter&lt;'a&gt; {\n    type Item = bool;\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        if !self.vals.is_some() {\n            let look_for = self.look_for;\n            self.vals = Some(Box::new({\n                self.display.chars().filter(move |&amp;i| i == look_for)\n            }));\n        }\n\n        if let &amp;Some(v) = &amp;self.vals.as_mut().unwrap().next() {\n            Some(expensive(v))\n        } else {\n            None\n        }\n    }\n}\n</code></pre>\n\n<p>The explicit cast on the <code>Box</code> is not necessary, so I removed it.</p>\n"}], "owner": {"reputation": 6604, "user_id": 318206, "user_type": "registered", "accept_rate": 65, "profile_image": "https://www.gravatar.com/avatar/f30e68fd58551b03172a66098e37db95?s=128&d=identicon&r=PG", "display_name": "Bosh", "link": "https://stackoverflow.com/users/318206/bosh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 125, "favorite_count": 0, "accepted_answer_id": 41786816, "answer_count": 1, "score": 2, "last_activity_date": 1485055737, "creation_date": 1485051420, "question_id": 41786651, "link": "https://stackoverflow.com/questions/41786651/trying-to-implement-an-iterator-cannot-infer-an-appropriate-lifetime-due-to-con", "title": "Trying to implement an iterator: cannot infer an appropriate lifetime due to conflicting requirements", "body": "<p>I'm trying to implement an iterator on my own struct. My general approach is by generating and storing an iterator the first time <code>next</code> is invoked, and then calling this iterator each time I need a value. </p>\n\n<p>My minimal failing example <a href=\"https://play.rust-lang.org/?gist=8928b97d0dab06aaada7a2f97290f0ec&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">looks like this</a>, and the heart of it is:</p>\n\n<pre><code>    if !self.vals.is_some() {\n        self.vals = Some(Box::new({\n            self.display.chars().filter(|&amp;i| i == self.look_for)\n        }) as Box&lt;std::iter::Iterator&lt;Item = _&gt;&gt;);\n    }\n</code></pre>\n\n<p>My code fails to compile, producing the following message:</p>\n\n<pre><code>help: consider using an explicit lifetime parameter as shown: fn next(self: &amp;'a mut Self) -&gt; Option&lt;&lt;Self&gt;::Item&gt;\n</code></pre>\n\n<p>Following the advice doesn't help (just leads to more compile errors saying that my implementation is incompatible with the Iterator trait definition.</p>\n\n<p>I'd appreciate help understanding what's going wrong and how I can fix it.</p>\n"}, {"tags": ["rust", "future"], "comments": [{"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 2, "creation_date": 1485039007, "post_id": 41784828, "comment_id": 70760710, "body": "I couldn&#39;t reproduce your issue (after fixing unrelated issues). There&#39;s <code>impl&lt;S: ?Sized + Stream&gt; Stream for Box&lt;S&gt;</code> in futures-rs that should make this just work. Make sure your question contains an <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a> and the error message you&#39;re getting."}, {"owner": {"reputation": 1595, "user_id": 3833068, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6a2a668bce4cd485078f912cbda24f2a?s=128&d=identicon&r=PG", "display_name": "Ameo", "link": "https://stackoverflow.com/users/3833068/ameo"}, "reply_to_user": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1485041730, "post_id": 41784828, "comment_id": 70761317, "body": "Ohhh; in this particular test I hadn&#39;t done <code>use futures::Stream</code>; rustc was encountering the unsized error due to that <code>impl&lt;S: ?Sized + Stream&gt;</code> living inside the <code>Stream</code> module as <code>wait()</code> so the compilation errored out before it even noticed <code>wait()</code> wasn&#39;t in scope.  Thanks so much @FrancisGagn&#233;!  If you want to make this into an answer I&#39;ll accept it as solved; if not I&#39;ll do so myself."}], "answers": [{"tags": [], "owner": {"reputation": 1595, "user_id": 3833068, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6a2a668bce4cd485078f912cbda24f2a?s=128&d=identicon&r=PG", "display_name": "Ameo", "link": "https://stackoverflow.com/users/3833068/ameo"}, "is_accepted": true, "score": 1, "last_activity_date": 1485050719, "creation_date": 1485050719, "answer_id": 41786592, "question_id": 41784828, "link": "https://stackoverflow.com/questions/41784828/futures-rs-using-stream-combinators-on-boxstreams/41786592#41786592", "title": "futures-rs using Stream combinators on `BoxStream`s", "body": "<p>As pointed out by @FrancisGagn\u00e9 in a comment, <code>futures-rs</code> declares <code>impl&lt;S: ?Sized + Stream&gt; Stream for Box&lt;S&gt;</code> in the <code>futures::Stream</code> module.  In the test in which my code was, I had failed to import <code>Stream</code> so that trait wasn't in scope.</p>\n\n<p>The compiler didn't trigger an error for the lack of the <code>wait()</code> function because it had the unsized issue first.  </p>\n\n<p>This was resolved by adding <code>use futures::Stream;</code> to the start of the function.</p>\n"}], "owner": {"reputation": 1595, "user_id": 3833068, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6a2a668bce4cd485078f912cbda24f2a?s=128&d=identicon&r=PG", "display_name": "Ameo", "link": "https://stackoverflow.com/users/3833068/ameo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 994, "favorite_count": 0, "accepted_answer_id": 41786592, "answer_count": 1, "score": 1, "last_activity_date": 1485050719, "creation_date": 1485034797, "last_edit_date": 1485035879, "question_id": 41784828, "link": "https://stackoverflow.com/questions/41784828/futures-rs-using-stream-combinators-on-boxstreams", "title": "futures-rs using Stream combinators on `BoxStream`s", "body": "<p>Using the <a href=\"https://docs.rs/futures\" rel=\"nofollow noreferrer\"><code>futures-rs</code></a> library, I've encountered a situation where a stream needs to be mapped through an indeterminate number of other streams before being returned to the user.  Since the exact type of the output stream is unknown at the end of this operation, I've been using a <a href=\"https://docs.rs/futures/0.1.9/futures/stream/type.BoxStream.html\" rel=\"nofollow noreferrer\"><code>BoxStream</code></a> trait object while storing the stream in a struct and when returning it.</p>\n\n<p>Although this approach works fine, it has the unfortunate side effect of causing the inner <code>Stream</code> object to be unsized.  This is a problem because <em>every one</em> of the <a href=\"https://docs.rs/futures/0.1.9/futures/stream/trait.Stream.html\" rel=\"nofollow noreferrer\">stream combinators</a> require <code>Self: Sized</code> in their signatures meaning that I can't even <code>wait()</code> on the returned <code>BoxStream</code> in order to convert it into a blocking iterator.</p>\n\n<p>Here's an example of a situation that could lead to this issue:</p>\n\n<pre><code>struct Server {\n    receiver: Option&lt;Box&lt;Stream&lt;Item = usize, Error = ()&gt; + Send&gt;&gt;,\n}\n\nimpl Server {\n    pub fn new() -&gt; Server {\n        let (tx, rx) = channel(0);\n        // do things with the tx (subscribe to tcp socket, connect to database, etc.)\n        Server { receiver: Some(rx.boxed()) }\n    }\n\n    /// Maps the inner `Receiver` through another stream, essentially duplicating it.\n    pub fn get_stream(&amp;mut self) -&gt; Result&lt;Box&lt;Stream&lt;Item = usize, Error = ()&gt; + Send&gt;, ()&gt; {\n        let (tx, rx) = channel(0);\n\n        let strm = self.receiver.take().unwrap();\n        let mut tx_opt = Some(tx);\n        let new_strm = strm.map(move |msg| {\n            // unfortunate workaround needed since `send()` takes `self`\n            let mut tx = tx_opt.take().unwrap();\n            tx = tx.send(msg.clone()).wait().unwrap();\n            tx_opt = Some(tx);\n            msg\n        });\n        simbroker.receiver = Some(new_strm.boxed());\n\n        Ok(rx.boxed())\n    }\n}\n\npub fn main() {\n    let server = Server::new();\n\n    // possible that this may happen 0..n times\n    let rx: BoxStream&lt;usize, ()&gt; = server.get_stream();\n\n    // can't do this since the inner `Stream` trait object isn't `Sized` and `wait()`\n    // (along with all other stream combinators) requires that in their signatures.\n    for msg in rx.wait() {\n        // compiler error here\n        // ...\n    }\n}\n</code></pre>\n\n<p>As shown by the above code, <code>BoxStream</code>s are necessary since calling <code>map()</code> on a stream changes its type from <code>Receiver</code> to <code>Map</code> which would make it impossible to store back into the struct.  It's impossible to do pretty much anything with the returned <code>BoxStream</code> since it's <code>?Sized</code>.  In fact, the <em>only</em> function that's available for trait-object <code>Stream</code>s is <code>poll()</code> which is supposed to never be called outside of a <code>Task</code>.</p>\n\n<p>Is there any way that I can avoid this problem without doing something like returning an enum containing any one of the possible varieties of stream that could possibly occur?  Would writing my own struct that implements <code>Stream</code> fix the issue somehow?</p>\n"}, {"tags": ["function", "generics", "rust", "higher-kinded-types"], "comments": [{"owner": {"reputation": 1694, "user_id": 1000974, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af4d5b47cb2367fcb0c0a0895bfd21cd?s=128&d=identicon&r=PG", "display_name": "Daniel Worthington-Bodart", "link": "https://stackoverflow.com/users/1000974/daniel-worthington-bodart"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1485033469, "post_id": 41784344, "comment_id": 70759163, "body": "That&#39;s a fair point, at the moment I&#39;m not even sure what the correct terms are to describe the problem I have. Error[E0495] isn&#39;t the actual problem, it&#39;s how do I restructure my code in such a way that I can pass a function in or at least create a generic version of the code. Maybe I&#39;m just not thinking about this in an idiomatic Rust way, which was what I was trying to allude to with the trait comment. In summary I don&#39;t know what I don&#39;t know ;)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485033743, "post_id": 41784344, "comment_id": 70759242, "body": "How about such questions as <a href=\"http://stackoverflow.com/q/27831944/155423\">How do I store a closure in Rust?</a>, <a href=\"http://stackoverflow.com/q/29202137/155423\">Storing a closure in a HashMap</a>, or <a href=\"http://stackoverflow.com/q/21510694/155423\">Storing a closure in a structure \u2014 cannot infer an appropriate lifetime</a> (I&#39;ve not reviewed any in particular, they are just early search results)."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1485035520, "post_id": 41784344, "comment_id": 70759833, "body": "I&#39;ve posted an answer that uses <a href=\"https://doc.rust-lang.org/beta/nomicon/hrtb.html\" rel=\"nofollow noreferrer\">higher-rank trait bounds</a>, see <a href=\"https://gist.github.com/07a68fd62b03ae54659716e118d2b1da\" rel=\"nofollow noreferrer\">example in playground</a>. But this is still not as generic as your second snippet, it assumes that the closure returns <code>Result&lt;Cat&lt;&#39;a&gt;&gt;</code> rather than <code>T&lt;&#39;a&gt;</code>. I&#39;m afraid the latter might not be possible to express in current Rust which doesn&#39;t have <a href=\"https://users.rust-lang.org/t/does-rust-really-need-higher-kinded-types/5531\" rel=\"nofollow noreferrer\">higher-kinded types</a>. As this is beyond my understanding of the type system, I&#39;ve removed my answer."}, {"owner": {"reputation": 1694, "user_id": 1000974, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af4d5b47cb2367fcb0c0a0895bfd21cd?s=128&d=identicon&r=PG", "display_name": "Daniel Worthington-Bodart", "link": "https://stackoverflow.com/users/1000974/daniel-worthington-bodart"}, "edited": false, "score": 0, "creation_date": 1485036321, "post_id": 41784344, "comment_id": 70760055, "body": "I was wondering if higher-rank trait bounds was the answer. Maybe I could do some thing a bit like <a href=\"http://burntsushi.net/rustdoc/fst/trait.Streamer.html\" rel=\"nofollow noreferrer\">burntsushi.net/rustdoc/fst/trait.Streamer.html</a>"}], "answers": [{"tags": [], "owner": {"reputation": 1694, "user_id": 1000974, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af4d5b47cb2367fcb0c0a0895bfd21cd?s=128&d=identicon&r=PG", "display_name": "Daniel Worthington-Bodart", "link": "https://stackoverflow.com/users/1000974/daniel-worthington-bodart"}, "is_accepted": true, "score": 3, "last_activity_date": 1485096847, "last_edit_date": 1485096847, "creation_date": 1485077885, "answer_id": 41789367, "question_id": 41784344, "link": "https://stackoverflow.com/questions/41784344/how-do-i-make-a-structure-generic-in-rust-without-higher-kinded-type-hkt-suppo/41789367#41789367", "title": "How do I make a structure generic in Rust without higher kinded type (HKT) support?", "body": "<p>As with most problems I just needed another level of indirection! Higher kinded types (HKT) would obviously help but I actually only need to be able to associate a lifetime parameter with my parsing function. </p>\n\n<p>Inspired by user4815162342 and <a href=\"http://burntsushi.net/rustdoc/fst/trait.Streamer.html\" rel=\"nofollow noreferrer\">Streamer</a> I realised I could create two traits <code>Iteratee&lt;'a&gt;</code> and <code>Parser&lt;'a&gt;</code> each with an associated type and then when I create an implementation that combines them I would be able to combine the associated types to give me a form of HKTs:</p>\n\n<pre><code>trait Parser&lt;'a&gt; {\n    type Output: 'a;\n\n    fn parse(&amp;self, &amp;'a [u8]) -&gt; Result&lt;Self::Output, Utf8Error&gt;;\n}\n\nstruct CatParser;\n\nimpl&lt;'a&gt; Parser&lt;'a&gt; for CatParser{\n    type Output = Cat&lt;'a&gt;;\n\n    fn parse(&amp;self, slice: &amp;'a [u8]) -&gt; Result&lt;Self::Output, Utf8Error&gt; {\n        parse(slice)\n    }\n}\n\ntrait Iteratee&lt;'a&gt; {\n    type Item: 'a;\n\n    fn next&lt;F&gt;(&amp;'a mut self, fun: F) where F: Fn(Option&lt;Self::Item&gt;) -&gt; () + Sized;\n}\n\nstruct IterateeParser&lt;R, P&gt; {\n    read: R,\n    parser: P,\n}\n\nimpl&lt;'a, R, P&gt; Iteratee&lt;'a&gt; for IterateeParser&lt;R,P&gt; where R: BufRead + Sized, P: Parser&lt;'a&gt; {\n    type Item = Result&lt;P::Output, Utf8Error&gt;;\n    //                 ^^^^^^^^^ This is the magic!\n\n    fn next&lt;F&gt;(&amp;'a mut self, fun: F) where F: Fn(Option&lt;Self::Item&gt;) -&gt; () + Sized {\n        let slice = self.read.fill_buf().unwrap();\n        fun(Some(self.parser.parse(slice)))\n    }\n}\n\nfn main() {\n    let data = &amp;b\"felix\"[..];\n    let read = BufReader::new(data);\n    let mut iterator = IterateeParser { read: read, parser: CatParser };\n    iterator.next(|cat| assert_eq!(cat.unwrap().unwrap(), Cat { name: \"felix\" }));\n}\n</code></pre>\n\n<p>The magic line is <code>type Item = Result&lt;P::Output, Utf8Error&gt;;</code></p>\n"}], "owner": {"reputation": 1694, "user_id": 1000974, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af4d5b47cb2367fcb0c0a0895bfd21cd?s=128&d=identicon&r=PG", "display_name": "Daniel Worthington-Bodart", "link": "https://stackoverflow.com/users/1000974/daniel-worthington-bodart"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 373, "favorite_count": 0, "accepted_answer_id": 41789367, "answer_count": 1, "score": 4, "last_activity_date": 1485096847, "creation_date": 1485031743, "last_edit_date": 1485078054, "question_id": 41784344, "link": "https://stackoverflow.com/questions/41784344/how-do-i-make-a-structure-generic-in-rust-without-higher-kinded-type-hkt-suppo", "title": "How do I make a structure generic in Rust without higher kinded type (HKT) support?", "body": "<p>I am trying to make the <code>Iteratee</code> structure generic so I can pass in a different parsing function and get an different <code>Iteratee</code>. This is the non-generic version that works:</p>\n\n<pre><code>use std::io::{BufRead, BufReader};\nuse std::str::{from_utf8, Utf8Error};\n\n#[derive(PartialEq, Debug)]\nstruct Cat&lt;'a&gt; {\n    name: &amp;'a str,\n}\n\nfn parse&lt;'a&gt;(slice: &amp;'a [u8]) -&gt; Result&lt;Cat&lt;'a&gt;, Utf8Error&gt; {\n    from_utf8(slice).map(|name| Cat { name: name })\n}\n\nstruct Iteratee&lt;R&gt;\n    where R: BufRead + Sized\n{\n    read: R,\n}\n\nimpl&lt;R&gt; Iteratee&lt;R&gt;\n    where R: BufRead + Sized\n{\n    fn next&lt;'a, F&gt;(&amp;'a mut self, fun: F)\n        where F: Fn(Option&lt;Result&lt;Cat&lt;'a&gt;, Utf8Error&gt;&gt;) -&gt; () + Sized\n    {\n        let slice = self.read.fill_buf().unwrap();\n        fun(Some(parse(slice)))\n        //       ^^^^^^^^^^^ How do I pull 'parse' up as a function of Iteratee\n    }\n}\n\nfn main() {\n    let data = &amp;b\"felix\"[..];\n    let read = BufReader::new(data);\n    let mut iterator = Iteratee { read: read };\n    iterator.next(|cat| assert_eq!(cat.unwrap().unwrap(), Cat { name: \"felix\" }));\n}\n</code></pre>\n\n<p>This is my attempt at making it generic, but I can't construct <code>IterateeFun</code> with either a reference to the function or passing in a closure.</p>\n\n<pre><code>struct IterateeFun&lt;R, P, T&gt;\n    where R: BufRead + Sized,\n          P: Fn(&amp;[u8]) -&gt; (Result&lt;T, Utf8Error&gt;) + Sized\n{\n    read: R,\n    parser: P,\n}\n\nimpl&lt;R, P, T&gt; IterateeFun&lt;R, P, T&gt;\n    where R: BufRead + Sized,\n          P: Fn(&amp;[u8]) -&gt; (Result&lt;T, Utf8Error&gt;) + Sized\n{\n    fn next&lt;'a, F&gt;(&amp;'a mut self, fun: F)\n        where F: Fn(Option&lt;Result&lt;T, Utf8Error&gt;&gt;) -&gt; () + Sized\n    {\n        let slice = self.read.fill_buf().unwrap();\n        fun(Some((self.parser)(slice)))\n    }\n}\n\n\nfn main() {\n    let data = &amp;b\"felix\"[..];\n    let read = BufReader::new(data);\n    let mut iterator = IterateeFun {\n        read: read,\n        parser: parse, // What can I put here?\n        // I've tried a closure but then I get error[E0495]/ lifetime issues\n    };\n\n    iterator.next(|cat| assert_eq!(cat.unwrap().unwrap(), Cat { name: \"felix\" }));\n}\n</code></pre>\n\n<p>I'd like to know how to pass a function into a structure as shown. Or should I be doing this as a trait instead?</p>\n"}, {"tags": ["return", "rust", "lifetime"], "comments": [{"owner": {"reputation": 3176, "user_id": 1443496, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/9261936847b5a31e15da6e86533d3de3?s=128&d=identicon&r=PG", "display_name": "Sean Allred", "link": "https://stackoverflow.com/users/1443496/sean-allred"}, "edited": false, "score": 1, "creation_date": 1485006195, "post_id": 41780024, "comment_id": 70750377, "body": "Seems to be related to <a href=\"https://doc.rust-lang.org/nomicon/lifetimes.html#example-references-that-outlive-referents\" rel=\"nofollow noreferrer\">this section of the docs</a>."}, {"owner": {"reputation": 3176, "user_id": 1443496, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/9261936847b5a31e15da6e86533d3de3?s=128&d=identicon&r=PG", "display_name": "Sean Allred", "link": "https://stackoverflow.com/users/1443496/sean-allred"}, "edited": false, "score": 0, "creation_date": 1485010367, "post_id": 41780024, "comment_id": 70751695, "body": "Would the downvoter care to suggest ways to improve this question?"}], "answers": [{"comments": [{"owner": {"reputation": 3176, "user_id": 1443496, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/9261936847b5a31e15da6e86533d3de3?s=128&d=identicon&r=PG", "display_name": "Sean Allred", "link": "https://stackoverflow.com/users/1443496/sean-allred"}, "edited": false, "score": 0, "creation_date": 1485006503, "post_id": 41780098, "comment_id": 70750457, "body": "I&#39;ll accept that as truth, but I still don&#39;t understand: how is this functionally different than passing an owned <code>str</code>? Doesn&#39;t my <code>input: String</code> have a lifetime scoped to the function body?"}, {"owner": {"reputation": 34798, "user_id": 1362755, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/97aa8c37ffa60c4262955aefae56e605?s=128&d=identicon&r=PG", "display_name": "the8472", "link": "https://stackoverflow.com/users/1362755/the8472"}, "reply_to_user": {"reputation": 3176, "user_id": 1443496, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/9261936847b5a31e15da6e86533d3de3?s=128&d=identicon&r=PG", "display_name": "Sean Allred", "link": "https://stackoverflow.com/users/1443496/sean-allred"}, "edited": false, "score": 1, "creation_date": 1485008179, "post_id": 41780098, "comment_id": 70751022, "body": "You cannot own a <code>str</code> (except in a <code>Box&lt;str&gt;</code>). <code>str</code> is a slice of a <code>String</code> or of constants. It can only exist as reference <code>&amp;str</code>. Passing a <code>String</code> as argument on the other hand <i>moves</i> it into the function, which means the function owns it. And what is owned can be moved out again too."}], "tags": [], "owner": {"reputation": 34798, "user_id": 1362755, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/97aa8c37ffa60c4262955aefae56e605?s=128&d=identicon&r=PG", "display_name": "the8472", "link": "https://stackoverflow.com/users/1362755/the8472"}, "is_accepted": true, "score": 3, "last_activity_date": 1485006336, "creation_date": 1485006336, "answer_id": 41780098, "question_id": 41780024, "link": "https://stackoverflow.com/questions/41780024/effectively-take-ownership-of-a-borrowed-reference-to-return-from-a-function/41780098#41780098", "title": "Effectively take ownership of a borrowed reference to return from a function", "body": "<p>You can only return a <code>&amp;str</code> if it is a slice of the passed-in argument since that would allow it to have a lifetime equal to the argument. A slice of a locally allocated <code>String</code> will only be valid for the duration of the function, thus you cannot return it. You will have to return (move out) an owned <code>String</code></p>\n"}], "owner": {"reputation": 3176, "user_id": 1443496, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/9261936847b5a31e15da6e86533d3de3?s=128&d=identicon&r=PG", "display_name": "Sean Allred", "link": "https://stackoverflow.com/users/1443496/sean-allred"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2270, "favorite_count": 0, "closed_date": 1485009957, "accepted_answer_id": 41780098, "answer_count": 1, "score": 1, "last_activity_date": 1485006336, "creation_date": 1485005815, "question_id": 41780024, "link": "https://stackoverflow.com/questions/41780024/effectively-take-ownership-of-a-borrowed-reference-to-return-from-a-function", "closed_reason": "Duplicate", "title": "Effectively take ownership of a borrowed reference to return from a function", "body": "<p>I'm trying to write a simple <code>prompt</code> function that returns an input string without trailing newlines, but I'm not able to return my result because <code>input</code> does not live long enough.  I understand that <code>String::trim_right_matches</code> is returning a borrowed reference to a portion of <code>input: String</code>, but I can't figure out how to take ownership of this data or copy it somehow to return it.</p>\n\n<p>I've been spinning my wheels for a few hours now with no luck, though I have learned this 'fighting with the borrow checker' is a rite of passage for newcomers to Rust, so I guess I'm not alone.</p>\n\n<pre><code>use std::io;\nuse std::io::Write;\n\nfn main() {\n    println!(\"you entered: {}\", prompt(\"enter some text: \"));\n}\n\nfn prompt(msg: &amp;str) -&gt; &amp;str {\n    print!(\"{}\", msg);\n\n    io::stdout().flush()\n        .ok()\n        .expect(\"could not flush stdout\");\n\n    let mut input = String::new();\n\n    io::stdin()\n        .read_line(&amp;mut input)\n        .expect(\"failed to read from stdin\");\n\n    input.trim_right_matches(|c| c == '\\r' || c == '\\n')\n}\n</code></pre>\n\n<p>Intuition tells me I need to have <code>fn prompt(prompt: &amp;str) -&gt; str</code> instead of <code>-&gt; &amp;str</code>, but I haven't been able to effect that in a way the compiler accepts.</p>\n\n<pre><code>error: `input` does not live long enough\n  --&gt; src/main.rs:22:5\n   |\n22 |     input.trim_right_matches(|c| c == '\\r' || c == '\\n').clone()\n   |     ^^^^^ does not live long enough\n23 | }\n   | - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the anonymous lifetime #1 defined on the block at 9:32...\n  --&gt; src/main.rs:9:33\n   |\n9  | fn prompt(msg: &amp;str) -&gt; &amp;str {\n   |                                 ^\n\nerror: aborting due to previous error\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1484999045, "post_id": 41778723, "comment_id": 70748326, "body": "Is this not answered by <a href=\"http://stackoverflow.com/questions/39017871/how-to-prefix-suffix-macro-identifiers-in-rust/39018322#39018322\">&quot;How to prefix/suffix macro identifiers in Rust?&quot;</a>?"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1484999493, "post_id": 41778723, "comment_id": 70748475, "body": "How do you define <code>ObjectId</code>? Do you list all possible variants manually there? Then it could be possible to combine definition and this match thingy into one macro. This at least avoids specifying the list twice."}, {"owner": {"reputation": 5029, "user_id": 273924, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/50c78d9d967c8a192aae64a618e521ab?s=128&d=identicon&r=PG", "display_name": "locka", "link": "https://stackoverflow.com/users/273924/locka"}, "edited": false, "score": 0, "creation_date": 1485000909, "post_id": 41778723, "comment_id": 70748862, "body": "Not really as its a different context and the answers basically say &quot;you can&#39;t&quot; rather than suggesting alternatives."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485010103, "post_id": 41778723, "comment_id": 70751630, "body": "@locka just because you don&#39;t <i>like</i> the answer doesn&#39;t mean that the answer is <i>incorrect</i> or that the question isn&#39;t a duplicate. If an existing question doesn&#39;t have the answer you like, the appropriate thing to do is to place a bounty on the existing question, soliciting additional answers."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485010772, "post_id": 41778723, "comment_id": 70751799, "body": "You&#39;ve always got the possibility of a build script, as well."}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1485046007, "post_id": 41778723, "comment_id": 70762189, "body": "You could define a module that exposes ID&#39;s so instead of attempting to access <code>$x_Encoding_DefaultBinary</code>, it would access <code>some_module::$x::Encoding_DefaultBinary</code> - even if its a little tedious to define modules just to workaround this, it could be made to work."}], "owner": {"reputation": 5029, "user_id": 273924, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/50c78d9d967c8a192aae64a618e521ab?s=128&d=identicon&r=PG", "display_name": "locka", "link": "https://stackoverflow.com/users/273924/locka"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 54, "favorite_count": 0, "closed_date": 1485010434, "answer_count": 0, "score": 1, "last_activity_date": 1485010251, "creation_date": 1484997708, "last_edit_date": 1485010251, "question_id": 41778723, "link": "https://stackoverflow.com/questions/41778723/how-do-i-create-a-new-identifier-based-on-another-inside-a-rust-macro", "closed_reason": "Duplicate", "title": "How do I create a new identifier based on another inside a Rust macro?", "body": "<p>I'm trying to write a fairly complex macro in Rust. Here is what the macro would look like on the outside:</p>\n\n<pre><code>supported_messages![\n    OpenSecureChannelRequest,\n    OpenSecureChannelResponse,\n    CloseSecureChannelRequest,\n    CloseSecureChannelResponse,\n    // This list will eventually have 100s of values\n];\n</code></pre>\n\n<p>On the inside, it expands each id into something like this (plus a lot of other boiler plate):</p>\n\n<pre><code>ObjectId::Foo_Encoding_DefaultBinary =&gt; { SupportedMessage::Foo(Foo::decode()?) },\n</code></pre>\n\n<p>This pseudo-macro provides the gist of what I'm doing:</p>\n\n<pre><code>macro_rules! supported_messages {\n    [ $( $x:ident ), * ] =&gt; {\n       $( ObjectId::$x_Encoding_DefaultBinary =&gt; {\n           SupportedMessage::$x($x::decode()?)\n       }, )*\n     }\n</code></pre>\n\n<p>The full macro and source is online to see <a href=\"https://github.com/locka99/opcua/blob/master/core/src/comms/supported_message.rs\" rel=\"nofollow noreferrer\">here</a>.</p>\n\n<p>The macro takes an array of ids, and for each id spews out a set of match patterns similar to the example above.</p>\n\n<p>I can't take the identifier <code>$x</code>, e.g. <code>Foo</code> and turn it into a new identifier <code>Foo_Encoding_DefaultBinary</code>.</p>\n\n<p>Rust has a <a href=\"https://doc.rust-lang.org/std/macro.concat_idents.html\" rel=\"nofollow noreferrer\"><code>concat_idents!()</code></a>, but from what I've read it's practically useless and it's deprecated. Is there another way? Procedural macros aren't available on the stable compiler yet and may not be easy to use either.</p>\n\n<p>At present, I'm generating most of the other boilerplate automatically but have to write the code above by hand. It's very tedious. </p>\n\n<p>Is there a way to do this? </p>\n\n<p>In C, I'd just say Foo <code>## _Encoding_DefaultBinary</code> and it would happen. </p>\n"}, {"tags": ["rust", "automated-tests", "idioms"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484974687, "post_id": 41775900, "comment_id": 70742979, "body": "Also relevant: <a href=\"http://stackoverflow.com/questions/38168811/export-function-only-to-module-test/38168984#38168984\" title=\"export function only to module test\">stackoverflow.com/questions/38168811/&hellip;</a> - TL;DR for now, use <code>super::bar</code>. A yet-to-be-released version of Rust will expand it so that glob imports &quot;just work&quot; in that case."}, {"owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484975456, "post_id": 41775900, "comment_id": 70743115, "body": "Thanks. I&#39;ve also notice that if I do make bar public, then the compiler no longer gives me a warning that bar() is unused. Is there a way to ensure that tests do not give code the &quot;used&quot; attribute?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485009758, "post_id": 41775900, "comment_id": 70751515, "body": "Yes; do not make it public. As <a href=\"http://stackoverflow.com/questions/38168811/export-function-only-to-module-test/38168984#38168984\" title=\"export function only to module test\">stackoverflow.com/questions/38168811/&hellip;</a> says, you can just <code>use super::bar;</code> or call it explicitly <code>super::bar()</code>."}], "owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 39, "favorite_count": 0, "closed_date": 1484974665, "answer_count": 0, "score": 0, "last_activity_date": 1484991981, "creation_date": 1484974551, "last_edit_date": 1484991981, "question_id": 41775900, "link": "https://stackoverflow.com/questions/41775900/idiomatic-way-to-test-non-public-functions", "closed_reason": "Duplicate", "title": "Idiomatic way to test non-public functions", "body": "<p>This code does not compile with <code>cargo test</code>. It gives the error <strong>unresolved</strong> name <code>bar</code></p>\n\n<pre><code>fn bar()\n{\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_bar()\n    {\n        bar();\n    }\n}\n</code></pre>\n\n<p>Because <code>fn bar()</code> is not public. I can get around this by writing my tests this way:</p>\n\n<pre><code>fn bar()\n{\n}\n\n#[cfg(test)]\n#[test]\nfn test_bar()\n{\n    bar();\n}\n</code></pre>\n\n<p>However, according to the <a href=\"https://doc.rust-lang.org/book/testing.html#the-tests-module\" rel=\"nofollow noreferrer\">Rust Book</a> the first method is the idiomatic way to write tests in Rust. What is the idiomatic way to test non-public functions in Rust?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484973468, "post_id": 41775352, "comment_id": 70742770, "body": "<code>and_then</code> with a hardcoded <code>Some</code> doesn&#39;t really make sense; should just be <code>map</code>, no?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484973952, "post_id": 41775352, "comment_id": 70742848, "body": "<i>You have to clone</i> \u2014 not <b>have</b>, but &quot;can&quot;, perhaps."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484974238, "post_id": 41775352, "comment_id": 70742904, "body": "Also, I&#39;m pretty sure that you&#39;d be creating each string twice; once in the call to <code>String::new</code>, and then again with the <code>clone</code>. It&#39;s not terrible for an empty <code>String</code>, as there&#39;s no heap allocation, but in general it&#39;s odd."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484974276, "post_id": 41775352, "comment_id": 70742913, "body": "Oh of course :/ I will change it to <code>map</code>. Perhaps I will rephrase the &quot;have to&quot; part as well."}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 1, "last_activity_date": 1484974592, "last_edit_date": 1484974592, "creation_date": 1484968151, "answer_id": 41775352, "question_id": 41774423, "link": "https://stackoverflow.com/questions/41774423/produce-optionvecstring-out-of-an-optionveccustom-in-rust/41775352#41775352", "title": "Produce Option&lt;Vec&lt;String&gt;&gt; out of an Option&lt;Vec&lt;Custom&gt;&gt; in Rust", "body": "<p>Here is a solution that works:</p>\n\n<pre><code>#[derive(Debug)]\npub struct Attachment {\n    pub guid: Option&lt;String&gt;,\n}\n\nfn main() {\n    let ov: Option&lt;Vec&lt;Attachment&gt;&gt; =\n        Some(vec![Attachment { guid: Some(\"rere34r34r34r34\".to_string()) },\n                  Attachment { guid: Some(\"5345345534rtyr5345\".to_string()) }]);\n\n    let foo: Option&lt;Vec&lt;_&gt;&gt; = ov.map(|x|\n        x.iter().map(|a| a.guid.as_ref().unwrap_or(&amp;String::new()).clone()).collect());\n\n    println!(\"{:?}\", foo);\n}\n</code></pre>\n\n<p>One of the issues with the above code is stopping the <code>guid</code> being moved out of the <code>Attachment</code> and into the vector. My example calls <code>clone</code> to move cloned instances into the vector.</p>\n\n<p>This works, but I think it looks nicer wrapped in a trait impl for <code>Option&lt;T&gt;</code>. Perhaps this is a better ... option ...:</p>\n\n<pre><code>trait CloneOr&lt;T, U&gt;\n    where U: Into&lt;T&gt;,\n          T: Clone\n{\n    fn clone_or(&amp;self, other: U) -&gt; T;\n}\n\nimpl&lt;T, U&gt; CloneOr&lt;T, U&gt; for Option&lt;T&gt;\n    where U: Into&lt;T&gt;,\n          T: Clone\n{\n    fn clone_or(&amp;self, other: U) -&gt; T {\n        self.as_ref().unwrap_or(&amp;other.into()).clone()\n    }\n}\n\n#[derive(Debug)]\npub struct Attachment {\n    pub guid: Option&lt;String&gt;,\n}\n\nfn main() {\n    let ov: Option&lt;Vec&lt;Attachment&gt;&gt; =\n        Some(vec![Attachment { guid: Some(\"rere34r34r34r34\".to_string()) },\n                  Attachment { guid: Some(\"5345345534rtyr5345\".to_string()) },\n                  Attachment { guid: None }]);\n\n    let foo: Option&lt;Vec&lt;_&gt;&gt; =\n        ov.map(|x| x.iter().map(|a| a.guid.clone_or(\"\")).collect());\n\n    println!(\"{:?}\", foo);\n}\n</code></pre>\n\n<p>Essentially the unwrapping and cloning is hidden behind a trait implementation that attaches to <code>Option&lt;T&gt;</code>.</p>\n\n<p><a href=\"http://play.integer32.com/?gist=cd9ff434c7f5eae5eae0651cc562802c&amp;version=stable\" rel=\"nofollow noreferrer\">Here it is running on the playground</a>.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1484974371, "last_edit_date": 1484974371, "creation_date": 1484973377, "answer_id": 41775783, "question_id": 41774423, "link": "https://stackoverflow.com/questions/41774423/produce-optionvecstring-out-of-an-optionveccustom-in-rust/41775783#41775783", "title": "Produce Option&lt;Vec&lt;String&gt;&gt; out of an Option&lt;Vec&lt;Custom&gt;&gt; in Rust", "body": "<p>You should read and memorize all of the methods on <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" rel=\"nofollow noreferrer\"><code>Option</code></a> (and <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" rel=\"nofollow noreferrer\"><code>Result</code></a>). These are used <em>so pervasively</em> in Rust that knowing what is present will help you immensely.</p>\n\n<p>For example, your <code>match</code> statement is <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.map\" rel=\"nofollow noreferrer\"><code>Option::map</code></a>.</p>\n\n<p>Since you never said you <em>couldn't</em> transfer ownership of the <code>String</code>s, I'd just do that. This will avoid any extra allocation:</p>\n\n<pre><code>let foo: Option&lt;Vec&lt;_&gt;&gt; =\n    ov.map(|i| i.into_iter().map(|a| a.guid.unwrap_or_else(String::new)).collect());\n</code></pre>\n\n<p>Note we don't have to specify the type inside the <code>Vec</code>; it can be inferred.</p>\n\n<p>You can of course introduce functions to make it cleaner:</p>\n\n<pre><code>impl Attachment {\n    fn into_guid(self) -&gt; String {\n        self.guid.unwrap_or_else(String::new)\n    }\n}\n\n// ...\n\nlet foo: Option&lt;Vec&lt;_&gt;&gt; = ov.map(|i| i.into_iter().map(Attachment::into_guid).collect());\n</code></pre>\n\n<p>If you don't want to give up ownership of the <code>String</code>, you can do the same concept but with a string slice:</p>\n\n<pre><code>impl Attachment {\n    fn guid(&amp;self) -&gt; &amp;str {\n        self.guid.as_ref().map_or(\"\", String::as_str)\n    }\n}\n\n// ...    \n\nlet foo: Option&lt;Vec&lt;_&gt;&gt; = ov.as_ref().map(|i| i.iter().map(|a| a.guid().to_owned()).collect());\n</code></pre>\n\n<p>Here, we have to use <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref\" rel=\"nofollow noreferrer\"><code>Option::as_ref</code></a> to avoid moving the <code>guid</code> out of the <code>Attachment</code>, then convert to a <code>&amp;str</code> with <a href=\"https://doc.rust-lang.org/std/string/struct.String.html#method.as_str\" rel=\"nofollow noreferrer\"><code>String::as_str</code></a>, providing a default value. We likewise don't take ownership of the <code>Option</code> of <code>ov</code>, and thus need to iterate over references, and ultimately allocate new <code>String</code>s with <code>ToOwned</code>.</p>\n"}], "owner": {"reputation": 53, "user_id": 882682, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b58a6f61b13d15a4d01a128d06f66c39?s=128&d=identicon&r=PG", "display_name": "on_pwogram&#232;", "link": "https://stackoverflow.com/users/882682/on-pwogram%c3%a8"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1065, "favorite_count": 0, "accepted_answer_id": 41775783, "answer_count": 2, "score": 0, "last_activity_date": 1484974592, "creation_date": 1484957971, "last_edit_date": 1484972629, "question_id": 41774423, "link": "https://stackoverflow.com/questions/41774423/produce-optionvecstring-out-of-an-optionveccustom-in-rust", "title": "Produce Option&lt;Vec&lt;String&gt;&gt; out of an Option&lt;Vec&lt;Custom&gt;&gt; in Rust", "body": "<p>I'm trying to do the equivalent of Ruby's <code>Enumerable.collect()</code> in Rust.</p>\n\n<p>I have an <code>Option&lt;Vec&lt;Attachment&gt;&gt;</code> and I want to create a <code>Option&lt;Vec&lt;String&gt;&gt;</code> from it, with <code>String::new()</code> elements in case of <code>None</code> guid. </p>\n\n<pre><code>#[derive(Debug)]\npub struct Attachment {\n    pub guid: Option&lt;String&gt;,\n}\n\nfn main() {\n    let ov: Option&lt;Vec&lt;Attachment&gt;&gt; =\n        Some(vec![Attachment { guid: Some(\"rere34r34r34r34\".to_string()) },\n                  Attachment { guid: Some(\"5345345534rtyr5345\".to_string()) }]);\n\n    let foo: Option&lt;Vec&lt;String&gt;&gt; = match ov {\n        Some(x) =&gt; {\n            x.iter()\n                .map(|&amp;attachment| attachment.guid.unwrap_or(String::new()))\n                .collect()\n        }\n        None =&gt; None,\n    };\n}\n</code></pre>\n\n<p>The error in the compiler is clear:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `std::option::Option&lt;std::vec::Vec&lt;std::string::String&gt;&gt;: std::iter::FromIterator&lt;std::string::String&gt;` is not satisfied\n  --&gt; src/main.rs:15:18\n   |\n15 |                 .collect()\n   |                  ^^^^^^^ the trait `std::iter::FromIterator&lt;std::string::String&gt;` is not implemented for `std::option::Option&lt;std::vec::Vec&lt;std::string::String&gt;&gt;`\n   |\n   = note: a collection of type `std::option::Option&lt;std::vec::Vec&lt;std::string::String&gt;&gt;` cannot be built from an iterator over elements of type `std::string::String`\n</code></pre>\n\n<p>If I remember what I've read from the documentation so far, I cannot implement traits for <code>struct</code> that I don't own.</p>\n\n<p>How can I do this using <code>iter().map(...).collect()</code> or maybe another way?</p>\n"}, {"tags": ["multithreading", "rust"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 3, "creation_date": 1484937947, "post_id": 41770184, "comment_id": 70732208, "body": "What exactly do you want to manage with that <code>Arc</code>? The <code>workers</code> vector? <code>Arc</code> needs ownership of the thing it manages, but you can&#39;t provide ownership, because you only have a borrow of the vector. There are <a href=\"http://stackoverflow.com/search?q=%5Brust%5D+%22cannot+move+out+of+borrowed+content%22\">plenty of questions with the error message &quot;cannot move out of borrowed content&quot;</a> already. Maybe one of those can help you?"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 3, "creation_date": 1484938025, "post_id": 41770184, "comment_id": 70732240, "body": "Also: string interpolation in Rust is usually not done via the <code>+</code> operator, but with <code>format!()</code>. You can replace your strange line with <code>name: format!(&quot;Worker{}&quot;, i)</code>. This does the same, looks cleaner and avoids unnecessary heap allocations."}, {"owner": {"reputation": 916, "user_id": 3019905, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/P1ga3.png?s=128&g=1", "display_name": "Dash83", "link": "https://stackoverflow.com/users/3019905/dash83"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1484938452, "post_id": 41770184, "comment_id": 70732443, "body": "I am indeed trying to manage the worker vector. My idea was that each thread would be a worker, and keep a worker struct as it&#39;s internal state, while at the same time the master keeps a reference to the vector of workers."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1484939916, "post_id": 41770184, "comment_id": 70733170, "body": "@Dash83: You were so close to the solution! I suggest you find a <a href=\"https://en.wikipedia.org/wiki/Rubber_duck_debugging\" rel=\"nofollow noreferrer\">Rubber Duck</a> to help you in the future, somewhat talking aloud about your assumptions help highlight the funky bits."}], "answers": [{"comments": [{"owner": {"reputation": 916, "user_id": 3019905, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/P1ga3.png?s=128&g=1", "display_name": "Dash83", "link": "https://stackoverflow.com/users/3019905/dash83"}, "edited": false, "score": 0, "creation_date": 1485182199, "post_id": 41770867, "comment_id": 70805605, "body": "Thank you, @Matthieu, insightful answers as always. However, I&#39;m stumped now. Truth be told is, I don&#39;t need this shared collection of workers and start threads for each one, I could have created a separate worker binary that takes parameters for startup and then spawn the processes and forget about ownership, but since Rust promotes fearless concurrency, I opted to give that a shot.However, moving the issue from the compiler to runtime does not seem fearless. Is there a way to achieve the desired effect with compiler checks? Or am I simply looking at this the wrong way?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 916, "user_id": 3019905, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/P1ga3.png?s=128&g=1", "display_name": "Dash83", "link": "https://stackoverflow.com/users/3019905/dash83"}, "edited": false, "score": 0, "creation_date": 1485189986, "post_id": 41770867, "comment_id": 70810818, "body": "@Dash83: Fearless means that the language has your back (at either compile time or runtime), though I do too tend to prefer compile time checks rather than panicking binaries. Since you are not modifying <code>workers</code> in the thread, you can use a crate like <code>crossbeam</code> which supports referencing stack data from multiple threads, and you will no longer need <code>Arc</code> at all. Another solution is to copy the <code>Worker</code>. Yet another is to have <code>Master</code> relinquish ownership of <code>Worker</code> (<code>for w in self.workers.drain() { ... }</code>... it really depends on your constraints :)"}, {"owner": {"reputation": 916, "user_id": 3019905, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/P1ga3.png?s=128&g=1", "display_name": "Dash83", "link": "https://stackoverflow.com/users/3019905/dash83"}, "edited": false, "score": 0, "creation_date": 1485271919, "post_id": 41770867, "comment_id": 70850853, "body": "you sir, are a scholar. Crossbeam scopes work great for this initial proof of concept. Not sure I&#39;ll stick with that crate in the long run, as I would rather learn the best practices for concurrency in Rust and design good code around them, but it works for now! Thanks!"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 916, "user_id": 3019905, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/P1ga3.png?s=128&g=1", "display_name": "Dash83", "link": "https://stackoverflow.com/users/3019905/dash83"}, "edited": false, "score": 0, "creation_date": 1485272123, "post_id": 41770867, "comment_id": 70850993, "body": "I would say Crossbeam helps promoting good code :) Rust used to have the ability to reference stack-allocated data across threads, however the implementation relied on the fact that destructors would always be called and a PoC was made that you could manage to leak the destructor in order to have the stack-allocated data vanish was still referenced... creating a crash with safe code. Ouch. Since then, multiple crates have popped up to explore options to restore this capability: crossbeam &amp; rayon are both written by different core team members (and explore different directions/usecases)."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 6, "last_activity_date": 1484939846, "creation_date": 1484939846, "answer_id": 41770867, "question_id": 41770184, "link": "https://stackoverflow.com/questions/41770184/arc-reference-to-member-of-field/41770867#41770867", "title": "Arc reference to member of field", "body": "<p>Welcome to Ownership.</p>\n\n<p>In Rust, any single piece of data has <em>one and exactly one</em> owner. Don't be fooled by <code>Rc</code> and <code>Arc</code>: they are a shared interface on top of a single (invisible) owner.</p>\n\n<p>The simplest way of expressing ownership is <em>by value</em>:</p>\n\n<pre><code>struct Master {\n    workers: Vec&lt;Worker&gt;\n}\n</code></pre>\n\n<p>Here, <code>Master</code> owns a <code>Vec&lt;Worker&gt;</code> which itself owns multiple <code>Worker</code>.</p>\n\n<p>Similarly, functions that take their argument by value (<code>fn new(t: T) -&gt; Arc&lt;T&gt;</code> for example) receive ownership of their argument.</p>\n\n<p>And that is where the issue lies:</p>\n\n<pre><code>Arc::new(self.workers)\n</code></pre>\n\n<p>means that you are, at the same time:</p>\n\n<ul>\n<li>claiming that <code>Master</code> is the owner of <code>workers</code></li>\n<li>claiming that <code>Arc</code> is the owner of <code>workers</code></li>\n</ul>\n\n<p>Given the rule of <em>one and exactly one</em> owner, this is clearly intractable.</p>\n\n<hr>\n\n<p>So, how do you cheat and have multiple co-owners for a single piece of data?</p>\n\n<p>Well... use <code>Rc</code> or <code>Arc</code>!</p>\n\n<pre><code>struct Master {\n    workers: Arc&lt;Vec&lt;Worker&gt;&gt;\n}\n</code></pre>\n\n<p>And now creating <code>data</code> is as simple as:</p>\n\n<pre><code>let data = self.workers.clone();\n</code></pre>\n\n<p>which creates a new <code>Arc</code> (which just bumps the reference count).</p>\n\n<hr>\n\n<p>That's not quite all, though. The core tenet of the Borrowing system is: <strong>Aliasing XOR Mutability</strong>.</p>\n\n<p>Since <code>Arc</code> is about aliasing, it prevents mutability. You cannot insert workers into <code>self.workers</code> any longer!</p>\n\n<p>There are multiple solutions, such as deferring the initialization of <code>self.workers</code> until the vector is built, however the most common is to use cells or mutexes, that is <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> or <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> (or <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>).</p>\n\n<p><code>RefCell</code> and <code>Mutex</code> are wrappers that move borrow checking from compile-time to run-time. This gives a bit more flexibility, but may result in run-time panics instead of compile-time errors, so is best used as a last resort.</p>\n"}], "owner": {"reputation": 916, "user_id": 3019905, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/P1ga3.png?s=128&g=1", "display_name": "Dash83", "link": "https://stackoverflow.com/users/3019905/dash83"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 943, "favorite_count": 0, "accepted_answer_id": 41770867, "answer_count": 1, "score": 0, "last_activity_date": 1484940468, "creation_date": 1484936941, "last_edit_date": 1484940468, "question_id": 41770184, "link": "https://stackoverflow.com/questions/41770184/arc-reference-to-member-of-field", "title": "Arc reference to member of field", "body": "<p>I'm trying to spawn a given set of threads and have each perform a long running operation. I would be passing a structure to each worker thread as the internal state of the given thread. The collection of said structs is kept in a vector, part of a <code>Master</code> struct.</p>\n\n<p>The compiler rejects me passing the internal member of a struct to <code>Arc::new()</code>:</p>\n\n<pre><code>use std::thread;\nuse std::sync::Arc;\n\nstruct Worker {\n   name: String,\n}\n\nstruct Master {\n    workers: Vec&lt;Worker&gt;,\n}\n\nimpl Worker {\n    fn start(&amp;self) {\n        println!(\"My name is {} and I'm working!\", self.name);\n        thread::sleep_ms(100_000);\n    }\n}\n\nimpl Master {\n    pub fn run_test(&amp;mut self) {\n        for i in 0..10 {\n            self.workers.push(Worker { \n                name: String::new() + \"Worker\" + &amp;i.to_string() \n            });\n        }\n        let mut data = Arc::new(self.workers);\n\n        for i in 0..10 {\n            let local_data = data.clone();\n            thread::spawn(move || {\n                local_data[i].start();\n            });\n        }\n\n        thread::sleep_ms(100_000);\n    }\n}\n\n\nfn main() {\n    let mut master = Master { workers: vec![] };\n}\n</code></pre>\n\n<p>The error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n  --&gt; &lt;anon&gt;:26:33\n   |\n26 |         let mut data = Arc::new(self.workers);\n   |                                 ^^^^ cannot move out of borrowed content\n</code></pre>\n\n<p>What am I doing wrong? Is this idiomatic Rust?</p>\n"}, {"tags": ["macos", "ubuntu", "rust", "rust-cargo"], "answers": [{"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 2, "last_activity_date": 1484909540, "last_edit_date": 1484909540, "creation_date": 1484908838, "answer_id": 41761642, "question_id": 41761485, "link": "https://stackoverflow.com/questions/41761485/how-to-cross-compile-from-mac-to-linux/41761642#41761642", "title": "How to cross compile from Mac to Linux?", "body": "<p>Well, it is <em>because</em> Rust has no runtime (unlike e.g. Java's JVM) that you can't just compile code on one OS and expect it to run on a different one; what you are looking for is <a href=\"https://en.wikipedia.org/wiki/Cross_compiler\" rel=\"nofollow noreferrer\">cross-compilation</a>. I haven't done it in Rust, but from what I can gather you can find relevant information on different cross-compilation Rust strategies on this <a href=\"https://github.com/japaric/rust-cross\" rel=\"nofollow noreferrer\">GitHub repo</a>.</p>\n"}, {"comments": [{"owner": {"reputation": 323, "user_id": 6039371, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bf93ffed843f66eeb081062f5f10de04?s=128&d=identicon&r=PG&f=1", "display_name": "FrontMage", "link": "https://stackoverflow.com/users/6039371/frontmage"}, "edited": false, "score": 1, "creation_date": 1485057198, "post_id": 41765896, "comment_id": 70763964, "body": "I tried, I think you might have to install <code>x86_64-linux-gnu-gcc</code> then add a <code>linker</code> to <code>.cargo&#47;config</code> to make that work."}, {"owner": {"reputation": 1099, "user_id": 2213795, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/5409f467d86d77fab3f97eecac7ca4c7?s=128&d=identicon&r=PG", "display_name": "Digant C Kasundra", "link": "https://stackoverflow.com/users/2213795/digant-c-kasundra"}, "reply_to_user": {"reputation": 323, "user_id": 6039371, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bf93ffed843f66eeb081062f5f10de04?s=128&d=identicon&r=PG&f=1", "display_name": "FrontMage", "link": "https://stackoverflow.com/users/6039371/frontmage"}, "edited": false, "score": 5, "creation_date": 1489772464, "post_id": 41765896, "comment_id": 72833964, "body": "@FrontMage -- how do you install <code>x86_64-linux-gnu-gcc</code> on Mac?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 4, "creation_date": 1539447248, "post_id": 41765896, "comment_id": 92509856, "body": "This does not produce a binary: <code>error: linking with `cc` failed:</code> ... <code>= note: clang: warning: argument unused during compilation: &#39;-pie&#39; [-Wunused-command-line-argument] ld: unknown option: --as-needed clang: error: linker command failed with exit code 1 (use -v to see invocation)</code>"}, {"owner": {"reputation": 2384, "user_id": 3553432, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/fb2106952e54afdb0d370799f988ba25?s=128&d=identicon&r=PG", "display_name": "nikoss", "link": "https://stackoverflow.com/users/3553432/nikoss"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1549616309, "post_id": 41765896, "comment_id": 95974016, "body": "@Shepmaster i have the same issue while compiling from linux to mac do you have any idea about the solution ?"}, {"owner": {"reputation": 15112, "user_id": 623735, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/8eb2d80a35122171463f423eeec7bfa4?s=128&d=identicon&r=PG", "display_name": "hobs", "link": "https://stackoverflow.com/users/623735/hobs"}, "edited": false, "score": 0, "creation_date": 1550984133, "post_id": 41765896, "comment_id": 96470095, "body": "<code>brew install rustup-init &amp;&amp; rustup-init</code>"}, {"owner": {"reputation": 609, "user_id": 4242336, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/IlAOL.jpg?s=128&g=1", "display_name": "PapEr", "link": "https://stackoverflow.com/users/4242336/paper"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1555393571, "post_id": 41765896, "comment_id": 98083932, "body": "@Shepmaster you may need to install the linker, <code>brew install FiloSottile&#47;musl-cross&#47;musl-cross</code> or <code>brew install gcc</code>, and add it to <code>.cargo&#47;config</code>"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 17, "last_activity_date": 1484923418, "last_edit_date": 1484923418, "creation_date": 1484922388, "answer_id": 41765896, "question_id": 41761485, "link": "https://stackoverflow.com/questions/41761485/how-to-cross-compile-from-mac-to-linux/41765896#41765896", "title": "How to cross compile from Mac to Linux?", "body": "<p>Rust not having a runtime means that it doesn't have a lot of code running as part of the language (for example a garbage collector or bytecode interpreter).  It does still need to use operating system primitives (i.e. syscalls), and these are different on MacOS and Linux.</p>\n\n<p>What you want is a cross compiler.  If you're using <code>rustup</code>, then <a href=\"https://github.com/rust-lang-nursery/rustup.rs/#cross-compilation\" rel=\"noreferrer\">installing a cross compiler</a> should be simple:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code># Install the toolchain to build Linux x86_64 binaries\nrustup target add x86_64-unknown-linux-gnu\n</code></pre>\n\n<p>Then building is:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>cargo build --release --target=x86_64-unknown-linux-gnu\n</code></pre>\n\n<p>Caveat: I don't have an OS X machine to test this on; please comment or edit to fix this if it works!</p>\n"}], "owner": {"reputation": 323, "user_id": 6039371, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bf93ffed843f66eeb081062f5f10de04?s=128&d=identicon&r=PG&f=1", "display_name": "FrontMage", "link": "https://stackoverflow.com/users/6039371/frontmage"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4566, "favorite_count": 1, "accepted_answer_id": 41765896, "answer_count": 2, "score": 13, "last_activity_date": 1597402005, "creation_date": 1484908380, "last_edit_date": 1484923389, "question_id": 41761485, "link": "https://stackoverflow.com/questions/41761485/how-to-cross-compile-from-mac-to-linux", "title": "How to cross compile from Mac to Linux?", "body": "<p>I wrote a little game using Rust, and I used <code>cargo build --release</code> to compile a release version on Mac.</p>\n\n<p>I tried to share this with my friend who is using Ubuntu, but when he tried to run the binary, he got the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>cannot execute binary file: Exec format error\n</code></pre>\n\n<p>I searched for this but found no answers. Doesn't Rust claim to have \"no runtime\"? Shouldn't it be able to run anywhere in binary form?</p>\n"}, {"tags": ["rust", "traits"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484883207, "post_id": 41755504, "comment_id": 70703494, "body": "Duplicate of <a href=\"http://stackoverflow.com/q/26983355/155423\">Is there a way to combine multiple traits in order to define a new trait</a>?"}, {"owner": {"reputation": 3333, "user_id": 3859566, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a7c4c1c9ad9bd41f49004d32884bc680?s=128&d=identicon&r=PG&f=1", "display_name": "yong", "link": "https://stackoverflow.com/users/3859566/yong"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484883920, "post_id": 41755504, "comment_id": 70703667, "body": "Hmm, it&#39;s different because it involves a second type, <code>f64</code> -- it involves the relationship between two or more types. Should I make that more explicit?"}, {"owner": {"reputation": 3333, "user_id": 3859566, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a7c4c1c9ad9bd41f49004d32884bc680?s=128&d=identicon&r=PG&f=1", "display_name": "yong", "link": "https://stackoverflow.com/users/3859566/yong"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1484888890, "post_id": 41755504, "comment_id": 70704948, "body": "@DK Adding the line <code>impl&lt;X: Sized&gt; CanBeAdded for X where f64: Add&lt;X&gt; {}</code> doesn&#39;t help -- what should the <code>imp</code> look like? <a href=\"https://play.rust-lang.org/?gist=59b0932a780fdcaf21848de9d310621a&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1484889211, "post_id": 41755504, "comment_id": 70705029, "body": "@yong Ah, I see now.  I was wrong.  The problem is that the compiler is not implemented such that it can use the information in the trait&#39;s where clause to infer <code>f64: Add&lt;X&gt;</code> in the function.  You can have the constraint in place, but you can&#39;t use it to force a constraint on a different type.  The simplest workaround I know of would be to implement a <code>fn add_to_f64(self, f64)</code> to the <code>CanBeAdded</code> trait directly, and not to try and use <code>+</code> itself."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 0, "last_activity_date": 1485355556, "creation_date": 1485355556, "answer_id": 41854466, "question_id": 41755504, "link": "https://stackoverflow.com/questions/41755504/specify-relation-between-types-as-a-trait-or-macro/41854466#41854466", "title": "Specify relation between types as a trait or macro", "body": "<p>It's actually quite unlikely that a random type <code>X</code> is such that <code>f64: Add&lt;X&gt;</code>.</p>\n\n<p>Given that <code>f64</code> is a built-in, the only module which can define implementations of <code>Add</code> for <code>f64</code> is the one where <code>Add</code> is defined. We can check the <a href=\"https://doc.rust-lang.org/std/ops/trait.Add.html\" rel=\"nofollow noreferrer\">listed implementations here</a>:</p>\n\n<ul>\n<li><code>impl Add&lt;f64&gt; for f64</code></li>\n<li><code>impl&lt;'a&gt; Add&lt;&amp;'a f64&gt; for f64</code></li>\n</ul>\n\n<p>And that's all.</p>\n\n<hr>\n\n<p>Still, if that is all that you want, you can define the trait differently.</p>\n\n<p>First, we define a new marker trait. It's pretty uninteresting by itself as it has absolutely no method:</p>\n\n<pre><code>trait ReverseAdd&lt;T&gt; { type Output; }\n</code></pre>\n\n<p>Then, we add a blanket implementation, to automatically implement the trait for any type that implements <code>Add</code>, but with the relationship reversed:</p>\n\n<pre><code>impl&lt;T, U&gt; ReverseAdd&lt;T&gt; for U where T: Add&lt;U&gt; {\n    type Output = &lt;T as Add&lt;U&gt;&gt;::Output;\n}\n</code></pre>\n\n<p>And finally, we use it as our bound:</p>\n\n<pre><code>fn add2&lt;X: ReverseAdd&lt;f64&gt;&gt;(x: X) {\n}\n</code></pre>\n"}], "owner": {"reputation": 3333, "user_id": 3859566, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a7c4c1c9ad9bd41f49004d32884bc680?s=128&d=identicon&r=PG&f=1", "display_name": "yong", "link": "https://stackoverflow.com/users/3859566/yong"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 98, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1485355556, "creation_date": 1484882183, "last_edit_date": 1484882863, "question_id": 41755504, "link": "https://stackoverflow.com/questions/41755504/specify-relation-between-types-as-a-trait-or-macro", "title": "Specify relation between types as a trait or macro", "body": "<p>I would like to make something like the following work:</p>\n\n<pre><code>use std::ops::Add;\n\ntrait CanBeAdded: Sized where f64: Add&lt;Self&gt; {}\n\nfn add2&lt;X: CanBeAdded&gt;(x: X) {}\n\nfn main() {}\n</code></pre>\n\n<p>The above fails to compile:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `f64: std::ops::Add&lt;X&gt;` is not satisfied\n --&gt; src/main.rs:5:1\n  |\n5 | fn add2&lt;X: CanBeAdded&gt;(x: X) {}\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::ops::Add&lt;X&gt;` is not implemented for `f64`\n  |\n  = help: consider adding a `where f64: std::ops::Add&lt;X&gt;` bound\n  = note: required by `CanBeAdded`\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=e6d54a18057ec349204bf8cd7745e089&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground link</a></p>\n\n<p>I'm trying to assert the existence of certain <code>impl</code>s via a trait: i.e. <code>X: CanBeAdded</code> implies <code>f64: Add&lt;X&gt;</code>. While I can add the bounds to the where clause of the function like this:</p>\n\n<pre><code>fn add2&lt;X&gt;(x: X) where f64: Add&lt;X&gt; { }\n</code></pre>\n\n<p>I have many of them so it gets unwieldy and I would prefer to not repeat the bounds over and over. Is there a good solution to this? For example, is it possible to include a macro that expands to a series of <code>where</code> clauses?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1484859036, "post_id": 41751262, "comment_id": 70695309, "body": "Unrelated to your core issue, that&#39;s not really a proper use of an <code>enum</code>. It may just be an artifact of playing around or of a minimized example, but &quot;top speed&quot; and &quot;BMW&quot; don&#39;t seem like exclusive choices."}, {"owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1484859162, "post_id": 41751262, "comment_id": 70695378, "body": "Yeah I know it isn&#39;t really a good use, I just tried doing something like what is on <a href=\"http://rustbyexample.com/custom_types/enum.html\" rel=\"nofollow noreferrer\">rustbyexample.com/custom_types/enum.html</a> and experimented a bit."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484859540, "post_id": 41751262, "comment_id": 70695580, "body": "I&#39;m sorry that the Rust by Example enum looks like that, and I&#39;m very happy to hear that you know that&#39;s not a good example of how to use an enum!"}, {"owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1484860209, "post_id": 41751262, "comment_id": 70695972, "body": "@Shepmaster I think I sort of understand it now. The String is owned and the only way I can access it is by making a reference to it right? I didn&#39;t know that since i&#39;m on chapter 3 of Rust by Example and borrowing is on chapter 13..."}, {"owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484861813, "post_id": 41751262, "comment_id": 70696810, "body": "@Shepmaster I think this one solved it <a href=\"http://stackoverflow.com/questions/33925232/how-to-match-over-self-in-an-enum\" title=\"how to match over self in an enum\">stackoverflow.com/questions/33925232/&hellip;</a>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1484862030, "post_id": 41751262, "comment_id": 70696922, "body": "Great! I&#39;ve deleted my meta comments (and I&#39;ll delete this one soon too) but left other comments that might be useful to future people. Sorry to be such a pain, but we want to work hard to make <a href=\"https://stackoverflow.com/questions/tagged/rust\">rust</a> a great resource for everyone coming after, and that means sometimes being a bit ogreish!"}], "owner": {"reputation": 97, "user_id": 5866466, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/bba8b450bca84ed864bbfb30351e7970?s=128&d=identicon&r=PG&f=1", "display_name": "David Frickert", "link": "https://stackoverflow.com/users/5866466/david-frickert"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 42, "favorite_count": 0, "closed_date": 1484861894, "answer_count": 0, "score": 0, "last_activity_date": 1484858767, "creation_date": 1484858369, "last_edit_date": 1484858767, "question_id": 41751262, "link": "https://stackoverflow.com/questions/41751262/implementing-fmtdisplay-for-enum-cannot-move-out-of-borrowed-content", "closed_reason": "Duplicate", "title": "Implementing fmt::Display for enum - cannot move out of borrowed content", "body": "<p>I tried implementing <code>fmt::Display</code> for an <code>enum</code>, though I had a hard time understanding references:</p>\n\n<pre><code>use std::fmt;\n\nenum Car {\n    BMW,\n    Ford,\n    TopSpeed(i32),\n    Specs { weight: i32, name: String },\n}\n\nimpl fmt::Display for Car {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match self {\n            &amp;Car::BMW =&gt; write!(f, \"[Car] BMW\"),\n            &amp;Car::Ford =&gt; write!(f, \"[Car] Ford\"),\n            &amp;Car::TopSpeed(i) =&gt; write!(f, \"[Car] TopSpeed={}\", i),\n            &amp;Car::Specs { weight, name } =&gt; write!(f, \"[Car] Weight={}, Name={}\", weight, name),\n        }\n    }\n}\n\nfn main() {\n    println!(\"This is a {}\", Car::BMW);\n    println!(\"This is a {}\", Car::Ford);\n    println!(\"This is a {}\", Car::TopSpeed(200));\n    println!(\"This is a {}\",\n             Car::Specs {\n                 weight: 2000,\n                 name: \"Clio\".to_owned(),\n             });\n}\n</code></pre>\n\n<p>It gets an error: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n  --&gt; src/main.rs:16:13\n   |\n16 |             &amp;Car::Specs { weight, name } =&gt; write!(f, \"[Car] Weight={}, Name={}\", weight, name),\n   |             ^^^^^^^^^^^^^^^^^^^^^^----^^\n   |             |                     |\n   |             |                     hint: to prevent move, use `ref name` or `ref mut name`\n   |             cannot move out of borrowed content\n</code></pre>\n\n<p>If I change to <code>ref name</code> as the compiler suggests:</p>\n\n<pre><code>&amp;Car::Specs { weight, ref name } =&gt; write!(f, \"[Car] Weight={}, Name={}\", weight, name),\n</code></pre>\n\n<p>It works. Why do I need to mark <code>name</code> as <code>ref</code>?</p>\n"}, {"tags": ["char", "rust", "ffi"], "answers": [{"comments": [{"owner": {"reputation": 1113, "user_id": 969295, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/dea809ef5ac9770fb400f1eb65544443?s=128&d=identicon&r=PG", "display_name": "Sassa", "link": "https://stackoverflow.com/users/969295/sassa"}, "edited": false, "score": 0, "creation_date": 1484855131, "post_id": 41750297, "comment_id": 70693111, "body": "Making the assert would be the correct way to handle it or should I change my function (the one that will call the glue function) to receive a <code>c_char</code> instead of a <code>char</code>?"}, {"owner": {"reputation": 1113, "user_id": 969295, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/dea809ef5ac9770fb400f1eb65544443?s=128&d=identicon&r=PG", "display_name": "Sassa", "link": "https://stackoverflow.com/users/969295/sassa"}, "edited": false, "score": 2, "creation_date": 1484856008, "post_id": 41750297, "comment_id": 70693627, "body": "Thanks a lot for the detailed and very insightful answer!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 9, "last_activity_date": 1484860245, "last_edit_date": 1484860245, "creation_date": 1484854895, "answer_id": 41750297, "question_id": 41750067, "link": "https://stackoverflow.com/questions/41750067/how-to-convert-a-char-to-a-libcc-char/41750297#41750297", "title": "How to convert a char to a libc::c_char?", "body": "<p>You are asking the question:</p>\n\n<blockquote>\n  <p>How do I fit a 32-bit number into an 8-bit value?</p>\n</blockquote>\n\n<p>Which has the immediate answer: \"throw away most of the bits\":</p>\n\n<pre><code>let c = rust_character as libc::c_char;\n</code></pre>\n\n<p>However, that should cause you to stop and ask the questions:</p>\n\n<ul>\n<li>Are the remaining bits in the right encoding?</li>\n<li>What about all those bits I threw away? </li>\n</ul>\n\n<p>Rust <code>char</code>s allow encoding all Unicode scalar values. What is <em>your</em> desired behavior for this code:</p>\n\n<pre><code>let c = '\ud83d\udca9' as libc::c_char;\n</code></pre>\n\n<p>It's probably not to create the value <code>-87</code>, a non-ASCII value! Or this less-silly and perhaps more realistic variant, which is <code>-17</code>:</p>\n\n<pre><code>let c = '\u00ef' as libc::c_char;\n</code></pre>\n\n<p>You then have to ask: what does the C code mean by a character? What encoding does the C code think strings are? How does the C code handle non-ASCII text?</p>\n\n<p>The safest thing may be to assert that the value is within the ASCII range:</p>\n\n<pre><code>let c = '\u00ef';\nlet v = c as u32;\nassert!(v &lt;= 127, \"Invalid C character value\");\nlet v = v as libc::c_char;\n</code></pre>\n\n<p>Instead of asserting, you could also return a <code>Result</code> type that indicates that the value was out of range.</p>\n\n<blockquote>\n  <p>should I change my function (the one that will call the glue function) to receive a <code>c_char</code> instead of a <code>char</code>?</p>\n</blockquote>\n\n<p>That depends. That may just be pushing the problem further up the stack; now <em>every</em> caller has to decide how to create the <code>c_char</code> and worry about the values between 128 and 255. If the semantics of your code are such that the value has to be an ASCII character, then <em>encode that in your types</em>. Specifically, you can use something like the <a href=\"https://crates.io/crates/ascii\" rel=\"noreferrer\">ascii crate</a>. </p>\n\n<p>In either case, you push the possibility for failure into someone else's code, which makes your life easier at the potential expense of making the caller more frustrated.</p>\n"}], "owner": {"reputation": 1113, "user_id": 969295, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/dea809ef5ac9770fb400f1eb65544443?s=128&d=identicon&r=PG", "display_name": "Sassa", "link": "https://stackoverflow.com/users/969295/sassa"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 820, "favorite_count": 0, "accepted_answer_id": 41750297, "answer_count": 1, "score": 3, "last_activity_date": 1484860245, "creation_date": 1484853934, "last_edit_date": 1484855086, "question_id": 41750067, "link": "https://stackoverflow.com/questions/41750067/how-to-convert-a-char-to-a-libcc-char", "title": "How to convert a char to a libc::c_char?", "body": "<p>I have a C function:</p>\n\n<pre><code>Node * first_element_by_path(const Node * node, const char * path, char delimiter);\n</code></pre>\n\n<p>And a Rust glue function:</p>\n\n<pre><code>pub fn first_element_by_path(node: *mut CNode, path: *const c_char, delimiter: c_char) -&gt; *mut CNode;\n</code></pre>\n\n<p>It expects a <code>c_char</code> as delimiter. I want to send a <code>char</code> to it, but <code>c_char</code> is a <code>i8</code> and not a <code>char</code>. How can I convert a Rust <code>char</code> to <code>i8</code> or <code>c_char</code> in this case?</p>\n"}, {"tags": ["rust", "lifetime", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 4, "last_activity_date": 1484838790, "last_edit_date": 1484838790, "creation_date": 1484838284, "answer_id": 41745081, "question_id": 41744878, "link": "https://stackoverflow.com/questions/41744878/how-do-i-update-a-variable-in-a-loop-to-a-reference-to-a-value-created-inside-th/41745081#41745081", "title": "How do I update a variable in a loop to a reference to a value created inside the loop?", "body": "<p>If I understand this right, the problem is not related to life outside of the loop; <code>m</code> doesn't live long enough to keep a reference for the next iteration.</p>\n\n<pre><code>let mut n = n;\nfor i in 1..10 {\n    let (q,m) = (*n).do_something(...)\n    n = &amp;m\n}  // At this point m is no longer live, i.e. doesn't live until the next iteration.\n</code></pre>\n\n<p>Again it depends on the specific types/lifetimes, but you could potentially assign <code>m</code> to a variable with a longer lifetime, but then you're back to the first example.</p>\n"}, {"comments": [{"owner": {"reputation": 8210, "user_id": 267631, "user_type": "registered", "accept_rate": 97, "profile_image": "https://www.gravatar.com/avatar/80f84ea0bc61680503fc58c9d9f496ca?s=128&d=identicon&r=PG", "display_name": "Ben", "link": "https://stackoverflow.com/users/267631/ben"}, "edited": false, "score": 0, "creation_date": 1484845001, "post_id": 41745251, "comment_id": 70687556, "body": "I agree Cow is a clever solution, but in this case I think just assigning to n (instead of to m) would be more simplistic: <a href=\"https://play.rust-lang.org/?gist=d1def91992515ac5a409c24b9bc41af6&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 8210, "user_id": 267631, "user_type": "registered", "accept_rate": 97, "profile_image": "https://www.gravatar.com/avatar/80f84ea0bc61680503fc58c9d9f496ca?s=128&d=identicon&r=PG", "display_name": "Ben", "link": "https://stackoverflow.com/users/267631/ben"}, "edited": false, "score": 0, "creation_date": 1484845506, "post_id": 41745251, "comment_id": 70687863, "body": "@Ben only if that did what you thought it does ^_^. That defines a <b>new binding</b> (that&#39;s the meaning of <code>let</code>), thus the type of <code>n</code> changes and you never get the new value. See that <a href=\"http://play.integer32.com/?gist=37936638d30435da3a72749c59d3adbc&amp;version=stable\" rel=\"nofollow noreferrer\">this version seemingly never increments the value</a>; which is why it (and your solution) complain that <code>n</code> is a unused variable. For further information, <a href=\"http://stackoverflow.com/q/31798737/155423\">see this other question</a>."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 9, "last_activity_date": 1484841876, "last_edit_date": 1495542375, "creation_date": 1484838763, "answer_id": 41745251, "question_id": 41744878, "link": "https://stackoverflow.com/questions/41744878/how-do-i-update-a-variable-in-a-loop-to-a-reference-to-a-value-created-inside-th/41745251#41745251", "title": "How do I update a variable in a loop to a reference to a value created inside the loop?", "body": "<p>As <a href=\"https://stackoverflow.com/a/41745081/155423\">Chris Emerson points out</a>, what you are doing is <strong>unsafe</strong> and it is probably not appropriate to write code like that in C either. The variable you are taking a reference to goes out of scope at the end of each <em>loop iteration</em>, and thus you would have a <em>dangling pointer</em> at the beginning of the next iteration. This would lead to all of the memory errors that Rust attempts to prevent; <strong>Rust has prevented you from doing something bad that you thought was safe</strong>.</p>\n\n<p>If you want something that can be either borrowed or owned; that's a <a href=\"https://doc.rust-lang.org/std/borrow/enum.Cow.html\" rel=\"nofollow noreferrer\"><code>Cow</code></a>:</p>\n\n<pre><code>use std::borrow::Cow;\n\n#[derive(Clone)]\nstruct Thing;\n\nimpl Thing {\n    fn do_something(&amp;self) -&gt; (usize, Thing) {\n        (1, Thing)\n    }\n}\n\nfn test(n: &amp;Thing) -&gt; usize {\n    let mut n = Cow::Borrowed(n);\n    let mut x = 0;\n\n    for _ in 1..10 {\n        let (q, m) = n.do_something();\n        n = Cow::Owned(m);\n        x = x + q;\n    }\n\n    x\n}\n\nfn main() {\n    println!(\"{}\", test(&amp;Thing));\n}\n</code></pre>\n"}], "owner": {"reputation": 6199, "user_id": 2560053, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/64aacb2c26ae0bb85730da51291d0b9b?s=128&d=identicon&r=PG", "display_name": "Thomas Baruchel", "link": "https://stackoverflow.com/users/2560053/thomas-baruchel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3603, "favorite_count": 1, "answer_count": 2, "score": 6, "last_activity_date": 1484841876, "creation_date": 1484837717, "last_edit_date": 1484841060, "question_id": 41744878, "link": "https://stackoverflow.com/questions/41744878/how-do-i-update-a-variable-in-a-loop-to-a-reference-to-a-value-created-inside-th", "title": "How do I update a variable in a loop to a reference to a value created inside the loop?", "body": "<p>I want to enter a loop with a variable <code>n</code> which is borrowed by the function. At each step, <code>n</code> takes a new value; when exiting the loop, the job is done, with the help of other variables, and <code>n</code> will <em>never</em> be used again.</p>\n\n<p>If I don't use references, I have something like this:</p>\n\n<pre><code>fn test(n: Thing) -&gt; usize {\n    // stuff\n    let mut n = n;\n    for i in 1..10 {\n        let (q, m) = n.do_something(...);\n        n = m;\n        // stuff with x\n    }\n    x\n}\n</code></pre>\n\n<p><code>x</code> is the result of some computation with <code>q</code> and <code>m</code> but it is an <code>usize</code> type and I didn't encounter any issue in this part of the code. I didn't test this code, but this is the idea. I could make code written like this work.</p>\n\n<p>Since I want to do it with a reference; I tried to write:</p>\n\n<pre><code>fn test(n: &amp;Thing) -&gt; usize {\n    // stuff\n    let mut n = n;\n    for i in 1..10 {\n        let (q, m) = (*n).do_something(...);\n        n = &amp;m;\n        // stuff with x\n    }\n    x\n}\n</code></pre>\n\n<p>Now the code will not compile because <code>m</code> has a shorter lifetime than <code>n</code>. I tried to make it work by doing some tricky things or by cloning things, but this can't be the right way. In C, the code would work because we don't care about what <code>n</code> is pointing to when exiting the loop since <code>n</code> isn't used after the loop. I perfectly understand that this is where Rust and C differ, but I am pretty sure a clean way of doing it in Rust exists.</p>\n\n<p>Consider my question as very general; I am not asking for some <em>ad-hoc</em> solution for a specific problem.</p>\n"}, {"tags": ["rust", "rust-cargo"], "answers": [{"comments": [{"owner": {"reputation": 400, "user_id": 716769, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/448f9df88102c83808f2cf401ecc1b51?s=128&d=identicon&r=PG", "display_name": "Bogdan Mart", "link": "https://stackoverflow.com/users/716769/bogdan-mart"}, "edited": false, "score": 0, "creation_date": 1548287050, "post_id": 41743950, "comment_id": 95491897, "body": "thanks for list. Sadly it don&#39;t have any options to detect is it nightly or stable"}, {"owner": {"reputation": 796, "user_id": 959847, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/40d3fdc131dbfeae3a893a354bcbcf67?s=128&d=identicon&r=PG", "display_name": "euclio", "link": "https://stackoverflow.com/users/959847/euclio"}, "reply_to_user": {"reputation": 400, "user_id": 716769, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/448f9df88102c83808f2cf401ecc1b51?s=128&d=identicon&r=PG", "display_name": "Bogdan Mart", "link": "https://stackoverflow.com/users/716769/bogdan-mart"}, "edited": false, "score": 1, "creation_date": 1577714718, "post_id": 41743950, "comment_id": 105233774, "body": "@BogdanMart you might be interested in <a href=\"https://github.com/rust-lang/rfcs/pull/2523\" rel=\"nofollow noreferrer\">this RFC</a>."}], "tags": [], "owner": {"reputation": 8378, "user_id": 124538, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/82159aeb57c52bc0c7bfe6e9c832c3ea?s=128&d=identicon&r=PG", "display_name": "Wesley Wiser", "link": "https://stackoverflow.com/users/124538/wesley-wiser"}, "is_accepted": true, "score": 36, "last_activity_date": 1554975417, "last_edit_date": 1554975417, "creation_date": 1484835302, "answer_id": 41743950, "question_id": 41742046, "link": "https://stackoverflow.com/questions/41742046/is-there-a-list-of-all-cfg-features/41743950#41743950", "title": "Is there a list of all cfg features?", "body": "<p>The <a href=\"https://doc.rust-lang.org/reference/conditional-compilation.html\" rel=\"noreferrer\">\"Conditional compilation\" section of the Reference</a> has a list of configurations that must be defined <em>(as of Rust 1.14)</em>:</p>\n\n<ul>\n<li><code>target_arch</code> with values like: \n\n<ul>\n<li><code>x86</code> </li>\n<li><code>x86_64</code></li>\n<li><code>mips</code></li>\n<li><code>powerpc</code></li>\n<li><code>powerpc64</code></li>\n<li><code>arm</code></li>\n<li><code>aarch64</code></li>\n</ul></li>\n<li><code>target_os</code> with values like: \n\n<ul>\n<li><code>windows</code></li>\n<li><code>macos</code></li>\n<li><code>ios</code></li>\n<li><code>linux</code></li>\n<li><code>android</code></li>\n<li><code>freebsd</code></li>\n<li><code>dragonfly</code></li>\n<li><code>bitrig</code></li>\n<li><code>openbsd</code></li>\n<li><code>netbsd</code></li>\n</ul></li>\n<li><code>target_family</code> with values like:\n\n<ul>\n<li><code>unix</code></li>\n<li><code>windows</code></li>\n</ul></li>\n<li><code>unix</code> (shortcut for <code>target_family</code>)</li>\n<li><code>windows</code> (shortcut for <code>target_family</code>)</li>\n<li><code>target_env</code> with values like:\n\n<ul>\n<li><code>gnu</code></li>\n<li><code>msvc</code></li>\n<li><code>musl</code></li>\n<li><code>\"\"</code> (empty string)</li>\n</ul></li>\n<li><code>target_endian</code> with values:\n\n<ul>\n<li><code>little</code></li>\n<li><code>big</code></li>\n</ul></li>\n<li><code>target_pointer_width</code> with values like:\n\n<ul>\n<li><code>32</code></li>\n<li><code>64</code></li>\n</ul></li>\n<li><code>target_has_atomic</code> with values like:\n\n<ul>\n<li><code>8</code></li>\n<li><code>16</code></li>\n<li><code>32</code></li>\n<li><code>64</code></li>\n<li><code>ptr</code></li>\n</ul></li>\n<li><code>target_vendor</code> with values like:\n\n<ul>\n<li><code>apple</code></li>\n<li><code>pc</code></li>\n<li><code>unknown</code></li>\n</ul></li>\n<li><code>test</code></li>\n<li><code>debug_assertions</code></li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 730, "user_id": 3283003, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/969f644f75512332a20f0ea1ff6e64d0?s=128&d=identicon&r=PG&f=1", "display_name": "Squirrel", "link": "https://stackoverflow.com/users/3283003/squirrel"}, "is_accepted": false, "score": 0, "last_activity_date": 1522816070, "creation_date": 1522816070, "answer_id": 49642779, "question_id": 41742046, "link": "https://stackoverflow.com/questions/41742046/is-there-a-list-of-all-cfg-features/49642779#49642779", "title": "Is there a list of all cfg features?", "body": "<p>See also <a href=\"https://internals.rust-lang.org/t/all-the-rust-features/4322\" rel=\"nofollow noreferrer\">https://internals.rust-lang.org/t/all-the-rust-features/4322</a> for a comprehensive list of features.</p>\n\n<p>Bear in mind that some / most of the features won't be stabilized so will only be available in nightly for some time and are subject to breaking improvements / upgrades until they are either stabilized or discontinued.</p>\n\n<p>Features in rust nightly is survival of the fittest.</p>\n"}, {"tags": [], "owner": {"reputation": 351, "user_id": 6335914, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/6Lanm.png?s=128&g=1", "display_name": "Bo Lu", "link": "https://stackoverflow.com/users/6335914/bo-lu"}, "is_accepted": false, "score": 4, "last_activity_date": 1546945183, "creation_date": 1546945183, "answer_id": 54090349, "question_id": 41742046, "link": "https://stackoverflow.com/questions/41742046/is-there-a-list-of-all-cfg-features/54090349#54090349", "title": "Is there a list of all cfg features?", "body": "<p>You can also use this command: <code>rustc --print target-list</code>.</p>\n\n<p>Each triple are formatted as follows: <strong>{arch}-{vendor}-{sys}-{abi}</strong>.</p>\n\n<p>For example, the triple '<em>arm-unknown-linux-gnueabihf</em>' refers to:</p>\n\n<ol>\n<li>architecture: arm</li>\n<li>vendor: unknown. In this case, no vendor was specified.</li>\n<li>system: linux</li>\n<li>ABI: gnueabihf</li>\n</ol>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 12794, "favorite_count": 13, "accepted_answer_id": 41743950, "answer_count": 3, "score": 22, "last_activity_date": 1554975417, "creation_date": 1484829598, "last_edit_date": 1518705017, "question_id": 41742046, "link": "https://stackoverflow.com/questions/41742046/is-there-a-list-of-all-cfg-features", "title": "Is there a list of all cfg features?", "body": "<p>Rust has the ability to <a href=\"https://doc.rust-lang.org/book/conditional-compilation.html\" rel=\"noreferrer\">check configuration at build</a> time with, e.g., <code>#[cfg(target_os = \"linux\")]</code> or  <code>if cfg!(target_os = \"linux\") {...}</code>, where <code>target_os</code> is a <em>feature</em>.</p>\n\n<p>Is there a list of all (or, at least, commonly used) features that can be checked in Rust?</p>\n\n<hr>\n\n<p>See related question regarding <em>attributes</em> <a href=\"https://stackoverflow.com/questions/37900513/is-there-an-exhaustive-list-of-standard-attributes-anywhere?noredirect=1&amp;lq=1\">Is there an exhaustive list of standard attributes anywhere?</a>.</p>\n"}, {"tags": ["rust", "closures", "lifetime"], "answers": [{"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 5, "last_activity_date": 1484821643, "last_edit_date": 1484821643, "creation_date": 1484819514, "answer_id": 41738619, "question_id": 41738049, "link": "https://stackoverflow.com/questions/41738049/idiomatic-way-to-store-a-closure-for-reuse/41738619#41738619", "title": "Idiomatic way to store a closure for reuse?", "body": "<p>The idiomatic solution to this is to box the closures. While boxing a closure and calling it later incurs allocation overhead and dynamic dispatch overhead, in most cases it is negligible and the <code>MyAction</code> type stays easily usable with friendly error messages.</p>\n\n<p>Alternatively the different functions can be generic fields of the <code>MyAction</code> struct, which store the closure without indirection. This can yield enormous speedups in some cases, but the usability of such a type decreases due to more complex error messages and the inability to move <code>MyAction</code> objects around freely.</p>\n\n<p>If the boxed version clearly shows up in profiling as slow, then you can move to the generic version. Otherwise I suggest to stay with the easy to use boxed version.</p>\n\n<blockquote>\n  <p>box with 'static lifetime or not?</p>\n</blockquote>\n\n<p>Again, for simplicity you can use the <code>'static</code> lifetime, but then your <code>MyAction</code> struct can only store closures that do not borrow their environment. If you use a lifetime on the <code>MyAction</code> struct and forward it to the closures, you'll be able to borrow your environment, at the cost of generic arguments, which again might end up making the <code>MyAction</code> struct harder to use correctly.</p>\n"}, {"tags": [], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "is_accepted": false, "score": 3, "last_activity_date": 1484856315, "last_edit_date": 1484856315, "creation_date": 1484833626, "answer_id": 41743355, "question_id": 41738049, "link": "https://stackoverflow.com/questions/41738049/idiomatic-way-to-store-a-closure-for-reuse/41743355#41743355", "title": "Idiomatic way to store a closure for reuse?", "body": "<p>For completeness, since some of the syntax for closure ownership isn't obvious, here is my attempt at an idiomatic/rustic version of the code in the question.</p>\n\n<p><em>(if theres any issues with it, please comment or update it directly).</em></p>\n\n<ul>\n<li>Used Boxed closure, in general this seems to be the preferred method since it means multiple different closure types can be stored in the same struct.</li>\n<li>Not using <code>'static</code>, this allows the caller to use variables in their environment (see <code>num_other</code> use in the question). Instead use a lifetime on the <code>struct</code>.</li>\n</ul>\n\n<p>Working example using boxed closures inheriting the container structs lifetime:</p>\n\n<pre><code>use std::boxed::Box;\n\nstruct MyActions&lt;'a&gt; {\n    num: i32,\n    times: i32,\n\n    update_fn:  Option&lt;Box&lt;Fn(i32) -&gt; i32 + 'a&gt;&gt;,\n    twiddle_fn: Option&lt;Box&lt;Fn(i32) -&gt; i32 + 'a&gt;&gt;,\n}\n\nimpl &lt;'a&gt; MyActions&lt;'a&gt; {\n    pub fn new(num: i32) -&gt; Self {\n        return MyActions {\n            num: num,\n            times: 1,\n            update_fn: None,\n            twiddle_fn: None,\n        }\n    }\n\n    pub fn build(self) -&gt; i32 {\n        let mut num = self.num;\n\n        if let Some(update_fn) = self.update_fn {\n            for _ in 0..self.times {\n                num = update_fn(num);\n            }\n        }\n\n        if let Some(twiddle_fn) = self.twiddle_fn {\n            for _ in 0..self.times {\n                num = twiddle_fn(num);\n            }\n        }\n\n        return num;\n    }\n\n    pub fn num_times(mut self, times: i32) -&gt; Self {\n        self.times = times;\n        self\n    }\n\n    pub fn num_update&lt;F&gt;(mut self, func: F) -&gt; Self\n        where\n        F: 'a,\n        F: Fn(i32) -&gt; i32,\n    {\n        self.update_fn = Some(Box::new(func));\n        self\n    }\n\n    pub fn num_twiddle&lt;F&gt;(mut self, func: F) -&gt; Self\n        where\n        F: 'a,\n        F: Fn(i32) -&gt; i32,\n    {\n        self.twiddle_fn = Some(Box::new(func));\n        self\n    }\n}\n\n// no changes needed here\nfn main() {\n    let act = MyActions::new(133);\n    let num_other: i32 = 4;\n\n    // builder pattern (currently executes immediately).\n    let result = act\n        .num_times(8)\n        .num_update(|x| x * 2 + num_other)\n        .num_twiddle(|x| (((x / 2) - 1) ^ (x + 1)) ^ num_other)\n        .build();\n\n    println!(\"done: {}\", result);\n\n    // Lets say we would want this example to work,\n    // where 'times' is set after defining both functions.\n    let act = MyActions::new(133);\n    let result = act\n        .num_update(|x| x * 2 + num_other)\n        .num_twiddle(|x| (((x / 2) - 1) ^ (x + 1)) ^ num_other)\n        .num_times(8)  // &lt;-- order changed here\n        .build();\n\n    println!(\"done: {}\", result);\n}\n</code></pre>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1640, "favorite_count": 0, "answer_count": 2, "score": 3, "last_activity_date": 1484856315, "creation_date": 1484817737, "last_edit_date": 1484830657, "question_id": 41738049, "link": "https://stackoverflow.com/questions/41738049/idiomatic-way-to-store-a-closure-for-reuse", "title": "Idiomatic way to store a closure for reuse?", "body": "<p>Passing closures in Rust is quite straightforward, however when storing closures for re-use, there are multiple solutions (use generic function types, reference closures or box, box with <code>'static</code> lifetime or not?...).</p>\n\n<p>While I've muddled through this multiple times using different kinds of boxed types, read over similar Q&amp;A's and could even hazard a guess at answering this question. I don't have a feel for how to handle this, even for the simple/obvious case, or what a good starting point would be.</p>\n\n<p>To make the question more concrete, what would be a good way to make this example store functions for re-use, using the builder pattern to store closures to be called later.</p>\n\n<pre><code>// This example looks a bit long but its really very simple.\n\n// * This example is most of the way to implementing the builder pattern,\n//   it ust runs the code immediately instead of storing input\n//   to run on `build()`.\n// * Changes should only be needed where the comment `stored closures:`\n//   has been written.\n// * I've attempted to make this example as generic as possible,\n//   but not _so_ simple that the answer wont apply to real-world use (hopefully!).\n\nstruct MyActions {\n    num: i32,\n    times: i32,\n\n    // stored closures: should be stored here.\n    // update_fn: Option&lt;Fn(...)&gt;,\n    // twiddle_fn: Option&lt;Fn(...)&gt;,\n}\n\nimpl MyActions {\n    pub fn new(num: i32) -&gt; Self {\n        return MyActions {\n            num: num,\n            times: 1,\n        }\n    }\n\n    pub fn build(self) -&gt; i32 {\n        // stored closures:\n        // should run both actions if they're defined and return the result.\n        return self.num;\n    }\n\n    pub fn num_times(mut self, times: i32) -&gt; Self {\n        self.times = times;\n        self\n    }\n\n    pub fn num_update&lt;F&gt;(mut self, func: F) -&gt; Self\n        where\n        F: Fn(i32) -&gt; i32\n    {\n        // stored closures: run immediately for now\n        for _ in 0..self.times {\n            self.num = func(self.num);\n        }\n        self\n    }\n\n    pub fn num_twiddle&lt;F&gt;(mut self, func: F) -&gt; Self\n        where\n        F: Fn(i32) -&gt; i32\n    {\n        // stored closures: run immediately for now\n        for _ in 0..self.times {\n            self.num = func(self.num);\n        }\n        self\n    }\n}\n\n// no changes needed here\nfn main() {\n    let act = MyActions::new(133);\n    let num_other: i32 = 4;\n\n    // builder pattern (currently executes immediately).\n    let result = act\n        .num_times(8)\n        .num_update(|x| x * 2 + num_other)\n        .num_twiddle(|x| (((x / 2) - 1) ^ (x + 1)) ^ num_other)\n        .build();\n\n    // Lets say we would want this example to work,\n    // where 'times' is set after defining both functions.\n    /*\n    let result = act\n        .num_update(|x| x * 2 + num_other)\n        .num_twiddle(|x| (((x / 2) - 1) ^ (x + 1)) ^ num_other)\n        .num_times(8)  // &lt;-- order changed here\n        .build();\n     */\n\n    println!(\"done: {}\", result);\n}\n</code></pre>\n"}, {"tags": ["rust", "traits"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1484798102, "post_id": 41733424, "comment_id": 70661089, "body": "You put it on the method declaration on the trait and saw it doesn&#39;t work. I&#39;m not sure what question you want answered; it seems like you&#39;ve already figured it out."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1485356892, "post_id": 41854749, "comment_id": 70893576, "body": "Pedantically, <code>#[inline(always)]</code> only <a href=\"https://doc.rust-lang.org/reference.html#inline-attributes\" rel=\"nofollow noreferrer\"><b>asks</b> the compiler to inline</a>, the compiler is free to ignore it."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1485357641, "post_id": 41854749, "comment_id": 70894111, "body": "@Shepmaster: While you are right, I would be sorely disappointed if a compiler ignored an <code>#[inline(always)]</code> request. <code>#[inline]</code> is a hint, and that&#39;s fine, but <code>#[inline(always)]</code> is an order; if it&#39;s not, it&#39;s not even possible to test whether inlining is beneficial or not!"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 3, "last_activity_date": 1485356805, "last_edit_date": 1485356805, "creation_date": 1485356294, "answer_id": 41854749, "question_id": 41733424, "link": "https://stackoverflow.com/questions/41733424/can-inline-be-used-in-both-trait-method-declarations-and-implementations/41854749#41854749", "title": "Can #[inline] be used in both trait method declarations and implementations?", "body": "<p><strong>What does <code>inline</code> mean?</strong></p>\n\n<p>When a compiler inlines a call, it copies the body of the function at the call site. Essentially, it's as if the code had been copy/pasted at each call site where it's inlined.</p>\n\n<p><strong>What does <code>#[inline(always)]</code> mean?</strong></p>\n\n<p>This instructs the compiler to perform inlining, always.</p>\n\n<p>Normally, the compiler performs inlining when:</p>\n\n<ul>\n<li>the body of the function is known</li>\n<li>the set of heuristics estimate that this is a good trade-off (it might not be, though) which notably depends on the size of the function body</li>\n</ul>\n\n<p><strong>Why can I not specify <code>#[inline(always)]</code> on a trait method?</strong></p>\n\n<p>Because there is no body.</p>\n\n<p>This may sounds trite, I know, however this is nonetheless true.</p>\n\n<p>In Rust, traits may be used in two ways:</p>\n\n<ul>\n<li>as bounds, for generic parameters</li>\n<li>as runtime interfaces, aka trait objects</li>\n</ul>\n\n<p>When used as a trait object, there is literally no body: the function to be called is determined at runtime!</p>\n\n<p>Now, there are specific optimizations (devirtualizations) where the compiler attempts to divine or track the actual dynamic type of variables to be able to avoid the dynamic dispatch. I've even seen partial devirtualization in GCC where the compiler computes a likeliness of each type and creates an <code>if</code> ladder for the sufficiently likely one (<code>if A { A::call(x); } else if B { B::call(x); } else { x.call(); }</code>). However those are not guaranteed to succeed, of course.</p>\n\n<p>So, what would be the semantics of <code>#[inline(always)]</code> on a virtual call? Should the compiler just ignore the attribute silently (uh!)?</p>\n\n<hr>\n\n<p>It seems to me that what you are looking for is a new attribute (<code>require(inline(always))</code>?) to enforce specific constraints on the implementations of trait methods.</p>\n\n<p>As far as I know, this does not exist yet.</p>\n"}], "owner": {"reputation": 1431, "user_id": 1553741, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/6daac35161547a75785e69de774334b8?s=128&d=identicon&r=PG", "display_name": "ajp", "link": "https://stackoverflow.com/users/1553741/ajp"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1181, "favorite_count": 0, "answer_count": 1, "score": 3, "last_activity_date": 1485356805, "creation_date": 1484797819, "last_edit_date": 1484815365, "question_id": 41733424, "link": "https://stackoverflow.com/questions/41733424/can-inline-be-used-in-both-trait-method-declarations-and-implementations", "title": "Can #[inline] be used in both trait method declarations and implementations?", "body": "<p>I have a trait with some small methods, which are generally implemented as one-line wrappers around other methods that the implementing structs have. If I want to make sure that the trait method is inlined, should I place <code>#[inline(always)]</code> inside the trait definition, or inside the <code>impl</code> for each struct? I'd prefer to simply put it in the trait definition, but as far as I can tell that doesn't work.</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 3, "creation_date": 1484797353, "post_id": 41732404, "comment_id": 70660859, "body": "Eventually, <a href=\"https://internals.rust-lang.org/t/non-lexical-lifetimes-based-on-liveness/3428\" rel=\"nofollow noreferrer\">your code should just work</a>, but Rust is not there yet."}], "answers": [{"comments": [{"owner": {"reputation": 5913, "user_id": 1244932, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d2c608e688b798896e8b516855fc1ab1?s=128&d=identicon&r=PG", "display_name": "user1244932", "link": "https://stackoverflow.com/users/1244932/user1244932"}, "edited": false, "score": 0, "creation_date": 1484796357, "post_id": 41732874, "comment_id": 70660653, "body": "You not get my point. After <code>trans.commit();</code> trans not exists. So there is no mutable references."}, {"owner": {"reputation": 5913, "user_id": 1244932, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d2c608e688b798896e8b516855fc1ab1?s=128&d=identicon&r=PG", "display_name": "user1244932", "link": "https://stackoverflow.com/users/1244932/user1244932"}, "edited": false, "score": 0, "creation_date": 1484796444, "post_id": 41732874, "comment_id": 70660671, "body": "Your solution add addiotional memory allocation, plus additional counter. Is it possible to achieve the same goal without such unnecessary things?"}, {"owner": {"reputation": 5913, "user_id": 1244932, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d2c608e688b798896e8b516855fc1ab1?s=128&d=identicon&r=PG", "display_name": "user1244932", "link": "https://stackoverflow.com/users/1244932/user1244932"}, "edited": false, "score": 0, "creation_date": 1484796457, "post_id": 41732874, "comment_id": 70660675, "body": "Thanks for answer."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 5913, "user_id": 1244932, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d2c608e688b798896e8b516855fc1ab1?s=128&d=identicon&r=PG", "display_name": "user1244932", "link": "https://stackoverflow.com/users/1244932/user1244932"}, "edited": false, "score": 0, "creation_date": 1484797055, "post_id": 41732874, "comment_id": 70660800, "body": "@user1244932 &quot;So there is no mutable references&quot; - sure, at runtime. The borrow checker can&#39;t tell that statically though at compile time that I am aware of. &quot;Is it possible to achieve the same goal without such unnecessary things?&quot; - I believe so, but it would require restructuring your code to not have the <code>parent-&gt;&lt;-child</code> relationship held together via references. When I get more time tonight I could show you what I mean in that regard."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 5913, "user_id": 1244932, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d2c608e688b798896e8b516855fc1ab1?s=128&d=identicon&r=PG", "display_name": "user1244932", "link": "https://stackoverflow.com/users/1244932/user1244932"}, "edited": false, "score": 1, "creation_date": 1484829519, "post_id": 41732874, "comment_id": 70676678, "body": "@user1244932: There is hope that, at some point, Rust will get non-lexical borrowing; that is, that instead of borrows being tracked by lexical scope (from variable introduction to closing <code>}</code>) they will instead be tracked based on the lifetime of the variable. I don&#39;t think anyone is working on it right now, though."}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 2, "last_activity_date": 1484793907, "creation_date": 1484793907, "answer_id": 41732874, "question_id": 41732404, "link": "https://stackoverflow.com/questions/41732404/why-does-a-mutable-reference-to-a-dropped-object-still-count-as-a-mutable-refere/41732874#41732874", "title": "Why does a mutable reference to a dropped object still count as a mutable reference?", "body": "<p>There is a mutable reference.</p>\n\n<p>If you change <code>transaction</code> to this:</p>\n\n<pre><code>fn transaction(&amp;mut self) -&gt; Transaction {\n    let _: () = self;\n    Transaction{conn: self}\n}\n</code></pre>\n\n<p>You'll see that the compiler errors with:</p>\n\n<pre><code> = note: expected type `()`\n = note:    found type `&amp;mut Connection`\n</code></pre>\n\n<p>So <code>self</code> is of type <code>&amp;mut Connection</code> ... a mutable reference. You're then passing this into the <code>Transaction</code> instance that is being returned from this function.</p>\n\n<p>That means your mutable borrow exists for the lifetime of <code>trans</code> (curly braces added by me to show the scope of the borrow):</p>\n\n<pre><code>let mut trans = db_conn.transaction();\n{ // &lt;-------------------- Borrow starts here\n    let mut records_without_sync = 0_usize;\n    const MAX_RECORDS_WITHOUT_SYNC: usize = 100;\n    loop {\n        //do something\n        records_without_sync += 1;\n        if records_without_sync &gt;= MAX_RECORDS_WITHOUT_SYNC {\n            trans.commit();\n            records_without_sync = 0;\n            trans = db_conn.transaction();// &lt;--- ####### D'oh! Still mutably borrowed\n        }\n    }\n} // &lt;-------------------- Borrow ends here\n</code></pre>\n\n<p>If you're looking for this sort of <code>parent-&gt;&lt;-child</code> setup, I think you'll have to reach for <code>Rc&lt;RefCell&gt;</code>.</p>\n\n<p>Specifically, an <code>Rc</code> to reference count how many times you pass the connection around and <code>RefCell</code> to track borrowing at runtime instead of compile time. Yes, that does mean you'll panic if you manage to try and mutably borrow it twice at runtime. Without knowing more about your architecture its hard to say whether this is suitable or not. </p>\n\n<p><a href=\"http://play.integer32.com/?gist=7e227161a9f7d4c3f720bff01f816b40&amp;version=stable\" rel=\"nofollow noreferrer\">Here is my solution anyway</a>:</p>\n\n<pre><code>use std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct Connection {}\n\nimpl Connection {\n    fn do_something_mutable(&amp;mut self) {\n        println!(\"Did something mutable\");\n    }\n}\n\ntype Conn = Rc&lt;RefCell&lt;Connection&gt;&gt;;\n\nstruct Transaction {\n    conn: Conn,\n}\n\nimpl Transaction {\n    fn new(connection: Conn) -&gt; Transaction {\n        Transaction { conn: connection }\n    }\n\n    fn commit(mut self) {\n        self.conn.borrow_mut().do_something_mutable();\n    }\n}\n\nfn main() {\n    let db_conn = Rc::new(RefCell::new(Connection {}));\n\n    let mut trans = Transaction::new(db_conn.clone());\n    let mut records_without_sync = 0_usize;\n    const MAX_RECORDS_WITHOUT_SYNC: usize = 100;\n    loop {\n        //do something\n        records_without_sync += 1;\n        if records_without_sync &gt;= MAX_RECORDS_WITHOUT_SYNC {\n            trans.commit();\n            records_without_sync = 0;\n            trans = Transaction::new(db_conn.clone());\n            break; // Used to stop the loop crashing the playground\n        }\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1526609099, "creation_date": 1526609099, "answer_id": 50402793, "question_id": 41732404, "link": "https://stackoverflow.com/questions/41732404/why-does-a-mutable-reference-to-a-dropped-object-still-count-as-a-mutable-refere/50402793#50402793", "title": "Why does a mutable reference to a dropped object still count as a mutable reference?", "body": "<p>Your original code works when <a href=\"https://stackoverflow.com/q/50251487/155423\">non-lexical lifetimes</a> are enabled:</p>\n\n<pre><code>#![feature(nll)]\n\nstruct Connection {}\n\nimpl Connection {\n    fn transaction(&amp;mut self) -&gt; Transaction {\n        Transaction { conn: self }\n    }\n}\n\nstruct Transaction&lt;'conn&gt; {\n    conn: &amp;'conn Connection,\n}\n\nimpl&lt;'conn&gt; Transaction&lt;'conn&gt; {\n    fn commit(self) {}\n}\n\nfn main() {\n    let mut db_conn = Connection {};\n\n    let mut trans = db_conn.transaction();\n    let mut records_without_sync = 0_usize;\n    const MAX_RECORDS_WITHOUT_SYNC: usize = 100;\n    loop {\n        //do something\n        records_without_sync += 1;\n        if records_without_sync &gt;= MAX_RECORDS_WITHOUT_SYNC {\n            trans.commit();\n            records_without_sync = 0;\n            trans = db_conn.transaction();\n        }\n    }\n}\n</code></pre>\n\n<p>Non-lexical lifetimes improve the precision of the borrow checker. The compiler has become smarter and it is now able to prove that more programs are memory safe.</p>\n"}], "owner": {"reputation": 5913, "user_id": 1244932, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d2c608e688b798896e8b516855fc1ab1?s=128&d=identicon&r=PG", "display_name": "user1244932", "link": "https://stackoverflow.com/users/1244932/user1244932"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 277, "favorite_count": 0, "answer_count": 2, "score": 3, "last_activity_date": 1526609099, "creation_date": 1484790217, "last_edit_date": 1484815748, "question_id": 41732404, "link": "https://stackoverflow.com/questions/41732404/why-does-a-mutable-reference-to-a-dropped-object-still-count-as-a-mutable-refere", "title": "Why does a mutable reference to a dropped object still count as a mutable reference?", "body": "<p>Here is a simplified example:</p>\n\n<pre><code>struct Connection {}\n\nimpl Connection {\n    fn transaction(&amp;mut self) -&gt; Transaction {\n        Transaction { conn: self }\n    }\n}\n\nstruct Transaction&lt;'conn&gt; {\n    conn: &amp;'conn Connection,\n}\n\nimpl&lt;'conn&gt; Transaction&lt;'conn&gt; {\n    fn commit(mut self) {}\n}\n\nfn main() {\n    let mut db_conn = Connection {};\n\n    let mut trans = db_conn.transaction(); //1\n    let mut records_without_sync = 0_usize;\n    const MAX_RECORDS_WITHOUT_SYNC: usize = 100;\n    loop {\n        //do something\n        records_without_sync += 1;\n        if records_without_sync &gt;= MAX_RECORDS_WITHOUT_SYNC {\n            trans.commit();\n            records_without_sync = 0;\n            trans = db_conn.transaction(); //2\n        }\n    }\n}\n</code></pre>\n\n<p>The compiler reports two mutable borrows at <strong>1</strong> and <strong>2</strong>, but that is not the case. Since <code>trans.commit()</code> takes <code>self</code> by value, <code>trans</code> is dropped, so by point <strong>2</strong> there should be no mutable references.</p>\n\n<ol>\n<li>Why can the compiler not see that at <strong>2</strong> there are no mutable references?</li>\n<li>How can I fix the code, leaving the same logic?</li>\n</ol>\n"}, {"tags": ["methods", "struct", "rust", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 836, "user_id": 2971839, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/ae42092534f65bffafcc85cc02e7d35b?s=128&d=identicon&r=PG&f=1", "display_name": "Keozon", "link": "https://stackoverflow.com/users/2971839/keozon"}, "edited": false, "score": 0, "creation_date": 1484785828, "post_id": 41731791, "comment_id": 70657961, "body": "I figured there had to be as well... but I couldn&#39;t find the magic key words to search by. If you find it, feel free to flag and close!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1484798590, "post_id": 41731791, "comment_id": 70661210, "body": "&quot;rust mutable borrow argument&quot; restricted to SO.com"}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 1, "last_activity_date": 1484785584, "creation_date": 1484785584, "answer_id": 41731791, "question_id": 41731700, "link": "https://stackoverflow.com/questions/41731700/rust-implement-methods-borrow-with-getter-method-inside-mutable-borrow-meth/41731791#41731791", "title": "Rust Implement Methods -- Borrow with &quot;getter&quot; method inside mutable borrow method", "body": "<p>(I'm sure this is a duplicate but I can't seem to find one that matches exactly)</p>\n\n<p>You need to split the calls out:</p>\n\n<pre><code>fn write(&amp;mut self) {\n    let byte = self.peek();\n    self.output.push(byte);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 836, "user_id": 2971839, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/ae42092534f65bffafcc85cc02e7d35b?s=128&d=identicon&r=PG&f=1", "display_name": "Keozon", "link": "https://stackoverflow.com/users/2971839/keozon"}, "edited": false, "score": 0, "creation_date": 1484785904, "post_id": 41731797, "comment_id": 70657977, "body": "Thanks for the explanation. Now I feel really dumb! I can&#39;t believe I never tried splitting it!"}], "tags": [], "owner": {"reputation": 17641, "user_id": 16800, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ea1de76c4c343fc844135e18da8a80f1?s=128&d=identicon&r=PG", "display_name": "Guvante", "link": "https://stackoverflow.com/users/16800/guvante"}, "is_accepted": true, "score": 2, "last_activity_date": 1484785623, "creation_date": 1484785623, "answer_id": 41731797, "question_id": 41731700, "link": "https://stackoverflow.com/questions/41731700/rust-implement-methods-borrow-with-getter-method-inside-mutable-borrow-meth/41731797#41731797", "title": "Rust Implement Methods -- Borrow with &quot;getter&quot; method inside mutable borrow method", "body": "<p>You need to save <code>self.peek()</code> into a temporary</p>\n\n<pre><code>fn write(&amp;mut self) {\n    let tmp = self.peek();\n    self.output.push(tmp);\n}\n</code></pre>\n\n<p>This should work as the durations of the borrows no longer overlap.</p>\n\n<p>The reason for the error is that your logic is roughly equal to:</p>\n\n<pre><code>let tmp1 = &amp;mut self.output;\nlet tmp2 = self.peek();\nVec&lt;u8&gt;::push(tmp1, tmp2);\n</code></pre>\n\n<p>In this way it is more obvious why the borrows overlap.</p>\n"}], "owner": {"reputation": 836, "user_id": 2971839, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/ae42092534f65bffafcc85cc02e7d35b?s=128&d=identicon&r=PG&f=1", "display_name": "Keozon", "link": "https://stackoverflow.com/users/2971839/keozon"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 349, "favorite_count": 0, "closed_date": 1484798562, "accepted_answer_id": 41731797, "answer_count": 2, "score": 1, "last_activity_date": 1484786053, "creation_date": 1484784939, "last_edit_date": 1484786053, "question_id": 41731700, "link": "https://stackoverflow.com/questions/41731700/rust-implement-methods-borrow-with-getter-method-inside-mutable-borrow-meth", "closed_reason": "Duplicate", "title": "Rust Implement Methods -- Borrow with &quot;getter&quot; method inside mutable borrow method", "body": "<p>Consider the following example program:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct Data {\n    output: Vec&lt;u8&gt;,\n    array: Vec&lt;u8&gt;\n}\n\nimpl Data {\n    fn peek(&amp;self) -&gt; u8 {\n        self.array[0]\n    }\n    fn write(&amp;mut self) {\n        self.output.push(self.peek());\n    }\n}\n\nfn main() {\n\n}\n</code></pre>\n\n<p>(Ignore the naming of methods; it makes more sense in the larger scope of the actual implementation)</p>\n\n<p>When I try to compile this, I get an error, that I can't borrow from self while self is mutably borrowed. </p>\n\n<blockquote>\n  <p>test.rs:11:26: 11:30 error: cannot borrow <code>*self</code> as immutable because\n  <code>self.output</code> is also borrowed as mutable</p>\n</blockquote>\n\n<p>I understand the concept it is addressing here; what I don't understand is how to get around this. In reality, peek does more than just read the zeroth element, and I don't want to repeat the logic of peek inside write; there must be a way for implementing this in Rust. Write and peek use completely different struct members, so there is zero chance of a race condition here. </p>\n\n<p>I'm very new to Rust, so I wouldn't be surprised if I'm missing something obvious, or if there's a design pattern or best practice I'm violating. Please let me know if that's the case. </p>\n"}]