[{"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 5913, "user_id": 899752, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/CzfBy.jpg?s=128&g=1", "display_name": "mdup", "link": "https://stackoverflow.com/users/899752/mdup"}, "is_accepted": false, "score": 0, "last_activity_date": 1430947782, "last_edit_date": 1430947782, "creation_date": 1430946074, "answer_id": 30087433, "question_id": 30087338, "link": "https://stackoverflow.com/questions/30087338/why-does-unwrap-or-keep-borrow-in-scope/30087433#30087433", "title": "Why does unwrap_or() keep borrow in scope?", "body": "<p>The problem is that <em>you</em> know, by virtue of its semantics, that <code>vec.iter_mut().find().unwrap_or()</code> will ignore anything about the <code>vec</code> it comes from. However, the compiler has no knowledge of that. Indeed, the chain of method calls could very well store a value coming from the iterator, up to the closure invoked by <code>unwrap_or()</code>. See this common scenario, which has an analog structure to your example:</p>\n\n<pre><code>let mut vec: Vec&lt;i32&gt; = vec![3, 2, 5];\nvec.iter().map(|&amp;i| { \n    vec.push(i+1)\n}).last();\n</code></pre>\n\n<p>Here <code>vec.iter_mut().find().unwrap_or()</code> is just replaced by <code>vec.iter().map()</code>. And as you can see, values from <code>vec</code> <em>can</em> be borrowed throughout the method call. In this latter example it is obvious how <code>vec.push(i+1)</code> would invalidate the iterator, that is why the compiler prevents it.</p>\n"}, {"tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "is_accepted": true, "score": 7, "last_activity_date": 1430952570, "last_edit_date": 1430952570, "creation_date": 1430947670, "answer_id": 30087881, "question_id": 30087338, "link": "https://stackoverflow.com/questions/30087338/why-does-unwrap-or-keep-borrow-in-scope/30087881#30087881", "title": "Why does unwrap_or() keep borrow in scope?", "body": "<p>The borrow is active at least for that entire statement. Unfortunately, the usual solution of pulling the <code>Option</code> out into a separate statement won't help, since it will still contain a mutable reference (in <code>Some</code>) which forces the borrow of the vector to be expanded too. This seems unavoidable when using <code>find()</code>. The compiler is worried that a pointer into the Vector's storage is floating around somewhere and would possibly be invalidated by pushing onto the vector (which could cause a reallocation). This includes not only the pointer in the returned <code>Option</code> but also ones that could be made internally by one of those functions. This would be a quite valid concern, if not for the fact that there are no \"hidden\" pointers and you only push when the <code>Option</code> <em>isn't</em> a pointer. The lifetime system is not fine-grained enough to capture this fact, and I don't see a simple way to repair this or work around it.</p>\n\n<p>What you can do is use <code>position</code> to find an index:</p>\n\n<pre><code>fn borrow_or_add(vec: &amp;mut Vec&lt;u32&gt;, val: u32) -&gt; &amp;mut u32 {\n    match vec.iter().position(|&amp;v| v == val) {\n        Some(i) =&gt; &amp;mut vec[i],\n        None =&gt; {\n            vec.push(val);\n            vec.last_mut().unwrap()\n        }\n    }\n}\n</code></pre>\n\n<p>Note that indices into vectors are essentially glorified pointers. They can start referring to the wrong element if the vector changes, though they can not become dangling on re-allocation and invalid indices (greater than the largest valid index) will cause a panic rather than memory unsafety. Still, getting the index from <code>position</code> and then indexing with it is only <em>correct</em> because the vector is not (substantially) modified in between.</p>\n"}], "owner": {"reputation": 53, "user_id": 4871435, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8940bb08da551275c972933a6265f2ed?s=128&d=identicon&r=PG&f=1", "display_name": "Vectorious", "link": "https://stackoverflow.com/users/4871435/vectorious"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 434, "favorite_count": 0, "accepted_answer_id": 30087881, "answer_count": 2, "score": 5, "last_activity_date": 1430952570, "creation_date": 1430945642, "question_id": 30087338, "link": "https://stackoverflow.com/questions/30087338/why-does-unwrap-or-keep-borrow-in-scope", "title": "Why does unwrap_or() keep borrow in scope?", "body": "<p>Trying to compile:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn main() {\n    let mut vec = vec![1, 2, 3];\n    let four: &amp;mut u32 = borrow_or_add(&amp;mut vec, 4);\n}\n\nfn borrow_or_add(vec: &amp;mut Vec&lt;u32&gt;, val: u32) -&gt; &amp;mut u32 {\n    vec.iter_mut().find(|v| **v == val).unwrap_or({\n        vec.push(val);\n\n        vec.last_mut().unwrap()\n    })\n}\n</code></pre>\n\n<p><a href=\"http://is.gd/TgzgBp\" rel=\"noreferrer\">Playground</a></p>\n\n<p>...gives the following result:</p>\n\n<pre><code>q.rs:8:9: 8:12 error: cannot borrow `*vec` as mutable more than once at a time\nq.rs:8         vec.push(val);\n               ^~~\nq.rs:7:5: 7:8 note: previous borrow of `*vec` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `*vec` until the borrow ends\nq.rs:7     vec.iter_mut().find(|v| **v == val).unwrap_or({\n           ^~~\nq.rs:12:2: 12:2 note: previous borrow ends here\nq.rs:6 fn borrow_or_add(vec: &amp;mut Vec&lt;u32&gt;, val: u32) -&gt; &amp;mut u32 {\n...\nq.rs:12 }\n        ^\nq.rs:10:9: 10:12 error: cannot borrow `*vec` as mutable more than once at a time\nq.rs:10         vec.last_mut().unwrap()\n                ^~~\nq.rs:7:5: 7:8 note: previous borrow of `*vec` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `*vec` until the borrow ends\nq.rs:7     vec.iter_mut().find(|v| **v == val).unwrap_or({\n           ^~~\nq.rs:12:2: 12:2 note: previous borrow ends here\nq.rs:6 fn borrow_or_add(vec: &amp;mut Vec&lt;u32&gt;, val: u32) -&gt; &amp;mut u32 {\n...\nq.rs:12 }\n        ^\nq.rs:10:9: 10:12 error: cannot borrow `*vec` as mutable more than once at a time\nq.rs:10         vec.last_mut().unwrap()\n                ^~~\nq.rs:7:5: 7:8 note: previous borrow of `*vec` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `*vec` until the borrow ends\nq.rs:7     vec.iter_mut().find(|v| **v == val).unwrap_or({\n           ^~~\nq.rs:12:2: 12:2 note: previous borrow ends here\nq.rs:6 fn borrow_or_add(vec: &amp;mut Vec&lt;u32&gt;, val: u32) -&gt; &amp;mut u32 {\n...\nq.rs:12 }\n        ^\n</code></pre>\n\n<p>As far as I know, the body of <code>unwrap_or()</code> cannot reference the mentioned borrow of <code>vec</code>, so why is it not dropped from scope? Is there an elegant way to implement this function? I actually can't find a way to successfully do this without using two passes and a <code>bool</code> (i.e. <code>contains()</code>).</p>\n"}, {"tags": ["multithreading", "rust"], "answers": [{"comments": [{"owner": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1430981774, "post_id": 30090126, "comment_id": 48300114, "body": "Oh woops, old code, let me wrap it back in a mutex."}, {"owner": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1430981833, "post_id": 30090126, "comment_id": 48300150, "body": "I&#39;m trying to build a dispatcher, so a broadcaster can register their endpoint (a Receiver) and a subscriber can subscribe to events (via a Sender).  Then, for every receiver a thread gets boot up, listening on that receiver, and then sends over messages to the senders that are listening to that particular message"}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1430982121, "post_id": 30090126, "comment_id": 48300307, "body": "So, what&#39;s the question now? My answer didn&#39;t address the Sync issue?"}, {"owner": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1430983314, "post_id": 30090126, "comment_id": 48301028, "body": "Why the error? Your Arc/Mutex answer is the right answer for a channel with primitive types. However, that&#39;s not the case and I&#39;m pretty sure this has to do with the struct."}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1430984641, "post_id": 30090126, "comment_id": 48301874, "body": "I think I understand your question now. Your <code>self.subscribers</code> is <code>broadcasters: Vec&lt;mpsc::Receiver&lt;DispatchMessage&gt;&gt;</code>. You stick that in an <code>Arc</code>, and like I said, channel endpoints <i>themselves</i> are <i>not sync</i>. It&#39;s not a situation like everywhere else, where <code>W</code> in <code>W&lt;T&gt;</code> would be <code>Sync</code> if <code>T</code> is <code>Sync</code>; channel endpoints are <i>fundamentally</i> not <code>Sync</code> as currently implemented in the std, since they contain <code>UnsafeCell</code>s."}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1430984704, "post_id": 30090126, "comment_id": 48301917, "body": "Your <code>DispatchMessage</code> struct is <code>Sync</code> AFAIK, since the types it consists of are <code>Sync</code>, so that&#39;s not the issue, as I expressed with the <code>W&lt;T&gt;</code> example above."}, {"owner": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1430985977, "post_id": 30090126, "comment_id": 48302653, "body": "See also the gist for the full code. But like you said, an Arc&lt;Mutex&lt;Receiver&gt;&gt; should be sync? Then why is there still this error about the unsafecell on DispatchMessage requiring sync?"}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1430986836, "post_id": 30090126, "comment_id": 48303138, "body": "Indeed that should be <code>Sync</code>. However, I&#39;m referring to line 50: <code>let shared_subscribers = Arc::new(self.subscribers);</code> and I know that <code>self.subscribers</code> is of type <code>subscribers: HashMap&lt;&amp;&#39;static str, Vec&lt;mpsc::Sender&lt;DispatchMessage&gt;&gt;&gt;,</code>. You protected the broadcasters behind a mutex, but not the subscribers."}, {"owner": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1430998887, "post_id": 30090126, "comment_id": 48311451, "body": "Same error with the subscribers removed and no extra error (although you&#39;re never sure I guess). I can always clone that over if I really need to (start only runs once), but its not the issue."}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1431024495, "post_id": 30090126, "comment_id": 48329510, "body": "Can you please update the code and show the latest error, even if it&#39;s the same? I checked here on SO and on the gist."}, {"owner": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "edited": false, "score": 0, "creation_date": 1431063797, "post_id": 30090126, "comment_id": 48343654, "body": "This is the latest code. You want me to simplify the example so subscribers are left out?"}], "tags": [], "owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "is_accepted": false, "score": 6, "last_activity_date": 1430960093, "creation_date": 1430960093, "answer_id": 30090126, "question_id": 30087033, "link": "https://stackoverflow.com/questions/30087033/moving-receiver-to-thread-complains-about-sync-but-expected-send/30090126#30090126", "title": "Moving Receiver to thread complains about Sync, but expected Send", "body": "<p><code>Arc</code> requires <code>Sync</code>, and it seems to me like you're attempting to put channels inside an <code>Arc</code>. Channels are not <code>Sync</code>, neither <code>Sender</code> nor <code>Receiver</code>.</p>\n\n<p>Without knowing what you're trying to do, here are some things that may help you:</p>\n\n<ul>\n<li>it's possible to clone <code>Sender</code>, so where you would probably <code>Arc</code> a <code>T</code> and share it between many threads, you can instead clone a <code>Sender</code> and send it to many threads, since it <em>is</em> <code>Send</code></li>\n<li>otherwise (and especially for <code>Receiver</code>, which you can't clone) you have to stick it inside an <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, which makes it <code>Sync</code>.</li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "is_accepted": true, "score": 0, "last_activity_date": 1431458840, "creation_date": 1431458840, "answer_id": 30199804, "question_id": 30087033, "link": "https://stackoverflow.com/questions/30087033/moving-receiver-to-thread-complains-about-sync-but-expected-send/30199804#30199804", "title": "Moving Receiver to thread complains about Sync, but expected Send", "body": "<p>Although Jorge is correct in the general sense, the problem with this particular code is that creating an Arc Mutex takes ownership of the argument and can thus not be a reference. This makes sense when you think about it. How can you lock something that is not yours? Or more concrete, we need to lock whatever is at that memory location, not the pointer to it.</p>\n\n<p>Changing the code to create the Arc Mutex when the broadcaster is added to the struct solves the problem. This would change that part of the code to:</p>\n\n<pre><code>pub fn register_broadcaster(&amp;mut self, broadcaster: &amp;mut Broadcast) {\n   let handle = Arc::new(Mutex::new(broadcaster.broadcast_handle()));\n   self.broadcasters.push(handle);\n}\n</code></pre>\n\n<p>And then the start method of the dispatcher would look like:</p>\n\n<pre><code>pub fn start(&amp;self) {\n   // Assuming that broadcasters.clone() copies the vector, but increase ref count on els\n   for broadcaster in self.broadcasters.clone() {\n      let subscribers = self.subscribers.clone();\n      thread::spawn(move || {\n         loop {\n            let message = broadcaster.lock().unwrap().recv().ok().expect(\"Couldn't receive message in broadcaster or channel hung up\");\n            match subscribers.get(type_to_str(&amp;message.dispatch_type)) {\n              Some(ref subs) =&gt; { \n                  for sub in subs.iter() { sub.send(message.clone()).unwrap(); }\n              },\n              None =&gt; ()\n            }\n\n         }\n      });\n   }\n}\n</code></pre>\n"}], "owner": {"reputation": 431, "user_id": 558617, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/b5cc9ec9d382c06d89cc4b785a67951e?s=128&d=identicon&r=PG", "display_name": "Timon Vonk", "link": "https://stackoverflow.com/users/558617/timon-vonk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1874, "favorite_count": 1, "accepted_answer_id": 30199804, "answer_count": 2, "score": 5, "last_activity_date": 1431458840, "creation_date": 1430944581, "last_edit_date": 1430982049, "question_id": 30087033, "link": "https://stackoverflow.com/questions/30087033/moving-receiver-to-thread-complains-about-sync-but-expected-send", "title": "Moving Receiver to thread complains about Sync, but expected Send", "body": "<p>I'm trying to reference, via an <code>Arc</code>, a receiver into a thread, so I can do centralized pub-sub via dispatcher. However, I get the following error:</p>\n\n<pre><code>src/dispatcher.rs:58:11: 58:24 error: the trait `core::marker::Sync` is not implemented for the type `core::cell::UnsafeCell&lt;std::sync::mpsc::Flavor&lt;dispatcher::DispatchMessage&gt;&gt;` [E0277]\nsrc/dispatcher.rs:58           thread::spawn(move || {\n                               ^~~~~~~~~~~~~\nsrc/dispatcher.rs:58:11: 58:24 note: `core::cell::UnsafeCell&lt;std::sync::mpsc::Flavor&lt;dispatcher::DispatchMessage&gt;&gt;` cannot be shared between threads safely\nsrc/dispatcher.rs:58           thread::spawn(move || {\n</code></pre>\n\n<p>Wat! I thought only <code>Send</code> was required for moving across channels? The code of <code>DispatchMessage</code> is:</p>\n\n<pre><code>#[derive(PartialEq, Debug, Clone)]\nenum DispatchType {\n    ChangeCurrentChannel,\n    OutgoingMessage,\n    IncomingMessage\n}\n\n#[derive(Clone)]\nstruct DispatchMessage {\n   dispatch_type: DispatchType,\n   payload: String\n}\n</code></pre>\n\n<p>Both <code>String</code> and surely <code>Enum</code> are <code>Send</code>, right? Why is it complaining about <code>Sync</code>?</p>\n\n<p>The relevant part from the dispatcher:</p>\n\n<pre><code>pub fn start(&amp;self) {\n   let shared_subscribers = Arc::new(self.subscribers);\n   for ref broadcaster in &amp;self.broadcasters {\n      let shared_broadcaster = Arc::new(Mutex::new(broadcaster));\n\n      let broadcaster = shared_broadcaster.clone();\n      let subscribers = shared_subscribers.clone();\n      thread::spawn(move || {\n         loop {\n            let message = &amp;broadcaster.lock().unwrap().recv().ok().expect(\"Couldn't receive message in broadcaster\");\n            match subscribers.get(type_to_str(&amp;message.dispatch_type)) {\n              Some(ref subs) =&gt; { \n                  for sub in subs.iter() { sub.send(*message).unwrap(); }\n              },\n              None =&gt; ()\n            }\n\n         }\n      });\n   }\n}\n</code></pre>\n\n<p>Full dispatcher code is in this gist: <a href=\"https://gist.github.com/timonv/5cdc56bf671cee69d3fa\" rel=\"nofollow\">https://gist.github.com/timonv/5cdc56bf671cee69d3fa</a></p>\n\n<p>If it's still relevant, built against the 5-2-2015 nightly.</p>\n"}, {"tags": ["reference", "rust", "traits"], "answers": [{"tags": [], "owner": {"reputation": 153, "user_id": 4860094, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-q3pM6k7fKs8/AAAAAAAAAAI/AAAAAAAAIKw/8OPkyn4pACs/photo.jpg?sz=128", "display_name": "Mikhail Borisov", "link": "https://stackoverflow.com/users/4860094/mikhail-borisov"}, "is_accepted": false, "score": 3, "last_activity_date": 1430943338, "last_edit_date": 1592644375, "creation_date": 1430943338, "answer_id": 30086679, "question_id": 30083833, "link": "https://stackoverflow.com/questions/30083833/why-does-the-borrow-trait-require-the-borrowed-type-to-be-a-reference/30086679#30086679", "title": "Why does the Borrow trait require the borrowed type to be a reference?", "body": "<p>Got <a href=\"https://botbot.me/mozilla/rust/2015-05-06/?msg=38490694&amp;page=39\" rel=\"nofollow noreferrer\">some explanation</a> on #rust IRC.</p>\n<p>From <strong>aturon</strong>:</p>\n<blockquote>\n<p>the short answer is: we'd need higher-kinded types (HKT) to do better here; it should be possible to smoothly &quot;upgrade&quot; to HKT later on, though</p>\n<p>(this is a pattern that's come up a few places in the standard library)</p>\n<p>(lifting the lifetime to the trait level is a way of encoding HKT, but makes it significantly more awkward to use the trait)</p>\n</blockquote>\n<p>From <strong>bluss</strong>:</p>\n<blockquote>\n<p>I like your question. That kind of lifetime in a trait hasn't been explored enough IMO\nbut it also has a known bug in the borrow checker right now</p>\n</blockquote>\n"}], "owner": {"reputation": 153, "user_id": 4860094, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-q3pM6k7fKs8/AAAAAAAAAAI/AAAAAAAAIKw/8OPkyn4pACs/photo.jpg?sz=128", "display_name": "Mikhail Borisov", "link": "https://stackoverflow.com/users/4860094/mikhail-borisov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1003, "favorite_count": 1, "answer_count": 1, "score": 7, "last_activity_date": 1430943338, "creation_date": 1430933854, "last_edit_date": 1430936203, "question_id": 30083833, "link": "https://stackoverflow.com/questions/30083833/why-does-the-borrow-trait-require-the-borrowed-type-to-be-a-reference", "title": "Why does the Borrow trait require the borrowed type to be a reference?", "body": "<p>Imagine some event source, which produces events represented as an enum. Of course, for best efficiency, this producer is zero-copy, i.e. it returns references to its internal buffers:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>enum Variant&lt;'a&gt; {\n    Nothing,\n    SomeInt(u64),\n    SomeBytes(&amp;'a [u8])\n}\n\nimpl Producer {\n    fn next(&amp;'a mut self) -&gt; Variant&lt;'a&gt; { ... }\n}\n</code></pre>\n\n<p>This is perfectly fine for consumers that don't require lookahead or backtracking, but sometimes there is a need to save some sequence of events. Thus, our <code>Variant</code> type becomes a generic:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>enum Variant&lt;BytesT&gt; {\n    Nothing,\n    SomeInt(u64),\n    SomeBytes(BytesT)\n}\n\ntype OwnedVariant = Variant&lt;Vec&lt;u8&gt;&gt;;\ntype BorrowedVariant&lt;'a&gt; = Variant&lt;&amp;'a [u8]&gt;;\n</code></pre>\n\n<p>Here, we end up with two types with \"owner-reference\" relationship, which is similar to pairs <code>Vec&lt;T&gt;</code>-<code>&amp;[T]</code>, <code>String</code>-<code>&amp;str</code>. Docs suggest builtin traits <code>Borrow</code> and <code>ToOwned</code> which provide just what is required except for a subtle nuance:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>trait Borrow&lt;Borrowed: ?Sized&gt; {\n    fn borrow(&amp;self) -&gt; &amp;Borrowed;\n    // this: -----------^\n}\n\npub trait ToOwned {\n    type Owned: Borrow&lt;Self&gt;;\n    fn to_owned(&amp;self) -&gt; Self::Owned;\n}\n</code></pre>\n\n<p>Result of <code>borrow</code> is required to be a <em>reference to something</em>, which <code>BorrowedVariant&lt;'a&gt;</code> is obviously not. Removing this requirement solves this problem (here, names are prefixed with <strong>alt</strong> to emphasize the fact this is an alternative interface):</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>trait AltBorrow&lt;'a, AltBorrowed&gt; {\n    fn alt_borrow(&amp;'a self) -&gt; AltBorrowed;\n}\n\ntrait AltToOwned&lt;'a&gt; {\n    type AltOwned: AltBorrow&lt;'a, Self&gt;;\n    fn alt_to_owned(&amp;'a self) -&gt; Self::AltOwned;\n}\n</code></pre>\n\n<p>This trait could then be implemented for standard types, e.g. <code>Vec</code>:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>impl&lt;'a, T&gt; AltBorrow&lt;'a, &amp;'a [T]&gt; for Vec&lt;T&gt; {\n    fn alt_borrow(&amp;'a self) -&gt; &amp;'a [T] {\n        self.as_slice()\n    }\n}\n\nimpl&lt;'a, T&gt; AltToOwned&lt;'a&gt; for &amp;'a [T]\n    where T: Clone\n{\n    type AltOwned = Vec&lt;T&gt;;\n\n    fn alt_to_owned(&amp;'a self) -&gt; Vec&lt;T&gt; {\n        self.to_vec()\n    }\n}\n</code></pre>\n\n<p>As well as for the <code>Variant</code> enum in question: </p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>impl&lt;'a&gt; AltBorrow&lt;'a, BorrowedVariant&lt;'a&gt;&gt; for OwnedVariant {\n    fn alt_borrow(&amp;'a self) -&gt; BorrowedVariant&lt;'a&gt; {\n        match self {\n            &amp;Variant::Nothing =&gt; Variant::Nothing,\n            &amp;Variant::SomeInt(value) =&gt; Variant::SomeInt(value),\n            &amp;Variant::SomeBytes(ref value) =&gt; Variant::SomeBytes(value.alt_borrow()),\n        }\n    }\n}\n\nimpl&lt;'a&gt; AltToOwned&lt;'a&gt; for BorrowedVariant&lt;'a&gt; {\n    type AltOwned = OwnedVariant;\n\n    fn alt_to_owned(&amp;'a self) -&gt; OwnedVariant {\n        match self {\n            &amp;Variant::Nothing =&gt; Variant::Nothing,\n            &amp;Variant::SomeInt(value) =&gt; Variant::SomeInt(value),\n            &amp;Variant::SomeBytes(value) =&gt; Variant::SomeBytes(value.alt_to_owned()),\n        }\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>Finally, the questions:</p>\n\n<ol>\n<li>Am I misusing the original <code>Borrow</code>/<code>ToOwned</code> concept? Should I use something else to achieve this?</li>\n<li>If not, then what are the reasons why the current less-generic interface from <code>std::borrow</code> might have been preferred?</li>\n</ol>\n\n<p><a href=\"http://is.gd/jzHt4T\" rel=\"noreferrer\">This example on Rust playpen</a></p>\n"}, {"tags": ["arrays", "rust", "slice"], "answers": [{"comments": [{"owner": {"reputation": 549, "user_id": 4396823, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/e7493ed20de304e4d88666ff6977ae33?s=128&d=identicon&r=PG&f=1", "display_name": "Steve", "link": "https://stackoverflow.com/users/4396823/steve"}, "edited": false, "score": 0, "creation_date": 1430978549, "post_id": 30080874, "comment_id": 48298533, "body": "So I wouldn&#39;t use &amp;[str] at all? What if I wanted an array of borrowed strings? Would that be [&amp;str]?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 549, "user_id": 4396823, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/e7493ed20de304e4d88666ff6977ae33?s=128&d=identicon&r=PG&f=1", "display_name": "Steve", "link": "https://stackoverflow.com/users/4396823/steve"}, "edited": false, "score": 1, "creation_date": 1430985973, "post_id": 30080874, "comment_id": 48302651, "body": "@Steve, yes, <code>&amp;[&amp;str]</code> is a slice of borrowed strings (not array - arrays have fixed size and their types look like <code>[&amp;str; 123]</code>). <code>&amp;[str]</code> is not a valid type - <code>T</code> in <code>&amp;[T]</code> should be sized (implement <code>Sized</code> trait) because slices point to a sequence of elements which are laid out in the memory uniformly. This requires each element to have definite size. <code>str</code> has no definite size, so it does not implement <code>Sized</code> and can&#39;t be used in arrays. Besides, there is also no way to construct bare <code>str</code>."}, {"owner": {"reputation": 549, "user_id": 4396823, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/e7493ed20de304e4d88666ff6977ae33?s=128&d=identicon&r=PG&f=1", "display_name": "Steve", "link": "https://stackoverflow.com/users/4396823/steve"}, "edited": false, "score": 0, "creation_date": 1431010448, "post_id": 30080874, "comment_id": 48320473, "body": "Thank you for your help!"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 39, "last_activity_date": 1430929033, "last_edit_date": 1430929033, "creation_date": 1430925387, "answer_id": 30080874, "question_id": 30080744, "link": "https://stackoverflow.com/questions/30080744/getting-size-of-an-array-passed-in-as-an-argument/30080874#30080874", "title": "Getting size of an array passed in as an argument", "body": "<p>Of course, you can do it - it's just <code>len</code> is not a field, it's a method:</p>\n\n<pre><code>fn test_length(arr: &amp;[String]){\n    if arr.len() &gt;= 10 {\n        // Do stuff\n    }\n}\n</code></pre>\n\n<p>If you only started learning Rust, you should read through the <a href=\"http://doc.rust-lang.org/1.0.0-beta/book/\">official book</a> - you will also find why <code>&amp;[str]</code> does not make sense (in short, <code>str</code> is unsized type, and you can't make an array of it; instead <code>&amp;str</code> should be used for borrowed strings and <code>String</code> for owned strings; most likely you have a <code>Vec&lt;String&gt;</code> somewhere, and you can easily get <code>&amp;[String]</code> out of it).</p>\n\n<p>I would also add that it is not clear if you want to pass a string or an array of strings into the function. If it is a string, then you should write</p>\n\n<pre><code>fn test_length(arr: &amp;str) {\n    if arr.len() &gt;= 10 {\n        // Do stuff\n    }\n}\n</code></pre>\n\n<p><code>len()</code> on a string, however, returns the length in bytes which may be not what you need (length in bytes != length in \"characters\" in general, whatever definition of \"character\" you use, because strings are in UTF-8 in Rust, and UTF-8 is a variable width encoding).</p>\n\n<p>Note that I also changed <code>testLength</code> to <code>test_length</code> because snake_case is the accepted convention for Rust programs.</p>\n"}], "owner": {"reputation": 549, "user_id": 4396823, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/e7493ed20de304e4d88666ff6977ae33?s=128&d=identicon&r=PG&f=1", "display_name": "Steve", "link": "https://stackoverflow.com/users/4396823/steve"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 18815, "favorite_count": 1, "accepted_answer_id": 30080874, "answer_count": 1, "score": 24, "last_activity_date": 1566745615, "creation_date": 1430925090, "last_edit_date": 1566745615, "question_id": 30080744, "link": "https://stackoverflow.com/questions/30080744/getting-size-of-an-array-passed-in-as-an-argument", "title": "Getting size of an array passed in as an argument", "body": "<p>I can't seem to make this work. I keep getting an error saying 'len' doesn't exist on type '&amp;[String]'.</p>\n\n<pre><code>fn testLength(arr: &amp;[String]) {\n    if arr.len &gt;= 10 {\n        // Do stuff\n    }\n}\n</code></pre>\n\n<p>I'm still pretty new to Rust, and I understand this is a pointer to a raw string somewhere. Why can't I get the length of the underlying string at runtime? Googling things like \"length of string in rust\" and \"length of array in rust\" lead me absolutely no where.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 11, "creation_date": 1430910173, "post_id": 30073875, "comment_id": 48263049, "body": "Please inline the solution. Links go stale over time."}], "tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": false, "score": 0, "last_activity_date": 1430978490, "last_edit_date": 1430978490, "creation_date": 1430907460, "answer_id": 30073875, "question_id": 30073684, "link": "https://stackoverflow.com/questions/30073684/how-to-get-mutable-references-to-two-array-elements-at-the-same-time/30073875#30073875", "title": "How to get mutable references to two array elements at the same time?", "body": "<p>The problem is that <code>&amp;mut v[\u2026]</code> first mutably borrows <code>v</code> and then gives the mutable reference to the element to the change-function.</p>\n\n<p><a href=\"https://www.reddit.com/r/rust/comments/34d42c/mutable_slice_chunking_problem/cqtndbz\" rel=\"nofollow\">This</a> reddit comment has a solution to your problem.</p>\n\n<p>Edit: Thanks for the heads-up, Shepmaster. <a href=\"https://github.com/contain-rs/par-vec\" rel=\"nofollow\">par-vec</a> is a library that allows to mutably borrow disjunct partitions of a vec.</p>\n"}, {"tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": false, "score": 12, "last_activity_date": 1487600048, "last_edit_date": 1487600048, "creation_date": 1430909450, "answer_id": 30074615, "question_id": 30073684, "link": "https://stackoverflow.com/questions/30073684/how-to-get-mutable-references-to-two-array-elements-at-the-same-time/30074615#30074615", "title": "How to get mutable references to two array elements at the same time?", "body": "<p>The borrow rules of Rust need to be checked at compilation time, that is why something like mutably borrowing a part of a <code>Vec</code> is a very hard problem to solve (if not impossible), and why it is not possible with Rust.</p>\n\n<p>Thus, when you do something like <code>&amp;mut v[i]</code>, it will mutably borrow the entire vector.</p>\n\n<p>Imagine I did something like</p>\n\n<pre><code>let guard = something(&amp;mut v[i]);\ndo_something_else(&amp;mut v[j]);\nguard.do_job();\n</code></pre>\n\n<p>Here, I create an object <code>guard</code> that internally stores a mutable reference to <code>v[i]</code>, and will do something with it when I call <code>do_job()</code>.</p>\n\n<p>In the meantime, I did something that changed <code>v[j]</code>. <code>guard</code> holds a mutable reference that is supposed to guarantee nothing else can modify <code>v[i]</code>. In this case, all is good, as long as <code>i</code> is different from <code>j</code>; if the two values are equal it is a huge violation of the borrow rules.</p>\n\n<p>As the compiler cannot guarantee that <code>i != j</code>, it is thus forbidden.</p>\n\n<p>This was a simple example, but similar cases are legions, and are why such access mutably borrows the whole container. Plus the fact that the compiler actually does not know enough about the internals of <code>Vec</code> to ensure that this operation is safe even if <code>i != j</code>.</p>\n\n<hr>\n\n<p>In your precise case, you can have a look at the <a href=\"http://doc.rust-lang.org/std/primitive.slice.html#method.swap\" rel=\"noreferrer\"><code>swap(..)</code> method</a> available on <code>Vec</code> that does the swap you are manually implementing.</p>\n\n<p>On a more generic case, you'll probably need an other container. Possibilities are wrapping all the values of your <code>Vec</code> into a type with interior mutability, such as <a href=\"http://doc.rust-lang.org/std/cell/struct.Cell.html\" rel=\"noreferrer\"><code>Cell</code></a> or <a href=\"http://doc.rust-lang.org/std/cell/struct.RefCell.html\" rel=\"noreferrer\"><code>RefCell</code></a>, or even using a completely different container, as @llogiq suggested in his answer with <a href=\"https://github.com/contain-rs/par-vec\" rel=\"noreferrer\"><code>par-vec</code></a>.</p>\n"}, {"tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": true, "score": 36, "last_activity_date": 1487599932, "last_edit_date": 1487599932, "creation_date": 1430912349, "answer_id": 30075629, "question_id": 30073684, "link": "https://stackoverflow.com/questions/30073684/how-to-get-mutable-references-to-two-array-elements-at-the-same-time/30075629#30075629", "title": "How to get mutable references to two array elements at the same time?", "body": "<p>You can solve this with <a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut\" rel=\"noreferrer\"><code>split_at_mut()</code></a>:</p>\n\n<pre><code>let mut v = vec![1, 2, 3];\nlet (a, b) = v.split_at_mut(1);   // Returns (&amp;mut [1], &amp;mut [2, 3])\nchange(&amp;mut a[0], &amp;mut b[0]); \n</code></pre>\n\n<p>There are uncountably many safe things to do that the compiler unfortunately does not recognize yet. <code>split_at_mut()</code> is just like that, a safe abstraction implemented with an <code>unsafe</code> block internally.</p>\n\n<p>We can do that too, for this problem. The following is something I use in code where I need to separate all three cases anyway (I: Index out of bounds, II: Indices equal, III: Separate indices).</p>\n\n<pre><code>enum Pair&lt;T&gt; {\n    Both(T, T),\n    One(T),\n    None,\n}\n\nfn index_twice&lt;T&gt;(slc: &amp;mut [T], a: usize, b: usize) -&gt; Pair&lt;&amp;mut T&gt; {\n    if a == b {\n        slc.get_mut(a).map_or(Pair::None, Pair::One)\n    } else {\n        if a &gt;= slc.len() || b &gt;= slc.len() {\n            Pair::None\n        } else {\n            // safe because a, b are in bounds and distinct\n            unsafe {\n                let ar = &amp;mut *(slc.get_unchecked_mut(a) as *mut _);\n                let br = &amp;mut *(slc.get_unchecked_mut(b) as *mut _);\n                Pair::Both(ar, br)\n            }\n        }\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "is_accepted": false, "score": 2, "last_activity_date": 1430923733, "last_edit_date": 1430923733, "creation_date": 1430914091, "answer_id": 30076295, "question_id": 30073684, "link": "https://stackoverflow.com/questions/30073684/how-to-get-mutable-references-to-two-array-elements-at-the-same-time/30076295#30076295", "title": "How to get mutable references to two array elements at the same time?", "body": "<p>You can't make two mutable references to the same data. This is something explicitly forbidden by the borrow checker, to prevent concurrent modifications.  However you can bypass the borrow checker by using <code>unsafe</code> blocks.</p>\n\n<p>While in your case <code>v[0]</code> and <code>v[1]</code> are clearly separate chunks, that doesn't stand to serious scrutiny. What if <code>v</code> is some kind of map called <code>NullMap</code> that maps all elements to a single field? How will compiler know in a <code>Vec</code> operations<code>v[0];v[1];</code> is safe but in <code>NullMap</code> isn't?</p>\n\n<hr>\n\n<p>If you are trying to swap two elements of an array, why not go for <a href=\"http://doc.rust-lang.org/1.0.0-beta.4/std/primitive.slice.html#method.swap\" rel=\"nofollow\"><code>slice::swap</code></a>?</p>\n\n<pre><code>fn main() {\n    let mut v = vec![1, 2, 3];\n    v.swap(0,1);\n    println!(\"{:?}\",v);\n}\n</code></pre>\n\n<p>Also <code>v</code> needs to be <code>mut</code>, because you are changing vector. An immutable version would clone and perform a swap on it.</p>\n"}, {"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 12, "last_activity_date": 1590283024, "last_edit_date": 1590283024, "creation_date": 1430925309, "answer_id": 30080841, "question_id": 30073684, "link": "https://stackoverflow.com/questions/30073684/how-to-get-mutable-references-to-two-array-elements-at-the-same-time/30080841#30080841", "title": "How to get mutable references to two array elements at the same time?", "body": "<p>Since Rust 1.26, pattern matching can be done on slices. You can use that as long as you don't have huge indices and your indices are known at compile-time.</p>\n\n<pre><code>fn change(a: &amp;mut i32, b: &amp;mut i32) {\n    let c = *a;\n    *a = *b;\n    *b = c;\n}\n\nfn main() {\n    let mut arr = [5, 6, 7, 8];\n    {\n        let [ref mut a, _, ref mut b, ..] = arr;\n        change(a, b);\n    }\n    assert_eq!(arr, [7, 6, 5, 8]);\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 6, "last_activity_date": 1487637806, "creation_date": 1487637806, "answer_id": 42356713, "question_id": 30073684, "link": "https://stackoverflow.com/questions/30073684/how-to-get-mutable-references-to-two-array-elements-at-the-same-time/42356713#42356713", "title": "How to get mutable references to two array elements at the same time?", "body": "<p>The method <a href=\"https://doc.rust-lang.org/stable/std/primitive.slice.html#method.iter_mut\" rel=\"noreferrer\"><code>[T]::iter_mut()</code></a> returns an iterator that can yield a mutable reference for each element in the slice. Other collections have an <code>iter_mut</code> method too. These methods often encapsulate unsafe code, but their interface is totally safe.</p>\n\n<p>Here's a general purpose extension trait that adds a method on slices that returns mutable references to two distinct items by index:</p>\n\n<pre><code>pub trait SliceExt {\n    type Item;\n\n    fn get_two_mut(&amp;mut self, index0: usize, index1: usize) -&gt; (&amp;mut Self::Item, &amp;mut Self::Item);\n}\n\nimpl&lt;T&gt; SliceExt for [T] {\n    type Item = T;\n\n    fn get_two_mut(&amp;mut self, index0: usize, index1: usize) -&gt; (&amp;mut Self::Item, &amp;mut Self::Item) {\n        match index0.cmp(&amp;index1) {\n            Ordering::Less =&gt; {\n                let mut iter = self.iter_mut();\n                let item0 = iter.nth(index0).unwrap();\n                let item1 = iter.nth(index1 - index0 - 1).unwrap();\n                (item0, item1)\n            }\n            Ordering::Equal =&gt; panic!(\"[T]::get_two_mut(): received same index twice ({})\", index0),\n            Ordering::Greater =&gt; {\n                let mut iter = self.iter_mut();\n                let item1 = iter.nth(index1).unwrap();\n                let item0 = iter.nth(index0 - index1 - 1).unwrap();\n                (item0, item1)\n            }\n        }\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 790, "user_id": 2925565, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/4579a7106d0d674e2a912bdc01f91418?s=128&d=identicon&r=PG&f=1", "display_name": "user2925565", "link": "https://stackoverflow.com/users/2925565/user2925565"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 10319, "favorite_count": 8, "accepted_answer_id": 30075629, "answer_count": 6, "score": 38, "last_activity_date": 1590283024, "creation_date": 1430906977, "last_edit_date": 1487599838, "question_id": 30073684, "link": "https://stackoverflow.com/questions/30073684/how-to-get-mutable-references-to-two-array-elements-at-the-same-time", "title": "How to get mutable references to two array elements at the same time?", "body": "<pre><code>fn change(a: &amp;mut i32, b: &amp;mut i32) {\n    let c = *a;\n    *a = *b;\n    *b = c;\n}\n\nfn main() {\n    let mut v = vec![1, 2, 3];\n    change(&amp;mut v[0], &amp;mut v[1]);\n}\n</code></pre>\n\n<p>When I compile the code above, it has the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0499]: cannot borrow `v` as mutable more than once at a time\n --&gt; src/main.rs:9:32\n  |\n9 |         change(&amp;mut v[0], &amp;mut v[1]);\n  |                     -          ^   - first borrow ends here\n  |                     |          |\n  |                     |          second mutable borrow occurs here\n  |                     first mutable borrow occurs here\n</code></pre>\n\n<p>Why does the compiler prohibit it? <code>v[0]</code> and <code>v[1]</code> occupy different memory positions, so it's not dangerous to use these together. And what should I do if I come across this problem?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 2282, "user_id": 123642, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/73aa7ad0c97ecb6a1d766fa8810aba29?s=128&d=identicon&r=PG", "display_name": "kolen", "link": "https://stackoverflow.com/users/123642/kolen"}, "edited": false, "score": 0, "creation_date": 1464108674, "post_id": 30065557, "comment_id": 62344667, "body": "Possible duplicate of <a href=\"http://stackoverflow.com/questions/25693824/what-is-the-best-way-to-parse-binary-protocols-with-rust\">What is the best way to parse binary protocols with Rust</a>"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1430873646, "creation_date": 1430873646, "answer_id": 30065704, "question_id": 30065557, "link": "https://stackoverflow.com/questions/30065557/idiomatic-way-to-parse-binary-data-into-primitive-types/30065704#30065704", "title": "Idiomatic way to parse binary data into primitive types", "body": "<p>Your code allows <em>any</em> copyable <code>T</code>, not just primitives. That means you could try to parse in something with a reference, which is probably not what you want:</p>\n\n<pre><code>#[derive(Copy)]\nstruct Foo(&amp;str);\n</code></pre>\n\n<p>However, the general sketch of your code is what I'd expect. You need a temporary place to store some data, and then you must convert that data to the appropriate primitive (perhaps dealing with endinaness issues).</p>\n\n<p>I'd recommend the <a href=\"http://burntsushi.net/rustdoc/byteorder/\">byteorder</a> library. With it, you call specific methods for the primitive that is required:</p>\n\n<pre><code>reader.read_u16::&lt;LittleEndian&gt;()\n</code></pre>\n\n<p>Since these methods know the desired size, they can stack-allocate an array to use as the temporary buffer, which is likely a bit more efficient than a heap-allocation. Additionally, I'd suggest changing your code to accept a generic object with the <code>Read</code> trait, instead of the specific <code>GzDecoder</code>.</p>\n\n<p>You may also want to look into a serialization library like <a href=\"https://github.com/rust-lang/rustc-serialize\">rustc-serialize</a> or <a href=\"https://github.com/serde-rs/serde\">serde</a> to see if they fit any of your use cases.</p>\n"}], "owner": {"reputation": 900, "user_id": 602721, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/be8ca2dd9f7a396f2f1e0cadcd378aa3?s=128&d=identicon&r=PG", "display_name": "tomsgd", "link": "https://stackoverflow.com/users/602721/tomsgd"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3693, "favorite_count": 2, "accepted_answer_id": 30065704, "answer_count": 1, "score": 7, "last_activity_date": 1430873646, "creation_date": 1430872594, "question_id": 30065557, "link": "https://stackoverflow.com/questions/30065557/idiomatic-way-to-parse-binary-data-into-primitive-types", "title": "Idiomatic way to parse binary data into primitive types", "body": "<p>I've written the following method to parse binary data from a gzipped file using <a href=\"https://github.com/alexcrichton/flate2-rs\" rel=\"noreferrer\">GzDecoder from the Flate2 library</a></p>\n\n<pre><code>fn read_primitive&lt;T: Copy&gt;(reader: &amp;mut GzDecoder&lt;File&gt;) -&gt; std::io::Result&lt;T&gt;\n{\n    let sz = mem::size_of::&lt;T&gt;();\n    let mut vec =  Vec::&lt;u8&gt;::with_capacity(sz);\n    let ret: T;\n    unsafe{\n        vec.set_len(sz);\n        let mut s = &amp;mut vec[..];\n        try!(reader.read(&amp;mut s));\n\n        let ptr :*const u8 = s.as_ptr();\n        ret = *(ptr as *const T)\n    }\n    Ok(ret)\n}\n</code></pre>\n\n<p>It works, but I'm not particularly happy with the code, especially with using the dummy vector and the temporary variable <code>ptr</code>. It all feels very inelegant to me and I'm sure there's a better way to do this. I'd be happy to hear any suggestions of how to clean up this code. </p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1430851208, "creation_date": 1430851208, "answer_id": 30060782, "question_id": 30060639, "link": "https://stackoverflow.com/questions/30060639/mismatched-types-when-calling-from-str-on-a-string-from-osargs/30060782#30060782", "title": "Mismatched types when calling from_str on a String from os::args", "body": "<p>That tutorial states:</p>\n\n<blockquote>\n  <p>Spring 2014</p>\n</blockquote>\n\n<p>Which is bad news in Rust-land. Until very recently, the language was undergoing many structural changes. Since the 1.0.0 betas however, the language has stabilized greatly.</p>\n\n<p>So, here's that example fixed:</p>\n\n<pre><code>use std::env; // env, not os\n\nfn main() {\n    // args is an iterator now\n    let args: Vec&lt;_&gt; = env::args().collect(); \n\n    if args.len() &lt; 2 {\n        println!(\"Error: Please provide a number as argument.\");\n        return;\n    }\n\n    // int doesn't exist anymore, from_str is better as `parse`\n    let i: i32 = args[1].parse().unwrap();\n    // No more `d` specifier\n    println!(\"{} has {} Collatz steps\", i, collatz(i)); \n}\n\n// variables should be snake_case\nfn collatz(n: i32) -&gt; i32 {\n    if n == 1 { return 0; }\n    match n % 2 {\n        0 =&gt; { 1 + collatz(n/2) }\n        _ =&gt; { 1 + collatz(n*3+1) }\n    }\n}\n</code></pre>\n\n<p>I'd suggest one of</p>\n\n<ol>\n<li>Not using that tutorial anymore</li>\n<li>Contact the authors and ask them to label what version of Rust it works with</li>\n<li>Fix the examples and submit them back</li>\n</ol>\n"}], "owner": {"reputation": 113, "user_id": 2943615, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a42d33d0f1432f90e64808339e94d2be?s=128&d=identicon&r=PG&f=1", "display_name": "user2943615", "link": "https://stackoverflow.com/users/2943615/user2943615"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 264, "favorite_count": 0, "accepted_answer_id": 30060782, "answer_count": 1, "score": 1, "last_activity_date": 1430851321, "creation_date": 1430850647, "last_edit_date": 1430851321, "question_id": 30060639, "link": "https://stackoverflow.com/questions/30060639/mismatched-types-when-calling-from-str-on-a-string-from-osargs", "title": "Mismatched types when calling from_str on a String from os::args", "body": "<p>I am working through the Rust tutorial at <a href=\"http://aml3.github.io/RustTutorial/html/01.html\" rel=\"nofollow\">http://aml3.github.io/RustTutorial/html/01.html</a>, and I am currently on the Collatz problem. When I try to compile this code, I get an error of: </p>\n\n<pre><code>main.rs:9:26: 9:39 error: mismatched types: expected `&amp;str`, found `collections::string::String` (expected &amp;-ptr, found struct collections::string::String)                                                                                            \n\nmain.rs:9 let i = from_str::&lt;int&gt;(os::args()[1]).unwrap();                                                                                     \n</code></pre>\n\n<p>So, I am trying to convert the string given from the command line input into an <code>int</code>, but the input from the command line is a <code>&amp;str</code>? What is being mismatched here?</p>\n\n<pre><code>use std::os;\n\nfn main() {\n    if os::args().len() &lt; 2 {\n        println!(\"Error: Please provide a number as argument.\");\n        return;\n    }\n\n    let i = from_str::&lt;int&gt;(os::args()[1]).unwrap();\n    println!(\"{:d} has {:d} Collatz steps\", i, collatz(i));\n}\n\nfn collatz(N: int) -&gt; int {\n    if N == 1 { return 0; }\n    match N % 2 {\n        0 =&gt; { 1 + collatz(N/2) }\n        _ =&gt; { 1 + collatz(N*3+1) }\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "is_accepted": true, "score": 8, "last_activity_date": 1430844276, "last_edit_date": 1495540400, "creation_date": 1430841373, "answer_id": 30057824, "question_id": 30057726, "link": "https://stackoverflow.com/questions/30057726/how-to-safely-cast-integers/30057824#30057824", "title": "How to safely cast integers?", "body": "<p>Similarily to previous <a href=\"https://stackoverflow.com/questions/30044026/what-happened-to-stdnumprimitive\">question</a>, that functionality moved to <a href=\"https://crates.io/crates/num\" rel=\"nofollow noreferrer\">num</a> crate. More precisely, It's in <a href=\"http://doc.rust-lang.org/num/num/traits/fn.cast.html\" rel=\"nofollow noreferrer\">num::traits::cast</a>. </p>\n"}], "owner": {"reputation": 4398, "user_id": 417803, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/78bce6b348f3c186e4830cf1dde37382?s=128&d=identicon&r=PG", "display_name": "bfops", "link": "https://stackoverflow.com/users/417803/bfops"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 473, "favorite_count": 0, "accepted_answer_id": 30057824, "answer_count": 1, "score": 7, "last_activity_date": 1430844276, "creation_date": 1430841122, "last_edit_date": 1430841992, "question_id": 30057726, "link": "https://stackoverflow.com/questions/30057726/how-to-safely-cast-integers", "title": "How to safely cast integers?", "body": "<p>There used to be a <code>fn std::num::cast</code> that would cast between integer types and return an <code>Option</code> (returning <code>None</code> if the cast was invalid). Where did that functionality go?</p>\n"}, {"tags": ["rust", "traits"], "answers": [{"comments": [{"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 1, "creation_date": 1430838713, "post_id": 30056316, "comment_id": 48228326, "body": "Isn&#39;t <code>Box&lt;TraitA&gt;</code> legal in Rust?"}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 1, "creation_date": 1430838802, "post_id": 30056316, "comment_id": 48228380, "body": "@DanielFath: the point is that <code>Box&lt;A&gt;</code> is approximately useless because <code>A</code> is not object safe\u2014you can\u2019t actually <i>do</i> anything with it."}, {"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "reply_to_user": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1430839393, "post_id": 30056316, "comment_id": 48228855, "body": "@ChrisMorgan Interesting. Can you point me to more resource on what object safe means and what is and isn&#39;t object safe?"}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1430852491, "post_id": 30056316, "comment_id": 48237330, "body": "Here&#39;s a blog post on the topic by huon: <a href=\"http://huonw.github.io/blog/2015/01/object-safety/\" rel=\"nofollow noreferrer\">huonw.github.io/blog/2015/01/object-safety</a>"}, {"owner": {"reputation": 9656, "user_id": 665488, "user_type": "registered", "accept_rate": 84, "profile_image": "https://www.gravatar.com/avatar/ed4ce6d9f3561a7c63d4c6245158d7e6?s=128&d=identicon&r=PG", "display_name": "Cam Jackson", "link": "https://stackoverflow.com/users/665488/cam-jackson"}, "edited": false, "score": 1, "creation_date": 1434973199, "post_id": 30056316, "comment_id": 49988287, "body": "Note that you can actually use a reference (<code>&amp;</code>) instead of a <code>Box</code> if you want to use the stack instead of the heap. I.e. <code>fn f(&amp;self, p: &amp;Fn() -&gt; ());</code>. Apparently this is still called a &#39;boxed closure&#39;, despite not using a <code>Box</code>. In this context, &#39;boxed&#39; just means it&#39;s a pointer type."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 7, "last_activity_date": 1430839142, "last_edit_date": 1430839142, "creation_date": 1430837409, "answer_id": 30056316, "question_id": 30055356, "link": "https://stackoverflow.com/questions/30055356/the-trait-a-is-not-implemented-for-the-type-a/30056316#30056316", "title": "The trait `A` is not implemented for the type `A`", "body": "<p>The problem is that method <code>f</code> is not object-safe because it is generic, and hence it can't be called on a trait object. You will have to force its users to pass boxed closure:</p>\n\n<pre><code>trait A {\n    fn f(&amp;self, p: Box&lt;Fn() -&gt; ()&gt;);\n}\n</code></pre>\n\n<p>I wonder why Rust allows <code>Box&lt;A&gt;</code> in the first place, I would expect an error there. And this particular error is really misleading. I would file a bug about this.</p>\n\n<p>Alternatively, you can discard trait objects in favor of regular bounded generics, though it is not always possible.</p>\n"}], "owner": {"reputation": 2232, "user_id": 1430323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/70e8f1601166dab5b623eeb428115050?s=128&d=identicon&r=PG", "display_name": "tofcoder", "link": "https://stackoverflow.com/users/1430323/tofcoder"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1846, "favorite_count": 0, "accepted_answer_id": 30056316, "answer_count": 1, "score": 5, "last_activity_date": 1430839142, "creation_date": 1430834918, "last_edit_date": 1430837035, "question_id": 30055356, "link": "https://stackoverflow.com/questions/30055356/the-trait-a-is-not-implemented-for-the-type-a", "title": "The trait `A` is not implemented for the type `A`", "body": "<p>I am trying to use a trait that has a function that takes a closure as argument, and then use it on a trait object.</p>\n\n<pre><code>trait A {\n    fn f&lt;P&gt;(&amp;self, p: P) where P: Fn() -&gt; ();\n}\n\nstruct B {\n    a: Box&lt;A&gt;\n}\n\nimpl B {\n    fn c(&amp;self) {\n        self.a.f(|| {});\n    }\n}\n</code></pre>\n\n<p>This snippet generates the following error:</p>\n\n<pre><code>the trait `A` is not implemented for the type `A` [E0277]\n</code></pre>\n\n<p>The version of <code>rustc</code> is <code>rustc 1.0.0-beta.3 (5241bf9c3 2015-04-25) (built 2015-04-25)</code>.</p>\n"}, {"tags": ["closures", "rust"], "comments": [{"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1430832463, "post_id": 30053816, "comment_id": 48223184, "body": "Convention is <code>vec![1, 2, 3]</code> over <code>vec!(1, 2, 3)</code>, incidentally."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1430832653, "post_id": 30053816, "comment_id": 48223339, "body": "@ChrisMorgan: Edited :)"}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1430832328, "post_id": 30054148, "comment_id": 48223074, "body": "Doh! I thought that declaring <code>allow_once</code> <code>mut</code> was sufficient (inherited mutability) and tried about everything short of that..."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1430833647, "post_id": 30054148, "comment_id": 48224130, "body": "Yeah, on one hand it may appear confusing, but on the other hand there is no explicit move between variables, so <code>mut</code> rules still take effect. For example, if this was an <code>FnOnce</code> closure you could move the variable like <code>let mut vector = vector</code> and then <code>mut</code> qualifier on the original variable wouldn&#39;t matter."}, {"owner": {"reputation": 3026, "user_id": 381712, "user_type": "registered", "accept_rate": 53, "profile_image": "https://www.gravatar.com/avatar/561f214b150981056634bc5b60a995cb?s=128&d=identicon&r=PG", "display_name": "soulmachine", "link": "https://stackoverflow.com/users/381712/soulmachine"}, "edited": false, "score": 0, "creation_date": 1609313048, "post_id": 30054148, "comment_id": 115807457, "body": "I want to print the length of vector at the end of <code>main()</code>, if I add <code>println!(&quot;{}&quot;, vector.len());</code>, the compiler actually says, <code>cannot move out of `vector` because it is borrowed rustc(E0505)</code>"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 6, "last_activity_date": 1430833703, "last_edit_date": 1430833703, "creation_date": 1430831911, "answer_id": 30054148, "question_id": 30053816, "link": "https://stackoverflow.com/questions/30053816/mutating-an-upvar-captured-by-value-in-a-fnmut-closure/30054148#30054148", "title": "Mutating an upvar captured by value in a FnMut closure", "body": "<p>The problem can be solved easily, in fact. Just add <code>mut</code> qualifier to <code>vector</code>:</p>\n\n<pre><code>fn main() {\n    let mut vector = vec![1, 2, 3];\n\n    let mut allow_once = move |i: &amp;i32| -&gt; bool {\n        if let Some(index) = vector.position_elem(i) {\n            vector.remove(index);\n            true\n        } else { false }\n    };\n\n    for e in &amp;[1, 2, 3, 1, 2, 3] {\n        let is_in = if allow_once(e) { \"is\" } else { \"is not\" };\n        println!(\"{} {} allowed\", e, is_in);\n    }\n}\n</code></pre>\n\n<p>(working code <a href=\"http://is.gd/cRpOIg\" rel=\"nofollow\">here</a>)</p>\n\n<p>It's just the same mutability rules as always - in order to mutate something, it has to have <code>mut</code> somewhere, either in its variable declaration or in its type (<code>&amp;mut</code>).</p>\n"}], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 888, "favorite_count": 0, "accepted_answer_id": 30054148, "answer_count": 1, "score": 3, "last_activity_date": 1430833703, "creation_date": 1430831008, "last_edit_date": 1430832647, "question_id": 30053816, "link": "https://stackoverflow.com/questions/30053816/mutating-an-upvar-captured-by-value-in-a-fnmut-closure", "title": "Mutating an upvar captured by value in a FnMut closure", "body": "<p>I am attempting to create a simple program, with a closure containing a collection that progressively empties itself:</p>\n\n<pre><code>fn main() {\n    let vector = vec![1, 2, 3];\n\n    let mut allow_once = move |i: &amp;i32| -&gt; bool {\n        if let Some(index) = vector.position_elem(i) {\n            vector.remove(index);\n            return true\n        }\n        false\n    };\n\n    for e in &amp;[1, 2, 3, 1, 2, 3] {\n        let is_in = if allow_once(e) { \"is\" } else { \"is not\" };\n        println!(\"{} {} allowed\", e, is_in);\n    }\n}\n</code></pre>\n\n<p>It seems kosher (to me), but rustc complains (on nightly):</p>\n\n<pre><code>&lt;anon&gt;:6:13: 6:19 error: cannot borrow captured outer variable in an `FnMut` closure as mutable\n&lt;anon&gt;:6             vector.remove(index);\n                     ^~~~~~\n</code></pre>\n\n<p>I expect that the issue might be one of desugaring. That is, while the implementation never violates the Aliasing XOR Mutation principle, maybe the desguaring is so that <code>rustc</code> does not realize it.</p>\n\n<p>Thus:</p>\n\n<ol>\n<li>Is this a temporary limitation/bug or is it intrinsic?</li>\n<li>How can I create a closure with a mutable environment, as efficiently as possible?</li>\n</ol>\n\n<p>Note: Capture by reference is not an option, I wish to be able to move the closure around.</p>\n"}, {"tags": ["rust", "rust-cargo"], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": false, "score": 1, "last_activity_date": 1430812991, "creation_date": 1430812991, "answer_id": 30047333, "question_id": 30047179, "link": "https://stackoverflow.com/questions/30047179/can-cargo-toml-have-cargo-tell-rustc-to-include-plugins/30047333#30047333", "title": "Can Cargo.toml have Cargo tell rustc to include plugins?", "body": "<p>No, you must specify the macro in the source code.</p>\n"}, {"comments": [{"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "edited": false, "score": 0, "creation_date": 1430815333, "post_id": 30048033, "comment_id": 48211170, "body": "Thank you. Perhaps I should have opened an issue myself, but I was unsure if not exposing it was a deliberate decision."}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 5, "last_activity_date": 1430815213, "creation_date": 1430815213, "answer_id": 30048033, "question_id": 30047179, "link": "https://stackoverflow.com/questions/30047179/can-cargo-toml-have-cargo-tell-rustc-to-include-plugins/30048033#30048033", "title": "Can Cargo.toml have Cargo tell rustc to include plugins?", "body": "<p>There's no way to do this with <code>cargo</code> (without editing source), but it's definitely something I'd like too. The use case I can imagine is that some users wish to outlaw certain patterns in all dependencies, e.g. maybe outlaw <code>unsafe</code> code that's not in a white list of crates, or even go further by requiring any <code>unsafe</code> is <a href=\"https://github.com/kmcallister/launch-code\" rel=\"noreferrer\">verified</a>.</p>\n\n<p>The compiler has partial support for this in the form of <code>rustc -Z extra-plugins=...</code>, but Cargo doesn't expose anything like it externally yet.</p>\n\n<p>I opened <a href=\"https://github.com/rust-lang/cargo/issues/1579\" rel=\"noreferrer\">#1579</a>.</p>\n"}], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 156, "favorite_count": 1, "accepted_answer_id": 30048033, "answer_count": 2, "score": 3, "last_activity_date": 1430815213, "creation_date": 1430812565, "question_id": 30047179, "link": "https://stackoverflow.com/questions/30047179/can-cargo-toml-have-cargo-tell-rustc-to-include-plugins", "title": "Can Cargo.toml have Cargo tell rustc to include plugins?", "body": "<p>Let's say I want to lint all my code by rust-clippy. For now, I'll have to write</p>\n\n<pre><code>#![feature(plugin)]\n#![plugin(clippy)]\n</code></pre>\n\n<p>in each of my sources. Can I somehow configure Cargo to have rustc use the plugin without needing to add it to my source file? If so, how?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 20407, "user_id": 1017941, "user_type": "registered", "accept_rate": 97, "profile_image": "https://i.stack.imgur.com/yocPw.jpg?s=128&g=1", "display_name": "Hauleth", "link": "https://stackoverflow.com/users/1017941/hauleth"}, "edited": false, "score": 1, "creation_date": 1430816046, "post_id": 30044066, "comment_id": 48211659, "body": "Most of <code>std::num</code> traits was moved to <a href=\"http://doc.rust-lang.org/num/num/index.html\" rel=\"nofollow noreferrer\"><code>num</code> crate</a>."}, {"owner": {"reputation": 10840, "user_id": 1198729, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/0a3069491bfded90cdf623341cadc1d1?s=128&d=identicon&r=PG", "display_name": "Manishearth", "link": "https://stackoverflow.com/users/1198729/manishearth"}, "reply_to_user": {"reputation": 20407, "user_id": 1017941, "user_type": "registered", "accept_rate": 97, "profile_image": "https://i.stack.imgur.com/yocPw.jpg?s=128&g=1", "display_name": "Hauleth", "link": "https://stackoverflow.com/users/1017941/hauleth"}, "edited": false, "score": 0, "creation_date": 1430816376, "post_id": 30044066, "comment_id": 48211882, "body": "Yes, but not that one."}, {"owner": {"reputation": 20407, "user_id": 1017941, "user_type": "registered", "accept_rate": 97, "profile_image": "https://i.stack.imgur.com/yocPw.jpg?s=128&g=1", "display_name": "Hauleth", "link": "https://stackoverflow.com/users/1017941/hauleth"}, "edited": false, "score": 2, "creation_date": 1430816591, "post_id": 30044066, "comment_id": 48212036, "body": "IIRC <code>Primitive</code> trait was just meta-trait for <code>Copy + Num + Bounded + NumCast + PartialOrd + Clone</code>."}, {"owner": {"reputation": 10840, "user_id": 1198729, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/0a3069491bfded90cdf623341cadc1d1?s=128&d=identicon&r=PG", "display_name": "Manishearth", "link": "https://stackoverflow.com/users/1198729/manishearth"}, "reply_to_user": {"reputation": 20407, "user_id": 1017941, "user_type": "registered", "accept_rate": 97, "profile_image": "https://i.stack.imgur.com/yocPw.jpg?s=128&g=1", "display_name": "Hauleth", "link": "https://stackoverflow.com/users/1017941/hauleth"}, "edited": false, "score": 1, "creation_date": 1430818263, "post_id": 30044066, "comment_id": 48213186, "body": "Exactly. You can write your own marker trait like that if you want. That&#39;s my point."}, {"owner": {"reputation": 485, "user_id": 5350761, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh6.googleusercontent.com/-0vaJdsJ7fXw/AAAAAAAAAAI/AAAAAAAAD9s/pdF45XCQLN4/photo.jpg?sz=128", "display_name": "Jackson Loper", "link": "https://stackoverflow.com/users/5350761/jackson-loper"}, "edited": false, "score": 0, "creation_date": 1445965769, "post_id": 30044066, "comment_id": 54542734, "body": "... but isn&#39;t that collection of traits actually the most common use case?  It would be nice to have a standard name for that.  Where&#39;s the harm?"}], "tags": [], "owner": {"reputation": 10840, "user_id": 1198729, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/0a3069491bfded90cdf623341cadc1d1?s=128&d=identicon&r=PG", "display_name": "Manishearth", "link": "https://stackoverflow.com/users/1198729/manishearth"}, "is_accepted": true, "score": 5, "last_activity_date": 1430798679, "creation_date": 1430798679, "answer_id": 30044066, "question_id": 30044026, "link": "https://stackoverflow.com/questions/30044026/what-happened-to-stdnumprimitive/30044066#30044066", "title": "What happened to std::num::Primitive?", "body": "<p>It <a href=\"https://github.com/rust-lang/rust/pull/24636\" rel=\"noreferrer\">was removed</a>, since it wasn't being used at the time.</p>\n\n<p>You can write your own marker trait of the form, though.</p>\n"}], "owner": {"reputation": 900, "user_id": 602721, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/be8ca2dd9f7a396f2f1e0cadcd378aa3?s=128&d=identicon&r=PG", "display_name": "tomsgd", "link": "https://stackoverflow.com/users/602721/tomsgd"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 790, "favorite_count": 0, "accepted_answer_id": 30044066, "answer_count": 1, "score": 3, "last_activity_date": 1430798679, "creation_date": 1430798351, "question_id": 30044026, "link": "https://stackoverflow.com/questions/30044026/what-happened-to-stdnumprimitive", "title": "What happened to std::num::Primitive?", "body": "<p>I found \n<a href=\"http://doc.rust-lang.org/0.12.0/std/num/trait.Primitive.html\" rel=\"nofollow\">Primitive</a> through Google but it appears to be from a pre-beta version and my compiler (beta 3) complains that it can't find it. Can anyone point me to where it has moved or if there is an equivalent? Web searching hasn't thrown up anything promising</p>\n"}, {"tags": ["generics", "rust"], "answers": [{"comments": [{"owner": {"reputation": 55, "user_id": 2363468, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f4a614797d952a41f59fa8dbd351176c?s=128&d=identicon&r=PG", "display_name": "Sheosi", "link": "https://stackoverflow.com/users/2363468/sheosi"}, "edited": false, "score": 0, "creation_date": 1430815805, "post_id": 30036988, "comment_id": 48211499, "body": "Hmm... I&#39;ve been able to use the struct just like I posted,however, I&#39;m using rust-nightly, maybe that&#39;s why I can do it that way?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1439601499, "last_edit_date": 1439601499, "creation_date": 1430763048, "answer_id": 30036988, "question_id": 30036900, "link": "https://stackoverflow.com/questions/30036900/embed-generics-inside-struct/30036988#30036988", "title": "Embed generics inside struct", "body": "<p>You can only use generics when defining the struct, but you can use <em>trait bounds</em> on those generics to restrict it to specific types. Here, I've used the <code>where</code> clause:</p>\n\n<pre><code>trait Vertex {}\n\nstruct Mesh&lt;R&gt; {\n    r: R,\n}\n\nstruct Cube&lt;V, R&gt;\n    where V: Vertex,\n{\n    vertex_data: [V; 24],\n    mesh: Mesh&lt;R&gt;,\n}\n\nfn main() {}\n</code></pre>\n\n<p>You will also want to use those bounds on any method implementations:</p>\n\n<pre><code>impl&lt;V, R&gt; Cube&lt;V, R&gt;\n    where V: Vertex,\n{\n    fn new(vertex: V, mesh: Mesh&lt;R&gt;) -&gt; Cube&lt;V, R&gt; { ... }\n}\n</code></pre>\n\n<p>In fact, you frequently will only see the <code>where</code> clause on the implementation, not the struct. This is because you normally only access the struct through the methods, and the struct is opaque to the end user. If you have public fields it may be worth leaving the bound in both places though.</p>\n"}], "owner": {"reputation": 55, "user_id": 2363468, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f4a614797d952a41f59fa8dbd351176c?s=128&d=identicon&r=PG", "display_name": "Sheosi", "link": "https://stackoverflow.com/users/2363468/sheosi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 730, "favorite_count": 0, "accepted_answer_id": 30036988, "answer_count": 1, "score": 4, "last_activity_date": 1439601499, "creation_date": 1430762799, "last_edit_date": 1430768808, "question_id": 30036900, "link": "https://stackoverflow.com/questions/30036900/embed-generics-inside-struct", "title": "Embed generics inside struct", "body": "<p>I find difficulties when using Rust traits, so for example which is the correct way to do this?</p>\n\n<pre><code>pub struct Cube&lt;R&gt;{\n    pub vertex_data: [Vertex;24],\n    pub asMesh: gfx::Mesh&lt;R&gt;\n}\n</code></pre>\n"}, {"tags": ["rust", "mutex"], "answers": [{"tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": false, "score": 5, "last_activity_date": 1430733933, "last_edit_date": 1430733933, "creation_date": 1430733607, "answer_id": 30027334, "question_id": 30026921, "link": "https://stackoverflow.com/questions/30026921/printing-the-arc-and-mutex-types/30027334#30027334", "title": "Printing the Arc and Mutex types", "body": "<p>To work with a Mutex value you have to lock the Mutex, just like you do in the spawned threads. (<a href=\"http://is.gd/JHoz04\" rel=\"nofollow\">playpen</a>):</p>\n\n<pre><code>let data = data.lock().unwrap();\nprintln!(\"{:?}\", String::from_utf8(data.clone()).unwrap());\n</code></pre>\n\n<p>Note that <a href=\"http://doc.rust-lang.org/collections/string/struct.String.html#method.from_utf8\" rel=\"nofollow\">String::from_utf8</a> consumes the vector (in order to wrap it in a String without extra allocations), which is obvious from it taking a value <code>vec: Vec&lt;u8&gt;</code> and not a reference. Since we aren't ready to relinquish our hold on <code>data</code> we have to <code>clone</code> it when using this method.</p>\n\n<p>A cheaper alternative would be to use the slice-based version of <a href=\"http://doc.rust-lang.org/collections/str/fn.from_utf8.html\" rel=\"nofollow\">from_utf8</a> (<a href=\"http://is.gd/Sdj4Ib\" rel=\"nofollow\">playpen</a>):</p>\n\n<pre><code>let data = data.lock().unwrap();\nprintln!(\"{:?}\", from_utf8(&amp;data).unwrap());\n</code></pre>\n"}], "owner": {"reputation": 13, "user_id": 3559406, "user_type": "registered", "profile_image": "https://graph.facebook.com/1491414437/picture?type=large", "display_name": "user3559406", "link": "https://stackoverflow.com/users/3559406/user3559406"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1016, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1430744798, "creation_date": 1430732297, "last_edit_date": 1430744798, "question_id": 30026921, "link": "https://stackoverflow.com/questions/30026921/printing-the-arc-and-mutex-types", "title": "Printing the Arc and Mutex types", "body": "<p>How can I print the values of a <code>Vec</code> that is encapsulated by a <code>Mutex</code> and <code>Arc</code>? I'm really new to Rust, so I'm not sure if I am phrasing this well.</p>\n\n<p>This is the code I have, loosely based on the documentation.</p>\n\n<pre><code>use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let data = Arc::new(Mutex::new(vec![104, 101, 108, 108, 111]));\n\n    for i in 0..2 {\n        let data = data.clone();\n        thread::spawn(move || {\n            let mut data = data.lock().unwrap();\n            data[i] += 1;\n        });\n    }\n\n    println!(\"{:?}\", String::from_utf8(data).unwrap());\n    thread::sleep_ms(50);\n}\n</code></pre>\n\n<p>The error that the compiler gives me: </p>\n\n<blockquote>\n  <p>$ rustc datarace_fixed.rs\n  datarace_fixed.rs:14:37: 14:41 error: mismatched types:\n   expected <code>collections::vec::Vec&lt;u8&gt;</code>,\n      found <code>alloc::arc::Arc&lt;std::sync::mutex::Mutex&lt;collections::vec::Vec&lt;_&gt;&gt;&gt;</code>\n  (expected struct <code>collections::vec::Vec</code>,\n      found struct <code>alloc::arc::Arc</code>) [E0308]\n  datarace_fixed.rs:14    println!(\"{:?}\", String::from_utf8(data).unwrap());</p>\n</blockquote>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 107, "last_activity_date": 1430732477, "creation_date": 1430732477, "answer_id": 30026986, "question_id": 30026893, "link": "https://stackoverflow.com/questions/30026893/using-map-with-vectors/30026986#30026986", "title": "Using map with Vectors", "body": "<p>Rust likes to be more general than that; mapping is done over iterators, rather than over solely vectors or slices.</p>\n\n<p>A couple of demonstrations:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let u = vec![1, 2, 3];\nlet v: Vec&lt;_&gt; = u.iter().map(f).collect();\n</code></pre>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let u = vec![1, 2, 3];\nlet v = u.iter().map(|&amp;x| x + 1).collect::&lt;Vec&lt;_&gt;&gt;();\n</code></pre>\n\n<p><a href=\"http://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect\"><code>.collect()</code></a> is probably the most magic part of it, and allows you to collect all the elements of the iterator into a large variety of different types, as shown by the <a href=\"http://doc.rust-lang.org/std/iter/trait.FromIterator.html#implementors\">implementors of <code>FromIterator</code></a>. For example, an iterator of <code>T</code>s can be collected to <code>Vec&lt;T&gt;</code>, of <code>char</code>s can be collected to a <code>String</code>, of <code>(K, V)</code> pairs to a <code>HashMap&lt;K, V&gt;</code>, and so forth.</p>\n\n<p>This way of working with iterators also means that you often won\u2019t even need to create intermediate vectors where in other languages or with other techniques you would; this is more efficient and typically just as natural.</p>\n"}, {"comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 3, "creation_date": 1430753874, "post_id": 30031088, "comment_id": 48184313, "body": "If you don&#39;t need map_in_place&#39;s magical type change, you can just use the mutable iterator.  <code>for elt in &amp;mut v { *elt = *elt + 1; }</code>"}, {"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 2, "creation_date": 1430755776, "post_id": 30031088, "comment_id": 48185523, "body": "Note that it also require the input and output types to be of the same size, which is certainly not always the case."}, {"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 3, "creation_date": 1458395193, "post_id": 30031088, "comment_id": 59847729, "body": "Note that <code>map_in_place</code> has been deprecated since 1.3. I guess we use <code>.into_iter().map(\u2026).collect()</code> now?"}, {"owner": {"reputation": 3152, "user_id": 1525759, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/LHtNL.jpg?s=128&g=1", "display_name": "Addison", "link": "https://stackoverflow.com/users/1525759/addison"}, "edited": false, "score": 2, "creation_date": 1564597657, "post_id": 30031088, "comment_id": 101087867, "body": "Anyone know why <code>Vec::map_in_place</code> was deprecated? The docs say &quot;unclear that the API is strong enough and did not proven itself&quot; but I don&#39;t really know what that&#39;s supposed to mean..."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 17, "last_activity_date": 1476277625, "last_edit_date": 1495541436, "creation_date": 1430745153, "answer_id": 30031088, "question_id": 30026893, "link": "https://stackoverflow.com/questions/30026893/using-map-with-vectors/30031088#30031088", "title": "Using map with Vectors", "body": "<p>As pointed out <a href=\"https://stackoverflow.com/questions/30026893/using-map-with-vectors/30031088?noredirect=1#comment48184313_30031088\">by bluss</a>, you can also use the mutable iterator to mutate the value in place, without changing the type:</p>\n\n<pre><code>let mut nums = nums;\nfor num in &amp;mut nums { *num += 1 }\nprintln!(\"{:p} - {:?}\", &amp;nums, nums);\n</code></pre>\n\n<hr>\n\n<blockquote>\n  <p>The function <code>Vec::map_in_place</code> was deprecated in Rust 1.3 and is no longer present in Rust 1.4.</p>\n</blockquote>\n\n<p>Chris Morgan's answer is the best solution 99% of the time. However, there is a specialized function called <a href=\"https://doc.rust-lang.org/1.3.0/collections/vec/struct.Vec.html#method.map_in_place\" rel=\"noreferrer\"><code>Vec::map_in_place</code></a>. This has the benefit of not requiring any additional memory allocations, but it requires that the input and output type are the same size (<a href=\"https://stackoverflow.com/questions/30026893/using-map-with-vectors/30031088?noredirect=1#comment48185523_30031088\">thanks Levans</a>) and is currently unstable:</p>\n\n<pre><code>fn map_in_place&lt;U, F&gt;(self, f: F) -&gt; Vec&lt;U&gt; \n    where F: FnMut(T) -&gt; U\n</code></pre>\n\n<p>An example:</p>\n\n<pre><code>#![feature(collections)]\n\nfn main() {\n    let nums = vec![1,2,3];\n    println!(\"{:p} - {:?}\", &amp;nums, nums);\n\n    let nums = nums.map_in_place(|v| v + 1);\n    println!(\"{:p} - {:?}\", &amp;nums, nums);\n}\n</code></pre>\n"}], "owner": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 45331, "favorite_count": 12, "accepted_answer_id": 30026986, "answer_count": 2, "score": 74, "last_activity_date": 1476283387, "creation_date": 1430732208, "last_edit_date": 1476283387, "question_id": 30026893, "link": "https://stackoverflow.com/questions/30026893/using-map-with-vectors", "title": "Using map with Vectors", "body": "<p>Although vectors are best suited for procedural programming, I would like to use a <code>map</code> function on them. The following snippet works:</p>\n\n<pre><code>fn map&lt;A, B&gt;(u: &amp;Vec&lt;A&gt;, f: &amp;Fn(&amp;A) -&gt; B) -&gt; Vec&lt;B&gt; {\n    let mut res: Vec&lt;B&gt; = Vec::with_capacity(u.len());\n    for x in u.iter() {\n        res.push(f(x));\n    }\n    res\n}\n\nfn f(x: &amp;i32) -&gt; i32 {\n    *x + 1\n}\n\nfn main() {\n    let u = vec![1, 2, 3];\n    let v = map(&amp;u, &amp;f);\n    println!(\"{} {} {}\", v[0], v[1], v[2]);\n}\n</code></pre>\n\n<p>Why isn't there any such function in the standard library? (and also in <code>std::collections::LinkedList</code>). Is there another way to deal with it?</p>\n"}, {"tags": ["tcp", "rust"], "comments": [{"owner": {"reputation": 288867, "user_id": 207421, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=128&d=identicon&r=PG", "display_name": "user207421", "link": "https://stackoverflow.com/users/207421/user207421"}, "edited": false, "score": 2, "creation_date": 1430709727, "post_id": 30022084, "comment_id": 48161485, "body": "Not forever. It should timeout after about a minute."}], "answers": [{"comments": [{"owner": {"reputation": 654, "user_id": 3458484, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Sl4jg.png?s=128&g=1", "display_name": "Aiyion.Prime", "link": "https://stackoverflow.com/users/3458484/aiyion-prime"}, "edited": false, "score": 0, "creation_date": 1598579115, "post_id": 30022262, "comment_id": 112511694, "body": "You might want to fix the answer, as googlers might read this first.  See: <a href=\"https://stackoverflow.com/a/63626320/3458484\">stackoverflow.com/a/63626320/3458484</a>"}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 1, "last_activity_date": 1430710839, "creation_date": 1430710839, "answer_id": 30022262, "question_id": 30022084, "link": "https://stackoverflow.com/questions/30022084/how-do-i-set-connect-timeout-on-tcpstream/30022262#30022262", "title": "How do I set connect timeout on TcpStream", "body": "<p>It is not at present possible to alter the timeout on making a TCP connection. The network stacks will have their own default settings, which may vary from OS to OS; I believe that one minute is a typical timeout.</p>\n"}, {"tags": [], "owner": {"reputation": 994, "user_id": 2754323, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/1258c3a2e37afb9c32b54b620f85ce92?s=128&d=identicon&r=PG&f=1", "display_name": "Yoha&#239;-Eliel Berreby", "link": "https://stackoverflow.com/users/2754323/yoha%c3%af-eliel-berreby"}, "is_accepted": false, "score": 2, "last_activity_date": 1442573058, "creation_date": 1442573058, "answer_id": 32650047, "question_id": 30022084, "link": "https://stackoverflow.com/questions/30022084/how-do-i-set-connect-timeout-on-tcpstream/32650047#32650047", "title": "How do I set connect timeout on TcpStream", "body": "<p>There is no easy, standard way to do this, so I did it by porting <a href=\"https://stackoverflow.com/a/2597774/2754323\">this answer</a> to Rust using the <a href=\"https://github.com/carllerche/nix-rust\" rel=\"nofollow\">nix crate</a>, with a minor change: setting the socket back to blocking once the connection has been established, so that it can be used with Rust's std I/O, and of course wrapping it back in a <code>std::net::TcpStream</code>.</p>\n\n<p>Here is the repo: <a href=\"https://github.com/filsmick/rust-tcp-connection-timeout\" rel=\"nofollow\">https://github.com/filsmick/rust-tcp-connection-timeout</a></p>\n\n<p>From src/lib.rs:</p>\n\n<pre><code>pub fn tcp_connect_with_timeout(socket_addr: std::net::SocketAddr, timeout: Duration) -&gt; Result&lt;TcpStream, ConnectionError&gt; {\n  // Create a socket file descriptor.\n  let socket_fd = try!(nix::sys::socket::socket(\n    nix::sys::socket::AddressFamily::Inet,\n    nix::sys::socket::SockType::Stream,\n    nix::sys::socket::SockFlag::empty()\n  ));\n\n  // Set the socket to non-blocking mode so we can `select()` on it.\n  try!(nix::fcntl::fcntl(\n    socket_fd,\n    nix::fcntl::FcntlArg::F_SETFL(nix::fcntl::O_NONBLOCK)\n  ));\n\n  let connection_result = nix::sys::socket::connect(\n    socket_fd,\n    &amp;(nix::sys::socket::SockAddr::Inet(nix::sys::socket::InetAddr::from_std(&amp;socket_addr)))\n  );\n\n  match connection_result {\n    Ok(_) =&gt; (),\n    Err(e) =&gt; {\n      match e {\n        nix::Error::Sys(errno) =&gt; {\n          match errno {\n            nix::errno::Errno::EINPROGRESS =&gt; (), // socket is non-blocking so an EINPROGRESS is to be expected\n            _ =&gt; return Err(ConnectionError::from(e))\n          }\n        }\n        nix::Error::InvalidPath =&gt; unreachable!() //\n      }\n    }\n  }\n\n  let mut timeout_timeval = nix::sys::time::TimeVal {\n    tv_sec: timeout.as_secs() as i64,\n    tv_usec: timeout.subsec_nanos() as i32\n  };\n\n  // Create a new fd_set monitoring our socket file descriptor.\n  let mut fdset = nix::sys::select::FdSet::new();\n  fdset.insert(socket_fd);\n\n  // `select()` on it, will return when the connection succeeds or times out.\n  let select_res = try!(nix::sys::select::select(\n    socket_fd + 1,\n    None,\n    Some(&amp;mut fdset),\n    None,\n    &amp;mut timeout_timeval\n  ));\n\n  // This it what fails if `addr` is unreachable.\n  if select_res != 1 {\n    println!(\"select return value: {}\", select_res);\n    return Err(ConnectionError::SelectError);\n  }\n\n  // Make sure the socket encountered no error.\n  let socket_error_code = try!(nix::sys::socket::getsockopt(\n    socket_fd,\n    nix::sys::socket::sockopt::SocketError\n  ));\n\n  if socket_error_code != 0 {\n    return Err(ConnectionError::SocketError(socket_error_code));\n  }\n\n  // Set the socket back to blocking mode so it can be used with std's I/O facilities.\n  try!(nix::fcntl::fcntl(\n    socket_fd,\n    nix::fcntl::FcntlArg::F_SETFL(nix::fcntl::OFlag::empty())\n  ));\n\n  // Wrap it in a TcpStream and return that stream.\n  Ok(\n    unsafe { TcpStream::from_raw_fd(socket_fd) }\n  )\n}\n</code></pre>\n\n<p><code>ConnectionError</code> is defined in <a href=\"https://github.com/filsmick/rust-tcp-connection-timeout/blob/master/src/error.rs\" rel=\"nofollow\"><code>error.rs</code></a>, but you can ignore it if you wish by unwrapping instead of using <code>try!</code>.</p>\n\n<p>There's a catch, though: <code>select</code> isn't yet implemented in the main nix repo at the time of writing but there is a <a href=\"https://github.com/carllerche/nix-rust/pull/188\" rel=\"nofollow\">pending Pull Request</a>, so you'll have to depend on a fork in the meantime (it shouldn't take long to merge, though):</p>\n\n<pre><code>[dependencies]\nnix = { git = \"https://github.com/utkarshkukreti/nix-rust.git\", branch = \"add-sys-select\" }\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 378, "user_id": 10146018, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/NdcRa.png?s=128&g=1", "display_name": "noone", "link": "https://stackoverflow.com/users/10146018/noone"}, "is_accepted": false, "score": 0, "last_activity_date": 1597742273, "creation_date": 1597742273, "answer_id": 63465533, "question_id": 30022084, "link": "https://stackoverflow.com/questions/30022084/how-do-i-set-connect-timeout-on-tcpstream/63465533#63465533", "title": "How do I set connect timeout on TcpStream", "body": "<p>If you are using async rust with tokio then you can use this:-</p>\n<pre><code>const CONNECTION_TIME: u64 = 100;\n\n...\n\nlet (socket, _response) = match tokio::time::timeout(\n     Duration::from_secs(CONNECTION_TIME),\n     tokio::net::TcpStream::connect(&quot;127.0.0.1:8080&quot;)\n )\n .await\n {\n     Ok(ok) =&gt; ok,\n     Err(e) =&gt; panic!(format!(&quot;timeout while connecting to server : {}&quot;, e)),\n }\n .expect(&quot;Error while connecting to server&quot;)\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 654, "user_id": 3458484, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Sl4jg.png?s=128&g=1", "display_name": "Aiyion.Prime", "link": "https://stackoverflow.com/users/3458484/aiyion-prime"}, "is_accepted": false, "score": 3, "last_activity_date": 1598579026, "creation_date": 1598579026, "answer_id": 63626320, "question_id": 30022084, "link": "https://stackoverflow.com/questions/30022084/how-do-i-set-connect-timeout-on-tcpstream/63626320#63626320", "title": "How do I set connect timeout on TcpStream", "body": "<p>greetings from 2020.</p>\n<p>In the meantime the answer changed,\nit's no longer &quot;can't be done easily&quot; but is:</p>\n<pre><code>TcpStream::connect_timeout()\n</code></pre>\n<p><a href=\"https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.connect_timeout\" rel=\"nofollow noreferrer\">https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.connect_timeout</a></p>\n"}], "owner": {"reputation": 3828, "user_id": 956680, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/20a0fb51ca249bf1896bf3fec079086f?s=128&d=identicon&r=PG", "display_name": "spicavigo", "link": "https://stackoverflow.com/users/956680/spicavigo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2018, "favorite_count": 0, "accepted_answer_id": 30022262, "answer_count": 4, "score": 4, "last_activity_date": 1598579026, "creation_date": 1430709465, "question_id": 30022084, "link": "https://stackoverflow.com/questions/30022084/how-do-i-set-connect-timeout-on-tcpstream", "title": "How do I set connect timeout on TcpStream", "body": "<p>I am trying to connect to a server which is <strong>unreachable</strong> using the following code:</p>\n\n<pre><code>println!(\"Connecting\");\nTcpStream::connect(s).unwrap();\nprintln!(\"Connected\");\n</code></pre>\n\n<p>When I run the code, it gets stuck on second line.</p>\n\n<p>Output:</p>\n\n<pre><code>Connecting\n</code></pre>\n"}, {"tags": ["generics", "rust", "idioms"], "answers": [{"comments": [{"owner": {"reputation": 153, "user_id": 4860094, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-q3pM6k7fKs8/AAAAAAAAAAI/AAAAAAAAIKw/8OPkyn4pACs/photo.jpg?sz=128", "display_name": "Mikhail Borisov", "link": "https://stackoverflow.com/users/4860094/mikhail-borisov"}, "edited": false, "score": 1, "creation_date": 1430685920, "post_id": 30019078, "comment_id": 48155741, "body": "Thank you! What I didn&#39;t realize was that it&#39;s possible to have multiple &#39;impl&#39; clauses for different parameterizations."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1430685206, "creation_date": 1430685206, "answer_id": 30019078, "question_id": 30018978, "link": "https://stackoverflow.com/questions/30018978/explicit-type-annotation-for-generic-constructor-of-a-generic-type/30019078#30019078", "title": "Explicit type annotation for generic constructor of a generic type", "body": "<p>As I understand it, your original code is parameterized on <code>T</code>, but you have methods that want to specify the parameter. The trick is to <em>not have a generic</em> for these cases. Instead, try creating specialized implementations for each interesting type:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>// this is just an example. suppress unrelated warnings\n#![allow(dead_code, unused_variables)]\n\nstruct Foobar&lt;T&gt; {\n    origin: T,\n}\n\ntrait Orange {}\n\nstruct Grapefruit;\n\nimpl Orange for Grapefruit {}\n\nimpl Foobar&lt;()&gt; {\n    fn from_nowhere() -&gt; Foobar&lt;()&gt; {\n        Foobar { origin: () }\n    }\n}\n\nimpl&lt;'a, F&gt; Foobar&lt;&amp;'a mut F&gt;\n    where F: Orange\n{\n    fn from_orange(orange: &amp;'a mut F) -&gt; Foobar&lt;&amp;'a mut F&gt; {\n        Foobar { origin: orange }\n    }\n}\n\nimpl&lt;F&gt; Foobar&lt;F&gt;\n    where F: FnMut(u64) -&gt; u64\n{\n    fn from_callback(callback: F) -&gt; Foobar&lt;F&gt; {\n        Foobar { origin: callback }\n    }\n}\n\nfn main() {\n    let mut fruit = Grapefruit;\n\n    // What I actually wanted to do\n    let a1 = Foobar::from_nowhere();\n    let b1 = Foobar::from_orange(&amp;mut fruit);\n    let c1 = Foobar::from_callback(|x| x*x);\n}\n</code></pre>\n"}], "owner": {"reputation": 153, "user_id": 4860094, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-q3pM6k7fKs8/AAAAAAAAAAI/AAAAAAAAIKw/8OPkyn4pACs/photo.jpg?sz=128", "display_name": "Mikhail Borisov", "link": "https://stackoverflow.com/users/4860094/mikhail-borisov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3023, "favorite_count": 0, "accepted_answer_id": 30019078, "answer_count": 1, "score": 5, "last_activity_date": 1430685206, "creation_date": 1430684627, "last_edit_date": 1430684796, "question_id": 30018978, "link": "https://stackoverflow.com/questions/30018978/explicit-type-annotation-for-generic-constructor-of-a-generic-type", "title": "Explicit type annotation for generic constructor of a generic type", "body": "<p>I'm writing a Rust binding for a C library. It implements an entity that can be constructed from different source entities, possibly saving some references internally. I want the Rust type to enforce a safe ownership policy, thus the wrapper struct is generic, parameterized by the type of the stored reference.</p>\n\n<pre><code>struct Foobar&lt;T&gt; {\n    origin: T,\n}\n</code></pre>\n\n<p>Then I implement some constructors for my <code>Foobar</code> type.</p>\n\n<pre><code>impl&lt;T&gt; Foobar&lt;T&gt; {\n    fn from_nowhere() -&gt; Foobar&lt;()&gt; {\n        Foobar { origin: () }\n    }\n\n    fn from_orange&lt;F&gt;(orange: &amp;mut F) -&gt; Foobar&lt;&amp;mut F&gt;\n        where F: Orange\n    {\n        Foobar { origin: orange }\n    }\n\n    fn from_callback&lt;F&gt;(callback: F) -&gt; Foobar&lt;F&gt;\n        where F: FnMut(u64) -&gt; u64\n    {\n        Foobar { origin: callback }\n    }\n}\n</code></pre>\n\n<p>And here comes the problem: both the struct and the constructor are independently parameterized. While the constructor type parameter can be inferred from its arguments, the struct type parameter is not used in the constructor and cannot be inferred. Thus, the naive way to call a constructor</p>\n\n<pre><code>let a = Foobar::from_nowhere();\nlet b = Foobar::from_orange(&amp;mut fruit);\nlet c = Foobar::from_callback(|x| x*x);\n</code></pre>\n\n<p>confuses rustc:</p>\n\n<pre><code>    rustgen.rs:43:13: 43:33 error: unable to infer enough type information about `_`; type annotations required [E0282]\n    rustgen.rs:43     let a = Foobar::from_nowhere();\n</code></pre>\n\n<p>It can be fixed by providing some arbitrary type parameter:</p>\n\n<pre><code>let a = Foobar::&lt;()&gt;::from_nowhere();\nlet b = Foobar::&lt;()&gt;::from_orange(&amp;mut fruit);\nlet c = Foobar::&lt;()&gt;::from_callback(|x| x*x);\n</code></pre>\n\n<p>...which is all sorts of ugly. Another way to solve the problem would be to turn constructors into free functions, though it would be (kinda) non-idiomatic.</p>\n\n<p>The question is, am I missing something? The design seems to be flawed in some way. What would be the proper way to design this type to get away with only one level of generics?</p>\n\n<hr>\n\n<p><a href=\"http://is.gd/KeC7T2\" rel=\"noreferrer\">Minimal reproducible example on Rust playpen</a></p>\n\n<p>For reference, my compiler version is:</p>\n\n<pre><code>$ rustc --version\nrustc 1.1.0-dev (built 2015-04-26)\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 653, "user_id": 916546, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/40be8cc1b147ac208e3b4ad62a657db6?s=128&d=identicon&r=PG", "display_name": "smarr", "link": "https://stackoverflow.com/users/916546/smarr"}, "edited": false, "score": 0, "creation_date": 1431034340, "post_id": 30013230, "comment_id": 48334955, "body": "pub fn init() -&gt; Receiver&lt;ControlKeys&gt; {     let (tx, rx) = channel::&lt;ControlKeys&gt;();     thread::spawn(move|| {         while true {             tx.send(read_stdin());         }     });     rx }  pub fn get(rx: &amp;Receiver&lt;ControlKeys&gt;, old: ControlKeys) -&gt; ControlKeys {     match rx.try_recv() {         Ok(key) =&gt; key,         Err(_)  =&gt; old     } }  fn read_stdin() -&gt; ControlKeys {     let mut reader = stdin();     let mut buf = &amp;mut [0u8; 10];      match reader.read(buf) {         Err(why) =&gt; panic!(...),         Ok(size) =&gt; {             // read buf             return res;         }     } }"}], "tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": true, "score": 6, "last_activity_date": 1430669444, "last_edit_date": 1430669444, "creation_date": 1430652084, "answer_id": 30013230, "question_id": 30012995, "link": "https://stackoverflow.com/questions/30012995/how-can-i-read-non-blocking-from-stdin/30013230#30013230", "title": "How can I read non-blocking from stdin?", "body": "<p>Most operating systems default to work with the standard input and output in a blocking way. No wonder then that the Rust library follows in stead.</p>\n\n<p>To read from a blocking stream in a non-blocking way you might create a separate thread, so that the extra thread blocks instead of the main one. Checking whether a blocking file descriptor produced some input is similar: spawn a thread, make it read the data, check whether it produced any data so far.</p>\n\n<p><a href=\"https://gist.github.com/ArtemGr/db40ae04b431a95f2b78\" rel=\"nofollow\">Here's</a> a piece of code that I use with a similar goal of processing a pipe output interactively and that can hopefully serve as an example. It sends the data over a <a href=\"http://rustbyexample.com/std_misc/channels.html\" rel=\"nofollow\">channel</a>, which supports the <a href=\"http://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.try_recv\" rel=\"nofollow\">try_recv</a> method - allowing you to check whether the data is available or not.</p>\n\n<p><a href=\"http://www.reddit.com/r/rust/comments/2nka2k/interactive_pipe_reading/cmfbe5w\" rel=\"nofollow\">Someone has told me</a> that <a href=\"https://github.com/carllerche/mio\" rel=\"nofollow\">mio</a> might be used to read from a pipe in a non-blocking way, so you might want to check it out too. I suspect that passing the stdin file descriptor (0) to <a href=\"http://carllerche.github.io/mio/mio/struct.PipeReader.html\" rel=\"nofollow\">PipeReader::from_fd</a> should just work.</p>\n"}, {"tags": [], "owner": {"reputation": 126, "user_id": 3281907, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/167b5d70056ea34fa24058a251d63964?s=128&d=identicon&r=PG", "display_name": "kbknapp", "link": "https://stackoverflow.com/users/3281907/kbknapp"}, "is_accepted": false, "score": 1, "last_activity_date": 1430709978, "creation_date": 1430709978, "answer_id": 30022157, "question_id": 30012995, "link": "https://stackoverflow.com/questions/30012995/how-can-i-read-non-blocking-from-stdin/30022157#30022157", "title": "How can I read non-blocking from stdin?", "body": "<p>You could also potentially look at using <a href=\"https://github.com/jeaye/ncurses-rs\" rel=\"nofollow\">ncurses</a> (also on <a href=\"https://crates.io/crates/ncurses\" rel=\"nofollow\">crates.io</a>) which would allow you read in raw mode. There are a few examples in the Github repository which show how to do this.</p>\n"}, {"comments": [{"owner": {"reputation": 1119, "user_id": 11714860, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/e6Xo3.png?s=128&g=1", "display_name": "Sapphire_Brick", "link": "https://stackoverflow.com/users/11714860/sapphire-brick"}, "edited": false, "score": 0, "creation_date": 1610734047, "post_id": 55201400, "comment_id": 116234798, "body": "Brilliant! Multi-threading is Rust&#39;s forte."}], "tags": [], "owner": {"reputation": 71, "user_id": 1356670, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/bcd1b6937ec5aee479456c0218378e97?s=128&d=identicon&r=PG", "display_name": "masonforest", "link": "https://stackoverflow.com/users/1356670/masonforest"}, "is_accepted": false, "score": 6, "last_activity_date": 1552769697, "creation_date": 1552769697, "answer_id": 55201400, "question_id": 30012995, "link": "https://stackoverflow.com/questions/30012995/how-can-i-read-non-blocking-from-stdin/55201400#55201400", "title": "How can I read non-blocking from stdin?", "body": "<p>Converting OP's comment into an answer:</p>\n\n<p>You can spawn a thread and send data over a <a href=\"https://doc.rust-lang.org/stable/rust-by-example/std_misc/channels.html\" rel=\"noreferrer\">channel</a>. You can then poll that channel in the main thread using <a href=\"https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.try_recv\" rel=\"noreferrer\">try_recv</a>.</p>\n\n<pre><code>use std::io;\nuse std::sync::mpsc;\nuse std::sync::mpsc::Receiver;\nuse std::sync::mpsc::TryRecvError;\nuse std::{thread, time};\n\nfn main() {\n    let stdin_channel = spawn_stdin_channel();\n    loop {\n        match stdin_channel.try_recv() {\n            Ok(key) =&gt; println!(\"Received: {}\", key),\n            Err(TryRecvError::Empty) =&gt; println!(\"Channel empty\"),\n            Err(TryRecvError::Disconnected) =&gt; panic!(\"Channel disconnected\"),\n        }\n        sleep(1000);\n    }\n}\n\nfn spawn_stdin_channel() -&gt; Receiver&lt;String&gt; {\n    let (tx, rx) = mpsc::channel::&lt;String&gt;();\n    thread::spawn(move || loop {\n        let mut buffer = String::new();\n        io::stdin().read_line(&amp;mut buffer).unwrap();\n        tx.send(buffer).unwrap();\n    });\n    rx\n}\n\nfn sleep(millis: u64) {\n    let duration = time::Duration::from_millis(millis);\n    thread::sleep(duration);\n}\n</code></pre>\n"}], "owner": {"reputation": 653, "user_id": 916546, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/40be8cc1b147ac208e3b4ad62a657db6?s=128&d=identicon&r=PG", "display_name": "smarr", "link": "https://stackoverflow.com/users/916546/smarr"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 7824, "favorite_count": 3, "accepted_answer_id": 30013230, "answer_count": 3, "score": 14, "last_activity_date": 1552769697, "creation_date": 1430650564, "last_edit_date": 1430657940, "question_id": 30012995, "link": "https://stackoverflow.com/questions/30012995/how-can-i-read-non-blocking-from-stdin", "title": "How can I read non-blocking from stdin?", "body": "<p>Is there a way to check whether data is available on <code>stdin</code> in Rust, or to do a read that returns immediately with the currently available data?</p>\n\n<p>My goal is to be able to read the input produced for instance by cursor keys in a shell that is setup to return all read data immediately. For instance with an equivalent to: <code>stty -echo -echok -icanon min 1 time 0</code>.</p>\n\n<p>I suppose one solution would be to use ncurses or similar libraries, but I would like to avoid any kind of large dependencies.</p>\n\n<p>So far, I got only blocking input, which is not what I want:</p>\n\n<pre><code>let mut reader = stdin();\nlet mut s = String::new();\n\nmatch reader.read_to_string(&amp;mut s) {...} // this blocks :(\n</code></pre>\n"}, {"tags": ["c++", "rust", "smart-pointers"], "comments": [{"owner": {"reputation": 21663, "user_id": 9305398, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cqJvE.png?s=128&g=1", "display_name": "Acorn", "link": "https://stackoverflow.com/users/9305398/acorn"}, "edited": false, "score": 0, "creation_date": 1600773561, "post_id": 30011603, "comment_id": 113187486, "body": "This question conflates ownership/RAII and borrowing/references/pointers in both C++ and Rust."}, {"owner": {"reputation": 17424, "user_id": 278842, "user_type": "registered", "accept_rate": 51, "profile_image": "https://www.gravatar.com/avatar/df6877d3f05e542ca5975b4670600f2e?s=128&d=identicon&r=PG", "display_name": "Christopher Oezbek", "link": "https://stackoverflow.com/users/278842/christopher-oezbek"}, "reply_to_user": {"reputation": 21663, "user_id": 9305398, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cqJvE.png?s=128&g=1", "display_name": "Acorn", "link": "https://stackoverflow.com/users/9305398/acorn"}, "edited": false, "score": 0, "creation_date": 1600801703, "post_id": 30011603, "comment_id": 113201380, "body": "@Acorn care to elaborate?"}], "answers": [{"comments": [{"owner": {"reputation": 17424, "user_id": 278842, "user_type": "registered", "accept_rate": 51, "profile_image": "https://www.gravatar.com/avatar/df6877d3f05e542ca5975b4670600f2e?s=128&d=identicon&r=PG", "display_name": "Christopher Oezbek", "link": "https://stackoverflow.com/users/278842/christopher-oezbek"}, "edited": false, "score": 2, "creation_date": 1430676280, "post_id": 30013891, "comment_id": 48152202, "body": "Thanks! Some points: (1) Borrow counting is easy - we can replace all occurrence of shared_ptr with owner_ptr or borrowed_ptr, (2) Murphy is the enemy, not Machiavelli, thus it only needs to be hard to do the wrong thing. (3) unique_ptr is not a good place to start (IMHO), because it has no facilities to deal with observers (see edit). (4) We are using convention to guard against circular shared_ptr dependency but it is too easy to Shoot Yourself in the Foot (TM). (5) Using Rust is out of the question ATM, because it is considerably less powerful than C++ (while we appreciate the new ideas!)."}, {"owner": {"reputation": 7287, "user_id": 963864, "user_type": "registered", "accept_rate": 17, "profile_image": "https://www.gravatar.com/avatar/94e2dd813e278309b6281b4a4b7fdddd?s=128&d=identicon&r=PG", "display_name": "curiousguy", "link": "https://stackoverflow.com/users/963864/curiousguy"}, "edited": false, "score": 1, "creation_date": 1489744126, "post_id": 30013891, "comment_id": 72814743, "body": "&quot;<i>It will even sometimes be necessary to get a raw pointer</i>&quot; sometimes? are you serious?"}], "tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "is_accepted": true, "score": 30, "last_activity_date": 1430658016, "last_edit_date": 1430658016, "creation_date": 1430656649, "answer_id": 30013891, "question_id": 30011603, "link": "https://stackoverflow.com/questions/30011603/how-to-enable-rust-ownership-paradigm-in-c/30013891#30013891", "title": "How to enable Rust Ownership paradigm in C++", "body": "<p>You can't do this with compile-time checks at all. The C++ type system is lacking any way to reason about when an object goes out of scope, is moved, or is destroyed &mdash; much less turn this into a type constraint.</p>\n\n<p>What you could do is have a variant of <code>unique_ptr</code> that keeps a counter of how many \"borrows\" are active at run time. Instead of <code>get()</code> returning a raw pointer, it would return a smart pointer that increments this counter on construction and decrements it on destruction. If the <code>unique_ptr</code> is destroyed while the count is non-zero, at least you know someone somewhere did something wrong.</p>\n\n<p>However, this is not a fool-proof solution. Regardless of how hard you try to prevent it, there will always be ways to get a raw pointer to the underlying object, and then it's game over, since that raw pointer can easily outlive the smart pointer and the <code>unique_ptr</code>. It will even sometimes be necessary to get a raw pointer, to interact with an API that requires raw pointers.</p>\n\n<p>Moreover, <strong>ownership is not about pointers</strong>. <code>Box</code>/<code>unique_ptr</code> allows you to heap allocate an object, but it changes nothing about ownership, life time, etc. compared to putting the same object on the stack (or inside another object, or anywhere else really). To get the same mileage out of such a system in C++, you'd have to make such \"borrow counting\" wrappers for all objects everywhere, not just for <code>unique_ptr</code>s. And that is pretty impractical.</p>\n\n<p>So let's revisit the compile time option. The C++ compiler can't help us, but maybe lints can? Theoretically, if you implement the whole life time part of the type system and add annotations to all APIs you use (in addition to your own code), that may work.</p>\n\n<p>But it requires annotations for all functions used in the whole program. Including private helper function of third party libraries. And those for which no source code is available. And for those whose implementation that are too complicated for the linter to understand (from Rust experience, sometimes the reason something is safe are too subtle to express in the static model of lifetimes and it has to be written slightly differently to help the compiler). For the last two, the linter can't verify that the annotation is indeed correct, so you're back to trusting the programmer. Additionally, some APIs (or rather, the conditions for when they are safe) can't really be expressed very well in the lifetime system as Rust uses it.</p>\n\n<p>In other words, a complete and practically useful linter for this this would be substantial original research with the associated risk of failure.</p>\n\n<p>Maybe there is a middle ground that gets 80% of the benefits with 20% of the cost, but since you want a hard guarantee (and honestly, I'd like that too), tough luck. Existing \"good practices\" in C++ already go a long way to minimizing the risks, by essentially thinking (and documenting) the way a Rust programmer does, just without compiler aid. I'm not sure if there is much improvement over that to be had considering the state of C++ and its ecosystem.</p>\n\n<p>tl;dr Just use Rust ;-)</p>\n"}, {"tags": [], "owner": {"reputation": 14050, "user_id": 1858225, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/8afcf8a38024eb5b17c0b0b58ff96d79?s=128&d=identicon&r=PG", "display_name": "Kyle Strand", "link": "https://stackoverflow.com/users/1858225/kyle-strand"}, "is_accepted": false, "score": 2, "last_activity_date": 1430858247, "creation_date": 1430858247, "answer_id": 30062820, "question_id": 30011603, "link": "https://stackoverflow.com/questions/30011603/how-to-enable-rust-ownership-paradigm-in-c/30062820#30062820", "title": "How to enable Rust Ownership paradigm in C++", "body": "<p>I believe you can get <em>some</em> of the benefits of Rust by enforcing some strict coding conventions (which is after all what you'd have to do anyway, since there's no way with \"template magic\" to tell the compiler <em>not</em> to compile code that <em>doesn't</em> use said \"magic\"). Off the top of my head, the following could get you...well...<em>kind of</em> close, but only for single-threaded applications:</p>\n\n<ul>\n<li>Never use <code>new</code> directly; instead, use <code>make_unique</code>. This goes partway toward ensuring that heap-allocated objects are \"owned\" in a Rust-like manner.</li>\n<li>\"Borrowing\" should always be represented via reference parameters to function calls. Functions that take a reference should <em>never</em> create any sort of pointer to the refered-to object. (It may in some cases be necessary to use a raw pointer as a paramter instead of a reference, but the same rule should apply.)\n<ul>\n<li>Note that this works for objects on the stack <em>or</em> on the heap; the function shouldn't care.</li>\n</ul></li>\n<li><em>Transfer</em> of ownership is, of course, represented via R-value references (<code>&amp;&amp;</code>) and/or R-value references to <code>unique_ptr</code>s.</li>\n</ul>\n\n<p>Unfortunately, I can't think of any way to enforce Rust's rule that mutable references can only exist <em>anywhere in the system</em> when there are <em>no</em> other extant references.</p>\n\n<p>Also, for any kind of parallelism, you would need to start dealing with lifetimes, and the only way I can think of to permit cross-thread lifetime management (or cross-process lifetime management using shared memory) would be to implement your own \"ptr-with-lifetime\" wrapper. This could be implemented using <code>shared_ptr</code>, because here, reference-counting would actually be important; it's still a bit of unnecessary overhead, though, because reference-count blocks actually have <em>two</em> reference counters (one for all the <code>shared_ptr</code>s pointing to the object, another for all the <code>weak_ptr</code>s). It's also a little... <em>odd</em>, because in a <code>shared_ptr</code> scenario, <em>everybody</em> with a <code>shared_ptr</code> has \"equal\" ownership, whereas in a \"borrowing with lifetime\" scenario, only one thread/process should actually \"own\" the memory.</p>\n"}, {"comments": [{"owner": {"reputation": 69264, "user_id": 256138, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/ed9e8c0ff767e38f8fade11f5af00a45?s=128&d=identicon&r=PG", "display_name": "rubenvb", "link": "https://stackoverflow.com/users/256138/rubenvb"}, "edited": false, "score": 0, "creation_date": 1489734693, "post_id": 32037551, "comment_id": 72809748, "body": "How are the enhanced versions any different from shared_per/unique_ptr? Except sole syntax and usage differences, both use some sort of type-safe reference (counting) system, no?"}, {"owner": {"reputation": 721, "user_id": 479532, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/29d62e4d73bf4a16a7755f6862a6031f?s=128&d=identicon&r=PG", "display_name": "Ond\u0159ej \u010cert&#237;k", "link": "https://stackoverflow.com/users/479532/ond%c5%99ej-%c4%8cert%c3%adk"}, "reply_to_user": {"reputation": 69264, "user_id": 256138, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/ed9e8c0ff767e38f8fade11f5af00a45?s=128&d=identicon&r=PG", "display_name": "rubenvb", "link": "https://stackoverflow.com/users/256138/rubenvb"}, "edited": false, "score": 0, "creation_date": 1490742647, "post_id": 32037551, "comment_id": 73246066, "body": "Yes, both use reference counting, but the STL&#39;s shared_ptr/unique_ptr return a raw pointer, and if you store it and the original <code>unique_ptr</code> goes out of scope, the raw pointer becomes dangling. <code>UniquePtr</code> in my answer above allows to return a <code>Ptr</code>, that is as fast as a raw pointer in Release mode, but it will catch all dangling or null pointers in Debug mode, thus should be 100% safe."}], "tags": [], "owner": {"reputation": 721, "user_id": 479532, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/29d62e4d73bf4a16a7755f6862a6031f?s=128&d=identicon&r=PG", "display_name": "Ond\u0159ej \u010cert&#237;k", "link": "https://stackoverflow.com/users/479532/ond%c5%99ej-%c4%8cert%c3%adk"}, "is_accepted": false, "score": 0, "last_activity_date": 1439743543, "creation_date": 1439743543, "answer_id": 32037551, "question_id": 30011603, "link": "https://stackoverflow.com/questions/30011603/how-to-enable-rust-ownership-paradigm-in-c/32037551#32037551", "title": "How to enable Rust Ownership paradigm in C++", "body": "<p>You can use an enhanced version of a <code>unique_ptr</code> (to enforce a unique owner) together with an enhanced version of <code>observer_ptr</code> (to get a nice runtime exception for dangling pointers, i.e. if the original object maintained through <code>unique_ptr</code> went out of scope). The <a href=\"https://trilinos.org/\" rel=\"nofollow\">Trilinos</a> package implements this enhanced <code>observer_ptr</code>, they call it <code>Ptr</code>. I have implemented the enhanced version of <code>unique_ptr</code> here (I call it <code>UniquePtr</code>): <a href=\"https://github.com/certik/trilinos/pull/1\" rel=\"nofollow\">https://github.com/certik/trilinos/pull/1</a></p>\n\n<p>Finally, if you want the object to be stack allocated, but still be able to pass safe references around, you need to use the <code>Viewable</code> class, see my initial implementation here: <a href=\"https://github.com/certik/trilinos/pull/2\" rel=\"nofollow\">https://github.com/certik/trilinos/pull/2</a></p>\n\n<p>This should allow you to use C++ just like Rust for pointers, except that in Rust you get a compile time error, while in C++ you get a runtime exception. Also, it should be noted, that you only get a runtime exception in Debug mode. In Release mode, the classes do not do these checks, so they are as fast as in Rust (essentially as fast as raw pointers), but then they can segfault. So one has to make sure the whole test suite runs in Debug mode.</p>\n"}, {"tags": [], "owner": {"reputation": 61, "user_id": 409697, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d4a1757421781cc3f31bf4c570cea13?s=128&d=identicon&r=PG", "display_name": "user409697", "link": "https://stackoverflow.com/users/409697/user409697"}, "is_accepted": false, "score": 0, "last_activity_date": 1600772161, "last_edit_date": 1600772161, "creation_date": 1600765052, "answer_id": 64006335, "question_id": 30011603, "link": "https://stackoverflow.com/questions/30011603/how-to-enable-rust-ownership-paradigm-in-c/64006335#64006335", "title": "How to enable Rust Ownership paradigm in C++", "body": "<p>I think one could add a degree of compile-time introspection and custom sanitisation by introducing custom wrapper classes that track ownership and borrowing.</p>\n<p><em>The code below is a hypothetical sketch, and not a production solution which would need a lot more tooling, e.g. #def out the checks when not sanitising. It uses a very naive lifetime checker to 'count' borrow errors in ints, in this instance during compilation. <code>static_assert</code>s are not possible as the ints are not constexpr, but the values are there and can be interrogated before runtime. I believe this answers your 3 constraints, regardless of whether these are heap allocations, so I'm using a simple int type to demo the idea, rather than a smart pointer.</em></p>\n<p>Try uncommenting the use cases in main() below (run in compiler explorer with -O3 to see boilerplate optimise away), and you'll see the warning counters change.</p>\n<p><a href=\"https://godbolt.org/z/Pj4WMr\" rel=\"nofollow noreferrer\">https://godbolt.org/z/Pj4WMr</a></p>\n<pre><code>// Hypothetical Rust-like owner / borrow wrappers in C++\n// This wraps types with data which is compiled away in release\n// It is not possible to static_assert, so this uses static ints to count errors.\n#include &lt;utility&gt;\n\n// Statics to track errors. Ideally these would be static_asserts\n// but they depen on Owner::has_been_moved which changes during compilation.\nstatic int owner_already_moved = 0;\nstatic int owner_use_after_move = 0;\nstatic int owner_already_borrowed = 0;\n\n// This method exists to ensure static errors are reported in compiler explorer\nint get_fault_count() {\n    return owner_already_moved + owner_use_after_move + owner_already_borrowed;\n}\n\n// Storage for ownership of a type T.\n// Equivalent to mut usage in Rust\n// Disallows move by value, instead ownership must be explicitly moved.\ntemplate &lt;typename T&gt;\nstruct Owner {\n    Owner(T v) : value(v) {}\n    Owner(Owner&lt;T&gt;&amp; ov) = delete;\n    Owner(Owner&lt;T&gt;&amp;&amp; ov) {\n        if (ov.has_been_moved) {\n            owner_already_moved++;\n        }\n        value = std::move(ov.value);\n        ov.has_been_moved = true;\n    }\n\n    T&amp; operator*() {\n        if (has_been_moved) {\n            owner_use_after_move++;\n        }\n        return value;\n    }\n\n    T value;\n    bool has_been_moved{false};\n};\n\n// Safely borrow a value of type T\n// Implicit constuction from Owner of same type to check borrow is safe\ntemplate &lt;typename T&gt;\nstruct Borrower {\n    Borrower(Owner&lt;T&gt;&amp; v) : value(v.value) {\n        if (v.has_been_moved) {\n            owner_already_borrowed++;\n        }\n    }\n\n    const T&amp; operator*() const {\n        return value;\n    }\n\n    T value;\n};\n\n// Example of function borrowing a value, can only read const ref\nstatic void use(Borrower&lt;int&gt; v) {\n    (void)*v;\n}\n\n// Example of function taking ownership of value, can mutate via owner ref\nstatic void use_mut(Owner&lt;int&gt; v) {\n    *v = 5;\n}\n\nint main() {\n    // Rather than just 'int', Owner&lt;int&gt; tracks the lifetime of the value\n    Owner&lt;int&gt; x{3};\n\n    // Borrowing value before mutating causes no problems\n    use(x);\n\n    // Mutating value passes ownership, has_been_moved set on original x\n    use_mut(std::move(x));\n\n    // Uncomment for owner_already_borrowed = 1\n    //use(x);\n\n    // Uncomment for owner_already_moved = 1\n    //use_mut(std::move(x));\n\n    // Uncomment for another owner_already_borrowed++\n    //Borrower&lt;int&gt; y = x;\n\n    // Uncomment for owner_use_after_move = 1;\n    //return *x;\n}\n</code></pre>\n<p>The use of static counters is obviously not desirable, but it is not possible to use static_assert as owner_already_moved is non-const. The idea is these statics give hints to errors appearing, and in final production code they could be #defed out.</p>\n"}], "owner": {"reputation": 17424, "user_id": 278842, "user_type": "registered", "accept_rate": 51, "profile_image": "https://www.gravatar.com/avatar/df6877d3f05e542ca5975b4670600f2e?s=128&d=identicon&r=PG", "display_name": "Christopher Oezbek", "link": "https://stackoverflow.com/users/278842/christopher-oezbek"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5749, "favorite_count": 8, "accepted_answer_id": 30013891, "answer_count": 4, "score": 30, "last_activity_date": 1600772403, "creation_date": 1430640544, "last_edit_date": 1600772403, "question_id": 30011603, "link": "https://stackoverflow.com/questions/30011603/how-to-enable-rust-ownership-paradigm-in-c", "title": "How to enable Rust Ownership paradigm in C++", "body": "<p>The system programming language Rust uses the <a href=\"https://doc.rust-lang.org/book/ownership.html\" rel=\"nofollow noreferrer\">ownership</a> paradigm to ensure at compile time with zero cost for the runtime when a resource has to be freed.</p>\n<p>In C++ we commonly use smart pointers to achieve the same goal of hiding the complexity of managing resource allocation. There are a couple of differences though:</p>\n<ul>\n<li>In Rust there is always only one owner, whereas C++ <code>shared_ptr</code> can easily leak ownership.</li>\n<li>In Rust we can borrow references we do not own, whereas C++ <code>unique_ptr</code> can not be shared in a safe way via <code>weak_ptr</code> and <code>lock()</code>.</li>\n<li>Reference counting of <code>shared_ptr</code> is costly.</li>\n</ul>\n<p>My question is: How can we emulate the ownership paradigm in C++ within the following constraints:</p>\n<ul>\n<li>Only one owner at any time</li>\n<li>Possibility to borrow a pointer and use it temporarily without fear of the resource going out of scope (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3840.pdf\" rel=\"nofollow noreferrer\"><code>observer_ptr</code></a> is useless for this)</li>\n<li>As much compile-time checks as possible.</li>\n</ul>\n<p><strong>Edit:</strong> Given the comments so far, we can conclude:</p>\n<ul>\n<li><p>No compile-time support for this (I was hoping for some <code>decltype</code>/template magic unknown to me) in the compilers. Might be possible using static analysis elsewhere (taint?)</p>\n</li>\n<li><p>No way to get this without reference counting.</p>\n</li>\n<li><p>No standard implementation to distinguish <code>shared_ptr</code>s with owning or borrowing semantic</p>\n</li>\n<li><p>Could roll your own by creating wrapper types around <code>shared_ptr</code> and <code>weak_ptr</code>:</p>\n<ul>\n<li><code>owned_ptr</code>: non-copyable, move-semantics, encapsulates shared_ptr, access to <code>borrowed_ptr</code></li>\n<li><code>borrowed_ptr</code>: copyable, encapsulates <code>weak_ptr</code>, lock method</li>\n<li><code>locked_ptr</code>: non-copyable, move-semantics, encapsulates <code>shared_ptr</code> from locking <code>weak_ptr</code></li>\n</ul>\n</li>\n</ul>\n"}, {"tags": ["qml", "qt5", "rust"], "comments": [{"owner": {"reputation": 7002, "user_id": 2538363, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9a17eb0f935aaff6b21269f57ccdc1bd?s=128&d=identicon&r=PG", "display_name": "BaCaRoZzo", "link": "https://stackoverflow.com/users/2538363/bacarozzo"}, "edited": false, "score": 0, "creation_date": 1430645194, "post_id": 30010184, "comment_id": 48142420, "body": "Qml libs changes (usually) with Qt releases. <code>Controls</code>  reached version 1.3 currently. For each library you should install the one matching the required version or probably an higher version."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1430678410, "post_id": 30010184, "comment_id": 48153015, "body": "Have you installed version 1.2 of the package, as the error suggests?"}, {"owner": {"reputation": 11, "user_id": 4858426, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/fK5MO.png?s=128&g=1", "display_name": "dallyshalla", "link": "https://stackoverflow.com/users/4858426/dallyshalla"}, "edited": false, "score": 0, "creation_date": 1430715154, "post_id": 30010184, "comment_id": 48162791, "body": "I&#39;m not sure how to install previous versions; do either of you know? Shepmater, BaCaRoZzo?"}, {"owner": {"reputation": 7002, "user_id": 2538363, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9a17eb0f935aaff6b21269f57ccdc1bd?s=128&d=identicon&r=PG", "display_name": "BaCaRoZzo", "link": "https://stackoverflow.com/users/2538363/bacarozzo"}, "edited": false, "score": 0, "creation_date": 1430741974, "post_id": 30010184, "comment_id": 48176080, "body": "Use the <code>@</code> before the name to notify other users about the message, e.g. @Shepmater will be correctly  notified of this message. :) As for the library, controls were introduced in Qt 5.1 - version 1.0 - and thus you should download Qt 5.3 to obtain the correct 1.2 version."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 7002, "user_id": 2538363, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9a17eb0f935aaff6b21269f57ccdc1bd?s=128&d=identicon&r=PG", "display_name": "BaCaRoZzo", "link": "https://stackoverflow.com/users/2538363/bacarozzo"}, "edited": false, "score": 0, "creation_date": 1431649902, "post_id": 30010184, "comment_id": 48599740, "body": "@BaCaRoZzo although you do have to spell it correctly... ^_^"}, {"owner": {"reputation": 7002, "user_id": 2538363, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9a17eb0f935aaff6b21269f57ccdc1bd?s=128&d=identicon&r=PG", "display_name": "BaCaRoZzo", "link": "https://stackoverflow.com/users/2538363/bacarozzo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1431650693, "post_id": 30010184, "comment_id": 48599956, "body": "Lol, Does it &quot;mater&quot; if I say that I&#39;ve used the stackoverflow autocompletion @Shepmaster? No it doesn&#39;t...I was able to miss your name. A record! :D"}], "answers": [{"tags": [], "owner": {"reputation": 11, "user_id": 4858426, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/fK5MO.png?s=128&g=1", "display_name": "dallyshalla", "link": "https://stackoverflow.com/users/4858426/dallyshalla"}, "is_accepted": false, "score": 1, "last_activity_date": 1431520471, "creation_date": 1431520471, "answer_id": 30214945, "question_id": 30010184, "link": "https://stackoverflow.com/questions/30010184/qtquick-controls-version-1-2-is-not-installed-when-compiling-the-example-for-q/30214945#30214945", "title": "&quot;QtQuick.Controls version 1.2 is not installed&quot; when compiling the example for QMLRS", "body": "<p>So I figured out in the qmlrs project find the file called <code>factorial_ui.qml</code> and change the line where it says:\nchange the version of QtQuick.Controls:\n<code>import QtQuick.Controls 1.1</code> (in my case was 1.1 which solved my version)</p>\n\n<p>Otherwise check out:\n<a href=\"https://github.com/cyndis/qmlrs/blob/master/.travis.yml\" rel=\"nofollow\">https://github.com/cyndis/qmlrs/blob/master/.travis.yml</a></p>\n\n<pre><code>language: rust\ninstall:\n  - sudo add-apt-repository \"deb mirror://mirrors.ubuntu.com/mirrors.txt trusty main restricted universe multiverse\" -y\n  - sudo apt-get update -qq\n  - sudo apt-get install -qq libqt5core5a libqt5gui5 libqt5quick5 libqt5qml5 qtbase5-dev qtdeclarative5-dev cmake\n</code></pre>\n\n<p>to install the requirements they are located in the project;</p>\n\n<p>I know my solution is quick hack to make it work; but hey I'm on the ground running with GUIs in Rust :)</p>\n"}], "owner": {"reputation": 11, "user_id": 4858426, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/fK5MO.png?s=128&g=1", "display_name": "dallyshalla", "link": "https://stackoverflow.com/users/4858426/dallyshalla"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5723, "favorite_count": 1, "answer_count": 1, "score": 0, "last_activity_date": 1431520471, "creation_date": 1430626697, "last_edit_date": 1430678265, "question_id": 30010184, "link": "https://stackoverflow.com/questions/30010184/qtquick-controls-version-1-2-is-not-installed-when-compiling-the-example-for-q", "title": "&quot;QtQuick.Controls version 1.2 is not installed&quot; when compiling the example for QMLRS", "body": "<p>While trying to use <a href=\"https://github.com/cyndis/qmlrs\" rel=\"nofollow\">qmlrs</a>, I encountered this issue:</p>\n\n<pre><code>~/rustqml/qmlrs$ cargo run --example factorial\nCompiling qmlrs v0.0.1 (file:///home/dally/rustqml/qmlrs)\nRunning target/debug/examples/factorial\nQQmlApplicationEngine failed to load component\nfile:///home/dally/rustqml/qmlrs/examples/factorial_ui.qml:2 module \"QtQuick.Controls\" is not installed\nfile:///home/dally/rustqml/qmlrs/examples/factorial_ui.qml:3 module \"QtQuick.Layouts\" is not installed\nfile:///home/dally/rustqml/qmlrs/examples/factorial_ui.qml:2 module \"QtQuick.Controls\" is not installed\nfile:///home/dally/rustqml/qmlrs/examples/factorial_ui.qml:3 module \"QtQuick.Layouts\" is not installed\n</code></pre>\n\n<p>After searching, I installed <code>libqt5qml-quickcontrols</code>. I now get errors  about requiring version 1.2:</p>\n\n<pre><code>~/rustqml/qmlrs$ cargo run --example factorial\nRunning target/debug/examples/factorial\nQQmlApplicationEngine failed to load component\nfile:///home/dally/rustqml/qmlrs/examples/factorial_ui.qml:2 module \"QtQuick.Controls\" version 1.2 is not installed\n</code></pre>\n"}, {"tags": ["compiler-errors", "rust"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 2, "last_activity_date": 1430622013, "creation_date": 1430622013, "answer_id": 30009785, "question_id": 30009697, "link": "https://stackoverflow.com/questions/30009697/cannot-clone-ioerror-in-1-0-0-beta/30009785#30009785", "title": "Cannot clone io::Error in 1.0.0 beta", "body": "<p>It appears that <code>std::io::Error</code> doesn't implement <code>Clone</code>, which is the problem.  I don't see any real reason why it <em>couldn't</em>, so I assume this is simply an oversight.  It might be worth filing an issue to support it.</p>\n\n<p>In the mean time, the simplest workaround I can think of is to replace the <code>Error</code> with something you <em>can</em> clone.  The quickest way to do that is to turn it into a <code>String</code>:</p>\n\n<pre><code>let opt = opt.map(|r| r.map_err(|e| format!(\"{}\", e)));\n</code></pre>\n\n<p>If you want to keep the actual <code>Error</code> value around, you could try moving it into an <code>Rc</code> so that you have shared ownership.</p>\n"}, {"comments": [{"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 1, "creation_date": 1430693244, "post_id": 30009786, "comment_id": 48157875, "body": "Looks like the Clone + Clone thing is a Rustdoc bug, it&#39;s happening for Copy too.."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1430622808, "last_edit_date": 1430622808, "creation_date": 1430622015, "answer_id": 30009786, "question_id": 30009697, "link": "https://stackoverflow.com/questions/30009697/cannot-clone-ioerror-in-1-0-0-beta/30009786#30009786", "title": "Cannot clone io::Error in 1.0.0 beta", "body": "<p>It seems like the the error message is confusing you, so let's look at it:</p>\n\n<pre><code>type `core::option::Option&lt;core::result::Result&lt;collections::string::String, std::io::error::Error&gt;&gt;` does not implement any method in scope named `clone`\n</code></pre>\n\n<p>Let's shorten up the types a bit:</p>\n\n<pre><code>type `Option&lt;Result&lt;String, io::Error&gt;&gt;` does not implement any method in scope named `clone`\n</code></pre>\n\n<p>So, let's check out <a href=\"http://doc.rust-lang.org/std/option/enum.Option.html\" rel=\"nofollow\"><code>Option</code></a>. It says it implements <code>Clone</code>:</p>\n\n<pre><code>impl&lt;T&gt; Clone for Option&lt;T&gt; where T: Clone + Clone\n</code></pre>\n\n<p>I'm not sure what's going on with <code>Clone + Clone</code>, but this says \"I can implement <code>Clone</code> if my contained type implements <code>Clone</code>. So let's look at the contained type, <a href=\"http://doc.rust-lang.org/std/result/enum.Result.html\" rel=\"nofollow\"><code>Result</code></a>. It says something similar:</p>\n\n<pre><code>impl&lt;T, E&gt; Clone for Result&lt;T, E&gt; where E: Clone + Clone, T: Clone + Clone\n</code></pre>\n\n<p>Ok, so let's check <a href=\"http://doc.rust-lang.org/std/string/struct.String.html\" rel=\"nofollow\"><code>String</code></a>. It says it supports <code>Clone</code>. How about <a href=\"http://doc.rust-lang.org/std/io/struct.Error.html\" rel=\"nofollow\"><code>io::Error</code></a>? </p>\n\n<p>This does <strong>not</strong> implement <code>Clone</code>, so therefore the whole type cannot implement it.</p>\n\n<p>So how do you fix it? In you case, you don't care about the failures (you just unwrap), so do that first:</p>\n\n<pre><code>let str = opt.unwrap().unwrap().clone();\n</code></pre>\n\n<p>This clones the <code>String</code> instead of all the intermediate state. This may even be slightly more efficient, as you clone less data.</p>\n"}, {"tags": [], "owner": {"reputation": 5913, "user_id": 899752, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/CzfBy.jpg?s=128&g=1", "display_name": "mdup", "link": "https://stackoverflow.com/users/899752/mdup"}, "is_accepted": false, "score": 1, "last_activity_date": 1430622355, "creation_date": 1430622355, "answer_id": 30009818, "question_id": 30009697, "link": "https://stackoverflow.com/questions/30009697/cannot-clone-ioerror-in-1-0-0-beta/30009818#30009818", "title": "Cannot clone io::Error in 1.0.0 beta", "body": "<p>In order for <code>.clone()</code> to work on <code>Result&lt;T, E&gt;</code>, both <code>T</code> and <code>E</code> must implement the <code>Clone</code> trait. </p>\n\n<p>In this case, you deal with a <code>Result&lt;String, Error&gt;</code>, however <code>Error</code> does not implement <code>Clone</code>!</p>\n"}], "owner": {"reputation": 23, "user_id": 4858294, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/40ff1593b44ebae45934946e5ef14a8b?s=128&d=identicon&r=PG&f=1", "display_name": "Gian", "link": "https://stackoverflow.com/users/4858294/gian"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 603, "favorite_count": 0, "accepted_answer_id": 30009786, "answer_count": 3, "score": 2, "last_activity_date": 1430622808, "creation_date": 1430620838, "last_edit_date": 1430622288, "question_id": 30009697, "link": "https://stackoverflow.com/questions/30009697/cannot-clone-ioerror-in-1-0-0-beta", "title": "Cannot clone io::Error in 1.0.0 beta", "body": "<p>I just began learning Rust, but since updating to the beta version, I am facing many compilation errors that weren't there before.\nOne of these is related to <code>clone</code>, here is my code:</p>\n\n<pre><code>use std::io::{BufReader, BufRead};\nuse std::clone::Clone;\nuse std::env;\nuse std::fs::File;\n\npub fn main() {\n\n    let ref path = match env::args().nth(1) {\n            Some(path) =&gt; path,\n            None =&gt; panic!(\"file path is missing!\"), };\n\n    let file = match File::open(&amp;path) {\n            Ok(file) =&gt; file,\n            Err(_) =&gt; panic!(\"could not open {}\", path), };\n\n    let mut iter = BufReader::new(file).lines();\n    let mut opt = iter.next();\n\n    let str = opt.clone().unwrap().unwrap();\n\n    // some code omitted\n}\n</code></pre>\n\n<p>And this is the error:</p>\n\n<blockquote>\n  <p>test.rs:19:19: 19:26 error: type <code>core::option::Option&lt;core::result::Result&lt;collections::string::String, std::io::error::Error&gt;&gt;</code> does not implement any method in scope named <code>clone</code>\n  test.rs:19     let str = opt.clone().unwrap().unwrap();</p>\n</blockquote>\n\n<p>I need the <code>clone</code> because I use <code>opt</code> in other parts of my code.</p>\n\n<p>Is my code at fault, or has something I don't know about changed in Rust?</p>\n"}, {"tags": ["rust", "rustdoc"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1430621515, "post_id": 30009650, "comment_id": 48137732, "body": "FWIW, I prefer to leverage the type system. Instead of saying &quot;This u8 must be a power of 2 or prime&quot;, make a <code>PowerOfTwoOrPrime</code> newtype with an appropriate constructor."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1430640489, "post_id": 30009650, "comment_id": 48141316, "body": "No syntax for that nor are guidelines/conventions established."}], "answers": [{"comments": [{"owner": {"reputation": 1679, "user_id": 267874, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/007a9c64b82a001443ff463ef326366b?s=128&d=identicon&r=PG", "display_name": "Paul-Sebastian Manole", "link": "https://stackoverflow.com/users/267874/paul-sebastian-manole"}, "edited": false, "score": 0, "creation_date": 1581257931, "post_id": 30013052, "comment_id": 106362747, "body": "Sort of like JSDoc. I say it&#39;s more ergonomic too. You can see the full function documentation at a single glance."}], "tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": false, "score": 25, "last_activity_date": 1605837637, "last_edit_date": 1605837637, "creation_date": 1430650869, "answer_id": 30013052, "question_id": 30009650, "link": "https://stackoverflow.com/questions/30009650/how-do-you-document-function-arguments/30013052#30013052", "title": "How do you document function arguments?", "body": "<p>I've seen the following style used in some of the examples:</p>\n<pre><code>/// Brief.\n///\n/// Description.\n/// \n/// * `foo` - Text about foo.\n/// * `bar` - Text about bar.\nfn function (foo: i32, bar: &amp;str) {}\n</code></pre>\n<p>So far it's working fine for me too.</p>\n<p>P.S. There's also an <a href=\"https://github.com/rust-lang/rust/issues/57525\" rel=\"nofollow noreferrer\">issue</a> on this.<br />\nP.S. Check also the improved rustdoc <em>linking</em> and the <em>search aliases</em> <a href=\"https://blog.rust-lang.org/2020/11/19/Rust-1.48.html#easier-linking-in-rustdoc\" rel=\"nofollow noreferrer\">in 1.48</a>.</p>\n"}, {"comments": [{"owner": {"reputation": 2369, "user_id": 4614680, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c9b36fb2c1d356a919916f77e74f1c3c?s=128&d=identicon&r=PG&f=1", "display_name": "Philipp Ludwig", "link": "https://stackoverflow.com/users/4614680/philipp-ludwig"}, "edited": false, "score": 0, "creation_date": 1521716279, "post_id": 30020261, "comment_id": 85854689, "body": "Since this answer is 3 years old, I&#39;d like to inquire if there are any updates about this - at least I couldn&#39;t find any."}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "reply_to_user": {"reputation": 2369, "user_id": 4614680, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c9b36fb2c1d356a919916f77e74f1c3c?s=128&d=identicon&r=PG&f=1", "display_name": "Philipp Ludwig", "link": "https://stackoverflow.com/users/4614680/philipp-ludwig"}, "edited": false, "score": 3, "creation_date": 1521716433, "post_id": 30020261, "comment_id": 85854790, "body": "There is not. Most people rely on the type and argument name, and it tends to be pretty clear. If clarifications are needed, most use a bit of prose, rather than something that rustdoc needs to understand."}], "tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 19, "last_activity_date": 1430693270, "creation_date": 1430693270, "answer_id": 30020261, "question_id": 30009650, "link": "https://stackoverflow.com/questions/30009650/how-do-you-document-function-arguments/30020261#30020261", "title": "How do you document function arguments?", "body": "<blockquote>\n  <p>Is there an \"official\" way to document them</p>\n</blockquote>\n\n<p>There is not currently an official way to document arguments.</p>\n"}], "owner": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5386, "favorite_count": 2, "answer_count": 2, "score": 27, "last_activity_date": 1605837637, "creation_date": 1430620493, "last_edit_date": 1430621355, "question_id": 30009650, "link": "https://stackoverflow.com/questions/30009650/how-do-you-document-function-arguments", "title": "How do you document function arguments?", "body": "<p>rustdoc allows you to document struct fields and enum variants by including a doc comment above each line:</p>\n\n<pre><code>enum Choices {\n  /// The first choice.\n  First,\n  /// The second choice.\n  Second,\n}\n\nstruct Person {\n  /// The person's name.\n  name: String,\n  /// The person's age.\n  age: u8,\n}\n</code></pre>\n\n<p>These will show up with nice formatting in the HTML generated by rustdoc. However, I haven't seen any way of making similar nicely-formatted documents for function arguments. Is there an \"official\" way to document them or do you just have to describe them freeform in the function's main documentation section?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1430599306, "post_id": 30007087, "comment_id": 48132906, "body": "It would be very helpful if you can make your code compile on the <a href=\"https://play.rust-lang.org/\" rel=\"nofollow noreferrer\">playpen</a>. For example, you don&#39;t include what <code>Letter</code> or <code>Json</code> are, so I am unable to compile it and see the same error that you are getting. Try and make the code <a href=\"http://stackoverflow.com/help/mcve\">minimal</a> as well."}], "answers": [{"comments": [{"owner": {"reputation": 8775, "user_id": 821110, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/fa6fca5f613944238a91d2daeba67b9d?s=128&d=identicon&r=PG", "display_name": "W.K.S", "link": "https://stackoverflow.com/users/821110/w-k-s"}, "edited": false, "score": 1, "creation_date": 1430762734, "post_id": 30007395, "comment_id": 48189635, "body": "That&#39;s a very thorough explanation. I now understand what exactly the conflicting requirements are. Thanks a lot, especially for going through the trouble of writing a compilable version!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1533734253, "last_edit_date": 1533734253, "creation_date": 1430600219, "answer_id": 30007395, "question_id": 30007087, "link": "https://stackoverflow.com/questions/30007087/factory-method-instance-does-not-live-long-enough/30007395#30007395", "title": "Factory method: instance does not live long enough", "body": "<p>Here's a smaller example that probably is where you started:</p>\n\n<pre><code>use std::collections::HashMap;\n\nstruct Letter;\n\nstruct Alphabet&lt;'a&gt;{\n    vowels: Vec&lt;Letter&gt;,\n    letters: HashMap&lt;u8, &amp;'a Letter&gt;\n}\n\nimpl&lt;'a&gt; Alphabet&lt;'a&gt; {\n    fn add(&amp;mut self, l: Letter) {\n        self.vowels.push(l);\n        self.letters.insert(42, &amp;self.vowels.last().unwrap());\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>You then followed the compiler error<sup><strong>1</strong></sup>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>&lt;anon&gt;:12:46: 12:52 error: cannot infer an appropriate lifetime for lifetime parameter 'a in function call due to conflicting requirements\n&lt;anon&gt;:12         self.letters.insert(42, &amp;self.vowels.last().unwrap());\n                                                       ^~~~~~\n&lt;anon&gt;:10:5: 13:6 help: consider using an explicit lifetime parameter as shown: fn add(&amp;'a mut self, l: Letter)\n</code></pre>\n\n<p>And continued on, until you got something like this:</p>\n\n<pre><code>use std::collections::HashMap;\n\nstruct Letter;\n\nstruct Alphabet&lt;'a&gt;{\n    vowels: Vec&lt;Letter&gt;,\n    letters: HashMap&lt;u8, &amp;'a Letter&gt;\n}\n\nimpl&lt;'a&gt; Alphabet&lt;'a&gt; {\n    fn new() -&gt; Alphabet&lt;'a&gt; {\n        Alphabet { vowels: Vec::new(), letters: HashMap::new() }\n    }\n\n    fn add(&amp;'a mut self, l: Letter) {\n        self.vowels.push(l);\n        self.letters.insert(42, &amp;self.vowels.last().unwrap());\n    }\n\n    fn parse() -&gt; Alphabet&lt;'a&gt; {\n        let mut a = Alphabet::new();\n        a.add(Letter);\n        a\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>The root problem is that <a href=\"https://stackoverflow.com/q/32300132/155423\"><em>you cannot have references to your own members</em></a> <sup><strong>2</strong></sup>. In the general case, whenever you moved the structure, then the memory location of all the member variables would change, invalidating all the references. This is a bad thing, and Rust would stop you.</p>\n\n<p>The error message you are getting states that there's no possible lifetime that can satisfy what you want \u2014 the reference is only valid while the struct doesn't move, but you want to return the struct from the method, <em>moving it</em>.</p>\n\n<p>\"But wait!\" you say, \"I have a <code>Vec</code> and the contents of the <code>Vec</code> are on the heap and won't move!\". While technically true (the best kind of true), Rust doesn't track things at that fine-grained of a level.</p>\n\n<p>The general solution here would be to split your structure into two parts. Parse everything from JSON into an <code>Alphabet</code> struct with just the <code>Vec</code>s. Then pass that struct (likely by reference, maybe by value) to a <code>AlphabetSoup</code> struct. That struct can create the <code>HashMap</code> all at once and provide a place to cache your values.</p>\n\n<p><sup><strong>1</strong></sup> Newer compilers actually <em>removed</em> this suggestion because the false-positive rate was too high and it introduced more confusion than it helped.</p>\n\n<p><sup><strong>2</strong></sup> You actually <em>can</em> have references to your own members, but you can then never move the object, which makes it impractical for most cases.</p>\n"}], "owner": {"reputation": 8775, "user_id": 821110, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/fa6fca5f613944238a91d2daeba67b9d?s=128&d=identicon&r=PG", "display_name": "W.K.S", "link": "https://stackoverflow.com/users/821110/w-k-s"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 743, "favorite_count": 0, "accepted_answer_id": 30007395, "answer_count": 1, "score": 3, "last_activity_date": 1533734253, "creation_date": 1430598270, "last_edit_date": 1430599127, "question_id": 30007087, "link": "https://stackoverflow.com/questions/30007087/factory-method-instance-does-not-live-long-enough", "title": "Factory method: instance does not live long enough", "body": "<p>I'm developing a word generator in Rust. The application consists of two main structs: <code>Letter</code> and <code>Alphabet</code>.</p>\n\n<p><code>Letter</code> consists of a single character and rules concerning its relationship with other letters.</p>\n\n<p><code>Alphabet</code> contains vectors for vowels and consonants as well as a hashmap with references to the letters in those vectors. This is done so that rules of a letter can be retrieved in O(1) time.</p>\n\n<p>I've created a factory method to read the alphabet from a json string (code below)  but I'm getting an error stating the alphabet instance does not live long enough.</p>\n\n<blockquote>\n  <p>src/word_generator/alphabet.rs:47:6: 47:14 error: <code>alphabet</code> does not\n  live long enough src/word_generator/alphabet.rs:47\n                    alphabet.add_letter(letter);</p>\n  \n  <p>src/word_generator/alphabet.rs:26:40: 55:3 note: reference must be\n  valid for the anonymous lifetime #1 defined on the block at 26:39...\n  src/word_generator/alphabet.rs:26     pub fn from_json(json:\n  &amp;str)->Alphabet{</p>\n  \n  <p>note: ...but borrowed value is only valid for the block suffix\n  following statement 3 at 40:37 src/word_generator/alphabet.rs:40      let\n  mut alphabet = Alphabet::new(); src/word_generator/alphabet.rs:41</p>\n</blockquote>\n\n<p>I understand the error (I hope) but I don't understand why it happens. Why is the instance of <code>Alphabet</code>, returned by the function <code>new()</code>, borrowed by the variable <code>alphabet</code>? Isn't this a move operation? </p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub struct Alphabet&lt;'a&gt;{\n    pub vowels: Vec&lt;Letter&gt;,\n    pub consonants: Vec&lt;Letter&gt;,\n    letters: HashMap&lt;char,&amp;'a Letter&gt;\n}\n\nimpl&lt;'a&gt; Alphabet&lt;'a&gt;{\n\n    pub fn new()-&gt;Alphabet&lt;'a&gt;{\n\n        return Alphabet{\n            vowels: Vec::new(),\n            consonants: Vec::new(),\n            letters: HashMap::new()\n        }\n\n    }\n\n    pub fn from_json(json: &amp;str)-&gt;Alphabet{\n\n        let data :Json = match Json::from_str(json){\n            Ok(_data)=&gt;_data,\n            Err(_err)=&gt;panic!(\"Invalid JSON provided\")\n        };\n\n        let letters = match data.as_array(){\n            Some(_letters)=&gt;_letters,\n            None=&gt;panic!(\"Expected JSON\\'s root to be an array but found a different structure.\")\n        };\n\n        let mut it = letters.iter();\n\n        let mut alphabet = Alphabet::new();\n\n        loop {\n            match it.next(){\n                Some(x) =&gt;{\n\n                    let letter : Letter= json::decode(&amp;(x.to_string())).unwrap();\n                    alphabet.add_letter(letter);\n\n                },\n                None =&gt; break,\n            }\n        }\n\n        return alphabet\n    }\n\n    fn add_letter(&amp;'a mut self,ref l: Letter){\n\n        match l.letter_type {\n            LetterType::Vowel =&gt;{\n                self.vowels.push(l.clone());\n                self.letters.insert(l.value, &amp;self.vowels.last().unwrap());\n            },\n            LetterType::Consonant =&gt;{ \n                self.consonants.push(l.clone());\n                self.letters.insert(l.value, &amp;self.consonants.last().unwrap());\n            }\n        }\n\n    }\n}\n</code></pre>\n\n<p>P.S.: I'm very new to Rust so any suggestions for improvement to the code are most welcome.</p>\n"}, {"tags": ["module", "rust"], "comments": [{"owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "edited": false, "score": 2, "creation_date": 1430590621, "post_id": 30004569, "comment_id": 48130114, "body": "I can&#39;t speak to this specific issue, but I would definitely recommend trying to find a refactoring approach that lets you use smaller steps. You&#39;d have to make a lot of changes between working compilations to fix 400+ errors..."}], "answers": [{"comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "reply_to_user": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "edited": false, "score": 0, "creation_date": 1430668730, "post_id": 30007409, "comment_id": 48149420, "body": "I thought I saw <code>use std::io::prelude::*</code> in both modules. I&#39;m not 100% it will work, but this is the hunch I have."}, {"owner": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "edited": false, "score": 0, "creation_date": 1430671145, "post_id": 30007409, "comment_id": 48150362, "body": "Link to the rust issue describing it : <a href=\"https://github.com/rust-lang/rust/issues/4865\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/4865</a>"}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "reply_to_user": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "edited": false, "score": 0, "creation_date": 1430671825, "post_id": 30007409, "comment_id": 48150597, "body": "great! Thanks for the link, I didn&#39;t find it."}], "tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": true, "score": 4, "last_activity_date": 1443708249, "last_edit_date": 1443708249, "creation_date": 1430600295, "answer_id": 30007409, "question_id": 30004569, "link": "https://stackoverflow.com/questions/30004569/unresolved-import-with-a-circular-dependency-between-modules/30007409#30007409", "title": "&quot;unresolved import&quot; with a circular dependency between modules", "body": "<p>Edit: Glorious news, the bug mentioned below is fixed! It's fixed in Rust 1.4 or later.</p>\n\n<p>Glob imports (<code>use foo::*</code>) have <a href=\"https://github.com/rust-lang/rust/issues/4865\" rel=\"nofollow\">a known bug</a> where they are incompatible with cyclic imports. I would try removing the glob imports in both affected modules.</p>\n"}], "owner": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1953, "favorite_count": 1, "accepted_answer_id": 30007409, "answer_count": 1, "score": 4, "last_activity_date": 1443753517, "creation_date": 1430583384, "last_edit_date": 1443753517, "question_id": 30004569, "link": "https://stackoverflow.com/questions/30004569/unresolved-import-with-a-circular-dependency-between-modules", "title": "&quot;unresolved import&quot; with a circular dependency between modules", "body": "<p>I have two files :</p>\n\n<ul>\n<li><a href=\"https://github.com/gbersac/rustc-serialize/blob/json_mod/src/json/json.rs\" rel=\"nofollow\">json.rs</a> in which I call Builder, a struct defined in builder.rs</li>\n<li><a href=\"https://github.com/gbersac/rustc-serialize/blob/json_mod/src/json/builder.rs\" rel=\"nofollow\">builder.rs</a> in which I call Json, a struct defined in json.rs</li>\n</ul>\n\n<p>As you can see there is a circular dependency between these two modules. It seems like sometimes Rust supports circular dependencies, but for this case, the compiler throws errors:</p>\n\n<pre><code>src/json/mod.rs:1:25: 1:31 error: unresolved import (maybe you meant `ToJson::*`?)\nsrc/json/mod.rs:1 pub use self::to_json::{ToJson};\n                                          ^~~~~~\nsrc/json/builder.rs:2:18: 2:22 error: unresolved import (maybe you meant `Json::*`?)\nsrc/json/builder.rs:2 use json::json::{Json, JsonEvent, Array, Object}; //commenting this line solve the dependency error\n\n[...]\n</code></pre>\n\n<p>The code <a href=\"https://github.com/gbersac/rustc-serialize/tree/json_mod\" rel=\"nofollow\">is here</a> in the branch json_mod. I tried to reproduce the problem in fewer lines of code, but the circular dependencies I created compiled correctly.</p>\n\n<p>After the debugging, something like 400 errors are left \u2014 this is normal as I am in the process of a huge code refactoring (splitting one file of ~= 4000 line file into many files) and I still have a lot of work to do before making it work.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "edited": false, "score": 0, "creation_date": 1430582004, "post_id": 30004175, "comment_id": 48126994, "body": "I would recommend posting questions like &quot;Is this code idiomatic?&quot; to <a href=\"http://codereview.stackexchange.com/\">codereview.stackexchange.com</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "edited": false, "score": 5, "creation_date": 1430582106, "post_id": 30004175, "comment_id": 48127025, "body": "@Adrian I agree, but Code Review requires <i>working code</i>, which this doesn&#39;t seem to be, yet."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1430590240, "post_id": 30004175, "comment_id": 48129986, "body": "By the way, why use <code>Rc</code>? Normally expressions form tree, so the unique owner of an <code>Expr</code> is the outer <code>Expr</code> that contains it. I don&#39;t think it would solve any of your compilation errors, but it&#39;s certainly not idiomatic to use <code>Rc</code> needlessly. <code>String</code>, however, is just fine when a string slice is not appropriate or too much pain."}, {"owner": {"reputation": 46453, "user_id": 13924, "user_type": "registered", "accept_rate": 45, "profile_image": "https://i.stack.imgur.com/rRkqv.jpg?s=128&g=1", "display_name": "J D", "link": "https://stackoverflow.com/users/13924/j-d"}, "edited": false, "score": 0, "creation_date": 1515968367, "post_id": 30004175, "comment_id": 83492106, "body": "@delnan: &quot;Normally expressions form tree&quot;. Normally expressions for a DAG due to sharing of subexpressions. In that case there is no unique owner at compile time in the general case so you need to resort to a more general form of memory management. In the absence of a tracing GC, reference counting is the next most logical option although it is slower and leaks cycles."}], "answers": [{"comments": [{"owner": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "edited": false, "score": 1, "creation_date": 1430589735, "post_id": 30005235, "comment_id": 48129814, "body": "thank you for the answer, but there is something I don&#39;t understand about return values. I thought this was an antipattern for a function in Rust to return a pointer."}, {"owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "reply_to_user": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "edited": false, "score": 1, "creation_date": 1430589985, "post_id": 30005235, "comment_id": 48129906, "body": "It is not necessarily a bad idea to return a pointer/reference from a function. Generally, in Rust, you would return a pointer/reference in the same situations that you would return one in C/C++. For example, there are functions which return references in your code: <code>env.get(a).unwrap()</code> returns a <code>&amp;Expr</code>."}, {"owner": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "edited": false, "score": 1, "creation_date": 1430592098, "post_id": 30005235, "comment_id": 48130571, "body": "thanks ! I still have trouble to get the code right if the return value is a <code>Rc</code> pointer. I would like to replace the line <code>match (a.evaluate(env), b.evaluate(env))</code> with <code>match (*a.evaluate(env), *b.evaluate(env))</code> but those values are owned by the <code>Rc</code> container and cannot be moved."}, {"owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "reply_to_user": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "edited": false, "score": 1, "creation_date": 1430592505, "post_id": 30005235, "comment_id": 48130718, "body": "The expression <code>*a.evaluate(env)</code> is invalid because <code>a.evaluate(env)</code> isn&#39;t a reference or pointer. It&#39;s a <code>Expr</code>."}, {"owner": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "edited": false, "score": 1, "creation_date": 1430594424, "post_id": 30005235, "comment_id": 48131342, "body": "Sorry, I meant in the case where the prototype of <code>evaluate</code> is  <code>fn evaluate(&amp;self, &amp;mut HashMap&lt;String, Expr&gt;) -&gt; Rc&lt;Expr&gt;</code>"}], "tags": [], "owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "is_accepted": true, "score": 2, "last_activity_date": 1430587117, "creation_date": 1430587117, "answer_id": 30005235, "question_id": 30004175, "link": "https://stackoverflow.com/questions/30004175/a-simple-formula-interpreter/30005235#30005235", "title": "A simple formula interpreter", "body": "<p>This question is somewhat subjective, but here are some problems I see:</p>\n\n<hr>\n\n<pre><code>let a_ev = Rc::new(a.evaluate(env));\nlet b_ev = Rc::new(b.evaluate(env));\nmatch (*a_ev, *b_ev) {\n    (Expr::Integer(x), Expr::Integer(y)) =&gt; Expr::Integer(x+y),\n    _ =&gt; Expr::Plus(a_ev,b_ev)\n}\n</code></pre>\n\n<p>Here, you can't dereference <code>a_ev</code> and <code>b_ev</code> because <code>*a_ev</code> is owned by the <code>Rc</code> container holding it. You can fix this error by waiting until you actually need the values to be put in <code>Rc</code> containers to create them:</p>\n\n<pre><code>match (a.evaluate(env), b.evaluate(env)) {\n    (Expr::Integer(x), Expr::Integer(y)) =&gt; Expr::Integer(x + y),\n    (a_ev, b_ev) =&gt; Expr::Plus(Rc::new(a_ev), Rc::new(b_ev))\n}\n</code></pre>\n\n<hr>\n\n<pre><code>Expr::Term(ref a) =&gt; *env.get(&amp;a).unwrap()\n</code></pre>\n\n<p>Here, the variable <code>a</code> has type <code>&amp;String</code>, and so writing <code>&amp;a</code> makes no sense -- it would be like a reference to a reference. That can be fixed by changing <code>&amp;a</code> to <code>a</code>. Also, <code>env.get(a).unwrap()</code> is a reference to a <code>Expr</code> that is owned by the <code>HashMap</code>, so you can't dereference/move it. One solution to this problem would be to use a <code>HashMap&lt;String, Rc&lt;Expr&gt;&gt;</code> instead of a <code>HashMap&lt;String, Expr&gt;</code>. Another would be to simply clone the value:</p>\n\n<pre><code>Expr::Term(ref a) =&gt; env.get(a).unwrap().clone(),\n</code></pre>\n\n<p>In order to be able to clone the value, you must use a \"derive\" compiler directive to say that <code>Expr</code> implements that trait:</p>\n\n<pre><code>#[derive(Clone)]\nenum Expr {   // ...\n</code></pre>\n\n<hr>\n\n<pre><code>let b_ev = Rc::new(b.evaluate(env));\nmatch **a {\n    Expr::Term(x) =&gt; {\n        let x_value = env.get_mut(&amp;x).unwrap();\n         *x_value = *b_ev;\n         *b_ev\n    },\n    // ...\n</code></pre>\n\n<p>Here, you move <code>*b_ev</code> into the <code>HashMap</code> and then try to dereference/move it again by returning it. Also, like above, you have an extra <code>&amp;</code>. Both of these issues can be solved in the same way as above:</p>\n\n<pre><code>let b_ev = b.evaluate(env);\nmatch **a {\n    Expr::Term(ref x) =&gt; {\n        let x_value = env.get_mut(x).unwrap();\n        *x_value = b_ev.clone();\n        b_ev\n    },\n    // ...\n</code></pre>\n\n<hr>\n\n<pre><code>otherwise =&gt; { let a_ev = Rc::new(a.evaluate(env)); // ...\n</code></pre>\n\n<p>Here, you are moving <code>**a</code> into <code>otherwise</code> while it is still owned by an <code>Rc</code> container. Since you don't use <code>otherwise</code>, the problem is easily fixed by replacing it with <code>_</code>:</p>\n\n<pre><code>_ =&gt; { // ...\n</code></pre>\n\n<hr>\n\n<pre><code>otherwise =&gt; otherwise\n</code></pre>\n\n<p>You can't take a value that is owned by something else (<code>*self</code> is owned by something else) and return it by value. You can, however, clone it:</p>\n\n<pre><code>_ =&gt; self.clone()\n</code></pre>\n\n<hr>\n\n<p>Overall, the problem with your code is that it tries to duplicate data in a few places. As I said above, there are two ways of fixing it that I can think of: using <code>Rc&lt;Expr&gt;</code> <em>everywhere</em> instead of <code>Expr</code>, or using <code>clone</code>. Here is a fixed version of your code that compiles and uses <code>clone</code>:</p>\n\n<pre><code>use std::rc::Rc;\nuse std::collections::HashMap;\n\n#[derive(Clone, Debug)]\nenum Expr {\n    Integer(i32),\n    Term(String),\n    Plus(Rc&lt;Expr&gt;, Rc&lt;Expr&gt;),\n    Set(Rc&lt;Expr&gt;, Rc&lt;Expr&gt;),\n}\n\nimpl Expr {\n    fn evaluate(&amp;self, env: &amp;mut HashMap&lt;String, Expr&gt;) -&gt; Expr {\n        match *self {\n            Expr::Plus(ref a, ref b) =&gt; {\n                match (a.evaluate(env), b.evaluate(env)) {\n                    (Expr::Integer(x), Expr::Integer(y)) =&gt; Expr::Integer(x + y),\n                    (a_ev, b_ev) =&gt; Expr::Plus(Rc::new(a_ev), Rc::new(b_ev))\n                }\n            },\n            Expr::Term(ref a) =&gt; env.get(a).unwrap().clone(),\n            Expr::Set(ref a, ref b) =&gt; {\n                let b_ev = b.evaluate(env);\n                match **a {\n                    Expr::Term(ref x) =&gt; {\n                        let x_value = env.get_mut(x).unwrap();\n                        *x_value = b_ev.clone();\n                        b_ev\n                    },\n                    _ =&gt; {\n                        let a_ev = a.evaluate(env);\n                        Expr::Set(Rc::new(a_ev), Rc::new(b_ev))\n                    }\n                }\n            }\n            _ =&gt; self.clone()\n        }\n    }\n}\n\nfn main() {\n    let e = Expr::Plus(Rc::new(Expr::Integer(9)), Rc::new(Expr::Integer(34)));\n    let mut env = HashMap::new();\n\n    println!(\"{:?}\", e.evaluate(&amp;mut env));\n}\n</code></pre>\n\n<p>[<a href=\"http://is.gd/YlFDmy\" rel=\"nofollow\">playpen</a>]</p>\n"}, {"tags": [], "owner": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "is_accepted": false, "score": 0, "last_activity_date": 1515946623, "last_edit_date": 1515946623, "creation_date": 1430638633, "answer_id": 30011393, "question_id": 30004175, "link": "https://stackoverflow.com/questions/30004175/a-simple-formula-interpreter/30011393#30011393", "title": "A simple formula interpreter", "body": "<p>This is a second version where I follow Adrian's suggestion to replace all <code>ExprNode</code> with <code>Rc&lt;ExprNode&gt;</code>. The only cloned variables are <code>Rc</code> pointers, so I guess this just increments a reference count. My only regret is that we lost the method syntax, but I think this can be repaired by defining <code>Expr</code> with a <code>struct</code> instead of a type alias.</p>\n\n<pre><code>use std::rc::Rc;\nuse std::collections::HashMap;\n\n#[derive(Debug)]\nenum ExprNode {\n    Integer(i32),\n    Term(String),\n    Plus(Expr, Expr),\n    Set(Expr, Expr),\n}\n\ntype Expr = Rc&lt;ExprNode&gt;;\n\ntype Env = HashMap&lt;String, Expr&gt;;\n\nfn evaluate(e: &amp;Expr, env: &amp;mut Env) -&gt; Expr {\n    match **e {\n        ExprNode::Plus(ref a, ref b) =&gt; {\n            let a_ev = evaluate(a, env);\n            let b_ev = evaluate(b, env);\n            match (&amp;*a_ev, &amp;*b_ev) {\n                (&amp;ExprNode::Integer(x), &amp;ExprNode::Integer(y)) =&gt; Rc::new(ExprNode::Integer(x + y)),\n                _ =&gt; Rc::new(ExprNode::Plus(a_ev, b_ev)),\n            }\n        }\n        ExprNode::Term(ref a) =&gt; env.get(a).unwrap().clone(),\n        ExprNode::Set(ref a, ref b) =&gt; {\n            let b_ev = evaluate(b, env);\n            match **a {\n                ExprNode::Term(ref x) =&gt; {\n                    let x_value = env.get_mut(x).unwrap();\n                    *x_value = b_ev;\n                    x_value.clone()\n                }\n                _ =&gt; Rc::new(ExprNode::Set(evaluate(a, env), b_ev)),\n            }\n        }\n        _ =&gt; e.clone(),\n    }\n}\n\nfn main() {\n    let e = Rc::new(ExprNode::Plus(\n        Rc::new(ExprNode::Integer(9)),\n        Rc::new(ExprNode::Integer(4)),\n    ));\n    let mut env = HashMap::new();\n\n    println!(\"{:?}\", evaluate(&amp;e, &amp;mut env));\n}\n</code></pre>\n"}], "owner": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 455, "favorite_count": 0, "accepted_answer_id": 30005235, "answer_count": 2, "score": 1, "last_activity_date": 1515946761, "creation_date": 1430581004, "last_edit_date": 1515946761, "question_id": 30004175, "link": "https://stackoverflow.com/questions/30004175/a-simple-formula-interpreter", "title": "A simple formula interpreter", "body": "<p>To understand Rust, I am trying to implement a little formula interpreter.\nAn expression can only be an integer, a sum, a variable (<code>Term</code>) or an assignment (<code>Set</code>). We can then evaluate an expression. Since symbols with no associated values can appear in an expression, its evaluation yields another expression (and not necessarily an integer).</p>\n\n<p>The values of the variables (if there are any) can be found in a hash table.</p>\n\n<pre><code>use std::rc::Rc;\nuse std::collections::HashMap;\n\nenum Expr {\n    Integer(i32),\n    Term(String),\n    Plus(Rc&lt;Expr&gt;, Rc&lt;Expr&gt;),\n    Set(Rc&lt;Expr&gt;, Rc&lt;Expr&gt;),\n}\n\nimpl Expr {\n    fn evaluate(&amp;self, env: &amp;mut HashMap&lt;String, Expr&gt;) -&gt; Expr {\n        match *self {\n            Expr::Plus(ref a, ref b) =&gt; {\n                let a_ev = Rc::new(a.evaluate(env));\n                let b_ev = Rc::new(b.evaluate(env));\n                match (*a_ev, *b_ev) {\n                    (Expr::Integer(x), Expr::Integer(y)) =&gt; Expr::Integer(x + y),\n                    _ =&gt; Expr::Plus(a_ev, b_ev),\n                }\n            }\n            Expr::Term(ref a) =&gt; *env.get(&amp;a).unwrap(),\n            Expr::Set(ref a, ref b) =&gt; {\n                let b_ev = Rc::new(b.evaluate(env));\n                match **a {\n                    Expr::Term(x) =&gt; {\n                        let x_value = env.get_mut(&amp;x).unwrap();\n                        *x_value = *b_ev;\n                        *b_ev\n                    }\n                    otherwise =&gt; {\n                        let a_ev = Rc::new(a.evaluate(env));\n                        Expr::Set(a_ev, b_ev)\n                    }\n                }\n            }\n            otherwise =&gt; otherwise,\n        }\n    }\n}\n</code></pre>\n\n<p>The above code does not compile. Each <code>match</code> seems to borrow a variable. Moreover, I think we should not use the <code>String</code> type, but I can't understand why.</p>\n\n<p>The compilation error:</p>\n\n<blockquote>\n  <pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `std::string::String: std::borrow::Borrow&lt;&amp;std::string::String&gt;` is not satisfied\n  --&gt; src/main.rs:22:39\n   |\n22 |             Expr::Term(ref a) =&gt; *env.get(&amp;a).unwrap(),\n   |                                       ^^^ the trait `std::borrow::Borrow&lt;&amp;std::string::String&gt;` is not implemented for `std::string::String`\n   |\n   = help: the following implementations were found:\n             &lt;std::string::String as std::borrow::Borrow&lt;str&gt;&gt;\n</code></pre>\n</blockquote>\n"}, {"tags": ["testing", "rust", "rust-cargo"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 45, "last_activity_date": 1613272783, "last_edit_date": 1613272783, "creation_date": 1430581504, "answer_id": 30004252, "question_id": 30003921, "link": "https://stackoverflow.com/questions/30003921/how-can-i-locate-resources-for-testing-with-cargo/30004252#30004252", "title": "How can I locate resources for testing with Cargo?", "body": "<p>The environment variable <a href=\"https://doc.rust-lang.org/cargo/reference/environment-variables.html\" rel=\"nofollow noreferrer\"><code>CARGO_MANIFEST_DIR</code></a> can give you a stable base point to reference other files. Here, we assume that there's a <code>resources/test</code> directory at the top level of the crate:</p>\n<pre><code>use std::path::PathBuf;\n\nfn main() {\n    let mut d = PathBuf::from(env!(&quot;CARGO_MANIFEST_DIR&quot;));\n    d.push(&quot;resources/test&quot;);\n\n    println!(&quot;{}&quot;, d.display());\n}\n</code></pre>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/27840394/155423\">How can a Rust program access metadata from its Cargo package?</a></li>\n</ul>\n"}], "owner": {"reputation": 730, "user_id": 4382650, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e636f2f5c51d67a92f0505e5171757f7?s=128&d=identicon&r=PG&f=1", "display_name": "L&#233;o Ercolanelli", "link": "https://stackoverflow.com/users/4382650/l%c3%a9o-ercolanelli"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4666, "favorite_count": 2, "accepted_answer_id": 30004252, "answer_count": 1, "score": 27, "last_activity_date": 1613272783, "creation_date": 1430579535, "last_edit_date": 1560962662, "question_id": 30003921, "link": "https://stackoverflow.com/questions/30003921/how-can-i-locate-resources-for-testing-with-cargo", "title": "How can I locate resources for testing with Cargo?", "body": "<p>I'm on a project interacting with files, and I would like to use text files to test my work. However tests aren't run from the <code>tests/</code> directory, and thus I cannot reliably find them when running <code>cargo run</code>.  </p>\n\n<p>Does Cargo handle this by always running test from the root directory (which seems to be the case but I didn't find anything attesting it)?</p>\n"}, {"tags": ["vector", "rust"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 17, "last_activity_date": 1430542720, "creation_date": 1430542720, "answer_id": 29998582, "question_id": 29998515, "link": "https://stackoverflow.com/questions/29998515/whats-the-idiomatic-way-to-append-a-slice-to-a-vector/29998582#29998582", "title": "What&#39;s the idiomatic way to append a slice to a vector?", "body": "<pre><code>v.extend(s.iter().cloned());\n</code></pre>\n\n<p>That is effectively equivalent to using <code>.map(|&amp;i| i)</code> and it does <em>minimal</em> copying.</p>\n\n<p>The problem is that you absolutely <em>cannot</em> avoid copying in this case.  You cannot simply move the values because a slice <em>does not own its contents</em>, thus it can only take a copy.</p>\n\n<p>Now, that said, there are two things to consider:</p>\n\n<ol>\n<li><p>Rust tends to inline rather aggressively; there is enough information in this code for the compiler to just copy the values directly into the destination without any intermediate step.</p></li>\n<li><p>Closures in Rust aren't like closures in most other languages: they don't require heap allocation and can be directly inlined, thus making them no less efficient than hard-coding the behaviour directly.</p></li>\n</ol>\n\n<p>Do keep in mind that the above two are dependent on optimisation: they'll generally work out for the best, but aren't guaranteed.</p>\n\n<hr>\n\n<p><em>But having said that...</em> what you're actually trying to do here in this <em>specific</em> example is append a stack-allocated array which you <em>do</em> own.  I'm not aware of any library code that can actually take advantage of this fact (support for array values is rather weak in Rust at the moment), but theoretically, you could effectively create an <code>into_iter()</code> equivalent using unsafe code... but I don't recommend it, and it's probably not worth the hassle.</p>\n"}, {"comments": [{"owner": {"reputation": 1143, "user_id": 11588505, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cc506473f38d0dc9a703179a853a1ebf?s=128&d=identicon&r=PG&f=1", "display_name": "Camelid", "link": "https://stackoverflow.com/users/11588505/camelid"}, "edited": false, "score": 0, "creation_date": 1609039062, "post_id": 30022230, "comment_id": 115735467, "body": "This appears to no longer work. Maybe it was removed before 1.0? (Weird though because 1.0 was released just 11 days after this answer was posted....)"}], "tags": [], "owner": {"reputation": 126, "user_id": 3281907, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/167b5d70056ea34fa24058a251d63964?s=128&d=identicon&r=PG", "display_name": "kbknapp", "link": "https://stackoverflow.com/users/3281907/kbknapp"}, "is_accepted": false, "score": 2, "last_activity_date": 1430710551, "creation_date": 1430710551, "answer_id": 30022230, "question_id": 29998515, "link": "https://stackoverflow.com/questions/29998515/whats-the-idiomatic-way-to-append-a-slice-to-a-vector/30022230#30022230", "title": "What&#39;s the idiomatic way to append a slice to a vector?", "body": "<p>I can't speak for the full performance implications, but <code>v + &amp;s</code> will work on beta, which I believe is just similar to pushing each value onto the original Vec.</p>\n"}, {"tags": [], "owner": {"reputation": 2105, "user_id": 870079, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/58fd7fa8ab09a8a4c7b204f67e3f818e?s=128&d=identicon&r=PG", "display_name": "heinrich5991", "link": "https://stackoverflow.com/users/870079/heinrich5991"}, "is_accepted": true, "score": 74, "last_activity_date": 1457742465, "creation_date": 1457742465, "answer_id": 35952229, "question_id": 29998515, "link": "https://stackoverflow.com/questions/29998515/whats-the-idiomatic-way-to-append-a-slice-to-a-vector/35952229#35952229", "title": "What&#39;s the idiomatic way to append a slice to a vector?", "body": "<p>There's a method that does exactly this: <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.extend_from_slice\" rel=\"noreferrer\"><code>Vec::extend_from_slice</code></a></p>\n\n<p>Example:</p>\n\n<pre><code>let s = [0u8, 1, 2];\nlet mut v = Vec::new();\nv.extend_from_slice(&amp;s); \n</code></pre>\n"}], "owner": {"reputation": 1582, "user_id": 1079493, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/dfc87059a3d24c9f85993c85e7c55a05?s=128&d=identicon&r=PG", "display_name": "Kai", "link": "https://stackoverflow.com/users/1079493/kai"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 21702, "favorite_count": 2, "accepted_answer_id": 35952229, "answer_count": 3, "score": 39, "last_activity_date": 1481951104, "creation_date": 1430542147, "last_edit_date": 1481951104, "question_id": 29998515, "link": "https://stackoverflow.com/questions/29998515/whats-the-idiomatic-way-to-append-a-slice-to-a-vector", "title": "What&#39;s the idiomatic way to append a slice to a vector?", "body": "<p>I have a slice of <code>&amp;[u8]</code> and I'd like to append it to a <code>Vec&lt;u8&gt;</code> with minimal copying. Here are two approaches that I know work:</p>\n\n<pre><code>let s = [0u8, 1u8, 2u8];\nlet mut v = Vec::new();\nv.extend(s.iter().map(|&amp;i| i));\nv.extend(s.to_vec().into_iter()); // allocates an extra copy of the slice\n</code></pre>\n\n<p>Is there a better way to do this in Rust stable? (<code>rustc 1.0.0-beta.2</code>)</p>\n"}, {"tags": ["rust", "httpserver"], "comments": [{"owner": {"reputation": 1217, "user_id": 881195, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/n74Mq.jpg?s=128&g=1", "display_name": "Tupshin Harper", "link": "https://stackoverflow.com/users/881195/tupshin-harper"}, "edited": false, "score": 0, "creation_date": 1430532236, "post_id": 29996909, "comment_id": 48114653, "body": "I have an example that does what you want.  <a href=\"https://github.com/tupshin/CastIron/blob/master/src/main.rs\" rel=\"nofollow noreferrer\">github.com/tupshin/CastIron/blob/master/src/main.rs</a> it creates a struct that wraps an local state that it needs to pass (note that Session is a FFI wrapper around a C++ thread-safe db session object), wraps it in an Arc, clones the Arc twice into explicitly named variables, and then uses closure move semantics to move each copy into the closure so it doesn&#39;t outlive the parent. That was the cleanest approach I could come up with."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1430922691, "post_id": 29996909, "comment_id": 48272729, "body": "I wonder if <a href=\"http://stackoverflow.com/a/29618235/155423\">this answer</a> would be of any use, especially the paragraph beginning with &quot;I&#39;m no expert&quot;."}], "answers": [{"comments": [{"owner": {"reputation": 1606, "user_id": 559833, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0cf07c8cc2ec5892dd92722bf28e07e1?s=128&d=identicon&r=PG", "display_name": "Gyscos", "link": "https://stackoverflow.com/users/559833/gyscos"}, "edited": false, "score": 0, "creation_date": 1430930427, "post_id": 30077830, "comment_id": 48278422, "body": "Thank you very much! I now understand the issues coming from the &#39;static requirement on the middleware. Unfortunately, it seems hyper does that too ( <a href=\"http://hyperium.github.io/hyper/hyper/server/struct.Server.html#method.http\" rel=\"nofollow noreferrer\">hyperium.github.io/hyper/hyper/server/&hellip;</a> ), so it seems logical that iron and nickel, both using hyper, apply the same restrictions... I didn&#39;t know about thread_local, it seems interesting, I will investigate."}, {"owner": {"reputation": 1606, "user_id": 559833, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0cf07c8cc2ec5892dd92722bf28e07e1?s=128&d=identicon&r=PG", "display_name": "Gyscos", "link": "https://stackoverflow.com/users/559833/gyscos"}, "edited": false, "score": 0, "creation_date": 1430933873, "post_id": 30077830, "comment_id": 48280680, "body": "For now, I&#39;m working an a simple private project, so I think I&#39;ll go the unsafe route, but I&#39;m curious - what is the price for thread_local? Is this a simple unsafe wrapper, or is there an actual performance impact? Oh, or this means multiple HTTP calls will end up in different threads, and access independent copies of the data?"}, {"owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "reply_to_user": {"reputation": 1606, "user_id": 559833, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0cf07c8cc2ec5892dd92722bf28e07e1?s=128&d=identicon&r=PG", "display_name": "Gyscos", "link": "https://stackoverflow.com/users/559833/gyscos"}, "edited": false, "score": 0, "creation_date": 1430937828, "post_id": 30077830, "comment_id": 48283134, "body": "You&#39;re welcome! I know that some thread-locals can be very fast (<a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Thread-Local.html\" rel=\"nofollow noreferrer\">gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Thread-Local.html</a>) but I don&#39;t know yet how they fare in Rust. The thread-local will only be available on the same thread that set it. If the web-server uses multiple threads then you&#39;ll have to adjust your implementation strategy."}], "tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": true, "score": 1, "last_activity_date": 1430937889, "last_edit_date": 1430937889, "creation_date": 1430917916, "answer_id": 30077830, "question_id": 29996909, "link": "https://stackoverflow.com/questions/29996909/share-immutable-reference-in-a-http-server/30077830#30077830", "title": "Share immutable reference in a HTTP Server", "body": "<p>Note that I have no prior experience with Nickel or Iron (personally I'm using SCGI so far).</p>\n\n<p>The error I got compiling your Nickel example is:</p>\n\n<pre><code>&lt;nickel macros&gt;:7:9: 7:70 error: captured variable `obj` does not outlive the enclosing closure\n</code></pre>\n\n<p>The error happens in the following snippet:</p>\n\n<pre><code>server.utilize(router! {\n    get \"/foo\" =&gt; |_req, _res| {\n        obj.foo();\n    }\n});\n</code></pre>\n\n<p>Now, <code>router!</code> is just a fancy macros to wrap your closure in a <code>Middleware</code>, with some additional checks built in. For our investigation we might want to get to the roots and use the <code>Middleware</code> directly.</p>\n\n<p>Unfortunately Nickel explicitly requires the <a href=\"http://docs.nickel.rs/nickel/trait.Middleware.html\" rel=\"nofollow\">Middleware</a> to have a <code>'static</code> lifetime. That's a quirk of the Nickel API design and doesn't have much with Rust per se (except for the fact that Rust allows the library to require such things from the user).</p>\n\n<p>I see two options then. First is to use our superior knowledge of the object lifetime (Nickel doesn't know that our object outlives the server but we do) and tell the compiler so. Compiler allows us to show our superiour knowledge with the helpful <code>unsafe</code> and <code>transmute</code> primitives.</p>\n\n<p>Here it is, working: <a href=\"https://gist.github.com/ArtemGr/cae521d49677a905d63c#file-unsafe-rs\" rel=\"nofollow\">unsafe.rs</a>.</p>\n\n<p>In Rust <code>unsafe</code> means \"this piece of code is safe because the programmer said so\". Every <code>unsafe</code> piece must satisfy this safety contract between the programmer and the compiler. In this case we know that the object outlives the server so the safety guarantee is maintained.</p>\n\n<p>The second option is to pay the price for tricks that would satisfy the requirements of the Nickel API. Here we use a scoped thread-local storage for this: <a href=\"https://gist.github.com/ArtemGr/cae521d49677a905d63c#file-thread_local-rs\" rel=\"nofollow\">thread_local.rs</a>.</p>\n\n<p>Bottom line: Nickel API has requirements that make you jump through some hoops to get you where you want. I haven't investigated the Iron API. I have a feeling that you might have a better luck with the lower-level Hyper API.</p>\n"}], "owner": {"reputation": 1606, "user_id": 559833, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0cf07c8cc2ec5892dd92722bf28e07e1?s=128&d=identicon&r=PG", "display_name": "Gyscos", "link": "https://stackoverflow.com/users/559833/gyscos"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 471, "favorite_count": 0, "accepted_answer_id": 30077830, "answer_count": 1, "score": 1, "last_activity_date": 1430937889, "creation_date": 1430525874, "last_edit_date": 1430758521, "question_id": 29996909, "link": "https://stackoverflow.com/questions/29996909/share-immutable-reference-in-a-http-server", "title": "Share immutable reference in a HTTP Server", "body": "<p>I'm currently building a HTTP service exposing actions on a unique object.\nI already created the central object, with several methods taking immutable <code>&amp;self</code> references, and using internally various efficient synchronization structures to access the data inside (all the code is unsafe-free). My thought was that this would be enough to make it safe to use concurrently.</p>\n\n<p>And then comes the hard part of actually connecting it to a HTTP server.\nI'm currently trying to use Iron, but I could switch to Nickel.rs or any other if it makes things easier.</p>\n\n<p>Most HTTP server examples I saw used stateless handlers, without any access to local variables. I now understand why: it's near-impossible to do.</p>\n\n<p>Here is an example of what I'd like to do, using Nickel.rs:\n<a href=\"https://gist.github.com/Gyscos/42510a335098ce935848\" rel=\"nofollow\">https://gist.github.com/Gyscos/42510a335098ce935848</a></p>\n\n<p>Here is a similar failed attempt using Iron:\n<a href=\"https://gist.github.com/Gyscos/92e56e95baee0ebce78f\" rel=\"nofollow\">https://gist.github.com/Gyscos/92e56e95baee0ebce78f</a></p>\n\n<p>The basic idea being that obj only lives for the duration of the scope, but so does server, so it shouldn't be a big deal... right?</p>\n\n<p>Unfortunately each of my attempts failed. When trying to give the server a closure that accesses self.object, I get an error saying that the closure might outlive the reference.</p>\n\n<p>I saw Iron provided a shared memory module with a Read structure. Not only does it look overly complicated for my needs, I also would like to avoid paying the Arc price when I don't need it (I have a clear view of the lifecycle of the object and really don't need to count references).</p>\n\n<p>The current solution I see would be to have a static Object and use that instead of one specific to MyServer, but I'd prefer to avoid this level of ugliness if possible.</p>\n\n<p>I come from golang, where this is not a problem (I could use object-bound methods as handler for that). So my question is: how do you easily access a shared immutable reference from your HTTP handlers in Rust?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 0, "creation_date": 1430518284, "post_id": 29995257, "comment_id": 48111309, "body": "cf. <a href=\"http://www.reddit.com/r/rust/comments/334434/trouble_with_modules/\" rel=\"nofollow noreferrer\">reddit.com/r/rust/comments/334434/trouble_with_modules</a>"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 2, "creation_date": 1430522463, "post_id": 29995257, "comment_id": 48112589, "body": "The <code>lib.rs</code> says the crate name is &quot;bar&quot;, which is probably wrong. It doesn&#39;t fit the error message, but maybe the diagnostic is just bad. (Also, how do you compile these crates?)"}, {"owner": {"reputation": 2308, "user_id": 1120799, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/IRCQ4.jpg?s=128&g=1", "display_name": "Abhishek Chanda", "link": "https://stackoverflow.com/users/1120799/abhishek-chanda"}, "edited": false, "score": 0, "creation_date": 1430533726, "post_id": 29995257, "comment_id": 48114924, "body": "@delnan sorry, I misplaced a number of names while trying to remove non open sourced information. Updated the code now, the diagnostics is good. I&#39;ve been compiling bar by <code>cargo build</code> and uploaded it to crates.io,  the test crate pulls in that as a cargo dependency."}], "answers": [{"comments": [{"owner": {"reputation": 2308, "user_id": 1120799, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/IRCQ4.jpg?s=128&g=1", "display_name": "Abhishek Chanda", "link": "https://stackoverflow.com/users/1120799/abhishek-chanda"}, "edited": false, "score": 0, "creation_date": 1430640217, "post_id": 29997783, "comment_id": 48141236, "body": "Thanks for explaining that. <code>bar::bar::baz</code> did work, but I decided that it&#39;s not how I want it to look. Now when I copied the contents of <code>bar.rs</code> to <code>lib.rs</code>, I still cant access <code>baz</code> as <code>use bar::baz</code>, while <code>bar::bar::baz</code> works. Shouldn&#39;t <code>bar::baz</code> work now?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2308, "user_id": 1120799, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/IRCQ4.jpg?s=128&g=1", "display_name": "Abhishek Chanda", "link": "https://stackoverflow.com/users/1120799/abhishek-chanda"}, "edited": false, "score": 0, "creation_date": 1430678732, "post_id": 29997783, "comment_id": 48153159, "body": "@AbhishekChanda you copied the contents of <code>bar.rs</code> to <code>lib.rs</code> directly, without wrapping it in <code>mod bar { ... }</code>, correct? If so, and <code>use bar::bar::baz</code> still works, then it sounds like you aren&#39;t correctly specifying or compiling your dependencies. I assume you are using Cargo?"}, {"owner": {"reputation": 2308, "user_id": 1120799, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/IRCQ4.jpg?s=128&g=1", "display_name": "Abhishek Chanda", "link": "https://stackoverflow.com/users/1120799/abhishek-chanda"}, "edited": false, "score": 0, "creation_date": 1430783597, "post_id": 29997783, "comment_id": 48199690, "body": "yes, using cargo. And yes, my module structure was messed up. Cleaned up, thanks for your help :)"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1510753982, "last_edit_date": 1510753982, "creation_date": 1430534364, "answer_id": 29997783, "question_id": 29995257, "link": "https://stackoverflow.com/questions/29995257/cant-import-a-module-from-another-crate-unresolved-import/29997783#29997783", "title": "Can&#39;t import a module from another crate - unresolved import", "body": "<p>The important part you are missing is that crates define their own module. That is, your crate <code>bar</code> implicitly defines a module called <code>bar</code>, but you also have created a module called <code>bar</code> <em>inside that</em>. Your struct resides within this nested module.</p>\n\n<p>If you change your main to <code>use bar::bar::baz;</code> you can progress past this. You will have to decide if that's the structure you want though. Most idiomatic Rust projects would not have the extra <code>mod</code> and would flatten it out:</p>\n\n<p><strong>src/lib.rs</strong></p>\n\n<pre><code>pub struct Baz {\n    // stuff\n}\n\nimpl Baz {\n    // stuff\n}\n</code></pre>\n\n<p>Unfortunately, your example code cannot compile, as you have invalid struct definitions, and you call methods that don't exist (<code>new</code>), so I can't tell you what else it will take to compile.</p>\n\n<p>Also, structs should be <code>PascalCase</code>.</p>\n"}], "owner": {"reputation": 2308, "user_id": 1120799, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/IRCQ4.jpg?s=128&g=1", "display_name": "Abhishek Chanda", "link": "https://stackoverflow.com/users/1120799/abhishek-chanda"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1496, "favorite_count": 0, "accepted_answer_id": 29997783, "answer_count": 1, "score": 1, "last_activity_date": 1510753982, "creation_date": 1430514917, "last_edit_date": 1430533554, "question_id": 29995257, "link": "https://stackoverflow.com/questions/29995257/cant-import-a-module-from-another-crate-unresolved-import", "title": "Can&#39;t import a module from another crate - unresolved import", "body": "<p>I am trying to write a crate called <code>bar</code>, the structure looks like this</p>\n\n<pre><code>src/\n\u251c\u2500\u2500 bar.rs\n\u2514\u2500\u2500 lib.rs\n</code></pre>\n\n<p>My <code>src/lib.rs</code> looks like this</p>\n\n<pre><code>#![crate_type = \"lib\"]\n#![crate_name = \"bar\"]\n#![feature(ip_addr)]\n#[allow(dead_code)]\npub mod bar;\n</code></pre>\n\n<p>My <code>bar.rs</code> has</p>\n\n<pre><code>pub struct baz {\n  // stuff\n}\n\nimpl baz {\n  // stuff\n}\n</code></pre>\n\n<p>Now when I try to use this crate in another crate like:</p>\n\n<pre><code>extern crate bar;\n\nuse bar::baz;\n\nfn main() {\n    let cidr = baz::new(\"Hi\");\n    println!(\"{}\", cidr.say());\n}\n</code></pre>\n\n<p>This fails with </p>\n\n<pre><code>error: unresolved import `bar::baz`. There is no `baz` in `bar`\n</code></pre>\n\n<p>Do I need to declare the module somewhere else?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "edited": false, "score": 0, "creation_date": 1430508185, "post_id": 29993058, "comment_id": 48106622, "body": "thanks, I did not know there was a <code>return</code> keyword. This is useful !"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1507727979, "last_edit_date": 1507727979, "creation_date": 1430505890, "answer_id": 29993058, "question_id": 29992951, "link": "https://stackoverflow.com/questions/29992951/mixing-mutable-and-immutable-references-to-a-hashmap/29993058#29993058", "title": "Mixing mutable and immutable references to a HashMap", "body": "<p>This is a great time to use the <a href=\"http://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry\" rel=\"nofollow noreferrer\"><code>entry</code></a> method:</p>\n\n<pre><code>use std::collections::HashMap;\n\nfn get_or_insert(table: &amp;mut HashMap&lt;i32, i32&gt;, key: i32) -&gt; i32 {\n    *table.entry(key).or_insert(0)\n}\n\nfn main() {}\n</code></pre>\n\n<p>But you are correct, otherwise you'd have to split the call:</p>\n\n<pre><code>fn get_or_insert(table: &amp;mut HashMap&lt;i32, i32&gt;, key: i32) -&gt; i32 {\n    match table.get(&amp;key) {\n        None =&gt; {}\n        Some(v) =&gt; return *v,\n    }\n\n    table.insert(key, 0).unwrap()\n}\n</code></pre>\n\n<p>However, you have to calculate the hash a second time, which is part of the reason that <code>entry</code> was created.</p>\n\n<p>As a side note, <code>insert</code> returns the <em>previous value</em> for the key. If I'm reading it correctly, your <code>unwrap</code> call will always fail.</p>\n"}], "owner": {"reputation": 1479, "user_id": 4673683, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/106a6b52825462b10ef0904466351c00?s=128&d=identicon&r=PG", "display_name": "user19018", "link": "https://stackoverflow.com/users/4673683/user19018"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 640, "favorite_count": 0, "closed_date": 1507727901, "accepted_answer_id": 29993058, "answer_count": 1, "score": 2, "last_activity_date": 1507727979, "creation_date": 1430505525, "last_edit_date": 1507727874, "question_id": 29992951, "link": "https://stackoverflow.com/questions/29992951/mixing-mutable-and-immutable-references-to-a-hashmap", "closed_reason": "Duplicate", "title": "Mixing mutable and immutable references to a HashMap", "body": "<p>I want to create a function which gets the value associated to a key in a hashtable, and, if such value does not exist, inserts an arbitrary value (let us say 0).</p>\n\n<pre><code>use std::collections::HashMap;\n\nfn get_or_insert(table: &amp;mut HashMap&lt;i32, i32&gt;, key: i32) -&gt; i32 {\n    match table.get(&amp;key) {\n        None =&gt; table.insert(key, 0).unwrap(),\n        Some(v) =&gt; *v,\n    }\n}\n</code></pre>\n\n<p>This code does not compile:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `*table` as mutable because it is also borrowed as immutable\n --&gt; src/main.rs:5:17\n  |\n4 |     match table.get(&amp;key) {\n  |           ----- immutable borrow occurs here\n5 |         None =&gt; table.insert(key, 0).unwrap(),\n  |                 ^^^^^ mutable borrow occurs here\n6 |         Some(v) =&gt; *v,\n7 |     }\n  |     - immutable borrow ends here\n</code></pre>\n\n<p>Indeed, <code>table</code> is mutably borrowed in the method <code>insert</code> whereas it is immutably borrowed in the method <code>get</code>.</p>\n\n<p>I can see no way to separate the mutable and immutable parts in this function.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 33, "user_id": 361358, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/28e4f255f725a0e3b975f58104d000e0?s=128&d=identicon&r=PG", "display_name": "Ilya S", "link": "https://stackoverflow.com/users/361358/ilya-s"}, "edited": false, "score": 0, "creation_date": 1430487206, "post_id": 29987501, "comment_id": 48094851, "body": "Thank you, this makes sense. What are good ways to fix this? I see that I can avoid this just by separating sdl_ctx and renderer, e.g.      fn event_loop(&amp;sdl_ctx, &amp;mut renderer) {         ...     }  but what to do if I want to keep all SDL-related data in one structure?"}, {"owner": {"reputation": 33, "user_id": 361358, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/28e4f255f725a0e3b975f58104d000e0?s=128&d=identicon&r=PG", "display_name": "Ilya S", "link": "https://stackoverflow.com/users/361358/ilya-s"}, "edited": false, "score": 0, "creation_date": 1430488053, "post_id": 29987501, "comment_id": 48095340, "body": "&quot;A way to work around this is to directly call methods on the member variables&quot; - this works fine, thanks again."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1430486622, "last_edit_date": 1430486622, "creation_date": 1430486008, "answer_id": 29987501, "question_id": 29987374, "link": "https://stackoverflow.com/questions/29987374/the-immutable-borrow-prevents-mutable-borrows-when-pumping-events-with-rust-sd/29987501#29987501", "title": "&quot;the immutable borrow prevents mutable borrows&quot; when pumping events with rust-sdl2", "body": "<blockquote>\n  <p>the call to <code>self.event_pump</code> should temporarily borrow <code>*self</code></p>\n</blockquote>\n\n<p>Yup</p>\n\n<blockquote>\n  <p>then return <code>EventPump</code> struct which is now owned by <code>event_loop</code> and release <code>*self</code></p>\n</blockquote>\n\n<p>Nope. This is your method:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn event_pump(&amp;self) -&gt; sdl2::event::EventPump {\n    self.sdl_ctx.event_pump()\n}\n</code></pre>\n\n<p>Before lifetime elision, it would look like:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn event_pump&lt;'a&gt;(&amp;'a self) -&gt; sdl2::event::EventPump&lt;'a&gt; {\n    self.sdl_ctx.event_pump()\n}\n</code></pre>\n\n<p>The <code>EventPump</code> struct <a href=\"https://github.com/AngryLawyer/rust-sdl2/blob/master/src/sdl2/event.rs#L905-L912\" rel=\"nofollow\">looks like</a>:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub struct EventPump&lt;'sdl&gt; {\n    _sdl:    PhantomData&lt;&amp;'sdl ()&gt;,\n\n    // Prevents the event pump from moving to other threads.\n    // SDL events can only be pumped on the main thread.\n    _nosend: PhantomData&lt;*mut ()&gt;\n}\n</code></pre>\n\n<p>When you borrow <code>self.sdl_ctx</code>, you are also borrowing <code>self</code>. The borrow checker has fine-grained checks <em>within</em> a function, but not <em>across</em> function calls. Checking across calls would be very expensive, if it's even technically possible.</p>\n\n<p>A way to work around this is to directly call methods on the member variables - instead of creating your own <code>event_pump</code> method, just inline it. Often this leads to creating finer-grained structs.</p>\n"}], "owner": {"reputation": 33, "user_id": 361358, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/28e4f255f725a0e3b975f58104d000e0?s=128&d=identicon&r=PG", "display_name": "Ilya S", "link": "https://stackoverflow.com/users/361358/ilya-s"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 428, "favorite_count": 0, "accepted_answer_id": 29987501, "answer_count": 1, "score": 0, "last_activity_date": 1430486622, "creation_date": 1430485495, "last_edit_date": 1430486110, "question_id": 29987374, "link": "https://stackoverflow.com/questions/29987374/the-immutable-borrow-prevents-mutable-borrows-when-pumping-events-with-rust-sd", "title": "&quot;the immutable borrow prevents mutable borrows&quot; when pumping events with rust-sdl2", "body": "<p>After learning Rust for a while, I started to think that I understood its ownership/borrowing mechanism, but the next example makes me really puzzled. I am playing with <a href=\"https://github.com/AngryLawyer/rust-sdl2\" rel=\"nofollow\">rust-sdl2</a>:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>extern crate sdl2;\n\nuse sdl2::Sdl;\nuse sdl2::event::Event;\nuse sdl2::render::Renderer;\n\nstruct SdlDriver&lt;'a&gt; {\n    sdl_ctx  : Sdl,\n    renderer : Renderer&lt;'a&gt;\n}\n\nimpl&lt;'a&gt; SdlDriver&lt;'a&gt; {\n    fn event_pump(&amp;self) -&gt; sdl2::event::EventPump {\n        self.sdl_ctx.event_pump()\n    }\n\n    fn draw_rect(&amp;mut self, x: i32, y: i32) {\n        let mut drawer = self.renderer.drawer();\n        drawer.draw_rect(sdl2::rect::Rect::new(x-20, y-20, 40, 40));\n        drawer.present();\n    }\n\n    fn event_loop(&amp;mut self) {\n        let mut event_pump = self.event_pump();\n\n        loop {\n            let event = event_pump.wait_event();\n\n            match event {\n                Event::Quit {..} =&gt; { break },\n                Event::MouseMotion { x, y, .. } =&gt; { \n                    self.draw_rect(x, y);\n                },\n                _ =&gt; ()\n            }\n        }\n    }\n}\n\nfn main() {\n}\n</code></pre>\n\n<p>The compiler shows me the error:</p>\n\n<pre><code>main.rs:32:25: 32:29 error: cannot borrow `*self` as mutable because it is also borrowed as immutable\nmain.rs:32                         self.draw_rect(x, y);\n                                   ^~~~\nmain.rs:24:34: 24:38 note: previous borrow of `*self` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `*self` until the borrow ends\nmain.rs:24             let mut event_pump = self.event_pump();\n                                            ^~~~\nmain.rs:37:10: 37:10 note: previous borrow ends here\nmain.rs:23         fn event_loop(&amp;mut self) {\n...\nmain.rs:37         }\n                   ^\n</code></pre>\n\n<p>As I understand it, the call to <code>self.event_pump()</code> should temporarily borrow <code>*self</code>, return <code>EventPump</code> struct which is now owned by <code>event_loop()</code>, and then release <code>*self</code>. But it looks like <code>*self</code> is borrowed for the entire lifetime of <code>event_pump</code>. Why?</p>\n\n<p>For comparison, when I call methods without returning results, like</p>\n\n<pre><code>self.draw_rect(x, y);\nself.draw_rect(x, y);\n</code></pre>\n\n<p>everything works fine, <code>*self</code> is released immediately after every call.</p>\n\n<p>Another thing I don't understand is why <code>*self</code> is borrowed (with star)? <code>event_loop(&amp;mut self)</code> already borrows <code>self</code> from its caller, why is it required to borrow <code>*self</code> here?</p>\n\n<p>How should the example above be rewritten to satisfy Rust's borrow checker?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 229, "user_id": 4255309, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/5wow8.jpg?s=128&g=1", "display_name": "jojo", "link": "https://stackoverflow.com/users/4255309/jojo"}, "edited": false, "score": 0, "creation_date": 1430486537, "post_id": 29986870, "comment_id": 48094505, "body": "thanks, this is exactly what I needed. I&#39;d rep you if I could:)."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 3, "last_activity_date": 1430483392, "creation_date": 1430483392, "answer_id": 29986870, "question_id": 29986493, "link": "https://stackoverflow.com/questions/29986493/how-can-i-implement-a-function-that-returns-a-generic-constrained-by-an-integral/29986870#29986870", "title": "How can I implement a function that returns a generic constrained by an integral type?", "body": "<p>The problem is that generics are type-checked <em>prior</em> to being expanded; this means that the compiler must verify that <code>n as T</code> (where <code>n</code> is an <code>i32</code>) is valid for all possible <code>T</code>.  It isn't.</p>\n\n<p>What you <em>want</em> is to, using a trait, constrain <code>T</code> to types which can be cast from an <code>i32</code>.  Somewhat tragically, this trait does not exist.</p>\n\n<p>The closest analog is probably <code>std::convert::From</code>, but it doesn't implement such basic conversions and you can't provide them yourself.  There used to be some traits that dealt in converting to/from primitive integer types, but I believe they were removed prior to the 1.0 cleanup.</p>\n\n<p>At which point, you're basically on your own.  You need to roll a trait that expresses this conversion, then implement it for the types you care about.  So, you could use a trait such as:</p>\n\n<pre><code>trait FromI32 {\n    fn from_i32(v: i32) -&gt; Self;\n}\n</code></pre>\n\n<p>then change the function to use <code>&lt;T: FromI32&gt;</code> and <code>FromI32::from_i32(n)</code> instead of <code>n as T</code>.</p>\n\n<p>If there are more than a few types for which you want to implement said trait, a simple macro should cut down on the repetition.</p>\n"}], "owner": {"reputation": 229, "user_id": 4255309, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/5wow8.jpg?s=128&g=1", "display_name": "jojo", "link": "https://stackoverflow.com/users/4255309/jojo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 461, "favorite_count": 0, "accepted_answer_id": 29986870, "answer_count": 1, "score": 1, "last_activity_date": 1430485376, "creation_date": 1430481786, "last_edit_date": 1430485376, "question_id": 29986493, "link": "https://stackoverflow.com/questions/29986493/how-can-i-implement-a-function-that-returns-a-generic-constrained-by-an-integral", "title": "How can I implement a function that returns a generic constrained by an integral type?", "body": "<p>How can I implement a function such as the following, where <code>T</code> is an integral type?</p>\n\n<pre><code>fn get_vec&lt;T&gt;() -&gt; Vec&lt;T&gt;\n{\n    let vec: Vec&lt;T&gt; = Vec::new();\n    let n: i32 = 5;\n    let n_as_t = n as T;\n    vec.push(n_as_t);\n    vec\n}\n</code></pre>\n"}, {"tags": ["rust", "macros"], "comments": [{"owner": {"reputation": 6980, "user_id": 1544347, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1ad87bb0303238ee876a147dacd557a1?s=128&d=identicon&r=PG", "display_name": "Markus Unterwaditzer", "link": "https://stackoverflow.com/users/1544347/markus-unterwaditzer"}, "edited": false, "score": 2, "creation_date": 1430480073, "post_id": 29986057, "comment_id": 48091365, "body": "This doesn&#39;t directly answer your question, but whatever you&#39;re doing, it&#39;s probably a bad idea. Please describe your actual usecase for this."}, {"owner": {"reputation": 295, "user_id": 3697018, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c2d6d8638ac5ca493f849639e46202b4?s=128&d=identicon&r=PG&f=1", "display_name": "Joel Hermanns", "link": "https://stackoverflow.com/users/3697018/joel-hermanns"}, "reply_to_user": {"reputation": 6980, "user_id": 1544347, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1ad87bb0303238ee876a147dacd557a1?s=128&d=identicon&r=PG", "display_name": "Markus Unterwaditzer", "link": "https://stackoverflow.com/users/1544347/markus-unterwaditzer"}, "edited": false, "score": 0, "creation_date": 1430481875, "post_id": 29986057, "comment_id": 48092184, "body": "One idea was to create a command line interface for the given struct using the macro. I wanted to deconstruct the struct and create appropriate options/flags based on the type of each field. However, while I&#39;m talking about it now, I&#39;m not sure if  macros are the best way to do this..."}, {"owner": {"reputation": 295, "user_id": 3697018, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c2d6d8638ac5ca493f849639e46202b4?s=128&d=identicon&r=PG&f=1", "display_name": "Joel Hermanns", "link": "https://stackoverflow.com/users/3697018/joel-hermanns"}, "reply_to_user": {"reputation": 6980, "user_id": 1544347, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1ad87bb0303238ee876a147dacd557a1?s=128&d=identicon&r=PG", "display_name": "Markus Unterwaditzer", "link": "https://stackoverflow.com/users/1544347/markus-unterwaditzer"}, "edited": false, "score": 0, "creation_date": 1430482215, "post_id": 29986057, "comment_id": 48092345, "body": "Well, maybe it&#39;s also possible to do that using just Generics and Traits."}], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 25, "last_activity_date": 1430482849, "creation_date": 1430482849, "answer_id": 29986760, "question_id": 29986057, "link": "https://stackoverflow.com/questions/29986057/is-there-a-way-to-get-the-field-names-of-a-struct-in-a-macro/29986760#29986760", "title": "Is there a way to get the field names of a struct in a macro?", "body": "<p>A macro is expanded during parsing, more or less; it has no access to the AST or anything like that\u2014all it has access to is the stuff that you pass to it, which for <code>my_macro!(S)</code> is purely that there should be a type named <code>S</code>.</p>\n\n<p>If you define the struct as part of the macro then you can know about the fields:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>macro_rules! my_macro {\n    (struct $name:ident {\n        $($field_name:ident: $field_type:ty,)*\n    }) =&gt; {\n        struct $name {\n            $($field_name: $field_type,)*\n        }\n\n        impl $name {\n            // This is purely an example\u2014not a good one.\n            fn get_field_names() -&gt; Vec&lt;&amp;'static str&gt; {\n                vec![$(stringify!($field_name)),*]\n            }\n        }\n    }\n}\n\nmy_macro! {\n    struct S {\n        a: String,\n        b: String,\n    }\n}\n\n// S::get_field_names() == vec![\"a\", \"b\"]\n</code></pre>\n\n<p>\u2026 but this is, while potentially useful, often going to be a dubious thing to do.</p>\n"}, {"tags": [], "owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "is_accepted": false, "score": 2, "last_activity_date": 1463688818, "last_edit_date": 1463688818, "creation_date": 1463687813, "answer_id": 37332874, "question_id": 29986057, "link": "https://stackoverflow.com/questions/29986057/is-there-a-way-to-get-the-field-names-of-a-struct-in-a-macro/37332874#37332874", "title": "Is there a way to get the field names of a struct in a macro?", "body": "<p>Here is another possibility that does not require to write a macro (however, the field names will be resolved at run time):</p>\n\n<pre><code>extern crate rustc_serialize;\n\nuse rustc_serialize::json::{Encoder, Json};\nuse rustc_serialize::json::Json::Object;\nuse rustc_serialize::Encodable;\n\n#[derive(Default, RustcEncodable)]\nstruct S {\n    a: String,\n    b: String,\n}\n\nfn main() {\n    let mut json = \"\".to_owned();\n    {\n        let mut encoder = Encoder::new(&amp;mut json);\n        S::default().encode(&amp;mut encoder).unwrap();\n    }\n\n    let json = Json::from_str(&amp;json).unwrap();\n    if let Object(object) = json {\n        let field_names: Vec&lt;_&gt; = object.keys().collect();\n        println!(\"{:?}\", field_names);\n    }\n}\n</code></pre>\n\n<p>(this solution needs the <code>rustc-serialize</code> crate)</p>\n\n<p>The <code>derive(Default)</code> has been added to avoid having to manually create a struct as you wanted (but a struct will still be created).</p>\n\n<p>This solution works by encoding the struct to a <code>String</code> in JSON format and decoding it to a <code>Json</code>. From the <code>Json</code> object, we can extract the field names (if it is an <code>Object</code> variant).</p>\n\n<p>A possibly more efficient method is to write its own encoder:</p>\n\n<pre><code>struct FieldNames {\n    names: Vec&lt;String&gt;,\n}\n\nimpl FieldNames {\n    fn new() -&gt; FieldNames {\n        FieldNames {\n            names: vec![],\n        }\n    }\n}\n\nstruct FieldsEncoder&lt;'a&gt; {\n    fields: &amp;'a mut FieldNames,\n}\n\nimpl&lt;'a&gt; FieldsEncoder&lt;'a&gt; {\n    fn new(fields: &amp;mut FieldNames) -&gt; FieldsEncoder {\n        FieldsEncoder {\n            fields: fields,\n        }\n    }\n}\n\ntype EncoderError = ();\n\nimpl&lt;'a&gt; Encoder for FieldsEncoder&lt;'a&gt; {\n    fn emit_struct&lt;F&gt;(&amp;mut self, _name: &amp;str, _len: usize, f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; {\n        f(self)\n    }\n\n    fn emit_struct_field&lt;F&gt;(&amp;mut self, f_name: &amp;str, _f_idx: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; {\n        self.fields.names.push(f_name.to_owned());\n        Ok(())\n    }\n\n    type Error = EncoderError;\n    fn emit_nil(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_usize(&amp;mut self, _v: usize) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_u64(&amp;mut self, _v: u64) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_u32(&amp;mut self, _v: u32) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_u16(&amp;mut self, _v: u16) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_u8(&amp;mut self, _v: u8) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_isize(&amp;mut self, _v: isize) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_i64(&amp;mut self, _v: i64) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_i32(&amp;mut self, _v: i32) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_i16(&amp;mut self, _v: i16) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_i8(&amp;mut self, _v: i8) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_bool(&amp;mut self, _v: bool) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_f64(&amp;mut self, _v: f64) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_f32(&amp;mut self, _v: f32) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_char(&amp;mut self, _v: char) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_str(&amp;mut self, _v: &amp;str) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_enum&lt;F&gt;(&amp;mut self, _name: &amp;str, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_enum_variant&lt;F&gt;(&amp;mut self, _v_name: &amp;str, _v_id: usize, _len: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_enum_variant_arg&lt;F&gt;(&amp;mut self, _a_idx: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_enum_struct_variant&lt;F&gt;(&amp;mut self, _v_name: &amp;str, _v_id: usize, _len: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_enum_struct_variant_field&lt;F&gt;(&amp;mut self, _f_name: &amp;str, _f_idx: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_tuple&lt;F&gt;(&amp;mut self, _len: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_tuple_arg&lt;F&gt;(&amp;mut self, _idx: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_tuple_struct&lt;F&gt;(&amp;mut self, _name: &amp;str, _len: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_tuple_struct_arg&lt;F&gt;(&amp;mut self, _f_idx: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_option&lt;F&gt;(&amp;mut self, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_option_none(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_option_some&lt;F&gt;(&amp;mut self, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_seq&lt;F&gt;(&amp;mut self, _len: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_seq_elt&lt;F&gt;(&amp;mut self, _idx: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_map&lt;F&gt;(&amp;mut self, _len: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_map_elt_key&lt;F&gt;(&amp;mut self, _idx: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n    fn emit_map_elt_val&lt;F&gt;(&amp;mut self, _idx: usize, _f: F) -&gt; Result&lt;(), Self::Error&gt; where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt; { Err(()) }\n}\n</code></pre>\n\n<p>which can be used as such:</p>\n\n<pre><code>fn main() {\n    let mut fields = FieldNames::new();\n    {\n        let mut encoder = FieldsEncoder::new(&amp;mut fields);\n        S::default().encode(&amp;mut encoder).unwrap();\n    }\n\n    println!(\"{:?}\", fields.names);\n}\n</code></pre>\n"}], "owner": {"reputation": 295, "user_id": 3697018, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c2d6d8638ac5ca493f849639e46202b4?s=128&d=identicon&r=PG&f=1", "display_name": "Joel Hermanns", "link": "https://stackoverflow.com/users/3697018/joel-hermanns"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 7736, "favorite_count": 4, "accepted_answer_id": 29986760, "answer_count": 2, "score": 13, "last_activity_date": 1606396611, "creation_date": 1430479814, "last_edit_date": 1606396611, "question_id": 29986057, "link": "https://stackoverflow.com/questions/29986057/is-there-a-way-to-get-the-field-names-of-a-struct-in-a-macro", "title": "Is there a way to get the field names of a struct in a macro?", "body": "<p>Consider the following example:</p>\n\n<pre><code>struct S {\n    a: String,\n    b: String,\n}\n</code></pre>\n\n<p>I have a macro which is called like this:</p>\n\n<pre><code>my_macro!(S);\n</code></pre>\n\n<p>I want to access the field names of the struct in the macro like this:</p>\n\n<pre><code>macro_rules! my_macro {\n    ($t:ty) =&gt; {{\n        let field_names = get_field_names($t);\n        // do something with field_names\n    }};\n}\n</code></pre>\n\n<p>I'm new to Rust and macros, so maybe I'm missing something obvious.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 20407, "user_id": 1017941, "user_type": "registered", "accept_rate": 97, "profile_image": "https://i.stack.imgur.com/yocPw.jpg?s=128&g=1", "display_name": "Hauleth", "link": "https://stackoverflow.com/users/1017941/hauleth"}, "is_accepted": true, "score": 5, "last_activity_date": 1430514767, "last_edit_date": 1430514767, "creation_date": 1430479574, "answer_id": 29986009, "question_id": 29985655, "link": "https://stackoverflow.com/questions/29985655/borrows-and-ownership-of-object-on-thread/29986009#29986009", "title": "Borrows and ownership of object on thread", "body": "<p><code>Arc</code> isn't allowing to mutate of it's inner state, even if container is marked as mutable. You should use one of <code>Cell</code>, <code>RefCell</code> or <code>Mutex</code>. Both <code>Cell</code> and <code>RefCell</code> are non-threadsafe so you should use <code>Mutex</code> (<a href=\"https://doc.rust-lang.org/std/cell/index.html#introducing-inherited-mutability-roots-to-shared-types\" rel=\"nofollow\">last paragraph in docs</a>).</p>\n\n<p>Example:</p>\n\n<pre><code>use std::thread::spawn;\nuse std::sync::Mutex;\nuse std::sync::Arc;\n\nstruct RoutingNode {\n    data: u16,\n}\n\nimpl RoutingNode {\n    pub fn new() -&gt; Self { RoutingNode { data: 0, } }  \n    pub fn run(&amp;self) { println!(\"data : {}\" , self.data); }   \n    pub fn put(&amp;mut self, increase: u16) { self.data += increase; }\n}\n\nfn main() {\n    let routing_node = Arc::new(Mutex::new(RoutingNode::new()));\n    let my_node = routing_node.clone();\n    let thread = spawn(move || { my_node.lock().unwrap().run(); });\n\n    routing_node.lock().unwrap().put(3);\n    let _ = thread.join();\n}\n</code></pre>\n\n<p><a href=\"http://is.gd/cnzQY9\" rel=\"nofollow\">Playpen</a></p>\n"}], "owner": {"reputation": 48909, "user_id": 1445334, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/185bc1a9b6a36d8f065bdb9a1de74f90?s=128&d=identicon&r=PG", "display_name": "dirvine", "link": "https://stackoverflow.com/users/1445334/dirvine"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 573, "favorite_count": 1, "accepted_answer_id": 29986009, "answer_count": 1, "score": 4, "last_activity_date": 1430514767, "creation_date": 1430477929, "question_id": 29985655, "link": "https://stackoverflow.com/questions/29985655/borrows-and-ownership-of-object-on-thread", "title": "Borrows and ownership of object on thread", "body": "<p>Sorry for newbie question. The error here is </p>\n\n<pre><code>&lt;anon&gt;:30:5: 30:17 error: cannot borrow immutable borrowed content as mutable\n&lt;anon&gt;:30     routing_node.put(3);\n              ^^^^^^^^^^^^\n</code></pre>\n\n<p>I have tried many things to work around this but know for sure this is a simple error. Any help much appreciated. </p>\n\n<pre><code>use std::thread;\nuse std::thread::spawn;\nuse std::sync::Arc;\n\nstruct RoutingNode {\n  data: u16\n}\n\nimpl RoutingNode {\n  pub fn new() -&gt; RoutingNode {\n      RoutingNode { data: 0 }\n}\n\npub fn run(&amp;self) {\n    println!(\"data : {}\", self.data);\n}\n\npub fn put(&amp;mut self, increase: u16) {\n    self.data += increase;\n}\n}\n\nfn main() {\n  let mut routing_node = Arc::new(RoutingNode::new());\n  let mut my_node = routing_node.clone();\n{\n    spawn(move || {my_node.run(); });\n}\n\nrouting_node.put(3);\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1430476828, "post_id": 29985438, "comment_id": 48090038, "body": "15 seconds.  You utter ratbag.  :D"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1430476841, "post_id": 29985438, "comment_id": 48090047, "body": "Yeah, it always happens with me too :)"}, {"owner": {"reputation": 3029, "user_id": 1060004, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/ZOBMa.jpg?s=128&g=1", "display_name": "ustulation", "link": "https://stackoverflow.com/users/1060004/ustulation"}, "edited": false, "score": 0, "creation_date": 1430477408, "post_id": 29985438, "comment_id": 48090327, "body": "brilliant as always ! I&#39;s trying to equate Box to <code>std::unique_ptr&lt;A&gt;</code>  where <code>A</code> is some Base class. That is what i though Box&lt;Self&gt; did and implicit casting (to base) would occur if concrete type was given. But seems Box&lt;A&gt; and Box&lt;Self&gt; are different notions. Still wrapping my head round rust :)"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1430478737, "post_id": 29985438, "comment_id": 48090813, "body": "Yes, there is (almost) no subtyping in Rust, so <code>Box&lt;Self&gt;</code> is never <code>Box&lt;A&gt;</code>. You have to be explicit :)"}, {"owner": {"reputation": 3029, "user_id": 1060004, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/ZOBMa.jpg?s=128&g=1", "display_name": "ustulation", "link": "https://stackoverflow.com/users/1060004/ustulation"}, "edited": false, "score": 0, "creation_date": 1430481082, "post_id": 29985438, "comment_id": 48091801, "body": "ok one more question: if the method signature is <code>fn fun2() -&gt; Option&lt;Box&lt;A&gt;&gt;</code> then it is still the same error. Why? Why does static function not work?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 3029, "user_id": 1060004, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/ZOBMa.jpg?s=128&g=1", "display_name": "ustulation", "link": "https://stackoverflow.com/users/1060004/ustulation"}, "edited": false, "score": 0, "creation_date": 1430482252, "post_id": 29985438, "comment_id": 48092366, "body": "@ustulation, since trait object methods are dispatched dynamically, they need their object to obtain a pointer to a virtual table. With static methods there is no object to dispatch on, so static methods can&#39;t be called through an object and are not present in the vtable. Hence they are not object-safe too."}, {"owner": {"reputation": 3029, "user_id": 1060004, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/ZOBMa.jpg?s=128&g=1", "display_name": "ustulation", "link": "https://stackoverflow.com/users/1060004/ustulation"}, "edited": false, "score": 0, "creation_date": 1430482994, "post_id": 29985438, "comment_id": 48092742, "body": "But the v-table should be present when assigning a derived pointer to the Base (traits in rust) pointer in the return type, no?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1430492053, "post_id": 29985438, "comment_id": 48097728, "body": "Do you mean the return type of the static method? But when you call it there is no object yet."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 11, "last_activity_date": 1430477270, "last_edit_date": 1430477270, "creation_date": 1430476784, "answer_id": 29985438, "question_id": 29985153, "link": "https://stackoverflow.com/questions/29985153/trait-object-is-not-object-safe-error/29985438#29985438", "title": "Trait Object is not Object-safe error", "body": "<p>As you have noticed, the problem vanishes when you remove <code>fun2</code> method. Let's look at it more closely:</p>\n\n<pre><code>fn fun2(&amp;self) -&gt; Option&lt;Box&lt;Self&gt;&gt;;\n</code></pre>\n\n<p>Note that its output type contains <code>Self</code>, that is, the type which the trait is implemented for. For example, if <code>A</code> is implemented for <code>String</code>, it would be <code>String</code>:</p>\n\n<pre><code>impl A for String {\n    fn fun2(&amp;self) -&gt; Option&lt;Box&lt;String&gt;&gt; { ... }\n}\n</code></pre>\n\n<p>However! With the trait objects the actual type of the value is erased, and the only thing that we know about trait objects is that it is a value which implements the trait, but we don't know the <em>actual type</em> the trait is implemented for. Trait object methods are dispatched dynamically, so the program selects the actual method to call at runtime. These methods have to behave identically, that is, accept the same number of parameters of the same size (pairwise) and return values of the same size too. If a method uses <code>Self</code> somewhere in its signature, like <code>fun2</code>, its implementations won't be compatible with each other because they would need to operate on values of different size, and hence such methods can't be unified.</p>\n\n<p>Such methods (which can't work with trait objects) are called object-unsafe (or not object-safe). If a trait contains such methods, it can't be made a trait object - it is also called not object-safe.</p>\n\n<p>What would work, I believe, is that you can make the trait return a trait object:</p>\n\n<pre><code>fn fun2(&amp;self) -&gt; Option&lt;Box&lt;A&gt;&gt;\n</code></pre>\n\n<p>Now the dependency on the actual type is lifted, and the trait becomes object-safe again.</p>\n"}, {"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 2, "last_activity_date": 1430476798, "creation_date": 1430476798, "answer_id": 29985442, "question_id": 29985153, "link": "https://stackoverflow.com/questions/29985153/trait-object-is-not-object-safe-error/29985442#29985442", "title": "Trait Object is not Object-safe error", "body": "<p>Well, the error message pretty much spells out the immediate problem: you're trying to use a non-object-safe trait in an object context, and you can't do that.</p>\n\n<p>You can remove <code>fun2</code> from the trait <code>A</code>, and define it in a different trait: its presence will prevent <code>A</code> from ever being used as a \"trait object\"; so <code>&amp;A</code>, <code>Box&lt;A&gt;</code>, etc. will all out of the question.  Each type can then implement both of these traits.</p>\n\n<p>Another alternative is to change <code>fun2</code> so that its result <em>does not</em> contain the <code>Self</code> type; your example is too abstract to know, but would <code>Option&lt;Box&lt;A&gt;&gt;</code> be acceptable?</p>\n\n<p>As for <em>why</em>: in order for a trait to be used as a trait object, the compiler has to be able to generate a vtable for the trait's methods so that it can do dynamic, runtime dispatch.  This means that every method in the trait has to be implementable with the same types (the <code>self</code> parameter is a special case).  So what does <code>fun2</code> return?  It has to return an <code>Option&lt;Box&lt;Self&gt;&gt;</code>, but <code>Self</code> is a different type for every implementation!  There's no possible way to unify it!</p>\n"}], "owner": {"reputation": 3029, "user_id": 1060004, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/ZOBMa.jpg?s=128&g=1", "display_name": "ustulation", "link": "https://stackoverflow.com/users/1060004/ustulation"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2467, "favorite_count": 1, "accepted_answer_id": 29985438, "answer_count": 2, "score": 7, "last_activity_date": 1430482002, "creation_date": 1430475610, "last_edit_date": 1495542719, "question_id": 29985153, "link": "https://stackoverflow.com/questions/29985153/trait-object-is-not-object-safe-error", "title": "Trait Object is not Object-safe error", "body": "<p>The following code does not compile for me.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>trait A {\n    fn fun0(&amp;self);\n    fn fun2(&amp;self) -&gt; Option&lt;Box&lt;Self&gt;&gt;;\n}\n\nstruct B0 {\n    id: usize,\n}\n\nimpl A for B0 {\n    fn fun0(&amp;self) { println!(\"Value: {:?}\", self.id); }\n    fn fun2(&amp;self) -&gt; Option&lt;Box&lt;Self&gt;&gt; { Option::None }\n}\n\nstruct B1 {\n    id: isize,\n}\n\nimpl A for B1 {\n    fn fun0(&amp;self) { println!(\"Value: {:?}\", self.id); }\n    fn fun2(&amp;self) -&gt; Option&lt;Box&lt;Self&gt;&gt; { Option::Some(Box::new(B1 { id: self.id, })) }\n}\n\nenum C {\n    None,\n    Put { object: Box&lt;A&gt;, },\n}\n\nfn fun1(values: Vec&lt;C&gt;) {\n    for it in values.iter() {\n        match *it {\n            C::Put { object: ref val, } =&gt; val.fun0(),\n            C::None =&gt; (),\n        };\n    }\n}\n\nfn main() {\n    let obj_b0 = Box::new(B0 { id: 778, });\n    let obj_b1 = Box::new(B1 { id: -8778, });\n    let obj_c0 = C::Put { object: obj_b0, };\n    let obj_c1 = C::Put { object: obj_b1, };\n    let mut vec = Vec::new();\n    vec.push(obj_c0);\n    vec.push(obj_c1);\n    fun1(vec);\n}\n</code></pre>\n\n<p>gives an error:</p>\n\n<pre><code>cargo run\n   Compiling misc v0.0.1 (file:///home/spandan/virtualization/coding/my/rust-tests/misc/misc)\nsrc/main.rs:188:48: 188:54 error: the trait `A` is not implemented for the type `A` [E0277]\nsrc/main.rs:188             C::Put { object: ref val, } =&gt; val.fun0(),\n                                                               ^~~~~~\nsrc/main.rs:197:35: 197:41 error: cannot convert to a trait object because trait `A` is not object-safe [E0038]\nsrc/main.rs:197     let obj_c0 = C::Put { object: obj_b0, };\n                                                  ^~~~~~\nsrc/main.rs:197:35: 197:41 note: method `fun2` references the `Self` type in its arguments or return type\nsrc/main.rs:197     let obj_c0 = C::Put { object: obj_b0, };\n                                                  ^~~~~~\nsrc/main.rs:198:35: 198:41 error: cannot convert to a trait object because trait `A` is not object-safe [E0038]\nsrc/main.rs:198     let obj_c1 = C::Put { object: obj_b1, };\n                                                  ^~~~~~\nsrc/main.rs:198:35: 198:41 note: method `fun2` references the `Self` type in its arguments or return type\nsrc/main.rs:198     let obj_c1 = C::Put { object: obj_b1, };\n                                                  ^~~~~~\nerror: aborting due to 3 previous errors\nCould not compile `misc`.\n</code></pre>\n\n<p>working with</p>\n\n<pre><code>rustc --version\nrustc 1.0.0-nightly (00978a987 2015-04-18) (built 2015-04-19)\n</code></pre>\n\n<p>The problem appears when <code>fun2(&amp;self)</code> is brought into the picture. It compiles and runs fine if <code>fun0</code> is the only existing function in the trait. But my code needs such a pattern - How do i do it ?</p>\n\n<p><strong>Edit:</strong> the correct answer for the above has been given here (<a href=\"https://stackoverflow.com/a/29985438/1060004\">https://stackoverflow.com/a/29985438/1060004</a>) . But i am running into the same problem if i remove the <code>&amp;self</code> from function signature (ie., make it static):</p>\n\n<pre><code>fn fun2() -&gt; Option&lt;Box&lt;A&gt;&gt;\n</code></pre>\n\n<p>what is the issue now ?</p>\n"}, {"tags": ["multithreading", "rust", "lifetime"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1501024574, "post_id": 29983088, "comment_id": 77592326, "body": "Note that <code>thread::scoped</code> was removed from the standard library because it was not memory-safe. It has been <a href=\"https://stackoverflow.com/a/32751956/155423\">safely replaced by crates</a>."}], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 3, "last_activity_date": 1430465841, "creation_date": 1430465841, "answer_id": 29983245, "question_id": 29983088, "link": "https://stackoverflow.com/questions/29983088/why-doesnt-a-local-variable-live-long-enough-for-threadscoped/29983245#29983245", "title": "Why doesn&#39;t a local variable live long enough for thread::scoped?", "body": "<p><code>join_guards</code> is a vector of scoped threads with a certain shared lifetime. That lifetime is determined by which variables it closes over: <code>value</code> is the only one. Therefore, the lifetime of the scoped threads is the scope of <code>value</code>. Where is <code>value</code> legal? <em>After it is defined</em> and until it goes out of scope\u2014that is, \u201cthe block suffix following statement 1 at 8:40\u201d. <code>join_guards</code> must have as its lifetime a lifetime no greater than this, but if <code>join_guards</code> is defined <em>before</em> <code>value</code>, this is not the case.</p>\n\n<p>The solution is to reverse the order of declaration:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let value = AtomicUsize::new(0);\nlet mut join_guards = Vec::new();\n</code></pre>\n\n<p>This explains why the second example works, also.</p>\n"}], "owner": {"reputation": 647, "user_id": 4037231, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fe12602a9e9ca343dc477b81e1244b1b?s=128&d=identicon&r=PG&f=1", "display_name": "kmky", "link": "https://stackoverflow.com/users/4037231/kmky"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 84, "favorite_count": 0, "accepted_answer_id": 29983245, "answer_count": 1, "score": 2, "last_activity_date": 1501024498, "creation_date": 1430464993, "last_edit_date": 1501024498, "question_id": 29983088, "link": "https://stackoverflow.com/questions/29983088/why-doesnt-a-local-variable-live-long-enough-for-threadscoped", "title": "Why doesn&#39;t a local variable live long enough for thread::scoped?", "body": "<p>Why doesn't Example 1 compile given that Example 2 compiles just fine? The only difference between the examples is that in Example 1 <code>value</code> is a function local variable, and in Example 2 <code>value</code> is an argument to the function.</p>\n\n<p><strong>Example 1</strong></p>\n\n<pre><code>#![feature(scoped)]\n\nuse std::thread;\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\npub fn foo&lt;F&gt;() {\n    let mut join_guards = Vec::new();\n    let value = AtomicUsize::new(0);\n\n    for _ in 0..10 {\n        join_guards.push(thread::scoped(|| {\n            value.fetch_add(1, Ordering::SeqCst);\n        }));\n    }\n}\n</code></pre>\n\n<p><strong>Example 2</strong></p>\n\n<pre><code>#![feature(scoped)]\n\nuse std::thread;\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\npub fn foo&lt;F&gt;(value: AtomicUsize) {\n    let mut join_guards = Vec::new();\n\n    for _ in 0..10 {\n        join_guards.push(thread::scoped(|| {\n            value.fetch_add(1, Ordering::SeqCst);\n        }));\n    }\n}\n</code></pre>\n\n<p>These are the error messages I get trying to compile Example 1:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `value` does not live long enough\n         join_guards.push(thread::scoped(|| {\n             value.fetch_add(1, Ordering::SeqCst);\n         }));\nnote: reference must be valid for the block at 6:20...\npub fn foo&lt;F&gt;() {\n    let mut join_guards = Vec::new();\n    let value = AtomicUsize::new(0);\n\n     for _ in 0..10 {\n         join_guards.push(thread::scoped(|| {\n\nnote: ...but borrowed value is only valid for the block suffix following statement 1 at 8:40\n    let value = AtomicUsize::new(0);\n\n     for _ in 0..10 {\n         join_guards.push(thread::scoped(|| {\n             value.fetch_add(1, Ordering::SeqCst);\n         }));\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": false, "score": 0, "last_activity_date": 1430453396, "creation_date": 1430453396, "answer_id": 29981481, "question_id": 29981378, "link": "https://stackoverflow.com/questions/29981378/is-there-an-easy-way-to-cast-entire-tuples-of-scalar-values-at-once/29981481#29981481", "title": "Is there an easy way to cast entire tuples of scalar values at once?", "body": "<p>No, \n       there \n             is \n                not.</p>\n"}, {"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 2, "last_activity_date": 1430453753, "creation_date": 1430453753, "answer_id": 29981516, "question_id": 29981378, "link": "https://stackoverflow.com/questions/29981378/is-there-an-easy-way-to-cast-entire-tuples-of-scalar-values-at-once/29981516#29981516", "title": "Is there an easy way to cast entire tuples of scalar values at once?", "body": "<p>No, you cannot.  This is roughly equivalent to \"can I cast all the fields in a struct to different types all at once?\".</p>\n\n<p>You <em>can</em> write a generic extension trait which can do this conversion for you, the only problem is that I don't believe there's any existing generic \"conversion\" trait which also has a <code>u16 -&gt; f32</code> implementation defined.</p>\n\n<p>If you really want a function that does this, here is an as-minimal-as-I-could-make-it skeleton you can build on:</p>\n\n<pre><code>trait TupleCast&lt;T&gt; {\n    type Output;\n    fn tuple_cast(self) -&gt; &lt;Self as TupleCast&lt;T&gt;&gt;::Output;\n}\n\nimpl&lt;T&gt; TupleCast&lt;T&gt; for () {\n    type Output = ();\n    fn tuple_cast(self) -&gt; &lt;() as TupleCast&lt;T&gt;&gt;::Output {\n        ()\n    }\n}\n\nimpl&lt;S, T&gt; TupleCast&lt;T&gt; for (S,) where S: CustomAs&lt;T&gt; {\n    type Output = (T,);\n    fn tuple_cast(self) -&gt; &lt;(S,) as TupleCast&lt;T&gt;&gt;::Output {\n        (self.0.custom_as(),)\n    }\n}\n\nimpl&lt;S, T&gt; TupleCast&lt;T&gt; for (S, S) where S: CustomAs&lt;T&gt; {\n    type Output = (T, T);\n    fn tuple_cast(self) -&gt; &lt;(S, S) as TupleCast&lt;T&gt;&gt;::Output {\n        (self.0.custom_as(), self.1.custom_as())\n    }\n}\n\n// You would probably have more impls, up to some size limit.\n\n// We can't use std::convert::From, because it isn't defined for the same\n// basic types as the `as` operator is... which kinda sucks.  So, we have\n// to implement the desired conversions ourselves.\n//\n// Since this would be hideously tedious, we can use a macro to speed things\n// up a little.\n\ntrait CustomAs&lt;T&gt; {\n    fn custom_as(self) -&gt; T;\n}\n\nmacro_rules! custom_as_impl {\n    ($src:ty:) =&gt; {};\n    ($src:ty: $dst:ty) =&gt; {\n        impl CustomAs&lt;$dst&gt; for $src {\n            fn custom_as(self) -&gt; $dst {\n                self as $dst\n            }\n        }\n    };\n    ($src:ty: $dst:ty, $($rest:ty),*) =&gt; {\n        custom_as_impl! { $src: $dst }\n        custom_as_impl! { $src: $($rest),* }\n    };\n}\n\n// You could obviously list others, or do manual impls.\ncustom_as_impl! { u16: u16, u32, u64, i32, i64, f32, f64 }\n\nfn main() {\n    let x: (u16, u16) = (1, 2);\n    let y: (f32, f32) = x.tuple_cast();\n    println!(\"{:?}\", y);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "edited": false, "score": 0, "creation_date": 1430454815, "post_id": 29981602, "comment_id": 48082739, "body": "That&#39;s an awesome way to do it imo, thanks! I haven&#39;t used macros much yet so I wasn&#39;t aware that something like this was possible."}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 7, "last_activity_date": 1430454457, "creation_date": 1430454457, "answer_id": 29981602, "question_id": 29981378, "link": "https://stackoverflow.com/questions/29981378/is-there-an-easy-way-to-cast-entire-tuples-of-scalar-values-at-once/29981602#29981602", "title": "Is there an easy way to cast entire tuples of scalar values at once?", "body": "<p>There's no built-in way to do this, but one can do it with a macro:</p>\n\n<pre><code>macro_rules! tuple_as {\n    ($t: expr, ($($ty: ident),*)) =&gt; {\n        {\n            let ($($ty,)*) = $t;\n            ($($ty as $ty,)*) \n        }\n    }\n}\n\nfn main() {\n    let t: (u8, char, isize) = (97, 'a', -1);\n\n    let other = tuple_as!(t, (char, i32, i8));\n\n    println!(\"{:?}\", other);\n}\n</code></pre>\n\n<p>Prints <code>('a', 97, -1)</code>.</p>\n\n<p>The macro only works for casting between types with names that are a single identifier (that's what the <code>: ident</code> refers to), since it reuses those names for binding to the elements of the source tuple to be able to cast them. All primitive types are valid single identifiers, so it works well for those.</p>\n"}], "owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1097, "favorite_count": 1, "accepted_answer_id": 29981602, "answer_count": 3, "score": 3, "last_activity_date": 1430454457, "creation_date": 1430452412, "question_id": 29981378, "link": "https://stackoverflow.com/questions/29981378/is-there-an-easy-way-to-cast-entire-tuples-of-scalar-values-at-once", "title": "Is there an easy way to cast entire tuples of scalar values at once?", "body": "<p>I want to cast a <code>(u16, u16)</code> to a <code>(f32, f32)</code>. This is what I tried:</p>\n\n<pre><code>let tuple1 = (5u16, 8u16);\nlet tuple2 = tuple1 as (f32, f32);\n</code></pre>\n\n<p>Ideally, I would like to avoid writing</p>\n\n<pre><code>let tuple2 = (tuple1.0 as f32, tuple1.1 as f32);\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1430509183, "post_id": 29981201, "comment_id": 48107196, "body": "You can also use <a href=\"https://github.com/erickt/rust-serde\" rel=\"nofollow noreferrer\">serde</a>, which allows to <a href=\"https://github.com/Byron/google-apis-rs/blob/c2dd9c7a020e0367bc87b20fa8054c85f48b71c1/gen/adexchangebuyer1d3/src/lib.rs#L416\" rel=\"nofollow noreferrer\">rename fields natively</a>."}, {"owner": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "reply_to_user": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1430512031, "post_id": 29981201, "comment_id": 48108666, "body": "Ah ha! I looked at serde but didn&#39;t know it could do that! The docs probably need some love."}], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 4, "last_activity_date": 1430452360, "last_edit_date": 1430452360, "creation_date": 1430451756, "answer_id": 29981319, "question_id": 29981201, "link": "https://stackoverflow.com/questions/29981201/formatting-a-struct-field-differently-than-its-json-key/29981319#29981319", "title": "Formatting a struct field differently than its JSON key", "body": "<p>No, the <code>#[derive]</code> infrastructure provides no opportunities for customisation at all.</p>\n\n<p>You can, however, know what the <code>#[derive]</code> stuff expands to with <code>rustc -Z unstable-options --pretty expanded</code>:</p>\n\n<pre><code>#![feature(no_std)]\n#![no_std]\n#[prelude_import]\nuse std::prelude::v1::*;\n#[macro_use]\nextern crate std as std;\nstruct Person {\n    first_name: String,\n    last_name: String,\n    age: u8,\n}\n#[automatically_derived]\nimpl ::rustc_serialize::Decodable for Person {\n    fn decode&lt;__D: ::rustc_serialize::Decoder&gt;(__arg_0: &amp;mut __D)\n     -&gt; ::std::result::Result&lt;Person, __D::Error&gt; {\n        __arg_0.read_struct(\"Person\", 3usize, |_d| -&gt; _ {\n                            ::std::result::Result::Ok(Person{first_name:\n                                                                 match _d.read_struct_field(\"first_name\",\n                                                                                            0usize,\n                                                                                            ::rustc_serialize::Decodable::decode)\n                                                                     {\n                                                                     ::std::result::Result::Ok(__try_var)\n                                                                     =&gt;\n                                                                     __try_var,\n                                                                     ::std::result::Result::Err(__try_var)\n                                                                     =&gt;\n                                                                     return ::std::result::Result::Err(__try_var),\n                                                                 },\n                                                             last_name:\n                                                                 match _d.read_struct_field(\"last_name\",\n                                                                                            1usize,\n                                                                                            ::rustc_serialize::Decodable::decode)\n                                                                     {\n                                                                     ::std::result::Result::Ok(__try_var)\n                                                                     =&gt;\n                                                                     __try_var,\n                                                                     ::std::result::Result::Err(__try_var)\n                                                                     =&gt;\n                                                                     return ::std::result::Result::Err(__try_var),\n                                                                 },\n                                                             age:\n                                                                 match _d.read_struct_field(\"age\",\n                                                                                            2usize,\n                                                                                            ::rustc_serialize::Decodable::decode)\n                                                                     {\n                                                                     ::std::result::Result::Ok(__try_var)\n                                                                     =&gt;\n                                                                     __try_var,\n                                                                     ::std::result::Result::Err(__try_var)\n                                                                     =&gt;\n                                                                     return ::std::result::Result::Err(__try_var),\n                                                                 },}) })\n    }\n}\n#[automatically_derived]\nimpl ::rustc_serialize::Encodable for Person {\n    fn encode&lt;__S: ::rustc_serialize::Encoder&gt;(&amp;self, __arg_0: &amp;mut __S)\n     -&gt; ::std::result::Result&lt;(), __S::Error&gt; {\n        match *self {\n            Person {\n            first_name: ref __self_0_0,\n            last_name: ref __self_0_1,\n            age: ref __self_0_2 } =&gt;\n            __arg_0.emit_struct(\"Person\", 3usize, |_e| -&gt; _ {\n                                match _e.emit_struct_field(\"first_name\",\n                                                           0usize, |_e| -&gt; _ {\n                                                           (*__self_0_0).encode(_e)\n                                                       }) {\n                                    ::std::result::Result::Ok(__try_var) =&gt;\n                                    __try_var,\n                                    ::std::result::Result::Err(__try_var) =&gt;\n                                    return ::std::result::Result::Err(__try_var),\n                                };\n                                match _e.emit_struct_field(\"last_name\",\n                                                           1usize, |_e| -&gt; _ {\n                                                           (*__self_0_1).encode(_e)\n                                                       }) {\n                                    ::std::result::Result::Ok(__try_var) =&gt;\n                                    __try_var,\n                                    ::std::result::Result::Err(__try_var) =&gt;\n                                    return ::std::result::Result::Err(__try_var),\n                                };\n                                return _e.emit_struct_field(\"age\", 2usize,\n                                                            |_e| -&gt; _ {\n                                                            (*__self_0_2).encode(_e)\n                                                        }); }),\n        }\n    }\n}\n</code></pre>\n\n<p>Yeah, it\u2019s pretty clumsy, all expanded like that, but it can be collapsed quite easily and altered to suit:</p>\n\n<pre><code>impl Decodable for Person {\n    fn decode&lt;D: Decoder&gt;(decoder: &amp;mut D) -&gt; Result&lt;Person, D::Error&gt; {\n        decoder.read_struct(\"Person\", 3, |d| Ok(Person {\n            first_name: try!(d.read_struct_field(\"firstName\", 0, Decodable::decode)),\n            last_name: try!(d.read_struct_field(\"lastName\", 1, Decodable::decode)),\n            age: try!(d.read_struct_field(\"age\", 2, Decodable::decode)),\n        }))\n    }\n}\n\nimpl Encodable for Person {\n    fn encode&lt;S: Encoder&gt;(&amp;self, s: &amp;mut S) -&gt; Result&lt;(), S::Error&gt; {\n        s.emit_struct(\"Person\", 3, |e| {\n            try!(e.emit_struct_field(\"firstName\", 0, |e| self.first_name.encode(e)));\n            try!(e.emit_struct_field(\"lastName\", 1, |e| self.last_name.encode(e)));\n            e.emit_struct_field(\"age\", 2, |e| self.age.encode(e))\n        })\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 270, "favorite_count": 2, "accepted_answer_id": 29981319, "answer_count": 1, "score": 3, "last_activity_date": 1430452360, "creation_date": 1430450381, "question_id": 29981201, "link": "https://stackoverflow.com/questions/29981201/formatting-a-struct-field-differently-than-its-json-key", "title": "Formatting a struct field differently than its JSON key", "body": "<p>The <a href=\"https://github.com/rust-lang/rustc-serialize\" rel=\"nofollow\">rustc-serialize</a> package for Rust allows a struct to be serialized or deserialized to JSON automatically in some cases by deriving from <code>RustcEncodable</code> and <code>RustcDecodable</code>, respectively. For example, the following struct:</p>\n\n<pre><code>#[derive(RustcEncodable, RustcDecodable)]\nstruct Person {\n    first_name: String,\n    last_name: String,\n    age: u8,\n}\n</code></pre>\n\n<p>would be represented as this JSON:</p>\n\n<pre><code>{\n  \"first_name\": \"Joe\",\n  \"last_name\": \"Shmoe\",\n  \"age\": 30\n}\n</code></pre>\n\n<p>I need to deserialize some JSON that uses camel-cased keys. This seems to require that the struct fields be named similarly, which emits a compiler warning that struct fields should be snake-cased. I can silence this warning with <code>#[allow(non_snake_case)]</code>, but I'd rather have the struct field snake-cased. Is there a way to do this without manually implementing JSON serialization/deserialization with the <code>ToJson</code>/<code>Encodable</code>/<code>Decodable</code> traits?</p>\n"}, {"tags": ["buffer", "rust", "traits"], "answers": [{"comments": [{"owner": {"reputation": 1668, "user_id": 311358, "user_type": "registered", "accept_rate": 59, "profile_image": "https://www.gravatar.com/avatar/0b2b51e4cceb4a0c1609b81815001b69?s=128&d=identicon&r=PG", "display_name": "xrl", "link": "https://stackoverflow.com/users/311358/xrl"}, "edited": false, "score": 0, "creation_date": 1430500445, "post_id": 29981330, "comment_id": 48102598, "body": "I was not complete in my description of the issue with my code. You solved the first error (the one I listed) for satisfying the trait <code>std::io::Write</code> but I want to use the <code>write_be_u32</code>/<code>write_be_f64</code> and those are not working. I will update the post with those errors."}, {"owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "reply_to_user": {"reputation": 1668, "user_id": 311358, "user_type": "registered", "accept_rate": 59, "profile_image": "https://www.gravatar.com/avatar/0b2b51e4cceb4a0c1609b81815001b69?s=128&d=identicon&r=PG", "display_name": "xrl", "link": "https://stackoverflow.com/users/311358/xrl"}, "edited": false, "score": 0, "creation_date": 1430507353, "post_id": 29981330, "comment_id": 48106140, "body": "@xrl: I believe that the <code>Writer</code> trait, which is what implements those methods, has been removed from the Rust standard library. So you are probably out of luck in that regard."}, {"owner": {"reputation": 1668, "user_id": 311358, "user_type": "registered", "accept_rate": 59, "profile_image": "https://www.gravatar.com/avatar/0b2b51e4cceb4a0c1609b81815001b69?s=128&d=identicon&r=PG", "display_name": "xrl", "link": "https://stackoverflow.com/users/311358/xrl"}, "edited": false, "score": 0, "creation_date": 1430522622, "post_id": 29981330, "comment_id": 48112624, "body": "Adrian good catch! I&#39;m not sure how I came across that old documentation and didn&#39;t realize it was old."}], "tags": [], "owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "is_accepted": true, "score": 2, "last_activity_date": 1430451898, "creation_date": 1430451898, "answer_id": 29981330, "question_id": 29981180, "link": "https://stackoverflow.com/questions/29981180/how-to-build-writebuf-from-array/29981330#29981330", "title": "How to build WriteBuf from array", "body": "<p>I see a few potential problems with your code:</p>\n\n<ul>\n<li><code>packed_data</code> isn't mutable.</li>\n<li>You use <code>packed_data</code> at the end of <code>main</code> while <code>writer</code> holds a mutable reference to it.</li>\n</ul>\n\n<p>I don't think that either of those things are causing the error. I did however find something that works:</p>\n\n<pre><code>use std::io::{ BufWriter, Write };\n\nfn main() {\n    let mut packed_data = [0; 12];\n\n    {\n        let packed_data_ref: &amp;mut [u8] = &amp;mut packed_data;\n        let mut writer = BufWriter::new(packed_data_ref);\n\n        writer.write(&amp;[1, 2, 3, 4]).unwrap();\n    } // `writer` gets deallocated and releases the mutable reference\n\n    println!(\"Packed data looks like {:?}\", packed_data);\n}\n</code></pre>\n\n<p>[<a href=\"http://is.gd/eZxn0Z\" rel=\"nofollow\">playpen</a>]</p>\n\n<p>So I guess the issue is that you need a <code>&amp;[u8]</code> rather than a <code>&amp;[u8; 12]</code>. I have no idea why. I hope this at least helps though.</p>\n"}], "owner": {"reputation": 1668, "user_id": 311358, "user_type": "registered", "accept_rate": 59, "profile_image": "https://www.gravatar.com/avatar/0b2b51e4cceb4a0c1609b81815001b69?s=128&d=identicon&r=PG", "display_name": "xrl", "link": "https://stackoverflow.com/users/311358/xrl"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 173, "favorite_count": 0, "accepted_answer_id": 29981330, "answer_count": 1, "score": 0, "last_activity_date": 1430500658, "creation_date": 1430450191, "last_edit_date": 1430500658, "question_id": 29981180, "link": "https://stackoverflow.com/questions/29981180/how-to-build-writebuf-from-array", "title": "How to build WriteBuf from array", "body": "<p>I am serializing two values in to an array and I am trying to go through a WriteBuf but I am getting the error that</p>\n\n<pre><code>error: the trait `std::io::Write` is not implemented for the type `[_; 12]`\nerror: type `std::io::buffered::BufWriter&lt;&amp;mut [_; 12]&gt;` does not implement any method in scope named `write_be_u32`\nerror: type `std::io::buffered::BufWriter&lt;&amp;mut [_; 12]&gt;` does not implement any method in scope named `write_be_f64`\n</code></pre>\n\n<p>Here is the minimum code to generate this error:</p>\n\n<pre><code>use std::io::{ BufWriter, Write };\n\nfn main(){\n  let packed_data = [0; 12];\n  let timestamp : u32 = 100;\n  let value : f64 = 9.9;\n\n  let writer = BufWriter::new(&amp;mut packed_data);\n  writer.write_be_u32(timestamp);\n  writer.write_be_f64(value);\n\n  println!(\"Packed data looks like {:?}\", packed_data);\n}\n</code></pre>\n\n<p>Am I no borrowing the slice correctly? Am I note using the proper module to define the <code>Write</code> trait for my buffer?</p>\n\n<p>Here is a playpen for this code: <a href=\"http://is.gd/ol8qND\" rel=\"nofollow\">http://is.gd/ol8qND</a></p>\n"}, {"tags": ["rust", "traits"], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": false, "score": 3, "last_activity_date": 1430433475, "creation_date": 1430433475, "answer_id": 29978977, "question_id": 29978133, "link": "https://stackoverflow.com/questions/29978133/capturing-a-trait-in-a-struct-that-is-only-used-in-the-implementation/29978977#29978977", "title": "Capturing a trait in a struct that is only used in the implementation", "body": "<p>There are a couple of directions you can go:</p>\n\n<ul>\n<li><p>Add a <a href=\"http://doc.rust-lang.org/nightly/std/marker/struct.PhantomData.html\" rel=\"nofollow\">phantom data marker for <code>Evaluator</code></a>:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::marker;\n\npub trait StateEvaluator&lt;State&gt; {\n    fn eval(state: State, buf: &amp;mut [u8]);\n}\n\npub struct Interpreter&lt;State, Evaluator&gt; {\n    state: State,\n    evaluator: marker::PhantomData&lt;Evaluator&gt;,\n}\n\nimpl&lt;State: Default + Clone, Evaluator: StateEvaluator&lt;State&gt;&gt; Interpreter&lt;State, Evaluator&gt; {\n    pub fn new() -&gt; Interpreter&lt;State, Evaluator&gt; {\n        Interpreter {\n            state: Default::default(),\n            evaluator: marker::PhantomData,\n        }\n    }\n\n    pub fn eval(&amp;self, buf: &amp;mut [u8]) {\n        Evaluator::eval(self.state.clone(), buf)\n    }\n}\n</code></pre>\n\n<p>This way the generic type is used in the struct. (Note that I\u2019ve made the executive decision to add the <code>Clone</code> bound to <code>State</code> so that <code>eval</code> can pass a <code>State</code> to the <code>StateEvaluator</code>; you could also go for it taking <code>&amp;State</code> or a <code>Copy</code> bound.)</p></li>\n<li><p>Shift the <code>Evaluator</code> generic from the type to the <code>eval</code> function. This is probably not what you want, but as it just might be I\u2019ll mention it.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub trait StateEvaluator&lt;State&gt; {\n    fn eval(state: State, buf: &amp;mut [u8]);\n}\n\npub struct Interpreter&lt;State&gt; {\n    state: State,\n}\n\nimpl&lt;State: Default + Clone&gt; Interpreter&lt;State&gt; {\n    pub fn new() -&gt; Interpreter&lt;State&gt; {\n        Interpreter {\n            state: Default::default(),\n        }\n    }\n\n    pub fn eval&lt;Evaluator: StateEvaluator&lt;State&gt;&gt;(&amp;self, buf: &amp;mut [u8]) {\n        Evaluator::eval(self.state.clone(), buf)\n    }\n}\n</code></pre></li>\n</ul>\n"}, {"comments": [{"owner": {"reputation": 193600, "user_id": 87189, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/98e7d6edce863e7a1bf8199b082eb25e?s=128&d=identicon&r=PG", "display_name": "tadman", "link": "https://stackoverflow.com/users/87189/tadman"}, "edited": false, "score": 0, "creation_date": 1430500008, "post_id": 29979009, "comment_id": 48102370, "body": "Sort of a missed opportunity there to adopt the <code>phantom</code> modifier as suggested in the RFC. That did the trick, though."}], "tags": [], "owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "is_accepted": true, "score": 2, "last_activity_date": 1430433662, "creation_date": 1430433662, "answer_id": 29979009, "question_id": 29978133, "link": "https://stackoverflow.com/questions/29978133/capturing-a-trait-in-a-struct-that-is-only-used-in-the-implementation/29979009#29979009", "title": "Capturing a trait in a struct that is only used in the implementation", "body": "<p>The type parameter <code>Evaluator</code> is called a <a href=\"http://en.wikipedia.org/wiki/Generalized_algebraic_data_type\" rel=\"nofollow\"><em>phantom type</em></a> because it is not used in the type definition. Rust used to allow such code to compile, but a <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\" rel=\"nofollow\">change earlier this year related to variance</a> outlawed it. Instead, you must use the type parameter.</p>\n\n<p>To retain its phantom nature, you can use a \"marker\" of sorts called <a href=\"http://doc.rust-lang.org/std/marker/struct.PhantomData.html\" rel=\"nofollow\"><code>PhantomData</code></a>. This is a special type that is interpreted by the compiler.</p>\n\n<p>Making your code work is easy. Just add a <code>PhantomData</code> member that uses your phantom type parameter:</p>\n\n<pre><code>use std::marker::PhantomData;\n\npub struct Interpreter&lt;State, Evaluator&gt; {\n    state: State,\n    _marker: PhantomData&lt;Evaluator&gt;,\n}\n</code></pre>\n\n<p>And then tweak the construction slightly:</p>\n\n<pre><code>Interpreter {\n    state: Default::default(),\n    _marker: PhantomData,\n}\n</code></pre>\n\n<p>Type inference will fill in the type parameter for <code>PhantomData</code> automatically.</p>\n"}], "owner": {"reputation": 193600, "user_id": 87189, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/98e7d6edce863e7a1bf8199b082eb25e?s=128&d=identicon&r=PG", "display_name": "tadman", "link": "https://stackoverflow.com/users/87189/tadman"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 245, "favorite_count": 0, "accepted_answer_id": 29979009, "answer_count": 2, "score": 0, "last_activity_date": 1430433662, "creation_date": 1430429523, "question_id": 29978133, "link": "https://stackoverflow.com/questions/29978133/capturing-a-trait-in-a-struct-that-is-only-used-in-the-implementation", "title": "Capturing a trait in a struct that is only used in the implementation", "body": "<p>How do you define a <code>struct</code> that has a polymorphic struct and trait associated with it, but where the trait does not factor into the <code>struct</code> definition, only implementation?</p>\n\n<p>Here the compiler refuses to accept this definition of <code>Interpreter</code> since <code>Evaluator</code> is unused, yet it is necessary within the implementation:</p>\n\n<pre><code>pub trait StateEvaluator&lt;State&gt; {\n    fn eval(state: State, buf: &amp;mut [u8]);\n}\n\npub struct Interpreter&lt;State, Evaluator&gt; {\n    state: State\n}\n\nimpl&lt;State: Default, Evaluator: StateEvaluator&lt;State&gt;&gt; Interpreter&lt;State, Evaluator&gt; {\n    pub fn new() -&gt; Interpreter&lt;State, Evaluator&gt; {\n        Interpreter {\n            state: Default::default()\n        }\n    }\n\n    pub fn eval(&amp;self, buf: &amp;mut [u8]) {\n        Evaluator::eval(self.state, buf)\n    }\n}\n</code></pre>\n\n<p>Removing that from the <code>struct</code> causes a mismatch on the <code>impl</code> version and a different compiler error about expecting 1 argument and getting 2.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 0, "creation_date": 1430433558, "post_id": 29978200, "comment_id": 48077533, "body": "I had no idea such patterns were possible, this is good to know!"}, {"owner": {"reputation": 125, "user_id": 4847426, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/05dfde52ab9c1ac46d8786e76d40b74e?s=128&d=identicon&r=PG&f=1", "display_name": "ggriffiniii", "link": "https://stackoverflow.com/users/4847426/ggriffiniii"}, "edited": false, "score": 0, "creation_date": 1430433882, "post_id": 29978200, "comment_id": 48077620, "body": "Thanks. That&#39;s exactly what I was looking for. Out of curiosity where would I find this behavior documented? I tried to find authoritative docs about what&#39;s possible in pattern matching, but couldn&#39;t really find much other than very trivial examples."}, {"owner": {"reputation": 287982, "user_id": 69755, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/6aa87e056bd2ee342fbd56eb2110603c?s=128&d=identicon&r=PG", "display_name": "Brian Campbell", "link": "https://stackoverflow.com/users/69755/brian-campbell"}, "reply_to_user": {"reputation": 125, "user_id": 4847426, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/05dfde52ab9c1ac46d8786e76d40b74e?s=128&d=identicon&r=PG&f=1", "display_name": "ggriffiniii", "link": "https://stackoverflow.com/users/4847426/ggriffiniii"}, "edited": false, "score": 0, "creation_date": 1430434292, "post_id": 29978200, "comment_id": 48077748, "body": "@ggriffiniii Looks like it&#39;s documented in the <a href=\"http://doc.rust-lang.org/reference.html\" rel=\"nofollow noreferrer\">Rust Reference</a>, in the <a href=\"http://doc.rust-lang.org/reference.html#match-expressions\" rel=\"nofollow noreferrer\">Match expressions</a> section: &quot;Subpatterns can also be bound to variables by the use of the syntax <code>variable @ subpattern</code>.&quot;"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "reply_to_user": {"reputation": 125, "user_id": 4847426, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/05dfde52ab9c1ac46d8786e76d40b74e?s=128&d=identicon&r=PG&f=1", "display_name": "ggriffiniii", "link": "https://stackoverflow.com/users/4847426/ggriffiniii"}, "edited": false, "score": 0, "creation_date": 1430434417, "post_id": 29978200, "comment_id": 48077790, "body": "@ggriffiniii It&#39;s mentioned (once) in <a href=\"https://doc.rust-lang.org/reference.html#match-expressions\" rel=\"nofollow noreferrer\">the reference</a>, and also <a href=\"http://doc.rust-lang.org/book/patterns.html#bindings\" rel=\"nofollow noreferrer\">in the Patterns section of the book</a> (although that&#39;s not as precise as it could be, <a href=\"https://github.com/rust-lang/rust/issues/25008\" rel=\"nofollow noreferrer\">#25008</a>)."}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 6, "last_activity_date": 1430429795, "creation_date": 1430429795, "answer_id": 29978200, "question_id": 29976107, "link": "https://stackoverflow.com/questions/29976107/pattern-matching-on-a-temporary-tuple-with-mutable-references/29978200#29978200", "title": "Pattern matching on a temporary tuple with mutable references", "body": "<p>There is a way to get the mutable reference, as one can use an <code>@</code>-pattern (known as an as-pattern in Haskell) to bind an identifier to the value a whole pattern represents:</p>\n\n<pre><code>fn insert(&amp;mut self, k: K, v: V) -&gt; Option&lt;V&gt; {\n    match (k.cmp(self.k.borrow()), &amp;mut self.left, &amp;mut self.right) {\n        (Ordering::Less, left @ &amp;mut None, _) =&gt; {\n            *left = Some(Box::new(TreeNode::new(k, v)));\n            None\n        }\n    // ...\n</code></pre>\n\n<p>This is exactly like writing <code>let left = &amp;mut self.left;</code> inside the match arm, but it has the useful advantage of working.</p>\n"}], "owner": {"reputation": 125, "user_id": 4847426, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/05dfde52ab9c1ac46d8786e76d40b74e?s=128&d=identicon&r=PG&f=1", "display_name": "ggriffiniii", "link": "https://stackoverflow.com/users/4847426/ggriffiniii"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 597, "favorite_count": 1, "accepted_answer_id": 29978200, "answer_count": 1, "score": 2, "last_activity_date": 1430429795, "creation_date": 1430421905, "last_edit_date": 1430424594, "question_id": 29976107, "link": "https://stackoverflow.com/questions/29976107/pattern-matching-on-a-temporary-tuple-with-mutable-references", "title": "Pattern matching on a temporary tuple with mutable references", "body": "<p>I'm new to Rust and wondering if there is a natural way to write the following while still pattern matching on the tuple.</p>\n\n<p>I have a tree like structure with <code>key</code>, <code>value</code>, <code>left</code> and <code>right</code> members. I want to create an insert function that looks something similar to</p>\n\n<pre><code>fn insert(&amp;mut self, k: K, v: V) -&gt; Option&lt;V&gt; {\n    match (k.cmp(self.k.borrow()), &amp;mut self.left, &amp;mut self.right) {\n        (Ordering::Less, &amp;mut None, _) =&gt; { self.left = Some(Box::new(TreeNode::new(k, v))); None },\n        (Ordering::Less, &amp;mut Some(ref mut left), _) =&gt; left.insert(k, v),\n        (Ordering::Greater, &amp;mut None, _) =&gt; { self.right = Some(Box::new(TreeNode::new(k, v))); None },\n        (Ordering::Greater, &amp;mut Some(ref mut right), _) =&gt; right.insert(k, v),\n        (Ordering::Equal, _, _) =&gt; { let mut temp = v; std::mem::swap(self.v.borrow_mut(), temp.borrow_mut()); Some(temp) },\n    }\n}\n</code></pre>\n\n<p>I like how this clearly covers all the cases and the resulting actions, however this doesn't compile because <code>self.left</code> and <code>self.right</code> are mutably borrowed by the temporary tuple used in the match statement meaning that I can't modify <code>self.left</code> or <code>self.right</code> within the action arms of the match. The following alternative works</p>\n\n<pre><code>fn insert(&amp;mut self, k: K, v: V) -&gt; Option&lt;V&gt; {\n    match k.cmp(self.k.borrow()) {\n        Ordering::Less =&gt; match self.left {\n            None =&gt; { self.left = Some(Box::new(TreeNode::new(k, v))); None },\n            Some(ref mut left) =&gt; left.insert(k, v),\n        },\n        Ordering::Greater =&gt; match self.right {\n            None =&gt; { self.right = Some(Box::new(TreeNode::new(k, v))); None },\n            Some(ref mut right) =&gt; right.insert(k, v),\n        },\n        Ordering::Equal =&gt; { let mut temp = v; std::mem::swap(self.v.borrow_mut(), temp.borrow_mut()); Some(temp) }\n    }\n}\n</code></pre>\n\n<p>and should be logically equivalent, but I feel like the former more clearly and concisely describes the problem. Being new to Rust I wasn't sure if there was some ability to extract the mutable reference from the tuple and change it from a <code>None</code> to <code>Some</code> value in the action, so figured I would ask if there are any alternatives I'm overlooking.</p>\n\n<p>I've uploaded short snippets of the <a href=\"http://is.gd/DdJY70\" rel=\"nofollow\">working</a> and <a href=\"http://is.gd/iDnQfx\" rel=\"nofollow\">non-working</a> variations to the playpen.</p>\n"}, {"tags": ["rust", "traits", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 1743, "user_id": 398021, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a5a39b5f9de50200406c7a209ff7a121?s=128&d=identicon&r=PG", "display_name": "goertzenator", "link": "https://stackoverflow.com/users/398021/goertzenator"}, "edited": false, "score": 0, "creation_date": 1430422550, "post_id": 29975927, "comment_id": 48072236, "body": "Still a little fuzzy.  What would the non-trait versions of save() and restore() look like for SimpleKeeper&lt;&#39;a&gt;?  And would they mean exactly the same thing as the the trait version?"}, {"owner": {"reputation": 1743, "user_id": 398021, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a5a39b5f9de50200406c7a209ff7a121?s=128&d=identicon&r=PG", "display_name": "goertzenator", "link": "https://stackoverflow.com/users/398021/goertzenator"}, "edited": false, "score": 0, "creation_date": 1430424065, "post_id": 29975927, "comment_id": 48073051, "body": "Would this be it?    fn save&lt;&#39;a&gt;(keep:&amp;mut SimpleKeeper&lt;&#39;a&gt;, v: &amp;&#39;a u8) { keep.val = v }     fn restore&lt;&#39;a&gt;(keep:&amp; SimpleKeeper&lt;&#39;a&gt;) -&gt; &amp;&#39;a u8 { keep.val }"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1743, "user_id": 398021, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a5a39b5f9de50200406c7a209ff7a121?s=128&d=identicon&r=PG", "display_name": "goertzenator", "link": "https://stackoverflow.com/users/398021/goertzenator"}, "edited": false, "score": 0, "creation_date": 1430424687, "post_id": 29975927, "comment_id": 48073376, "body": "@goertzenator I attempted to answer. The important part is that the struct is also parameterized with the lifetime."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1585600237, "last_edit_date": 1585600237, "creation_date": 1430421310, "answer_id": 29975927, "question_id": 29975854, "link": "https://stackoverflow.com/questions/29975854/what-does-it-mean-for-a-trait-to-have-a-lifetime-parameter/29975927#29975927", "title": "What does it mean for a trait to have a lifetime parameter?", "body": "<p>If you have a trait with a lifetime bound, then <em>implementors</em> of the trait can participate in the same lifetime. Concretely, this allows you to store references with that lifetime. It is <strong>not</strong> a shortcut for specifying lifetimes on member methods, and difficulty and confusing error messages lie that way!</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>trait Keeper&lt;'a&gt; {\n    fn save(&amp;mut self, v: &amp;'a u8);\n    fn restore(&amp;self) -&gt; &amp;'a u8;\n}\n\nstruct SimpleKeeper&lt;'a&gt; {\n    val: &amp;'a u8,\n}\n\nimpl&lt;'a&gt; Keeper&lt;'a&gt; for SimpleKeeper&lt;'a&gt; {\n    fn save(&amp;mut self, v: &amp;'a u8) {\n        self.val = v\n    }\n    fn restore(&amp;self) -&gt; &amp;'a u8 {\n        self.val\n    }\n}\n</code></pre>\n\n<p>Note how both the struct and the trait are parameterized on a lifetime, and that lifetime <strong>is the same</strong>.</p>\n\n<blockquote>\n  <p>What would the non-trait versions of <code>save()</code> and <code>restore()</code> look like for <code>SimpleKeeper&lt;'a&gt;</code>?</p>\n</blockquote>\n\n<p>Very similar, actually. The important part is that the struct stores the reference itself, so it needs to have a lifetime parameter for the values inside.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct SimpleKeeper&lt;'a&gt; {\n    val: &amp;'a u8,\n}\n\nimpl&lt;'a&gt; SimpleKeeper&lt;'a&gt; {\n    fn save(&amp;mut self, v: &amp;'a u8) {\n        self.val = v\n    }\n    fn restore(&amp;self) -&gt; &amp;'a u8 {\n        self.val\n    }\n}\n</code></pre>\n\n<blockquote>\n  <p>And would they mean exactly the same thing as the the trait version?</p>\n</blockquote>\n\n<p>Yep!</p>\n"}], "owner": {"reputation": 1743, "user_id": 398021, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a5a39b5f9de50200406c7a209ff7a121?s=128&d=identicon&r=PG", "display_name": "goertzenator", "link": "https://stackoverflow.com/users/398021/goertzenator"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 683, "favorite_count": 1, "accepted_answer_id": 29975927, "answer_count": 1, "score": 5, "last_activity_date": 1585600237, "creation_date": 1430421079, "last_edit_date": 1430421154, "question_id": 29975854, "link": "https://stackoverflow.com/questions/29975854/what-does-it-mean-for-a-trait-to-have-a-lifetime-parameter", "title": "What does it mean for a trait to have a lifetime parameter?", "body": "<p>I understand how lifetime parameters apply to functions and structs, but what does it mean for a <strong>trait</strong> to have a lifetime parameter?  Is it a shortcut to introduce a lifetime parameter to its methods, or is it something else?</p>\n"}, {"tags": ["rust", "travis-ci", "rust-cargo"], "comments": [{"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1430401553, "post_id": 29969208, "comment_id": 48058467, "body": "Could you clarify second sentence a bit? <code>cargo build</code> just builds a Rust example. <code>cargo test</code> will build and test the cargo. Only <code>cargo run &lt;name&gt;</code> will actually run the example?"}, {"owner": {"reputation": 43, "user_id": 3046088, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/HGH4t.png?s=128&g=1", "display_name": "Ross Muir", "link": "https://stackoverflow.com/users/3046088/ross-muir"}, "reply_to_user": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1430405696, "post_id": 29969208, "comment_id": 48061631, "body": "@DanielFath I want to test that all the examples actually build without having to run them - <code>cargo build</code> runs successfully but when you look in the <code>...target&#47;debug&#47;examples</code> directory nothing exists, but if use <code>cargo run --example &lt;name&gt;</code> the example is built in that directory?"}, {"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 2, "creation_date": 1430412888, "post_id": 29969208, "comment_id": 48066818, "body": "Why is that so important? What are you trying to achieve? If your Travis CI runs <code>cargo test</code> <code>cargo build</code> it will only pass if the both are successfully built."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1430413858, "post_id": 29969208, "comment_id": 48067433, "body": "have you tried <code>cargo test examples</code>? cargo can run specific tests and skip all the others if you pass the name. Maybe that works for examples, too, as long as you do not have any tests named <code>examples</code>"}], "answers": [{"comments": [{"owner": {"reputation": 43, "user_id": 3046088, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/HGH4t.png?s=128&g=1", "display_name": "Ross Muir", "link": "https://stackoverflow.com/users/3046088/ross-muir"}, "edited": false, "score": 0, "creation_date": 1430405057, "post_id": 29970329, "comment_id": 48061205, "body": "Nothing seems to be built after running this in the <code>...target&#47;debug&#47;examples</code> directory?"}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "edited": false, "score": 1, "creation_date": 1430407626, "post_id": 29970329, "comment_id": 48063138, "body": "Still need that <code>carbo build --example &lt;blah&gt;</code>"}, {"owner": {"reputation": 43, "user_id": 3046088, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/HGH4t.png?s=128&g=1", "display_name": "Ross Muir", "link": "https://stackoverflow.com/users/3046088/ross-muir"}, "reply_to_user": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "edited": false, "score": 0, "creation_date": 1430410683, "post_id": 29970329, "comment_id": 48065457, "body": "@JorgeIsraelPe&#241;a I am on the latest Nightly and that gives me <code>Unknown flag: &#39;--example&#39;  Usage:     cargo build [options] </code>"}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 43, "user_id": 3046088, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/HGH4t.png?s=128&g=1", "display_name": "Ross Muir", "link": "https://stackoverflow.com/users/3046088/ross-muir"}, "edited": false, "score": 0, "creation_date": 1430412791, "post_id": 29970329, "comment_id": 48066757, "body": "@RossMuir my comment was directed at huon. There&#39;s currently no way to do what you want aside from what huon suggested, which ends up running the tests. My point is we need something like <code>cargo build --example &lt;blah&gt;</code>"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "reply_to_user": {"reputation": 43, "user_id": 3046088, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/HGH4t.png?s=128&g=1", "display_name": "Ross Muir", "link": "https://stackoverflow.com/users/3046088/ross-muir"}, "edited": false, "score": 0, "creation_date": 1430428352, "post_id": 29970329, "comment_id": 48075265, "body": "@RossMuir, hm, I&#39;m confused. I just ran <code>cargo clean &amp;&amp; cargo test -v</code> in one of my own projects, and the output included <code>Running `rustc examples&#47;...` </code> lines (i.e. building the examples) and <code>target&#47;debug&#47;examples&#47;</code> contains all the binaries I would expect. Could you clarify?"}, {"owner": {"reputation": 43, "user_id": 3046088, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/HGH4t.png?s=128&g=1", "display_name": "Ross Muir", "link": "https://stackoverflow.com/users/3046088/ross-muir"}, "edited": false, "score": 0, "creation_date": 1430472715, "post_id": 29970329, "comment_id": 48088260, "body": "@huon-dbaupp thanks for your help I had <code>test = false</code> set for examples in the <code>cargo.toml</code> file - setting this to true builds the examples with <code>cargo test</code>"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "reply_to_user": {"reputation": 43, "user_id": 3046088, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/HGH4t.png?s=128&g=1", "display_name": "Ross Muir", "link": "https://stackoverflow.com/users/3046088/ross-muir"}, "edited": false, "score": 0, "creation_date": 1430473916, "post_id": 29970329, "comment_id": 48088752, "body": "@RossMuir, great! (I believe that <code>test = true</code> is the default btw, so you can probably omit it entirely.)"}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 4, "last_activity_date": 1430403789, "creation_date": 1430403789, "answer_id": 29970329, "question_id": 29969208, "link": "https://stackoverflow.com/questions/29969208/how-to-build-rust-examples-without-running/29970329#29970329", "title": "How to build Rust examples without running", "body": "<p><code>cargo test</code> automatically builds examples (but doesn't run them). I believe it does this first, before the main test runners, but you can verify with <code>cargo test -v</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 11878, "user_id": 588759, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/216ea4da5cae7be4030b6242ab90631c?s=128&d=identicon&r=PG", "display_name": "rofrol", "link": "https://stackoverflow.com/users/588759/rofrol"}, "is_accepted": false, "score": 0, "last_activity_date": 1471870143, "last_edit_date": 1471870143, "creation_date": 1471870028, "answer_id": 39079987, "question_id": 29969208, "link": "https://stackoverflow.com/questions/29969208/how-to-build-rust-examples-without-running/39079987#39079987", "title": "How to build Rust examples without running", "body": "<p><code>cargo test</code> runs examples.</p>\n\n<p>To build them it I do this:</p>\n\n<pre class=\"lang-sh prettyprint-override\"><code>for i in examples/*; do cargo build --target=x86_64-pc-windows-gnu --verbose --example $(basename $i .rs); done\n</code></pre>\n\n<p><a href=\"https://github.com/rust-lang/cargo/issues/192\" rel=\"nofollow\">Cargo issue #192</a> covers a feature request for something similar.</p>\n"}, {"tags": [], "owner": {"reputation": 509, "user_id": 10320232, "user_type": "registered", "profile_image": "https://lh5.googleusercontent.com/-lLtRg7lioSs/AAAAAAAAAAI/AAAAAAAAAfQ/lxbwpkpWxuc/photo.jpg?sz=128", "display_name": "Kevin Martins", "link": "https://stackoverflow.com/users/10320232/kevin-martins"}, "is_accepted": false, "score": 1, "last_activity_date": 1554384590, "last_edit_date": 1554384590, "creation_date": 1554384553, "answer_id": 55517222, "question_id": 29969208, "link": "https://stackoverflow.com/questions/29969208/how-to-build-rust-examples-without-running/55517222#55517222", "title": "How to build Rust examples without running", "body": "<p>I use the following code to run with Travis</p>\n\n<pre><code>language: rust\nrust:\n  - stable\n  - beta\nscript:\n  - cargo build --verbose --all\n  - cargo test --verbose --all\n</code></pre>\n"}], "owner": {"reputation": 43, "user_id": 3046088, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/HGH4t.png?s=128&g=1", "display_name": "Ross Muir", "link": "https://stackoverflow.com/users/3046088/ross-muir"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2560, "favorite_count": 0, "accepted_answer_id": 29970329, "answer_count": 3, "score": 4, "last_activity_date": 1554384590, "creation_date": 1430400898, "last_edit_date": 1430404130, "question_id": 29969208, "link": "https://stackoverflow.com/questions/29969208/how-to-build-rust-examples-without-running", "title": "How to build Rust examples without running", "body": "<p>Is there any way to build Rust examples without running them?\nSpecifically to test examples build successfully using Travis CI. </p>\n"}, {"tags": ["go", "rust"], "comments": [{"owner": {"reputation": 27854, "user_id": 1892060, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e50f7bd50bf166113e2fbcf94eb9ab76?s=128&d=identicon&r=PG", "display_name": "Ainar-G", "link": "https://stackoverflow.com/users/1892060/ainar-g"}, "edited": false, "score": 0, "creation_date": 1430385023, "post_id": 29963449, "comment_id": 48047326, "body": "I don&#39;t know a lot of Rust, but wouldn&#39;t a function that takes a closure suffice?"}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1430393877, "post_id": 29963449, "comment_id": 48053029, "body": "Of course, regular files opened using Rust&#39;s libstd will close in their drop glue by themselves."}, {"owner": {"reputation": 20384, "user_id": 220060, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/56533d50fdfceb887852bf50be54678b?s=128&d=identicon&r=PG", "display_name": "nalply", "link": "https://stackoverflow.com/users/220060/nalply"}, "reply_to_user": {"reputation": 27854, "user_id": 1892060, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e50f7bd50bf166113e2fbcf94eb9ab76?s=128&d=identicon&r=PG", "display_name": "Ainar-G", "link": "https://stackoverflow.com/users/1892060/ainar-g"}, "edited": false, "score": 0, "creation_date": 1581863360, "post_id": 29963449, "comment_id": 106570690, "body": "@Ainar-G, sorry for the late answer and the jargon. Defer could be achieved with a Newtype implementing <code>Drop</code> and executing a closure you passed when creating the Newtype. However closures close over variables and then lifetimes are problematic. Let&#39;s say you close over a variable you already moved when the Newtype is going out of scope. This won&#39;t compile. I think you&#39;ll need a closure where the variables you close over move into the closure and will not be available anymore. I am not sure, but using huon&#39;s <code>defer!</code> macro seems to solve this problem because it doesn&#39;t close over anything."}], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 36, "last_activity_date": 1430400181, "last_edit_date": 1430400181, "creation_date": 1430385270, "answer_id": 29963675, "question_id": 29963449, "link": "https://stackoverflow.com/questions/29963449/golang-like-defer-in-rust/29963675#29963675", "title": "Golang-like defer in Rust", "body": "<p>(<em>e:</em> don't miss bluss's answer and their <a href=\"https://crates.io/crates/scopeguard\" rel=\"noreferrer\">scopedguard</a> crate, below.)</p>\n\n<p>The correct way to achieve this by having code that runs in a destructor, like the <code>defer!</code> macro you link to does. For anything more than ad-hoc testing I would recommend writing a handle type with a proper destructor, e.g. one interacts with <code>std::sync::Mutex</code> via its <a href=\"http://doc.rust-lang.org/nightly/std/sync/struct.MutexGuard.html\" rel=\"noreferrer\"><code>MutexGuard</code></a> type (returned by <code>lock</code>): there's no need to call <code>unlock</code> on the mutex itself. (The explicit handle-with-destructor approach is more flexible too: it has mutable access to the data, whereas the deferred approach may not be able to, due to Rust's strong aliasing controls.)</p>\n\n<p>In any case, that macro is now (much!) improved due to recent changes, in particular, pnkfelix's <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md\" rel=\"noreferrer\">sound generic drop work</a>, which removes the necessity for <code>#[unsafe_destructor]</code>. The direct update would be:</p>\n\n<pre><code>struct ScopeCall&lt;F: FnMut()&gt; {\n    c: F\n}\nimpl&lt;F: FnMut()&gt; Drop for ScopeCall&lt;F&gt; {\n    fn drop(&amp;mut self) {\n        (self.c)();\n    }\n}\n\nmacro_rules! defer {\n    ($e:expr) =&gt; (\n        let _scope_call = ScopeCall { c: || -&gt; () { $e; } };\n    )\n}\n\nfn main() {\n    let x = 42u8;\n    defer!(println!(\"defer 1\"));\n    defer!({\n        println!(\"defer 2\");\n        println!(\"inside defer {}\", x)\n    });\n    println!(\"normal execution {}\", x);\n}\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>normal execution 42\ndefer 2\ninside defer 42\ndefer 1\n</code></pre>\n\n<hr>\n\n<p>Although, it would be syntactically nicer as:</p>\n\n<pre><code>macro_rules! expr { ($e: expr) =&gt; { $e } } // tt hack\nmacro_rules! defer {\n    ($($data: tt)*) =&gt; (\n        let _scope_call = ScopeCall { \n            c: || -&gt; () { expr!({ $($data)* }) }\n        };\n    )\n}\n</code></pre>\n\n<p>(The <code>tt hack</code> is necessary due to <a href=\"https://github.com/rust-lang/rust/issues/5846\" rel=\"noreferrer\">#5846</a>.)</p>\n\n<p>The use of the generic <code>tt</code> (\"token tree\") allows one to invoke it without the inner <code>{ ... }</code> when there are multiple statements (i.e. it behaves more like a \"normal\" control flow structure):</p>\n\n<pre><code>defer! {\n    println!(\"defer 2\");\n    println!(\"inside defer {}\", x)\n}\n</code></pre>\n\n<p>Also, for maximum flexibility about what the deferred code can do with captured variables, one could use <code>FnOnce</code> instead of <code>FnMut</code>:</p>\n\n<pre><code>struct ScopeCall&lt;F: FnOnce()&gt; {\n    c: Option&lt;F&gt;\n}\nimpl&lt;F: FnOnce()&gt; Drop for ScopeCall&lt;F&gt; {\n    fn drop(&amp;mut self) {\n        self.c.take().unwrap()()\n    }\n}\n</code></pre>\n\n<p>That will also require constructing the <code>ScopeCall</code> with a <code>Some</code> around the value for <code>c</code>. The <code>Option</code> dance is required because calling a <code>FnOnce</code> moves ownership, which isn't possible from behind <code>self: &amp;mut ScopeCall&lt;F&gt;</code> without it. (Doing this is OK, since the destructor only executes once.)</p>\n\n<p>All in all:</p>\n\n<pre><code>struct ScopeCall&lt;F: FnOnce()&gt; {\n    c: Option&lt;F&gt;\n}\nimpl&lt;F: FnOnce()&gt; Drop for ScopeCall&lt;F&gt; {\n    fn drop(&amp;mut self) {\n        self.c.take().unwrap()()\n    }\n}\n\nmacro_rules! expr { ($e: expr) =&gt; { $e } } // tt hack\nmacro_rules! defer {\n    ($($data: tt)*) =&gt; (\n        let _scope_call = ScopeCall {\n            c: Some(|| -&gt; () { expr!({ $($data)* }) })\n        };\n    )\n}\n\nfn main() {\n    let x = 42u8;\n    defer!(println!(\"defer 1\"));\n    defer! {\n        println!(\"defer 2\");\n        println!(\"inside defer {}\", x)\n    }\n    println!(\"normal execution {}\", x);\n}\n</code></pre>\n\n<p>(Same output as the original.)</p>\n"}, {"comments": [{"owner": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "edited": false, "score": 2, "creation_date": 1430449742, "post_id": 29966656, "comment_id": 48081692, "body": "I wish I could accept both answers, cause this is really awesome, and likely what I will actually use. Thank you!"}], "tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": false, "score": 17, "last_activity_date": 1430395554, "last_edit_date": 1430395554, "creation_date": 1430393695, "answer_id": 29966656, "question_id": 29963449, "link": "https://stackoverflow.com/questions/29963449/golang-like-defer-in-rust/29966656#29966656", "title": "Golang-like defer in Rust", "body": "<p>I use the following for a scope guard. It uses the <code>Deref</code> traits to provide shared &amp; mutable access to the guarded value, without moving it out (that would invalidate the guard!)</p>\n\n<p>My use case is correctly resetting the terminal when the program exits, even if panicking:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>extern crate scopeguard;\nuse scopeguard::guard;\n\n// ... terminal setup omitted ...\n\n// Use a scope guard to restore terminal settings on quit/panic\nlet mut tty = guard(tty, |tty| {\n    // ... I use tty.write() here too ...\n    ts::tcsetattr(tty.as_raw_fd(), ts::TCSANOW, &amp;old_attr).ok();\n});\ngame_main(&amp;mut tty).unwrap();   // Deref coercion magic hands off the inner &amp;mut TTY pointer here.\n</code></pre>\n\n<p>Module scopeguard.rs:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::ops::{Deref, DerefMut};\n\npub struct Guard&lt;T, F&gt; where\n    F: FnMut(&amp;mut T)\n{\n    __dropfn: F,\n    __value: T,\n}\n\npub fn guard&lt;T, F&gt;(v: T, dropfn: F) -&gt; Guard&lt;T, F&gt; where\n    F: FnMut(&amp;mut T)\n{\n    Guard{__value: v, __dropfn: dropfn}\n}\n\nimpl&lt;T, F&gt; Deref for Guard&lt;T, F&gt; where\n    F: FnMut(&amp;mut T)\n{\n    type Target = T;\n    fn deref(&amp;self) -&gt; &amp;T\n    {\n        &amp;self.__value\n    }\n\n}\n\nimpl&lt;T, F&gt; DerefMut for Guard&lt;T, F&gt; where\n    F: FnMut(&amp;mut T)\n{\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut T\n    {\n        &amp;mut self.__value\n    }\n}\n\nimpl&lt;T, F&gt; Drop for Guard&lt;T, F&gt; where\n    F: FnMut(&amp;mut T)\n{\n    fn drop(&amp;mut self) {\n        (self.__dropfn)(&amp;mut self.__value)\n    }\n}\n</code></pre>\n\n<p>This is now the crate <a href=\"https://crates.io/crates/scopeguard\">scopeguard  on crates.io.</a></p>\n"}], "owner": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6363, "favorite_count": 10, "accepted_answer_id": 29963675, "answer_count": 2, "score": 27, "last_activity_date": 1430400181, "creation_date": 1430384644, "question_id": 29963449, "link": "https://stackoverflow.com/questions/29963449/golang-like-defer-in-rust", "title": "Golang-like defer in Rust", "body": "<p>In Go, you can use the <code>defer</code> keyword to execute a function when the current function returns, similar to the traditional <code>finally</code> keyword in other languages. This is useful for cleaning up state regardless of what happens throughout the function body. Here's an example from the Go blog:</p>\n\n<pre><code>func CopyFile(dstName, srcName string) (written int64, err error) {\n    src, err := os.Open(srcName)\n    if err != nil {\n        return\n    }\n    defer src.Close()\n\n    dst, err := os.Create(dstName)\n    if err != nil {\n        return\n    }\n    defer dst.Close()\n\n    return io.Copy(dst, src)\n}\n</code></pre>\n\n<p>How can this functionality be achieved in Rust? I know about RAII, but in my specific case the state is in an external system. I'm writing a test that writes a key to a key-value store, and I need to make sure it's deleted at the end of the test regardless of whether or not the assertions in the test cause a panic.</p>\n\n<p>I found <a href=\"https://gist.github.com/karablin/8568808\">this Gist</a> but I don't know if this is a recommended approach. The unsafe destructor is worrisome.</p>\n\n<p>There is also <a href=\"https://github.com/rust-lang/rust/issues/1523\">this issue</a> on the Rust GitHub repository, but it's three years old and clearly not very relevant anymore.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1430371729, "post_id": 29958807, "comment_id": 48039752, "body": "This seems to me like a bug. I can\u2019t see where the unsized type <code>std::error::Error + Send + Sync</code> (which probably doesn\u2019t implement <code>Error</code>, so that part is true) comes in\u2014the <code>T</code> in the <code>From</code> implementation is <code>std::io::error::Error</code>. <code>std::io::error::Error</code> <i>contains</i> a boxed <code>Error + Send + Sync</code>, but that shouldn\u2019t have any impact here."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1430372482, "post_id": 29958807, "comment_id": 48040089, "body": "Jon Reem helped explain it so it was clear to me: these negative impls are tied to the marker traits like <code>Send</code> and <code>Sync</code> and so it interacts poorly with trait objects; the type <code>std::error::Error</code>, for example, doesn\u2019t implement <code>Send</code>, while <code>std::error::Error + Send</code> does. Using the negative implementations approach means that anything that contains a trait object that doesn\u2019t have the <code>NotMyError</code> bound added (e.g. <code>std::error::Error + Send + Sync + NotMyError</code>) doesn\u2019t implement <code>NotMyError</code>. So sorry, this approach I fed you earlier seems like it really won\u2019t work."}], "answers": [{"tags": [], "owner": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "is_accepted": false, "score": 16, "last_activity_date": 1564672984, "last_edit_date": 1564672984, "creation_date": 1431978290, "answer_id": 30311605, "question_id": 29958807, "link": "https://stackoverflow.com/questions/29958807/how-to-implement-an-error-wrapper-for-all-existing-errors/30311605#30311605", "title": "How to implement an error wrapper for all existing Errors?", "body": "<p>There's <a href=\"https://blog.burntsushi.net/rust-error-handling/\" rel=\"noreferrer\">an excellent post about it</a>. To get first-class support for your error you need to do two things:</p>\n\n<ul>\n<li>Implement <a href=\"http://doc.rust-lang.org/std/error/trait.Error.html\" rel=\"noreferrer\">the <code>Error</code> trait</a> for your type.</li>\n<li>Implement <code>std::convert::From</code> for error types you want to use seamlessly with the <code>?</code> operator (the <a href=\"https://lib.rs/crates/quick-error\" rel=\"noreferrer\">quick_error</a> crate helps automate this).</li>\n</ul>\n"}], "owner": {"reputation": 2910, "user_id": 1329147, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/bb27892c2e4adec367d862a16db8389c?s=128&d=identicon&r=PG", "display_name": "Amos", "link": "https://stackoverflow.com/users/1329147/amos"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6757, "favorite_count": 7, "answer_count": 1, "score": 17, "last_activity_date": 1564672984, "creation_date": 1430366733, "last_edit_date": 1526937474, "question_id": 29958807, "link": "https://stackoverflow.com/questions/29958807/how-to-implement-an-error-wrapper-for-all-existing-errors", "title": "How to implement an error wrapper for all existing Errors?", "body": "<p>I want to use my customised error type in all functions and I need to wrap the existing standard errors so that the <code>?</code> operator will succeed.</p>\n\n<p>Here is what I am doing:</p>\n\n<pre><code>use std::{error::Error, fmt, fs};\n\n#[derive(Debug)]\nenum MyError {\n    A,\n    B,\n}\n\nimpl fmt::Display for MyError {\n    fn fmt(&amp;self, _f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        Ok(())\n    }\n}\n\nimpl Error for MyError {\n    fn description(&amp;self) -&gt; &amp;str {\n        \"\"\n    }\n}\n\ntrait NotMyError {}\n\nimpl&lt;T: NotMyError + Error&gt; From&lt;T&gt; for MyError {\n    fn from(_: T) -&gt; MyError {\n        MyError::A\n    }\n}\n\nfn test() -&gt; Result&lt;(), MyError&gt; {\n    fs::read_dir(\"test\")?;\n    Ok(())\n}\n\nfn main() {}\n</code></pre>\n\n<p>The compiler complains: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `std::io::Error: NotMyError` is not satisfied\n  --&gt; src/main.rs:30:5\n   |\n30 |     fs::read_dir(\"test\")?;\n   |     ^^^^^^^^^^^^^^^^^^^^^ the trait `NotMyError` is not implemented for `std::io::Error`\n   |\n   = note: required because of the requirements on the impl of `std::convert::From&lt;std::io::Error&gt;` for `MyError`\n   = note: required by `std::convert::From::from`\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1430406348, "post_id": 29958259, "comment_id": 48062131, "body": "write <code>where &amp;T: Add&lt;Output=T&gt;</code> instead, should make it compile."}], "answers": [{"comments": [{"owner": {"reputation": 900, "user_id": 602721, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/be8ca2dd9f7a396f2f1e0cadcd378aa3?s=128&d=identicon&r=PG", "display_name": "tomsgd", "link": "https://stackoverflow.com/users/602721/tomsgd"}, "edited": false, "score": 0, "creation_date": 1430363676, "post_id": 29958322, "comment_id": 48037372, "body": "If I indicate that it is Clone, does that mean an actual memcpy will take place when addition happens? Some of the types I have in mind may be quite large and I definitely want to avoid wasteful copying."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 900, "user_id": 602721, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/be8ca2dd9f7a396f2f1e0cadcd378aa3?s=128&d=identicon&r=PG", "display_name": "tomsgd", "link": "https://stackoverflow.com/users/602721/tomsgd"}, "edited": false, "score": 0, "creation_date": 1430365639, "post_id": 29958322, "comment_id": 48037913, "body": "That depends.  <code>Clone</code> simply means &quot;a copy can be made&quot;, but says nothing about the complexity.  If you can, it&#39;s best to go with the second option; then, at least, any copies that need to be made are explicit to the caller.  Also, I just realised that the <code>clone</code>s in the second example were entirely incorrect; the whole point of taking <code>a</code> and <code>b</code> by value is to <i>avoid</i> copying."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 4, "last_activity_date": 1430365586, "last_edit_date": 1430365586, "creation_date": 1430363219, "answer_id": 29958322, "question_id": 29958259, "link": "https://stackoverflow.com/questions/29958259/applying-add-implementation-to-borrowed-arguments/29958322#29958322", "title": "Applying Add implementation to borrowed arguments", "body": "<p>First of all, if you check the <a href=\"http://doc.rust-lang.org/std/ops/trait.Add.html\" rel=\"nofollow\">documentation for <code>Add</code></a>, you'll see that it's defined as taking its arguments <em>by value</em>.  Unfortunately, you cannot simply dereference <code>a</code> and <code>b</code>, because that would require moving out of an immutable reference, which isn't allowed.</p>\n\n<p>There are two ways to solve this: you can either add a <code>Clone</code> bound to <code>T</code> like so:</p>\n\n<pre><code>pub fn my_add&lt;T: Add&lt;Output = T&gt; + Clone&gt;(a: &amp;T, b: &amp;T) -&gt; T\n{\n    a.clone() + b.clone()\n}\n</code></pre>\n\n<p>...or you can just take <code>a</code> and <code>b</code> by value in the first place:</p>\n\n<pre><code>pub fn my_add&lt;T: Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T\n{\n    a + b\n}\n</code></pre>\n\n<p>As an aside, you can't add random sigils to type parameter names; if you want to so something more complex than providing basic constraints, you need a <code>where</code> clause, like so:</p>\n\n<pre><code>fn made_up_nonsense&lt;T&gt;(a: T) -&gt; T where &amp;T: SomeTrait, T: SomeOtherTrait {\n    ...\n}\n</code></pre>\n"}], "owner": {"reputation": 900, "user_id": 602721, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/be8ca2dd9f7a396f2f1e0cadcd378aa3?s=128&d=identicon&r=PG", "display_name": "tomsgd", "link": "https://stackoverflow.com/users/602721/tomsgd"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 56, "favorite_count": 0, "accepted_answer_id": 29958322, "answer_count": 1, "score": 1, "last_activity_date": 1430365586, "creation_date": 1430362811, "question_id": 29958259, "link": "https://stackoverflow.com/questions/29958259/applying-add-implementation-to-borrowed-arguments", "title": "Applying Add implementation to borrowed arguments", "body": "<p>I'm trying to add two borrowed arguments of a generic type that implements <code>Add</code>. My actual method is more complicated but the essence of my problem is captured by this simplified example:</p>\n\n<pre><code>pub fn my_add&lt;T: Add&lt;Output = T&gt;&gt;(a: &amp;T, b: &amp;T) -&gt; T\n{\n    a + b\n}\n</code></pre>\n\n<p>I get an error message saying that <code>+</code> cannot be applied to type <code>&amp;T</code>.</p>\n\n<p>My thought is that while I've indicated that <code>Add</code> is implemented for <code>T</code>, I haven't indicated that it is implemented for <code>&amp;T</code>. However, if I change the function declaration to <code>my_add&lt;&amp;T: Add...&gt;</code> the compiler complains that it expected an ident rather than a <code>&amp;</code>. \nI've tried putting the <code>&amp;</code> in numerous different locations but to no avail.</p>\n\n<p>What am I missing here? </p>\n"}, {"tags": ["struct", "rust"], "comments": [{"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 1, "creation_date": 1430358858, "post_id": 29957013, "comment_id": 48036079, "body": "You could also try CBOR: <a href=\"https://github.com/BurntSushi/rust-cbor\" rel=\"nofollow noreferrer\">github.com/BurntSushi/rust-cbor</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1430359110, "post_id": 29957013, "comment_id": 48036142, "body": "<i>but bincode is having compilation problems with the beta</i> - it does compile successfully on my nightly version. Don&#39;t have the beta handy to test with."}, {"owner": {"reputation": 3828, "user_id": 956680, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/20a0fb51ca249bf1896bf3fec079086f?s=128&d=identicon&r=PG", "display_name": "spicavigo", "link": "https://stackoverflow.com/users/956680/spicavigo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1430359275, "post_id": 29957013, "comment_id": 48036180, "body": "Thanks @Shepmaster. I will use nightly then. Everything is a moving target right now, so why not work with nightly."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1430359456, "post_id": 29957013, "comment_id": 48036229, "body": "Well, things <i>should</i> be stable now (3rd party crates are their own deal). However, I&#39;d expect that many crate authors would want to make their crates compatible with 1.0, if only so that more people can use them soon! You may want to let the bincode project know it doesn&#39;t compile with the beta."}], "owner": {"reputation": 3828, "user_id": 956680, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/20a0fb51ca249bf1896bf3fec079086f?s=128&d=identicon&r=PG", "display_name": "spicavigo", "link": "https://stackoverflow.com/users/956680/spicavigo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 82, "favorite_count": 0, "closed_date": 1430402271, "answer_count": 0, "score": 0, "last_activity_date": 1430357934, "creation_date": 1430354076, "last_edit_date": 1495539820, "question_id": 29957013, "link": "https://stackoverflow.com/questions/29957013/how-do-i-encode-or-pack-a-struct-into-bytes-without-using-an-external-library", "closed_reason": "Duplicate", "title": "How do I encode or pack a struct into bytes without using an external library?", "body": "<p>I have a struct like this</p>\n\n<pre><code>struct A {\n  id: i8,\n  key: i16,\n  name: String,\n  values: Vec&lt;String&gt;\n}\n</code></pre>\n\n<p>I wish to convert it to bytes and pad it with the converted size so I can send it over TCP. The string data should be sent as itself. I will worry about the endianness of things once this part is done.</p>\n\n<p>I am using <code>rustc 1.0.0-beta.3 (5241bf9c3 2015-04-25) (built 2015-04-25)</code>. I looked at <a href=\"https://stackoverflow.com/questions/28127165\">How to convert &#39;struct&#39; to &#39;&amp;[u8]&#39;?</a>, but bincode is having compilation problems with the beta. I am hoping to find a non-external lib way for doing the above.</p>\n"}]