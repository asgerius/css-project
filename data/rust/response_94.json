[{"tags": ["generics", "rust", "serde"], "comments": [{"owner": {"reputation": 641, "user_id": 2503352, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ee9a4c635c036b8c8aaa7d3526774e1d?s=128&d=identicon&r=PG", "display_name": "gbe", "link": "https://stackoverflow.com/users/2503352/gbe"}, "edited": false, "score": 0, "creation_date": 1477726693, "post_id": 40272063, "comment_id": 67890634, "body": "Rust <i>does</i> support generic programming: <a href=\"https://doc.rust-lang.org/book/generics.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/book/generics.html</a>"}, {"owner": {"reputation": 2779, "user_id": 2037422, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/fbe43538cf41cb5974a7bf75b7f9d843?s=128&d=identicon&r=PG", "display_name": "Pavel Davydov", "link": "https://stackoverflow.com/users/2037422/pavel-davydov"}, "reply_to_user": {"reputation": 641, "user_id": 2503352, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ee9a4c635c036b8c8aaa7d3526774e1d?s=128&d=identicon&r=PG", "display_name": "gbe", "link": "https://stackoverflow.com/users/2503352/gbe"}, "edited": false, "score": 1, "creation_date": 1477734564, "post_id": 40272063, "comment_id": 67891934, "body": "@gbe Sure, I know it does. However I need not just generics, I need to generate new functions with new identifiers (names). My current understanding is that it&#39;s unfortunatelly impossible now, because rust&#39;s macro rules do not allow generating new idents.."}], "answers": [{"tags": [], "owner": {"reputation": 2779, "user_id": 2037422, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/fbe43538cf41cb5974a7bf75b7f9d843?s=128&d=identicon&r=PG", "display_name": "Pavel Davydov", "link": "https://stackoverflow.com/users/2037422/pavel-davydov"}, "is_accepted": true, "score": 0, "last_activity_date": 1485511838, "creation_date": 1485511838, "answer_id": 41891446, "question_id": 40272063, "link": "https://stackoverflow.com/questions/40272063/how-to-implement-many-similar-methods-for-trait/41891446#41891446", "title": "How to implement many similar methods for trait?", "body": "<p>I found and example in <a href=\"https://github.com/serde-rs/bench/blob/master/src/de.rs\" rel=\"nofollow noreferrer\">serde/bench</a> project:</p>\n\n<pre><code>macro_rules! impl_nums {\n    ($ty:ty, $dser_method:ident, $visitor_method:ident, $reader_method:ident) =&gt; {\n        #[inline]\n        fn $dser_method&lt;V&gt;(&amp;mut self, mut visitor: V) -&gt; Result&lt;V::Value&gt;\n            where V: Visitor\n        {\n            let value = try!(self.reader.$reader_method::&lt;NativeEndian&gt;());\n            visitor.$visitor_method(value)\n        }\n    };\n}\n\nimpl_nums!(u16, deserialize_u16, visit_u16, read_u16);\nimpl_nums!(u32, deserialize_u32, visit_u32, read_u32);\n....\n</code></pre>\n\n<p>It looks like for now it is the best possible way to do it -  <a href=\"https://doc.rust-lang.org/std/macro.concat_idents.html\" rel=\"nofollow noreferrer\"><code>concat_idents!</code></a> macro is unstable, and is not very useful acording to <a href=\"https://github.com/rust-lang/rust/issues/13294\" rel=\"nofollow noreferrer\">this github issue</a>.</p>\n"}], "owner": {"reputation": 2779, "user_id": 2037422, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/fbe43538cf41cb5974a7bf75b7f9d843?s=128&d=identicon&r=PG", "display_name": "Pavel Davydov", "link": "https://stackoverflow.com/users/2037422/pavel-davydov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 98, "favorite_count": 0, "accepted_answer_id": 41891446, "answer_count": 1, "score": 4, "last_activity_date": 1485527077, "creation_date": 1477515789, "last_edit_date": 1485527077, "question_id": 40272063, "link": "https://stackoverflow.com/questions/40272063/how-to-implement-many-similar-methods-for-trait", "title": "How to implement many similar methods for trait?", "body": "<p>I am implementing  the <a href=\"https://docs.serde.rs/serde/ser/trait.Serializer.html\" rel=\"nofollow noreferrer\">Serde <code>Serializer</code> trait</a> which has a lot of methods. Many of them look quite similar (for example those for integer types just copy bytes to some buffer), so it would be nice to generate them somehow. Can I write some generic function or macro to implement many of them with one method (macro)?</p>\n\n<p>I have something like this:</p>\n\n<pre><code>use serde::Serializer;\nuse byteorder::{WriteBytesExt, LittleEndian};\n\nstruct MySerializer {\n     ...\n}\n\nimpl Serializer for MySerializer {\n    fn serialize_i32(&amp;mut self, v:i32) -&gt; Result&lt;(), Error&gt; {\n        try!(self.buffer.write_i32::&lt;LittleEndian&gt;(v));\n    }\n    fn serialize_u8(&amp;mut self, v:u8) -&gt; Result&lt;(), Error&gt; {\n        try!(self.buffer.write_u8::&lt;LittleEndian&gt;(v));\n    }\n    // many similar looking functions here\n}\n</code></pre>\n"}, {"tags": ["testing", "rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1477534565, "post_id": 40271926, "comment_id": 67809441, "body": "I thought that <code>#[test]</code> did imply <code>cfg(test)</code>. That still doesn&#39;t deal with helper methods or glob imports though."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477555739, "post_id": 40271926, "comment_id": 67817460, "body": "@Shepmaster Actually it appears you and OP are right, <code>#[test]</code> does seem to imply <code>#[cfg(test)]</code>. (A bit strange IMHO, but whatever.)"}], "tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "is_accepted": true, "score": 6, "last_activity_date": 1477555705, "last_edit_date": 1477555705, "creation_date": 1477515248, "answer_id": 40271926, "question_id": 40271711, "link": "https://stackoverflow.com/questions/40271711/does-a-tests-submodule-really-reduce-code-bloat-in-rust/40271926#40271926", "title": "Does a tests submodule really reduce code bloat in Rust?", "body": "<p>Yes, you can hide individual functions with <code>#[cfg(test)]</code>, and <code>#[test]</code> functions will be stripped in non-test builds (note that one can test in release mode as well!). And yes, in a release build unused functions will be optimized away. However:</p>\n\n<ul>\n<li>Adding a single <code>#[cfg(test)]</code> to a module is easier (and thus, is more likely to actually be done) than adding it on every single test.</li>\n<li>The compile-time difference still applies. In release builds, when the unused functions are stripped, they have already been analyzed, type-checked, and optimized before they get removed. It's quicker to throw the function's source code away early in the compilation process.</li>\n<li>Non-test debug builds matter, too --- and there, unused functions won't be removed.</li>\n</ul>\n"}], "owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 176, "favorite_count": 0, "accepted_answer_id": 40271926, "answer_count": 1, "score": 2, "last_activity_date": 1477555705, "creation_date": 1477514342, "last_edit_date": 1477534503, "question_id": 40271711, "link": "https://stackoverflow.com/questions/40271711/does-a-tests-submodule-really-reduce-code-bloat-in-rust", "title": "Does a tests submodule really reduce code bloat in Rust?", "body": "<p><a href=\"https://doc.rust-lang.org/book/testing.html\" rel=\"nofollow\">Section 5.2 Testing</a> in the Rust Book says</p>\n\n<blockquote>\n  <p>The [<code>tests</code>] module allows us to group all of our tests together, and to also define helper functions if needed, that don't become a part of the rest of our crate. The <code>cfg</code> attribute only compiles our test code if we're currently trying to run the tests. This can save compile time, and also ensures that our tests are entirely left out of a normal build.</p>\n</blockquote>\n\n<p>I presume functions marked as <code>#[test]</code> do not appear in release builds, even if they appear in a module that does, right?  I'd expect it's just test helper functions that might waste space.  And they could be hidden individually with <code>#[cfg(test)]</code>, right? </p>\n"}, {"tags": ["while-loop", "pattern-matching", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1477505356, "post_id": 40269242, "comment_id": 67798615, "body": "<i>and is probably not idiomatic Rust</i> \u2014 FWIW, I&#39;ve written code like that; doesn&#39;t seem bad to me."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477506969, "post_id": 40269242, "comment_id": 67799582, "body": "I&#39;d encourage answerers to focus on answering the <i>primary</i> question (guards in a <code>while let</code>). OP <a href=\"http://meta.stackexchange.com/q/39223/281829\">should probably ask another question</a> for the &quot;is there a better way&quot; aspect."}], "answers": [{"tags": [], "owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "is_accepted": true, "score": 4, "last_activity_date": 1477510832, "creation_date": 1477510832, "answer_id": 40270851, "question_id": 40269242, "link": "https://stackoverflow.com/questions/40269242/is-it-possible-to-use-pattern-matching-guards-in-a-while-let/40270851#40270851", "title": "Is it possible to use pattern matching guards in a `while let`?", "body": "<p>No, <code>while let</code> and <code>if let</code> patterns cannot have guards. There has been some discussion about changing that (e.g. <a href=\"https://github.com/rust-lang/rfcs/issues/935\" rel=\"nofollow\">here</a>), but nothing has been decided yet.</p>\n\n<p>Regarding alternatives, I think your version is pretty clear and I can't think of any ways to really improve on that.</p>\n"}], "owner": {"reputation": 9435, "user_id": 2626000, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/j8GY0.jpg?s=128&g=1", "display_name": "Aaron Christiansen", "link": "https://stackoverflow.com/users/2626000/aaron-christiansen"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2556, "favorite_count": 0, "accepted_answer_id": 40270851, "answer_count": 1, "score": 9, "last_activity_date": 1477510832, "creation_date": 1477505078, "last_edit_date": 1477505260, "question_id": 40269242, "link": "https://stackoverflow.com/questions/40269242/is-it-possible-to-use-pattern-matching-guards-in-a-while-let", "title": "Is it possible to use pattern matching guards in a `while let`?", "body": "<p>I have a <code>while let</code> loop which goes over an iterator of <code>Result</code> and uses pattern matching; it goes over the iterator until it either hits an <code>Err</code> or the <code>Ok</code>'s value is an empty string:</p>\n\n<pre><code>while let Some(Ok(a)) = some_iterator.next() {\n    if a == \"\" {\n        break;\n    }\n    // ...\n}\n</code></pre>\n\n<p>This code works fine. However, I think the <code>if</code> statement looks ugly and is probably not idiomatic Rust. In <code>match</code> statements, guards can be used in pattern matching, like so:</p>\n\n<pre><code>match foo {\n    Some(Ok(a)) if a != \"\" =&gt; bar(a)\n    // ...\n}\n</code></pre>\n\n<p>This would be ideal for my <code>while let</code> loop, although the pattern matching employed there doesn't seem to support it, causing a syntax error:</p>\n\n<pre><code>while let Some(Ok(a)) = some_iterator.next() if a != \"\" { // &lt;-- Syntax error\n    // ...\n}\n</code></pre>\n\n<p>Is there any way of using guards like this in the condition of a <code>while let</code>? If not, is there a better way of breaking out of the loop if an empty string is found?</p>\n"}, {"tags": ["arrays", "vector", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1477495637, "post_id": 40266207, "comment_id": 67792930, "body": "<i>the dimension limit is 1023</i> \u2014 no, it isn&#39;t. That&#39;s like saying that the &quot;memory limit&quot; is 4GB because that&#39;s all your computer has. Yes, stack space is limited, but it can usually be changed within some bounds. Additionally, if the item in the array takes 1MB, you would be unlikely to place 1023 of them in an array, and if the item takes a single byte, you can probably place more than 1023."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477496217, "post_id": 40266207, "comment_id": 67793313, "body": "Duplicate of <a href=\"http://stackoverflow.com/q/25151890/155423\">stackoverflow.com/q/25151890/155423</a> or <a href=\"http://stackoverflow.com/q/13102786/155423\">stackoverflow.com/q/13102786/155423</a> or <a href=\"http://stackoverflow.com/q/28145732/155423\">stackoverflow.com/q/28145732/155423</a> or <a href=\"http://stackoverflow.com/q/39240360/155423\">stackoverflow.com/q/39240360/155423</a>. <b>Please</b> respect the time of answerers by doing a search before asking questions. The specific error you are experiencing is probably explained by <a href=\"http://stackoverflow.com/q/30415354/155423\">stackoverflow.com/q/30415354/155423</a>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1477496318, "post_id": 40266207, "comment_id": 67793381, "body": "In addition, there are <a href=\"https://crates.io/\" rel=\"nofollow noreferrer\">a few crates</a> that deal with numeric and scientific computing. The authors of those crates have already put a good amount of thought into these decisions. One that I&#39;m aware of is <a href=\"https://github.com/bluss/rust-ndarray\" rel=\"nofollow noreferrer\">ndarray</a>."}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1477501605, "post_id": 40266207, "comment_id": 67796591, "body": "I described my problem and gave my code. Before that I searched hard, but not for &quot;cloning&quot; or &quot;crate&quot; to create a matrix.  I have not shown disrespect toward anyone by not using their library that I didn&#39;t know existed in a language that I tried for the first time two days ago. In retrospect, the limit of 1023 was ignorantly stated as a fact, but I just experienced it and got it confirmed by other users. So, I am not particularly sorry, but thanks for the clarifications and tips!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477502395, "post_id": 40266207, "comment_id": 67796970, "body": "I apologize, I didn&#39;t intend to suggest that you were showing disrespect to crate authors. However, A <a href=\"https://www.google.com/?q=site:stackoverflow.com+rust+2D\" rel=\"nofollow noreferrer\">Google search for &quot;rust 2d&quot;</a> provides most of the questions I just linked. That&#39;s the primary thing I would have expected someone to do before asking a question. Everything else I said is just pointing you to further information."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477496747, "post_id": 40266548, "comment_id": 67793663, "body": "<i>what the <code>vec!</code> macro does under the hood.</i> \u2014 Not quite, it&#39;s actually <a href=\"https://github.com/rust-lang/rust/blob/91f34c0c70746f5c938d25d02a8a66b41240b2f0/src/libcollections/macros.rs#L45-L53\" rel=\"nofollow noreferrer\">a bit more efficient than that</a>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477497182, "post_id": 40266548, "comment_id": 67793957, "body": "@Shepmaster: How? It invokes <code>from_elem</code> which itself invokes <a href=\"https://doc.rust-lang.org/src/collections/up/src/libcollections/vec.rs.html#1045\" rel=\"nofollow noreferrer\"><code>extend_with_element</code></a> which uses a loop. Is there a specialization somewhere?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477497262, "post_id": 40266548, "comment_id": 67794019, "body": "Sorry, I was playing a bit fast-and-loose with my wording. The <code>vec![X; N]</code> form you were saying is probably basically a loop. The <code>vec![a, b, c]</code> form is not a loop though."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1477497665, "post_id": 40266548, "comment_id": 67794312, "body": "How, extend_with_element_uses a loop where there is no reallocation condition inside the body of the loop, so it can be much more efficient. There&#39;s a PR in the pipeline to fix up Vec&#39;s collect to be equivalent if the iterator is trusted to tell its exact length."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1477500805, "post_id": 40266548, "comment_id": 67796183, "body": "@bluss: I blame Shepmaster! :D (I used <code>reserve</code> in the initial version, but it was ugly if faster... glad to know <code>collect</code> will be improved so that we can have both elegant and efficient)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1477501964, "post_id": 40266548, "comment_id": 67796764, "body": "@bluss what&#39;s your feeling; how would <code>Vec::new(); vec.reserve(); for _ in range { vec.push(X) }</code> compare to <code>range.map(X).collect</code>?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1477549422, "post_id": 40266548, "comment_id": 67813746, "body": "@bluss: Thanks :)"}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477825650, "post_id": 40266548, "comment_id": 67911864, "body": "And if I got everything right now, this is how it works: <code>&lt;_&gt;</code> means no type is specified. <code>(0..MAX)</code> is a tuple of the integers 0 to MAX. <code>|_| [0.;MAX]</code> is a <i>closure</i> (a function) taking any item <code>_</code> returning the array <code>[0.;MAX]</code> of size MAX filled with <code>0.</code>s. <code>map()</code> calls the closure for every item in the tuple producing arrays that <code>collect()</code> puts together into a Vec. From <code>0.</code> the type <code>f64</code> is inferred for the entries in the Vec."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477826426, "post_id": 40266548, "comment_id": 67912065, "body": "@Jonatan&#214;str&#246;m: Close! A tuple is declared by separating its elements with a comma as in <code>(0, MAX)</code>. <code>0..MAX</code> (no parenthesis needed) is a <a href=\"https://doc.rust-lang.org/std/ops/struct.Range.html\" rel=\"nofollow noreferrer\"><code>Range&lt;usize&gt;</code></a>, which implements the <code>Iterator</code> trait (from where the <code>map</code> method comes from) and will iterate over the half-open <code>[0, MAX)</code> range. Other ranges include <code>..</code> (<code>RangeFull</code>), <code>0..</code> (<code>RangeFrom</code>) and <code>..MAX</code> (<code>RangeTo</code>). There is also a proposal for <code>0...MAX</code> (3 dots) being an inclusive range."}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477836631, "post_id": 40266548, "comment_id": 67914913, "body": "Ah, thanks that makes a lot of sense! Those parenthesis got me thinking of tuples. And I think that triple dot is a really good idea. Then with <code>1...MAX</code> you will have a clearly stated one-based indexing, which is nice if you are used to that."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477841005, "post_id": 40266548, "comment_id": 67916116, "body": "@Jonatan&#214;str&#246;m: I am on the fence regarding the triple dot. If only because the difference between <code>..</code> and <code>...</code> is very small syntactically and therefore this seems like a small typo could easily lead to off-by-one error. I&#39;d rather have something more visually distinctive so that it&#39;s noticeable at a glance whether the range is half-open or closed."}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477848138, "post_id": 40266548, "comment_id": 67918103, "body": "Well I get that. I guess features that are syntactically allowed to be interchanged, should differ in syntax by more than a typical typo, to get a compile time error instead of unexpected run time behavior. At the same time one wants associated syntax for associated features, maybe something like <code>1..:MAX</code> would be much less typo prone."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 2, "last_activity_date": 1477518810, "last_edit_date": 1477518810, "creation_date": 1477496358, "answer_id": 40266548, "question_id": 40266207, "link": "https://stackoverflow.com/questions/40266207/how-to-make-a-large-2d-matrix/40266548#40266548", "title": "How to make a large 2D Matrix", "body": "<p>You are hitting the issue that Rust does not support non-type generic parameters yet, and therefore traits on <code>[T; N]</code> are only implemented for values of <code>N</code> from <code>0</code> to <code>32</code> (inclusive). Yes, it's annoying.</p>\n\n<p>A simple work-around is to use a loop:</p>\n\n<pre><code>let v: Vec&lt;_&gt; = (0..MAX).map(|_| [0.; MAX]).collect();\n</code></pre>\n\n<p>which is close to what the <code>vec!</code> macro does under the hood<sup>1</sup>.</p>\n\n<p>Otherwise it would be possible to wrap your array in a custom type and implement <code>Clone</code> for it (and <code>Index</code>). It's also a possibility.</p>\n\n<hr>\n\n<p><sup>1</sup> <code>vec![T; N]</code> is a bit smarter and will ensure memory is only allocated once rather than having multiple allocations. However, according to @bluss, who has been contributed an impressive number of quality performance improvements to the library, <code>collect</code> should soon become smart enough to do a single allocation for most common iterators, too.</p>\n"}], "owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 306, "favorite_count": 0, "accepted_answer_id": 40266548, "answer_count": 1, "score": 0, "last_activity_date": 1477518810, "creation_date": 1477495413, "last_edit_date": 1495535248, "question_id": 40266207, "link": "https://stackoverflow.com/questions/40266207/how-to-make-a-large-2d-matrix", "title": "How to make a large 2D Matrix", "body": "<p>I want to make a large square array, but the dimension limit is 1023. Therefore, I want to make a <code>Vec</code> of 1D-arrays, as suggested <a href=\"https://stackoverflow.com/a/40261543/4483861\">in a comment</a>. I tried this as a start:</p>\n\n<pre><code>fn main() { \n    const VMAX: usize = 1000; \n    const ALEN: usize = 32; \n    let mut arr2: Vec&lt;[f64; ALEN]&gt; = vec![[0.0; ALEN]; VMAX];}\n</code></pre>\n\n<p>which is fine for any value of <code>VMAX</code>, but <code>ALEN</code> larger than 32 gives: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `[f64; 33]: std::clone::Clone` is not satisfied\n --&gt; &lt;std macros&gt;:2:1\n  |\n2 | $ crate :: vec :: from_elem ( $ elem , $ n ) ) ; ( $ ( $ x : expr ) , * ) =&gt; (\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\ntes3.rs:4:35: 4:58 note: in this expansion of vec! (defined in &lt;std macros&gt;)\n  |\n  = help: the following implementations were found:\n  = help:   &lt;[T; 0] as std::clone::Clone&gt;\n  = help:   &lt;[T; 1] as std::clone::Clone&gt;\n  = help:   &lt;[T; 2] as std::clone::Clone&gt;\n  = help:   &lt;[T; 3] as std::clone::Clone&gt;\n  = help: and 29 others\n  = note: required by `std::vec::from_elem`\n</code></pre>\n\n<p>Something is going wrong and I have problems finding info and interpreting the error message. How can I make my giant square matrix? A different approach would be fine too, performance is important. Of course, I would do something with the array, like looping over the indices and putting some values in it, for example. </p>\n"}, {"tags": ["rust", "move", "box"], "answers": [{"comments": [{"owner": {"reputation": 13, "user_id": 4109107, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-KK_hmMw5ZAk/AAAAAAAAAAI/AAAAAAAAAMg/Ef5SIu1pHw0/photo.jpg?sz=128", "display_name": "Alexander Antoshuk", "link": "https://stackoverflow.com/users/4109107/alexander-antoshuk"}, "edited": false, "score": 0, "creation_date": 1477488376, "post_id": 40263053, "comment_id": 67787474, "body": "In this simple  example borrowing is not needed, but in real code this needed"}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 13, "user_id": 4109107, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-KK_hmMw5ZAk/AAAAAAAAAAI/AAAAAAAAAMg/Ef5SIu1pHw0/photo.jpg?sz=128", "display_name": "Alexander Antoshuk", "link": "https://stackoverflow.com/users/4109107/alexander-antoshuk"}, "edited": false, "score": 0, "creation_date": 1477488635, "post_id": 40263053, "comment_id": 67787681, "body": "@AlexanderAntoshuk in that case you probably need to restructure your code, e.g. put the borrow in its own scope."}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 1, "last_activity_date": 1477488222, "last_edit_date": 1477488222, "creation_date": 1477486981, "answer_id": 40263053, "question_id": 40262957, "link": "https://stackoverflow.com/questions/40262957/how-can-i-pass-a-boxed-member-of-a-borrowed-struct-to-a-function-without-copying/40263053#40263053", "title": "How can I pass a boxed member of a borrowed struct to a function without copying it?", "body": "<p>Your <code>calc_data</code> consumes its argument; you can't consume <code>x</code> when <code>d</code> is borrowed, though. If you don't want to change the signature of <code>calc_data</code> you need to drop the borrow.</p>\n\n<pre><code>fn main() {\n    let b = BigData {};\n    let d = Data { x: Box::new(b) };\n    calc_data(d.x);\n}\n</code></pre>\n\n<p>Since you are consuming the argument, the boxed data is not copied.</p>\n"}, {"comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 3, "creation_date": 1477488139, "post_id": 40263215, "comment_id": 67787270, "body": "Although you probably wouldn&#39;t really want to pass <code>&amp;Box&lt;BigData&gt;</code> unless you specifically want to work with the <code>Box</code> (and there&#39;s not a lot you can do with it immutably). Probably <code>calc_data</code> should just take <code>&amp;BigData</code> and let the caller worry about whether it&#39;s boxed or not"}, {"owner": {"reputation": 13, "user_id": 4109107, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-KK_hmMw5ZAk/AAAAAAAAAAI/AAAAAAAAAMg/Ef5SIu1pHw0/photo.jpg?sz=128", "display_name": "Alexander Antoshuk", "link": "https://stackoverflow.com/users/4109107/alexander-antoshuk"}, "edited": false, "score": 0, "creation_date": 1477488525, "post_id": 40263215, "comment_id": 67787594, "body": "Is it a idiomatic way? I mean &amp;Box ? What about performance? Looks like another level of indirection here or it will be optimized by compiler?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1477488714, "post_id": 40263215, "comment_id": 67787743, "body": "Thanks, I agree that&#39;s better."}, {"owner": {"reputation": 13, "user_id": 4109107, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-KK_hmMw5ZAk/AAAAAAAAAAI/AAAAAAAAAMg/Ef5SIu1pHw0/photo.jpg?sz=128", "display_name": "Alexander Antoshuk", "link": "https://stackoverflow.com/users/4109107/alexander-antoshuk"}, "edited": false, "score": 0, "creation_date": 1477488834, "post_id": 40263215, "comment_id": 67787837, "body": "In real code I have Boxed trait, not boxed structure. So i don&#39;t know is it possible to use it without box as a struct member. Can i use something like &amp;MyTrait instead of Box&lt;MyTrait&gt; ?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1477489124, "post_id": 40263215, "comment_id": 67788081, "body": "... but you need to call it as <code>calc_data(&amp;*borrowed_d.x)</code>."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 3, "last_activity_date": 1477488706, "last_edit_date": 1477488706, "creation_date": 1477487400, "answer_id": 40263215, "question_id": 40262957, "link": "https://stackoverflow.com/questions/40262957/how-can-i-pass-a-boxed-member-of-a-borrowed-struct-to-a-function-without-copying/40263215#40263215", "title": "How can I pass a boxed member of a borrowed struct to a function without copying it?", "body": "<p>You can just borrow the boxed member and pass by reference:</p>\n\n<pre><code>struct BigData {}\n\nstruct Data {\n    x: Box&lt;BigData&gt;,\n}\n\nfn calc_data(x: &amp;Box&lt;BigData&gt;) {}\n\nfn main() {\n    let b = BigData {};\n    let d = Data { x: Box::new(b) };\n    let borrowed_d = &amp;d;\n    calc_data(&amp;borrowed_d.x);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=b32fb63faa73df0efd25f927aec069db&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">playground</a></p>\n\n<p>But it's unlikely you actually want to pass a reference to the box rather than the <code>BigData</code> itself, so you can just do:</p>\n\n<pre><code>fn calc_data(x: &amp;BigData) {}\n</code></pre>\n\n<p>and call it in the same way (<code>&amp;Box&lt;T&gt;</code> automatically converts to <code>&amp;T</code>).</p>\n"}], "owner": {"reputation": 13, "user_id": 4109107, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-KK_hmMw5ZAk/AAAAAAAAAAI/AAAAAAAAAMg/Ef5SIu1pHw0/photo.jpg?sz=128", "display_name": "Alexander Antoshuk", "link": "https://stackoverflow.com/users/4109107/alexander-antoshuk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 106, "favorite_count": 0, "accepted_answer_id": 40263215, "answer_count": 2, "score": 0, "last_activity_date": 1477488706, "creation_date": 1477486676, "last_edit_date": 1477488168, "question_id": 40262957, "link": "https://stackoverflow.com/questions/40262957/how-can-i-pass-a-boxed-member-of-a-borrowed-struct-to-a-function-without-copying", "title": "How can I pass a boxed member of a borrowed struct to a function without copying it?", "body": "<p>In my example I get an error:</p>\n\n<blockquote>\n  <p>cannot move out of borrowed content</p>\n</blockquote>\n\n<pre><code>struct BigData {}\n\nstruct Data {\n    x: Box&lt;BigData&gt;,\n}\n\nfn calc_data(x: Box&lt;BigData&gt;) {}\n\nfn main() {\n    let b = BigData {};\n    let d = Data { x: Box::new(b) };\n    let borrowed_d = &amp;d;\n    calc_data(borrowed_d.x); //error: cannot move out of borrowed content\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?code=struct%20BigData%7B%7D%0A%0Astruct%20Data%7B%0A%20%20%20%20x%3A%20Box%3CBigData%3E%20%20%20%20%20%20%20%20%0A%7D%0A%0Afn%20calc_data(x%3A%20Box%3CBigData%3E)%7B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20b%20%3D%20BigData%7B%7D%3B%0A%20%20%20%20let%20d%20%3D%20Data%7Bx%3A%20Box%3A%3Anew(b)%7D%3B%0A%20%20%20%20let%20borrowed_d%20%3D%20%26d%3B%0A%20%20%20%20calc_data(borrowed_d.x)%3B%0A%7D%0A&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">playground</a></p>\n"}, {"tags": ["arrays", "segmentation-fault", "rust"], "comments": [{"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 0, "creation_date": 1477482061, "post_id": 40261308, "comment_id": 67783127, "body": "This is because in debug mode it is created on the stack; and the stack is too small to contain it. See here: <a href=\"http://stackoverflow.com/questions/30242770/how-to-allocate-arrays-on-the-heap-in-rust-1-0-beta?noredirect=1&amp;lq=1\" title=\"how to allocate arrays on the heap in rust 1 0 beta\">stackoverflow.com/questions/30242770/&hellip;</a>"}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "reply_to_user": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 0, "creation_date": 1477482106, "post_id": 40261308, "comment_id": 67783163, "body": "How do I exit debug mode?"}, {"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 0, "creation_date": 1477482167, "post_id": 40261308, "comment_id": 67783203, "body": "You can run <code>cargo run --release</code> or turn on optimization on <code>rustc</code>"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 0, "creation_date": 1477482361, "post_id": 40261308, "comment_id": 67783302, "body": "@Neikos: Doesn&#39;t matter here, because he IS creating the array on the stack without any intent to move it on the heap anyway, so Debug and Release will both crash."}, {"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 0, "creation_date": 1477482658, "post_id": 40261308, "comment_id": 67783463, "body": "Oops, you are correct. I got distracted by my link."}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477482688, "post_id": 40261308, "comment_id": 67783482, "body": "<code>cargo run --release</code> gave <code>error: could not find &#39;Cargo.toml&#39; in &#47;my&#47;home&#47;dir or any parent directory</code>"}], "answers": [{"comments": [{"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477482987, "post_id": 40261543, "comment_id": 67783658, "body": "Thank you, I&#39;ll try the Vec. I really don&#39;t care if it&#39;s the stack or the heap and I wasn&#39;t aware I had made that choice by using an array. I assumed arrays are faster because they are type restricted and static."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477484092, "post_id": 40261543, "comment_id": 67784384, "body": "@Jonatan&#214;str&#246;m: in theory arrays may be faster because eliding bounds checks is easier for the optimizer, this means that using a <code>Box&lt;[[f64; MAX]; MAX]&gt;</code> to place the array on the heap could have some advantage... but there is no stable way in Rust today to place the array on the heap without first constructing it on the stack (there is a reflexion on the best way to accomplish this in a manner that would not be hardcoded). Using <code>Vec</code> might prevent some bounds-check elisions for index-based access, iterators optimize better."}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477484863, "post_id": 40261543, "comment_id": 67784945, "body": "Now that I read a bit more about the Vec structure, it seems as it is only one-dimensional, is that right? This example could be altered in that sense, but the ability to use a large multidimensional arrays is kind of important for the intended applications so maybe I&#39;ll check on Rust in the future to see it if these kinds of features have improved."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 1, "creation_date": 1477484943, "post_id": 40261543, "comment_id": 67784983, "body": "@Jonatan&#214;str&#246;m: <code>Vec</code> is one dimensional, but nothing prevents you from storing arrays in <code>Vec</code> as in <code>Vec&lt;[f64; MAX]&gt;</code> :) Rust guarantees that you will get all the <code>Vec</code> elements assigned contiguously, so it&#39;ll just be one big blob of memory (<code>mem::size_of::&lt;f64&gt;() * MAX * MAX</code> bytes) but you&#39;ll be able to access it with <code>vec[i][j]</code> as if you had nested arrays."}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477488891, "post_id": 40261543, "comment_id": 67787886, "body": "OK, now that&#39;s a different story! So to create the largest possible square matrix consisting of a single Vec that consists of 1D-arrays I could have 1023^2 1D-arrys, each having 1023^2 entries. Which should be fine. I&#39;ll try that approach. Thank you again!"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 6, "last_activity_date": 1477482655, "last_edit_date": 1495541960, "creation_date": 1477482655, "answer_id": 40261543, "question_id": 40261308, "link": "https://stackoverflow.com/questions/40261308/segmentation-fault-for-array-larger-than-1022x1022/40261543#40261543", "title": "Segmentation fault for array larger than 1022x1022", "body": "<p>You have a <em>Stack Overflow</em> (how ironic, hey?).</p>\n\n<p>There are two solutions to the issue:</p>\n\n<ol>\n<li>Do not allocate a large array on the stack, use the heap instead (<code>Vec</code>)</li>\n<li>Only do so on a large stack.</li>\n</ol>\n\n<p>Needless to say, using a <code>Vec</code> is just much easier; and you can use a <code>Vec[f64; MAX]</code> if you wish.</p>\n\n<p>If you insist on using the stack, then I will redirect you <a href=\"https://stackoverflow.com/questions/29937697/how-to-set-the-thread-stack-size-during-compile-time\">to this question</a>.</p>\n"}], "owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 172, "favorite_count": 0, "accepted_answer_id": 40261543, "answer_count": 1, "score": 0, "last_activity_date": 1477483180, "creation_date": 1477481862, "last_edit_date": 1477483180, "question_id": 40261308, "link": "https://stackoverflow.com/questions/40261308/segmentation-fault-for-array-larger-than-1022x1022", "title": "Segmentation fault for array larger than 1022x1022", "body": "<p>I don't know Rust but I wanted to investigate the performance in scientific computing to compare it to Julia and Fortran. I managed to write the following program but the problem is that I get a runtime segmentation fault when <code>MAX</code> is larger than 1022. Any advice? </p>\n\n<pre><code>fn main() {\n    const MAX: usize = 1023;\n    let mut arr2: [[f64;  MAX];  MAX] = [[0.0;  MAX];  MAX]; \n\n    let pi: f64 = 3.1415926535;\n    // compute something useless and put in matrix\n    for ii in 0.. MAX {\n        for jj in 0.. MAX {\n            let i = ii as f64;\n            let j = jj as f64;\n            arr2[ii][jj] = ((i + j) * pi * 41.0).sqrt().sin();\n        }\n    }\n\nlet mut sum0:f64 = 0.0;\n\n//collapse to scalar like sum(sum(array,1),2) in other langs\nfor iii in 0..MAX {\n    let vec1:&amp;[f64] = &amp;arr2[iii][..];\n    sum0 += vec1.iter().sum();\n}\nprintln!(\"this {}\", sum0);\n}\n</code></pre>\n\n<p>So no error just 'Segmentaion fault' in the terminal. I'm using Ubuntu 16 and installed with the command on www.rustup.rs. It is stable version <code>rustc 1.12.1 (d4f39402a 2016-10-19)</code>. </p>\n"}, {"tags": ["rust", "immutability"], "comments": [{"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 1, "creation_date": 1477478952, "post_id": 40260132, "comment_id": 67781144, "body": "Why? You could abuse some iterator adapters (<code>fold</code> and <code>take_while</code>, just ignoring the loop value), but that would just hide the mutability from you. This is perfectly idiomatic Rust. Is this a toy problem and you have some specific problem where something similar is making the borrow checker complain?"}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1477479096, "post_id": 40260132, "comment_id": 67781253, "body": "Also, trying to be helpful, not mean. Comments force terseness."}, {"owner": {"reputation": 1835, "user_id": 6292577, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/gqMCP.jpg?s=128&g=1", "display_name": "rityzmon", "link": "https://stackoverflow.com/users/6292577/rityzmon"}, "reply_to_user": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1477479404, "post_id": 40260132, "comment_id": 67781442, "body": "Would like to minimize mutability since it aids in understanding the logic. Referential integrity and all that."}, {"owner": {"reputation": 1835, "user_id": 6292577, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/gqMCP.jpg?s=128&g=1", "display_name": "rityzmon", "link": "https://stackoverflow.com/users/6292577/rityzmon"}, "reply_to_user": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1477481490, "post_id": 40260132, "comment_id": 67782793, "body": "Haha. Sorry. I meant referential transparency."}], "answers": [{"comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1477480152, "post_id": 40260449, "comment_id": 67781931, "body": "Not exactly, I don&#39;t think.  You could write one, but the plain boring for loop is probably easier to understand.  :-)"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 2, "last_activity_date": 1477479412, "creation_date": 1477479412, "answer_id": 40260449, "question_id": 40260132, "link": "https://stackoverflow.com/questions/40260132/how-can-i-remove-the-mutable-variable-in-this-mandelbrot-function-without-recurs/40260449#40260449", "title": "How can I remove the mutable variable in this mandelbrot function without recursion?", "body": "<p>It's not possible.</p>\n\n<p>You need to create the values of <code>z</code> for each iteration at some point.  So either you have a mutable location to store each one in, or you need space for all of them.</p>\n\n<p>You can hide the mutability inside an iterator, though:</p>\n\n<pre><code>struct MandelIterator {\n    c: f32,\n    z: f32,\n}\n\nfn mandel_iter(c: f32) -&gt; MandelIterator {\n    MandelIterator { c: c, z: 0.0 }\n}\n\nimpl Iterator for MandelIterator {\n    type Item = f32;\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.z = self.z * self.z + self.c;\n        Some(self.z)\n    }\n}\n\nfn mandel_escape(x: f32, y: f32, limit: f32, orbits: usize) -&gt; Option&lt;usize&gt; {\n    for (i, z) in mandel_iter(x*y).enumerate().take(orbits) {\n        if z.abs() &gt; limit { return Some(i); }\n    }\n    None\n}\n\nfn main() {\n    println!(\"{:?}\", mandel_escape(1.00001, 1.00001, 40999.0, 4));\n}\n</code></pre>\n"}], "owner": {"reputation": 1835, "user_id": 6292577, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/gqMCP.jpg?s=128&g=1", "display_name": "rityzmon", "link": "https://stackoverflow.com/users/6292577/rityzmon"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 247, "favorite_count": 0, "accepted_answer_id": 40260449, "answer_count": 1, "score": 0, "last_activity_date": 1477485990, "creation_date": 1477478549, "last_edit_date": 1477485990, "question_id": 40260132, "link": "https://stackoverflow.com/questions/40260132/how-can-i-remove-the-mutable-variable-in-this-mandelbrot-function-without-recurs", "title": "How can I remove the mutable variable in this mandelbrot function without recursion?", "body": "<p>The following function calculates the number of orbits it takes for an <a href=\"https://en.wikipedia.org/wiki/Mandelbrot_set\" rel=\"nofollow\">mandelbrot fractal</a> initial value to \"escape\":</p>\n\n<pre><code>extern crate num;\n\nfn mandel_escape(x: f32, y: f32, limit: f32, orbits: u32) -&gt; Option&lt;u32&gt; {\n    let c = num::complex::Complex32::new(x, y);\n    let mut z = c;\n    for i in 0 .. orbits {\n        z = z * z + c;\n        if z.norm_sqr() &gt; limit { return Some(i); }\n    }\n    None\n}\n</code></pre>\n\n<p>I understand that there is no guaranteed tail call optimization in Rust. How might I be able to remove the mutable variable in this function without recursion?</p>\n"}, {"tags": ["indexing", "rust"], "comments": [{"owner": {"reputation": 26154, "user_id": 5436257, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/iGuaK.jpg?s=128&g=1", "display_name": "Joe Clay", "link": "https://stackoverflow.com/users/5436257/joe-clay"}, "edited": false, "score": 0, "creation_date": 1477478144, "post_id": 40259802, "comment_id": 67780669, "body": "There actually are hints - <i>&quot;note: slice indices are of type <code>usize</code>&quot;</i> on an array, and <i>&quot;the type <code>std::vec::Vec&lt;&amp;str&gt;</code> cannot be indexed by <code>u8</code>&quot;</i> on a vector. Admittedly they&#39;re not as clear as they could be, though. <a href=\"https://play.rust-lang.org/?gist=b5b9b067d15266c9a89df5d7f2c1fd84&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}], "answers": [{"comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 1, "creation_date": 1477488375, "post_id": 40260098, "comment_id": 67787472, "body": "How would adding indexing with smaller types be backwards incompatible?"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1477488484, "post_id": 40260098, "comment_id": 67787555, "body": "@delnan Currently, <code>some_arr[0]</code> works because there is only <i>one</i> implementation of <code>Index</code> for slices.  If you added others, the compiler could no longer decide which one you wanted.  At least, that&#39;s how I remember it."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1477488989, "post_id": 40260098, "comment_id": 67787980, "body": "Oh, good point. There is one way out (aside from smarter inference): <a href=\"https://play.rust-lang.org/?gist=27e3abd1249a3d0b3f66c8a54a0b0cfe&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">allow <code>i32</code> indices</a>"}, {"owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "edited": false, "score": 0, "creation_date": 1477499915, "post_id": 40260098, "comment_id": 67795665, "body": "I see.  It&#39;s the backwards compatibility issue that breaks adding more types.  Thanks!"}, {"owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "edited": false, "score": 0, "creation_date": 1477500166, "post_id": 40260098, "comment_id": 67795830, "body": "Actually I wonder if Rust&#39;s preference for <code>i32</code> might make <code>some_arr[0]</code> still work, but as <code>i32</code> rather than <code>usize</code>."}, {"owner": {"reputation": 4394, "user_id": 534238, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/nZVSf.jpg?s=128&g=1", "display_name": "Mike Williamson", "link": "https://stackoverflow.com/users/534238/mike-williamson"}, "edited": false, "score": 0, "creation_date": 1495845891, "post_id": 40260098, "comment_id": 75435850, "body": "I am new to Rust and trying to get my head around it.  I do not understand the backward-compatibility issue you&#39;re mentioning.  I&#39;m imagining that at some point the only value allowed was usize.  But Rust differentiates <b>slices</b> from a <b>single index</b>.  Wouldn&#39;t a u32 or similar integer always be safe for indexing?  Thanks!"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 4394, "user_id": 534238, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/nZVSf.jpg?s=128&g=1", "display_name": "Mike Williamson", "link": "https://stackoverflow.com/users/534238/mike-williamson"}, "edited": false, "score": 1, "creation_date": 1495857624, "post_id": 40260098, "comment_id": 75437639, "body": "@MikeWilliamson: First, you&#39;re forgetting that Rust has type inference.  If you could suddenly <i>also</i> index by <code>u32</code>, then cases where Rust inferred the type of a variable based on its usage as an index would no longer compile due to there being multiple possible solutions.  Secondly, you&#39;re forgetting that Rust also targets embedded processors which might only have 16-bit <code>usize</code>s, meaning a <code>u32</code> is <i>not</i> always safe for indexing.  Third: when I said &quot;slice&quot;, I mean <code>[T]</code>, not <code>a..b</code> which is a <code>Range</code>."}, {"owner": {"reputation": 4394, "user_id": 534238, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/nZVSf.jpg?s=128&g=1", "display_name": "Mike Williamson", "link": "https://stackoverflow.com/users/534238/mike-williamson"}, "edited": false, "score": 0, "creation_date": 1496888240, "post_id": 40260098, "comment_id": 75849501, "body": "Thanks, @DK.  Actually, I wasn&#39;t &quot;forgetting&quot;... I just didn&#39;t know yet!  ;-p   The second issue - allowing for embedded &amp; tiny processors (or perhaps really huge ones some day) - makes a lot of sense. I was just assuming that &quot;u32 would always be big enough, but not so big that it wasted space&quot;.  My ignorance there."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 14, "last_activity_date": 1477478475, "creation_date": 1477478475, "answer_id": 40260098, "question_id": 40259802, "link": "https://stackoverflow.com/questions/40259802/why-are-all-indexes-in-rust-of-type-usize/40260098#40260098", "title": "Why are all indexes in Rust of type usize?", "body": "<blockquote>\n  <p>Rust's <code>std::ops::Index&lt;T&gt;</code> only supports <code>T</code> being a <code>usize</code>.</p>\n</blockquote>\n\n<p>This is just not true.  <a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html\"><code>HashMap</code></a>, for example, accepts any type that the key type can borrow to (so you can index a <code>HashMap&lt;String, _&gt;</code> using a <code>&amp;str</code>).</p>\n\n<p><em>Slices</em> only allow you to index them using <code>usize</code>, as do all container types that either pretend to be, or actually <em>are</em>, linear in memory.  That's because <code>usize</code> is the <em>correct</em> type with which to index them.  Any other type would either not be able to access the full potential range of the container, or would allow for indices that cannot possibly exist.</p>\n\n<p>People have asked in the past about adding smaller types to slice indexing, but this would be backward-incompatible, so it's not going to happen any time soon.</p>\n"}], "owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3664, "favorite_count": 0, "accepted_answer_id": 40260098, "answer_count": 1, "score": 9, "last_activity_date": 1477485221, "creation_date": 1477477647, "last_edit_date": 1477485221, "question_id": 40259802, "link": "https://stackoverflow.com/questions/40259802/why-are-all-indexes-in-rust-of-type-usize", "title": "Why are all indexes in Rust of type usize?", "body": "<p>Rust's <code>std::ops::Index&lt;T&gt;</code> <a href=\"https://doc.rust-lang.org/core/ops/trait.Index.html\" rel=\"noreferrer\">only</a> supports <code>T</code> being a <code>usize</code>.  What is the reason behind this?</p>\n\n<p>Also, there is no advice to \"try using usize\" when you attempt to use anything else, just a \"trait <code>[&amp;'static str]: core::ops::Index&lt;u8&gt;</code> not satisfied\" error.  Is this maybe because they plan to support more types <code>T</code>, but delayed doing so for some reason?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 365, "user_id": 2593302, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17fe83beb5917d7541b088a20bce08b3?s=128&d=identicon&r=PG&f=1", "display_name": "chad", "link": "https://stackoverflow.com/users/2593302/chad"}, "edited": false, "score": 1, "creation_date": 1479946069, "post_id": 40256524, "comment_id": 68775977, "body": "As far as I know, none of the things you have listed really exist anymore, at least not in that form. Your best bet is to write a compiler plugin/procedural macro. These allow you to execute arbitrary code at compile time so I&#39;d hardly call them limited in scope. The documentation seems pretty sparse right now, but you may want to take a look at some projects which utilize them, such as <a href=\"https://github.com/docopt/docopt.rs\" rel=\"nofollow noreferrer\">doctopt.rs</a> and <a href=\"https://github.com/diesel-rs/diesel/tree/master/diesel_codegen\" rel=\"nofollow noreferrer\">Diesel</a>"}, {"owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "edited": false, "score": 1, "creation_date": 1489904712, "post_id": 40256524, "comment_id": 72869634, "body": "Procedural macros are being rewritten at the moment (<a href=\"https://github.com/rust-lang/rust/issues/38356\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/38356</a>) so I&#39;m not sure how much of this question will still make sense."}], "answers": [{"tags": [], "owner": {"reputation": 5869, "user_id": 2543666, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4e7c6887ce958029525412ab297b5895?s=128&d=identicon&r=PG", "display_name": "Thayne", "link": "https://stackoverflow.com/users/2543666/thayne"}, "is_accepted": true, "score": 1, "last_activity_date": 1556645192, "last_edit_date": 1556645192, "creation_date": 1506659206, "answer_id": 46481806, "question_id": 40256524, "link": "https://stackoverflow.com/questions/40256524/what-kind-of-rust-plugins-syntax-extensions-can-be-written-and-where-are-they-do/46481806#46481806", "title": "What kind of Rust plugins/syntax extensions can be written and where are they documented?", "body": "<p>That site is pretty out of date \u2014 it's from before Rust was stabilized. The only \"plugins/syntax extensions\" supported in Rust 1.20 are macros by example and custom derive, both of which are in <a href=\"https://doc.rust-lang.org/stable/book/\" rel=\"nofollow noreferrer\"><em>The Rust Programming Language</em></a>. Unstable Rust also has <a href=\"https://doc.rust-lang.org/unstable-book/language-features/custom-attribute.html\" rel=\"nofollow noreferrer\">custom attributes</a> and <a href=\"https://doc.rust-lang.org/unstable-book/language-features/proc-macro.html\" rel=\"nofollow noreferrer\">procedural macros</a>, but both of those will likely change before they are stabilized. </p>\n\n<p>A rough mapping of the extension types listed in that site to the current types of macros would be something like:</p>\n\n<ul>\n<li>Decorator -> Custom Derive</li>\n<li>Modifier, MultiModifier -> Custom Attribute</li>\n<li>NormalTT -> Procedural Macros</li>\n<li>IdentTT -> Procedural Macros (I don't entirely understand what they are though, so I'm not sure)</li>\n<li>MacroRulesTT -> Macros by Example (a.k.a. Declarative Macros)</li>\n</ul>\n\n<p>Examples of macros by example are easy to find (for example <code>std</code> and the <code>log</code> crate make extensive use of them). The <code>serde_derive</code> crate is probably the best example of using custom derive.</p>\n\n<p><strong>UPDATE:</strong></p>\n\n<p>Procederual macros (including custom attributes) were stabilized in Rust 1.30. See <a href=\"https://doc.rust-lang.org/stable/book/ch19-06-macros.html\" rel=\"nofollow noreferrer\">https://doc.rust-lang.org/stable/book/ch19-06-macros.html</a></p>\n"}], "owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 224, "favorite_count": 0, "accepted_answer_id": 46481806, "answer_count": 1, "score": 12, "last_activity_date": 1556645192, "creation_date": 1477468030, "last_edit_date": 1478897261, "question_id": 40256524, "link": "https://stackoverflow.com/questions/40256524/what-kind-of-rust-plugins-syntax-extensions-can-be-written-and-where-are-they-do", "title": "What kind of Rust plugins/syntax extensions can be written and where are they documented?", "body": "<p><a href=\"https://www.gulshansingh.com/posts/how-to-write-a-rust-syntax-extension/\">This</a> site goes over six types of syntax extensions in Rust as of 1.0. <code>Decorator</code>, <code>Modifier</code>, <code>MultiModifier</code>, <code>NormalTT</code>, <code>IdentTT</code>, and <code>MacroRulesTT</code>. </p>\n\n<p>Unfortunately, all of its links to documentation for these (and related compiler extension) items appear to be defunct.  Indeed, even manually searching the Rust documentation for <a href=\"https://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html\">SyntaxExtension</a> or even the <a href=\"https://doc.rust-lang.org/std/?search=syntax\">syntax</a> module yields nothing. It <a href=\"https://github.com/rust-lang/rust/tree/master/src/libsyntax\">still</a> appears to be in the main Rust repository in the master branch, so it's clearly not a matter of just being in the nursery somewhere.</p>\n\n<p>Of note, that page mentions that at some point \"soon\" (as of 1.0) <code>MultiModifier</code> and <code>Modifier</code> may be merged, but due to the disappearing documentation I can't confirm this as of the current Nightly.</p>\n\n<p>The <a href=\"https://doc.rust-lang.org/book/compiler-plugins.html\">book</a> only documents basic lints and \"procedural macros\", which seem to be fairly limited in scope.</p>\n\n<p>So, as of now, are there still 6 syntax extension types? Has their documentation been kept up to date in some new location? Do each of them still perform roughly the same function as they did around 1.0?</p>\n"}, {"tags": ["c", "rust", "ffi"], "comments": [{"owner": {"reputation": 361191, "user_id": 440558, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/9ZYta.jpg?s=128&g=1", "display_name": "Some programmer dude", "link": "https://stackoverflow.com/users/440558/some-programmer-dude"}, "edited": false, "score": 0, "creation_date": 1477464095, "post_id": 40255192, "comment_id": 67772266, "body": "I assume you can&#39;t change the library function? Then you probably have to live with the cast and the warning."}, {"owner": {"reputation": 6933, "user_id": 2580955, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/WZR9N.jpg?s=128&g=1", "display_name": "s3rvac", "link": "https://stackoverflow.com/users/2580955/s3rvac"}, "reply_to_user": {"reputation": 361191, "user_id": 440558, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/9ZYta.jpg?s=128&g=1", "display_name": "Some programmer dude", "link": "https://stackoverflow.com/users/440558/some-programmer-dude"}, "edited": false, "score": 0, "creation_date": 1477464410, "post_id": 40255192, "comment_id": 67772433, "body": "@Someprogrammerdude No, I cannot change the C library."}], "answers": [{"tags": [], "owner": {"reputation": 7787, "user_id": 1257035, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/WHLC8.png?s=128&g=1", "display_name": "a3f", "link": "https://stackoverflow.com/users/1257035/a3f"}, "is_accepted": false, "score": 0, "last_activity_date": 1477466032, "creation_date": 1477466032, "answer_id": 40255928, "question_id": 40255192, "link": "https://stackoverflow.com/questions/40255192/how-to-handle-passing-usize-to-a-c-function-that-expects-uint32-t/40255928#40255928", "title": "How to handle passing usize to a C function that expects uint32_t?", "body": "<ul>\n<li>If it makes sense to read/write chunks with <code>lib_foo</code>, wrap it in a loop that processes chunks of 2**32 (at increasing offsets) and then processes the remainder. In most cases it will skip the loop, but in the exceptional case, it will just call <code>lib_foo</code> more than once</li>\n<li>If truncating is acceptable behavior for <code>lib_foo</code>, truncate and tell user somehow</li>\n<li>If it's not, complain loudly if len >= 2**32</li>\n</ul>\n"}, {"comments": [{"owner": {"reputation": 28979, "user_id": 266720, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/7c9333e1816aefc7fc97f64b09afe05c?s=128&d=identicon&r=PG", "display_name": "Vi.", "link": "https://stackoverflow.com/users/266720/vi"}, "edited": false, "score": 0, "creation_date": 1482264574, "post_id": 40256023, "comment_id": 69701204, "body": "For <code>unsigned char</code> it is reasonable, but isn&#39;t lengthening <code>u32</code> to <code>libc::uint32_t</code> excessive, as <code>uint32_t</code> clearly and explicitly intended to always represent a 32-bit unsigned integer, just like <code>u32</code>?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 28979, "user_id": 266720, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/7c9333e1816aefc7fc97f64b09afe05c?s=128&d=identicon&r=PG", "display_name": "Vi.", "link": "https://stackoverflow.com/users/266720/vi"}, "edited": false, "score": 0, "creation_date": 1482431119, "post_id": 40256023, "comment_id": 69781417, "body": "@Vi.: On the other hand, when you have a C header file to translate to Rust, it&#39;s so much easier to just slap <code>libc::</code> in front of the type name and be done with it."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 4, "last_activity_date": 1477466325, "creation_date": 1477466325, "answer_id": 40256023, "question_id": 40255192, "link": "https://stackoverflow.com/questions/40255192/how-to-handle-passing-usize-to-a-c-function-that-expects-uint32-t/40256023#40256023", "title": "How to handle passing usize to a C function that expects uint32_t?", "body": "<p>First of all, please use the <a href=\"https://crates.io/crates/libc\" rel=\"nofollow\"><code>libc</code></a> crate for types.</p>\n\n<p>That is: <code>extern fn lib_foo(buf: *const libc::c_uchar, buf_len: libc::uint32_t);</code></p>\n\n<p>While it is slightly longer, it will avoid making assumption (<code>unsigned char</code> maps to <code>u8</code>) and makes the translation automatic.</p>\n\n<hr>\n\n<p>Then, onto the high level wrapper.</p>\n\n<p>Without any assumption, the simplest solution is to panic, and document this.</p>\n\n<pre><code>/// Calls `lib_foo`, ...\n///\n/// # Panics\n///\n/// If the size of the buffer is strictly greater than 2^32-1 bytes.\npub fn foo(buf: &amp;[u8]) {\n    assert!(buf.len() &lt;= (std::u32::MAX as usize));\n\n    unsafe { lib_foo(buf.as_ptr() as *const _, buf.len() as libc::uint32_t) }\n}\n</code></pre>\n\n<p>Then, depending on the domain, other options may arise:</p>\n\n<ul>\n<li>saturation may be an option (using <code>std::cmp::min</code>)</li>\n<li>repeated calls may be another</li>\n<li>...</li>\n</ul>\n\n<p>in any case, if the difference of behavior is observable to the user, <em>document</em>.</p>\n"}], "owner": {"reputation": 6933, "user_id": 2580955, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/WZR9N.jpg?s=128&g=1", "display_name": "s3rvac", "link": "https://stackoverflow.com/users/2580955/s3rvac"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 570, "favorite_count": 0, "accepted_answer_id": 40256023, "answer_count": 2, "score": 1, "last_activity_date": 1477466703, "creation_date": 1477463391, "question_id": 40255192, "link": "https://stackoverflow.com/questions/40255192/how-to-handle-passing-usize-to-a-c-function-that-expects-uint32-t", "title": "How to handle passing usize to a C function that expects uint32_t?", "body": "<p>I am writing a Rust wrapper around a C library. The C library provides the following function:</p>\n\n<pre class=\"lang-c prettyprint-override\"><code>void lib_foo(const unsigned char *buf, uint32_t buf_len);\n</code></pre>\n\n<p>I have created the following <code>extern</code> wrapper:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn lib_foo(buf: *const u8, buf_len: u32);\n</code></pre>\n\n<p>and the following high-level wrapper:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub fn foo(buf: &amp;[u8]) {\n    unsafe { lib_foo(buf.as_ptr(), buf.len() as u32) }\n}\n</code></pre>\n\n<p>However, the cast from <code>usize</code> (the type of <code>buf.len()</code>) to <code>u32</code> may cause the size to be truncated. What is the best way of dealing with this?</p>\n"}, {"tags": ["concurrency", "locking", "rust", "race-condition", "wakeup"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477486155, "post_id": 40256249, "comment_id": 67785820, "body": "<i>It is never reset</i>, well every 2^32 or 2^64 increments it is. AKA the <code>time_t</code> 2038 issue ^_^"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477486902, "post_id": 40256249, "comment_id": 67786350, "body": "@Shepmaster: Yes, I wish that <code>AtomicU64</code> was stable, as a 64-bits counter cannot physically overflow from 1-increments (for the math-inclined, it takes ~600 years to overflow it with 1 inc/ns, or ~120 years at 5 GHz)."}, {"owner": {"reputation": 1668, "user_id": 311358, "user_type": "registered", "accept_rate": 59, "profile_image": "https://www.gravatar.com/avatar/0b2b51e4cceb4a0c1609b81815001b69?s=128&d=identicon&r=PG", "display_name": "xrl", "link": "https://stackoverflow.com/users/311358/xrl"}, "edited": false, "score": 0, "creation_date": 1477505362, "post_id": 40256249, "comment_id": 67798620, "body": "I could put the atomic load in the <code>wait()</code> and the thread would wake up when the reloaded count was higher."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 3, "last_activity_date": 1477467080, "creation_date": 1477467080, "answer_id": 40256249, "question_id": 40254677, "link": "https://stackoverflow.com/questions/40254677/how-to-monitor-changes-with-condvar-and-mutex/40256249#40256249", "title": "How to monitor changes with Condvar and Mutex", "body": "<p>The simplest solution is to use a counter instead of a boolean.</p>\n\n<pre><code>struct MonitorInner&lt;T&gt; {\n    data: sync::Mutex&lt;T&gt;,\n    signal: sync::Condvar,\n    counter: sync::AtomicUsize,\n}\n</code></pre>\n\n<p>Then, every time an update is done, the counter is incremented. It is never reset, so there is no question about when to reset.</p>\n\n<p>Of course, it means that readers should remember the value of the counter the last time they were woken up.</p>\n"}], "owner": {"reputation": 1668, "user_id": 311358, "user_type": "registered", "accept_rate": 59, "profile_image": "https://www.gravatar.com/avatar/0b2b51e4cceb4a0c1609b81815001b69?s=128&d=identicon&r=PG", "display_name": "xrl", "link": "https://stackoverflow.com/users/311358/xrl"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 281, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1477486221, "creation_date": 1477461196, "last_edit_date": 1477486221, "question_id": 40254677, "link": "https://stackoverflow.com/questions/40254677/how-to-monitor-changes-with-condvar-and-mutex", "title": "How to monitor changes with Condvar and Mutex", "body": "<p>I have a shared <code>Vec&lt;CacheChange&gt;</code>. Whenever a new <code>CacheChange</code> is written I want to wake up readers. I recall that a <code>Condvar</code> is good for signaling when a predicate/situation is ready, namely, when the <code>Vec</code> is modified.</p>\n\n<p>So I spent some time creating a <code>Monitor</code> abstraction to own the <code>Vec</code> and provide <code>wait</code> and <code>lock</code> semantics.</p>\n\n<p>The problem now is I don't know when to reset the <code>Condvar</code>. What is a good way to give a reasonable amount of time to readers to hit the predicate and work their way to holding the lock? before closing the condvar? Am I approach <code>Condvar</code>s the wrong way?</p>\n\n<p>This is Rust code but this more a question of fundamentals for exact concurrent access/notification between multiple readers.</p>\n\n<pre><code>pub struct Monitor&lt;T&gt;(\n    sync::Arc&lt;MonitorInner&lt;T&gt;&gt;\n);\n\nstruct MonitorInner&lt;T&gt; {\n    data: sync::Mutex&lt;T&gt;,\n    predicate: (sync::Mutex&lt;bool&gt;, sync::Condvar)\n}\n\nimpl&lt;T&gt; Monitor&lt;T&gt; {   \n    pub fn wait(&amp;self) -&gt; Result&lt;(),sync::PoisonError&lt;sync::MutexGuard&lt;bool&gt;&gt;&gt; {\n        let mut open = try!(self.0.predicate.0.lock());\n        while !*open {\n            open = try!(self.0.predicate.1.wait(open));\n        }\n        Ok(())\n    }\n\n    pub fn lock(&amp;self) -&gt; Result&lt;sync::MutexGuard&lt;T&gt;, sync::PoisonError&lt;sync::MutexGuard&lt;T&gt;&gt;&gt; {\n        self.0.data.lock()\n    }\n\n    pub fn reset(&amp;mut self) -&gt; Result&lt;(),sync::PoisonError&lt;sync::MutexGuard&lt;bool&gt;&gt;&gt; {\n        let mut open = try!(self.0.predicate.0.lock());\n        *open = false;\n        Ok(())\n    }\n\n    pub fn wakeup_all(&amp;mut self) -&gt; Result&lt;(),sync::PoisonError&lt;sync::MutexGuard&lt;bool&gt;&gt;&gt;  {\n        let mut open = try!(self.0.predicate.0.lock());\n        *open = true;\n        self.0.predicate.1.notify_all();\n        Ok(())\n    }\n}\n</code></pre>\n\n<p>After the first wakeup call, my readers are able to miss reads. Probably because they are still holding the data lock while the predicate has been toggled again.I've seen this in my test code with just one reader and one writer.</p>\n\n<p>Then there's the complication of when to reset the <code>Monitor</code>, ideally it would be locked after all readers had their chance to look at the data. This could cause deadlock issues if the reader ignore their monitors (no guarantee they should service every wakeup call).</p>\n\n<p>Do I need to use some kind of reader tracking system with timeouts and track when new data arrives while monitor reads are still being serviced? Is there an existing paradigm I should be aware of?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477453020, "post_id": 40252935, "comment_id": 67768659, "body": "<i>This does not compile</i> \u2014 <a href=\"http://play.integer32.com/?gist=c98d286832c67299c7506218c391ba40&amp;version=stable\" rel=\"nofollow noreferrer\">seems to compile just fine</a>. What am I missing?"}, {"owner": {"reputation": 449, "user_id": 878298, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/9d5910505de191043ea9aa614073ae05?s=128&d=identicon&r=PG", "display_name": "Sergey Mitskevich", "link": "https://stackoverflow.com/users/878298/sergey-mitskevich"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477453188, "post_id": 40252935, "comment_id": 67768696, "body": "@Shepmaster: <a href=\"http://play.integer32.com/?gist=5255f362bedbf9367e14772b98ee6838&amp;version=stable\" rel=\"nofollow noreferrer\">This won&#39;t compile</a> if you actually invoke that function from <code>main()</code>."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1477464488, "post_id": 40252935, "comment_id": 67772476, "body": "I&#39;m not sure if this is the right approach; what do you want to achieve? If you need a container with a generic member, why not just have some member <code>T</code> and e.g. use <a href=\"https://doc.rust-lang.org/stable/std/any/trait.Any.html#tymethod.get_type_id\" rel=\"nofollow noreferrer\"><code>get_type_id()</code></a> to get its concrete type when needed? Using an associated type doesn&#39;t seem like the way to go."}, {"owner": {"reputation": 449, "user_id": 878298, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/9d5910505de191043ea9aa614073ae05?s=128&d=identicon&r=PG", "display_name": "Sergey Mitskevich", "link": "https://stackoverflow.com/users/878298/sergey-mitskevich"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1477501139, "post_id": 40252935, "comment_id": 67796355, "body": "@ljedrz Associated type gives compile-time guarantees. You are right, it can be checked dynamically during run-time with <code>get_type_id()</code>, but I prefer static restriction if possible."}], "answers": [{"comments": [{"owner": {"reputation": 449, "user_id": 878298, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/9d5910505de191043ea9aa614073ae05?s=128&d=identicon&r=PG", "display_name": "Sergey Mitskevich", "link": "https://stackoverflow.com/users/878298/sergey-mitskevich"}, "edited": false, "score": 0, "creation_date": 1477500979, "post_id": 40255876, "comment_id": 67796291, "body": "Thanks! That seems to be the Rust syntax feature that I missed. It&#39;s a bit cumbersome, because if I want to specify one type parameter, I&#39;ll have to specify all other, even those that can be inferred by compiler, but it works fine!"}, {"owner": {"reputation": 3892, "user_id": 1236045, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9cdfcff173a4487d2a73a29e177930ec?s=128&d=identicon&r=PG&f=1", "display_name": "Micha\u0142 Politowski", "link": "https://stackoverflow.com/users/1236045/micha%c5%82-politowski"}, "reply_to_user": {"reputation": 449, "user_id": 878298, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/9d5910505de191043ea9aa614073ae05?s=128&d=identicon&r=PG", "display_name": "Sergey Mitskevich", "link": "https://stackoverflow.com/users/878298/sergey-mitskevich"}, "edited": false, "score": 2, "creation_date": 1477554734, "post_id": 40255876, "comment_id": 67816868, "body": "@SergeyMitskevich <a href=\"https://play.rust-lang.org/?gist=1d402c2d4a9173b2d0f43886e42c332c&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">actually...</a>"}], "tags": [], "owner": {"reputation": 3892, "user_id": 1236045, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9cdfcff173a4487d2a73a29e177930ec?s=128&d=identicon&r=PG&f=1", "display_name": "Micha\u0142 Politowski", "link": "https://stackoverflow.com/users/1236045/micha%c5%82-politowski"}, "is_accepted": true, "score": 7, "last_activity_date": 1477465841, "creation_date": 1477465841, "answer_id": 40255876, "question_id": 40252935, "link": "https://stackoverflow.com/questions/40252935/how-to-provide-type-only-argument-to-a-function/40255876#40255876", "title": "How to provide type-only argument to a function?", "body": "<p>If you want to pass a type argument to a function, you can just do it. You don't have to leave it out to be inferred.</p>\n\n<p>This is how it looks for your second example (<a href=\"https://play.rust-lang.org/?gist=3dad589a10c43a66ad08ab051c668e58&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">playground</a>):</p>\n\n<pre><code>fn pack_item&lt;C: Container&gt;(item: C::Item) -&gt; ItemPacket {\n    ItemPacket {  \n        container_description: C::describe_container(),\n        _payload: item.get_payload(),\n    }\n}\n\nfn main() {\n    let s = pack_item::&lt;ImAContainerType&gt;(ImAnItemType);\n    println!(\"{}\", s.container_description);\n    let s = pack_item::&lt;ImAnotherContainerType&gt;(ImAnItemType);\n    println!(\"{}\", s.container_description);\n}\n</code></pre>\n"}], "owner": {"reputation": 449, "user_id": 878298, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/9d5910505de191043ea9aa614073ae05?s=128&d=identicon&r=PG", "display_name": "Sergey Mitskevich", "link": "https://stackoverflow.com/users/878298/sergey-mitskevich"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2791, "favorite_count": 0, "accepted_answer_id": 40255876, "answer_count": 1, "score": 4, "last_activity_date": 1477465841, "creation_date": 1477450441, "last_edit_date": 1477452017, "question_id": 40252935, "link": "https://stackoverflow.com/questions/40252935/how-to-provide-type-only-argument-to-a-function", "title": "How to provide type-only argument to a function?", "body": "<p>In my short Rust experience I ran into this pattern several times, and I'm not sure if the way I solve it is actually adequate...</p>\n\n<p>Let's assume I have some trait that looks like this:</p>\n\n<pre><code>trait Container {\n    type Item;\n    fn describe_container() -&gt; String;\n}\n</code></pre>\n\n<p>And some struct that implements this trait:</p>\n\n<pre><code>struct ImAContainerType;\nstruct ImAnItemType;\nimpl Container for ImAContainerType {\n    type Item = ImAnItemType;\n    fn describe_container() -&gt; String { \"some container that contains items\".to_string() }\n}\n</code></pre>\n\n<p>This may be a container that has a knowledge about type of items it contains, like in this example, or, as another example, request which knows what type of response should be returned, etc.</p>\n\n<p>And now I find myself in a situation, when I need to implement a function that takes an item (associated type) and invokes a static function of the container (parent trait). This is the first naive attempt:</p>\n\n<pre><code>fn describe_item_container&lt;C: Container&gt;(item: C::Item) -&gt; String {\n    C::describe_container()\n}\n</code></pre>\n\n<p>This does not compile, because associated types are not injective, and <code>Item</code> can have several possible <code>Container</code>s, so this whole situation is ambiguous. I need to somehow provide the actual <code>Container</code> type, but without providing any container data. I may not have the container data itself at all when I invoke this function! </p>\n\n<p>In search for a solution, I find the documentation for <a href=\"https://doc.rust-lang.org/std/marker/struct.PhantomData.html\" rel=\"nofollow\">std::marker::PhantomData</a>. It says: </p>\n\n<blockquote>\n  <p>PhantomData allows you to describe that a type acts as if it stores a value of type T, even though it does not.</p>\n</blockquote>\n\n<p>This has to be the Rust's replacement for <a href=\"https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Proxy.html\" rel=\"nofollow\">Haskell's Proxy type</a>, right? Let's try to use it:</p>\n\n<pre><code>fn describe_item_container&lt;C: Container&gt;(container: PhantomData&lt;C&gt;, item: C::Item) -&gt; String {\n    C::describe_container()\n}\n\nlet s = describe_item_container(PhantomData::&lt;PhantomData&lt;ImAContainerType&gt;&gt;, ImAnItemType);\nprintln!(\"{}\", s);\n</code></pre>\n\n<p>Compiling... Error:</p>\n\n<pre><code>error[E0277]: the trait bound `std::marker::PhantomData&lt;ImAContainerType&gt;: Container` is not satisfied\n</code></pre>\n\n<p>I ask <code>#rust-beginners</code> and get a response: <code>PhantomData</code> is not meant to be used that way at all! Also I got an advice to simply make a backward associated type link from <code>Item</code> to <code>Container</code>. Something like this:</p>\n\n<pre><code>trait Item {\n    type C: Container;\n}\nfn describe_item_container&lt;I: Item&gt;(item: I) -&gt; String {\n    I::C::describe_container()\n}\n</code></pre>\n\n<p>It should work, but makes things much more complicated (especially for cases when item can be placed in different container kinds)...</p>\n\n<p>After a lot more experimentation, I do the following change and everything compiles and works correctly:</p>\n\n<pre><code>let s = describe_item_container(PhantomData::&lt;ImAContainerType&gt;, ImAnItemType);\nprintln!(\"{}\", s);\n</code></pre>\n\n<p>The change is <code>::&lt;PhantomData&lt;ImAContainerType&gt;&gt;</code> to <code>::&lt;ImAContainerType&gt;</code>.</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=855b8c837d8e70d2af005be19b811b00&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">Playground example.</a> </p>\n\n<p>It works, but now I'm completely confused. Is this the correct way to use <code>PhantomData</code>? Why does it work at all? Is there some other, better way to provide type-only argument to a function in Rust?</p>\n\n<hr>\n\n<p><strong>EDIT:</strong> There is some oversimplification in my example, because in that particular case it would be easier to just invoke <code>ImAContainerType::describe_container()</code>. Here is some <a href=\"https://play.rust-lang.org/?gist=e4e0e07ef4125e24f55f40c7f01de55a&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">more complicated case</a>, when the function actually does something with an <code>Item</code>, and still requires container type information.</p>\n"}, {"tags": ["rust", "unsafe"], "comments": [{"owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "edited": false, "score": 1, "creation_date": 1477448587, "post_id": 40252673, "comment_id": 67767565, "body": "Oops.  I need to take a reference to the result of <code>unsafe</code>, but you get the idea :  I do not want to <code>mem::transmute</code> a pointer."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477448648, "post_id": 40252673, "comment_id": 67767580, "body": "You should <a href=\"https://stackoverflow.com/posts/40252673/edit\">edit</a> your own question instead of commenting to yourself."}, {"owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477499802, "post_id": 40252673, "comment_id": 67795598, "body": "In fact, I must <code>mem:transmute</code> the reference since I need to pass the reference to <code>sha.result()</code>, but maybe I can find a safer way to do this."}], "answers": [{"comments": [{"owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "edited": false, "score": 0, "creation_date": 1477471645, "post_id": 40255813, "comment_id": 67776478, "body": "Yup, that&#39;s way more ergonomic than anything I&#39;d seen.  Thanks!  I&#39;ll probably keep my <code>unsafe</code> for now, but if it starts to bug me than I&#39;ll look into doing a workaround with this."}, {"owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "edited": false, "score": 0, "creation_date": 1477472678, "post_id": 40255813, "comment_id": 67777221, "body": "Just found a nice helper function <code>clone_into_array</code> in <a href=\"http://stackoverflow.com/a/37679442/667457\">stackoverflow.com/a/37679442/667457</a> that lets me use almost the idiomatic commented out lines."}], "tags": [], "owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "is_accepted": true, "score": 3, "last_activity_date": 1477471694, "last_edit_date": 1477471694, "creation_date": 1477465636, "answer_id": 40255813, "question_id": 40252673, "link": "https://stackoverflow.com/questions/40252673/ergonomics-issues-with-fixed-size-byte-arrays-in-rust/40255813#40255813", "title": "Ergonomics issues with fixed size byte arrays in Rust", "body": "<p>There's the <code>copy_from_slice</code> method.</p>\n\n<pre><code>fn main() {\n    use std::default::Default;\n\n    // Using 16+8 because Default isn't implemented\n    // for [u8; 32+16] due to type explosion unfortunateness\n    let b: [u8; 24] = Default::default();\n    let mut c: [u8; 16] = Default::default();\n    let mut d: [u8; 8] = Default::default();\n\n    c.copy_from_slice(&amp;b[..16])\n    d.copy_from_slice(&amp;b[16..16+8]);\n}\n</code></pre>\n\n<p>Note, unfortunately <code>copy_from_slice</code> throws a <strong>runtime</strong> error if the slices are not the same length, so make sure you thoroughly test this yourself, or use the lengths of the other arrays to guard.</p>\n\n<p>Unfortunately, <code>c.copy_from_slice(&amp;b[..c.len()])</code> doesn't work because Rust thinks <code>c</code> is borrowed both immutably and mutably at the same time.</p>\n"}, {"tags": [], "owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "is_accepted": false, "score": 0, "last_activity_date": 1586120893, "last_edit_date": 1586120893, "creation_date": 1477513637, "answer_id": 40271557, "question_id": 40252673, "link": "https://stackoverflow.com/questions/40252673/ergonomics-issues-with-fixed-size-byte-arrays-in-rust/40271557#40271557", "title": "Ergonomics issues with fixed size byte arrays in Rust", "body": "<p>I marked the accepted answer as best since it's safe, and led me to the <code>clone_into_array</code> answer <a href=\"https://stackoverflow.com/a/37679442/667457\">here</a>, but..</p>\n\n<p>Another idea that improves the safety is to make a version of <code>mem::transmute</code> for references that checks the sizes of the referenced types, as opposed to just the pointers.  It might look like : </p>\n\n<pre><code>#[inline]\nunsafe fn transmute_ptr_mut&lt;A,B&gt;(v: &amp;mut A) -&gt; &amp;mut B {\n    debug_assert_eq!(core::mem::size_of(A),core::mem::size_of(B));\n    core::mem::transmute::&lt;&amp;mut A,&amp;mut B&gt;(v)\n}\n</code></pre>\n\n<p>I have <a href=\"https://github.com/droundy/arrayref/issues/5\" rel=\"nofollow noreferrer\">raised an issue on the arrayref crate</a> to discuss this, as arrayref might be a reasonable crate for it to live in.</p>\n\n<p><em>Update</em> : We've a new \"best answer\" by the arrayref crate developer : </p>\n\n<pre><code>let (a,b) = array_refs![&amp;r,32,16];\n(MessageKey(*a), LeafKey(*b))\n</code></pre>\n"}], "owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 957, "favorite_count": 0, "accepted_answer_id": 40255813, "answer_count": 2, "score": 3, "last_activity_date": 1607291344, "creation_date": 1477448444, "last_edit_date": 1607291344, "question_id": 40252673, "link": "https://stackoverflow.com/questions/40252673/ergonomics-issues-with-fixed-size-byte-arrays-in-rust", "title": "Ergonomics issues with fixed size byte arrays in Rust", "body": "<p>Rust sadly cannot produce a fixed size array <code>[u8; 16]</code> with a fixed size slicing operator <code>s[0..16]</code>.  It'll throw errors like &quot;expected array of 16 elements, found slice&quot;.</p>\n<p>I've some KDFs that output several keys in wrapper <code>struct</code>s like</p>\n<pre><code>pub struct LeafKey([u8; 16]);\npub struct MessageKey([u8; 32]);\n\nfn kdfLeaf(...) -&gt; (MessageKey,LeafKey) {\n    // let mut r: [u8; 32+16];\n    let mut r: (MessageKey, LeafKey);\n    debug_assert_eq!(mem::size_of_val(&amp;r), 384/8);\n    let mut sha = Sha3::sha3_384();\n    sha.input(...);\n\n    // sha.result(r);\n    sha.result( \n      unsafe { mem::transmute::&lt;&amp;mut (MessageKey, LeafKey),&amp;mut [u8;32+16]&gt;(&amp;r) } \n    );\n    sha.reset();\n\n    // (MessageKey(r[0..31]), LeafKey(r[32..47]))\n    r\n}\n</code></pre>\n<p>Is there a safer way to do this?  We know <code>mem::transmute</code> will refuse to compile if the types do not have the same size, but that only checks that pointers have the same size here, so I added that <code>debug_assert</code>.</p>\n<p>In fact, I'm not terribly worried about extra copies though since I'm running SHA3 here, but afaik rust offers no ergonomic way to copy amongst byte arrays.</p>\n<p>Can I avoid writing <code>(MessageKey, LeafKey)</code> three times here?  Is there a type alias for the return type of the current function?  Is it safe to use <code>_</code> in the <code>mem::transmute</code> given that I want the code to refuse to compile if the sizes do not match?  Yes, I know I could make a type alias, but that seems silly.</p>\n<p>As an aside, there is a longer discussion of <code>s[0..16]</code> not having type <code>[u8; 16]</code> <a href=\"https://github.com/rust-lang/rfcs/issues/1772\" rel=\"nofollow noreferrer\">here</a></p>\n"}, {"tags": ["unicode", "rust"], "comments": [{"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 0, "creation_date": 1477438067, "post_id": 40250988, "comment_id": 67765120, "body": "What exactly is insufficient about those methods? It&#39;s hard to answer your question without knowing the problem you&#39;re trying to solve. There are also methods defined on char: <a href=\"https://doc.rust-lang.org/std/primitive.char.html#method.to_lowercase\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/primitive.char.html#method.to_lowercas&zwnj;&#8203;e</a>"}, {"owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "reply_to_user": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 0, "creation_date": 1477439151, "post_id": 40250988, "comment_id": 67765384, "body": "@BurntSushi5 I&#39;ve added some context to the question -- hope it helps."}, {"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 1, "creation_date": 1477515246, "post_id": 40250988, "comment_id": 67803796, "body": "Your best bet is probably <a href=\"https://docs.rs/caseless/0.1.1/caseless/\" rel=\"nofollow noreferrer\">docs.rs/caseless/0.1.1/caseless</a>"}], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 1, "last_activity_date": 1477441223, "creation_date": 1477441223, "answer_id": 40251769, "question_id": 40250988, "link": "https://stackoverflow.com/questions/40250988/how-can-i-case-fold-a-string-in-rust/40251769#40251769", "title": "How can I case fold a string in Rust?", "body": "<p>The <a href=\"https://github.com/seanmonstar/unicase\" rel=\"nofollow\">unicase</a> crate doesn't expose case folding directly, but it provides a generic wrapper type that implements <code>Eq</code>, <code>Ord</code> and <code>Hash</code> in a case insensitive manner. The master branch (unreleased) supports both ASCII case folding (as an optimization) and Unicode case folding (though only invariant case folding is supported).</p>\n"}, {"tags": [], "owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "is_accepted": true, "score": 2, "last_activity_date": 1477983071, "creation_date": 1477983071, "answer_id": 40355331, "question_id": 40250988, "link": "https://stackoverflow.com/questions/40250988/how-can-i-case-fold-a-string-in-rust/40355331#40355331", "title": "How can I case fold a string in Rust?", "body": "<p>For my use case, I've found the <a href=\"https://crates.io/crates/caseless\" rel=\"nofollow\">caseless</a> crate to be most useful.</p>\n\n<p>As far as I know, this is the only library which supports normalization. This is important when you want e.g. \"\u3392\" (U+3392 SQUARE MHZ) and \"mhz\" to match. See <a href=\"http://www.unicode.org/versions/Unicode9.0.0/ch03.pdf\" rel=\"nofollow\">Chapter 3 - Default Caseless Matching</a> in the Unicode Standard for details on how this works.</p>\n\n<p>Here's some example code that matches a string case-insensitively:</p>\n\n<pre><code>extern crate caseless;\nuse caseless::Caseless;\n\nlet a = \"100 \u3392\";\nlet b = \"100 mhz\";\n\n// These strings don't match with just case folding,\n// but do match after compatibility (NFKD) normalization\nassert!(!caseless::default_caseless_match_str(a, b));\nassert!(caseless::compatibility_caseless_match_str(a, b));\n</code></pre>\n\n<p>To get the case folded string directly, you can use the <code>default_case_fold_str</code> function:</p>\n\n<pre><code>let s = \"Twilight Sparkle \u3061\u3083\u3093\";\nassert_eq!(caseless::default_case_fold_str(s), \"twilight sparkle \u3061\u3083\u3093\");\n</code></pre>\n\n<p>Caseless doesn't expose a corresponding function that normalizes as well, but you can write one using the <a href=\"https://crates.io/crates/unicode-normalization\" rel=\"nofollow\">unicode-normalization</a> crate:</p>\n\n<pre><code>extern crate unicode_normalization;\nuse caseless::Caseless;\nuse unicode_normalization::UnicodeNormalization;\n\nfn compatibility_case_fold(s: &amp;str) -&gt; String {\n    s.nfd().default_case_fold().nfkd().default_case_fold().nfkd().collect()\n}\n\nlet a = \"100 \u3392\";\nassert_eq!(compatibility_case_fold(a), \"100 mhz\");\n</code></pre>\n\n<p>Note that multiple rounds of normalization and case folding are needed for a correct result.</p>\n\n<p>(Thanks to BurntSushi5 for pointing me to this library.)</p>\n"}, {"tags": [], "owner": {"reputation": 80945, "user_id": 1002260, "user_type": "registered", "accept_rate": 96, "profile_image": "https://www.gravatar.com/avatar/5ec9c21c8d54825b04def7a41998d18d?s=128&d=identicon&r=PG", "display_name": "Steven Penny", "link": "https://stackoverflow.com/users/1002260/steven-penny"}, "is_accepted": false, "score": 1, "last_activity_date": 1608933266, "creation_date": 1608933266, "answer_id": 65452097, "question_id": 40250988, "link": "https://stackoverflow.com/questions/40250988/how-can-i-case-fold-a-string-in-rust/65452097#65452097", "title": "How can I case fold a string in Rust?", "body": "<p>If someone did want to stick to the standard library, I wanted some actual data\non this. I pulled <a href=\"//stackoverflow.com/questions/11124705#65433126\">the\u00a0full list</a> of two byte characters that fail with\n<code>to_lowercase</code> or <code>to_uppercase</code>. I then ran this test:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>fn lowercase(left: char, right: char) -&gt; bool {\n   for c in left.to_lowercase() {\n      for d in right.to_lowercase() {\n         if c == d { return true }\n      }\n   }\n   false\n}\n\nfn uppercase(left: char, right: char) -&gt; bool {\n   for c in left.to_uppercase() {\n      for d in right.to_uppercase() {\n         if c == d { return true }\n      }\n   }\n   false\n}\n\nfn main() {\n   let pairs = &amp;[\n      &amp;['\\u{00E5}','\\u{212B}'],&amp;['\\u{00C5}','\\u{212B}'],&amp;['\\u{0399}','\\u{1FBE}'],\n      &amp;['\\u{03B9}','\\u{1FBE}'],&amp;['\\u{03B2}','\\u{03D0}'],&amp;['\\u{03B5}','\\u{03F5}'],\n      &amp;['\\u{03B8}','\\u{03D1}'],&amp;['\\u{03B8}','\\u{03F4}'],&amp;['\\u{03D1}','\\u{03F4}'],\n      &amp;['\\u{03B9}','\\u{1FBE}'],&amp;['\\u{0345}','\\u{03B9}'],&amp;['\\u{0345}','\\u{1FBE}'],\n      &amp;['\\u{03BA}','\\u{03F0}'],&amp;['\\u{00B5}','\\u{03BC}'],&amp;['\\u{03C0}','\\u{03D6}'],\n      &amp;['\\u{03C1}','\\u{03F1}'],&amp;['\\u{03C2}','\\u{03C3}'],&amp;['\\u{03C6}','\\u{03D5}'],\n      &amp;['\\u{03C9}','\\u{2126}'],&amp;['\\u{0392}','\\u{03D0}'],&amp;['\\u{0395}','\\u{03F5}'],\n      &amp;['\\u{03D1}','\\u{03F4}'],&amp;['\\u{0398}','\\u{03D1}'],&amp;['\\u{0398}','\\u{03F4}'],\n      &amp;['\\u{0345}','\\u{1FBE}'],&amp;['\\u{0345}','\\u{0399}'],&amp;['\\u{0399}','\\u{1FBE}'],\n      &amp;['\\u{039A}','\\u{03F0}'],&amp;['\\u{00B5}','\\u{039C}'],&amp;['\\u{03A0}','\\u{03D6}'],\n      &amp;['\\u{03A1}','\\u{03F1}'],&amp;['\\u{03A3}','\\u{03C2}'],&amp;['\\u{03A6}','\\u{03D5}'],\n      &amp;['\\u{03A9}','\\u{2126}'],&amp;['\\u{0398}','\\u{03F4}'],&amp;['\\u{03B8}','\\u{03F4}'],\n      &amp;['\\u{03B8}','\\u{03D1}'],&amp;['\\u{0398}','\\u{03D1}'],&amp;['\\u{0432}','\\u{1C80}'],\n      &amp;['\\u{0434}','\\u{1C81}'],&amp;['\\u{043E}','\\u{1C82}'],&amp;['\\u{0441}','\\u{1C83}'],\n      &amp;['\\u{0442}','\\u{1C84}'],&amp;['\\u{0442}','\\u{1C85}'],&amp;['\\u{1C84}','\\u{1C85}'],\n      &amp;['\\u{044A}','\\u{1C86}'],&amp;['\\u{0412}','\\u{1C80}'],&amp;['\\u{0414}','\\u{1C81}'],\n      &amp;['\\u{041E}','\\u{1C82}'],&amp;['\\u{0421}','\\u{1C83}'],&amp;['\\u{1C84}','\\u{1C85}'],\n      &amp;['\\u{0422}','\\u{1C84}'],&amp;['\\u{0422}','\\u{1C85}'],&amp;['\\u{042A}','\\u{1C86}'],\n      &amp;['\\u{0463}','\\u{1C87}'],&amp;['\\u{0462}','\\u{1C87}']\n   ];\n\n   let (mut upper, mut lower) = (0, 0);\n\n   for pair in pairs.iter() {\n      print!(&quot;U+{:04X} &quot;, pair[0] as u32);\n      print!(&quot;U+{:04X} pass: &quot;, pair[1] as u32);\n      if uppercase(pair[0], pair[1]) {\n         print!(&quot;to_uppercase &quot;);\n         upper += 1;\n      } else {\n         print!(&quot;             &quot;);\n      }\n      if lowercase(pair[0], pair[1]) {\n         print!(&quot;to_lowercase&quot;);\n         lower += 1;\n      }\n      println!();\n   }\n\n   println!(&quot;upper pass: {}, lower pass: {}&quot;, upper, lower);\n}\n</code></pre>\n<p>Result below. Interestingly, one of the pairs fails with both. But based on this,\n<strong>to_uppercase is the best option</strong>.</p>\n<pre class=\"lang-none prettyprint-override\"><code>U+00E5 U+212B pass:              to_lowercase\nU+00C5 U+212B pass:              to_lowercase\nU+0399 U+1FBE pass: to_uppercase\nU+03B9 U+1FBE pass: to_uppercase\nU+03B2 U+03D0 pass: to_uppercase\nU+03B5 U+03F5 pass: to_uppercase\nU+03B8 U+03D1 pass: to_uppercase\nU+03B8 U+03F4 pass:              to_lowercase\nU+03D1 U+03F4 pass:\nU+03B9 U+1FBE pass: to_uppercase\nU+0345 U+03B9 pass: to_uppercase\nU+0345 U+1FBE pass: to_uppercase\nU+03BA U+03F0 pass: to_uppercase\nU+00B5 U+03BC pass: to_uppercase\nU+03C0 U+03D6 pass: to_uppercase\nU+03C1 U+03F1 pass: to_uppercase\nU+03C2 U+03C3 pass: to_uppercase\nU+03C6 U+03D5 pass: to_uppercase\nU+03C9 U+2126 pass:              to_lowercase\nU+0392 U+03D0 pass: to_uppercase\nU+0395 U+03F5 pass: to_uppercase\nU+03D1 U+03F4 pass:\nU+0398 U+03D1 pass: to_uppercase\nU+0398 U+03F4 pass:              to_lowercase\nU+0345 U+1FBE pass: to_uppercase\nU+0345 U+0399 pass: to_uppercase\nU+0399 U+1FBE pass: to_uppercase\nU+039A U+03F0 pass: to_uppercase\nU+00B5 U+039C pass: to_uppercase\nU+03A0 U+03D6 pass: to_uppercase\nU+03A1 U+03F1 pass: to_uppercase\nU+03A3 U+03C2 pass: to_uppercase\nU+03A6 U+03D5 pass: to_uppercase\nU+03A9 U+2126 pass:              to_lowercase\nU+0398 U+03F4 pass:              to_lowercase\nU+03B8 U+03F4 pass:              to_lowercase\nU+03B8 U+03D1 pass: to_uppercase\nU+0398 U+03D1 pass: to_uppercase\nU+0432 U+1C80 pass: to_uppercase\nU+0434 U+1C81 pass: to_uppercase\nU+043E U+1C82 pass: to_uppercase\nU+0441 U+1C83 pass: to_uppercase\nU+0442 U+1C84 pass: to_uppercase\nU+0442 U+1C85 pass: to_uppercase\nU+1C84 U+1C85 pass: to_uppercase\nU+044A U+1C86 pass: to_uppercase\nU+0412 U+1C80 pass: to_uppercase\nU+0414 U+1C81 pass: to_uppercase\nU+041E U+1C82 pass: to_uppercase\nU+0421 U+1C83 pass: to_uppercase\nU+1C84 U+1C85 pass: to_uppercase\nU+0422 U+1C84 pass: to_uppercase\nU+0422 U+1C85 pass: to_uppercase\nU+042A U+1C86 pass: to_uppercase\nU+0463 U+1C87 pass: to_uppercase\nU+0462 U+1C87 pass: to_uppercase\nupper pass: 46, lower pass: 8\n</code></pre>\n"}], "owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 787, "favorite_count": 1, "accepted_answer_id": 40355331, "answer_count": 3, "score": 6, "last_activity_date": 1608933266, "creation_date": 1477435754, "last_edit_date": 1603781547, "question_id": 40250988, "link": "https://stackoverflow.com/questions/40250988/how-can-i-case-fold-a-string-in-rust", "title": "How can I case fold a string in Rust?", "body": "<p>I'm writing a simple full text search library, and need case folding to check if two words are equal. For this use case, the existing <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase\" rel=\"nofollow noreferrer\"><code>.to_lowercase()</code></a> and <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase\" rel=\"nofollow noreferrer\"><code>.to_uppercase()</code></a> methods are <a href=\"https://www.w3.org/International/wiki/Case_folding\" rel=\"nofollow noreferrer\">not enough</a>.</p>\n<p>From a quick search of crates.io, I can find libraries for normalization and word splitting but not case folding. <code>regex-syntax</code> does have <a href=\"https://doc.rust-lang.org/regex/regex_syntax/struct.CharClass.html\" rel=\"nofollow noreferrer\">case folding code</a>, but it's not exposed in its API.</p>\n"}, {"tags": ["arrays", "sum", "rust"], "answers": [{"comments": [{"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477409459, "post_id": 40243257, "comment_id": 67750079, "body": "I&#39;m using <code>rustc 1.7.0</code> from the Ubuntu apt-repositories, and get: <code>test.rs:19:29: 19:34 error: use of unstable library feature &#39;iter_arith&#39;: bounds recently changed (see issue #27739)</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 4, "creation_date": 1477410078, "post_id": 40243257, "comment_id": 67750534, "body": "@Jonatan&#214;str&#246;m you should update! Right now, 1.12.1 is the newest, and it represents about 30 additional weeks of work applied to the compiler; including better error messages."}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477411391, "post_id": 40243257, "comment_id": 67751466, "body": "I installed it on this machine just an hour ago, so I guess I should use some other channel then."}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1477416744, "post_id": 40243257, "comment_id": 67754620, "body": "<a href=\"https://www.rustup.rs/\" rel=\"nofollow noreferrer\">Rustup</a> is one of the best ways to get the Rust compiler and other useful resources. Do try it out. :)"}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1477433907, "post_id": 40243257, "comment_id": 67763962, "body": "@E_net4 Thanks, I&#39;ll check it out!"}, {"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477474343, "post_id": 40243257, "comment_id": 67778311, "body": "@Shepmaster I installed a newer version of Rust, so the specific example works. But the question was more general, I need to do this for higher dimensional arrays, at least two dims."}], "tags": [], "owner": {"reputation": 13693, "user_id": 352708, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/68dcad0efb04cad998822cc57112eb7c?s=128&d=identicon&r=PG", "display_name": "Slava Semushin", "link": "https://stackoverflow.com/users/352708/slava-semushin"}, "is_accepted": true, "score": 3, "last_activity_date": 1477407669, "last_edit_date": 1477407669, "creation_date": 1477407378, "answer_id": 40243257, "question_id": 40243061, "link": "https://stackoverflow.com/questions/40243061/sum-array-along-dimension/40243257#40243257", "title": "Sum array along dimension", "body": "<p>In this case you have to explicitly specify type of the elements:</p>\n\n<pre><code>println!(\"this {}\", arr1.iter().sum::&lt;f64&gt;())\n</code></pre>\n\n<p>You were very close :)</p>\n\n<hr>\n\n<p>Another option that were suggested by @E_net4 is to use separate binding:</p>\n\n<pre><code>let res: f64 = arr1.iter().sum();\nprintln!(\"this {}\", res)\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "is_accepted": false, "score": 1, "last_activity_date": 1477438707, "last_edit_date": 1495540838, "creation_date": 1477438707, "answer_id": 40251442, "question_id": 40243061, "link": "https://stackoverflow.com/questions/40243061/sum-array-along-dimension/40251442#40251442", "title": "Sum array along dimension", "body": "<p>The \"unable to infer enough type information about <code>_</code>\" error message is explained in a few other questions. See <a href=\"https://stackoverflow.com/q/37401681/1233251\">Error: unable to infer enough type information about `_`; type annotations or generic parameter binding required</a> and <a href=\"https://stackoverflow.com/questions/34001546/unable-to-infer-enough-type-information-about-type-annotations-or-generic-par\">Unable to infer enough type information about _; type annotations or generic parameter binding required</a>. Basically, it means that the compiler doesn't have enough information to specify all type parameters in a function or a data type.</p>\n\n<p><strong>Nevertheless</strong>, this particular case may arouse some confusion: why can't <code>Iterator.sum()</code> just infer the resulting sum's type to the iterator's <code>Item</code>? By supposedly adding up <code>f64</code>s, we'd be expecting <code>f64</code> as an outcome, right? Well, the method <code>sum</code> is actually defined like this:</p>\n\n<pre><code>fn sum&lt;S&gt;(self) -&gt; S \n    where S: Sum&lt;Self::Item&gt;\n</code></pre>\n\n<p>Where <code>S</code> implements another kind of <code>sum</code> function (see <a href=\"https://doc.rust-lang.org/std/iter/trait.Sum.html\" rel=\"nofollow noreferrer\"><code>trait Sum</code></a>) that takes an iterator:</p>\n\n<pre><code>pub trait Sum&lt;A = Self&gt; {\n    fn sum&lt;I&gt;(iter: I) -&gt; Self where I: Iterator&lt;Item=A&gt;;\n}\n</code></pre>\n\n<p>This trait gives us the freedom to sum numbers and references to numbers alike:</p>\n\n<pre><code>static MAGIC_CODE: u32 = 0xDEADBEEF;\nstatic BLAND_CODE: u32 = 0x1234ABCD;\n\nfn main() {\n\n    let sum1: u32 = vec![MAGIC_CODE, BLAND_CODE] // vec! infers to Vec&lt;u32&gt;\n        .into_iter().sum();\n\n    let sum2 = vec![&amp;MAGIC_CODE, &amp;BLAND_CODE] // vec! infers to Vec&lt;&amp;u32&gt;\n        .into_iter().sum::&lt;u32&gt;();\n\n\n    assert_eq!(sum1, sum2);\n}\n</code></pre>\n\n<p>On the other hand, this also means that the definition of a sum becomes more loose: any other data type implementing <code>Sum&lt;u32&gt;</code> (or <code>Sum&lt;&amp;u32&gt;</code>) could take its place in the code above, which leads to the aforementioned ambiguity. For the purpose of demonstration, this code also compiles:</p>\n\n<pre><code>use std::iter::Sum;\n\nstruct Accumulator(bool);\n\nimpl Sum&lt;u32&gt; for Accumulator {\n    fn sum&lt;I: Iterator&lt;Item = u32&gt;&gt;(mut iter: I) -&gt; Self {\n        Accumulator(iter.any(|v| v != 0))\n    }\n}\n\nfn main() {\n    let sum3: Accumulator = {\n        let data = vec![MAGIC_CODE, BLAND_CODE];\n\n        data.into_iter().sum()\n    };\n\n    assert!(sum3.0);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=4687ebe37e88a2c996208501102aab7c&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Full code on Playground</a>.</p>\n"}], "owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 326, "favorite_count": 0, "accepted_answer_id": 40243257, "answer_count": 2, "score": 0, "last_activity_date": 1477438707, "creation_date": 1477406859, "last_edit_date": 1477407647, "question_id": 40243061, "link": "https://stackoverflow.com/questions/40243061/sum-array-along-dimension", "title": "Sum array along dimension", "body": "<p>In many languages (Fortran, Matlab/Octave, Julia, etc) an expression like <code>sum(array,n)</code> will sum the values of an array along the n:th dimension and outputting an array of one lower dimensionality. Is there something equivalent in Rust? </p>\n\n<p>I tried:</p>\n\n<pre><code>fn main() {\n    let arr1: [f64; 5] = [1.1, 1.2, 2.3, 3.4, 4.5555];\n    println!(\"this {}\", arr1.iter().sum())\n}\n</code></pre>\n\n<p>with this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0282]: unable to infer enough type information about `_`\n --&gt; src/main.rs:3:37\n  |\n3 |     println!(\"this {}\", arr1.iter().sum())\n  |                                     ^^^ cannot infer type for `_`\n&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!\n&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)\nsrc/main.rs:3:5: 3:43 note: in this expansion of println! (defined in &lt;std macros&gt;)\n  |\n  = note: type annotations or generic parameter binding required\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477402429, "post_id": 40241407, "comment_id": 67744783, "body": "The function I want to make generic is somewhat long, so that is why I do not just copy and paste :)"}], "answers": [{"comments": [{"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477417888, "post_id": 40241643, "comment_id": 67755287, "body": "Love the haskellish where! It is so counterintuitive to me that closures aren&#39;t slow. Do you know if I can get the compiler to treat the closures as if I had created different functions for each operation (add_vec, minus_vec)? (Will need to look closer at the answer tomorrow before accepting.)"}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477418447, "post_id": 40241643, "comment_id": 67755598, "body": "@TheUnfunCat I&#39;m not sure this is what you are after, but you can define a closure in a let binding, e.g. <code>let add = |x, y| x + y;</code> and then pass it like a regular function argument: <code>new_vec(&amp;v1s, &amp;v2s, add)</code>."}, {"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477418749, "post_id": 40241643, "comment_id": 67755776, "body": "What I hoped to achieve: the same speed as if I had written the functions out in full and then compiled the file :)"}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477419583, "post_id": 40241643, "comment_id": 67756233, "body": "@TheUnfunCat you won&#39;t see any difference in this specific case; I compared the optimized LLVM-IR and ASM results for a classic function <code>fn foo(x: i32, y: i32) -&gt; i32 { x + y }</code> against a closure <code>|x: i32, y: i32| x + y</code> (with some side effect so that it was not optimized away completely) and they were exactly the same."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 1, "creation_date": 1477426704, "post_id": 40241643, "comment_id": 67760299, "body": "@TheUnfunCat I think the term you are looking for is &quot;Monomorphization&quot;."}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": true, "score": 5, "last_activity_date": 1477404534, "last_edit_date": 1495541798, "creation_date": 1477402898, "answer_id": 40241643, "question_id": 40241407, "link": "https://stackoverflow.com/questions/40241407/how-do-i-create-a-rust-function-that-is-generic-in-the-operation-applied/40241643#40241643", "title": "How do I create a Rust function that is generic in the operation applied?", "body": "<p>I would pass a closure:</p>\n\n<pre><code>fn new_vec&lt;F&gt;(v1s: &amp;[i32], v2s: &amp;[i32], foo: F) -&gt; Vec&lt;i32&gt;\n    where F: Fn(i32, i32) -&gt; i32\n{\n    let mut v3s = Vec::&lt;i32&gt;::new();\n    for (&amp;v1, &amp;v2) in v1s.iter().zip(v2s.iter()) {\n        v3s.push(foo(v1, v2))\n    }\n    v3s\n}\n\nfn main() {\n    let v1s = vec![1, 0, 1];\n    let v2s = vec![0, 1, 1];\n    let v3s = new_vec(&amp;v1s, &amp;v2s, |x, y| x - y);\n    let v4s = new_vec(&amp;v1s, &amp;v2s, |x, y| x + y);\n    println!(\"{:?}\", v3s); // [1, -1, 0]\n    println!(\"{:?}\", v4s); // [1, 1, 2]\n}\n</code></pre>\n\n<p>Note the change in the first two parameters; if your function doesn't need to consume its arguments, <a href=\"https://stackoverflow.com/q/40006219/155423\">references are preferable to <code>Vec</code>tors</a> - in this case <code>&amp;[i32]</code>.</p>\n\n<p>This implementation is not too efficient because the resulting <code>Vec</code>tor is extended incrementally; it's better if you modified it as follows to reduce the number of allocations:</p>\n\n<pre><code>fn new_vec&lt;F&gt;(v1s: &amp;[i32], v2s: &amp;[i32], foo: F) -&gt; Vec&lt;i32&gt;\n    where F: Fn(i32, i32) -&gt; i32\n{\n    v1s.iter().zip(v2s.iter()).map(|(&amp;x, &amp;y)| foo(x, y)).collect()\n}\n</code></pre>\n"}], "owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 75, "favorite_count": 0, "accepted_answer_id": 40241643, "answer_count": 1, "score": 0, "last_activity_date": 1477404534, "creation_date": 1477402347, "last_edit_date": 1477403129, "question_id": 40241407, "link": "https://stackoverflow.com/questions/40241407/how-do-i-create-a-rust-function-that-is-generic-in-the-operation-applied", "title": "How do I create a Rust function that is generic in the operation applied?", "body": "<p>I have a function called <code>new_vec</code>. It takes two vectors and creates a new one, by performing an elementwise operation on the pair of elements from the zipped vectors.</p>\n\n<pre><code>fn main() {\n    let v1s = vec![1, 0, 1];\n    let v2s = vec![0, 1, 1];\n    let v3s = new_vec(v1s, v2s);\n    println!(\"{:?}\", v3s) // [1, 1, 2]\n}\n\nfn new_vec(v1s: Vec&lt;i32&gt;, v2s: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut v3s = Vec::&lt;i32&gt;::new();\n    for (v1, v2) in v1s.iter().zip(v2s.iter()) {\n         v3s.push(v1 + v2) // would also like to use -\n    }\n    v3s\n}\n</code></pre>\n\n<p>I want to have a <code>new_vec</code> function for the common binary operation that is possible to use on two integers, such as <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>.</p>\n\n<p>How do I do this? I can imagine two ways: macros and closures. A minimal example of how to do this in the best way, for example with <code>+</code> and <code>-</code> would be appreciated.</p>\n"}, {"tags": ["generics", "rust"], "answers": [{"comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 2, "creation_date": 1477402314, "post_id": 40241288, "comment_id": 67744678, "body": "But according to <a href=\"http://rust-num.github.io/num/num/trait.Num.html\" rel=\"nofollow noreferrer\">rust-num.github.io/num/num/trait.Num.html</a>, <code>Num: ...+  Add&lt;Self&gt; + ...</code>, which you might think means you can assume <code>Add</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1477402717, "post_id": 40241288, "comment_id": 67745000, "body": "@ChrisEmerson yes, you can add together two values of a type that implements <code>Num</code> (and thus <code>Add</code>), but <i>not</i> two references to values of a type that implement <code>Num</code>. <code>T: Add&lt;T, Output=T&gt;</code> does not imply <code>&amp;T: Add&lt;&amp;T, Output=T&gt;</code>."}, {"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477418609, "post_id": 40241288, "comment_id": 67755697, "body": "Thanks for your great answer. What is the <code>&#39;a</code> and the <code>Output</code> in the signature called? Want to read up on them further."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477422282, "post_id": 40241288, "comment_id": 67757774, "body": "@TheUnfunCat <a href=\"https://doc.rust-lang.org/stable/book/lifetimes.html\" rel=\"nofollow noreferrer\">a lifetime</a> and <a href=\"https://doc.rust-lang.org/stable/book/associated-types.html\" rel=\"nofollow noreferrer\">an associated type</a>, respectively. I&#39;d <b>highly</b> recommend reading the <a href=\"https://doc.rust-lang.org/stable/book/\" rel=\"nofollow noreferrer\"><b>entire</b> book</a>; it has the collected answers to many questions that people ask when starting Rust."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1477402870, "last_edit_date": 1495540394, "creation_date": 1477402041, "answer_id": 40241288, "question_id": 40241159, "link": "https://stackoverflow.com/questions/40241159/why-do-you-need-to-implement-add-for-adding-two-variables-with-the-trait-num/40241288#40241288", "title": "Why do you need to implement Add for adding two variables with the trait Num?", "body": "<p>The important thing to realize is that the code isn't attempting to add two <code>N</code>s; the code is attempting to add two <em>references to <code>N</code></em> (<code>&amp;N</code>). Look at the error message (emphasis added):</p>\n\n<blockquote>\n  <p>binary operation <code>+</code> cannot be applied <strong>to type <code>&amp;N</code></strong></p>\n</blockquote>\n\n<p>By using <code>iter</code>, you are iterating on <em>references</em> to values inside the vector. There's no guarantee that a trait is implemented for a reference to a type that implements the trait.</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/28799372/155423\">When should I not implement a trait for references to implementors of that trait?</a></li>\n<li><a href=\"https://stackoverflow.com/q/28005134/155423\">How do I implement the Add trait for a reference to a struct?</a></li>\n</ul>\n\n<p>In addition, <code>T: Add&lt;T, Output=T&gt;</code> does <strong>not</strong> imply <code>&amp;T: Add&lt;&amp;T, Output=T&gt;</code>.</p>\n\n<blockquote>\n  <p>but I do not understand why I need to implement the <code>Add</code> trait. As if there are numbers that cannot be added...</p>\n</blockquote>\n\n<p>Why do you assume that <code>N</code> <strong>is a number</strong>? <em>Any possible type</em> that exists in Rust is welcome to implement any trait, and that includes <code>Num</code>. If it made sense, you could implement <code>Num</code> for your own type.</p>\n\n<blockquote>\n  <p>perhaps there exists a trait for these subtypes of num?</p>\n</blockquote>\n\n<p>Again, once a trait exists, <strong>any type</strong> is welcome to implement it.</p>\n\n<hr>\n\n<p>For what it's worth, I'd implement it like this:</p>\n\n<pre><code>use std::ops::Add;\n\nfn add_vec&lt;'a, N&gt;(v1s: &amp;'a [N], v2s: &amp;'a [N]) -&gt; Vec&lt;N&gt;\n    where &amp;'a N: Add&lt;Output = N&gt;\n{\n    v1s.iter().zip(v2s.iter()).map(|(v1, v2)| v1 + v2).collect()\n}\n</code></pre>\n\n<p>See <a href=\"https://stackoverflow.com/q/40006219/155423\">Why is it discouraged to accept a reference to a String (&amp;String) or Vec (&amp;Vec) as a function argument?</a> (also we just don't <em>need</em> to take ownership here). Using <code>map</code> is going to be more efficient - it can preallocate the output vector all at once.</p>\n\n<p>However, if you really wanted to consume the vectors:</p>\n\n<pre><code>fn add_vec&lt;N: Num&gt;(v1s: Vec&lt;N&gt;, v2s: Vec&lt;N&gt;) -&gt; Vec&lt;N&gt; {\n    v1s.into_iter()\n        .zip(v2s.into_iter())\n        .map(|(v1, v2)| v1 + v2)\n        .collect()\n}\n</code></pre>\n\n<p>Note that <code>into_iter</code> consumes the vectors, yielding values and not references. Thus the <code>Num</code> trait can be applied.</p>\n"}], "owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 94, "favorite_count": 0, "accepted_answer_id": 40241288, "answer_count": 1, "score": 1, "last_activity_date": 1477402870, "creation_date": 1477401723, "last_edit_date": 1495542841, "question_id": 40241159, "link": "https://stackoverflow.com/questions/40241159/why-do-you-need-to-implement-add-for-adding-two-variables-with-the-trait-num", "title": "Why do you need to implement Add for adding two variables with the trait Num?", "body": "<p>I have a function called <code>add_vec</code>. It takes two vectors and creates a new one, by performing an elementwise add on the pair of elements from the zipped vectors.</p>\n\n<pre><code>extern crate num;\nuse num::traits::Num;\n\nfn add_vec&lt;N: Num&gt;(v1s: Vec&lt;N&gt;, v2s: Vec&lt;N&gt;) -&gt; Vec&lt;N&gt; {\n    let mut v3s = Vec::new();\n    for (v1, v2) in v1s.iter().zip(v2s.iter()) {\n        v3s.push(v1 + v2)\n    }\n    v3s\n}\n\n#[cfg(test)]\nmod tests {\n    use super::add_vec;\n    #[test]\n    fn it_works() {\n        let v1s = vec![1, 0, 3];\n        let v2s = vec![0, 1, 1];\n        let v3s = add_vec(v1s, v2s);\n        assert_eq!(v3s, vec![1, 1, 4]);\n    }\n}\n</code></pre>\n\n<p>The problem is that I end up with the following error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0369]: binary operation `+` cannot be applied to type `&amp;N`\n  --&gt; src/lib.rs:14:18\n   |\n14 |         v3s.push(v1 + v2)\n   |                  ^^\n   |\nnote: an implementation of `std::ops::Add` might be missing for `&amp;N`\n  --&gt; src/lib.rs:14:18\n   |\n14 |         v3s.push(v1 + v2)\n   |                  ^^\n</code></pre>\n\n<p>I know this is answered in <a href=\"https://stackoverflow.com/questions/29184358/requiring-implementation-of-mul-in-generic-function\">Requiring implementation of Mul in generic function</a> but I do not understand why I need to implement the <code>Add</code> trait. As if there are numbers that cannot be added...</p>\n\n<p>Is there a way to solve this without implementing <code>Add</code>? I want to create a version of <code>add_vec</code> that uses <code>-</code>, <code>%</code>, <code>*</code>, <code>/</code> instead of <code>+</code>, and implementing the respective traits for each operation sounds like a drudge. I'm only interested in signed integers and floats, so perhaps there exists a trait for these subtypes of num?</p>\n\n<p>My <code>Cargo.toml</code> for convenience:</p>\n\n<pre><code>[package]\nname = \"minimal_example_2\"\nversion = \"0.1.0\"\nauthors = [\"User\"]\n\n[dependencies]\nnum = \"0.1.36\"\n</code></pre>\n"}, {"tags": ["multithreading", "ssl", "tcp", "concurrency", "rust"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 3, "creation_date": 1477388632, "post_id": 40233482, "comment_id": 67735285, "body": "Can you show the code that reproduces your concerns? It&#39;s hard for us to help without it."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1477399579, "post_id": 40233482, "comment_id": 67742556, "body": "To add to @E_net4&#39;s point, show us <i>what you have tried</i>, otherwise we are likely going to duplicate all the &quot;possible ways&quot; which already have &quot;all failed&quot;."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477399659, "post_id": 40233482, "comment_id": 67742617, "body": "Additionally, there&#39;s no <code>SslStream</code> in the standard library. You have to create a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>; we aren&#39;t going to search through every single crate to find one that <i>might</i> be the <code>SslStream</code> that you mean."}, {"owner": {"reputation": 19, "user_id": 7068027, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/6DcKp.jpg?s=128&g=1", "display_name": "DongJin Shin", "link": "https://stackoverflow.com/users/7068027/dongjin-shin"}, "edited": false, "score": 0, "creation_date": 1477425406, "post_id": 40233482, "comment_id": 67759595, "body": "Thank you for comments. I&#39;ve added details for my situation."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477425780, "post_id": 40233482, "comment_id": 67759805, "body": "<i>&quot;but <code>TcpStream</code> doesn&#39;t seem to have <code>clone</code> method&quot;</i> \u2014 just search through the <code>TcpStream</code> documentation for &quot;clone&quot; and you&#39;ll find <a href=\"https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.try_clone\" rel=\"nofollow noreferrer\"><code>try_clone</code></a>. Does that answer your question?"}, {"owner": {"reputation": 19, "user_id": 7068027, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/6DcKp.jpg?s=128&g=1", "display_name": "DongJin Shin", "link": "https://stackoverflow.com/users/7068027/dongjin-shin"}, "edited": false, "score": 0, "creation_date": 1477427098, "post_id": 40233482, "comment_id": 67760539, "body": "I&#39;m sorry that I&#39;ve missed that I could also use <code>try_clone</code>. I&#39;ve managed to clone <code>TcpStream</code> to separate it into <code>BufReader</code> and <code>BufWriter</code>. However the communication is based on ssl, so I can&#39;t simply use reader and writer from on <code>TcpStream</code>. I guess I have to ask this to <code>SslStream</code>"}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1532093954, "post_id": 51443397, "comment_id": 89857586, "body": "Idiomatic Rust does not use <code>return</code> at the end of blocks / functions."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1532094019, "post_id": 51443397, "comment_id": 89857641, "body": "Why <code>UnsafeCell</code> instead of something easier to get right like <code>Cell</code> or <code>RefCell</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1532094488, "post_id": 51443397, "comment_id": 89857988, "body": "This code is <b>unsafe</b> because <a href=\"https://play.rust-lang.org/?gist=a662db7712da6d30d475773df5e1e598&amp;version=stable&amp;mode=debug&amp;edition=2015\" rel=\"nofollow noreferrer\">it allows for mutable aliasing</a> from code that only uses safe functions."}, {"owner": {"reputation": 27, "user_id": 10111017, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fa5b2501084c269e3265957047143234?s=128&d=identicon&r=PG&f=1", "display_name": "Bernd", "link": "https://stackoverflow.com/users/10111017/bernd"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1532418380, "post_id": 51443397, "comment_id": 89954945, "body": "@Shepmaster: I re-checked the code, it compiles. I use Ubuntu 18.04, Rust stable toolchain, rustc 1.27.0. Note: You have to add the crate <a href=\"https://crates.io/crates/native-tls\" rel=\"nofollow noreferrer\">native_tls</a> to your dependencies and fulfill the requirments for native_tls on your system (see doc)."}, {"owner": {"reputation": 27, "user_id": 10111017, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fa5b2501084c269e3265957047143234?s=128&d=identicon&r=PG&f=1", "display_name": "Bernd", "link": "https://stackoverflow.com/users/10111017/bernd"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1532418574, "post_id": 51443397, "comment_id": 89955041, "body": "Yes, UnsafeMutator and UnsafeCell is unsafe - as indicated by the name."}, {"owner": {"reputation": 27, "user_id": 10111017, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fa5b2501084c269e3265957047143234?s=128&d=identicon&r=PG&f=1", "display_name": "Bernd", "link": "https://stackoverflow.com/users/10111017/bernd"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1532419721, "post_id": 51443397, "comment_id": 89955616, "body": "<b><i>But that &quot;the code&quot; is unsafe, is not exactly true!</i></b>  The key point is the API that is exposed to the user - the <code>pub struct Socket</code>. By using two <a href=\"https://doc.rust-lang.org/1.21.0/std/sync/struct.Mutex.html\" rel=\"nofollow noreferrer\">Mutex</a> it allows only one read and one write access in parallel to the underlying stream. As far as I now this is fine for streams and does not break any mutability rules (tested with tcp and ssl stream).  So, unsafe access to the stream via <code>UnsafeMutator</code> is controlled by the <code>Mutex</code> objects and therefore safe again."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1532437053, "post_id": 51443397, "comment_id": 89966365, "body": "<a href=\"https://play.rust-lang.org/?gist=a548b89700b94c2c643ebab7b83f54b3&amp;version=stable&amp;mode=debug&amp;edition=2015\" rel=\"nofollow noreferrer\">The code you have provided does not compile</a>. You have neglected to provide any version information, so that seems like a likely candidate for the problem."}, {"owner": {"reputation": 6475, "user_id": 7008416, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1aa92fca6ba297f9420e519fd789ac64?s=128&d=identicon&r=PG&f=1", "display_name": "Arthur Tacca", "link": "https://stackoverflow.com/users/7008416/arthur-tacca"}, "edited": false, "score": 0, "creation_date": 1583960793, "post_id": 51443397, "comment_id": 107292480, "body": "@Bernd Having two mutable references to the same object is undefined behaviour (not just &quot;unsafe but OK if you know what you&#39;re doing&quot; but actually dangerous), even if you never modify the actual object through those references. The optimisations that could be enabled by Rust&#39;s lifetime model are currently turned off because of a bug in them in LLVM, so if that gets fixed and turned back on then undefined behaviours from lifetime mistakes like this could suddenly start exploding."}, {"owner": {"reputation": 6475, "user_id": 7008416, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1aa92fca6ba297f9420e519fd789ac64?s=128&d=identicon&r=PG&f=1", "display_name": "Arthur Tacca", "link": "https://stackoverflow.com/users/7008416/arthur-tacca"}, "edited": false, "score": 0, "creation_date": 1583960967, "post_id": 51443397, "comment_id": 107292542, "body": "@Bernd The relevant line of the documentation in <a href=\"https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html\" rel=\"nofollow noreferrer\"><code>std::cell::UnsafeCell</code></a>: &quot;There is <i>no</i> legal way to obtain aliasing <code>&amp;mut</code>, not even with <code>UnsafeCell&lt;T&gt;</code>.&quot;"}], "tags": [], "owner": {"reputation": 27, "user_id": 10111017, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fa5b2501084c269e3265957047143234?s=128&d=identicon&r=PG&f=1", "display_name": "Bernd", "link": "https://stackoverflow.com/users/10111017/bernd"}, "is_accepted": false, "score": 0, "last_activity_date": 1532093907, "last_edit_date": 1532093907, "creation_date": 1532092567, "answer_id": 51443397, "question_id": 40233482, "link": "https://stackoverflow.com/questions/40233482/separate-tcpstream-sslstream-into-read-and-write-components/51443397#51443397", "title": "Separate TcpStream + SslStream into read and write components", "body": "<p>I accomplished the split of an SSL stream into a read and a write part by using Rust's <a href=\"https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html\" rel=\"nofollow noreferrer\"><code>std::cell::UnsafeCell</code></a>.</p>\n\n<pre><code>extern crate native_tls;\n\nuse native_tls::TlsConnector;\nuse std::cell::UnsafeCell;\nuse std::error::Error;\nuse std::io::Read;\nuse std::io::Write;\nuse std::marker::Sync;\nuse std::net::TcpStream;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::thread;\n\nstruct UnsafeMutator&lt;T&gt; {\n    value: UnsafeCell&lt;T&gt;,\n}\n\nimpl&lt;T&gt; UnsafeMutator&lt;T&gt; {\n    fn new(value: T) -&gt; UnsafeMutator&lt;T&gt; {\n        return UnsafeMutator {\n            value: UnsafeCell::new(value),\n        };\n    }\n\n    fn mut_value(&amp;self) -&gt; &amp;mut T {\n        return unsafe { &amp;mut *self.value.get() };\n    }\n}\n\nunsafe impl&lt;T&gt; Sync for UnsafeMutator&lt;T&gt; {}\n\nstruct ReadWrapper&lt;R&gt;\nwhere\n    R: Read,\n{\n    inner: Arc&lt;UnsafeMutator&lt;R&gt;&gt;,\n}\n\nimpl&lt;R: Read&gt; Read for ReadWrapper&lt;R&gt; {\n    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, std::io::Error&gt; {\n        return self.inner.mut_value().read(buf);\n    }\n}\nstruct WriteWrapper&lt;W&gt;\nwhere\n    W: Write,\n{\n    inner: Arc&lt;UnsafeMutator&lt;W&gt;&gt;,\n}\n\nimpl&lt;W: Write&gt; Write for WriteWrapper&lt;W&gt; {\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, std::io::Error&gt; {\n        return self.inner.mut_value().write(buf);\n    }\n\n    fn flush(&amp;mut self) -&gt; Result&lt;(), std::io::Error&gt; {\n        return self.inner.mut_value().flush();\n    }\n}\n\npub struct Socket {\n    pub output_stream: Arc&lt;Mutex&lt;Write + Send&gt;&gt;,\n    pub input_stream: Arc&lt;Mutex&lt;Read + Send&gt;&gt;,\n}\n\nimpl Socket {\n    pub fn bind(host: &amp;str, port: u16, secure: bool) -&gt; Result&lt;Socket, Box&lt;Error&gt;&gt; {\n        let tcp_stream = match TcpStream::connect((host, port)) {\n            Ok(x) =&gt; x,\n            Err(e) =&gt; return Err(Box::new(e)),\n        };\n        if secure {\n            let tls_connector = TlsConnector::builder().build().unwrap();\n            let tls_stream = match tls_connector.connect(host, tcp_stream) {\n                Ok(x) =&gt; x,\n                Err(e) =&gt; return Err(Box::new(e)),\n            };\n            let mutator = Arc::new(UnsafeMutator::new(tls_stream));\n            let input_stream = Arc::new(Mutex::new(ReadWrapper {\n                inner: mutator.clone(),\n            }));\n            let output_stream = Arc::new(Mutex::new(WriteWrapper { inner: mutator }));\n\n            let socket = Socket {\n                output_stream,\n                input_stream,\n            };\n            return Ok(socket);\n        } else {\n            let mutator = Arc::new(UnsafeMutator::new(tcp_stream));\n            let input_stream = Arc::new(Mutex::new(ReadWrapper {\n                inner: mutator.clone(),\n            }));\n            let output_stream = Arc::new(Mutex::new(WriteWrapper { inner: mutator }));\n\n            let socket = Socket {\n                output_stream,\n                input_stream,\n            };\n            return Ok(socket);\n        }\n    }\n}\n\nfn main() {\n    let socket = Arc::new(Socket::bind(\"google.com\", 443, true).unwrap());\n\n    let socket_clone = Arc::clone(&amp;socket);\n\n    let reader_thread = thread::spawn(move || {\n        let mut res = vec![];\n        let mut input_stream = socket_clone.input_stream.lock().unwrap();\n        input_stream.read_to_end(&amp;mut res).unwrap();\n        println!(\"{}\", String::from_utf8_lossy(&amp;res));\n    });\n\n    let writer_thread = thread::spawn(move || {\n        let mut output_stream = socket.output_stream.lock().unwrap();\n        output_stream.write_all(b\"GET / HTTP/1.0\\r\\n\\r\\n\").unwrap();\n    });\n\n    writer_thread.join().unwrap();\n    reader_thread.join().unwrap();\n}\n</code></pre>\n"}], "owner": {"reputation": 19, "user_id": 7068027, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/6DcKp.jpg?s=128&g=1", "display_name": "DongJin Shin", "link": "https://stackoverflow.com/users/7068027/dongjin-shin"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 652, "favorite_count": 2, "answer_count": 1, "score": 1, "last_activity_date": 1532093907, "creation_date": 1477379256, "last_edit_date": 1495542805, "question_id": 40233482, "link": "https://stackoverflow.com/questions/40233482/separate-tcpstream-sslstream-into-read-and-write-components", "title": "Separate TcpStream + SslStream into read and write components", "body": "<p>I'm trying to make client program that communicates with a server using a <code>TcpStream</code> wrapped by a <code>openssl::ssl::SslStream</code> (from <a href=\"https://crates.io/crates/openssl\" rel=\"nofollow noreferrer\">crates.io</a>). It should wait for <code>read</code>, and process data sent from the server if it was received <strong>without delay</strong>. At the same time, it should be able to send messages to the server regardless of reading.</p>\n\n<p>I tried some methods such as</p>\n\n<ol>\n<li>Passing single stream to both read and write threads. Both <code>read</code> and <code>write</code> methods require a mutable reference, so I couldn't pass a single stream to two threads.</li>\n<li>I followed <a href=\"https://stackoverflow.com/questions/26621746/in-rust-how-do-i-handle-parallel-read-writes-on-a-tcpstream\">In Rust how do I handle parallel read writes on a TcpStream</a>, but <code>TcpStream</code> doesn't seem to have <code>clone</code> method, and neither does <code>SslStream</code>.</li>\n<li>I tried making copy of <code>TcpStream</code> with <code>as_raw_fd</code> and <code>from_raw_fd</code> :</li>\n</ol>\n\n\n\n<pre><code>fn irc_read(mut stream: SslStream&lt;TcpStream&gt;) {\n    loop {\n        let mut buf = vec![0; 2048];\n        let resp = stream.ssl_read(&amp;mut buf);\n        match resp {\n            // Process Message\n        }\n    }\n}\n\nfn irc_write(mut stream: SslStream&lt;TcpStream&gt;) {\n    thread::sleep(Duration::new(3, 0));\n    let msg = \"QUIT\\n\";\n    let res = stream.ssl_write(msg.as_bytes());\n    let _ = stream.flush();\n    match res {\n        // Process\n    }\n}\n\nfn main() {\n    let ctx = SslContext::new(SslMethod::Sslv23).unwrap();\n    let read_ssl = Ssl::new(&amp;ctx).unwrap();\n    let write_ssl = Ssl::new(&amp;ctx).unwrap();\n\n    let raw_stream = TcpStream::connect((SERVER, PORT)).unwrap();\n    let mut fd_stream: TcpStream;\n    unsafe {\n        fd_stream = TcpStream::from_raw_fd(raw_stream.as_raw_fd());\n    }\n    let mut read_stream = SslStream::connect(read_ssl, raw_stream).unwrap();\n    let mut write_stream = SslStream::connect(write_ssl, fd_stream).unwrap();\n\n    let read_thread = thread::spawn(move || {\n        irc_read(read_stream);\n    });\n\n    let write_thread = thread::spawn(move || {\n        irc_write(write_stream);\n    });\n\n    let _ = read_thread.join();\n    let _ = write_thread.join();\n}\n</code></pre>\n\n<p>this code compiles, but panics on the second <code>SslStream::connect</code></p>\n\n<pre class=\"lang-none prettyprint-override\"><code>thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Failure(Ssl(ErrorStack([Error { library: \"SSL routines\", function: \"SSL23_GET_SERVER_HELLO\", reason: \"unknown protocol\" }])))', ../src/libcore/result.rs:788\nstack backtrace:\n   1:     0x556d719c6069 - std::sys::backtrace::tracing::imp::write::h00e948915d1e4c72\n   2:     0x556d719c9d3c - std::panicking::default_hook::_{{closure}}::h7b8a142818383fb8\n   3:     0x556d719c8f89 - std::panicking::default_hook::h41cf296f654245d7\n   4:     0x556d719c9678 - std::panicking::rust_panic_with_hook::h4cbd7ca63ce1aee9\n   5:     0x556d719c94d2 - std::panicking::begin_panic::h93672d0313d5e8e9\n   6:     0x556d719c9440 - std::panicking::begin_panic_fmt::hd0daa02942245d81\n   7:     0x556d719c93c1 - rust_begin_unwind\n   8:     0x556d719ffcbf - core::panicking::panic_fmt::hbfc935564d134c1b\n   9:     0x556d71899f02 - core::result::unwrap_failed::h66f79b2edc69ddfd\n                        at /buildslave/rust-buildbot/slave/stable-dist-rustc-linux/build/obj/../src/libcore/result.rs:29\n  10:     0x556d718952cb - _&lt;core..result..Result&lt;T, E&gt;&gt;::unwrap::h49a140af593bc4fa\n                        at /buildslave/rust-buildbot/slave/stable-dist-rustc-linux/build/obj/../src/libcore/result.rs:726\n  11:     0x556d718a5e3d - dbrust::main::h24a50e631826915e\n                        at /home/lastone817/dbrust/src/main.rs:87\n  12:     0x556d719d1826 - __rust_maybe_catch_panic\n  13:     0x556d719c8702 - std::rt::lang_start::h53bf99b0829cc03c\n  14:     0x556d718a6b83 - main\n  15:     0x7f40a0b5082f - __libc_start_main\n  16:     0x556d7188d038 - _start\n  17:                0x0 - &lt;unknown&gt;\nerror: Process didn't exit successfully: `target/debug/dbrust` (exit code: 101)\n</code></pre>\n\n<p>The best solution I've found so far is to use nonblocking. I used <code>Mutex</code> on the stream and passed it to both threads. Then the reading thread acquires a lock and calls <code>read</code>. If there is no message it releases the lock so that the writing thread can use the stream. With this method, the reading thread does busy waiting, resulting in 100% CPU consumption. This is not the best solution, I think.</p>\n\n<p>Is there a safe way to separate the read and write aspects of the stream?</p>\n"}, {"tags": ["arrays", "indexing", "rust", "declaration"], "answers": [{"comments": [{"owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "edited": false, "score": 0, "creation_date": 1477368327, "post_id": 40231105, "comment_id": 67725093, "body": "This was the solution I was searching for. The constant MAX now replaces all instances of 3, max and max2."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 5, "last_activity_date": 1477367640, "creation_date": 1477367640, "answer_id": 40231105, "question_id": 40231018, "link": "https://stackoverflow.com/questions/40231018/declare-array-with-constant-not-literal-as-dimension-specifier/40231105#40231105", "title": "Declare array with constant (not literal) as dimension specifier", "body": "<p>Arrays in Rust must be declared with a fixed size known at compile time.</p>\n\n<p>If the size is indeed known at compile time, then define a constant instead of a variable:</p>\n\n<pre><code>const MAX: usize = 3;\n</code></pre>\n\n<p>If the size is not known at compile time, use a <code>Vec</code> instead.</p>\n"}], "owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 73, "favorite_count": 0, "accepted_answer_id": 40231105, "answer_count": 1, "score": 0, "last_activity_date": 1477376980, "creation_date": 1477367050, "last_edit_date": 1477376980, "question_id": 40231018, "link": "https://stackoverflow.com/questions/40231018/declare-array-with-constant-not-literal-as-dimension-specifier", "title": "Declare array with constant (not literal) as dimension specifier", "body": "<p>The following code works, but to easily change the size of the array and the index range of the loops, can the variable <code>max</code> be used to specify the dimensions of the array?  </p>\n\n<pre><code>fn main() {\n    let max: i64 = 3;\n\n    let mut arr2: [[f64; 3]; 3] = [[0.0; 3]; 3]; //replace 3 by max?\n    // let mut arr2: [[f64; max]; max] = [[0.0; max]; max]; //does not work\n\n    let pi: f64 = 3.1415926535;\n    let max2 = max as usize;\n\n    for ii in 0..max2 {\n        for jj in 0..max2 {\n            let i = ii as f64;\n            let j = jj as f64;\n            arr2[ii][jj] = ((i + j) * pi * 41.0).sqrt().sin();\n            println!(\"arr2[{}][{}] is {}\", ii, jj, arr2[ii][jj]);\n        }\n    }\n}\n</code></pre>\n\n<p>Using the commented out line for the declaration I get this error: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0513]: no type for local variable 10\n --&gt; &lt;anon&gt;:6:32\n  |\n6 |     let mut arr2: [[f64; max]; max] = [[0.0; max]; max]; //does not work\n  |                                ^^^\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 8297, "user_id": 298847, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/b52bc71fb15db17f585b912aed45b217?s=128&d=identicon&r=PG", "display_name": "tibbe", "link": "https://stackoverflow.com/users/298847/tibbe"}, "edited": false, "score": 0, "creation_date": 1477367056, "post_id": 40230871, "comment_id": 67724843, "body": "Thanks for the explanation. I was assuming that since it&#39;s as cheap to copy the <code>i64</code>s as it is to take a reference to them (if not cheaper) and since you can&#39;t mutate the <code>i64</code>s Rust would just copy them by value transparently. Can you observe the value vs ref difference somehow in this code?"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 6, "last_activity_date": 1477367479, "last_edit_date": 1477367479, "creation_date": 1477365963, "answer_id": 40230871, "question_id": 40230796, "link": "https://stackoverflow.com/questions/40230796/why-does-rust-store-i64s-captured-by-a-closure-as-i64s-in-the-llvm-ir-closure-e/40230871#40230871", "title": "Why does Rust store i64s captured by a closure as i64*s in the LLVM IR closure environment?", "body": "<p><a href=\"https://doc.rust-lang.org/book/closures.html\" rel=\"nofollow\">Closures</a> capture by reference by default. You can change that behavior to capture by value by adding the <code>move</code> keyword before the parameter list:</p>\n\n<pre><code>let f = move |x: i64| x + y + z;\n</code></pre>\n\n<p>This generates much leaner code:</p>\n\n<pre><code>define internal fastcc i64 @apply(i64 %.0.0.val, i64 %.0.1.val) unnamed_addr #0 personality i32 (i32, i32, i64, %\"8.unwind::libunwind::_Unwind_Exception\"*, %\"8.unwind::libunwind::_Unwind_Context\"*)* @rust_eh_personality {\nentry-block:\n  %0 = add i64 %.0.0.val, 42\n  %1 = add i64 %0, %.0.1.val\n  ret i64 %1\n}\n</code></pre>\n\n<p>Adding the <code>move</code> keyword means that any value that the closure uses will be moved into the closure's environment. In the case of integers, which are <code>Copy</code>, it doesn't make much difference, but in the case of other types like <code>String</code>, it means that you can't use the <code>String</code> anymore in the outer scope after creating the closure. It's an all-or-nothing deal, but you can manually take references to individual variables outside a <code>move</code> closure and have the closure use these references instead of the original values to get manual capture-by-reference behavior.</p>\n\n<blockquote>\n  <p>Can you observe the value vs ref difference somehow in this code?</p>\n</blockquote>\n\n<p><a href=\"https://play.rust-lang.org/?gist=b19252c99d81c362a9b91c4f7af75990&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">If you take the address of the captured variable, you can observe the difference.</a> Notice how the first and second output lines are the same, and the third is different.</p>\n"}], "owner": {"reputation": 8297, "user_id": 298847, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/b52bc71fb15db17f585b912aed45b217?s=128&d=identicon&r=PG", "display_name": "tibbe", "link": "https://stackoverflow.com/users/298847/tibbe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 130, "favorite_count": 0, "accepted_answer_id": 40230871, "answer_count": 1, "score": 3, "last_activity_date": 1477399448, "creation_date": 1477365428, "last_edit_date": 1477399448, "question_id": 40230796, "link": "https://stackoverflow.com/questions/40230796/why-does-rust-store-i64s-captured-by-a-closure-as-i64s-in-the-llvm-ir-closure-e", "title": "Why does Rust store i64s captured by a closure as i64*s in the LLVM IR closure environment?", "body": "<p>In this simple example</p>\n\n<pre><code>#[inline(never)]\nfn apply&lt;F, A, B&gt;(f: F, x: A) -&gt; B\n    where F: FnOnce(A) -&gt; B {\n    f(x)\n}\n\nfn main() {\n    let y: i64 = 1;\n    let z: i64 = 2;\n    let f = |x: i64| x + y + z;\n    print!(\"{}\", apply(f, 42));\n}\n</code></pre>\n\n<p>the closure passed to <code>apply</code> is passed as a LLVM IR <code>{i64*, i64*}*</code>:</p>\n\n<pre><code>%closure = type { i64*, i64* }\ndefine internal fastcc i64 @apply(%closure* noalias nocapture readonly dereferenceable(16)) unnamed_addr #0 personality i32 (i32, i32, i64, %\"8.unwind::libunwind::_Unwind_Exception\"*, %\"8.unwind::libunwind::_Unwind_Context\"*)* @rust_eh_personality {\nentry-block:\n  %1 = getelementptr inbounds %closure, %closure* %0, i64 0, i32 1\n  %2 = getelementptr inbounds %closure, %closure* %0, i64 0, i32 0\n  %3 = load i64*, i64** %2, align 8\n  %4 = load i64*, i64** %1, align 8\n  %.idx.val.val.i = load i64, i64* %3, align 8, !noalias !1\n  %.idx1.val.val.i = load i64, i64* %4, align 8, !noalias !1\n  %5 = add i64 %.idx.val.val.i, 42\n  %6 = add i64 %5, %.idx1.val.val.i\n  ret i64 %6\n}\n</code></pre>\n\n<p>(<code>apply</code> actually has a more complicated name in the generated LLVM code.)</p>\n\n<p>This causes two loads to get to each of the captured variables. Why isn't <code>%closure</code> just <code>{i64, i64}</code> (which would make the argument to <code>apply</code> <code>{i64, i64}*</code>)?</p>\n"}, {"tags": ["arrays", "rust"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 15, "last_activity_date": 1477364995, "creation_date": 1477364995, "answer_id": 40230747, "question_id": 40230697, "link": "https://stackoverflow.com/questions/40230697/what-is-the-correct-type-to-use-for-an-array-index/40230747#40230747", "title": "What is the correct type to use for an array index?", "body": "<p>The compiler gives you a note about this:</p>\n\n<pre><code>   = note: slice indices are of type `usize`\n</code></pre>\n\n<p>You must index a slice with a <code>usize</code>. <code>usize</code> is an unsigned integral type that has the same size as a pointer, and can represent a memory offset or the size of an object in memory. On 32-bit systems, it's a 32-bit integer, and on 64-bit systems, it's a 64-bit integer. Declare your index variables as <code>usize</code> unless you really have a lot of them, in which case you can use <code>x as usize</code> to cast them to an <code>usize</code>.</p>\n\n<p>When you leave out the type annotation, Rust deduces that your integer literals must be of type <code>usize</code> because <a href=\"https://doc.rust-lang.org/stable/std/primitive.slice.html\" rel=\"noreferrer\">slices</a> implement <code>Index&lt;usize&gt;</code> and not <code>Index&lt;i32&gt;</code> or <code>Index&lt;any other integral type&gt;</code>.</p>\n"}], "owner": {"reputation": 1867, "user_id": 4483861, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/2dtp8.jpg?s=128&g=1", "display_name": "Jonatan &#214;str&#246;m", "link": "https://stackoverflow.com/users/4483861/jonatan-%c3%96str%c3%b6m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 9358, "favorite_count": 1, "accepted_answer_id": 40230747, "answer_count": 1, "score": 13, "last_activity_date": 1477399281, "creation_date": 1477364534, "last_edit_date": 1477399281, "question_id": 40230697, "link": "https://stackoverflow.com/questions/40230697/what-is-the-correct-type-to-use-for-an-array-index", "title": "What is the correct type to use for an array index?", "body": "<p>This code works, but I want to explicitly declare the type of the index range <code>max</code>. However <code>uX</code> or <code>iX</code>, where X = 8, 16 or 32 gives compile errors. What is the correct type?</p>\n\n<pre><code>fn main() {\n    let mut arr2: [[f64; 3]; 3] = [[0.0; 3]; 3];\n    let pi: f64 = 3.1415926535;\n\n    let max = 3; // let max: i16 e.g. is wrong\n\n    for ii in 0..max {\n        for jj in 0..3 {\n            let i = ii as f64;\n            let j = jj as f64;\n            arr2[ii][jj] = ((i + j) * pi * 41.0).sqrt().sin();\n            println!(\"arr2[{}][{}] is {}\", ii, jj, arr2[ii][jj]);\n        }\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 3271, "user_id": 232416, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/23e8c255702b8c9c2f1228301796ef4b?s=128&d=identicon&r=PG", "display_name": "Shaun", "link": "https://stackoverflow.com/users/232416/shaun"}, "edited": false, "score": 0, "creation_date": 1477359066, "post_id": 40229966, "comment_id": 67723068, "body": "Well, the idea is that first time through the loop <code>active_player</code> is self.player1, next time it&#39;s player2, then back to player1.  By changing the scope of <code>active_player</code> here I lose who was the active player, which is needed to switch to the next player"}, {"owner": {"reputation": 3271, "user_id": 232416, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/23e8c255702b8c9c2f1228301796ef4b?s=128&d=identicon&r=PG", "display_name": "Shaun", "link": "https://stackoverflow.com/users/232416/shaun"}, "edited": false, "score": 0, "creation_date": 1477360017, "post_id": 40229966, "comment_id": 67723289, "body": "Yeah, your solution will work. I didn&#39;t try to write the &quot;switch to next player&quot; part until just now... that ran into problems with multiple borrows.  I&#39;ll just have to track the active player with an integer or something"}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 3271, "user_id": 232416, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/23e8c255702b8c9c2f1228301796ef4b?s=128&d=identicon&r=PG", "display_name": "Shaun", "link": "https://stackoverflow.com/users/232416/shaun"}, "edited": false, "score": 0, "creation_date": 1477360093, "post_id": 40229966, "comment_id": 67723309, "body": "I imagine you could perhaps move the &quot;get active player&quot; logic into a method of its own. Without knowing the internals of the rest of your game I can&#39;t really suggest how you would go about that though."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 3271, "user_id": 232416, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/23e8c255702b8c9c2f1228301796ef4b?s=128&d=identicon&r=PG", "display_name": "Shaun", "link": "https://stackoverflow.com/users/232416/shaun"}, "edited": false, "score": 0, "creation_date": 1477360114, "post_id": 40229966, "comment_id": 67723316, "body": "Oh wow I&#39;m slow on typing today - I am glad you figured it out and my answer was helpful."}, {"owner": {"reputation": 3271, "user_id": 232416, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/23e8c255702b8c9c2f1228301796ef4b?s=128&d=identicon&r=PG", "display_name": "Shaun", "link": "https://stackoverflow.com/users/232416/shaun"}, "edited": false, "score": 0, "creation_date": 1477360141, "post_id": 40229966, "comment_id": 67723323, "body": "Thanks.  Rust day #2... fighting with the borrow checker"}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 3271, "user_id": 232416, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/23e8c255702b8c9c2f1228301796ef4b?s=128&d=identicon&r=PG", "display_name": "Shaun", "link": "https://stackoverflow.com/users/232416/shaun"}, "edited": false, "score": 2, "creation_date": 1477360261, "post_id": 40229966, "comment_id": 67723347, "body": "...and it will continue for at least a few weeks, trust me :) Eventually it&#39;ll all click though and you&#39;ll fight it less and less. Its been a while since I&#39;ve had to sit back and actually <i>think</i> about whats wrong with the code I&#39;ve written. It gets to the point where you consider the borrow checker errors to be glaringly obvious mistakes on your part and you&#39;ll feel comfortable fixing it up. It just takes a little bit of time thats all."}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": true, "score": 1, "last_activity_date": 1477360384, "last_edit_date": 1477360384, "creation_date": 1477358722, "answer_id": 40229966, "question_id": 40229915, "link": "https://stackoverflow.com/questions/40229915/cannot-borrow-x-as-immutable-because-it-is-also-borrowed-as-mutable/40229966#40229966", "title": "cannot borrow X as immutable because it is also borrowed as mutable", "body": "<p>The scope of the mutable borrow extends the entire body of the <code>loop</code>. <a href=\"https://play.rust-lang.org/?gist=5934cd696ed41b7c3262a05e025af7ac&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">Here is a simple reproduction of your issue</a>.</p>\n\n<p>You can limit the scope of the mutable borrow, by moving it into the <code>loop</code>.. perhaps like this:</p>\n\n<pre><code>loop {\n    {\n        let mut active_player = &amp;mut self.player1; // or perhaps self.get_active_player(); ?\n        // ... do stuff with active_player ...\n    }\n\n    println!(\"{} {}\", self.player1.last_move(), self.player2.last_move());\n\n    // Switch to next player\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=5bcb1cf56e2f5c1513347310f07f27b1&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">Here is a Gist that fixes it, as above</a>.</p>\n"}], "owner": {"reputation": 3271, "user_id": 232416, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/23e8c255702b8c9c2f1228301796ef4b?s=128&d=identicon&r=PG", "display_name": "Shaun", "link": "https://stackoverflow.com/users/232416/shaun"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 782, "favorite_count": 0, "accepted_answer_id": 40229966, "answer_count": 1, "score": 1, "last_activity_date": 1477360804, "creation_date": 1477358250, "last_edit_date": 1477360804, "question_id": 40229915, "link": "https://stackoverflow.com/questions/40229915/cannot-borrow-x-as-immutable-because-it-is-also-borrowed-as-mutable", "title": "cannot borrow X as immutable because it is also borrowed as mutable", "body": "<p>In a simple game loop I have <code>active_player</code> pointing to one of 2 player objects.  </p>\n\n<pre><code>let mut active_player = &amp;mut self.player1;\nloop {\n     // do stuff with active_player\n\n    println!(\"{} {}\", self.player1.last_move(), self.player2.last_move());\n\n    // Switch to next player\n}\n</code></pre>\n\n<p>The problem comes when I try to read <code>self.player1.last_move()</code>  I understand why I'm getting the error but I don't know the proper pattern to solve this.  Is this an instance where <code>active_player</code> should be an <code>Rc</code>?</p>\n"}, {"tags": ["rust", "traits"], "comments": [{"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1477361662, "post_id": 40229704, "comment_id": 67723668, "body": "Related: <a href=\"http://stackoverflow.com/q/26378842\">stackoverflow.com/q/26378842</a>"}], "answers": [{"comments": [{"owner": {"reputation": 1595, "user_id": 3833068, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6a2a668bce4cd485078f912cbda24f2a?s=128&d=identicon&r=PG", "display_name": "Ameo", "link": "https://stackoverflow.com/users/3833068/ameo"}, "edited": false, "score": 0, "creation_date": 1477361080, "post_id": 40230100, "comment_id": 67723521, "body": "Ahh, thinking of everything having to have an owner makes it a lot more clear.  Thanks for the great reply!"}], "tags": [], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "is_accepted": true, "score": 2, "last_activity_date": 1477359929, "creation_date": 1477359929, "answer_id": 40230100, "question_id": 40229704, "link": "https://stackoverflow.com/questions/40229704/preventing-value-from-dropping-inside-generic-match/40230100#40230100", "title": "Preventing value from dropping inside generic match", "body": "<p>The object you create needs to have an owner. Plain reference <code>&amp;</code> can not be owner, that's why you need <code>temp</code>/<code>temp2</code>/<code>temp3</code> in your code to serve as owner of the object you create in <code>match</code> arms.</p>\n\n<p>The simplest way to own a trait object is to use <code>Box</code> like below:</p>\n\n<pre><code>// definitions omitted...\nfn main() {\n    let x = Enm::X3;\n\n    let gen = match x {\n        Enm::X1 =&gt; {\n            Box::new(A{}) as Box&lt;Trt&gt;\n        },\n        Enm::X2 =&gt; {\n            Box::new(B{}) as Box&lt;Trt&gt;\n        },\n        Enm::X3 =&gt; {\n            Box::new(C{}) as Box&lt;Trt&gt;\n        },\n    };\n\n    println!(\"{}\", gen.foo());\n}\n</code></pre>\n\n<p>After the match clause, now <code>gen</code> owns the created trait object, so you don't have to define temporaries anymore.</p>\n"}], "owner": {"reputation": 1595, "user_id": 3833068, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6a2a668bce4cd485078f912cbda24f2a?s=128&d=identicon&r=PG", "display_name": "Ameo", "link": "https://stackoverflow.com/users/3833068/ameo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 44, "favorite_count": 0, "closed_date": 1477377187, "accepted_answer_id": 40230100, "answer_count": 1, "score": 2, "last_activity_date": 1477359929, "creation_date": 1477356374, "question_id": 40229704, "link": "https://stackoverflow.com/questions/40229704/preventing-value-from-dropping-inside-generic-match", "closed_reason": "Duplicate", "title": "Preventing value from dropping inside generic match", "body": "<p>When attempting to create objects that inherit a trait from within a <code>match</code> statement, I find it's necessary to define different external variables for every type of object being matched.  It's necessary to declare the variables outside of the match so that the declarations don't go out of scope.</p>\n\n<p>It's impossible to use a single external variable of type <code>Trt</code> since <code>Trt</code> is unsized.  It there any way to have the match return an object implementing <code>Trt</code> without reverting to this ugly method of defining lots of variables ahead of time?</p>\n\n<p>Here's an example of the problem:</p>\n\n<pre><code>enum Enm {\n    X1,\n    X2,\n    X3\n}\n\ntrait Trt {\n    fn foo(&amp;self) -&gt; &amp;'static str;\n}\n\nstruct A{}\nimpl Trt for A{\n    fn foo(&amp;self) -&gt; &amp;'static str { \"A\" }\n}\n\nstruct B{}\nimpl Trt for B{\n    fn foo(&amp;self) -&gt; &amp;'static str { \"B\" }\n}\n\nstruct C{}\nimpl Trt for C{\n    fn foo(&amp;self) -&gt; &amp;'static str { \"C\" }\n}\n\nfn main() {\n    let x = Enm::X3;\n\n    let mut temp;\n    let mut temp2;\n    let mut temp3;\n    let gen = match x {\n        Enm::X1 =&gt; {\n            temp = A{};\n            &amp;mut temp as &amp;mut Trt\n        },\n        Enm::X2 =&gt; {\n            temp2 = B{};\n            &amp;mut temp2 as &amp;mut Trt\n        },\n        Enm::X3 =&gt; {\n            temp3 = C{};\n            &amp;mut temp3 as &amp;mut Trt\n        },\n    };\n\n    println!(\"{}\", gen.foo());\n}\n</code></pre>\n"}, {"tags": ["windows", "rust", "rust-cargo"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 4, "creation_date": 1477321253, "post_id": 40221379, "comment_id": 67706556, "body": "It would be better to add the information as text rather than screenshots."}], "answers": [{"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 3, "last_activity_date": 1477321224, "creation_date": 1477321224, "answer_id": 40221561, "question_id": 40221379, "link": "https://stackoverflow.com/questions/40221379/cargo-fails-to-build-termbox-sys-on-windows/40221561#40221561", "title": "Cargo fails to build termbox-sys on Windows", "body": "<p>Rustbox doesn't seem to support Windows yet:  <a href=\"https://github.com/gchp/rustbox/issues/7\" rel=\"nofollow\">https://github.com/gchp/rustbox/issues/7</a> , though someone <a href=\"https://github.com/jayrandez/rustbox/tree/win-dev\" rel=\"nofollow\">has previously worked on it</a>.</p>\n"}], "owner": {"reputation": 163, "user_id": 5196007, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/dfbe866a40921aa8144aced2de396f56?s=128&d=identicon&r=PG&f=1", "display_name": "Emlingur", "link": "https://stackoverflow.com/users/5196007/emlingur"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 93, "favorite_count": 0, "answer_count": 1, "score": -2, "last_activity_date": 1477322167, "creation_date": 1477320574, "last_edit_date": 1477322167, "question_id": 40221379, "link": "https://stackoverflow.com/questions/40221379/cargo-fails-to-build-termbox-sys-on-windows", "title": "Cargo fails to build termbox-sys on Windows", "body": "<p><a href=\"https://i.stack.imgur.com/QqrbX.png\" rel=\"nofollow\"><img src=\"https://i.stack.imgur.com/QqrbX.png\" alt=\"cmd\"></a></p>\n\n<p><a href=\"https://i.stack.imgur.com/T4X7A.png\" rel=\"nofollow\"><img src=\"https://i.stack.imgur.com/T4X7A.png\" alt=\"toml\"></a></p>\n\n<p>Any ideas on what I can do to fix this?</p>\n"}, {"tags": ["types", "rust"], "answers": [{"comments": [{"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1477328650, "post_id": 40222903, "comment_id": 67710969, "body": "This is pretty much what I wanted. Awesome. I had a similar solution, but by required changing tail from <code>PhantomData&lt;T&gt;</code> to <code>T</code>."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 8, "last_activity_date": 1477325390, "creation_date": 1477325390, "answer_id": 40222903, "question_id": 40219725, "link": "https://stackoverflow.com/questions/40219725/constructing-hetereogenous-type-lists-in-rust/40222903#40222903", "title": "Constructing Hetereogenous Type Lists in Rust", "body": "<p>Recursion on using associated types seems to do the trick:</p>\n\n<pre><code>trait Append&lt;D: Data&gt; {\n    type Result;\n    fn append(self, item: D) -&gt; Self::Result;\n}\n\nimpl&lt;D:Data&gt; Append&lt;D&gt; for Nil {\n    type Result = Cons&lt;D, Nil&gt;;\n    fn append(self, item: D) -&gt; Self::Result {\n        Cons {\n            head: PhantomData,\n            tail: PhantomData,\n        }\n    }\n\n}\n\nimpl&lt;D:Data, H, T:HList+Append&lt;D&gt;&gt; Append&lt;D&gt; for Cons&lt;H,T&gt; {\n    type Result = Cons&lt;H, &lt;T as Append&lt;D&gt;&gt;::Result&gt;;\n    fn append(self, item: D) -&gt; Self::Result {\n        Cons {\n            head: PhantomData,\n            tail: PhantomData,\n        }\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=fcb00e98884988104c17358ea78f708d&amp;version=nightly&amp;backtrace=0\">Playground link</a></p>\n"}, {"tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": false, "score": 3, "last_activity_date": 1477326508, "creation_date": 1477326508, "answer_id": 40223207, "question_id": 40219725, "link": "https://stackoverflow.com/questions/40219725/constructing-hetereogenous-type-lists-in-rust/40223207#40223207", "title": "Constructing Hetereogenous Type Lists in Rust", "body": "<p>It's probably better to forego the zero-sized data altogether and just play with types:</p>\n\n<pre><code>trait Append&lt;D&gt;: Sized {\n    type Out;\n}\n\nimpl&lt;D&gt; Append&lt;D&gt; for Nil {\n    type Out = Cons&lt;D, Nil&gt;;\n}\n\nimpl&lt;D, H, T&gt; Append&lt;D&gt; for Cons&lt;H, T&gt;\n    where T: Append&lt;D&gt;\n{\n    type Out = Cons&lt;H, &lt;T as Append&lt;D&gt;&gt;::Out&gt;;\n}\n</code></pre>\n\n<p>This way your values can remain values, and if you want to do type math you just don't instantiate them. <a href=\"https://play.rust-lang.org/?gist=27d5e987da2d9fbd760324a36ca0b0bb&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow\">Here's a full example.</a></p>\n"}], "owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 500, "favorite_count": 0, "accepted_answer_id": 40222903, "answer_count": 2, "score": 9, "last_activity_date": 1477326508, "creation_date": 1477315688, "last_edit_date": 1477320866, "question_id": 40219725, "link": "https://stackoverflow.com/questions/40219725/constructing-hetereogenous-type-lists-in-rust", "title": "Constructing Hetereogenous Type Lists in Rust", "body": "<p>I have the following definition of <code>HList</code>:</p>\n\n<pre><code>pub trait Data: Any + Debug {}\nimpl&lt;T: Any + Debug&gt; Data for T {}\n\n/// The empty `HList`.\npub struct Nil;\n\n/// An `HList` with `H` at position 0, and `T` as the rest of the list.\npub struct Cons&lt;H, T&gt; {\n    head: PhantomData&lt;H&gt;,\n    tail: PhantomData&lt;T&gt;,\n}\n\n/// A marker trait that `Nil` and `Cons&lt;H, T&gt;` satisfies.\npub trait HList {}\nimpl HList for Nil {}\nimpl&lt;H, T: HList&gt; HList for Cons&lt;H, T&gt; {}\n</code></pre>\n\n<p>How would I construct the types by appending them to the end?</p>\n\n<p>Inserting them as the first element is trivial:</p>\n\n<pre><code>trait Prepend&lt;D: Data&gt;: Sized {\n    fn prepend(self, item: D) -&gt; Cons&lt;D, Self&gt;;\n}\n\nimpl&lt;D: Data&gt; Prepend&lt;D&gt; for Nil {\n    fn prepend(self, item: D) -&gt; Cons&lt;D, Nil&gt; {\n        Cons {\n            head: PhantomData,\n            tail: PhantomData,\n        }\n    }\n}\n\nimpl&lt;D: Data, H, T: HList&gt; Prepend&lt;D&gt; for Cons&lt;H, T&gt; {\n    fn prepend(self, item: D) -&gt; Cons&lt;D, Cons&lt;H, T&gt;&gt; {\n        Cons {\n            head: PhantomData,\n            tail: PhantomData,\n        }\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=26e25b07d67cfc045ce5790573736332&amp;version=nightly&amp;backtrace=0\" rel=\"noreferrer\">Playground link</a></p>\n\n<p>But appending elements on the end, while maintaining same structure seems hard. </p>\n\n<pre><code>Nil.prepend(true).prepend(3).prepend(\"string\") \n  -&gt; Cons&lt;&amp;'static str, Cons&lt;i32, Cons&lt;bool, Nil&gt;&gt;&gt;\n\n\nNil.push(\"string\").push(3).push(true) \n  -&gt; Cons&lt;&amp;'static str, Cons&lt;i32, Cons&lt;bool, Nil&gt;&gt;&gt;\n</code></pre>\n\n<p>I know the answer is some kind of recursive function, that seeks to the last <code>Nil</code> in the list and adds the current value there, but I have difficulty defining a function for the trait that works with such a recursive function.</p>\n\n<p>Assuming we have a trait <code>Push</code> with the method <code>push</code> that adds an element into the <code>HList</code> in the innermost bracket:</p>\n\n<pre><code>pub trait Push&lt;?&gt; {\n    fn push(self?, el: item) -&gt; ?;\n}\n</code></pre>\n\n<p>How would one construct it?</p>\n"}, {"tags": ["python", "rust", "cffi"], "comments": [{"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1477374772, "post_id": 40219711, "comment_id": 67727097, "body": "@Shepmaster Thanks for pushing me to make the example completely reproducible. That was my main problem with other very similar questions."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1477501753, "last_edit_date": 1477501753, "creation_date": 1477490234, "answer_id": 40264266, "question_id": 40219711, "link": "https://stackoverflow.com/questions/40219711/dereference-ffi-pointer-in-python-to-get-underlying-array/40264266#40264266", "title": "Dereference FFI pointer in Python to get underlying array", "body": "<p>The <code>cast</code> should be the first warning sign. Why do you have to cast from the type to what should be the same type? This is because there are simple typos:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>lib.rle_values.restype = POINTER(c_int32)    \nlib.rle_values_size.restype = c_int32\n</code></pre>\n\n<p>Note that it's supposed to be <code>restype</code>, not <code>restypes</code>.</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>def __str__(self):\n    values_size = lib.rle_values_size(self.obj)\n    print(values_size, \"values_size\")\n\n    values_pointer = lib.rle_values(self.obj)\n    print(\"values_pointer:\", values_pointer)\n\n    thing = values_pointer[:values_size]\n    return str(thing)\n</code></pre>\n\n<p>It's also better to use <code>as_mut_ptr</code>:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>#[no_mangle]\npub extern \"C\" fn rle_values(rle: *mut Rle) -&gt; *mut int32_t {\n    let mut rle = unsafe { &amp;mut *rle };\n    rle.values.as_mut_ptr()\n}\n</code></pre>\n\n<p>Running the program appears to work:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ LD_LIBRARY_PATH=$PWD/target/debug/ python3 main.py\nnew\n30 values_size\nvalues_pointer: &lt;__main__.LP_c_int object at 0x10f124048&gt;\n[1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2]\n</code></pre>\n\n<hr>\n\n<p>I'd also recommend:</p>\n\n<ul>\n<li>the default ctypes return value is a <code>cint</code>. Not specifying a return type for <code>free</code> is probably not a good idea, as it should be <code>void</code>.</li>\n<li>return an unsigned number for the length of the data; what would -53 items mean?</li>\n<li>reduce the scope of the <code>unsafe</code> blocks to just the part that is unsafe and the code that ensures it is actually safe.</li>\n<li><p>speaking of which, you could check for <code>NULL</code> pointers in each function.</p>\n\n<pre><code>#[no_mangle]\npub extern \"C\" fn rle_values_size(rle: *mut Rle) -&gt; int32_t {\n    match unsafe { rle.as_ref() } {\n        Some(rle) =&gt; rle.values.len() as i32,\n        None =&gt; 0,\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn rle_values(rle: *mut Rle) -&gt; *mut int32_t {\n    match unsafe { rle.as_mut() } {\n        Some(mut rle) =&gt; rle.values.as_mut_ptr(),\n        None =&gt; ptr::null_mut(),\n    }\n}\n</code></pre></li>\n</ul>\n"}], "owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 479, "favorite_count": 0, "accepted_answer_id": 40264266, "answer_count": 1, "score": 5, "last_activity_date": 1477501753, "creation_date": 1477315650, "last_edit_date": 1495541954, "question_id": 40219711, "link": "https://stackoverflow.com/questions/40219711/dereference-ffi-pointer-in-python-to-get-underlying-array", "title": "Dereference FFI pointer in Python to get underlying array", "body": "<p>I have a C FFI written in Rust, called <code>src/lib.rs</code> that looks like the following:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>// compile with $ cargo build\n\nextern crate libc;\nuse self::libc::{size_t, int32_t};\n\nuse std::cmp::min;\nuse std::slice;\n\n#[no_mangle]\npub extern \"C\" fn rle_new(values_data: *const int32_t, values_length: size_t) -&gt; *mut Rle {\n    let values = unsafe { slice::from_raw_parts(values_data, values_length as usize).to_vec() };\n\n    return Box::into_raw(Box::new(Rle::new(values)));\n\n}\n\n#[no_mangle]\npub extern \"C\" fn rle_free(ptr: *mut Rle) {\n    if ptr.is_null() {\n        return;\n    }\n    unsafe {\n        Box::from_raw(ptr);\n    }\n}  \n\n#[no_mangle]\npub extern \"C\" fn rle_values_size(rle: *mut Rle) -&gt; int32_t {\n    unsafe { (*rle).values.len() as i32 }\n}\n\n#[no_mangle]\npub extern \"C\" fn rle_values(rle: *mut Rle) -&gt; *mut int32_t {\n    unsafe { &amp;mut (*rle).values[0] }\n}\n\n\n#[derive(Debug, PartialEq)]\npub struct Rle {\n    pub values: Vec&lt;i32&gt;,\n}\n\n\nimpl Rle {\n    pub fn new(values: Vec&lt;i32&gt;) -&gt; Self {\n        return Rle { values: values };\n    }\n}\n</code></pre>\n\n<p>This is my Cargo.toml in the project base folder:</p>\n\n<pre><code>[package]\nname = \"minimal_example\"\nversion = \"0.1.0\"\nauthors = [\"Dumbass\"]\n\n[dependencies]\nlibc = \"0.2.16\"\n\n[lib]\ncrate-type = [\"dylib\"] # you might need a different type on linux/windows ?\n</code></pre>\n\n<p>This is the Python code calling Rust, also put in the base folder:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>import os\nimport sys, ctypes\nfrom ctypes import c_char_p, c_uint32, Structure, POINTER, c_int32, c_size_t, pointer\n\nclass RleS(Structure):\n    pass\n\nprefix = {'win32': ''}.get(sys.platform, 'lib')\nextension = {'darwin': '.dylib', 'win32': '.dll'}.get(sys.platform, '.so')\nlibpath = os.environ.get(\"LD_LIBRARY_PATH\", \"target/debug\") + \"/\"\nlibpath = libpath + prefix + \"minimal_example\" + extension\n\ntry:\n    lib = ctypes.cdll.LoadLibrary(libpath)\nexcept OSError:\n    print(\"Library not found at \" + libpath)\n    sys.exit()\n\nlib.rle_new.restype = POINTER(RleS)\n\nlib.rle_free.argtypes = (POINTER(RleS), )\n\nlib.rle_values.argtypes = (POINTER(RleS), )\nlib.rle_values.restypes = POINTER(c_int32)\n\nlib.rle_values_size.argtypes = (POINTER(RleS), )\nlib.rle_values_size.restypes = c_int32\n\n\nclass Rle:\n    def __init__(self, values):\n\n        values_length =  len(values)\n\n        values_array = (c_int32 * len(values))(*values)\n\n        self.obj = lib.rle_new(values_array, c_size_t(values_length))\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        lib.rle_free(self.obj)\n\n    def __str__(self):\n        values_size = lib.rle_values_size(self.obj)\n        print(values_size, \"values_size\") # prints correct value\n\n        values_pointer = lib.rle_values(self.obj)\n        print(\"values_pointer:\", values_pointer)\n        ar = ctypes.cast(values_pointer, ctypes.POINTER(ctypes.c_int32)).contents\n        print(ar) # segfaults!\n\nrle = Rle([1, 1, 2] * 10)\nprint(rle)\n</code></pre>\n\n<p>I have good reason to believe that the C code is correct, since the <code>rle_values_size</code> and <code>rle_values</code> refer to the same object, namely a Rust vector within a struct, and the <code>rle_values_size</code> function works.</p>\n\n<p>However, when I try to dereference the pointer given by <code>rle_values</code> and read it as an array I get segfaults.</p>\n\n<p>I have tried every single permutation of code snippets I have found on Stack Overflow, but it segfaults.</p>\n\n<p>Why is this crashing? What am I doing wrong?</p>\n\n<p>I added the Rust tag since I might be getting the address of the vector in the wrong way.</p>\n\n<p>Ps. If somebody also knows how to read this directly into a numpy array I would upvote that too. </p>\n\n<p>Background info: <a href=\"https://stackoverflow.com/questions/40156545/how-do-i-return-an-array-in-a-pub-extern-c-fn/40170400?noredirect=1#comment67624063_40170400\">How do I return an array in a pub extern &quot;C&quot; fn?</a></p>\n"}, {"tags": ["sockets", "unix", "rust"], "answers": [{"comments": [{"owner": {"reputation": 320, "user_id": 110470, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/fl0rE.jpg?s=128&g=1", "display_name": "Sam Khawase", "link": "https://stackoverflow.com/users/110470/sam-khawase"}, "edited": false, "score": 0, "creation_date": 1477318021, "post_id": 40218765, "comment_id": 67704329, "body": "My bad, I got carried away by the scope of the problem and posted the whole solution. I&#39;ll update the question once I&#39;m done with implementing the solution."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 12, "last_activity_date": 1578455093, "last_edit_date": 1578455093, "creation_date": 1477312982, "answer_id": 40218765, "question_id": 40218416, "link": "https://stackoverflow.com/questions/40218416/how-do-i-close-a-unix-socket-in-rust/40218765#40218765", "title": "How do I close a Unix socket in Rust?", "body": "<p>Please learn to create a <a href=\"/help/minimal-reproducible-example\">minimal reproducible example</a> and then take the time to do so. In this case, there's no need for threads or functions or testing frameworks; running this entire program twice reproduces the error:</p>\n\n<pre><code>use std::os::unix::net::UnixListener;\n\nfn main() {\n    UnixListener::bind(\"/tmp/my_socket.sock\").unwrap();\n}\n</code></pre>\n\n<p>If you look at the filesystem before and after the test, you will see that the file <code>/tmp/my_socket.sock</code> is not present before the first run and it is present before the second run. Deleting the file allows the program to run to completion again (at which point it recreates the file).</p>\n\n<p>This issue is <a href=\"https://troydhanson.github.io/network/Unix_domain_sockets.html\" rel=\"noreferrer\">not unique to Rust</a>:</p>\n\n<blockquote>\n  <p>Note that, once created, this socket file will continue to exist, even after the server exits. If the server subsequently restarts, the file prevents re-binding:</p>\n  \n  <p>[...]</p>\n  \n  <p>So, servers should unlink the socket pathname prior to binding it.</p>\n</blockquote>\n\n<p>You could choose to add some wrapper around the socket that would automatically delete it when it is dropped or <a href=\"https://docs.rs/tempdir/0.3.5/tempdir/\" rel=\"noreferrer\">create a temporary directory that is cleaned when it is dropped</a>, but I'm not sure how well that would work. You could also create a wrapper function that deletes the file before it opens the socket. </p>\n\n<h3>Unlinking the socket when it's dropped</h3>\n\n<pre><code>use std::path::{Path, PathBuf};\n\nstruct DeleteOnDrop {\n    path: PathBuf,\n    listener: UnixListener,\n}\n\nimpl DeleteOnDrop {\n    fn bind(path: impl AsRef&lt;Path&gt;) -&gt; std::io::Result&lt;Self&gt; {\n        let path = path.as_ref().to_owned();\n        UnixListener::bind(&amp;path).map(|listener| DeleteOnDrop { path, listener })\n    }\n}\n\nimpl Drop for DeleteOnDrop {\n    fn drop(&amp;mut self) {\n        // There's no way to return a useful error here\n        let _ = std::fs::remove_file(&amp;self.path).unwrap();\n    }\n}\n</code></pre>\n\n<p>You may also want to consider implementing <code>Deref</code> / <code>DerefMut</code> to make this into a smart pointer for sockets:</p>\n\n<pre><code>impl std::ops::Deref for DeleteOnDrop {\n    type Target = UnixListener;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        &amp;self.listener\n    }\n}\n\nimpl std::ops::DerefMut for DeleteOnDrop {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {\n        &amp;mut self.listener\n    }\n}\n</code></pre>\n\n<h3>Unlinking the socket before it's opened</h3>\n\n<p>This is much simpler:</p>\n\n<pre><code>use std::path::Path;\n\nfn bind(path: impl AsRef&lt;Path&gt;) -&gt; std::io::Result&lt;UnixListener&gt; {\n    let path = path.as_ref();\n    std::fs::remove_file(path)?;\n    UnixListener::bind(path)\n}\n</code></pre>\n\n<p>Note that you can combine the two solutions, such that the socket is deleted before creation and when it's dropped.</p>\n\n<p>I think that deleting during creation is a less-optimal solution: if you ever start a second server, you'll prevent the first server from receiving any more connections. It's probably better to error and tell the user instead.</p>\n"}], "owner": {"reputation": 320, "user_id": 110470, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/fl0rE.jpg?s=128&g=1", "display_name": "Sam Khawase", "link": "https://stackoverflow.com/users/110470/sam-khawase"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2640, "favorite_count": 0, "accepted_answer_id": 40218765, "answer_count": 1, "score": 3, "last_activity_date": 1578455093, "creation_date": 1477312004, "last_edit_date": 1477313189, "question_id": 40218416, "link": "https://stackoverflow.com/questions/40218416/how-do-i-close-a-unix-socket-in-rust", "title": "How do I close a Unix socket in Rust?", "body": "<p>I have a test that opens and listens to a Unix Domain Socket. The socket is opened and reads data without issues, but it doesn't shutdown gracefully. </p>\n\n<p>This is the error I get when I try to run the test a second time:</p>\n\n<blockquote>\n  <p>thread 'test_1' panicked at 'called <code>Result::unwrap()</code> on an <code>Err</code>\n  value: Error { repr: Os { code: 48, message: \"Address already in use\"\n  } }', ../src/libcore/result.rs:799 note: Run with <code>RUST_BACKTRACE=1</code>\n  for a backtrace.</p>\n</blockquote>\n\n<p>The code is available <a href=\"https://play.rust-lang.org/?gist=4bb3fb9ea20a5e6b9ce37fd69e7a39ca&amp;version=stable&amp;backtrace=2\" rel=\"nofollow\" title=\"Rust Playground\">at the Rust playground</a> and there's a <a href=\"https://gist.github.com/4bb3fb9ea20a5e6b9ce37fd69e7a39ca\" rel=\"nofollow\">Github Gist for it</a>.</p>\n\n<pre><code>use std::io::prelude::*;\nuse std::thread;\nuse std::net::Shutdown;\nuse std::os::unix::net::{UnixStream, UnixListener};\n</code></pre>\n\n<p><strong>Test Case:</strong></p>\n\n<pre><code>#[test]\nfn test_1() {\n    driver();\n    assert_eq!(\"1\", \"2\");\n}\n</code></pre>\n\n<p><strong>Main entry point function</strong>    </p>\n\n<pre><code>fn driver() {\n    let listener = UnixListener::bind(\"/tmp/my_socket.sock\").unwrap();\n\n    thread::spawn(|| socket_server(listener));\n\n    // send a message \n    busy_work(3);\n\n    // try to disconnect the socket\n    let drop_stream = UnixStream::connect(\"/tmp/my_socket.sock\").unwrap();\n    let _ = drop_stream.shutdown(Shutdown::Both);\n}\n</code></pre>\n\n<p><strong>Function to send data in intervals</strong></p>\n\n<pre><code>#[allow(unused_variables)]\nfn busy_work(threads: i32) {\n    // Make a vector to hold the children which are spawned.\n    let mut children = vec![];\n    for i in 0..threads {\n        // Spin up another thread\n        children.push(thread::spawn(|| socket_client()));\n    }\n    for child in children {\n        // Wait for the thread to finish. Returns a result.\n        let _ = child.join();\n    }\n}\n\nfn socket_client() {\n    let mut stream = UnixStream::connect(\"/tmp/my_socket.sock\").unwrap();\n    stream.write_all(b\"hello world\").unwrap();\n}\n</code></pre>\n\n<p><strong>Function to handle data</strong></p>\n\n<pre><code>fn handle_client(mut stream: UnixStream) {\n    let mut response = String::new();\n    stream.read_to_string(&amp;mut response).unwrap();\n    println!(\"got response: {:?}\", response);\n}\n</code></pre>\n\n<p><strong>Server socket that listens to incoming messages</strong></p>\n\n<pre><code>#[allow(unused_variables)]\nfn socket_server(listener: UnixListener) {\n    // accept connections and process them, spawning a new thread for each one\n    for stream in listener.incoming() {\n        match stream {\n            Ok(mut stream) =&gt; {\n                /* connection succeeded */\n                let mut response = String::new();\n                stream.read_to_string(&amp;mut response).unwrap();\n                if response.is_empty() {\n                    break;\n                } else {\n                    thread::spawn(|| handle_client(stream));\n                }                \n            }\n            Err(err) =&gt; {\n                /* connection failed */\n                break;\n            }\n        }\n    }\n    println!(\"Breaking out of socket_server()\");\n    drop(listener);\n}\n</code></pre>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "is_accepted": false, "score": 5, "last_activity_date": 1477302428, "creation_date": 1477302428, "answer_id": 40215307, "question_id": 40215216, "link": "https://stackoverflow.com/questions/40215216/manipulating-an-object-from-inside-a-loop-that-borrows-it/40215307#40215307", "title": "Manipulating an object from inside a loop that borrows it", "body": "<p>Given that you don't need the full <code>ServerReader</code> for processing a message, you could make <code>process_message</code> a free function and just pass <code>&amp;mut self.counters</code> to it. Then you have disjoint borrows of <code>server</code> and <code>counters</code>, which is fine.</p>\n\n<p>Or if your non-<code>server</code> part of <code>ServerReader</code> is larger, extract that into its own struct, and make <code>process_message</code> an impl method of that struct.</p>\n"}, {"comments": [{"owner": {"reputation": 1717, "user_id": 323589, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/6f7f6e4a945aa6cba9ae8ec87475f627?s=128&d=identicon&r=PG", "display_name": "Shtong", "link": "https://stackoverflow.com/users/323589/shtong"}, "edited": false, "score": 1, "creation_date": 1477303117, "post_id": 40215398, "comment_id": 67694892, "body": "Thanks, but that&#39;s not really what I&#39;m looking for; this is a very simplified example, and I&#39;m not a big fan of doing everything inline (which would end in a veeeery long loop :)"}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 3, "last_activity_date": 1477302733, "creation_date": 1477302733, "answer_id": 40215398, "question_id": 40215216, "link": "https://stackoverflow.com/questions/40215216/manipulating-an-object-from-inside-a-loop-that-borrows-it/40215398#40215398", "title": "Manipulating an object from inside a loop that borrows it", "body": "<p>In order to allow mutability in an <code>Iterator</code>, you should use <code>iter_mut()</code> and work on mutable references (<code>&amp;mut message</code>). Then, to avoid the additional borrow, you could just perform the addition in the body of the loop:</p>\n\n<pre><code>for &amp;mut message in self.server.iter_mut() {\n    println!(\"Received {}\", message);\n    *self.counters.entry(message).or_insert(0) += 1;\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1717, "user_id": 323589, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/6f7f6e4a945aa6cba9ae8ec87475f627?s=128&d=identicon&r=PG", "display_name": "Shtong", "link": "https://stackoverflow.com/users/323589/shtong"}, "edited": false, "score": 0, "creation_date": 1477305036, "post_id": 40215445, "comment_id": 67695955, "body": "Interesting. My first though reading your first suggestion was that I would get the same error, because getting a mut ref on <code>self.state</code> to call process_message would try to get a mut ref of <code>self</code> too, but your example works indeed... I&#39;m not sure why! I guess that means I should do a little more reading about borrowing"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 1717, "user_id": 323589, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/6f7f6e4a945aa6cba9ae8ec87475f627?s=128&d=identicon&r=PG", "display_name": "Shtong", "link": "https://stackoverflow.com/users/323589/shtong"}, "edited": false, "score": 2, "creation_date": 1477305353, "post_id": 40215445, "comment_id": 67696135, "body": "You can separately borrow fields of the struct; the first bit of documentation I found is <a href=\"https://doc.rust-lang.org/nomicon/borrow-splitting.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/nomicon/borrow-splitting.html</a>"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 18, "last_activity_date": 1477305420, "last_edit_date": 1477305420, "creation_date": 1477302874, "answer_id": 40215445, "question_id": 40215216, "link": "https://stackoverflow.com/questions/40215216/manipulating-an-object-from-inside-a-loop-that-borrows-it/40215445#40215445", "title": "Manipulating an object from inside a loop that borrows it", "body": "<p>As you've worked out, you can't call a <code>&amp;mut self</code> method while you're borrowing part of <code>self</code>, so you need to restructure somehow.</p>\n\n<p>The way I would do it is to split the state needed by <code>process_message</code> into a separate type (in your example that's basically the <code>HashMap</code>, but in the real application it's likely to contain more), and move the method to that type.  This works because <a href=\"https://doc.rust-lang.org/nomicon/borrow-splitting.html\" rel=\"noreferrer\">you can separately borrow fields from a struct</a>.</p>\n\n<pre><code>struct SomeState {\n    counters: HashMap&lt;u32, usize&gt;,\n}\n\nimpl SomeState {\n    pub fn new() -&gt; SomeState {\n        SomeState {\n            counters: HashMap::new(),\n        }\n    }\n    fn process_message(&amp;mut self, message: u32) {\n        let counter = self.counters.entry(message).or_insert(0);\n        *counter += 1;\n    }\n}\n\nstruct ServerReader {\n    server: Vec&lt;u32&gt;,\n    state: SomeState,\n}\n\nimpl ServerReader {\n    fn new() -&gt; ServerReader {\n        ServerReader {\n            server: vec!(1, 2, 5, 2, 7, 9, 1, 1, 5, 6),\n            state: SomeState::new(),\n        }\n    }\n\n    fn run(&amp;mut self) {\n        println!(\"Connecting...\");\n\n        for message in self.server.iter() {\n            println!(\"Received {}\", message);\n            self.state.process_message(*message);\n        }\n        println!(\"Disconnected\");\n    }\n\n}\n</code></pre>\n\n<p>An alternative (which may or may not be possible in your real example) would be to avoid borrowing in the loop, making it more like:</p>\n\n<pre><code>loop {\n    // if next_message() returns an owned message, ie not still borrowing\n    // self\n    let message = self.next_message();\n    // now no borrow left\n    self.process_message(message);\n}\n</code></pre>\n"}], "owner": {"reputation": 1717, "user_id": 323589, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/6f7f6e4a945aa6cba9ae8ec87475f627?s=128&d=identicon&r=PG", "display_name": "Shtong", "link": "https://stackoverflow.com/users/323589/shtong"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3124, "favorite_count": 0, "accepted_answer_id": 40215445, "answer_count": 3, "score": 25, "last_activity_date": 1477310736, "creation_date": 1477302110, "last_edit_date": 1477310736, "question_id": 40215216, "link": "https://stackoverflow.com/questions/40215216/manipulating-an-object-from-inside-a-loop-that-borrows-it", "title": "Manipulating an object from inside a loop that borrows it", "body": "<p>I'm writing some code in Rust that connects to a remote server, and depending on the messages sent by that server, computes some statistics or executes actions based on these statistics. But this is more of a learning project for me and I've run into an issue.</p>\n\n<p>Here is the code that I have reduced to a bare minimum to reproduce the problem :</p>\n\n<pre><code>// Repro code for error[E0502]: cannot borrow `*self` as mutable because `self.server` is also borrowed as immutable\n\nuse std::collections::HashMap;\n\nstruct ServerReader {\n    server: Vec&lt;u32&gt;, // A vec for demo purposes, but please imagine this is a server object\n    counters: HashMap&lt;u32, usize&gt;,\n}\n\nimpl ServerReader {\n    fn new() -&gt; ServerReader {\n        ServerReader {\n            server: vec!(1, 2, 5, 2, 7, 9, 1, 1, 5, 6), // Filling my \"server\" with some messages\n            counters: HashMap::new(),\n        }\n    }\n\n    fn run(&amp;mut self) {\n        println!(\"Connecting...\"); // ... here there should be some code to connect to the server ...\n\n        for message in self.server.iter() { // We wait for the network messages sent by the server, and process them as they come\n//                     ----------- immutable borrow occurs here\n            println!(\"Received {}\", message);\n            self.process_message(*message); // HOW\n//          ^^^^ mutable borrow occurs here\n        }\n//      - immutable borrow ends here\n        println!(\"Disconnected\");\n    }\n\n    fn process_message(&amp;mut self, message: u32) {\n        // Please imagine that this function contains complex stuff\n        let counter = self.counters.entry(message).or_insert(0);\n        *counter += 1;\n    }\n}\n\nfn main() {\n    let mut reader = ServerReader::new();\n\n    reader.run();\n\n    println!(\"Done\");\n}\n</code></pre>\n\n<p>While I think I understand why the compiler is unhappy, I'm struggling to come up with a solution. I cannot manipulate my structure outside of the loop, since I have to work while connected and listening to the server. I also could put everything directly in the loop and not call any method, but I don't want to end up with a 1000 line loop (and I'd prefer to understand what an actual solution would look like).</p>\n"}, {"tags": ["generics", "rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477313545, "post_id": 40213294, "comment_id": 67701087, "body": "Note that this only works because of type inference; <code>0</code> and <code>1</code> can mean <code>u8</code> or <code>u32</code> or <code>i64</code>. In most cases, you have to spell out the specific value you need."}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": true, "score": 8, "last_activity_date": 1477295676, "creation_date": 1477295676, "answer_id": 40213294, "question_id": 40212998, "link": "https://stackoverflow.com/questions/40212998/how-to-implement-a-trait-in-the-same-way-for-many-types-without-repetition/40213294#40213294", "title": "How to implement a trait in the same way for many types without repetition?", "body": "<p>As per <a href=\"https://doc.rust-lang.org/reference.html#implementations\">Rust reference</a>:</p>\n\n<blockquote>\n  <p>An implementation is an item that implements a trait for a specific type.</p>\n</blockquote>\n\n<p>Take a look at the implementations of <code>Zero</code> and <code>One</code> in the <a href=\"https://doc.rust-lang.org/stable/src/core/up/src/libcore/num/mod.rs.html#104-174\">docs</a> (deprecated since Rust 1.11, I removed the deprecation attributes for brevity):</p>\n\n<pre><code>pub trait Zero: Sized {\n    fn zero() -&gt; Self;\n}\n\npub trait One: Sized {\n    fn one() -&gt; Self;\n}\n\nmacro_rules! zero_one_impl {\n    ($($t:ty)*) =&gt; ($(\n        impl Zero for $t {\n            #[inline]\n            fn zero() -&gt; Self { 0 }\n        }\n        impl One for $t {\n            #[inline]\n            fn one() -&gt; Self { 1 }\n        }\n    )*)\n}\nzero_one_impl! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n</code></pre>\n\n<p>If the standard docs did it with macros, I doubt a better way exists.</p>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 95, "favorite_count": 0, "accepted_answer_id": 40213294, "answer_count": 1, "score": 3, "last_activity_date": 1477322826, "creation_date": 1477294630, "last_edit_date": 1477322826, "question_id": 40212998, "link": "https://stackoverflow.com/questions/40212998/how-to-implement-a-trait-in-the-same-way-for-many-types-without-repetition", "title": "How to implement a trait in the same way for many types without repetition?", "body": "<p>Given a trait, we may want to implement it for many types.</p>\n\n<pre><code>pub trait RTypeUnit {\n    fn zero() -&gt; Self;\n    fn one() -&gt; Self;\n}\n\nimpl RTypeUnit for usize { fn zero() -&gt; usize { 0 } fn one() -&gt; usize { 1 } }\nimpl RTypeUnit for isize { fn zero() -&gt; isize { 0 } fn one() -&gt; isize { 1 } }\nimpl RTypeUnit for u64 { fn zero() -&gt; u64 { 0 } fn one() -&gt; u64 { 1 } }\nimpl RTypeUnit for i64 { fn zero() -&gt; i64 { 0 } fn one() -&gt; i64 { 1 } }\nimpl RTypeUnit for u32 { fn zero() -&gt; u32 { 0 } fn one() -&gt; u32 { 1 } }\nimpl RTypeUnit for i32 { fn zero() -&gt; i32 { 0 } fn one() -&gt; i32 { 1 } }\nimpl RTypeUnit for u16 { fn zero() -&gt; u16 { 0 } fn one() -&gt; u16 { 1 } }\nimpl RTypeUnit for i16 { fn zero() -&gt; i16 { 0 } fn one() -&gt; i16 { 1 } }\nimpl RTypeUnit for u8 { fn zero() -&gt; u8 { 0 } fn one() -&gt; u8 { 1 } }\nimpl RTypeUnit for i8 { fn zero() -&gt; i8 { 0 } fn one() -&gt; i8 { 1 } }\n</code></pre>\n\n<p>What's an idiomatic way to avoid writing out functions for each type? Should I use default implementations, or maybe macros?</p>\n\n<p>I am aware of the <code>num</code> crate for these specific methods, but I'm interested to know how to do this in the general case.</p>\n"}, {"tags": ["pointers", "data-structures", "tree", "rust", "binary-tree"], "answers": [{"comments": [{"owner": {"reputation": 877, "user_id": 3666903, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/1i0Z6.jpg?s=128&g=1", "display_name": "bl4ckb0ne", "link": "https://stackoverflow.com/users/3666903/bl4ckb0ne"}, "edited": false, "score": 0, "creation_date": 1477328853, "post_id": 40210704, "comment_id": 67711077, "body": "I found an answer (see the post below), but thanks for your help"}], "tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 7, "last_activity_date": 1477330165, "last_edit_date": 1477330165, "creation_date": 1477283433, "answer_id": 40210704, "question_id": 40210631, "link": "https://stackoverflow.com/questions/40210631/type-name-t-undefined-when-creating-a-mutable-binary-tree/40210704#40210704", "title": "Type name T undefined when creating a mutable binary tree", "body": "<p>In this case, you have a basic syntax error, it should be</p>\n\n<pre><code>impl&lt;T&gt; Tree&lt;T&gt;\n</code></pre>\n\n<p>From there, you'll see that you need <code>if self.root.is_null()</code>.</p>\n\n<p>Then, the data structure needs lifetime specifiers, since you are using references. Using the most straightforward of that syntax eventually leads to</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0309]: the parameter type `T` may not live long enough\n</code></pre>\n\n<p>So you use <code>T: 'a</code> there... and you end up with:</p>\n\n<pre><code>use std::ptr;\n\nstruct Node&lt;'a, T: 'a&gt; {\n    data: T,\n    left: &amp;'a Node&lt;'a, T&gt;,\n    right: &amp;'a Node&lt;'a, T&gt;,\n    parent: &amp;'a Node&lt;'a, T&gt;,\n}\n\nstruct Tree&lt;'a, T: 'a&gt; {\n    root: &amp;'a Node&lt;'a, T&gt;,\n}\n\nimpl&lt;'a, T&gt; Tree&lt;'a, T&gt; {\n    pub fn new() -&gt; Tree&lt;'a, T&gt; {\n        Tree { root: ptr::null() }\n    }\n\n    pub fn insert(&amp;self, value: T) {\n        if self.root.is_null() {\n            self.root = Node {\n                data: value,\n                left: ptr::null(),\n                right: ptr::null(),\n                parent: ptr::null(),\n            };\n        }\n    }\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n</code></pre>\n\n<p>This gives another error</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>21 |             root: ptr::null(),\n   |                   ^^^^^^^^^^^ expected reference, found *-ptr\n</code></pre>\n\n<p>This is because <code>ptr::null()</code> returns raw pointers, but you've declared that your data structure uses references.</p>\n\n<p>Okay, that's as far as I'm going to go. Let's go back to your question...</p>\n\n<blockquote>\n  <p>I am new to Rust, and for an exercise, I am building a simple generic binary tree.</p>\n</blockquote>\n\n<p>I would suggest that you should consider something <em>other</em> than writing a data structure. They're not simple in Rust. If you still want to do this approach, may I recommend <a href=\"http://cglab.ca/~abeinges/blah/too-many-lists/book/\" rel=\"nofollow\">Too Many Lists</a>.</p>\n"}, {"comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 2, "creation_date": 1477331402, "post_id": 40223797, "comment_id": 67712433, "body": "<code>Box</code> is a pointer that owns the thing it points to. A node owning the children sound good, but a node can&#39;t own its parent. The parent pointer is what makes your data structure graphlike, it has a referential cycle, and neither Box nor Rust&#39;s regular references can deal with this. It is relatively straightforward to use a raw pointer for the parent pointer."}], "tags": [], "owner": {"reputation": 877, "user_id": 3666903, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/1i0Z6.jpg?s=128&g=1", "display_name": "bl4ckb0ne", "link": "https://stackoverflow.com/users/3666903/bl4ckb0ne"}, "is_accepted": false, "score": 0, "last_activity_date": 1477329386, "last_edit_date": 1477329386, "creation_date": 1477328826, "answer_id": 40223797, "question_id": 40210631, "link": "https://stackoverflow.com/questions/40210631/type-name-t-undefined-when-creating-a-mutable-binary-tree/40223797#40223797", "title": "Type name T undefined when creating a mutable binary tree", "body": "<p>I finally found a way to do it. I used <code>std::optional</code> instead of <code>std::ptr</code> for the node struct, and it works like a C pointer.</p>\n\n<pre><code>struct Node&lt;T&gt; {\n    id: u32,\n    data: T,\n    left: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n    right: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n    parent: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\n\nstruct Tree&lt;T&gt; {\n    root: Option&lt;Node&lt;T&gt;&gt;,\n}\n\nimpl&lt;T&gt; Node&lt;T&gt; {\n    pub fn new(value: Option&lt;T&gt;,\n               left: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n               right: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n               parent: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;)\n               -&gt; Node&lt;T&gt; {\n        Node {\n            data: value.unwrap(),\n            left: left,\n            right: right,\n            parent: parent,\n        }\n    }\n}\n\nimpl&lt;T&gt; Tree&lt;T&gt; {\n    pub fn new() -&gt; Tree&lt;T&gt; {\n        Tree { root: None }\n    }\n\n    pub fn insert(&amp;mut self, value: T) {\n        match self.root {\n            Some(ref n) =&gt; {\n                println!(\"Root is not empty\");\n            }\n            None =&gt; {\n                println!(\"Root is empty\");\n                self.root = Some(Node::new(Some(value), None, None, None));\n            }\n        }\n    }\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n\n    let mut tree: Tree&lt;i32&gt; = Tree::new();\n    tree.insert(42);\n}\n</code></pre>\n"}], "owner": {"reputation": 877, "user_id": 3666903, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/1i0Z6.jpg?s=128&g=1", "display_name": "bl4ckb0ne", "link": "https://stackoverflow.com/users/3666903/bl4ckb0ne"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 250, "favorite_count": 0, "answer_count": 2, "score": -1, "last_activity_date": 1477330165, "creation_date": 1477282732, "last_edit_date": 1477312225, "question_id": 40210631, "link": "https://stackoverflow.com/questions/40210631/type-name-t-undefined-when-creating-a-mutable-binary-tree", "title": "Type name T undefined when creating a mutable binary tree", "body": "<p>I am new to Rust, and for an exercise, I am building a simple generic binary tree. This is how I'd create one in C++</p>\n\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt;typename T&gt;\nstruct Node\n{\n    T data;\n    Node&lt;T&gt;* parent;\n    Node&lt;T&gt;* left;\n    Node&lt;T&gt;* right;\n};\n\ntemplate&lt;typename T&gt;\nstruct Bintree\n{\n    Node&lt;T&gt;* root;  \n};\n</code></pre>\n\n<p>But the same(ish) code in Rust doesn't seem to work:</p>\n\n<pre><code>use std::ptr;\n\nstruct Node&lt;T&gt; {\n    data: T,\n    left: &amp;Node&lt;T&gt;,\n    right: &amp;Node&lt;T&gt;,\n    parent: &amp;Node&lt;T&gt;,\n}\n\nstruct Tree&lt;T&gt; {\n    root: &amp;Node&lt;T&gt;,\n}\n\nimpl Tree&lt;T&gt; {\n    pub fn new() -&gt; Tree&lt;T&gt; {\n        Tree { root: ptr::null() }\n    }\n\n    pub fn insert(&amp;self, value: T) {\n        if root.is_null() {\n            self.root = Node {\n                data: value,\n                left: ptr::null(),\n                right: ptr::null(),\n                parent: ptr::null(),\n            };\n        }\n    }\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n</code></pre>\n\n<p>And here's the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0412]: type name `T` is undefined or not in scope\n  --&gt; src/main.rs:14:15\n   |\n14 |     impl Tree&lt;T&gt; {\n   |               ^ undefined or not in scope\n   |\n   = help: no candidates by the name of `T` found in your project; maybe you misspelled the name or forgot to import an external crate?\n\nerror[E0412]: type name `T` is undefined or not in scope\n  --&gt; src/main.rs:15:30\n   |\n15 |         pub fn new() -&gt; Tree&lt;T&gt; {\n   |                              ^ undefined or not in scope\n   |\n   = help: no candidates by the name of `T` found in your project; maybe you misspelled the name or forgot to import an external crate?\n\nerror[E0412]: type name `T` is undefined or not in scope\n  --&gt; src/main.rs:19:37\n   |\n19 |         pub fn insert(&amp;self, value: T) {\n   |                                     ^ undefined or not in scope\n   |\n   = help: no candidates by the name of `T` found in your project; maybe you misspelled the name or forgot to import an external crate?\n\nerror[E0425]: unresolved name `root`. Did you mean `self.root`?\n  --&gt; src/main.rs:20:16\n   |\n20 |             if root.is_null() {\n   |                ^^^^\n\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:5:15\n  |\n5 |         left: &amp;Node&lt;T&gt;,\n  |               ^ expected lifetime parameter\n\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:6:16\n  |\n6 |         right: &amp;Node&lt;T&gt;,\n  |                ^ expected lifetime parameter\n\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:7:17\n  |\n7 |         parent: &amp;Node&lt;T&gt;,\n  |                 ^ expected lifetime parameter\n\nerror[E0106]: missing lifetime specifier\n  --&gt; src/main.rs:11:15\n   |\n11 |         root: &amp;Node&lt;T&gt;,\n   |               ^ expected lifetime parameter\n</code></pre>\n\n<p>I don't really understand what's wrong with that. I don't really get how Rust's pointers work. </p>\n"}, {"tags": ["dictionary", "rust"], "answers": [{"comments": [{"owner": {"reputation": 171, "user_id": 3614352, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d66be3e50da03736e4af8f902511239d?s=128&d=identicon&r=PG&f=1", "display_name": "mfarrugi", "link": "https://stackoverflow.com/users/3614352/mfarrugi"}, "edited": false, "score": 0, "creation_date": 1477274478, "post_id": 40209605, "comment_id": 67683777, "body": "Thanks!   Is it at all a new development that you can borrow fields separately?"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 171, "user_id": 3614352, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d66be3e50da03736e4af8f902511239d?s=128&d=identicon&r=PG&f=1", "display_name": "mfarrugi", "link": "https://stackoverflow.com/users/3614352/mfarrugi"}, "edited": false, "score": 1, "creation_date": 1477276420, "post_id": 40209605, "comment_id": 67684171, "body": "No, I think it&#39;s been possible for a long time."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 6, "last_activity_date": 1477273002, "creation_date": 1477273002, "answer_id": 40209605, "question_id": 40209552, "link": "https://stackoverflow.com/questions/40209552/how-to-work-around-self-borrowing-with-map-or-insert-with-rust-1-11/40209605#40209605", "title": "How to work around self borrowing with map .or_insert_with? Rust (1.11)", "body": "<p>The problem is that the closure captures <code>self</code>, whereas it only needs to capture a mutable reference to the <code>last_id</code> field.</p>\n\n<p>Rust allows us to take independent mutable borrows on distinct fields, so we can use that to our advantage and pass a mutable reference to the <code>last_id</code> field to the closure.</p>\n\n<pre><code>use std::collections::HashMap;\n\nstruct Foo {\n    local_ids: HashMap&lt;i32, i32&gt;,\n    last_id: i32,\n}\n\nimpl Foo {\n    fn foo(&amp;mut self, external_id: i32) {\n        let last_id = &amp;mut self.last_id;\n        let id = self.local_ids\n                     .entry(external_id)\n                     .or_insert_with(|| { *last_id += 1; *last_id });\n    }\n}\n</code></pre>\n\n<p>When we use the expression <code>self.last_id</code> in the closure, the closure captures <code>self</code> directly, but Rust doesn't realize that the borrows are independent, so we need to be more explicit.</p>\n"}], "owner": {"reputation": 171, "user_id": 3614352, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d66be3e50da03736e4af8f902511239d?s=128&d=identicon&r=PG&f=1", "display_name": "mfarrugi", "link": "https://stackoverflow.com/users/3614352/mfarrugi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1002, "favorite_count": 0, "closed_date": 1518248535, "accepted_answer_id": 40209605, "answer_count": 1, "score": 5, "last_activity_date": 1477273367, "creation_date": 1477272475, "last_edit_date": 1495535248, "question_id": 40209552, "link": "https://stackoverflow.com/questions/40209552/how-to-work-around-self-borrowing-with-map-or-insert-with-rust-1-11", "closed_reason": "Duplicate", "title": "How to work around self borrowing with map .or_insert_with? Rust (1.11)", "body": "<p>This snippet </p>\n\n<pre><code>use std::collections::HashMap;\n\nstruct Foo {\n    local_ids: HashMap&lt;i32, i32&gt;,\n    last_id: i32,\n}\n\nimpl Foo {\n    fn foo(&amp;mut self, external_id: i32) {\n        let id = self.local_ids\n                     .entry(external_id)\n                     .or_insert_with(||{self.last_id += 1; self.last_id});\n    }\n}\n</code></pre>\n\n<p>Doesn't work because we can't borrow self twice</p>\n\n<pre><code>error: closure requires unique access to `self` but `self.local_ids` is already borrowed [E0500]\n</code></pre>\n\n<p>Is this possible to fix without a second key lookup?</p>\n\n<hr>\n\n<p>This is very similar to <a href=\"https://stackoverflow.com/questions/24287434/rust-hashmap-borrow-issue-when-trying-to-implement-find-or-insert\">Rust: HashMap borrow issue when trying to implement find or insert</a>, but the API has changed substantially.</p>\n\n<p>The find_with_or_insert_with answer from above doesn't appear to map to the current api.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 19, "last_activity_date": 1532984407, "last_edit_date": 1532984407, "creation_date": 1477267791, "answer_id": 40209090, "question_id": 40208893, "link": "https://stackoverflow.com/questions/40208893/why-did-rust-go-with-match-instead-of-switch-or-case/40209090#40209090", "title": "Why did Rust go with &quot;match&quot; instead of &quot;switch&quot; or &quot;case&quot;?", "body": "<p><a href=\"https://doc.rust-lang.org/reference/influences.html\" rel=\"noreferrer\">The Rust Reference cites</a> Standard ML (SML) and OCaml as an influence for pattern matching. In OCaml, <a href=\"http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora016.html\" rel=\"noreferrer\">pattern matching uses the <code>match</code> keyword</a>.</p>\n\n<p><a href=\"https://news.ycombinator.com/item?id=6932601\" rel=\"noreferrer\">The original Rust compiler was written in OCaml</a>, so it makes sense that OCaml would have had a stronger influence on Rust than, say, Haskell.</p>\n"}], "owner": {"reputation": 8297, "user_id": 298847, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/b52bc71fb15db17f585b912aed45b217?s=128&d=identicon&r=PG", "display_name": "tibbe", "link": "https://stackoverflow.com/users/298847/tibbe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2303, "favorite_count": 0, "accepted_answer_id": 40209090, "answer_count": 1, "score": 15, "last_activity_date": 1532984407, "creation_date": 1477265844, "question_id": 40208893, "link": "https://stackoverflow.com/questions/40208893/why-did-rust-go-with-match-instead-of-switch-or-case", "title": "Why did Rust go with &quot;match&quot; instead of &quot;switch&quot; or &quot;case&quot;?", "body": "<p>I'm curious about the history of this. I would assume <code>switch</code> would appeal to C/C++/Java/etc programmers and thus be a natural choice. If one wanted to avoid confusion in semantics (since <code>match</code> is more powerful than <code>switch</code>) I'd assume one would borrow <code>case</code> from Haskell instead.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1477232187, "post_id": 40203761, "comment_id": 67672370, "body": "Any implementation of this in the standard library would be almost guaranteed to use <code>unsafe</code>; why are you so hesitant to use it yourself? Also, is there truly a difference between code which cannot panic and code that has a <code>panic!</code> call but which may <b>never</b> be executed?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1477235015, "post_id": 40203761, "comment_id": 67673208, "body": "@Shepmaster: Regarding <code>panic!</code>: there is a difference between statically knowing that no <code>panic!</code> can occur and dynamically hoping (with a test suite) that <code>panic!</code> should never occur. Notably, in the former case, there is a guarantee that code generation will not call the panic hooks (even if the tests were flaky). Regarding <code>unsafe</code>, this is indeed what I use at the moment, however I would prefer relying on the standard library for this assuming (perhaps innocently) that it is better tested and has been more thoroughly audited than my own code."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477235067, "post_id": 40203761, "comment_id": 67673227, "body": "@Shepmaster: I would also note that the presence of <code>split_first</code> and <code>split_last</code>, which return <code>Option</code> had me quite hopeful that <code>split_at</code> would follow in their track. I am surprised at the discrepancy of interface here."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1477249298, "post_id": 40203761, "comment_id": 67677760, "body": "Someone has to write the code that is trusted (to use <code>unsafe</code> correctly) and it appears it&#39;s not yet in Rust&#39;s libstd."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1477325978, "post_id": 40203761, "comment_id": 67709564, "body": "@bluss: Certainly. To be honest I was surprised that <code>slice_at</code> did not return <code>Option&lt;(&amp;[T], &amp;[T])&gt;</code> in keeping with <code>split_first</code> and <code>split_last</code> interfaces."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477326145, "post_id": 40206905, "comment_id": 67709659, "body": "Nice. Do you know if <code>nth</code> could be optimized to ensure O(1)?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477330383, "post_id": 40206905, "comment_id": 67711876, "body": "On the case of panics, I just realized that we are using integer arithmetic which may panic when overflow checking is on. The <code>slice.len() - range.end</code> needs be rewritten with <code>wrapping_sub</code>. I could really benefit from a <code>no_panic</code> lint."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477330964, "post_id": 40206905, "comment_id": 67712179, "body": "Removing all the panic cases with that methodology means writing code that is silent on error though; that&#39;s not better: it is worse. <code>get_slice</code> is much better than that, especially if it would come from libstd."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477332873, "post_id": 40206905, "comment_id": 67713176, "body": "In this specific condition I would expect <code>wrapping_sub</code> to be correct since we already asserted (above) that <code>range.end &lt;= slice.len()</code>. It&#39;s a panic that is already unreachable dynamically."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477386403, "post_id": 40206905, "comment_id": 67733780, "body": "That&#39;s exactly how <code>get_slice</code> works. It uses bounds checked indexing, but it is unreachable dynamically. (And &quot;statically&quot;, since the compiler removed the panic cases from the optimized code)."}], "tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": false, "score": 6, "last_activity_date": 1477250815, "last_edit_date": 1477250815, "creation_date": 1477250510, "answer_id": 40206905, "question_id": 40203761, "link": "https://stackoverflow.com/questions/40203761/how-to-get-subslices-with-neither-panicking-nor-unsafe/40206905#40206905", "title": "How to get subslices with neither panicking nor unsafe?", "body": "<p>I'll start with the version that I prefer. It is <code>get_slice</code>, it uses bounds checked slicing, and you can look at the compiler's optimized output to verify that the compiler knows it will never panic. (<strong>1.</strong> I agree, \u201cno panic\u201d would be a terrific thing to be able to work with as an assertion; <strong>2</strong>. get_slice would be a nice addition to libstd and indeed is planned.)</p>\n\n<pre><code>/// Return the subslice corresponding to `range`, if it is in bounds\n/// and well formed (start &lt;= end).\npub fn get_slice(slice: &amp;[u8], range: Range&lt;usize&gt;) -&gt; Option&lt;&amp;[u8]&gt; {\n    if range.start &gt; range.end || range.end &gt; slice.len() {\n        None\n    } else {\n        Some(&amp;slice[range])\n    }\n}\n</code></pre>\n\n<p>Next is an attempted solution, that is still coded with what appears to be an <em>O(N)</em> algorithm, but is strength reduced to <em>O(1)</em> by the optimizer.</p>\n\n<p>We use the slice iterator and the fact that we can convert it back to a slice. The slice iterator's <code>.nth()</code> is open coded to jump forward in constant time, but the reverse version is unfortunately not. However its loop is optimized out.</p>\n\n<pre><code>pub fn sub(slice: &amp;[u8], range: Range&lt;usize&gt;) -&gt; Option&lt;&amp;[u8]&gt; {\n    if range.start &gt; range.end || range.end &gt; slice.len() {\n        return None;\n    }\n\n    let mut iter = slice.iter();\n    let take_front = range.start; \n    let take_back = slice.len() - range.end; \n    if take_front &gt; 0 {\n        iter.nth(take_front - 1);\n    }\n    if take_back &gt; 0 {\n        (&amp;mut iter).rev().nth(take_back - 1);\n    }\n    Some(iter.as_slice())\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=3152826696293a76514f6e73d151ab01&amp;version=nightly&amp;backtrace=1\">playground link</a></p>\n\n<p>Note: I unfortunately think we are making a bit of arbitrary rules here. We could use <code>.chunks()</code> after the take front operation, and it would give you a direct <em>O(1)</em> solution. However, chunks may panic if you ask for 0-size chunks. That puts it in the same bracket at just using bounds checked slicing for me (\u201cit may panic\u201d).</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1559716554, "post_id": 56454140, "comment_id": 99502868, "body": "Welcome to stackoverflow, and very nice answer. I&#39;m glad to see my wishes came true!"}], "tags": [], "owner": {"reputation": 56, "user_id": 7683050, "user_type": "registered", "profile_image": "https://lh5.googleusercontent.com/-d54uEYWKNrg/AAAAAAAAAAI/AAAAAAAADpc/NpQBdseOc_c/photo.jpg?sz=128", "display_name": "Benpigchu", "link": "https://stackoverflow.com/users/7683050/benpigchu"}, "is_accepted": true, "score": 4, "last_activity_date": 1559707677, "creation_date": 1559707677, "answer_id": 56454140, "question_id": 40203761, "link": "https://stackoverflow.com/questions/40203761/how-to-get-subslices-with-neither-panicking-nor-unsafe/56454140#56454140", "title": "How to get subslices with neither panicking nor unsafe?", "body": "<p>Now you can just use the <code>get</code> method on the slice.</p>\n\n<p>I copied the code below from <a href=\"https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get\" rel=\"nofollow noreferrer\">The document of that method</a>.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let v = [10, 40, 30];\nassert_eq!(Some(&amp;40), v.get(1));\nassert_eq!(Some(&amp;[10, 40][..]), v.get(0..2));\nassert_eq!(None, v.get(3));\nassert_eq!(None, v.get(0..4));\n</code></pre>\n"}], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 544, "favorite_count": 1, "accepted_answer_id": 56454140, "answer_count": 2, "score": 9, "last_activity_date": 1559707677, "creation_date": 1477231353, "last_edit_date": 1495541232, "question_id": 40203761, "link": "https://stackoverflow.com/questions/40203761/how-to-get-subslices-with-neither-panicking-nor-unsafe", "title": "How to get subslices with neither panicking nor unsafe?", "body": "<p><em>Note: <a href=\"https://stackoverflow.com/questions/30272673/how-to-get-subslices\">How to get subslices</a> is close, but without either constraint.</em></p>\n\n<p>I am looking for the best implementation possible of a function with this signature:</p>\n\n<pre><code>fn sub(slice: &amp;[u8], range: Range&lt;usize&gt;) -&gt; Option&lt;&amp;[u8]&gt;;\n</code></pre>\n\n<p>which would have the same functionality as the <code>impl Index&lt;Range&lt;usize&gt;&gt;</code> but replacing the failure case with <code>None</code> instead of panicking.</p>\n\n<p>The twists are the seemingly unusual constraints that this function should not:</p>\n\n<ul>\n<li>invoke functions that may <code>panic</code></li>\n<li>use <code>unsafe</code> code</li>\n</ul>\n\n<p>A careful investigation of the <a href=\"https://doc.rust-lang.org/std/primitive.slice.html\" rel=\"nofollow noreferrer\"><code>slice</code></a> interface has brought to my attention:</p>\n\n<ul>\n<li><a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.split_first\" rel=\"nofollow noreferrer\"><code>split_first</code></a> and <a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.split_last\" rel=\"nofollow noreferrer\"><code>split_last</code></a></li>\n<li><a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.split_at\" rel=\"nofollow noreferrer\"><code>split_at</code></a></li>\n<li><code>impl Index&lt;Range&lt;usize&gt;&gt;</code> (and variants)</li>\n<li><a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr\" rel=\"nofollow noreferrer\"><code>as_ptr</code></a> and <a href=\"https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html\" rel=\"nofollow noreferrer\"><code>from_raw_parts</code></a></li>\n</ul>\n\n<p>However most are not suitable:</p>\n\n<ul>\n<li><code>split_at</code> and <code>Index&lt;Range&lt;usize&gt;&gt;::index</code> may panic</li>\n<li><code>from_raw_parts</code> is <code>unsafe</code></li>\n</ul>\n\n<p>Leaving me to implement <code>sub</code> as:</p>\n\n<pre><code>fn sub(slice: &amp;[u8], range: Range&lt;usize&gt;) -&gt; Option&lt;&amp;[u8]&gt; {\n    if range.start &gt; range.end { return None; }\n\n    let length = range.end - range.start;\n\n    if length &gt; slice.len() { return None; }\n\n    if length == 0 { return Some(b\"\"); }\n\n    let mut slice = slice;\n    for _ in 0..range.start {\n        if let Some((_, s)) = slice.split_first() {\n            slice = s;\n        }\n    }\n\n    for _ in 0..(slice.len() - length) {\n        if let Some((_, s)) = slice.split_last() {\n            slice = s;\n        }\n    }\n\n    Some(slice)\n}\n</code></pre>\n\n<p>which while seemingly working has O(N) complexity; rather unsatisfying.</p>\n\n<p>Is there any way to do better?</p>\n"}, {"tags": ["reference", "rust", "language-lawyer"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 5, "last_activity_date": 1477313620, "last_edit_date": 1477313620, "creation_date": 1477276048, "answer_id": 40209896, "question_id": 40203559, "link": "https://stackoverflow.com/questions/40203559/are-rust-references-usually-voldemort-types/40209896#40209896", "title": "Are Rust references (usually) Voldemort types?", "body": "<p>As someone without any particularly strong knowledge in the area:</p>\n\n<p>I think the answer is probably: <em>technically yes, but it's overly reductive</em>. A bit like saying \"all types are arrays of integers\"; I mean, <em>yes</em>, but you're losing some useful semantic discrimination by doing that.</p>\n\n<p>Voldemort types are <em>usually</em> to hide the implementation type from the user, either because it's only supposed to be a temporary, or you're not supposed to use anything but the interface described by the function. References are <em>technically</em> unnameable in their entirety, but it's not like it ever <em>actually</em> restricts you. I mean, even if you <em>could</em> name the specific lifetime, I don't think you could do anything meaningful with it (except possibly for <em>slightly</em> stricter lifetime checking within a function).</p>\n"}, {"tags": [], "owner": {"reputation": 4036, "user_id": 667457, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/33f9a9233b25c8230f5b5edb38493842?s=128&d=identicon&r=PG", "display_name": "Jeff Burdges", "link": "https://stackoverflow.com/users/667457/jeff-burdges"}, "is_accepted": false, "score": 0, "last_activity_date": 1533452447, "creation_date": 1533452447, "answer_id": 51692134, "question_id": 40203559, "link": "https://stackoverflow.com/questions/40203559/are-rust-references-usually-voldemort-types/51692134#51692134", "title": "Are Rust references (usually) Voldemort types?", "body": "<p>Arguably no.  Are the types of references and pointers in all languages considered Voldemort types?  They hide <em>something</em>, but no.</p>\n\n<p>We envision lifetimes as being regions of code outside the called function.  Also, they're created roughly like that in rustc.  Yet, I'd argue function signatures are the type definition of the lifetimes we actually see.  And rustc is merely satisfying them.  There is nothing more to the named lifetimes than what you see in the function definition.</p>\n"}], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 376, "favorite_count": 1, "accepted_answer_id": 40209896, "answer_count": 2, "score": 7, "last_activity_date": 1533452447, "creation_date": 1477229989, "last_edit_date": 1504446946, "question_id": 40203559, "link": "https://stackoverflow.com/questions/40203559/are-rust-references-usually-voldemort-types", "title": "Are Rust references (usually) Voldemort types?", "body": "<p><a href=\"https://wiki.dlang.org/Voldemort_types\">Voldemort \u2013 <em>he who must not be named</em> \u2013 types</a> are types whose names are impossible to write down in the source code. In Rust, closures have such types, because the compiler <a href=\"https://doc.rust-lang.org/book/closures.html#closure-implementation\">generates a new internal type for each closure</a>. The only way to accept a closure as function argument is to accept a generic type (usually called <code>F</code>) which is bounded to be an <code>Fn()</code> (or similar) trait.</p>\n\n<p>References in Rust always contain a lifetime parameter, even if this lifetime can usually be omitted. Lifetimes can't be named explicitly, because they represent some complex compiler-internal scope of some kind. The only way to interact with lifetimes is to use a generic parameter (usually called <code>'a</code>) which stands for any lifetime (maybe bounded by another lifetime). Of course, there is <code>'static</code> which <em>can</em> be named, but this is a special case and doesn't conflict with my arguing. </p>\n\n<p><strong>So: are Rust references Voldemort types?</strong> Or do I misunderstand the term \u201cVoldemort type\u201d or Rust references?</p>\n"}, {"tags": ["polymorphism", "rust"], "comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 0, "creation_date": 1477227997, "post_id": 40203073, "comment_id": 67671050, "body": "Was <code>let b: Box&lt;Total&gt;</code> what you meant?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477228089, "post_id": 40203073, "comment_id": 67671078, "body": "I&#39;ve removed <a href=\"http://meta.stackexchange.com/q/39223/281829\">the second and apparently less important question</a>."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 6, "last_activity_date": 1477228618, "last_edit_date": 1477228618, "creation_date": 1477227985, "answer_id": 40203269, "question_id": 40203073, "link": "https://stackoverflow.com/questions/40203073/why-does-boxtrait-have-a-different-size-than-boxstruct/40203269#40203269", "title": "Why does Box&lt;trait&gt; have a different size than Box&lt;struct&gt;?", "body": "<p>A <a href=\"https://doc.rust-lang.org/stable/book/trait-objects.html\"><em>trait object</em></a>, such as <code>Box&lt;Trait&gt;</code> or <code>&amp;Trait</code>, <a href=\"https://doc.rust-lang.org/std/raw/struct.TraitObject.html\">contains two pointers</a>:</p>\n\n<ul>\n<li>A pointer to the data</li>\n<li>A pointer to the <em>vtable</em></li>\n</ul>\n\n<p>Two pointers (on 64-bit machines) adds up to 128 bits.</p>\n\n<p>A <code>Box&lt;Struct&gt;</code> only contains a single pointer, directly to the data. No vtable is needed because the specific methods are able to be resolved statically at compile time. This single pointer is only 64 bits.</p>\n\n<blockquote>\n  <p>Given that <code>Box&lt;Total&gt;</code> is really a <code>Box&lt;S&gt;</code></p>\n</blockquote>\n\n<p>They are not. If they <em>were</em> the same, why would they have different names? :-)</p>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 9, "last_activity_date": 1477228021, "creation_date": 1477228021, "answer_id": 40203273, "question_id": 40203073, "link": "https://stackoverflow.com/questions/40203073/why-does-boxtrait-have-a-different-size-than-boxstruct/40203273#40203273", "title": "Why does Box&lt;trait&gt; have a different size than Box&lt;struct&gt;?", "body": "<p>Unlike most languages featuring OO-concepts which embed virtual pointers in <code>class</code>, Rust uses the fat-pointer approach in which it carries both the virtual pointer and <code>struct</code> pointer alongside each other.</p>\n\n<p>As a result, the layout of <code>Box&lt;Trait&gt;</code> for a <code>S</code> is:</p>\n\n<pre><code>+-------+-------+\n| v-ptr | S-ptr |\n+-------+-------+\n</code></pre>\n\n<p>which is 128-bits on a 64-bits platform.</p>\n\n<hr>\n\n<p>As for downcasting, at the moment you can use the <a href=\"https://doc.rust-lang.org/beta/std/any/trait.Any.html\" rel=\"noreferrer\"><code>Any</code></a> type and its <code>downcast_ref</code> and <code>downcast_mut</code>.</p>\n\n<p>You may also be interested in the <a href=\"https://docs.rs/query_interface/0.3.3/query_interface/\" rel=\"noreferrer\">query_interface</a> crate for more elaborate use cases.</p>\n"}], "owner": {"reputation": 24802, "user_id": 232918, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5897762377de1c8ffb9a98673262e91?s=128&d=identicon&r=PG", "display_name": "doron", "link": "https://stackoverflow.com/users/232918/doron"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 117, "favorite_count": 0, "accepted_answer_id": 40203273, "answer_count": 2, "score": 7, "last_activity_date": 1477228652, "creation_date": 1477226878, "last_edit_date": 1477228652, "question_id": 40203073, "link": "https://stackoverflow.com/questions/40203073/why-does-boxtrait-have-a-different-size-than-boxstruct", "title": "Why does Box&lt;trait&gt; have a different size than Box&lt;struct&gt;?", "body": "<p>Consider the code:</p>\n\n<pre><code>use std::boxed::Box;\nuse std::mem::transmute;\n\ntrait Total {\n    fn total(&amp;self) -&gt; i32;\n}\n\n#[derive(Debug)]\nstruct S {\n    a: i32,\n    b: i32,\n    c: i32,\n}\n\nimpl S {\n    fn new() -&gt; S {\n        S { a: 2, b: 3, c: 4 }\n    }\n}\n\nimpl Total for S {\n    fn total(&amp;self) -&gt; i32 {\n        self.a + self.b + self.c\n    }\n}\n\nfn main() {\n    let b: Box&lt;Total&gt; = Box::new(S::new());\n    unsafe {\n        let s: Box&lt;S&gt; = std::mem::transmute(b);\n        println!(\"S = {:?}\", s);\n    }\n}\n</code></pre>\n\n<p>This gives the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0512]: transmute called with differently sized types: Box&lt;Total&gt; (128 bits) to Box&lt;S&gt; (64 bits)\n  --&gt; src/main.rs:30:29\n   |\n30 |             let s: Box&lt;S&gt; = std::mem::transmute(b);\n   |                             ^^^^^^^^^^^^^^^^^^^\n</code></pre>\n\n<p>Given that <code>Box&lt;Total&gt;</code> <em>is</em> really a <code>Box&lt;S&gt;</code>, why do we get this error?</p>\n"}, {"tags": ["rust", "immutability", "traits"], "answers": [{"comments": [{"owner": {"reputation": 9369, "user_id": 71079, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/3e302415f77b6c398abc0b16efc653f3?s=128&d=identicon&r=PG", "display_name": "Ralph Caraveo", "link": "https://stackoverflow.com/users/71079/ralph-caraveo"}, "edited": false, "score": 1, "creation_date": 1477194768, "post_id": 40199326, "comment_id": 67664302, "body": "That is actually a spot-on crystal clear explanation. Thanks!"}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 30, "last_activity_date": 1477208196, "last_edit_date": 1477208196, "creation_date": 1477194644, "answer_id": 40199326, "question_id": 40199253, "link": "https://stackoverflow.com/questions/40199253/why-does-iocopy-require-the-reader-and-writer-to-both-be-mutable-references/40199326#40199326", "title": "Why does io::copy require the reader and writer to both be mutable references?", "body": "<p>Because <code>Read</code> types are, in general, one-shot: by reading from it, you <em>are</em> mutating it.</p>\n\n<p>Consider standard input: you can only read from that once, so <em>something</em> must be changing.  When you read from a socket, you're almost certainly mutating an internal buffer used to account for the differences between the network packets you get, and how much data you want to read at any given moment.  How about reading from a <code>Chain</code>, which is used to concatenate readable things together; without mutation, it can't keep track of which one it's supposed to be reading from.</p>\n\n<p>Sure, it's <em>possible</em> to have a <code>Read</code> type that doesn't need mutable access to perform a read, but that's not <em>universally</em> true, and because it's not universally true, the <code>Read</code> trait demands mutable access.</p>\n"}], "owner": {"reputation": 9369, "user_id": 71079, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/3e302415f77b6c398abc0b16efc653f3?s=128&d=identicon&r=PG", "display_name": "Ralph Caraveo", "link": "https://stackoverflow.com/users/71079/ralph-caraveo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 972, "favorite_count": 1, "accepted_answer_id": 40199326, "answer_count": 1, "score": 23, "last_activity_date": 1477229381, "creation_date": 1477193717, "last_edit_date": 1477229381, "question_id": 40199253, "link": "https://stackoverflow.com/questions/40199253/why-does-iocopy-require-the-reader-and-writer-to-both-be-mutable-references", "title": "Why does io::copy require the reader and writer to both be mutable references?", "body": "<p>Why does <a href=\"https://doc.rust-lang.org/std/io/fn.copy.html\"><code>std::io::copy</code></a> require that both the reader and writer arguments need to be passed as mutable references?</p>\n\n<p>I can understand why the writer needs to be mutated in order to accommodate data being written to it, changing its internal state.</p>\n\n<p>However, why must a reader also be flagged as a mutable reference? If I am only reading data, then wouldn't I just need a reference to a given type and not a mutable reference?</p>\n"}, {"tags": ["enums", "rust"], "comments": [{"owner": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "edited": false, "score": 0, "creation_date": 1477188616, "post_id": 40197188, "comment_id": 67663498, "body": "You can use <code>string.as_ref()</code> to get <code>&amp;str</code> from a <code>String</code> and then use it in a match. But what is the type of <code>args</code>? <code>to_string()</code> may be unnecessary if you already have <code>&amp;str</code>."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 1, "creation_date": 1477208599, "post_id": 40197188, "comment_id": 67666393, "body": "Please add the exact error message and a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>. Then you are more likely to get any answers :)"}, {"owner": {"reputation": 29, "user_id": 7056869, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d2dc8ead3774832a4b7b0c30ea2a6502?s=128&d=identicon&r=PG", "display_name": "David Brown", "link": "https://stackoverflow.com/users/7056869/david-brown"}, "reply_to_user": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "edited": false, "score": 0, "creation_date": 1477215951, "post_id": 40197188, "comment_id": 67667954, "body": "@Pavel Strakhov the type of args follows simple from Cargo:getopts as a Vec&lt;String&gt;. I missed the obvious option to <code>match args[2].as_str()</code> which appears to work!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1477228515, "post_id": 40197188, "comment_id": 67671192, "body": "I&#39;m seconding @LukasKalbertodt&#39;s point about an MCVE. For example, this question has <i>nothing</i> to do with an enum. I&#39;d bet that <a href=\"http://play.integer32.com/?gist=2707ee26ba9429582a72fbed55b7a9e5&amp;version=stable\" rel=\"nofollow noreferrer\">your code looks like this</a>."}], "answers": [{"tags": [], "owner": {"reputation": 29, "user_id": 7056869, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d2dc8ead3774832a4b7b0c30ea2a6502?s=128&d=identicon&r=PG", "display_name": "David Brown", "link": "https://stackoverflow.com/users/7056869/david-brown"}, "is_accepted": false, "score": 1, "last_activity_date": 1477216049, "creation_date": 1477216049, "answer_id": 40201572, "question_id": 40197188, "link": "https://stackoverflow.com/questions/40197188/how-to-limit-an-cli-argument-to-an-enum/40201572#40201572", "title": "How to limit an CLI argument to an enum?", "body": "<p>Noting the answer looks to be to <code>match args[2].as_str()</code>!</p>\n"}], "owner": {"reputation": 29, "user_id": 7056869, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d2dc8ead3774832a4b7b0c30ea2a6502?s=128&d=identicon&r=PG", "display_name": "David Brown", "link": "https://stackoverflow.com/users/7056869/david-brown"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 119, "favorite_count": 0, "closed_date": 1477229221, "answer_count": 1, "score": 1, "last_activity_date": 1477216049, "creation_date": 1477171250, "last_edit_date": 1477208520, "question_id": 40197188, "link": "https://stackoverflow.com/questions/40197188/how-to-limit-an-cli-argument-to-an-enum", "closed_reason": "Duplicate", "title": "How to limit an CLI argument to an enum?", "body": "<p>While learning Rust and in an attempt to do something useful, I'm looking to craft a <a href=\"https://api.safedev.org/dns/add-service.html\" rel=\"nofollow\">SAFE API call for DNS:Add service</a>.\nThe API is well defined and should by rights be a simple PUT request, the body of which is a number of strings and one variable that is limited to two options.</p>\n\n<p>I've looked to define a struct and enum for the body of the put with its real limits, rather than just using strings; as I expect defining close the reality, is better practice.</p>\n\n<p>I think I must be close but then have a mismatch, trying to limit input to an enum. The third argument should be only 'drive' or 'app' as <code>RootPathVariant</code>.</p>\n\n<p>So, I'm looking to assign the <code>root_path</code> with a match of <code>arguments=arg[2]</code>\nbut atm the left-side of the match is <code>&amp;'static str</code>, which is wrong where it wants a <code>String</code>.</p>\n\n<h1>enum is defined:</h1>\n\n<pre><code>pub enum RootPathVariant { App, Drive }\n\nimpl RootPathVariant {\n    pub fn as_str(&amp;self) -&gt; &amp;str {\n        match self {\n            &amp;RootPathVariant::App =&gt; \"app\",\n            &amp;RootPathVariant::Drive =&gt; \"drive\",\n        }\n    }\n}\n</code></pre>\n\n<h1>How should I put the left side of this match, to only accept content of that enum?</h1>\n\n<pre><code>let mut root_path: RootPathVariant = RootPathVariant::Drive;\nmatch args[2].to_string() {\n    \"drive\" =&gt; { root_path = RootPathVariant::Drive },\n    \"app\" =&gt; { root_path = RootPathVariant::App },\n    _ =&gt; { println!( \"Error: root_path not [drive | app]\");  return }\n};\n\nlet put_body = AddServiceBody {\n    long_Name: args[0],\n    service_Name: args[1],\n    root_Path: root_path,\n    service_Home_Dir_Path: args[3]\n};\n</code></pre>\n\n<p>Thanks for any help!</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "edited": false, "score": 0, "creation_date": 1477170348, "post_id": 40196586, "comment_id": 67659965, "body": "In this specific case, you could just get the length outside of the loop and pass it to the <code>update</code> method, but I&#39;m guessing that your actual problem is more complicated. In general, you probably need to keep the information needed for <code>update</code> in its own sub-struct of <code>Gamestate</code>, which would allow you to access that data while iterating over <code>entitites</code>. But it&#39;s hard to be more specific without the details."}], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 6, "last_activity_date": 1477171014, "creation_date": 1477171014, "answer_id": 40197144, "question_id": 40196586, "link": "https://stackoverflow.com/questions/40196586/mutable-reference-to-container-object-within-iterator-loop/40197144#40197144", "title": "Mutable reference to container object within iterator loop", "body": "<p>First, let's answer the question you didn't ask: <em>Why is this not allowed?</em></p>\n\n<p>The answer lies around the guarantees that Rust makes about <code>&amp;</code> and <code>&amp;mut</code> pointers. A <code>&amp;</code> pointer is guaranteed to point to an <em>immutable</em> object, i.e. it's impossible for the objects behind the pointer to mutate while you can use that pointer. A <code>&amp;mut</code> pointer is guaranteed to be the only active pointer to an object, i.e. you can be sure that nobody is going to observe or mutate the object while you're mutating it.</p>\n\n<p>Now, let's look at the signature of <code>Entity::update</code>:</p>\n\n<pre><code>impl Entity {\n    pub fn update(&amp;mut self, container: &amp;GameState) {\n        // ...\n    }\n}\n</code></pre>\n\n<p>This method takes two parameters: a <code>&amp;mut Entity</code> and a <code>&amp;GameState</code>. But hold on, we can get another reference to <code>self</code> through the <code>&amp;GameState</code>! For example, suppose that <code>self</code> is the first entity. If we do this:</p>\n\n<pre><code>impl Entity {\n    pub fn update(&amp;mut self, container: &amp;GameState) {\n        let self_again = &amp;container.entities[0];\n        // ...\n    }\n}\n</code></pre>\n\n<p>then <code>self</code> and <code>self_again</code> alias each other (i.e. they refer to the same thing), which is not allowed as per the rules I mentioned above because one of the pointers is a mutable pointer.</p>\n\n<p>What can you do about this?</p>\n\n<p>One option is to remove an entity from the entities vector before calling <code>update</code> on it, then inserting it back after the call. This solves the aliasing problem because we can't get another alias to the entity from the game state. However, removing the entity from the vector and reinserting it are operations with linear complexity (the vector needs to shift all the following items), and if you do it for each entity, then the main update loop runs in quadratic complexity. You can work around that by using a different data structure; this can be as simple as a <code>Vec&lt;Option&lt;Entity&gt;&gt;</code>, where you simply <a href=\"https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.take\" rel=\"noreferrer\"><code>take</code></a> the <code>Entity</code> from each <code>Option</code>, though you might want to wrap this into a type that hides all <code>None</code> values to external code. A nice consequence is that when an entity has to interact with other entities, it will automatically skip itself when iterating on the entities vector, since it's no longer there!</p>\n\n<p>A variation on the above is to simply take ownership of the whole vector of entities and temporarily replace the game state's vector of entities with an empty one.</p>\n\n<pre><code>impl GameState {\n    pub fn update(&amp;mut self) {\n        let mut entities = std::mem::replace(&amp;mut self.entities, vec![]);\n        for mut t in entities.iter_mut() {\n            t.update(self);\n        }\n        self.entities = entities;\n    }\n}\n</code></pre>\n\n<p>This has one major downside: <code>Entity::update</code> will not be able to interact with the other entities.</p>\n\n<p>Another option is to wrap each entity in a <a href=\"https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html\" rel=\"noreferrer\"><code>RefCell</code></a>.</p>\n\n<pre><code>use std::cell::RefCell;\n\npub struct GameState {\n    pub entities: Vec&lt;RefCell&lt;Entity&gt;&gt;,\n}\n\nimpl GameState {\n    pub fn update(&amp;mut self) {\n        for t in self.entities.iter() {\n            t.borrow_mut().update(self);\n        }\n    }\n}\n</code></pre>\n\n<p>By using <code>RefCell</code>, we can avoid retaining a mutable borrow on <code>self</code>. Here, we can use <code>iter</code> instead of <code>iter_mut</code> to iterate on <code>entities</code>. In return, we now need to call <code>borrow_mut</code> to obtain a mutable pointer to the value wrapped in the <code>RefCell</code>.</p>\n\n<p><code>RefCell</code> essentially performs borrow checking at runtime. This means that you can end up writing code that compiles fine but panics at runtime. For example, if we write <code>Entity::update</code> like this:</p>\n\n<pre><code>impl Entity {\n    pub fn update(&amp;mut self, container: &amp;GameState) {\n        for entity in container.entities.iter() {\n            self.value += entity.borrow().value;\n        }\n    }\n}\n</code></pre>\n\n<p>the program will panic:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>thread 'main' panicked at 'already mutably borrowed: BorrowError', ../src/libcore/result.rs:788\n</code></pre>\n\n<p>That's because we end up calling <code>borrow</code> on the entity that we're currently updating, which is still borrowed by the <code>borrow_mut</code> call done in <code>GameState::update</code>. <code>Entity::update</code> doesn't have enough information to know which entity is <code>self</code>, so you would have to use <a href=\"https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html#method.try_borrow\" rel=\"noreferrer\"><code>try_borrow</code></a> or <a href=\"https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html#method.borrow_state\" rel=\"noreferrer\"><code>borrow_state</code></a> (which are both unstable as of Rust 1.12.1) or pass additional data to <code>Entity::update</code> to avoid panics with this approach.</p>\n"}], "owner": {"reputation": 3902, "user_id": 420, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/16a095d9da1c92f4cc0b956a30a5da87?s=128&d=identicon&r=PG", "display_name": "Alex", "link": "https://stackoverflow.com/users/420/alex"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1087, "favorite_count": 0, "answer_count": 1, "score": 5, "last_activity_date": 1477171014, "creation_date": 1477167201, "question_id": 40196586, "link": "https://stackoverflow.com/questions/40196586/mutable-reference-to-container-object-within-iterator-loop", "title": "Mutable reference to container object within iterator loop", "body": "<p>I'm writing a game engine. In the engine, I've got a game state which contains the list of entities in the game.</p>\n\n<p>I want to provide a function on my gamestate <code>update</code> which will in turn tell each entity to update. Each entity needs to be able to refer to the gamestate in order to correctly update itself.</p>\n\n<p>Here's a simplified version of what I have so far.</p>\n\n<pre><code>pub struct GameState {\n    pub entities: Vec&lt;Entity&gt;,\n}\n\nimpl GameState {\n    pub fn update(&amp;mut self) {\n        for mut t in self.entities.iter_mut() {\n            t.update(self);\n        }\n    }\n}\n\npub struct Entity {\n    pub value: i64,\n}\n\nimpl Entity {\n    pub fn update(&amp;mut self, container: &amp;GameState) {\n        self.value += container.entities.len() as i64;\n    }\n}\n\nfn main() {\n    let mut c = GameState { entities: vec![] };\n\n    c.entities.push(Entity { value: 1 });\n    c.entities.push(Entity { value: 2 });\n    c.entities.push(Entity { value: 3 });\n\n    c.update();\n}\n</code></pre>\n\n<p>The problem is the borrow checker doesn't like me passing the gamestate to the entity:</p>\n\n<pre><code>error[E0502]: cannot borrow `*self` as immutable because `self.entities` is also borrowed as mutable\n --&gt; example.rs:8:22\n  |\n7 |         for mut t in self.entities.iter_mut() {\n  |                      ------------- mutable borrow occurs here\n8 |             t.update(self);\n  |                      ^^^^ immutable borrow occurs here\n9 |         }\n  |         - mutable borrow ends here\n\nerror: aborting due to previous error\n</code></pre>\n\n<p>Can anyone give me some suggestions on better ways to design this that fits with Rust better?</p>\n\n<p>Thanks!</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 1, "creation_date": 1477157373, "post_id": 40194949, "comment_id": 67655840, "body": "You&#39;re creating a single-element array of <code>Range&lt;i32&gt;</code> types (aka <code>[std::ops::Range&lt;i32&gt;; 1]</code>). You probably just mean <code>(0 .. n)</code>, which just changes operator precedence so that you&#39;re not invoking <code>sum()</code> on <code>n</code>. (<a href=\"https://play.rust-lang.org/?gist=b27932d99482f3ddd62697b62f1fe28c&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground Example</a>)"}], "answers": [{"comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 3, "creation_date": 1477160542, "post_id": 40195029, "comment_id": 67656866, "body": "As of Rust 1.11, the <code>Iterator</code> trait has a <code>sum</code> method and ranges are iterators, so no need to <code>fold</code>. Also, no mention of n&#215;(n+1)/2?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 2, "creation_date": 1477165042, "post_id": 40195029, "comment_id": 67658361, "body": "@mcarton: Let&#39;s presume that he is interested in learning how to iterate and not in the closed form :)"}, {"owner": {"reputation": 1371, "user_id": 623316, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/aa2761ad1bad1ee4f56dd5c3514dd765?s=128&d=identicon&r=PG", "display_name": "Jon Wolski", "link": "https://stackoverflow.com/users/623316/jon-wolski"}, "edited": false, "score": 0, "creation_date": 1477166581, "post_id": 40195029, "comment_id": 67658835, "body": "Thanks arjan, mcarton, and matthieu-m. Yes, I like the Guass-ian shortcut, and yes, I&#39;m really just trying to play with iterators, filters, and other FP things in Rust.   Too much context switching between Rust and Haskell, I had confused the syntax for Range literals."}, {"owner": {"reputation": 1371, "user_id": 623316, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/aa2761ad1bad1ee4f56dd5c3514dd765?s=128&d=identicon&r=PG", "display_name": "Jon Wolski", "link": "https://stackoverflow.com/users/623316/jon-wolski"}, "edited": false, "score": 1, "creation_date": 1477166822, "post_id": 40195029, "comment_id": 67658906, "body": "FWIW, on current stable Rust (release 1.9.0) I cannot use <code>sum</code> (<a href=\"https://github.com/rust-lang/rust/issues/27739\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/27739</a>)."}, {"owner": {"reputation": 14973, "user_id": 128186, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/46c330659979615fe50c46f5f553b39f?s=128&d=identicon&r=PG", "display_name": "Arjan", "link": "https://stackoverflow.com/users/128186/arjan"}, "reply_to_user": {"reputation": 1371, "user_id": 623316, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/aa2761ad1bad1ee4f56dd5c3514dd765?s=128&d=identicon&r=PG", "display_name": "Jon Wolski", "link": "https://stackoverflow.com/users/623316/jon-wolski"}, "edited": false, "score": 4, "creation_date": 1477167618, "post_id": 40195029, "comment_id": 67659156, "body": "@JonWolski Current stable is 1.12.1"}, {"owner": {"reputation": 1371, "user_id": 623316, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/aa2761ad1bad1ee4f56dd5c3514dd765?s=128&d=identicon&r=PG", "display_name": "Jon Wolski", "link": "https://stackoverflow.com/users/623316/jon-wolski"}, "edited": false, "score": 0, "creation_date": 1477256474, "post_id": 40195029, "comment_id": 67680017, "body": "Thanks, @Arjan. It turns out, I have my path misconfigured. <code>rustup</code> installed <code>1.12.1</code>, but I was still using a <code>1.9.0</code> from homebrew."}], "tags": [], "owner": {"reputation": 14973, "user_id": 128186, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/46c330659979615fe50c46f5f553b39f?s=128&d=identicon&r=PG", "display_name": "Arjan", "link": "https://stackoverflow.com/users/128186/arjan"}, "is_accepted": true, "score": 16, "last_activity_date": 1477344882, "last_edit_date": 1477344882, "creation_date": 1477157421, "answer_id": 40195029, "question_id": 40194949, "link": "https://stackoverflow.com/questions/40194949/how-can-i-sum-a-range-of-numbers-in-rust/40195029#40195029", "title": "How can I sum a range of numbers in Rust?", "body": "<p>The problem is that you are creating an array of ranges (square brackets) but you just wanted the range (on which fold is defined).</p>\n\n<p>Another thing is that range syntax (<code>..</code>) is only inclusive of the lower bound. It's exclusive of the upper bound so you have to iterate up to <code>n+1</code> to get the desired result.</p>\n\n<pre><code>mod squares {\n\n    pub fn sum_from_zero( n: i32) -&gt; i32 {\n        (0 .. n+1).fold(0, |a, b| a + b)\n    }\n}\n\n#[test]\nfn test_sum_from_zero() {\n    assert_eq!(15, squares::sum_from_zero(5));\n}\n</code></pre>\n"}], "owner": {"reputation": 1371, "user_id": 623316, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/aa2761ad1bad1ee4f56dd5c3514dd765?s=128&d=identicon&r=PG", "display_name": "Jon Wolski", "link": "https://stackoverflow.com/users/623316/jon-wolski"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5372, "favorite_count": 1, "accepted_answer_id": 40195029, "answer_count": 1, "score": 8, "last_activity_date": 1477344882, "creation_date": 1477156940, "question_id": 40194949, "link": "https://stackoverflow.com/questions/40194949/how-can-i-sum-a-range-of-numbers-in-rust", "title": "How can I sum a range of numbers in Rust?", "body": "<p>I want to write a function to sum the numbers from zero to n. (Ideally, this would be generic over all numbers, but I will settle for <code>i32</code>).</p>\n\n<pre><code>mod squares {\n\n    pub fn sum_from_zero( n: i32) -&gt; i32 {\n        [0 .. n].fold(0, |a, b| a + b)\n    }\n}\n\n#[test]\nfn test_sum_from_zero() {\n    assert_eq!(15, squares::sum_from_zero(5));\n}\n</code></pre>\n\n<p>I get the following compiler error:</p>\n\n<pre><code>src/lib.rs:5:18: 5:22 error: no method named `fold` found for type `[std::ops::Range&lt;i32&gt;; 1]` in the current scope\nsrc/lib.rs:5         [0 .. n].fold(0, |a, b| a + b)\n                              ^~~~\nsrc/lib.rs:5:18: 5:22 note: the method `fold` exists but the following trait bounds were not satisfied: `[std::ops::Range&lt;i32&gt;; 1] : std::iter::Iterator`, `[std::ops::Range&lt;i32&gt;] : std::iter::Iterator`\n</code></pre>\n\n<p>I've also tried this with <code>sum()</code>:</p>\n\n<pre><code>mod squares {\n\n    pub fn sum_from_zero( n: i32) -&gt; i32 {\n        [0 .. n].sum()\n    }\n}\n\n#[test]\nfn test_sum_from_zero() {\n    assert_eq!(15, squares::sum_from_zero(5));\n}\n</code></pre>\n\n<p>And got the following compiler error:</p>\n\n<pre><code>src/lib.rs:5:18: 5:21 error: no method named `sum` found for type `[std::ops::Range&lt;i32&gt;; 1]` in the current scope\nsrc/lib.rs:5         [0 .. n].sum()\n                              ^~~\nsrc/lib.rs:5:18: 5:21 note: the method `sum` exists but the following trait bounds were not satisfied: `[std::ops::Range&lt;i32&gt;; 1] : std::iter::Iterator`, `[std::ops::Range&lt;i32&gt;] : std::iter::Iterator`\nsrc/lib.rs:5:18: 5:21 error: no method named `sum` found for type `[std::ops::Range&lt;i32&gt;; 1]` in the current scope\nsrc/lib.rs:5         [0 .. n].sum()\n                              ^~~\nsrc/lib.rs:5:18: 5:21 note: the method `sum` exists but the following trait bounds were not satisfied: `[std::ops::Range&lt;i32&gt;; 1] : std::iter::Iterator`, `[std::ops::Range&lt;i32&gt;] : std::iter::Iterator`\n</code></pre>\n\n<p>Do I have to declare explicit bounds/traits? </p>\n"}, {"tags": ["python-3.x", "rust", "python-cffi", "cffi"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1477138141, "post_id": 40190074, "comment_id": 67650066, "body": "You cannot put <code>Vec</code> in a FFI signature. Please read the <a href=\"http://jakegoulding.com/rust-ffi-omnibus/\" rel=\"nofollow noreferrer\">FFI Omnibus</a>. Many people make this mistake, so I&#39;d really appreciate it if you could tell me any sources that say you can do this or any thought process you had that led to writing this code. Then maybe the Rust community can start to fix the problem at the source."}, {"owner": {"reputation": 983, "user_id": 6300710, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/767e076c216bb4a53b8046bbd1caf31c?s=128&d=identicon&r=PG&f=1", "display_name": "hallow_me", "link": "https://stackoverflow.com/users/6300710/hallow-me"}, "edited": false, "score": 0, "creation_date": 1477139399, "post_id": 40190074, "comment_id": 67650481, "body": "I didn&#39;t see this documentation, so I tought it was possible. I need to change my code and my way to think. Thanks"}, {"owner": {"reputation": 10650, "user_id": 1556290, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/5b37e6b4ac97453e4ba9dba37954cf79?s=128&d=identicon&r=PG", "display_name": "Armin Rigo", "link": "https://stackoverflow.com/users/1556290/armin-rigo"}, "edited": false, "score": 1, "creation_date": 1477292357, "post_id": 40190074, "comment_id": 67688739, "body": "To answer your original question (even though it won&#39;t work because of <code>Vec</code>): you are missing a semicolon at the end of the function declaration inside the <code>cdef(&quot;xxx&quot;)</code>."}], "owner": {"reputation": 983, "user_id": 6300710, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/767e076c216bb4a53b8046bbd1caf31c?s=128&d=identicon&r=PG&f=1", "display_name": "hallow_me", "link": "https://stackoverflow.com/users/6300710/hallow-me"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 1126, "favorite_count": 0, "answer_count": 0, "score": 1, "last_activity_date": 1477128897, "creation_date": 1477125687, "last_edit_date": 1477128897, "question_id": 40190074, "link": "https://stackoverflow.com/questions/40190074/cffi-api-cdeferror-parse-error-python", "title": "cffi.api.CDefError: parse error Python", "body": "<p>Using cffi, I'm trying to call some Rust function in Python code.\nHere is the python code:</p>\n\n<pre><code>from cffi import FFI\n\ndef rust(solution):\n    ffi = FFI()\n    lib = ffi.dlopen(\"./libnorm.so\")\n    ffi.cdef('float norm(float**)')\n\n    return lib.norm(solution)\n\nsolution = [[1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6]]\nprint(rust(solution))\n</code></pre>\n\n<p>and this is the rust code:</p>\n\n<pre><code>#! [crate_type = \"dylib\"]\n\n#[no_mangle]\npub extern fn norm(array: Vec&lt; Vec&lt;f64&gt;&gt;) -&gt; f64 {\n    return array.len() as f64\n}\n</code></pre>\n\n<p>I compiled the lib with:</p>\n\n<pre><code>rustc --crate-type=dylib norm.rs\n</code></pre>\n\n<p>But when I run my python script, I get this stack:</p>\n\n<pre><code>Traceback (most recent call last):\n  File \"/usr/lib64/python3.5/site-packages/cffi/cparser.py\", line 260, in _parse\n    ast = _get_parser().parse(csource)\n  File \"/usr/lib/python3.5/site-packages/pycparser/c_parser.py\", line 151, in parse\n    debug=debuglevel)\n  File \"/usr/lib/python3.5/site-packages/pycparser/ply/yacc.py\", line 331, in parse\n    return self.parseopt_notrack(input, lexer, debug, tracking, tokenfunc)\n  File \"/usr/lib/python3.5/site-packages/pycparser/ply/yacc.py\", line 1181, in parseopt_notrack\n    tok = call_errorfunc(self.errorfunc, errtoken, self)\n  File \"/usr/lib/python3.5/site-packages/pycparser/ply/yacc.py\", line 193, in call_errorfunc\n    r = errorfunc(token)\n  File \"/usr/lib/python3.5/site-packages/pycparser/c_parser.py\", line 1723, in p_error\n    self._parse_error('At end of input', self.clex.filename)\n  File \"/usr/lib/python3.5/site-packages/pycparser/plyparser.py\", line 55, in _parse_error\n    raise ParseError(\"%s: %s\" % (coord, msg))\npycparser.plyparser.ParseError: : At end of input\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"main.py\", line 35, in &lt;module&gt;\n    print(rust(solution))\n  File \"main.py\", line 28, in rust\n    ffi.cdef('float norm(float**)')\n  File \"/usr/lib64/python3.5/site-packages/cffi/api.py\", line 105, in cdef\n    self._cdef(csource, override=override, packed=packed)\n  File \"/usr/lib64/python3.5/site-packages/cffi/api.py\", line 119, in _cdef\n    self._parser.parse(csource, override=override, **options)\n  File \"/usr/lib64/python3.5/site-packages/cffi/cparser.py\", line 299, in parse\n    self._internal_parse(csource)\n  File \"/usr/lib64/python3.5/site-packages/cffi/cparser.py\", line 304, in _internal_parse\n    ast, macros, csource = self._parse(csource)\n  File \"/usr/lib64/python3.5/site-packages/cffi/cparser.py\", line 262, in _parse\n    self.convert_pycparser_error(e, csource)\n  File \"/usr/lib64/python3.5/site-packages/cffi/cparser.py\", line 291, in convert_pycparser_error\n    raise api.CDefError(msg)\ncffi.api.CDefError: parse error\n: At end of input\n</code></pre>\n\n<p>Am I missing something?</p>\n\n<p>I tried several version for: <code>ffi.cdef('float norm(float**)')</code>. Like <code>ffi.cdef('float norm(Vec&lt; Vec&lt;float&gt;&gt;)')</code> or <code>ffi.cdef('float norm(float[][])')</code>\nBut it doesn't work too.</p>\n\n<p>Thanks for future replying.</p>\n"}, {"tags": ["rust", "hashset", "canonicalization"], "answers": [{"comments": [{"owner": {"reputation": 10651, "user_id": 167935, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/583358786e336bb14a400ca17722ec3b?s=128&d=identicon&r=PG", "display_name": "Laurence", "link": "https://stackoverflow.com/users/167935/laurence"}, "edited": false, "score": 0, "creation_date": 1477162008, "post_id": 40187454, "comment_id": 67657335, "body": "I&#39;m torn as to which of yours and Matthieu&#39;s answers to tick. I think you have more strictly answered the question I asked, but Matthieu has given a more idiomatic rust solution, albeit with with additional overheads and safety.  Both answers make valuable contributions, I wish I could tick both."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 10651, "user_id": 167935, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/583358786e336bb14a400ca17722ec3b?s=128&d=identicon&r=PG", "display_name": "Laurence", "link": "https://stackoverflow.com/users/167935/laurence"}, "edited": false, "score": 0, "creation_date": 1477162521, "post_id": 40187454, "comment_id": 67657510, "body": "@Laurence no worries! You are supposed to accept whichever answer best helps <i>you</i>. Upvotes are for questions and answers that were useful to <i>someone</i>. Over time, people may upvote a non-accepted answer more or less than the accepted one."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 10651, "user_id": 167935, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/583358786e336bb14a400ca17722ec3b?s=128&d=identicon&r=PG", "display_name": "Laurence", "link": "https://stackoverflow.com/users/167935/laurence"}, "edited": false, "score": 1, "creation_date": 1477162568, "post_id": 40187454, "comment_id": 67657528, "body": "@Laurence Although I <b>would</b> say that string_cache is probably the better answer than either version of rolling your own."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 4, "last_activity_date": 1583952427, "last_edit_date": 1583952427, "creation_date": 1477099832, "answer_id": 40187454, "question_id": 40186370, "link": "https://stackoverflow.com/questions/40186370/using-a-hashset-to-canonicalize-objects-in-rust/40187454#40187454", "title": "Using a HashSet to canonicalize objects in Rust", "body": "<p>Your analysis is correct. The ultimate issue is that when modifying the <code>HashSet</code>, the compiler cannot guarantee that the mutations will not affect the existing allocations. Indeed, in general they <em>might</em> affect them, unless you add another layer of indirection, as you have identified.</p>\n\n<p>This is a prime example of a place that <code>unsafe</code> is useful. You, the programmer, can assert that the code will only ever be used in a particular way, and that particular way will allow the variable to be stable through any mutations. You can use the type system and module visibility to help enforce these conditions.</p>\n\n<p>Note that <code>String</code> already introduces a heap allocation. So long as you don't change the <code>String</code> once it's allocated, you don't need an extra <code>Box</code>.</p>\n\n<p>Something like this seems like an OK start:</p>\n\n<pre><code>use std::{cell::RefCell, collections::HashSet, mem};\n\nstruct EasyInterner(RefCell&lt;HashSet&lt;String&gt;&gt;);\n\nimpl EasyInterner {\n    fn new() -&gt; Self {\n        EasyInterner(RefCell::new(HashSet::new()))\n    }\n\n    fn intern&lt;'a&gt;(&amp;'a self, s: &amp;str) -&gt; &amp;'a str {\n        let mut set = self.0.borrow_mut();\n\n        if !set.contains(s) {\n            set.insert(s.into());\n        }\n\n        let interned = set.get(s).expect(\"Impossible missing string\");\n\n        // TODO: Document the pre- and post-conditions that the code must\n        // uphold to make this unsafe code valid instead of copying this\n        // from Stack Overflow without reading it\n        unsafe { mem::transmute(interned.as_str()) }\n    }\n}\n\nfn main() {\n    let i = EasyInterner::new();\n\n    let a = i.intern(\"hello\");\n    let b = i.intern(\"world\");\n    let c = i.intern(\"hello\");\n\n    // Still strings\n    assert_eq!(a, \"hello\");\n    assert_eq!(a, c);\n    assert_eq!(b, \"world\");\n\n    // But with the same address\n    assert_eq!(a.as_ptr(), c.as_ptr());\n    assert!(a.as_ptr() != b.as_ptr());\n\n    // This shouldn't compile; a cannot outlive the interner\n    // let x = {\n    //     let i = EasyInterner::new();\n    //     let a = i.intern(\"hello\");\n    //     a\n    // };\n\n    let the_pointer;\n    let i = {\n        let i = EasyInterner::new();\n        {\n            // Introduce a scope to contstrain the borrow of `i` for `s`\n            let s = i.intern(\"inner\");\n            the_pointer = s.as_ptr();\n        }\n        i // moving i to a new location\n          // All outstanding borrows are invalidated\n    };\n\n    // but the data is still allocated\n    let s = i.intern(\"inner\");\n    assert_eq!(the_pointer, s.as_ptr());\n}\n</code></pre>\n\n<p>However, it may be much more expedient to use a crate like:</p>\n\n<ul>\n<li><a href=\"https://crates.io/crates/string_cache\" rel=\"nofollow noreferrer\">string_cache</a>, which has the collective brainpower of the Servo project behind it. </li>\n<li><a href=\"https://crates.io/crates/typed-arena\" rel=\"nofollow noreferrer\">typed-arena</a></li>\n<li><a href=\"https://crates.io/crates/generational-arena\" rel=\"nofollow noreferrer\">generational-arena</a></li>\n</ul>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477146205, "post_id": 40192906, "comment_id": 67652414, "body": "Could you clarify on <i>who</i> might change <code>HashSet</code>? I don&#39;t suppose you mean that the implementer of <code>HashSet</code> would change (there&#39;s not much we can do about that, anyway). If you mean the <i>use</i> of <code>HashSet</code> inside the interner, then yes. That&#39;s why I always advocate the use of comments next to each <code>unsafe</code> to document it. I thought about using <code>Rc</code>, but didn&#39;t like the interaction with the forced allocation. You can&#39;t intern <code>&amp;[u16]</code>, for example."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477146843, "post_id": 40192906, "comment_id": 67652618, "body": "@Shepmaster: Note that I say <i>change the use of <code>HashSet</code></i>, by which I mean that either the OP or some other future contributor might break the invariant that data is never removed from the set. As for commenting the use of the <code>unsafe</code>, this is a commendable idea, however one might not think of looking into the <code>intern</code> method when adding another method... and one might misunderstand or misinterpret comments, too. In <i>this specific</i> example, it is simple enough certainly, but I would prefer avoiding cultivating a culture of &quot;just use <code>unsafe</code> here&quot;."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477162329, "post_id": 40192906, "comment_id": 67657439, "body": "To clarify my previous comment for future readers, I dislike this solution in <i>this</i> case because it requires <i>extraneous allocations</i>. Specifically, every string that wants to be interned must first be allocated, then a hashmap checked, then either stored or deallocated. The total number of allocations over the lifetime of the program is the <i>same</i>, but duplicates are deallocated much earlier, so the maximum memory usage at any given time is lower. There is also some amount of runtime overhead to increment / decrement the refcount. If those limitations are OK, this is a perfect solution!"}, {"owner": {"reputation": 10651, "user_id": 167935, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/583358786e336bb14a400ca17722ec3b?s=128&d=identicon&r=PG", "display_name": "Laurence", "link": "https://stackoverflow.com/users/167935/laurence"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477162403, "post_id": 40192906, "comment_id": 67657469, "body": "I narrowly missed writing this myself. I missed the point of <code>Rc</code> is that you can return <code>T</code> instead of <code>&amp;T</code>. I&#39;ve marked this answer as correct, even though @Shepmaster has more strictly answered my question as you are right that this should be my first solution, and I should only go for the unsafe version after profiling. It is nice to know both options exist."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 5, "last_activity_date": 1477144086, "creation_date": 1477144086, "answer_id": 40192906, "question_id": 40186370, "link": "https://stackoverflow.com/questions/40186370/using-a-hashset-to-canonicalize-objects-in-rust/40192906#40192906", "title": "Using a HashSet to canonicalize objects in Rust", "body": "<p>I somewhat disagree with @Shepmaster on the use of <code>unsafe</code> here.</p>\n\n<p>While <em>right now</em> it does not cause issue, should someone decide in the future to change the use of <code>HashSet</code> to include some pruning (for example, to only ever keep a hundred authors in there), then <code>unsafe</code> will bite you sternly.</p>\n\n<p>In the absence of a strong performance reason, I would simply use a <code>Rc&lt;XXX&gt;</code>. You can alias it easily enough: <code>type InternedXXX = Rc&lt;XXX&gt;;</code>.</p>\n\n<pre><code>use std::collections::HashSet;\nuse std::hash::Hash;\nuse std::rc::Rc;\n\n#[derive(PartialEq, Eq, Debug, Hash, Clone)]\nstruct CvsNumber(Rc&lt;Vec&lt;u16&gt;&gt;);\n\nfn intern&lt;T:Eq + Hash + Clone&gt;(set: &amp;mut HashSet&lt;T&gt;, item: T) -&gt; T {\n    if !set.contains(&amp;item) {\n        let dupe = item.clone();\n        set.insert(dupe);\n        item\n    } else {\n        set.get(&amp;item).unwrap().clone()\n    }\n}\n\nfn main() {\n    let mut set: HashSet&lt;CvsNumber&gt; = HashSet::new();\n    let c1 = CvsNumber(Rc::new(vec![1, 2]));\n    let c2 = intern(&amp;mut set, c1);\n    let c3 = CvsNumber(Rc::new(vec![1, 2]));\n    let c4 = intern(&amp;mut set, c3);\n}\n</code></pre>\n"}], "owner": {"reputation": 10651, "user_id": 167935, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/583358786e336bb14a400ca17722ec3b?s=128&d=identicon&r=PG", "display_name": "Laurence", "link": "https://stackoverflow.com/users/167935/laurence"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 831, "favorite_count": 0, "accepted_answer_id": 40192906, "answer_count": 2, "score": 3, "last_activity_date": 1583952427, "creation_date": 1477089520, "last_edit_date": 1477098188, "question_id": 40186370, "link": "https://stackoverflow.com/questions/40186370/using-a-hashset-to-canonicalize-objects-in-rust", "title": "Using a HashSet to canonicalize objects in Rust", "body": "<p>As an educational exercise, I'm looking at porting <a href=\"https://gitlab.com/esr/cvs-fast-export\" rel=\"nofollow\" title=\"cvs-fast-export\">cvs-fast-export</a> to Rust.</p>\n\n<p>Its basic mode of operation is to parse a number of CVS master files into a intermediate form, and then to analyse the intermediate form with the goal of transforming it into a git fast-export stream. </p>\n\n<p>One of the things that is done when parsing is to convert common parts of the intermediate form into a canonical representation. A motivating example is commit authors. A CVS repository may have hundreds of thousands of individual file commits, but probably less than a thousand authors. So an interning table is used when parsing where you input the author as you parse it from the file and it will give you a pointer to a canonical version, creating a new one if it hasn't seen it before. (I've heard this called atomizing or interning too). This pointer then gets stored on the intermediate object.</p>\n\n<p>My first attempt to do something similar in Rust attempted to use a <code>HashSet</code> as the interning table. Note this uses CVS version numbers rather than authors, this is just a sequence of digits such as 1.2.3.4, represented as a <code>Vec</code>.</p>\n\n<pre><code>use std::collections::HashSet;\nuse std::hash::Hash;\n\n#[derive(PartialEq, Eq, Debug, Hash, Clone)]\nstruct CvsNumber(Vec&lt;u16&gt;);\n\nfn intern&lt;T:Eq + Hash + Clone&gt;(set: &amp;mut HashSet&lt;T&gt;, item: T) -&gt; &amp;T {\n    let dupe = item.clone();\n    if !set.contains(&amp;item) {\n        set.insert(item);\n    }\n    set.get(&amp;dupe).unwrap()\n}\n\nfn main() {\n    let mut set: HashSet&lt;CvsNumber&gt; = HashSet::new();\n    let c1 = CvsNumber(vec![1, 2]);\n    let c2 = intern(&amp;mut set, c1);\n    let c3 = CvsNumber(vec![1, 2]);\n    let c4 = intern(&amp;mut set, c3);\n}\n</code></pre>\n\n<p>This fails with <code>error[E0499]: cannot borrow 'set' as mutable more than once at a time</code>. This is fair enough, <code>HashSet</code> doesn't guarantee references to its keys will be valid if you add more items after you have obtained a reference. The C version is careful to guarantee this. To get this guarantee, I think the <code>HashSet</code> should be over <code>Box&lt;T&gt;</code>. However I can't explain the lifetimes for this to the borrow checker.</p>\n\n<p>The ownership model I am going for here is that the interning table owns the canonical versions of the data, and hands out references. The references should be valid as long the interning table exists. We should be able to add new things to the interning table without invalidating the old references. I think the root of my problem is that I'm confused how to write the interface for this contract in a way consistent with the Rust ownership model.</p>\n\n<p>Solutions I see with my limited Rust knowledge are:</p>\n\n<ol>\n<li>Do two passes, build a <code>HashSet</code> on the first pass, then freeze it and use references on the second pass. This means additional temporary storage (sometimes substantial).</li>\n<li>Unsafe</li>\n</ol>\n\n<p>Does anyone have a better idea?</p>\n"}, {"tags": ["generics", "reflection", "rust"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 7, "creation_date": 1477063940, "post_id": 40180252, "comment_id": 67628355, "body": "What do you want to do with the types later?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 3, "creation_date": 1477064419, "post_id": 40180252, "comment_id": 67628636, "body": "^ and... have you looked into traits?"}, {"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1477064920, "post_id": 40180252, "comment_id": 67628912, "body": "@ChrisEmerson: I have a heterogeneous list, that I want to type check. I used some type shenanigans to have all it&#39;s values in <code>Vec&lt;Box&lt;Any&gt;&gt;</code>, but extracting the types gets a bit... hard and I assume slow since the type is essentially a <code>Cons&lt;i32, Cons&lt;bool, Nil&gt;&gt;</code>."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1477065035, "post_id": 40180252, "comment_id": 67628972, "body": "I&#39;m not sure what you mean by typechecking a heterogenous list, and extracting types.  Can you show some pseudo code for what you want to do?"}, {"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477065067, "post_id": 40180252, "comment_id": 67628993, "body": "@MatthieuM. Yes, although not sure what you <b>exactly</b> mean? Storing different traits in Vector instead of types?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1477065071, "post_id": 40180252, "comment_id": 67628995, "body": "Agree with @ChrisEmerson, but perhaps <b>not</b> by changing <i>this</i> question, as it already has two answers for the current phrasing."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1477065313, "post_id": 40180252, "comment_id": 67629124, "body": "@DanielFath: You need something homogeneous in a <code>Vec</code>, but types could implement a single <code>trait</code> that returns what kind of type is stored in it (if the list of kind if finite) or you could use an <code>enum</code> if the list of types/kinds is well-known in advance, etc... You may want to ask a new question presenting the code you have written with <code>Cons</code> and asking how to do it better: with an exact example of your problem, the answers will be more relevant."}, {"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1477065429, "post_id": 40180252, "comment_id": 67629181, "body": "Yeah, it&#39;s a bit hard to explain. But imagine you have <code>let x = Cons&lt;32, Cons&lt;true, Cons&lt;&quot;string&quot;, Nil&gt;&gt;&gt;</code> and you want to extract the <code>&quot;string&quot;</code> from it. I was hoping to extract the type from a paired vector of types, rather than search recursively."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 6, "last_activity_date": 1477064540, "last_edit_date": 1495542804, "creation_date": 1477063568, "answer_id": 40180382, "question_id": 40180252, "link": "https://stackoverflow.com/questions/40180252/is-it-possible-to-store-types-not-instances-of-those-types-in-a-vec/40180382#40180382", "title": "Is it possible to store types, not instances of those types, in a Vec?", "body": "<p>No. Types are not a runtime construct and are removed during compilation. You cannot have a collection of the types themselves because they don't exist.</p>\n\n<p>Most of the time, you want to <a href=\"https://stackoverflow.com/q/27957103/155423\">create a heterogeneous collection of objects</a> that all adhere to some shared interface (a.k.a. a <code>trait</code>).</p>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 4, "last_activity_date": 1477064990, "last_edit_date": 1477064990, "creation_date": 1477064902, "answer_id": 40180786, "question_id": 40180252, "link": "https://stackoverflow.com/questions/40180252/is-it-possible-to-store-types-not-instances-of-those-types-in-a-vec/40180786#40180786", "title": "Is it possible to store types, not instances of those types, in a Vec?", "body": "<p>The only reason that <code>Integer.class</code> is useful in Java, is because Java implements <em>reflection</em>:</p>\n\n<ul>\n<li>the runtime has a description of all existing types</li>\n<li>for each type, it has a description of all attributes and methods</li>\n</ul>\n\n<p>and therefore the virtual machine can, at runtime, create an instance of a type <em>from thin air</em>.</p>\n\n<hr>\n\n<p>Automatic, pervasive reflection violates at least one core tenet of Rust:</p>\n\n<blockquote>\n  <p>You don't pay for what you don't use.</p>\n</blockquote>\n\n<p>so has not been implemented.</p>\n\n<p>Rust has <em>some amount</em> of reflection still:</p>\n\n<ul>\n<li>it has compile-time reflection, via plugins</li>\n<li>it has some type information, via <code>TypeId</code></li>\n</ul>\n\n<p>However, the former does not incur any memory/performance overhead and the latter is on a pay-per-use basis.</p>\n\n<p>As far as I know, there is no proposal to significantly extend reflection yet. Even down-casting is for now explored as a library, and not a language, option (see the <a href=\"https://docs.rs/query_interface/0.3.3/query_interface/\" rel=\"nofollow\">query_interface</a> crate).</p>\n"}], "owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 93, "favorite_count": 0, "answer_count": 2, "score": 2, "last_activity_date": 1477064990, "creation_date": 1477063095, "last_edit_date": 1477063649, "question_id": 40180252, "link": "https://stackoverflow.com/questions/40180252/is-it-possible-to-store-types-not-instances-of-those-types-in-a-vec", "title": "Is it possible to store types, not instances of those types, in a Vec?", "body": "<p>Is it possible to store different Rust types into a <code>Vec</code> in some form that would allow me to get the types at later date? </p>\n\n<p>I could store the <code>TypeId</code> of any types, but I couldn't then use the <code>TypeId</code> to get back to the original types, as far as I know.</p>\n\n<p>In Java terms, I want to create a <code>[boolean.class, char.class, ...]</code>, etc.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 240, "user_id": 6727289, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/012f7d3213d984a1f182f7ff44c49cad?s=128&d=identicon&r=PG&f=1", "display_name": "rpiper", "link": "https://stackoverflow.com/users/6727289/rpiper"}, "edited": false, "score": 0, "creation_date": 1477064256, "post_id": 40180310, "comment_id": 67628540, "body": "Thanks, for some reason I was under the incorrect belief that the for loop was directly  leveraging the next function."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 240, "user_id": 6727289, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/012f7d3213d984a1f182f7ff44c49cad?s=128&d=identicon&r=PG&f=1", "display_name": "rpiper", "link": "https://stackoverflow.com/users/6727289/rpiper"}, "edited": false, "score": 2, "creation_date": 1477064371, "post_id": 40180310, "comment_id": 67628601, "body": "@rpiper <i>the for loop was directly leveraging the <code>next</code> function</i> \u2014 yes, it does use <code>next</code> internally. It handles the case of <code>Some</code> or <code>None</code> for you, executing the body when <code>Some</code> and exiting the loop on <code>None</code>."}, {"owner": {"reputation": 339851, "user_id": 149392, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7a561ec0875fcbbe3066ea8fe288ec77?s=128&d=identicon&r=PG", "display_name": "sepp2k", "link": "https://stackoverflow.com/users/149392/sepp2k"}, "reply_to_user": {"reputation": 240, "user_id": 6727289, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/012f7d3213d984a1f182f7ff44c49cad?s=128&d=identicon&r=PG&f=1", "display_name": "rpiper", "link": "https://stackoverflow.com/users/6727289/rpiper"}, "edited": false, "score": 3, "creation_date": 1477064384, "post_id": 40180310, "comment_id": 67628615, "body": "@rpiper It is, but it&#39;s more along the lines of &quot;If next returned Some(x) assign <code>x</code> to the loop variable, else end the loop&quot;."}], "tags": [], "owner": {"reputation": 339851, "user_id": 149392, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7a561ec0875fcbbe3066ea8fe288ec77?s=128&d=identicon&r=PG", "display_name": "sepp2k", "link": "https://stackoverflow.com/users/149392/sepp2k"}, "is_accepted": true, "score": 3, "last_activity_date": 1477063302, "creation_date": 1477063302, "answer_id": 40180310, "question_id": 40180197, "link": "https://stackoverflow.com/questions/40180197/mismatched-types-in-if-let-statement-found-option-expected-result/40180310#40180310", "title": "Mismatched types in if let statement: found Option expected Result", "body": "<p>You linked to the documentation of <code>next</code>, but you're not using <code>next</code> (not directly anyway), you're using a for loop. In a for loop the type of the iteration variable (i.e. the type of <code>line</code> in your code) is the <code>Item</code> type of the iterator, which in your case is <code>Result&lt;String&gt;</code>.</p>\n\n<p>The type of <code>next</code> is <code>Option&lt;Item&gt;</code> because you might call <code>next</code> on an iterator that already reached the end. The body of a for loop won't ever execute after the end of the iteration, so there's no point in the iteration variable being an option.</p>\n"}], "owner": {"reputation": 240, "user_id": 6727289, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/012f7d3213d984a1f182f7ff44c49cad?s=128&d=identicon&r=PG&f=1", "display_name": "rpiper", "link": "https://stackoverflow.com/users/6727289/rpiper"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3896, "favorite_count": 0, "accepted_answer_id": 40180310, "answer_count": 1, "score": 5, "last_activity_date": 1477066079, "creation_date": 1477062913, "last_edit_date": 1477066079, "question_id": 40180197, "link": "https://stackoverflow.com/questions/40180197/mismatched-types-in-if-let-statement-found-option-expected-result", "title": "Mismatched types in if let statement: found Option expected Result", "body": "<p>I am trying to parse a file that has a pipe delimiter between each value and each line is a new record. I am iterating over each line like this:</p>\n\n<pre><code>use std::fs::File;\nuse std::io::BufReader;\nuse std::io::prelude::*;\n\nfn main() {\n    let source_file = File::open(\"input.txt\").unwrap();\n    let reader = BufReader::new(source_file);\n    for line in reader.lines() {\n        if let Some(channel_line) = line {\n            println!(\"yay\");\n        }\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=80b1a9c8a94f1c6665c353015661a016&amp;version=stable\" rel=\"noreferrer\">Playground</a></p>\n\n<p>However, I get an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:9:20\n  |\n9 |             if let Some(channel_line) = line {\n  |                    ^^^^^^^^^^^^^^^^^^ expected enum    `std::result::Result`, found enum `std::option::Option`\n  |\n  = note: expected type `std::result::Result&lt;std::string::String, std::io::Error&gt;`\n  = note:    found type `std::option::Option&lt;_&gt;`\n</code></pre>\n\n<p>This error is confusing to me as the found type is what I expected namely <code>Option&lt;Result&lt;String, Error&gt;&gt;</code> as indicated by the <a href=\"https://doc.rust-lang.org/std/io/struct.Lines.html#method.next\" rel=\"noreferrer\">docs</a> so it would make sense to unwrap the <code>Option</code> before the result assuming I am not missing something. </p>\n"}, {"tags": ["rust", "tuples", "generic-programming"], "answers": [{"comments": [{"owner": {"reputation": 1259, "user_id": 1814775, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/ea9a58ab403c34bc21cde3a006d2e6d8?s=128&d=identicon&r=PG", "display_name": "lloydmeta", "link": "https://stackoverflow.com/users/1814775/lloydmeta"}, "edited": false, "score": 1, "creation_date": 1477062293, "post_id": 40179025, "comment_id": 67627245, "body": "Thanks. Before I posted my question I had tried a few different ways but kept running into the conflicting implementations problem. For example, implementing <code>for (A, B)</code> means that you can&#39;t implement for <code>(A, (B, C))</code> and <code>(A, (B, (C, D)))</code> and so forth to solve the <code>N</code> nested pairs case, and I&#39;m not sure the situation changes with where clauses."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1259, "user_id": 1814775, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/ea9a58ab403c34bc21cde3a006d2e6d8?s=128&d=identicon&r=PG", "display_name": "lloydmeta", "link": "https://stackoverflow.com/users/1814775/lloydmeta"}, "edited": false, "score": 0, "creation_date": 1477063846, "post_id": 40179025, "comment_id": 67628278, "body": "@lloydmeta: Yeah, this conflicting implementation thing is really annoying :("}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477063925, "post_id": 40179025, "comment_id": 67628344, "body": "@MatthieuM. you know that it&#39;s far better for our code to not be ambiguous. Perhaps specialization will solve this issue, or maybe it wont..."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477064048, "post_id": 40179025, "comment_id": 67628426, "body": "@Shepmaster: I agree with the absence of ambiguity, but I&#39;ve used C++ so much in the past that specialization is ingrained in my brain ^^"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 4, "last_activity_date": 1477059988, "last_edit_date": 1477059988, "creation_date": 1477059463, "answer_id": 40179025, "question_id": 40178572, "link": "https://stackoverflow.com/questions/40178572/are-there-any-ways-to-recursively-flatten-tuples/40179025#40179025", "title": "Are there any ways to recursively flatten tuples?", "body": "<p><em>Maybe</em> for certain small definitions of \"flatten\", but realistically not really.</p>\n\n<p>Start with the most specific implementation:</p>\n\n<pre><code>trait FlattenTuple {\n    fn into_flattened(self) -&gt; (u8, u8, u8);\n}\n\nimpl FlattenTuple for (u8, (u8, u8)) {\n    fn into_flattened(self) -&gt; (u8, u8, u8) {\n        (self.0, (self.1).0, (self.1).1)\n    }\n}\n</code></pre>\n\n<p>Then make it a bit more generic:</p>\n\n<pre><code>trait FlattenTuple {\n    type Output;\n    fn into_flattened(self) -&gt; Self::Output;\n}\n\nimpl&lt;A, B, C&gt; FlattenTuple for (A, (B, C)) {\n    type Output = (A, B, C);\n\n    fn into_flattened(self) -&gt; Self::Output {\n        (self.0, (self.1).0, (self.1).1)\n    }\n}\n</code></pre>\n\n<p>And then repeat for <em>every possible permutation</em>:</p>\n\n<pre><code>impl&lt;A, B, C, D, E, F&gt; FlattenTuple for ((A, B), C, (D, (E, F))) {\n    type Output = (A, B, C, D, E, F);\n\n    fn into_flattened(self) -&gt; Self::Output {\n        ((self.0).0, (self.0).1, self.1, (self.2).0, ((self.2).1).0, ((self.2).1).1)\n    }\n}\n</code></pre>\n\n<p>These two implementations cover your two cases.</p>\n\n<p>However, you'd then have to enumerate every input type you'd like, probably via code generation. There's no way I'm aware of to \"inspect\" the input type and then \"splice\" it into the output type. </p>\n\n<p>You can even try to write something somewhat recursive:</p>\n\n<pre><code>impl&lt;A, B, C, D, E, F&gt; FlattenTuple for (A, B)\n    where A: FlattenTuple&lt;Output = (C, D)&gt;,\n          B: FlattenTuple&lt;Output = (E, F)&gt;,\n{\n    type Output = (C, D, E, F);\n\n    fn into_flattened(self) -&gt; Self::Output {\n        let (a, b) = self;\n        let (c, d) = a.into_flattened();\n        let (e, f) = b.into_flattened();\n\n        (c, d, e, f)\n    }\n}\n</code></pre>\n\n<p>But this will quickly run into base-case issues: the terminal <code>42</code> doesn't implement <code>FlattenTuple</code>, and if you try to <code>impl&lt;T&gt; FlattenTuple for T</code> you will hit conflicting trait implementations.</p>\n"}, {"tags": [], "owner": {"reputation": 321, "user_id": 6193633, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/f642d3c45da4db031e2d41798d1801a5?s=128&d=identicon&r=PG&f=1", "display_name": "kdy", "link": "https://stackoverflow.com/users/6193633/kdy"}, "is_accepted": false, "score": 0, "last_activity_date": 1514291617, "creation_date": 1514291617, "answer_id": 47978733, "question_id": 40178572, "link": "https://stackoverflow.com/questions/40178572/are-there-any-ways-to-recursively-flatten-tuples/47978733#47978733", "title": "Are there any ways to recursively flatten tuples?", "body": "<p>I implemented this with specialization and auto trait.</p>\n\n<p><a href=\"https://docs.rs/flatten/*/flatten/\" rel=\"nofollow noreferrer\">docs.rs</a></p>\n\n<p><a href=\"https://github.com/kdy1/flatten\" rel=\"nofollow noreferrer\">github repo</a></p>\n\n<hr>\n\n<p>Usage is basically</p>\n\n<pre><code>assert_eq!((1, (2, ((3,) (4, 5)), (), 6).flatten(), (1, 2, 3, 4, 5, 6));\n</code></pre>\n\n<p>It removes all empty unit tuple <code>()</code> (like python).</p>\n\n<hr>\n\n<p>If you are writing generic code, you need to add</p>\n\n<pre><code>where (A, B): Flatten\n</code></pre>\n\n<p>rustc wants this because Flatten is implemented only if length of output tuple is smaller than 13.</p>\n"}], "owner": {"reputation": 1259, "user_id": 1814775, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/ea9a58ab403c34bc21cde3a006d2e6d8?s=128&d=identicon&r=PG", "display_name": "lloydmeta", "link": "https://stackoverflow.com/users/1814775/lloydmeta"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1099, "favorite_count": 0, "answer_count": 2, "score": 4, "last_activity_date": 1514291617, "creation_date": 1477058208, "last_edit_date": 1477059480, "question_id": 40178572, "link": "https://stackoverflow.com/questions/40178572/are-there-any-ways-to-recursively-flatten-tuples", "title": "Are there any ways to recursively flatten tuples?", "body": "<p>In Rust, is there any way to use <code>trait</code>s and <code>impl</code>s to (recursively) flatten tuples?</p>\n\n<p>If it helps, something that works with N nested pairs is a good start</p>\n\n<pre><code>trait FlattenTuple {\n    fn into_flattened(self) -&gt; /* ??? */\n}\n\n// such that\nassert_eq!((1, (2, 3)).into_flattened(), (1, 2, 3))\n</code></pre>\n\n<p>It would be even better if it could be extended work with any kind of nested tuple such that: </p>\n\n<pre><code>assert_eq!(((1, 2), 2, (3, (4, 5))).into_flattened(), (1, 2, 2, 3, 4, 5))\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477058136, "post_id": 40178497, "comment_id": 67624145, "body": "Ah thanks! I was wracking my brain in totally the wrong direction and had not considered that most method calls are forwarded to the pointee via <code>Defer</code>."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 9, "last_activity_date": 1477058156, "last_edit_date": 1477058156, "creation_date": 1477058012, "answer_id": 40178497, "question_id": 40178388, "link": "https://stackoverflow.com/questions/40178388/why-doesnt-boxinto-raw-take-self-as-parameter/40178497#40178497", "title": "Why doesn&#39;t `Box::into_raw` take `self` as parameter?", "body": "<p>Because 99.995% of the time (statistic totally made up), <a href=\"https://github.com/rust-lang/rust/commit/a068fc70ab38adea73f84a8f8c6f826454ce563b\">you expect method calls to happen to the thing being pointed <em>to</em>, not to the pointer <em>itself</em></a>.  As a result, the \"smart pointer\" types in Rust <em>generally</em> avoid doing anything to break that expectation.  An obvious exception would be something like <code>Rc</code>/<code>Arc</code> implementing <code>Clone</code> directly.</p>\n"}, {"comments": [{"owner": {"reputation": 13479, "user_id": 1830736, "user_type": "registered", "accept_rate": 98, "profile_image": "https://i.stack.imgur.com/gwUf7.jpg?s=128&g=1", "display_name": "George Hilliard", "link": "https://stackoverflow.com/users/1830736/george-hilliard"}, "edited": false, "score": 2, "creation_date": 1477058460, "post_id": 40178561, "comment_id": 67624364, "body": "See <a href=\"https://github.com/rust-lang/rust/pull/21318\" rel=\"nofollow noreferrer\">the pull request</a> adding these functions to the standard library."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 13479, "user_id": 1830736, "user_type": "registered", "accept_rate": 98, "profile_image": "https://i.stack.imgur.com/gwUf7.jpg?s=128&g=1", "display_name": "George Hilliard", "link": "https://stackoverflow.com/users/1830736/george-hilliard"}, "edited": false, "score": 0, "creation_date": 1477062179, "post_id": 40178561, "comment_id": 67627176, "body": "@thirtythreeforty: An excellent source indeed, the comment by alexcrichton explains it exactly."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 7, "last_activity_date": 1477058496, "last_edit_date": 1477058496, "creation_date": 1477058188, "answer_id": 40178561, "question_id": 40178388, "link": "https://stackoverflow.com/questions/40178388/why-doesnt-boxinto-raw-take-self-as-parameter/40178561#40178561", "title": "Why doesn&#39;t `Box::into_raw` take `self` as parameter?", "body": "<p><code>Box</code> implements <a href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html\"><code>Deref</code></a>, which means that all methods that are enclosed by the <code>Box</code> are automatically made available; from the outside, <code>Box&lt;T&gt;</code> and <code>T</code> look and act the same.</p>\n\n<p>If <code>into_raw</code> were a method instead of an associated function, it would shadow any <code>into_raw</code> method on the contained type.</p>\n\n<p>There are other examples of these enhancing associated functions on <a href=\"https://doc.rust-lang.org/std/rc/struct.Rc.html\"><code>Rc</code></a>, such as <code>downgrade</code> or <code>try_unwrap</code>, or on <a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html\"><code>Arc</code></a>, such as <code>make_mut</code>.</p>\n"}], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 198, "favorite_count": 1, "accepted_answer_id": 40178497, "answer_count": 2, "score": 10, "last_activity_date": 1477058621, "creation_date": 1477057762, "last_edit_date": 1477058621, "question_id": 40178388, "link": "https://stackoverflow.com/questions/40178388/why-doesnt-boxinto-raw-take-self-as-parameter", "title": "Why doesn&#39;t `Box::into_raw` take `self` as parameter?", "body": "<p>This simple program:</p>\n\n<pre><code>fn main() {\n    let b: Box&lt;i32&gt; = Box::new(1);\n    b.into_raw();\n}\n</code></pre>\n\n<p>Produces this inconvenient error when compiled with Rust 1.12.0:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: no method named `into_raw` found for type `Box&lt;i32&gt;` in the current scope\n --&gt; &lt;anon&gt;:3:7\n  |\n3 |     b.into_raw();\n  |       ^^^^^^^^\n  |\n  = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n  = note: candidate #1 is defined in an impl for the type `Box&lt;_&gt;`\n</code></pre>\n\n<p>This is because <code>into_raw</code> is not defined to take <code>self</code> as parameter, but instead is defined as:</p>\n\n<pre><code>impl Box&lt;T: ?Sized&gt; {\n    fn into_raw(b: Box&lt;T&gt;) -&gt; *mut T;\n}\n</code></pre>\n\n<p>This seems inconvenient, and I cannot find a rationale.</p>\n\n<p>So... why?</p>\n"}, {"tags": ["rust", "sublimetext3"], "answers": [{"tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": false, "score": 2, "last_activity_date": 1477066359, "last_edit_date": 1477066359, "creation_date": 1477065913, "answer_id": 40181091, "question_id": 40178223, "link": "https://stackoverflow.com/questions/40178223/how-to-build-and-run-rust-code-with-a-single-sublime-text-shortcut/40181091#40181091", "title": "How to build and run Rust code with a single Sublime Text shortcut?", "body": "<p>Personally, I'm using a custom \"build system\" with Sublime.</p>\n\n<p>The file (byzon.sublime-build, <a href=\"http://docs.sublimetext.info/en/latest/reference/build_systems/basics.html#file-format-of-sublime-build-files\" rel=\"nofollow\">cf</a>) is placed in <code>c:\\Users\\$username\\AppData\\Roaming\\Sublime Text 3\\Packages\\User\\</code> and looks like this:</p>\n\n<pre><code>{ \"cmd\": [\"c:/spool/bin/sublime_build.exe\", \"--build=$file\"],\n  // New Rust\n  \"file_regex\": \"--&gt; (?:[\\\\w\\\\\\\\/\\\\.]+[\\\\\\\\/])?([\\\\w\\\\.]+\\\\.rs):(\\\\d+):(\\\\d+)\",\n  // Old Rust\n  //\"file_regex\": \"^(?:[\\\\w\\\\./]+/)?([\\\\w\\\\.]+\\\\.rs):(\\\\d+):(\\\\d+)\",\n  \"selector\": \"source.rust, source.php\" }\n</code></pre>\n\n<p>Once the custom \"build system\" file is in place, I just select it from the \"Tools / Build System\" menu (in case it wasn't already selected by the editor) and hitting Ctrl+B invokes my own build script (which is, unsurprisingly, written in Rust).</p>\n\n<p>This provided me with far better customisation than anything else could. For example, some of my projects have the build script open a couple of log files on different High Availability servers and forward their contents right into the build console, tagging each line with the hostname of the server the line originates from, so hitting Ctrl+B I get my project rebuilt and restarted on the servers and I see their logs right away as well. Other project is synchronized and built on a local Docker image. What I'm saying is having a custom build script has its advantages.</p>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480513265, "post_id": 40887031, "comment_id": 68993336, "body": "This does not use Cargo and thus is extremely limited."}], "tags": [], "owner": {"reputation": 725, "user_id": 2477820, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/8e40225c2b9ee5c64aa198074a7b8aef?s=128&d=identicon&r=PG", "display_name": "frost", "link": "https://stackoverflow.com/users/2477820/frost"}, "is_accepted": false, "score": 3, "last_activity_date": 1480504814, "creation_date": 1480504814, "answer_id": 40887031, "question_id": 40178223, "link": "https://stackoverflow.com/questions/40178223/how-to-build-and-run-rust-code-with-a-single-sublime-text-shortcut/40887031#40887031", "title": "How to build and run Rust code with a single Sublime Text shortcut?", "body": "<p>Simple custom build I'm using to build and run from one shortcut:</p>\n\n<pre><code>{\n    \"shell_cmd\": \"rustc $file\",\n    \"selector\": \"source.rust\",\n\n    \"variants\": \n    [\n        {\n            \"name\": \"Build &amp; Run\",\n            \"selector\": \"source.rust\",\n            \"shell_cmd\": \"rustc $file &amp;&amp; ./$file_base_name\",\n            \"windows\":\n            {\n                \"shell_cmd\": \"rustc $file &amp;&amp; $file_base_name.exe\"\n            }\n        }\n    ]\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 4563, "user_id": 393010, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/aa26083676d7b0d1d200d622f12f6793?s=128&d=identicon&r=PG", "display_name": "Moberg", "link": "https://stackoverflow.com/users/393010/moberg"}, "edited": false, "score": 0, "creation_date": 1503745309, "post_id": 41728686, "comment_id": 78748164, "body": "The rust book talks about compiling and running with cargo: <a href=\"https://doc.rust-lang.org/book/second-edition/ch01-02-hello-world.html#compiling-and-running-are-separate-steps\" rel=\"nofollow noreferrer\">doc.rust-lang.org/book/second-edition/&hellip;</a>"}], "tags": [], "owner": {"reputation": 191, "user_id": 2804645, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/3iWZi.jpg?s=128&g=1", "display_name": "Stan", "link": "https://stackoverflow.com/users/2804645/stan"}, "is_accepted": false, "score": 4, "last_activity_date": 1484770609, "creation_date": 1484770609, "answer_id": 41728686, "question_id": 40178223, "link": "https://stackoverflow.com/questions/40178223/how-to-build-and-run-rust-code-with-a-single-sublime-text-shortcut/41728686#41728686", "title": "How to build and run Rust code with a single Sublime Text shortcut?", "body": "<p>I like this answer posted on <a href=\"https://www.quora.com/How-can-I-run-Rust-code-inside-Sublime-Text-3\" rel=\"nofollow noreferrer\">Quora</a>, except that you don't have to do point 1 listed there. Here are the steps:</p>\n\n<ol>\n<li>Go to your workspace folder or wherever you're going to create your project.</li>\n<li><p>From the command line(Shift + Right click when inside the folder in Windows), invoke</p>\n\n<p><code>cargo new PROJECT_NAME --bin</code></p></li>\n<li><p>This creates a main.rs file inside src folder. Open it and code away.</p></li>\n<li>Run <kbd>Ctrl + Shift + B</kbd> once and select <strong>Cargo - Run</strong>. You can build (and run) with this from now on with only <kbd>Ctrl + B</kbd>.</li>\n</ol>\n"}, {"tags": [], "owner": {"reputation": 11, "user_id": 13490351, "user_type": "unregistered", "profile_image": "https://www.gravatar.com/avatar/c5ffedcce4b502f146a7d401209a0a37?s=128&d=identicon&r=PG", "display_name": "user13490351", "link": "https://stackoverflow.com/users/13490351/user13490351"}, "is_accepted": false, "score": 1, "last_activity_date": 1588864211, "last_edit_date": 1588864211, "creation_date": 1588849643, "answer_id": 61656256, "question_id": 40178223, "link": "https://stackoverflow.com/questions/40178223/how-to-build-and-run-rust-code-with-a-single-sublime-text-shortcut/61656256#61656256", "title": "How to build and run Rust code with a single Sublime Text shortcut?", "body": "<p>I modified my sublime-keymap file and added a new key map:</p>\n\n<pre><code>{ \"keys\": [\"alt+b\"], \"command\": \"build\", \"args\": { \"variant\": \"Run\" } },\n</code></pre>\n\n<p>This compiles then runs <code>.rs</code> files on selecting <code>alt +</code> b, I tend to leave the build only as the default on <code>ctrl + b</code> and select others with <code>ctrl + shift + b</code> as required.  I added this as it seems simpler than other suggestions even though this is an old thread.</p>\n"}], "owner": {"reputation": 3562, "user_id": 207352, "user_type": "registered", "accept_rate": 51, "profile_image": "https://www.gravatar.com/avatar/fa8609ca62438a65a86bcebe95dccbb6?s=128&d=identicon&r=PG", "display_name": "Pavel Vlasov", "link": "https://stackoverflow.com/users/207352/pavel-vlasov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1892, "favorite_count": 0, "answer_count": 4, "score": 6, "last_activity_date": 1588864211, "creation_date": 1477057273, "last_edit_date": 1477058464, "question_id": 40178223, "link": "https://stackoverflow.com/questions/40178223/how-to-build-and-run-rust-code-with-a-single-sublime-text-shortcut", "title": "How to build and run Rust code with a single Sublime Text shortcut?", "body": "<p>I have installed the \"Rust Enhanced\" plugin onto Sublime Text 3126 and I am able to build and run a <code>*.rs</code> program opened in Sublime Text.</p>\n\n<p>In reality, the process is a nightmare:</p>\n\n<ol>\n<li>Press <kbd>Cmd+Shift+B</kbd></li>\n<li>Select <code>Rust</code> to compile</li>\n<li>Make sure there is no errors</li>\n<li>Press <kbd>Cmd+Shift+B</kbd></li>\n<li>Select <code>Rust - Run</code> to run the last executable built</li>\n</ol>\n\n<p><kbd>Cmd+B</kbd> just repeats the last command executed.</p>\n\n<p>How can this be shortened into a single shortcut?</p>\n"}, {"tags": ["generics", "rust", "lifetime", "nightly-build"], "comments": [{"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 2, "creation_date": 1477030879, "post_id": 40169498, "comment_id": 67607272, "body": "I&#39;m confused, are <code>T</code> and <code>U</code> supposed to be different traits?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1477038333, "post_id": 40169498, "comment_id": 67611180, "body": "@Jsor: Probably, given that <code>F</code> is a transformer here."}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477038458, "post_id": 40169498, "comment_id": 67611254, "body": "@MatthieuM. I&#39;m thinking they actually want to transform between two implementations of the same trait, and then convert it into a boxed trait object."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1477038610, "post_id": 40169498, "comment_id": 67611329, "body": "@Jsor: Ah sorry; I misread. Given the type of the chain, I think that <code>T</code> and <code>U</code> are just difference instances of the same trait because the chain itself takes a trait in and returns <i>the same</i> trait out."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477038649, "post_id": 40171815, "comment_id": 67611360, "body": "It might be &quot;quicker&quot; to say <code>U: MyTrait + &#39;static,</code> rather than introduce a second <code>U</code> line."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1477038738, "post_id": 40171815, "comment_id": 67611407, "body": "Yeah, I considered that, but arbitrarily decided it would be clearer to add the seaprate bound.  I&#39;ll add a note."}, {"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 0, "creation_date": 1477039689, "post_id": 40171815, "comment_id": 67611944, "body": "I don&#39;t think it is clearer as it seems unusual to have a second line describing a type parameter (and thus might not be looked at at first glance)"}, {"owner": {"reputation": 23, "user_id": 7051408, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7cef9659fb1f64453f66bbaf1bdadb2c?s=128&d=identicon&r=PG&f=1", "display_name": "moulins", "link": "https://stackoverflow.com/users/7051408/moulins"}, "edited": false, "score": 0, "creation_date": 1477091187, "post_id": 40171815, "comment_id": 67640778, "body": "Okay, it was this simple ;)"}, {"owner": {"reputation": 23, "user_id": 7051408, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7cef9659fb1f64453f66bbaf1bdadb2c?s=128&d=identicon&r=PG&f=1", "display_name": "moulins", "link": "https://stackoverflow.com/users/7051408/moulins"}, "edited": false, "score": 0, "creation_date": 1477091712, "post_id": 40171815, "comment_id": 67640893, "body": "However, there&#39;s another problem now: inside <code>chain</code>, the <code>Box</code> points to an unsized trait, so I can&#39;t pass it to the transform function, and I can&#39;t pass a reference to it... I guess I have to ditch the idea entirely and simply and make the transform functions take and return a <code>Box&lt;MyTrait&gt;</code>."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1477113429, "post_id": 40171815, "comment_id": 67644191, "body": "Do you mean that one or both of <code>T</code> and <code>U</code> are trait objects instead of concrete types?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1477113733, "post_id": 40171815, "comment_id": 67644241, "body": "Or is your problem fixed by changing the return value to <code>Box&lt;U&gt;</code>?  It would probably help to see the context (perhaps in a new question)."}, {"owner": {"reputation": 23, "user_id": 7051408, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7cef9659fb1f64453f66bbaf1bdadb2c?s=128&d=identicon&r=PG&f=1", "display_name": "moulins", "link": "https://stackoverflow.com/users/7051408/moulins"}, "edited": false, "score": 0, "creation_date": 1477117742, "post_id": 40171815, "comment_id": 67644973, "body": "I&#39;ve edited the main post with more details on the problem. (If I return Box&lt;U&gt;, then it becomes completely equivalent to <code>let val = Box::new(...); let val = transform1(val); let val = transform2(val); ...</code>, so it&#39;s useless)"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 2, "last_activity_date": 1477054964, "last_edit_date": 1477054964, "creation_date": 1477038489, "answer_id": 40171815, "question_id": 40169498, "link": "https://stackoverflow.com/questions/40169498/chaining-functions-on-a-trait/40171815#40171815", "title": "Chaining functions on a trait", "body": "<p>The full compiler message is:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0310]: the parameter type `U` may not live long enough\n--&gt; &lt;anon&gt;:7:3\n  |\n7 |   Box::new(f(*val))\n  |   ^^^^^^^^^^^^^^^^^\n  |\n  = help: consider adding an explicit lifetime bound `U: 'static`...\n  note:...so that the type `U` will meet its required lifetime bounds\n--&gt; &lt;anon&gt;:7:3\n  |\n7 |   Box::new(f(*val))\n  |   ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n</code></pre>\n\n<p>The compiler is saying that it needs <code>U</code> to live for the <code>'static</code> lifetime; what this really means is that any references inside it need to be valid for that lifetime, since the <code>Box</code> can live forever (as far as the compiler knows here).</p>\n\n<p>So the fix is simple: add <code>'static</code> to <code>U</code>'s bounds:</p>\n\n<pre><code>fn chain&lt;T, U, F&gt;(val: Box&lt;T&gt;, f: F) -&gt; Box&lt;MyTrait&gt;\n  where T: MyTrait,\n        U: MyTrait + 'static,\n        F: FnOnce(T) -&gt; U,\n{\n    Box::new(f(*val))\n}\n</code></pre>\n\n<p>Adding an extra bound <code>U: 'static</code> would also be equivalent.</p>\n"}], "owner": {"reputation": 23, "user_id": 7051408, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7cef9659fb1f64453f66bbaf1bdadb2c?s=128&d=identicon&r=PG&f=1", "display_name": "moulins", "link": "https://stackoverflow.com/users/7051408/moulins"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 91, "favorite_count": 0, "accepted_answer_id": 40171815, "answer_count": 1, "score": 2, "last_activity_date": 1477117554, "creation_date": 1477030126, "last_edit_date": 1477117554, "question_id": 40169498, "link": "https://stackoverflow.com/questions/40169498/chaining-functions-on-a-trait", "title": "Chaining functions on a trait", "body": "<p>I'm trying to make chainable transformations on a trait, and I'm having some issues.</p>\n\n<p>I have a bunch of transformation functions of the form:</p>\n\n<pre><code>fn transform&lt;T: MyTrait&gt;(in: T) -&gt; impl MyTrait\n</code></pre>\n\n<p>And I want a function <code>chain</code> which will allow me to do</p>\n\n<pre><code>let mut val: Box&lt;MyTrait&gt; = ...;\nval = chain(val, transform1);\nval = chain(val, transform2);\n...\n</code></pre>\n\n<p>I have written this function</p>\n\n<pre><code>fn chain&lt;T, U, F&gt;(val: Box&lt;T&gt;, f: F) -&gt; Box&lt;MyTrait&gt;\n  where T: MyTrait,\n        U: MyTrait,\n        F: FnOnce(T) -&gt; U {\n  Box::new(f(*val))\n}\n</code></pre>\n\n<p>But when I compile, the borrow checker tells me that the type parameter U doesn't live long enough. I'm pretty sure my trait bounds are what I want, and I've tried various things with lifetime specifiers, so I'm stuck :(</p>\n\n<p>P.S. : Is it possible to make the <code>chain</code> function generic on <code>MyTrait</code>? I don't think it's possible, but we never know...</p>\n\n<p><strong>EDIT</strong>:</p>\n\n<p>I've added the fix proposed by @chris-emerson in his answer, by as I've said in its comments, I have uncovered another problem which seems unresolvable.</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=a519f51db3f43191f354c40e85b79fe1&amp;version=nightly\" rel=\"nofollow\" title=\"Here\">Here</a> is a gist of the code, to not clutter this post.</p>\n\n<p>In short, the problem is: the chain function needs to dereference the <code>Box&lt;T&gt;</code> object and pass the <code>T</code> to the transform function, so <code>T</code> must be <code>Sized</code>. But the whole point of this function was to allow arbitrary (and unknown at compile-time) <code>MyTrait</code> implementations to be used. For example:</p>\n\n<pre><code>let mut val: Box&lt;MyTrait&gt; = ...;\n//here we can know the type inside the Box\nif ... {\n  val = chain(val, transform);\n}\n//but here we don't know anymore\n//(its either the original type,\n//or the type returned by transform)\n</code></pre>\n\n<p>So this design can't work unless the transform function can take a &amp;T or a &amp;mut T (which it can't, as I need to consume the input to produce the output).</p>\n"}, {"tags": ["error-handling", "rust"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1477029839, "post_id": 40169337, "comment_id": 67606827, "body": "There is no input handling in your code - only an undefined <code>enum</code> variant. Also, the <code>match</code> is exhaustive; no need for <code>_</code>, since all options for <code>Animal</code> are covered - anything else would be a plain type error, like in your case."}], "answers": [{"tags": [], "owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "is_accepted": true, "score": 4, "last_activity_date": 1477039420, "last_edit_date": 1495541957, "creation_date": 1477031668, "answer_id": 40169858, "question_id": 40169337, "link": "https://stackoverflow.com/questions/40169337/handling-input-data-undefined-error/40169858#40169858", "title": "Handling input data undefined error", "body": "<p>Rust is a strongly<sup>1</sup>, statically typed, compile-time type checked language.</p>\n\n<p>This means that unlike, say, Python, it is <strong>impossible</strong> for a user to pass an invalid type to your function (unless they're passing data that has been invalidly coerced via <code>unsafe</code>, but you can't reasonably detect this. See my <a href=\"https://stackoverflow.com/questions/36924530/transmuting-bool-to-u8/36927845#36927845\">post</a> about incorrect transmutations to <code>bool</code>). You do not need to worry about this.</p>\n\n<p>In the more general case, the only time you need to worry about type variant checking in Rust is when receiving data from outside Rust, e.g. through a configuration or data file, or else an FFI function. In these cases, it's customary to return a <code>Result&lt;Animal,ErrorMessage&gt;</code> of some sort to indicate bad data. However, in some cases, especially in FFI, if you receive data that's particularly malformed it may be acceptable to <code>panic!</code>.</p>\n\n<p>This type of checking usually does not involve <code>match</code> statements on an enum, but rather more fundamental checks such as assertions about string or integer comparisons being one of a set of known values that you're trying to reinterpret to a higher level enum type.</p>\n\n<hr>\n\n<p><sup>1</sup> There's some inconsistency and disagreement on what \"strongly typed\" actually means, in this case I'm using it to mean \"few if any implicit type coercions\".</p>\n"}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 85, "favorite_count": 0, "accepted_answer_id": 40169858, "answer_count": 1, "score": 2, "last_activity_date": 1477039420, "creation_date": 1477029400, "last_edit_date": 1495541957, "question_id": 40169337, "link": "https://stackoverflow.com/questions/40169337/handling-input-data-undefined-error", "title": "Handling input data undefined error", "body": "<p>Inspired by <a href=\"https://stackoverflow.com/questions/36590549/matching-on-a-reference-to-an-enum\">this question</a>, I want to ask about how to handle input data type error in Rust. For example, the following function require input data type to be <code>enum Animal</code>. How about the user actually give an input with not-defined data type or even a empty one.</p>\n\n<p>Should I add a <code>None =&gt; None</code> or <code>_ =&gt; None</code> in the match? </p>\n\n<pre><code>use std::fmt;\nuse std::io::prelude::*;\n\npub enum Animal {\n    Cat(String),\n    Dog,\n}\n\nimpl fmt::Display for Animal {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match *self {\n            Animal::Cat(ref c) =&gt; f.write_str(\"c\"),\n            Animal::Dog =&gt; f.write_str(\"d\"),\n        }\n    }\n}\n\nfn main() {\n    let p: Animal = Animal::Cat(\"whiskers\".to_owned()); // yes, work! \n    let p: Animal = Animal::BadCat(\"whiskers\".to_owned()); // Badcat not defined,??\n}\n</code></pre>\n\n<p>Compiler error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: no associated item named `BadCat` found for type `Animal` in the current scope\n  --&gt; &lt;anon&gt;:20:25\n   |\n20 |         let p: Animal = Animal::BadCat(\"whiskers\".to_owned()); // Badcat not defined,??\n   |                         ^^^^^^^^^^^^^^\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 13479, "user_id": 1830736, "user_type": "registered", "accept_rate": 98, "profile_image": "https://i.stack.imgur.com/gwUf7.jpg?s=128&g=1", "display_name": "George Hilliard", "link": "https://stackoverflow.com/users/1830736/george-hilliard"}, "is_accepted": true, "score": 3, "last_activity_date": 1477021232, "last_edit_date": 1477021232, "creation_date": 1477006798, "answer_id": 40166189, "question_id": 40165686, "link": "https://stackoverflow.com/questions/40165686/borrow-errors-for-multiple-borrows/40166189#40166189", "title": "Borrow errors for multiple borrows", "body": "<p>What you are trying to do is unsound.  It looks like you are attempting to create multiple <code>MyBorrows</code> which all mutably borrow the same value, and have them all alive at once (in the vector).  Such setups are exactly what Rust is designed to prevent, as that's how data races occur.</p>\n\n<p>What you might instead want to do is <em>im</em>mutably borrow the value a bunch, which is legal.  So after cleaning up the unnecessary mutable borrows, I've reduced the problem to:</p>\n\n<pre><code>struct MyBorrows&lt;'a&gt; {\n    val : &amp;'a i32\n}\n\nimpl &lt;'a&gt; MyBorrows&lt;'a&gt; {\n    fn new(v : &amp;'a i32) -&gt; MyBorrows&lt;'a&gt; {\n        MyBorrows { val : v }\n    }\n}\n\nfn main() {\n    let my_val = 23;\n    let mut my_vec = vec![];\n    my_vec.push(Box::new(MyBorrows::new(&amp;my_val)));\n    for _ in 1..4 {\n        let last = my_vec.last().unwrap();\n        let new_borrow = Box::new(MyBorrows::new(last.val));\n        my_vec.push(new_borrow);\n    }\n}\n</code></pre>\n\n<p>You get a slightly different error now:</p>\n\n<pre><code>error[E0502]: cannot borrow `my_vec` as mutable because it is also borrowed as immutable\n  --&gt; test.rs:18:9\n   |\n16 |         let last = my_vec.last().unwrap();\n   |                    ------ immutable borrow occurs here\n17 |         let new_borrow = Box::new(MyBorrows::new(last.val));\n18 |         my_vec.push(new_borrow);\n   |         ^^^^^^ mutable borrow occurs here\n19 |     }\n   |     - immutable borrow ends here\n\nerror: aborting due to previous error\n</code></pre>\n\n<p>This one is trickier, and you have to realize what is going on when you call <code>my_vec.last()</code> -- it's returning a reference to existing memory in the Vec, precluding anything else from touching the Vec.  Currently in Rust, this reference lives until the end of the current block.  To get around this, encase the mutable borrow in its own block scope:</p>\n\n<pre><code>fn main() {\n    let my_val = 23;\n    let mut my_vec = vec![];\n    my_vec.push(Box::new(MyBorrows::new(&amp;my_val)));\n    for _ in 1..4 {\n        let new_borrow;\n        {\n            let last = my_vec.last().unwrap();\n            new_borrow = Box::new(MyBorrows::new(last.val));\n        }\n        my_vec.push(new_borrow);\n    }\n}\n</code></pre>\n\n<p>Now the mutable borrow ends before the push occurs, and the lifetimes work.  Hopefully in the future, <a href=\"https://github.com/rust-lang/rfcs/issues/811\" rel=\"nofollow\">we will get non-lexical lifetimes</a> added to the language, so the compiler can figure out that my first example is actually safe.</p>\n"}], "owner": {"reputation": 24802, "user_id": 232918, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5897762377de1c8ffb9a98673262e91?s=128&d=identicon&r=PG", "display_name": "doron", "link": "https://stackoverflow.com/users/232918/doron"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 329, "favorite_count": 0, "accepted_answer_id": 40166189, "answer_count": 1, "score": 3, "last_activity_date": 1477021232, "creation_date": 1477003401, "last_edit_date": 1477003930, "question_id": 40165686, "link": "https://stackoverflow.com/questions/40165686/borrow-errors-for-multiple-borrows", "title": "Borrow errors for multiple borrows", "body": "<p>I am implementing an in-place recursive parser in rust and I am getting some borrow errors. The code snippet reproduces the problem although it is not very useful</p>\n\n<pre><code> use std::vec::Vec;\n\nstruct MyBorrows&lt;'a&gt; {\n    val : &amp;'a mut i32\n}\n\nimpl &lt;'a&gt; MyBorrows&lt;'a&gt; {\n    fn new(v : &amp;'a mut i32) -&gt; MyBorrows&lt;'a&gt; {\n        MyBorrows { val : v }\n    }\n}\n\nfn main() {\n    let mut my_val = 23;\n    let mut my_vec : Vec&lt;Box&lt;MyBorrows&gt;&gt; = Vec::new();\n    my_vec.push(Box::new(MyBorrows::new(&amp;mut my_val)));\n    for i in [1..4].iter() {\n        let mut last : &amp;mut Box&lt;MyBorrows&gt; = my_vec.last_mut().unwrap();\n        let mut new_borrow = Box::new(MyBorrows::new(last.val));\n        my_vec.push(new_borrow);        \n    }\n}\n</code></pre>\n\n<p>This gives me the following error:</p>\n\n<pre>\nerror[E0499]: cannot borrow `my_vec` as mutable more than once at a time\n  --> test.rs:20:9\n   |\n18 |         let mut last : &mut Box = my_vec.last_mut().unwrap();\n   |                                              ------ first mutable borrow occurs here\n19 |         let mut new_borrow = Box::new(MyBorrows::new(last.val));\n20 |         my_vec.push(new_borrow);\n   |         ^^^^^^ second mutable borrow occurs here\n21 |     }\n22 | }\n   | - first borrow ends here\n\nerror: aborting due to 3 previous errors\n\n</pre>\n\n<p>In my real case, the vector is used as a stack to reference deeper and deeper components of the <code>struct</code> I am parsing into. This is common pattern I use for general purpose parsing in C++ which I am trying to replicate in Rust but I am having problems. Any help will be appreciated.</p>\n"}, {"tags": ["struct", "rust"], "answers": [{"comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1476996528, "post_id": 40163688, "comment_id": 67597339, "body": "To implement <code>Decodable</code>, <code>Herd</code> does not need all its fields to be <code>Decodable</code>. That&#39;s only required when you want to derive a trait. In such cases it would just be easier to implement the trait manually."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477054792, "post_id": 40163688, "comment_id": 67621804, "body": "I think this answer would be better if it showed a snippet of how to do this. It would also be the only answer to answer the general question posed by OP, not the specific instance ^_^"}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477055100, "post_id": 40163688, "comment_id": 67621994, "body": "@Shepmaster I&#39;d like to, but <a href=\"http://stackoverflow.com/questions/39220694/cargo-on-windows-behind-a-corporate-proxy\">this issue</a> makes it hard for me to test code with <code>extern crate</code>s and I&#39;d hate to let some error slip through. I&#39;ll add it when I have some time and a proper network."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1477055192, "post_id": 40163688, "comment_id": 67622061, "body": "@mcarton I almost forgot; I fixed the answer like you suggested."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477056015, "post_id": 40163688, "comment_id": 67622616, "body": "<a href=\"http://play.integer32.com/?gist=0bf17d8ea1465e1a886f4caf254d17df&amp;version=stable\" rel=\"nofollow noreferrer\">Let me help you not do work at work</a>. Not all playgrounds are created equal ^_^."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1477061127, "post_id": 40163688, "comment_id": 67626417, "body": "@Shepmaster: &lt;3"}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 1, "last_activity_date": 1477061474, "last_edit_date": 1477061474, "creation_date": 1476994346, "answer_id": 40163688, "question_id": 40163538, "link": "https://stackoverflow.com/questions/40163538/how-to-implement-rustc-serializedecodable-for-struct-that-has-a-field-value-th/40163688#40163688", "title": "How to implement rustc_serialize::Decodable for struct that has a field value that is another struct?", "body": "<p>In order to be able to <code>derive</code> <code>Decodable</code> for <code>Herd</code>, <code>NaiveDate</code> would need to be <code>Decodable</code> too. Its <code>ymdf</code> field is private, though, which is an issue if you wanted to implement it manually.</p>\n\n<p>What you could do is define your own wrapper type for <code>ymdf</code> (and use it in <code>Herd</code>) - then you should be able to <code>derive</code> <code>Decodable</code> for it and then for <code>Herd</code>.</p>\n\n<p><strong>Edit</strong>: It's not necessarily the way to go with <code>NaiveDate</code>, as there is no easy way to convert <code>ymdf</code> into it (or to import <code>DateImpl</code>, its type), but depending on your needs the following way might be enough:</p>\n\n<pre><code>use std::i32;\n\npub type DateImpl = i32;\npub const MAX_YEAR: DateImpl = i32::MAX &gt;&gt; 13;\npub const MIN_YEAR: DateImpl = i32::MIN &gt;&gt; 13;\n\n#[derive(RustcDecodable)]\nstruct YmdfWrapper {\n    ymdf: DateImpl\n}\n\n#[derive(RustcDecodable)]\nstruct Herd {\n    id: i32,\n    breed: String,\n    name: String,\n    purchase_date: YmdfWrapper,\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": true, "score": 5, "last_activity_date": 1476996335, "creation_date": 1476996335, "answer_id": 40164215, "question_id": 40163538, "link": "https://stackoverflow.com/questions/40163538/how-to-implement-rustc-serializedecodable-for-struct-that-has-a-field-value-th/40164215#40164215", "title": "How to implement rustc_serialize::Decodable for struct that has a field value that is another struct?", "body": "<p><code>NaiveDate</code> does implement <code>Decodable</code> but under an optional feature <code>\"rustc-serialize\"</code>.</p>\n\n<p>You should add this in your <code>Cargo.toml</code> to activate it:</p>\n\n<pre><code>chrono = { version = \"0.2\", features = [\"rustc-serialize\"]}\n</code></pre>\n"}], "owner": {"reputation": 2912, "user_id": 5666325, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/adqCR.jpg?s=128&g=1", "display_name": "Hunter Lester", "link": "https://stackoverflow.com/users/5666325/hunter-lester"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 260, "favorite_count": 0, "accepted_answer_id": 40164215, "answer_count": 2, "score": 1, "last_activity_date": 1477061474, "creation_date": 1476993796, "last_edit_date": 1476994583, "question_id": 40163538, "link": "https://stackoverflow.com/questions/40163538/how-to-implement-rustc-serializedecodable-for-struct-that-has-a-field-value-th", "title": "How to implement rustc_serialize::Decodable for struct that has a field value that is another struct?", "body": "<p>I need to implement the <code>rustc_serialize::Decoder</code> trait for my <code>Herd</code> struct:</p>\n\n<pre><code>extern crate chrono;\nextern crate rustc_serialize;\n\nuse chrono::NaiveDate;\nuse rustc_serialize::Decodable;\n\nstruct Herd {\n    id: i32,\n    breed: String,\n    name: String,\n    purchase_date: NaiveDate,\n}\n\nimpl Decodable for Herd {\n    fn decode&lt;D: Decoder&gt;(d: &amp;mut D) -&gt; Result&lt;Herd, D::Error&gt; {\n        d.read_struct(\"Herd\", 4, |d| {\n            let id = try!(d.read_struct_field(\"id\", 0, |d| d.read_i32()));\n            let breed = try!(d.read_struct_field(\"breed\", 1, |d| d.read_str()));\n            let name = try!(d.read_struct_field(\"name\", 2, |d| d.read_str()));\n            let purchase_date = try!(d.read_struct_field(\"purchase_date\", 3, |i| {\n                i.read_struct(\"NaiveDate\", 1, |i| {\n                    let ymdf = try!(i.read_struct_field(\"ymdf\", 0, |i| i.read_i32()));\n                    Ok(NaiveDate { ymdf: ymdf })\n                })\n            }));\n\n            Ok(Herd {\n                id: id,\n                breed: breed,\n                name: name,\n                purchase_date: purchase_date,\n            })\n        })\n    }\n}\n</code></pre>\n\n<p>I'm unable to use <code>#[derive(RustcDecodable)]</code> because the following error occurs:  </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound chrono::NaiveDate: rustc_serialize::Decodable is not satisfied\n</code></pre>\n\n<p>I'm working on manually implementing <code>Decodable</code> and that's what you see in the code above. <a href=\"https://github.com/lifthrasiir/rust-chrono/blob/2dea325524c23c47d1172c75fee1da5dd05210af/src/naive/date.rs#L97\" rel=\"nofollow\"><code>NaiveDate</code> from the rust-chrono crate</a> is a struct with one field that is of data type <code>i32</code>.  </p>\n\n<p>When I run the code right now, I receive the message:  </p>\n\n<blockquote>\n  <p>field ymdf of struct chrono::NaiveDate is private</p>\n</blockquote>\n\n<p>How do I implement <code>Decoder</code> for <code>NaiveDate</code>? Is there a simpler way to implement <code>Decodable</code> for my <code>Herd</code> struct? I am an all-around beginner programmer; perhaps there is another way to look at this problem.</p>\n\n<p>I am using Rust 1.12 with the following dependencies:</p>\n\n<ul>\n<li><code>nickel = \"0.9.0\"</code></li>\n<li><code>postgres = { version = \"0.12\", features = [\"with-chrono\"]}</code></li>\n<li><code>chrono = \"0.2\"</code></li>\n<li><code>rustc-serialize = \"0.3\"</code></li>\n</ul>\n"}, {"tags": ["rust", "ffi"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1476972087, "post_id": 40156545, "comment_id": 67581915, "body": "Vec to Array conversion is <a href=\"http://stackoverflow.com/a/37682288/147192\">covered here</a>, so you might want to focus on the first question (vector of unknown size instead). However this question does not match the title, so it&#39;s confusing."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1476972180, "post_id": 40156545, "comment_id": 67581996, "body": "I&#39;m not an expert on FFI, but if you can go with <code>values: Box&lt;[i32]&gt;</code> in your <code>array_and_size</code>, you could just convert the relevant <code>Vec</code>tors to it using <code>into_boxed_slice()</code>."}, {"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1476972363, "post_id": 40156545, "comment_id": 67582125, "body": "The compiler did not complain when I set <code>values: Box&lt;[i32]&gt;</code> but I guess Rust must convert this into a valid C struct somehow, because C does not use Boxes I guess."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1476972372, "post_id": 40156545, "comment_id": 67582131, "body": "C doesn&#39;t <b>have</b> fixed length arrays, that&#39;s why it&#39;s not covered in the Omnibus."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1476972599, "post_id": 40156545, "comment_id": 67582316, "body": "@Shepmaster: Note that the OP is using a fixed-length array <i>within a <code>struct</code></i>, which is perfectly valid C. What C does not allow is receiving arrays as parameters or returning them from functions."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 2, "creation_date": 1476972658, "post_id": 40156545, "comment_id": 67582357, "body": "@ljedrz: C does not have <code>Box</code>, but from <code>Box</code> you can further convert to a raw pointer. Of course freeing that memory back afterward is another story altogether."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1476972864, "post_id": 40156545, "comment_id": 67582512, "body": "@MatthieuM. hmm, interesting point! I don&#39;t know if I&#39;d trust that it correctly crosses FFI, as a Rust array would have the size baked-in (right?) and the C declaration would be closer to &quot;allocate a sequential blob of memory&quot; without the size... experimentation is needed!"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1476972926, "post_id": 40156545, "comment_id": 67582555, "body": "@Shepmaster: <code>[i32; 3]</code> has the size baked in as part of its type (much like in C), so there is no overhead. You are thinking of <code>[i32]</code> which is slightly different (though still named array, I think)."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1476973089, "post_id": 40156545, "comment_id": 67582672, "body": "@TheUnfunCat: You don&#39;t have to delete the question, but maybe some editing to focus on what you really need (the root problem) would let people more leeway for the best answer rather than artificially constraining it."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1476973934, "post_id": 40156545, "comment_id": 67583448, "body": "@MatthieuM. I was mostly thinking of how the slice can be built for free from an array, thinking there must be a size in there."}, {"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477031417, "post_id": 40156545, "comment_id": 67607552, "body": "I think I have simplified my question so that it is much easier to answer and more useful for others to look up. Thanks for the feedback! Edit: Made further changes."}], "answers": [{"comments": [{"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477054173, "post_id": 40170400, "comment_id": 67621358, "body": "I updated your rust_alloc to take a pointer to my <code>Rle</code> struct, from which I fetch the <code>Rle.values</code> vector. Problem is, I get an error in the line <code>array: values.into_boxed_slice().into_raw() as *mut _,</code>. I think this has to do with the fact that my Rle is boxed, so that the vector it contains also is. Anyways, this is the error: <code>error: no method named </code>into_raw` found for type <code>Box&lt;[i32]&gt;</code> in the current scope`. This might be a completely different problem: should I ask a new q about this, or is it trivial to fix?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477055085, "post_id": 40170400, "comment_id": 67621979, "body": "@TheUnfunCat: Hitting the same error... I did not expect it given <a href=\"https://doc.rust-lang.org/src/alloc/up/src/liballoc/boxed.rs.html#266\" rel=\"nofollow noreferrer\">the signature</a> and the fact that <code>T: ?Sized</code> in the bounds. I must be missing something..."}, {"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477055213, "post_id": 40170400, "comment_id": 67622076, "body": "Okay, so it has nothing to do with my vector being in a Boxed struct then, since you are just using a regular vector. I&#39;m sure it is just a minor tweak that is needed :)"}, {"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477056501, "post_id": 40170400, "comment_id": 67622959, "body": "Perhaps add a warning to the top that this isn&#39;t working just yet? Or perhaps ask a q about why? No shame in asking..."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477057298, "post_id": 40170400, "comment_id": 67623532, "body": "@TheUnfunCat: I am going to ask, I reduced the problem as much as I could and it still is persisting... and I have no idea why. In the mean time I switched to teasing the vector apart, which compiles (at least), so you don&#39;t have to wait for it ;)"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1477058033, "post_id": 40170400, "comment_id": 67624063, "body": "@TheUnfunCat: Found it! One must call Box::into_raw(...) because into_raw was NOT defined with self as a parameter. (Why? no idea)"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 4, "last_activity_date": 1477057203, "last_edit_date": 1477057203, "creation_date": 1477033700, "answer_id": 40170400, "question_id": 40156545, "link": "https://stackoverflow.com/questions/40156545/how-do-i-return-an-vector-of-dynamic-length-in-a-pub-extern-c-fn/40170400#40170400", "title": "How do I return an vector of dynamic length in a pub extern &quot;C&quot; fn?", "body": "<p>There are multiple ways to pass an array to C.</p>\n\n<hr>\n\n<p>First of all, while C <em>has</em> the concept of fixed-size arrays (<code>int a[5]</code> has type <code>int[5]</code> and <code>sizeof(a)</code> will return <code>5 * sizeof(int)</code>), it is not possible to directly pass an array to a function or return an array from it.</p>\n\n<p>On the other hand, it is possible to wrap a fixed size array in a <code>struct</code> and return that <code>struct</code>.</p>\n\n<p>Furthermore, when using an array, all elements must be initialized, otherwise a <code>memcpy</code> technically has undefined behavior (as it is reading from undefined values) and valgrind will definitely report the issue.</p>\n\n<hr>\n\n<p><strong>Using a dynamic array</strong></p>\n\n<p>A dynamic array is an array whose length is unknown at compile-time.</p>\n\n<p>One may chose to return a dynamic array if no reasonable upper-bound is known, or this bound is deemed too large for passing by value.</p>\n\n<p>There are two ways to handle this situation:</p>\n\n<ul>\n<li>ask C to pass a suitably sized buffer</li>\n<li>allocate a buffer and return it to C</li>\n</ul>\n\n<p>They differ in who allocates the memory: the former is simpler, but may require to either have a way to hint at a suitable size or to be able to \"rewind\" if the size proves unsuitable.</p>\n\n<p><em>Ask C to pass a suitable sized buffer</em></p>\n\n<pre><code>// file.h\nint rust_func(int32_t* buffer, size_t buffer_length);\n\n// file.rs\n#[no_mangle]\npub extern fn rust_func(buffer: *mut libc::int32_t, buffer_length: libc::size_t) -&gt; libc::c_int {\n    // your code here\n}\n</code></pre>\n\n<p>Note the existence of <a href=\"https://doc.rust-lang.org/std/slice/fn.from_raw_parts_mut.html\" rel=\"nofollow\"><code>std::slice::from_raw_parts_mut</code></a> to transform this pointer + length into a mutable slice (do initialize it with 0s before making it a slice or ask the client to).</p>\n\n<p><em>Allocate a buffer and return it to C</em></p>\n\n<pre><code>// file.h\nstruct DynArray {\n    int32_t* array;\n    size_t length;\n}\n\nDynArray rust_alloc();\nvoid rust_free(DynArray);\n\n// file.rs\n#[repr(C)]\nstruct DynArray {\n    array: *mut libc::int32_t,\n    length: libc::size_t,\n}\n\n#[no_mangle]\npub extern fn rust_alloc() -&gt; DynArray {\n    let mut v: Vec&lt;i32&gt; = vec!(...);\n\n    let result = DynArray {\n        array: v.as_mut_ptr(),\n        length: v.len() as _,\n    };\n\n    std::mem::forget(v);\n\n    result\n}\n\n#[no_mangle]\npub extern fn rust_free(array: DynArray) {\n    if !array.array.is_null() {\n        unsafe { Box::from_raw(array.array); }\n    }\n}\n</code></pre>\n\n<hr>\n\n<p><strong>Using a fixed-size array</strong></p>\n\n<p>Similarly, a <code>struct</code> containing a fixed size array can be used. Note that both in Rust and C all elements should be initialized, even if unused; zeroing them works well.</p>\n\n<p>Similarly to the dynamic case, it can be either passed by mutable pointer or returned by value.</p>\n\n<pre><code>// file.h\nstruct FixedArray {\n    int32_t array[32];\n};\n\n// file.rs\n#[repr(C)]\nstruct FixedArray {\n    array: [libc::int32_t; 32],\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "is_accepted": true, "score": 6, "last_activity_date": 1477038229, "last_edit_date": 1477038229, "creation_date": 1477034679, "answer_id": 40170699, "question_id": 40156545, "link": "https://stackoverflow.com/questions/40156545/how-do-i-return-an-vector-of-dynamic-length-in-a-pub-extern-c-fn/40170699#40170699", "title": "How do I return an vector of dynamic length in a pub extern &quot;C&quot; fn?", "body": "<pre><code>pub struct array_and_size {\n    values: int64_t, // this is probably not how you denote a pointer, right?\n    size: int32_t,\n}\n</code></pre>\n\n<p>First of all, you're correct. The type you want for <code>values</code> is <code>*mut int32_t</code>.</p>\n\n<p>In general, and note that there are a variety of C coding styles, C often doesn't \"like\" returning ad-hoc sized array structs like this. The more common C API would be</p>\n\n<pre><code>int32_t rle_values_size(RLE *rle);\nint32_t *rle_values(RLE *rle);\n</code></pre>\n\n<p>(Note: many internal programs do in fact use sized array structs, but this is by far the most common for user-facing libraries because it's automatically compatible with the most basic way of representing arrays in C).</p>\n\n<p>In Rust, this would translate to:</p>\n\n<pre><code>extern \"C\" fn rle_values_size(rle: *mut RLE) -&gt; int32_t\nextern \"C\" fn rle_values(rle: *mut RLE) -&gt; *mut int32_t\n</code></pre>\n\n<p>The <code>size</code> function is straightforward, to return the array, simply do</p>\n\n<pre><code>extern \"C\" fn rle_values(rle: *mut RLE) -&gt; *mut int32_t {\n    unsafe { &amp;mut (*rle).values[0] }\n}\n</code></pre>\n\n<p>This gives a raw pointer to the first element of the <code>Vec</code>'s underlying buffer, which is all C-style arrays really are.</p>\n\n<p>If, instead of giving C a reference to your data you want to <strong>give</strong> C the data, the most common option would be to allow the user to pass in a buffer that you clone the data into:</p>\n\n<pre><code>extern \"C\" fn rle_values_buf(rle: *mut RLE, buf: *mut int32_t, len: int32_t) {\n    use std::{slice,ptr}\n    unsafe {\n        // Make sure we don't overrun our buffer's length\n        if len &gt; (*rle).values.len() {\n           len = (*rle).values.len()\n        }\n        ptr::copy_nonoverlapping(&amp;(*rle).values[0], buf, len as usize);\n    }\n}\n</code></pre>\n\n<p>Which, from C, looks like</p>\n\n<pre><code>void rle_values_buf(RLE *rle, int32_t *buf, int32_t len);\n</code></pre>\n\n<p>This (shallowly) copies your data into the presumably C-allocated buffer, which the C user is then responsible for destroying. It also prevents multiple mutable copies of your array from floating around at the same time (assuming you don't implement the version that returns a pointer).</p>\n\n<p>Note that you could sort of \"move\" the array into C as well, but it's not particularly recommended and involves the use <code>mem::forget</code> and expecting the C user to explicitly call a destruction function, as well as requiring both you and the user to obey some discipline that may be difficult to structure the program around.</p>\n\n<p>If you want to <strong>receive</strong> an array from C, you essentially just ask for both a <code>*mut i32</code> and <code>i32</code> corresponding to the buffer start and length. You can assemble this into a slice using the <code>from_raw_parts</code> function, and then use the <code>to_vec</code> function to create an owned Vector containing the values allocated from the Rust side. If you don't plan on needing to own the values, you can simply pass around the slice you produced via <code>from_raw_parts</code>.</p>\n\n<p>However, it is imperative that all values be initialized from either side, typically to zero. Otherwise you invoke legitimately undefined behavior which often results in segmentation faults (which tend to frustratingly disappear when inspected with GDB).</p>\n"}], "owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2001, "favorite_count": 3, "accepted_answer_id": 40170699, "answer_count": 2, "score": 6, "last_activity_date": 1522530959, "creation_date": 1476971810, "last_edit_date": 1522530959, "question_id": 40156545, "link": "https://stackoverflow.com/questions/40156545/how-do-i-return-an-vector-of-dynamic-length-in-a-pub-extern-c-fn", "title": "How do I return an vector of dynamic length in a pub extern &quot;C&quot; fn?", "body": "<p>I want to return a vector in a <code>pub extern \"C\" fn</code>. Since a vector has an arbitrary length, I guess I need to return a struct with </p>\n\n<ol>\n<li><p>the pointer to the vector, and</p></li>\n<li><p>the number of elements in the vector</p></li>\n</ol>\n\n<p>My current code is:</p>\n\n<pre><code>extern crate libc;\nuse self::libc::{size_t, int32_t, int64_t};\n\n// struct to represent an array and its size\n#[repr(C)]\npub struct array_and_size {\n    values: int64_t, // this is probably not how you denote a pointer, right?\n    size: int32_t,\n}\n\n// The vector I want to return the address of is already in a Boxed struct, \n// which I have a pointer to, so I guess the vector is on the heap already. \n// Dunno if this changes/simplifies anything?\n#[no_mangle]\npub extern \"C\" fn rle_show_values(ptr: *mut Rle) -&gt; array_and_size {\n    let rle = unsafe {\n        assert!(!ptr.is_null());\n        &amp;mut *ptr\n    };\n\n    // this is the Vec&lt;i32&gt; I want to return \n    // the address and length of\n    let values = rle.values; \n    let length = values.len();\n\n    array_and_size {\n       values: Box::into_raw(Box::new(values)),\n       size: length as i32,\n       }\n}\n\n#[derive(Debug, PartialEq)]\npub struct Rle {\n    pub values: Vec&lt;i32&gt;,\n}\n</code></pre>\n\n<p>The error I get is </p>\n\n<pre><code>$ cargo test\n   Compiling ranges v0.1.0 (file:///Users/users/havpryd/code/rust-ranges)\nerror[E0308]: mismatched types\n  --&gt; src/rle.rs:52:17\n   |\n52 |         values: Box::into_raw(Box::new(values)),\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected i64, found *-ptr\n   |\n   = note: expected type `i64`\n   = note:    found type `*mut std::vec::Vec&lt;i32&gt;`\n\nerror: aborting due to previous error\n\nerror: Could not compile `ranges`.\n\nTo learn more, run the command again with --verbose.\n-&gt; exit code: 101\n</code></pre>\n\n<p>I posted the whole thing because I could not find an example of returning arrays/vectors in the eminently useful <a href=\"http://jakegoulding.com/rust-ffi-omnibus/\" rel=\"nofollow\">Rust FFI Omnibus</a>.</p>\n\n<p>Is this the best way to return a vector of unknown size from Rust? How do I fix my remaining compile error? Thanks!</p>\n\n<p>Bonus q: if the fact that my vector is in a struct changes the answer, perhaps you could also show how to do this if the vector was not in a Boxed struct already (which I think means the vector it owns is on the heap too)? I guess many people looking up this q will not have their vectors boxed already. </p>\n\n<p>Bonus q2: I only return the vector to view its values (in Python), but I do not want to let the calling code change the vector. But I guess there is no way to make the memory read-only and ensure the calling code does not fudge with the vector? <code>const</code> is just for showing intent, right?</p>\n\n<p>Ps: I do not know C or Rust well, so my attempt might be completely WTF. </p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 0, "creation_date": 1476965963, "post_id": 40154225, "comment_id": 67577258, "body": "Thanks. Does the <code>&lt;_&gt;</code> mean something like &quot;please infer the type&quot;?"}, {"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 4, "creation_date": 1476965968, "post_id": 40154225, "comment_id": 67577263, "body": "You don&#39;t need to collect <code>Skip</code> as <code>extend</code> can take an iterator"}, {"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "reply_to_user": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "edited": false, "score": 1, "creation_date": 1476966047, "post_id": 40154225, "comment_id": 67577322, "body": "@TheUnfunCat Yes, <code>_</code> is a type placeholder"}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": true, "score": 7, "last_activity_date": 1476967216, "last_edit_date": 1476967216, "creation_date": 1476965854, "answer_id": 40154225, "question_id": 40154150, "link": "https://stackoverflow.com/questions/40154150/how-do-i-concatenate-two-slices-in-rust/40154225#40154225", "title": "How do I concatenate two slices in Rust?", "body": "<p>You should <code>collect()</code> the results of the <code>take()</code> and <code>extend()</code> them with the <code>collect()</code>ed results of <code>skip()</code>:</p>\n\n<pre><code>let mut p1 = v.iter().take(3).collect::&lt;Vec&lt;_&gt;&gt;();\nlet p2 = v.iter().skip(l-3);\n\np1.extend(p2);\n\nprintln!(\"{:?}\", p1);\n</code></pre>\n\n<p><strong>Edit</strong>: as Neikos said, you don't even need to collect the result of <code>skip()</code>, since <code>extend()</code> accepts arguments implementing <code>IntoIterator</code> (which <code>Skip</code> does, as it is an <code>Iterator</code>).</p>\n\n<p><strong>Edit 2</strong>: your numbers are a bit off, though; in order to get <code>1, 2, 3, 8, 9, 10</code> you should declare <code>v</code> as follows:</p>\n\n<pre><code>let v = (1u64 .. 11).collect::&lt;Vec&lt;_&gt;&gt;();\n</code></pre>\n\n<p>Since the <a href=\"https://doc.rust-lang.org/stable/std/ops/struct.Range.html\" rel=\"noreferrer\"><code>Range</code></a> is left-closed and right-open.</p>\n"}, {"comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1476967819, "post_id": 40154795, "comment_id": 67578561, "body": "<code>extend()</code> should shortly be specialized to <code>extend_from_slice()</code>; it was merged a few days ago: <a href=\"https://github.com/rust-lang/rust/pull/37094\" rel=\"nofollow noreferrer\">Specialize Vec::extend to Vec::extend_from_slice</a>."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1477007795, "post_id": 40154795, "comment_id": 67601195, "body": "Stable release of which is... 9-ish weeks away?  Like I said, not <i>just yet.</i>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1477016062, "post_id": 40154795, "comment_id": 67603010, "body": "<code>let v = (1u64 .. 11).collect::&lt;Vec&lt;_&gt;&gt;();</code> booo. <code>let v: Vec&lt;u64&gt; = (1..11).collect();</code> yaaay"}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1477018543, "post_id": 40154795, "comment_id": 67603573, "body": "Why yes, just letting you know if you haven&#39;t seen that it was already merged."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 17, "last_activity_date": 1477007819, "last_edit_date": 1477007819, "creation_date": 1476967288, "answer_id": 40154795, "question_id": 40154150, "link": "https://stackoverflow.com/questions/40154150/how-do-i-concatenate-two-slices-in-rust/40154795#40154795", "title": "How do I concatenate two slices in Rust?", "body": "<p>Ok, first of all, your initial sequence definition is wrong.  You say you want <code>1, 2, 3, 8, 9, 10</code> as output, so it should look like:</p>\n\n<pre><code>    let v = (1u64 .. 11).collect::&lt;Vec&lt;_&gt;&gt;();\n</code></pre>\n\n<p>Next, you say you want to concatenate <em>slices</em>, so let's actually use slices:</p>\n\n<pre><code>    let head = &amp;v[..3];\n    let tail = &amp;v[l-3..];\n</code></pre>\n\n<p>At <em>this</em> point, it's really down to which approach you like the most.  You can turn those slices into iterators, chain, then collect...</p>\n\n<pre><code>    let v2: Vec&lt;_&gt; = head.iter().chain(tail.iter()).collect();\n</code></pre>\n\n<p>...or make a vec and extend it with the slices directly...</p>\n\n<pre><code>    let mut v3 = vec![];\n    v3.extend_from_slice(head);\n    v3.extend_from_slice(tail);\n</code></pre>\n\n<p>...or extend using more general iterators (which will become equivalent in the future with specialisation, but I don't believe it's as efficient <em>just yet</em>)...</p>\n\n<pre><code>    let mut v4: Vec&lt;u64&gt; = vec![];\n    v4.extend(head);\n    v4.extend(tail);\n</code></pre>\n\n<p>...or you could use <code>Vec::with_capacity</code> and <code>push</code> in a loop, or do the chained iterator thing, but using <code>extend</code>... but I have to stop at <em>some</em> point.</p>\n\n<p>Full example code:</p>\n\n<pre><code>fn main() {\n    let v = (1u64 .. 11).collect::&lt;Vec&lt;_&gt;&gt;();\n    let l = v.len();\n\n    let head = &amp;v[..3];\n    let tail = &amp;v[l-3..];\n\n    println!(\"head: {:?}\", head);\n    println!(\"tail: {:?}\", tail);\n\n    let v2: Vec&lt;_&gt; = head.iter().chain(tail.iter()).collect();\n    println!(\"v2: {:?}\", v2);\n\n    let mut v3 = vec![];\n    v3.extend_from_slice(head);\n    v3.extend_from_slice(tail);\n    println!(\"v3: {:?}\", v3);\n\n    // Explicit type to help inference.\n    let mut v4: Vec&lt;u64&gt; = vec![];\n    v4.extend(head);\n    v4.extend(tail);\n    println!(\"v4: {:?}\", v4);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1253, "user_id": 103192, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a0a0bf451db6d1e06be88b4ce3cd72a1?s=128&d=identicon&r=PG", "display_name": "Rawler", "link": "https://stackoverflow.com/users/103192/rawler"}, "edited": false, "score": 1, "creation_date": 1597766400, "post_id": 40166506, "comment_id": 112238471, "body": "Nice, but seem to require nightly"}], "tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": false, "score": 34, "last_activity_date": 1597253779, "last_edit_date": 1597253779, "creation_date": 1477009231, "answer_id": 40166506, "question_id": 40154150, "link": "https://stackoverflow.com/questions/40154150/how-do-i-concatenate-two-slices-in-rust/40166506#40166506", "title": "How do I concatenate two slices in Rust?", "body": "<p>Just use <a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.concat\" rel=\"noreferrer\"><code>.concat()</code></a> on a slice of slices:</p>\n<pre><code>fn main() {\n    let v = (0u64 .. 10).collect::&lt;Vec&lt;_&gt;&gt;();\n    let l = v.len();\n    let first_and_last = [&amp;v[..3], &amp;v[l - 3..]].concat();\n    println!(&quot;{:?}&quot;, first_and_last);\n    // The output is `[0, 1, 2, 7, 8, 9]`\n}\n</code></pre>\n<p>This creates a new vector, and it works with arbitrary number of slices.</p>\n<p><a href=\"https://play.rust-lang.org/?gist=c9414c870b2792b67eba9b959868f772&amp;version=stable&amp;backtrace=1\" rel=\"noreferrer\">(Playground link)</a></p>\n"}], "owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 17073, "favorite_count": 2, "accepted_answer_id": 40154225, "answer_count": 3, "score": 19, "last_activity_date": 1597253779, "creation_date": 1476965668, "last_edit_date": 1476966033, "question_id": 40154150, "link": "https://stackoverflow.com/questions/40154150/how-do-i-concatenate-two-slices-in-rust", "title": "How do I concatenate two slices in Rust?", "body": "<p>I want to take the x first and last elements from a vector and concatenate them. I have the following code:</p>\n\n<pre><code>fn main() {\n    let v = (0u64 .. 10).collect::&lt;Vec&lt;_&gt;&gt;();\n    let l = v.len();\n    vec![v.iter().take(3), v.iter().skip(l-3)];\n}\n</code></pre>\n\n<p>This gives me the error </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; &lt;anon&gt;:4:28\n  |\n4 |     vec![v.iter().take(3), v.iter().skip(l-3)];\n  |                            ^^^^^^^^^^^^^^^^^^ expected struct `std::iter::Take`, found struct `std::iter::Skip`\n&lt;anon&gt;:4:5: 4:48 note: in this expansion of vec! (defined in &lt;std macros&gt;)\n  |\n  = note: expected type `std::iter::Take&lt;std::slice::Iter&lt;'_, u64&gt;&gt;`\n  = note:    found type `std::iter::Skip&lt;std::slice::Iter&lt;'_, u64&gt;&gt;`\n</code></pre>\n\n<p>How do I get my <code>vec</code> of <code>1, 2, 3, 8, 9, 10</code>? I am using Rust 1.12.</p>\n"}, {"tags": ["rust", "constants", "inline"], "answers": [{"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 1, "last_activity_date": 1476954787, "last_edit_date": 1476954787, "creation_date": 1476949297, "answer_id": 40148307, "question_id": 40148175, "link": "https://stackoverflow.com/questions/40148175/what-does-it-mean-for-a-constant-value-in-rust-to-be-inlined/40148307#40148307", "title": "What does it mean for a constant value in Rust to be inlined?", "body": "<p>A <code>const</code>ant doesn't behave like a regular variable at all; when you define one it doesn't even get its own scope for borrow-checking purposes.</p>\n\n<p>Compare the MIR generated by the following pieces of code:</p>\n\n<pre><code>fn main() {\n    const N: i32 = 5;\n}\n</code></pre>\n\n<p>and</p>\n\n<pre><code>fn main() {\n    let n: i32 = 5;\n}\n</code></pre>\n\n<p>And you will find that what <code>N</code> expands to looks more like a function than a variable:</p>\n\n<pre><code>const main::N: i32 = {\n    let mut _0: i32;                     // return pointer\n\n    bb0: {\n        _0 = const 5i32;                 // scope 0 at &lt;anon&gt;:2:20: 2:21\n        return;                          // scope 0 at &lt;anon&gt;:2:5: 2:22\n    }\n}\n</code></pre>\n\n<p>When it is used in an expression, its value is placed on the stack for the purpose of that expression and is forgotten right afterwards.</p>\n\n<p><strong>Edit</strong>: at least this is what happens on MIR level. I'm not an expert on low-level optimizations, so the actual outcome (whether stack memory was actually used) would have to be checked in LLVM or even ASM. Note that this is also applicable to regular variables, though.</p>\n"}, {"comments": [{"owner": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "edited": false, "score": 0, "creation_date": 1476963717, "post_id": 40149323, "comment_id": 67575686, "body": "Can you explain why C++ enum is the closest thing?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "edited": false, "score": 2, "creation_date": 1476964384, "post_id": 40149323, "comment_id": 67576218, "body": "@PavelStrakhov: an <code>enum</code> value in C++ is a named value with no memory address (if you have <code>enum { X };</code> then <code>&amp;X</code> will raise a compile-time error), and the value of the enum is inlined at each and every site of use. It&#39;s a bit closer than a <code>#define</code> because it&#39;s only computed once (and it&#39;s also much cleaner: respects scopes, etc...)."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 2, "creation_date": 1476965094, "post_id": 40149323, "comment_id": 67576717, "body": "You make it sound like the compiler may decide to convert it into a <code>static</code> to avoid copies, but is that really the case? I don&#39;t seem to be able to get the compiler to do it; it always produces code equivalent to inlining the expression, even when it&#39;s obviously suboptimal."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 0, "creation_date": 1476966311, "post_id": 40149323, "comment_id": 67577495, "body": "@Veedrac: I thought rustc behaved like Clang in this regard, but my memories may be playing tricks on me here, especially since I thought way too much about <code>const fn</code> and what values may ultimately be stored in <code>const</code> (like <code>String</code>, <code>HashMap</code> but not <code>Arc</code> or <code>RefCell</code> because interior mutability prevents storage in ROM). I suppose that&#39;s one more instance of the work being pushed down to LLVM then :x"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 2, "creation_date": 1476968459, "post_id": 40149323, "comment_id": 67579011, "body": "@Veedrac: I checked a few variations on the playground and indeed rustc emits the definition inline in IR. Of course, in Release, LLVM just constant-folds it and you end up with the integer directly in a register."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 8, "last_activity_date": 1561566154, "last_edit_date": 1561566154, "creation_date": 1476952428, "answer_id": 40149323, "question_id": 40148175, "link": "https://stackoverflow.com/questions/40148175/what-does-it-mean-for-a-constant-value-in-rust-to-be-inlined/40149323#40149323", "title": "What does it mean for a constant value in Rust to be inlined?", "body": "<blockquote>\n  <p>I've only seen \"inline functions\" in C++, but never inline constant values. </p>\n</blockquote>\n\n<p>The closest approximate to a <code>const</code> in Rust is an <code>enum</code> in C++.</p>\n\n<blockquote>\n  <p>What is a beginner friendly explanation of how this works? </p>\n</blockquote>\n\n<p>The simple beginner's explanation is: it just works, don't worry about the nitty-gritty details.</p>\n\n<blockquote>\n  <p>I'm also confused by \"no fixed address in memory\". Does that mean every time we use a <code>const</code> value, a value on the <em>stack</em> is allocated just for this expression and after the expression is done executing, it'll be <em>destroyed</em>?</p>\n</blockquote>\n\n<p>Yes. Maybe. No.</p>\n\n<p>It means exactly what it says on the tin: <em>no guarantee is made</em>. This leaves the compiler with the maximum freedom to optimize things.</p>\n\n<hr>\n\n<p>Alright, that's all good and well, but... what really happens?</p>\n\n<p>In practice, there are two situations:</p>\n\n<ul>\n<li>the value is simple enough: it does not even touch the stack, and instead is hardcoded directly in the assembly. This is most likely to happen for integers, for example.</li>\n<li>the value is not that simple: it is created in read-only memory, and referenced/copied from there. Multiple copies on the stack will have different addresses.</li>\n</ul>\n\n<p>What does simple mean? Well, it depends. For each call site the compiler may decide \"simple enough\" or not, which is where it is close to inlining.</p>\n\n<blockquote>\n  <p>Does that mean every time we use a <code>const</code> value, a value on the <em>stack</em> is allocated just for this expression and after the expression is done executing, it'll be <em>destroyed</em>?</p>\n</blockquote>\n\n<p>It will not be destroyed. <code>const</code> variables cannot have a type that implements <code>Drop</code>. The value is just <em>forgotten</em> when it is no longer used. If it ever occupied memory on the stack, this memory will be overwritten sometime later.</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1476952477, "post_id": 40149326, "comment_id": 67567807, "body": "I&#39;d rather compare it to an <code>enum</code> than a <code>#define</code>, since <code>enum</code> have (some) more type safety."}], "tags": [], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "is_accepted": false, "score": 5, "last_activity_date": 1476952435, "creation_date": 1476952435, "answer_id": 40149326, "question_id": 40148175, "link": "https://stackoverflow.com/questions/40148175/what-does-it-mean-for-a-constant-value-in-rust-to-be-inlined/40149326#40149326", "title": "What does it mean for a constant value in Rust to be inlined?", "body": "<p><code>const N: i32 = 5</code> in Rust is like <code>#define N 5</code> in C or C++ done with type-safety.</p>\n\n<p>You can think of it like a textual substitution when the type matches, that is, <code>let foo = 32 + N;</code> is equivalent to <code>let foo = 32 + 5;</code> in your example.</p>\n"}], "owner": {"reputation": 514, "user_id": 1375259, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/yuWQ9.jpg?s=128&g=1", "display_name": "Chakravarthy Raghunandan", "link": "https://stackoverflow.com/users/1375259/chakravarthy-raghunandan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 948, "favorite_count": 1, "accepted_answer_id": 40149323, "answer_count": 3, "score": 7, "last_activity_date": 1561566154, "creation_date": 1476948849, "last_edit_date": 1561566009, "question_id": 40148175, "link": "https://stackoverflow.com/questions/40148175/what-does-it-mean-for-a-constant-value-in-rust-to-be-inlined", "title": "What does it mean for a constant value in Rust to be inlined?", "body": "<p>The <a href=\"https://doc.rust-lang.org/1.30.0/book/first-edition/const-and-static.html\" rel=\"nofollow noreferrer\">documentation for <code>const</code></a>:</p>\n\n<blockquote>\n  <p>Constants live for the entire lifetime of a program. More specifically, constants in Rust have no fixed address in memory. This is because they\u2019re effectively inlined to each place that they\u2019re used. References to the same constant are not necessarily guaranteed to refer to the same memory address for this reason.</p>\n</blockquote>\n\n<p>I've only seen \"inline functions\" in C++, but never inline constant values. What is a beginner friendly explanation of how this works? </p>\n\n<p>I'm also confused by \"no fixed address in memory\". Does that mean every time we use a <code>const</code> value, a value on the <em>stack</em> is allocated just for this expression and after the expression is done executing, it'll be <em>destroyed</em>?</p>\n"}, {"tags": ["rust", "traits", "generic-programming", "type-level-computation"], "answers": [{"comments": [{"owner": {"reputation": 1259, "user_id": 1814775, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/ea9a58ab403c34bc21cde3a006d2e6d8?s=128&d=identicon&r=PG", "display_name": "lloydmeta", "link": "https://stackoverflow.com/users/1814775/lloydmeta"}, "edited": false, "score": 0, "creation_date": 1476963890, "post_id": 40147686, "comment_id": 67575825, "body": "Thanks ! This was exactly what I was looking for. Specifying RHS as the generic parameter was the missing part of the puzzle in my case."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 8, "last_activity_date": 1476947309, "creation_date": 1476947309, "answer_id": 40147686, "question_id": 40147440, "link": "https://stackoverflow.com/questions/40147440/getting-the-associated-output-type-of-an-add-implementation-given-lhs-and-rhs-ty/40147686#40147686", "title": "Getting the associated Output type of an Add implementation given LHS and RHS types", "body": "<p>There is, although it does look like a bit of black magic.</p>\n\n<p>You need to combine 3 bits of syntax:</p>\n\n<ul>\n<li>the trait implementation of a type is accessible via <code>&lt;Type as Trait&gt;</code></li>\n<li>specifying the <code>RHS</code> simply requires passing it as a parameter <code>Add&lt;???&gt;</code></li>\n<li>and finally getting an associated type of a trait simply requires using <code>Trait::OutputType</code> (which may be ambiguous)</li>\n</ul>\n\n<p>Combining the 3 together we get <code>&lt;Self as Add&lt;RhsType&gt;&gt;::Output</code>.</p>\n"}], "owner": {"reputation": 1259, "user_id": 1814775, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/ea9a58ab403c34bc21cde3a006d2e6d8?s=128&d=identicon&r=PG", "display_name": "lloydmeta", "link": "https://stackoverflow.com/users/1814775/lloydmeta"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 121, "favorite_count": 0, "accepted_answer_id": 40147686, "answer_count": 1, "score": 5, "last_activity_date": 1476947329, "creation_date": 1476946550, "last_edit_date": 1476947329, "question_id": 40147440, "link": "https://stackoverflow.com/questions/40147440/getting-the-associated-output-type-of-an-add-implementation-given-lhs-and-rhs-ty", "title": "Getting the associated Output type of an Add implementation given LHS and RHS types", "body": "<p>In Rust, is there any way to, at the type level, summon an <code>Add</code> implementation by using the LHS (<code>Self</code>) and RHS types in order to use its <code>Output</code> type (in say, the return type of a generic function)?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1476965785, "post_id": 40144526, "comment_id": 67577148, "body": "You can mark this question as a duplicate of an existing one instead of editing a link into your question."}], "answers": [{"comments": [{"owner": {"reputation": 5913, "user_id": 371760, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/3d085b76439deed744ca412f1479ea4c?s=128&d=identicon&r=PG", "display_name": "Henry", "link": "https://stackoverflow.com/users/371760/henry"}, "edited": false, "score": 0, "creation_date": 1476941473, "post_id": 40145391, "comment_id": 67561681, "body": "Awesome, can&#39;t believe I missed that one. I found byteorder as you can see but nom looks much more suitable for what I&#39;m doing. Thank you!"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 5913, "user_id": 371760, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/3d085b76439deed744ca412f1479ea4c?s=128&d=identicon&r=PG", "display_name": "Henry", "link": "https://stackoverflow.com/users/371760/henry"}, "edited": false, "score": 3, "creation_date": 1476945968, "post_id": 40145391, "comment_id": 67563881, "body": "@Henry: ByteOrder is a low-level crate to deal with byte ordering (whether for parsing or formatting), while nom is a full-fledged parser generator crate :)"}, {"owner": {"reputation": 1960, "user_id": 549531, "user_type": "registered", "accept_rate": 18, "profile_image": "https://i.stack.imgur.com/qV5qe.png?s=128&g=1", "display_name": "Evgeni Nabokov", "link": "https://stackoverflow.com/users/549531/evgeni-nabokov"}, "edited": false, "score": 0, "creation_date": 1582957121, "post_id": 40145391, "comment_id": 106962949, "body": "What is record? A name of the parsing function?"}], "tags": [], "owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "is_accepted": true, "score": 5, "last_activity_date": 1476936995, "creation_date": 1476936995, "answer_id": 40145391, "question_id": 40144526, "link": "https://stackoverflow.com/questions/40144526/is-this-the-most-natural-way-to-read-structs-from-a-binary-file/40145391#40145391", "title": "Is this the most natural way to read structs from a binary file?", "body": "<p>Have a look a the <a href=\"https://crates.io/crates/nom\" rel=\"noreferrer\"><code>nom</code></a> crate: it is very useful to parse binary data.</p>\n\n<p>With <code>nom</code>, you could write your parser with something like the following (not tested):</p>\n\n<pre><code>named!(record&lt;Record&gt;, chain!\n    ( latch: le_u32\n    ~ total_energy: le_f32\n    ~ x_cm: le_f32\n    ~ y_cm: le_f32\n    ~ x_cos: le_f32\n    ~ y_cos: le_f32\n    ~ weight: le_f32\n    , {\n        Record {\n            latch: latch,\n            total_energy: total_energy,\n            x_cm: x_cm,\n            y_cm: y_cm,\n            x_cos: x_cos,\n            y_cos: y_cos,\n            weight: weight,\n        }\n    }\n    )\n);\n</code></pre>\n"}], "owner": {"reputation": 5913, "user_id": 371760, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/3d085b76439deed744ca412f1479ea4c?s=128&d=identicon&r=PG", "display_name": "Henry", "link": "https://stackoverflow.com/users/371760/henry"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1750, "favorite_count": 0, "accepted_answer_id": 40145391, "answer_count": 1, "score": 3, "last_activity_date": 1476965737, "creation_date": 1476931295, "last_edit_date": 1495542805, "question_id": 40144526, "link": "https://stackoverflow.com/questions/40144526/is-this-the-most-natural-way-to-read-structs-from-a-binary-file", "title": "Is this the most natural way to read structs from a binary file?", "body": "<h2>I just realized this is quite similar to <a href=\"https://stackoverflow.com/questions/25693824/what-is-the-best-way-to-parse-binary-protocols-with-rust?rq=1\">What is the best way to parse binary protocols with Rust</a></h2>\n\n<p>Is this the most natural way to read structs from a binary file using Rust? It works but seems a bit odd (why can't I just fill the struct wholesale?).</p>\n\n<pre><code>extern crate byteorder;\nuse byteorder::{ByteOrder, LittleEndian};\n\nstruct Record {\n    latch: u32,\n    total_energy: f32,\n    x_cm: f32,\n    y_cm: f32,\n    x_cos: f32,\n    y_cos: f32,\n    weight: f32\n}\n\nimpl Record {\n    fn make_from_bytes(buffer: &amp;[u8]) -&gt; Record {\n        Record {\n            latch: LittleEndian::read_u32(&amp;buffer[0..4]),\n            total_energy: LittleEndian::read_f32(&amp;buffer[4..8]),\n            x_cm: LittleEndian::read_f32(&amp;buffer[8..12]),\n            y_cm: LittleEndian::read_f32(&amp;buffer[12..16]),\n            x_cos: LittleEndian::read_f32(&amp;buffer[16..20]),\n            y_cos: LittleEndian::read_f32(&amp;buffer[20..24]),\n            weight: LittleEndian::read_f32(&amp;buffer[24..28]),\n        }\n    }\n}\n</code></pre>\n"}]