[{"tags": ["rust", "ownership"], "answers": [{"comments": [{"owner": {"reputation": 3, "user_id": 6764912, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/77fe4feae26b850452d11fbeec1a0e9d?s=128&d=identicon&r=PG&f=1", "display_name": "Mighty Leguan", "link": "https://stackoverflow.com/users/6764912/mighty-leguan"}, "edited": false, "score": 0, "creation_date": 1489005486, "post_id": 42681337, "comment_id": 72487012, "body": "Thank you for the answer. It works now. I thought that I would need the * to acces the contents of the reference."}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 1, "creation_date": 1489014975, "post_id": 42681337, "comment_id": 72491553, "body": "Dereferencing first, while unnecessary, should still work: you just have to use brackets so it will be parsed as <code>(*v1).push(10)</code> and not <code>*(v1.push(10))</code>. This is the same operator precedence as in C."}], "tags": [], "owner": {"reputation": 20407, "user_id": 1017941, "user_type": "registered", "accept_rate": 97, "profile_image": "https://i.stack.imgur.com/yocPw.jpg?s=128&g=1", "display_name": "Hauleth", "link": "https://stackoverflow.com/users/1017941/hauleth"}, "is_accepted": true, "score": 0, "last_activity_date": 1489007816, "last_edit_date": 1489007816, "creation_date": 1489004975, "answer_id": 42681337, "question_id": 42681081, "link": "https://stackoverflow.com/questions/42681081/function-mutable-borrow/42681337#42681337", "title": "Function, mutable borrow", "body": "<p>You should not wrap all types with <code>&lt;&gt;</code>. <code>&lt;&gt;</code> means that you want to specify a generic parameter. This is sufficient:</p>\n\n<pre><code>let i: i32 = /* value */;\n</code></pre>\n\n<p>What is more, you do not need to specify the type at all, the compiler will infer types on it's own. You can just write:</p>\n\n<pre><code>let mut vec = vec![10, 20, 30];\n\nlet i = test(&amp;mut vec);\n</code></pre>\n\n<p>This should solve your second problem.</p>\n\n<p>The first error is because you are trying to dereference <code>()</code>, which isn't a reference at all.</p>\n\n<p>In C (and C++) we have 2 different access operators:</p>\n\n<ul>\n<li><code>.</code> which allows you to access structure fields (and methods in C++)</li>\n<li><code>-&gt;</code> which allows you to access fields of a structure behind a pointer</li>\n</ul>\n\n<p>Rust hides these details from you, so you only need to use the <code>.</code> operator.</p>\n\n<p>The type of <code>Vec::&lt;T&gt;::push(&amp;mut vec, val: T)</code> means that it returns <code>()</code> (the unit type). To fix the problem, remove the <code>*</code>:</p>\n\n<pre><code>fn test(v1: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {\n    v1.push(10);\n\n    v1[3]\n}\n\nfn main() {\n    let mut vec = vec![10, 20, 30];\n    let i = test(&amp;mut vec);\n}\n</code></pre>\n"}], "owner": {"reputation": 3, "user_id": 6764912, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/77fe4feae26b850452d11fbeec1a0e9d?s=128&d=identicon&r=PG&f=1", "display_name": "Mighty Leguan", "link": "https://stackoverflow.com/users/6764912/mighty-leguan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 215, "favorite_count": 0, "accepted_answer_id": 42681337, "answer_count": 1, "score": -1, "last_activity_date": 1489013713, "creation_date": 1489004060, "last_edit_date": 1489013713, "question_id": 42681081, "link": "https://stackoverflow.com/questions/42681081/function-mutable-borrow", "title": "Function, mutable borrow", "body": "<p>I am trying to understand the ownership system. To test it, I wanted to make a function that borrows a <code>Vec</code>, adds a value to it and returns that value: </p>\n\n<pre><code>fn test(v1: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {    \n    *v1.push(10);    \n    v1[3]\n}\n\nfn main() {\n    let mut vec: Vec&lt;i32&gt; = vec![10, 20, 30];\n    let i: &lt;i32&gt; = test(&amp;mut vec);\n}\n</code></pre>\n\n<p>I get these two errors: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: expected `::`, found `=`\n --&gt; src/main.rs:8:16\n  |\n8 |   let i: &lt;i32&gt; = test(&amp;mut vec);\n  |                ^\n\nerror: type `()` cannot be dereferenced\n --&gt; src/main.rs:2:5\n  |\n2 |     *v1.push(10);    \n  |     ^^^^^^^^^^^^\n</code></pre>\n\n<p>Changing the <code>=</code> to <code>::</code> doesn't help and I don't understand why it would. </p>\n"}, {"tags": ["rust", "rust-cargo"], "answers": [{"comments": [{"owner": {"reputation": 29866, "user_id": 930450, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/se3CE.png?s=128&g=1", "display_name": "Ixx", "link": "https://stackoverflow.com/users/930450/ixx"}, "edited": false, "score": 0, "creation_date": 1593942462, "post_id": 52024080, "comment_id": 110947571, "body": "Any idea whether <code>.cargo&#47;config</code> supports home directory (having difficulties finding this, probably not)."}, {"owner": {"reputation": 939, "user_id": 2870802, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-lHzULJklIJg/AAAAAAAAAAI/AAAAAAAABwk/_pJZF95FiAY/photo.jpg?sz=128", "display_name": "ozkriff", "link": "https://stackoverflow.com/users/2870802/ozkriff"}, "reply_to_user": {"reputation": 29866, "user_id": 930450, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/se3CE.png?s=128&g=1", "display_name": "Ixx", "link": "https://stackoverflow.com/users/930450/ixx"}, "edited": false, "score": 1, "creation_date": 1594009129, "post_id": 52024080, "comment_id": 110965465, "body": "@lxx nope, as far as I know"}], "tags": [], "owner": {"reputation": 939, "user_id": 2870802, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-lHzULJklIJg/AAAAAAAAAAI/AAAAAAAABwk/_pJZF95FiAY/photo.jpg?sz=128", "display_name": "ozkriff", "link": "https://stackoverflow.com/users/2870802/ozkriff"}, "is_accepted": false, "score": 7, "last_activity_date": 1535268236, "creation_date": 1535268236, "answer_id": 52024080, "question_id": 42676757, "link": "https://stackoverflow.com/questions/42676757/how-do-i-use-an-environment-variable-in-a-cargo-config-file/52024080#52024080", "title": "How do I use an environment variable in a .cargo/config file?", "body": "<p><code>.cargo/config</code> doesn't support environment variables. But you can configure the linker with <code>RUSTC_LINKER</code> environment variable:</p>\n\n<pre><code>export RUSTC_LINKER=\"$NDK_HOME/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc\"\ncargo build  # will try to use NDK's linker now\n</code></pre>\n\n<p>Though it'll work for all targets, not only for <code>arm-linux-androideabi</code>.</p>\n"}], "owner": {"reputation": 169, "user_id": 4354599, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b9b12556e83d7f13aed7442cda0e1c6f?s=128&d=identicon&r=PG", "display_name": "edelangh", "link": "https://stackoverflow.com/users/4354599/edelangh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1381, "favorite_count": 1, "answer_count": 1, "score": 8, "last_activity_date": 1535268236, "creation_date": 1488990613, "last_edit_date": 1520197907, "question_id": 42676757, "link": "https://stackoverflow.com/questions/42676757/how-do-i-use-an-environment-variable-in-a-cargo-config-file", "title": "How do I use an environment variable in a .cargo/config file?", "body": "<p>I'm using <code>.cargo/config</code> like this</p>\n\n<pre><code>[target.arm-linux-androideabi]\nlinker = \"/home/rico/android-ndk-r13b/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc\"\n</code></pre>\n\n<p>But <code>/home/rico/android-ndk-r13b</code> is my NDK_HOME, not NDK_HOME of everyone</p>\n\n<p>How can I specify to use <code>$NDK_HOME</code>?</p>\n\n<p>Something like: </p>\n\n<pre><code>[target.arm-linux-androideabi]\nlinker = \"$NDK_HOME/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc\"\n</code></pre>\n"}, {"tags": ["reference", "rust", "iterator", "interior-mutability"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488990854, "post_id": 42676541, "comment_id": 72478219, "body": "Related: <a href=\"http://stackoverflow.com/q/30281664/155423\">Returning the T borrowed from RefCell&lt;T&gt;</a>"}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488999312, "post_id": 42678936, "comment_id": 72483484, "body": "(You can probably do this with <code>unsafe</code> code, but my brain isn&#39;t showing me the way at the moment)."}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1489006484, "post_id": 42678936, "comment_id": 72487533, "body": "With <a href=\"https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr\" rel=\"nofollow noreferrer\"><code>RefCell::as_ptr</code></a>, perhaps?"}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1489006599, "post_id": 42678936, "comment_id": 72487599, "body": "Wait, no... you&#39;d also have to fiddle with the contents of the <code>RefCell</code> to make sure nobody else borrowed it as mutable while the <code>Values</code> existed. Tricksy"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1534361523, "last_edit_date": 1534361523, "creation_date": 1488997151, "answer_id": 42678936, "question_id": 42676541, "link": "https://stackoverflow.com/questions/42676541/how-do-i-return-an-iterator-that-has-a-reference-to-something-inside-a-refcell/42678936#42678936", "title": "How do I return an iterator that has a reference to something inside a RefCell?", "body": "<p>You cannot do this.</p>\n\n<p>The ultimate problem is that <code>std::collections::hash_map::Values</code> holds a reference, but you don't have \"just\" a reference. You have the smart pointer <code>Ref</code>.</p>\n\n<p>The easiest solution I know of is to invert the code:</p>\n\n<pre><code>impl Foo {\n    fn with_iter&lt;F, T&gt;(&amp;self, f: F) -&gt; T\n    where\n        F: FnOnce(Values&lt;i32, i32&gt;) -&gt; T,\n    {\n        f(self.map.borrow().values())\n    }\n}\n\nfn main() {\n    let foo = Foo {\n        map: Rc::new(RefCell::new(HashMap::new())),\n    };\n\n    foo.with_iter(|i| {\n        for v in i {\n            println!(\"{}\", v)\n        }\n    })\n}\n</code></pre>\n\n<p>Here, the <code>Values</code> iterator no longer needs to outlive the result of <code>borrow</code>, so there's no additional complexity. </p>\n\n<p>If you are OK with leaking your implementation, you can return the <code>Ref</code>:</p>\n\n<pre><code>impl Foo {\n    fn iter(&amp;self) -&gt; Ref&lt;'_, HashMap&lt;i32, i32&gt;&gt; {\n        self.map.borrow()\n    }\n}\n</code></pre>\n\n\n\n<pre><code>for v in foo.iter().values() {\n    println!(\"{}\", v)\n}\n</code></pre>\n\n<p>In newer versions of Rust, you can return an unnamed type that implements <code>Deref</code>:</p>\n\n<pre><code>use std::ops::Deref;\n\nimpl Foo {\n    fn iter(&amp;self) -&gt; impl Deref&lt;Target = HashMap&lt;i32, i32&gt;&gt; + '_ {\n        self.map.borrow()\n    }\n}\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/29401626/155423\">How do I return a reference to something inside a RefCell without breaking encapsulation?</a></li>\n</ul>\n"}], "owner": {"reputation": 97, "user_id": 7559077, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/51e6e079bc1a96b993c26ba63ccc53ca?s=128&d=identicon&r=PG&f=1", "display_name": "Marik", "link": "https://stackoverflow.com/users/7559077/marik"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 920, "favorite_count": 0, "accepted_answer_id": 42678936, "answer_count": 1, "score": 5, "last_activity_date": 1545155825, "creation_date": 1488990033, "last_edit_date": 1545155825, "question_id": 42676541, "link": "https://stackoverflow.com/questions/42676541/how-do-i-return-an-iterator-that-has-a-reference-to-something-inside-a-refcell", "title": "How do I return an iterator that has a reference to something inside a RefCell?", "body": "<p>I'm trying to create a method that returns an iterator over the values of <code>HashMap</code> that is boxed inside a <code>RefCell</code>, but i'm having an error where <code>Ref</code> returned by <code>RefCell::borrow</code>  doesn't live long enough for iterator to be returned from the method. Here's my code:</p>\n\n<pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::collections::hash_map::Values;\n\nstruct Foo {\n    map: Rc&lt;RefCell&lt;HashMap&lt;i32, i32&gt;&gt;&gt;,\n}\n\nimpl Foo {\n    fn iter(&amp;self) -&gt; Values&lt;i32, i32&gt; {\n        self.map.borrow().values()\n    }\n}\n\nfn main() {\n    let foo = Foo {\n        map: Rc::new(RefCell::new(HashMap::new()))\n    };\n\n    for v in foo.iter() {\n        println!(\"{}\", v)\n    }\n}\n</code></pre>\n\n<p>Compilation error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>rustc 1.15.1 (021bd294c 2017-02-08)\nerror: borrowed value does not live long enough\n  --&gt; &lt;anon&gt;:12:9\n   |\n12 |         self.map.borrow().values()\n   |         ^^^^^^^^^^^^^^^^^ does not live long enough\n13 |     }\n   |     - temporary value only lives until here\n   |\n</code></pre>\n\n<p><a href=\"https://stackoverflow.com/questions/29401626/how-do-i-return-a-reference-to-something-inside-a-refcell-without-breaking-encap\">How do I return a reference to something inside a RefCell without breaking encapsulation?</a> suggests creating a guard that incapsulates <code>Ref</code> and provides an interface for accessing the underlying value, but what I need to do is to return an iterator object (<code>Values&lt;'a, K, V&gt;</code>) that already incapsulates a plain reference to a <code>HashMap</code>. </p>\n\n<p>My main problem is that I have a runtime tracked reference <code>Ref&lt;T&gt;</code> while I need a plain reference to create an iterator. <code>Ref::map</code> exposes a plain reference for mapping, but it requires the mapper function to return another reference which is impossible here. Should I redo the entire iterator functionality to work with <code>Ref</code> or is there a better way?</p>\n"}, {"tags": ["compiler-errors", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488990124, "post_id": 42676373, "comment_id": 72477684, "body": "Specifically, you need <code>impl&lt;&#39;a&gt; AddAssign&lt;Num&gt; for &amp;&#39;a mut Num {</code> and then <code>let mut rn1 = &amp;mut n1;</code>."}, {"owner": {"reputation": 111, "user_id": 7679205, "user_type": "registered", "accept_rate": 50, "profile_image": "https://graph.facebook.com/1785230388414883/picture?type=large", "display_name": "Atsuki Takahashi", "link": "https://stackoverflow.com/users/7679205/atsuki-takahashi"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488990638, "post_id": 42676373, "comment_id": 72478047, "body": "Thanks for answer. Is there difference between <code>let ref mut rn1 = n1;</code> and <code>let mut rn1 = &amp;mut n1</code> ?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488990809, "post_id": 42676373, "comment_id": 72478196, "body": "Yes. One produces a mutable reference (<code>rn1: &amp;mut Foo</code>), the other produces a mutable mutable reference (<code>mut rn1: &amp;mut Foo</code>). See <a href=\"http://stackoverflow.com/q/28587698/155423\">stackoverflow.com/q/28587698/155423</a>. Said more concisely, one works here, the other doesn&#39;t. Also <code>let mut ref x = foo</code>, while valid, is not idiomatic; <code>let x = &amp;mut foo</code>  is."}, {"owner": {"reputation": 111, "user_id": 7679205, "user_type": "registered", "accept_rate": 50, "profile_image": "https://graph.facebook.com/1785230388414883/picture?type=large", "display_name": "Atsuki Takahashi", "link": "https://stackoverflow.com/users/7679205/atsuki-takahashi"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488990919, "post_id": 42676373, "comment_id": 72478264, "body": "Many thanks !!!!!!"}], "owner": {"reputation": 111, "user_id": 7679205, "user_type": "registered", "accept_rate": 50, "profile_image": "https://graph.facebook.com/1785230388414883/picture?type=large", "display_name": "Atsuki Takahashi", "link": "https://stackoverflow.com/users/7679205/atsuki-takahashi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 52, "favorite_count": 0, "closed_date": 1488989938, "answer_count": 0, "score": 1, "last_activity_date": 1488989819, "creation_date": 1488989555, "last_edit_date": 1488989819, "question_id": 42676373, "link": "https://stackoverflow.com/questions/42676373/why-can-i-not-use-on-a-mutable-reference", "closed_reason": "Duplicate", "title": "Why can I not use `+=` on a mutable reference?", "body": "<p>I want to apply <code>+=</code> to a mutable reference (<code>&amp;mut</code>), but I do not understand why it does not compile:</p>\n\n<pre><code>use std::ops::AddAssign;\n\nstruct Num {\n    value: usize,\n}\n\nimpl AddAssign for Num {\n    fn add_assign(&amp;mut self, other: Num) {\n        self.value += other.value;\n    }\n}\n\nfn main() {\n    let mut n1 = Num { value: 42 };\n    let n2 = Num { value: 41 };\n    n1 += n2; // It work!\n\n    let ref mut rn1 = n1; // Get &amp;mut Num\n    let n2 = Num { value: 41 };\n    rn1 += n2; // It could not be compiled !\n}\n</code></pre>\n\n<p>I think <code>&amp;mut Num += Num</code> is valid because <code>add_assign</code> takes <code>&amp;mut self</code>.</p>\n\n<p>But the compiler error is:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0368]: binary assignment operation `+=` cannot be applied to type `&amp;mut Num`\n  --&gt; src/main.rs:20:5\n   |\n20 |    rn1 += n2;\n   |    ^^^ cannot use '+=' on type '&amp;mut Num'\n</code></pre>\n"}, {"tags": ["memory", "rust", "clone"], "answers": [{"comments": [{"owner": {"reputation": 23600, "user_id": 1695172, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/6319d7eafca7852cf04c88598ca31e75?s=128&d=identicon&r=PG", "display_name": "Netwave", "link": "https://stackoverflow.com/users/1695172/netwave"}, "edited": false, "score": 1, "creation_date": 1488974022, "post_id": 42670199, "comment_id": 72465884, "body": "acutally he could remove the last clone right? <code>do_more_work...</code> will just take posession of x then, since <code>x</code> is not used anymore it makes sense. Or im i wrong?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1488978340, "post_id": 42670199, "comment_id": 72468953, "body": "That&#39;s awfully pessimistic."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 4, "creation_date": 1488979480, "post_id": 42670199, "comment_id": 72469719, "body": "<i>(To clarify my comment)</i> You are assuming that the <code>clone</code> implementation is opaque, however it&#39;s not (necessarily) the case, and whenever it&#39;s transparent to the optimizer, then the optimizer can have the guarantee that <code>clone</code> has no observable side-effects. I am much more concerned about <code>Drop</code>, for this particular case, but the general answer is clearly <b>Yes, of course sometimes it gets optimized out</b>."}, {"owner": {"reputation": 24802, "user_id": 232918, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5897762377de1c8ffb9a98673262e91?s=128&d=identicon&r=PG", "display_name": "doron", "link": "https://stackoverflow.com/users/232918/doron"}, "edited": false, "score": 0, "creation_date": 1488999574, "post_id": 42670199, "comment_id": 72483620, "body": "I assumed from the question that the OP was familiar with the as-if rule which applies everywhere and not specifically to clone but thanks for pointing this out."}, {"owner": {"reputation": 24802, "user_id": 232918, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5897762377de1c8ffb9a98673262e91?s=128&d=identicon&r=PG", "display_name": "doron", "link": "https://stackoverflow.com/users/232918/doron"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1488999956, "post_id": 42670199, "comment_id": 72483848, "body": "@MatthieuM. I have now added this point in. Please feel free to modify my answer if you can express it better."}], "tags": [], "owner": {"reputation": 24802, "user_id": 232918, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5897762377de1c8ffb9a98673262e91?s=128&d=identicon&r=PG", "display_name": "doron", "link": "https://stackoverflow.com/users/232918/doron"}, "is_accepted": false, "score": 4, "last_activity_date": 1488999714, "last_edit_date": 1488999714, "creation_date": 1488972748, "answer_id": 42670199, "question_id": 42669949, "link": "https://stackoverflow.com/questions/42669949/is-a-clone-statement-ever-optimised-out/42670199#42670199", "title": "Is a clone statement ever optimised out?", "body": "<p>Clone might print something out or write to a file. Optimizing the clone out changes behaviour and therefore cannot be done.</p>\n\n<p>Of course, if the compiler has full knowledge of what clone is doing and can work out that it can never have side-effects, it may well optimize it out but don't hold your breath.</p>\n\n<p>As a general rule, if you know a function will always return the same value, cache the value in a variable rather than calling a function a number of times.</p>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 4, "last_activity_date": 1488979361, "creation_date": 1488979361, "answer_id": 42672515, "question_id": 42669949, "link": "https://stackoverflow.com/questions/42669949/is-a-clone-statement-ever-optimised-out/42672515#42672515", "title": "Is a clone statement ever optimised out?", "body": "<p><strong>Why not?</strong></p>\n\n<p>The over-arching principle of an optimizing compiler is the <em>as-if rule</em>, which specifies that anything can be optimized as long as the compiler can prove that the optimization is not observable.</p>\n\n<p><em>Note: this comes on top of some languages allowing specific optimizations.</em></p>\n\n<p>So for example:</p>\n\n<pre><code>#[derive(Clone, Debug)]\nstruct MyDummyType(u64);\n\nextern {\n    fn print_c(_: *const ());\n}\n\n#[inline(never)]\nfn print(dummy: MyDummyType) {\n    unsafe { print_c(&amp;dummy as *const _ as *const _) }\n}\n\nfn main() {\n    let x = MyDummyType(42);\n    print(x.clone());\n    print(x.clone());\n}\n</code></pre>\n\n<p>Yields the following <code>main</code>:</p>\n\n<pre><code>; Function Attrs: nounwind uwtable\ndefine internal void @_ZN8rust_out4main17h0c6f2596c7f28a79E() unnamed_addr #1 {\nentry-block:\n  tail call fastcc void @_ZN8rust_out5print17h1f2d1a86beea10d7E(i64 42)\n  tail call fastcc void @_ZN8rust_out5print17h1f2d1a86beea10d7E(i64 42)\n  ret void\n}\n</code></pre>\n\n<p>The compiler completely saw through our code (and I actually had to use an extern function to force it to emit <em>some</em> code in <code>main</code>).</p>\n\n<hr>\n\n<p>So, what about your case?</p>\n\n<p>It's quite more difficult, to be honest.</p>\n\n<p>Specifically, there's a potential change of semantics due to <code>Drop</code>:</p>\n\n<ul>\n<li>with <code>do_more_work_on_data(x.clone())</code>, <code>x</code> is guaranteed to be dropped <em>after</em> the execution ends, and therefore any side-effect of <code>Drop</code> to be executed <em>at the end of the current function</em>,</li>\n<li>with <code>do_more_work_on_data(x)</code>, <code>x</code> <em>may</em> be dropped at the end of <code>do_more_work_on_data</code> OR it may be dropped earlier somewhere within.</li>\n</ul>\n\n<p>So in order to prove that the optimization <em>is not observable</em>, the compiler has to prove:</p>\n\n<ul>\n<li>either that <code>Drop</code> has no effect,</li>\n<li>or that <code>Drop</code> will be executed at the very end of <code>do_more_work_on_data</code>, which is the same as right after it,</li>\n<li>or ...?</li>\n</ul>\n\n<p>How likely is this? </p>\n\n<p>The <code>Drop</code> implementation of <code>Mutex</code> requires invoking FFI, so from the optimizer point of view it <em>has</em> observable effects.</p>\n\n<p>So it all hinges on whether <code>do_more_work_on_data</code> gets inlined. If it does, yes indeed the extra <code>clone</code> could well be optimized out. If it does not, I would not hold my breath.</p>\n"}], "owner": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 93, "favorite_count": 0, "accepted_answer_id": 42672515, "answer_count": 2, "score": 3, "last_activity_date": 1488999714, "creation_date": 1488972104, "last_edit_date": 1488978040, "question_id": 42669949, "link": "https://stackoverflow.com/questions/42669949/is-a-clone-statement-ever-optimised-out", "title": "Is a clone statement ever optimised out?", "body": "<p>I have code similar to the following</p>\n\n<pre><code>let x = Arc::new(Mutex::new(Thing::new()));\n\nwork_on_data(x.clone());\ndo_more_work_on_data(x.clone());\n</code></pre>\n\n<p><code>x</code> isn't used after the second function and therefore the second clone is not required. Should I remove the <code>clone()</code> manually, or is it optimised out?</p>\n"}, {"tags": ["macros", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1488962991, "post_id": 42666203, "comment_id": 72458416, "body": "Not a macro specialist, so I&#39;ll just make 2 quick points: (1) a tuple is an expression, so &quot;(x, y)&quot; can match <code>$a:expr</code> and (2) I believe the patterns are tried in order... have you tried putting the more specific pattern first?"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 1, "creation_date": 1489020749, "post_id": 42666203, "comment_id": 72493429, "body": "Not related to the problem, but the standard library has a <a href=\"https://doc.rust-lang.org/stable/std/os/unix/fs/fn.symlink.html\" rel=\"nofollow noreferrer\"><code>symlink</code></a> function."}], "answers": [{"comments": [{"owner": {"reputation": 313, "user_id": 6114451, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/VTzZW.jpg?s=128&g=1", "display_name": "DRogueRonin", "link": "https://stackoverflow.com/users/6114451/drogueronin"}, "edited": false, "score": 0, "creation_date": 1488965922, "post_id": 42667440, "comment_id": 72460229, "body": "Of course a tuple is an expression! I totally missed that, thanks. Also thanks to @MatthieuM."}, {"owner": {"reputation": 313, "user_id": 6114451, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/VTzZW.jpg?s=128&g=1", "display_name": "DRogueRonin", "link": "https://stackoverflow.com/users/6114451/drogueronin"}, "edited": false, "score": 0, "creation_date": 1488966795, "post_id": 42667440, "comment_id": 72460841, "body": "And thanks for the edit and providing the fix for my two uncovered test cases! A solution with less rules would indeed be interesting. Maybe I can find one after digging more into rust macros."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1488979571, "post_id": 42667440, "comment_id": 72469775, "body": "Nice to see my hunch was right; I really haven&#39;t played much with macros :)"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 4, "last_activity_date": 1488966092, "last_edit_date": 1488966092, "creation_date": 1488965164, "answer_id": 42667440, "question_id": 42666203, "link": "https://stackoverflow.com/questions/42666203/macro-rule-only-matches-first-pattern/42667440#42667440", "title": "macro rule only matches first pattern", "body": "<p>As @MatthieuM points out in a comment, a tuple is an expression and macro rules are tried in order.</p>\n\n<p>So in your case:</p>\n\n<pre><code>macro_rules! syml {\n    ($a:expr, $b:expr) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", $a, $b])\n    };\n    ( ($a:expr, $($x:expr),+), ($b:expr, $($y:expr),+) ) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", &amp;format!($a, $($x),+), &amp;format!($b, $($y),+)])\n    }\n}\n</code></pre>\n\n<p>The first rule will always match any time the second would.  The solution is to swap them around:</p>\n\n<pre><code>macro_rules! syml {\n    ( ($a:expr, $($x:expr),+), ($b:expr, $($y:expr),+) ) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", &amp;format!($a, $($x),+), &amp;format!($b, $($y),+)])\n    };\n    ($a:expr, $b:expr) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", $a, $b])\n    }\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=dbc25ae8a1431a552d6afd8c4ee8f28e&amp;version=stable&amp;backtrace=1\" rel=\"nofollow noreferrer\">Playground</a>)</p>\n\n<p>The above doesn't cover two of your test cases where you mix tuples and strings:</p>\n\n<pre><code>syml!((\"{}\", from), \"to\");\nsyml!(\"from\", (\"{}\", to));\n</code></pre>\n\n<p>This can be simply fixed by adding new cases (in order).  (I don't know if it's possible to factor out the tuple/string matching, but would be interested in seeing any solutions.)</p>\n\n<pre><code>macro_rules! syml {\n    ( ($a:expr, $($x:expr),+), ($b:expr, $($y:expr),+) ) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", &amp;format!($a, $($x),+), &amp;format!($b, $($y),+)])\n    };\n    ( $a:expr, ($b:expr, $($y:expr),+) ) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", $a, &amp;format!($b, $($y),+)])\n    };\n    ( ($a:expr, $($x:expr),+), $b:expr ) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", &amp;format!($a, $($x),+), $b])\n    };\n    ($a:expr, $b:expr) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", $a, $b])\n    }\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=44cf7ab7240fdcab3fabcaf32f3a3a3e&amp;version=stable&amp;backtrace=1\" rel=\"nofollow noreferrer\">Playground</a>)</p>\n"}], "owner": {"reputation": 313, "user_id": 6114451, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/VTzZW.jpg?s=128&g=1", "display_name": "DRogueRonin", "link": "https://stackoverflow.com/users/6114451/drogueronin"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 236, "favorite_count": 0, "accepted_answer_id": 42667440, "answer_count": 1, "score": 3, "last_activity_date": 1488966092, "creation_date": 1488961059, "question_id": 42666203, "link": "https://stackoverflow.com/questions/42666203/macro-rule-only-matches-first-pattern", "title": "macro rule only matches first pattern", "body": "<p>I wrote a macro for sym-linking files. At first I had just the first pattern, but then thought that it would be nice not to have to write \"&amp;format!\" all the time.</p>\n\n<p>So with these patterns:</p>\n\n<pre><code>macro_rules! syml {\n    ($a:expr, $b:expr) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", $a, $b])\n    };\n    ( ($a:expr, $($x:expr),+), ($b:expr, $($y:expr),+) ) =&gt; {\n        Command::new(\"ln\").args(&amp;[\"-s\", &amp;format!($a, $($x),+), &amp;format!($b, $($y),+)])\n    }\n}\n</code></pre>\n\n<p>I want to match these cases:</p>\n\n<pre><code>syml!(\"from\", \"to\");\nsyml!((\"{}\", from), \"to\");\nsyml!(\"from\", (\"{}\", to));\nsyml!((\"{}\", from), (\"{}\", to));\nsyml!((\"{}{}\", from, here), (\"{}{}\", to, there));\n</code></pre>\n\n<p>But so far every time only the first pattern is matched, so I'm getting <code>mismatched types</code> errors like <code>expected reference, found tuple</code>.</p>\n\n<p>I don't understand why, even for the last two example cases, it tries to match the first pattern and not the second.</p>\n"}, {"tags": ["multithreading", "rust", "iron"], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 3, "last_activity_date": 1488966173, "creation_date": 1488966173, "answer_id": 42667811, "question_id": 42664771, "link": "https://stackoverflow.com/questions/42664771/how-to-enable-the-threading-feature-in-the-iron-framework/42667811#42667811", "title": "How to enable the threading feature in the Iron framework?", "body": "<p>It is enabled by default.</p>\n\n<p>The primary structure in <code>Iron</code> is <a href=\"http://ironframework.io/doc/iron/struct.Iron.html\" rel=\"nofollow noreferrer\"><code>Iron</code></a>, you can start the server using either the <code>http</code> or <code>listen_with</code> methods.</p>\n\n<p>For <a href=\"http://ironframework.io/doc/iron/struct.Iron.html#method.http\" rel=\"nofollow noreferrer\"><code>http</code></a>:</p>\n\n<blockquote>\n  <p>Defaults to a threadpool of size <code>8 * num_cpus</code>.</p>\n</blockquote>\n\n<p>For <a href=\"http://ironframework.io/doc/iron/struct.Iron.html#method.listen_with\" rel=\"nofollow noreferrer\"><code>listen_with</code></a>: the signature takes a <code>threads usize</code> argument:</p>\n\n<blockquote>\n  <p>Kick off the server process with X threads.</p>\n</blockquote>\n\n<p>Where I suppose <code>X</code> stands for the number of threads passed as argument.</p>\n"}], "owner": {"reputation": 3248, "user_id": 528588, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/aae4d666764ebe4d7165c792432cad49?s=128&d=identicon&r=PG", "display_name": "MajidTaheri", "link": "https://stackoverflow.com/users/528588/majidtaheri"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 153, "favorite_count": 0, "accepted_answer_id": 42667811, "answer_count": 1, "score": -3, "last_activity_date": 1488966173, "creation_date": 1488955827, "question_id": 42664771, "link": "https://stackoverflow.com/questions/42664771/how-to-enable-the-threading-feature-in-the-iron-framework", "title": "How to enable the threading feature in the Iron framework?", "body": "<p>Does the Iron framework support multithreaded mode? How do I enable &amp; configure it?</p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488913247, "post_id": 42656067, "comment_id": 72438083, "body": "See also <a href=\"http://stackoverflow.com/q/30243606/155423\">stackoverflow.com/q/30243606/155423</a>; where that OP discovered the same problem with <code>if let {} else {}</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488915787, "post_id": 42656067, "comment_id": 72439683, "body": "The related questions appears to have some relevant suggestions as well. Here&#39;s one <a href=\"http://stackoverflow.com/q/42260092/155423\">specifically about vectors</a>"}], "owner": {"reputation": 24273, "user_id": 525872, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/4d6f74711436cfe252bf4fc8f3cf4971?s=128&d=identicon&r=PG", "display_name": "Jo Liss", "link": "https://stackoverflow.com/users/525872/jo-liss"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 100, "favorite_count": 0, "closed_date": 1488913152, "answer_count": 0, "score": 0, "last_activity_date": 1488913298, "creation_date": 1488912890, "last_edit_date": 1488913298, "question_id": 42656067, "link": "https://stackoverflow.com/questions/42656067/match-get-for-none-how-to-avoid-useless-borrow", "closed_reason": "Duplicate", "title": "match .get() for None: how to avoid useless borrow?", "body": "<p>How can I mutate a <code>hash_map</code> in the <code>None</code> clause of <code>match hash_map.get(...)</code> (and similarly for <code>vec.get</code>)?</p>\n\n<pre><code>match hash_map.get(...) {\n    None =&gt; {\n        // How can I mutate hash_map here?\n    }\n}\n</code></pre>\n\n<p>As a full example, the following does not compile:</p>\n\n<pre><code>use std::collections::HashMap;\n\nfn map_question(map: &amp;mut HashMap&lt;String, String&gt;) {\n    match map.get(&amp;\"foo\".to_string()) {\n        Some(s) =&gt; {\n            // Do something with s\n        },\n        None =&gt; {\n            // I'd like to mutate `map` here, but I'm getting \"cannot borrow map\"\n            map.insert(\"bar\".to_string(), \"x\".to_string());\n        }\n    }\n}\n</code></pre>\n\n<p>The reason is that the <code>Option&lt;&amp;String&gt;</code> returned by <a href=\"https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.get\" rel=\"nofollow noreferrer\"><code>map.get()</code></a> is still in scope, so <code>map</code> is borrowed. Here's the full error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable\n  --&gt; test.rs:10:13\n   |\n4  |     match map.get(&amp;\"foo\".to_string()) {\n   |           --- immutable borrow occurs here\n...\n10 |             map.insert(\"bar\".to_string(), \"x\".to_string());\n   |             ^^^ mutable borrow occurs here\n11 |         }\n12 |     }\n   |     - immutable borrow ends here\n</code></pre>\n\n<p><strong>My solution</strong> has been to work around this problem by using <code>if let</code>:</p>\n\n<pre><code>fn map_alternative(map: &amp;mut HashMap&lt;String, String&gt;) {\n    if let Some(s) = map.get(&amp;\"foo\".to_string()) {\n        // Do something with s\n    }\n    // Now we can mutate `map` because the `Option` return by `.get`\n    // is out of scope.\n    map.insert(\"bar\".to_string(), \"x\".to_string());\n}\n</code></pre>\n\n<p>(Note that we're not using an <code>else</code> clause here, because the <code>Option&lt;&amp;String&gt;</code> returned by <code>.get</code> would still be in scope in the <code>else</code> clause for some reason.)</p>\n\n<p>But this seems somewhat unsatisfactory. Can I tell Rust that when I'm matching <code>None</code>, I'm done with the <code>Option</code> object I got from <code>.get</code>?</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 325, "user_id": 3688659, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/6265083c30ede6204e64facc809859d2?s=128&d=identicon&r=PG&f=1", "display_name": "SphericalCow", "link": "https://stackoverflow.com/users/3688659/sphericalcow"}, "edited": false, "score": 0, "creation_date": 1488891114, "post_id": 42648637, "comment_id": 72423698, "body": "But how does this syntax fn call_with_ref&lt;F&gt;(some_closure:F) -&gt; i32     where F: for&lt;&#39;a&gt; Fn(&amp;&#39;a i32) -&gt; i32 solve the problem?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 325, "user_id": 3688659, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/6265083c30ede6204e64facc809859d2?s=128&d=identicon&r=PG&f=1", "display_name": "SphericalCow", "link": "https://stackoverflow.com/users/3688659/sphericalcow"}, "edited": false, "score": 0, "creation_date": 1488898423, "post_id": 42648637, "comment_id": 72428744, "body": "I&#39;ve added a mention of that; hope it helps."}, {"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 1, "creation_date": 1488932958, "post_id": 42648637, "comment_id": 72447554, "body": "@ChrisEmerson <code>for&lt;&#39;a&gt; Fn(&amp;&#39;a i32) -&gt; i32</code> can also be <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0387-higher-ranked-trait-bounds.md#implicit-binders-when-using-parentheses-notation-and-in-fn-types\" rel=\"nofollow noreferrer\">written as <code>Fn(&amp;i32) -&gt; i32</code></a>."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 2, "last_activity_date": 1488899237, "last_edit_date": 1488899237, "creation_date": 1488890536, "answer_id": 42648637, "question_id": 42648207, "link": "https://stackoverflow.com/questions/42648207/taking-closures-with-explicit-lifetimes-as-arguments-in-rust/42648637#42648637", "title": "Taking closures with explicit lifetimes as arguments in Rust", "body": "<p>When a lifetime appears in the parameter list, that means the caller gets to decide.  The lifetime it chooses can be as long as it likes, and possibly longer than the closure lives for, even <code>'static</code>.</p>\n\n<p>Here's a bad example which is prevented by this error:</p>\n\n<pre><code>fn call_with_ref&lt;'a, F&gt;(some_closure: F) -&gt; i32\n    where F: FnMut(&amp;'a i32) -&gt; i32\n{\n    let value = 0;\n    some_closure(&amp;value)\n}\n\nfn main() {\n    let mut refstore: Option&lt;&amp;'static i32&gt; = None;\n\n    call_with_ref(|r| {\n        refstore = Some(r);\n        *r\n    });\n}\n</code></pre>\n\n<p>If this version of <code>call_with_ref</code> were allowed to compile, it would allow storing a dangling reference to the local <code>value</code> variable in a variable which lives for longer.</p>\n\n<p>Note I've changed the function to take an <code>FnMut</code> closure for simplicity; it would be possible to have the same unsafety using <code>Fn</code> and a <code>RefCell</code>, but it would have made the example more complicated.</p>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=9dfb6c81ecf323483258860a4743bee8&amp;version=stable&amp;backtrace=1\" rel=\"nofollow noreferrer\">Playground with \"bad\" line commented out</a>)</p>\n\n<p>The <a href=\"https://doc.rust-lang.org/book/closures.html\" rel=\"nofollow noreferrer\">closures section</a> of the book then shows the <code>for&lt;'a&gt;</code> syntax, which changes the meaning of the lifetime bound.</p>\n\n<p>Translating to English, the following:</p>\n\n<pre><code>fn call_with_ref&lt;'a, F&gt;(some_closure: F) -&gt; i32\n     where F: Fn(&amp;'a i32) -&gt; i32\n</code></pre>\n\n<p>means roughly \"given a lifetime <code>'a</code>, and a callable which takes a reference to an <code>i32</code> which is valid for <code>'a</code>, I'll return an <code>i32</code>\".  This means that the lifetime is set <em>by the caller</em> of <code>call_with_ref</code> and is fixed.</p>\n\n<p>In contrast, the following:</p>\n\n<pre><code>fn call_with_ref&lt;F&gt;(some_closure: F) -&gt; i32\n     where F: for&lt;'a&gt; Fn(&amp;'a i32) -&gt; i32\n</code></pre>\n\n<p>means \"given a callable which can take a reference to an <code>i32</code> of any lifetime, I'll return an <code>i32</code>\".  The difference is that the closure will accept <em>any</em> reference lifetime (which outlives the call of the closure).</p>\n\n<p>In the first case, the lifetime is a parameter to <code>call_with_ref</code>, so must outlive that call; but in the second case it's a parameter to the closure itself and only needs to outlive the call to the closure.</p>\n"}], "owner": {"reputation": 325, "user_id": 3688659, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/6265083c30ede6204e64facc809859d2?s=128&d=identicon&r=PG&f=1", "display_name": "SphericalCow", "link": "https://stackoverflow.com/users/3688659/sphericalcow"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 382, "favorite_count": 0, "accepted_answer_id": 42648637, "answer_count": 1, "score": 1, "last_activity_date": 1488899237, "creation_date": 1488889351, "last_edit_date": 1488894929, "question_id": 42648207, "link": "https://stackoverflow.com/questions/42648207/taking-closures-with-explicit-lifetimes-as-arguments-in-rust", "title": "Taking closures with explicit lifetimes as arguments in Rust", "body": "<p>The <a href=\"https://doc.rust-lang.org/book/closures.html\" rel=\"nofollow noreferrer\">closures</a> section of Rust documentation has this example:</p>\n\n<pre><code>fn call_with_ref&lt;'a, F&gt;(some_closure: F) -&gt; i32\n    where F: Fn(&amp;'a i32) -&gt; i32\n{\n    let value = 0;\n    some_closure(&amp;value)\n}\n</code></pre>\n\n<p>This doesn't compile because, as the docs put it:</p>\n\n<blockquote>\n  <p>When a function has an explicit lifetime parameter, that lifetime must\n  be at least as long as the entire call to that function. The borrow\n  checker will complain that value doesn't live long enough, because it\n  is only in scope after its declaration inside the function body.</p>\n</blockquote>\n\n<p>The error message being</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `value` does not live long enough\n --&gt; &lt;anon&gt;:5:19\n  |\n5 |     some_closure(&amp;value);\n  |                   ^^^^^ does not live long enough\n...\n8 | }\n  | - borrowed value only lives until here\n</code></pre>\n\n<p>I am having trouble understanding this. What does it mean that value does not live long enough? From what I understand value lives through the entire call of the function. So, where does the \"not living long enough\" come from?</p>\n"}, {"tags": ["multithreading", "rust", "rayon"], "answers": [{"comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1488966616, "post_id": 42656422, "comment_id": 72460695, "body": "It&#39;s a shame there doesn&#39;t seem to be anything scoped to this call (though this is clearly useful in a decent subset of cases)."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1488975651, "post_id": 42656422, "comment_id": 72467034, "body": "@ChrisEmerson Yes, what worries me about this answer is that I can&#39;t think of a way to clean up the created stores (or run other arbitrary commands when everything is done, such as flush them to disk) using safe code. Worse, the next call to <code>verify_and_store</code> will continue working with <b>last</b> known <code>Store</code> clones, which possibly have nothing to do with the current <code>store</code>."}, {"owner": {"reputation": 4825, "user_id": 181894, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/e734b1b426a713c8a0a7cfe6713e86e3?s=128&d=identicon&r=PG", "display_name": "Tomas", "link": "https://stackoverflow.com/users/181894/tomas"}, "edited": false, "score": 0, "creation_date": 1488978351, "post_id": 42656422, "comment_id": 72468966, "body": "Thanks. This works but in my particular case I&#39;ve found that Rayon has <code>par_chunks</code> to reduce the number of clones. Although this might still result in multiple clones per thread, it doesn&#39;t have the scope problem @user4815162342 is describing."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1489006894, "post_id": 42656422, "comment_id": 72487746, "body": "@ChrisEmerson I&#39;ve now updated the answer to add scoping and proper cleanup; the code is not elegant (to say the least), but it appears to work!"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 4825, "user_id": 181894, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/e734b1b426a713c8a0a7cfe6713e86e3?s=128&d=identicon&r=PG", "display_name": "Tomas", "link": "https://stackoverflow.com/users/181894/tomas"}, "edited": false, "score": 0, "creation_date": 1489008651, "post_id": 42656422, "comment_id": 72488671, "body": "@Tomas You might want to add your solution as an answer, and accept it. My answer is a fun exploration of Rust/Rayon&#39;s support for thread-local code, while your <code>par_chunks</code> solution seems to do a good and elegant job of nailing the actual problem."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 7, "last_activity_date": 1489007643, "last_edit_date": 1489007643, "creation_date": 1488913991, "answer_id": 42656422, "question_id": 42647900, "link": "https://stackoverflow.com/questions/42647900/per-thread-initialization-in-rayon/42656422#42656422", "title": "Per-thread initialization in Rayon", "body": "<p>It is possible to use a thread-local variable to ensure that <code>local_store</code> is not created more than once in a given thread.</p>\n\n<p>For example, this compiles (<a href=\"http://pastebin.com/qDtgEG42\" rel=\"nofollow noreferrer\">full source</a>):</p>\n\n<pre><code>fn verify_and_store(store: &amp;mut Store, txs: Vec&lt;Tx&gt;) {\n    use std::cell::RefCell;\n    thread_local!(static STORE: RefCell&lt;Option&lt;Store&gt;&gt; = RefCell::new(None));\n\n    let mut result = Vec::new();\n\n    txs.par_iter().map(|tx| {\n        STORE.with(|cell| {\n            let mut local_store = cell.borrow_mut();\n            if local_store.is_none() {\n                *local_store = Some(store.clone());\n            }\n            tx.verify_and_store(local_store.as_mut().unwrap())\n        })\n    }).collect_into(&amp;mut result);\n}\n</code></pre>\n\n<p>There are two problems with this code, however. One, if the clones of <code>store</code> need to do something when <code>par_iter()</code> is done, such as flush their buffers, it simply won't happen - their <code>Drop</code> will only be called when Rayon's worker threads exit, and even that <a href=\"https://doc.rust-lang.org/1.14.0/std/thread/struct.LocalKey.html#platform-specific-behavior\" rel=\"nofollow noreferrer\">is not guaranteed</a>.</p>\n\n<p>The second, and more serious problem, is that the clones of <code>store</code> are created exactly once per worker thread. If Rayon caches its thread pool (and I believe it does), this means that an unrelated later call to <code>verify_and_store</code> will continue working with last known clones of <code>store</code>, which possibly have nothing to do with the current store.</p>\n\n<p>This can be rectified by complicating the code somewhat:</p>\n\n<ul>\n<li><p>Store the cloned variables in a <code>Mutex&lt;Option&lt;...&gt;&gt;</code> instead of <code>Option</code>, so that they can be accessed by the thread that invoked <code>par_iter()</code>. This will incur a mutex lock on every access, but the lock will be uncontested and therefore cheap.</p></li>\n<li><p>Use an <code>Arc</code> around the mutex in order to collect references to the created store clones in a vector. This vector is used to clean up the stores by resetting them to <code>None</code> after the iteration has finished.</p></li>\n<li><p>Wrap the whole call in an unrelated mutex, so that two parallel calls to <code>verify_and_store</code> don't end up seeing each other's store clones. (This might be avoidable if a new thread pool were created and installed before the iteration.) Hopefully this serialization won't affect the performance of <code>verify_and_store</code>, since each call will utilize the whole thread pool.</p></li>\n</ul>\n\n<p>The result is not pretty, but it compiles, uses only safe code, and appears to work:</p>\n\n<pre><code>fn verify_and_store(store: &amp;mut Store, txs: Vec&lt;Tx&gt;) {\n    use std::sync::{Arc, Mutex};\n    type SharedStore = Arc&lt;Mutex&lt;Option&lt;Store&gt;&gt;&gt;;\n\n    lazy_static! {\n        static ref STORE_CLONES: Mutex&lt;Vec&lt;SharedStore&gt;&gt; = Mutex::new(Vec::new());\n        static ref NO_REENTRY: Mutex&lt;()&gt; = Mutex::new(());\n    }\n    thread_local!(static STORE: SharedStore = Arc::new(Mutex::new(None)));\n\n    let mut result = Vec::new();\n    let _no_reentry = NO_REENTRY.lock();\n\n    txs.par_iter().map({\n        |tx| {\n            STORE.with(|arc_mtx| {\n                let mut local_store = arc_mtx.lock().unwrap();\n                if local_store.is_none() {\n                    *local_store = Some(store.clone());\n                    STORE_CLONES.lock().unwrap().push(arc_mtx.clone());\n                }\n                tx.verify_and_store(local_store.as_mut().unwrap())\n            })\n        }\n    }).collect_into(&amp;mut result);\n\n    let mut store_clones = STORE_CLONES.lock().unwrap();\n    for store in store_clones.drain(..) {\n        store.lock().unwrap().take();\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 876, "user_id": 798414, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/8bdd78c9f27f9a61d8e9c6f19b122493?s=128&d=identicon&r=PG", "display_name": "Mike Pedersen", "link": "https://stackoverflow.com/users/798414/mike-pedersen"}, "is_accepted": false, "score": 4, "last_activity_date": 1565549214, "creation_date": 1565549214, "answer_id": 57452666, "question_id": 42647900, "link": "https://stackoverflow.com/questions/42647900/per-thread-initialization-in-rayon/57452666#57452666", "title": "Per-thread initialization in Rayon", "body": "<p>Old question, but I feel the answer needs revisiting. In general, there are two methods:</p>\n\n<p>Use <code>map_with</code>. This will clone every time a thread steals a work item from another thread. This will possibly clone more stores than there are threads, but it should be fairly low. If the clones are too expensive, you can increase the size rayon will split workloads with <code>with_min_len</code>.</p>\n\n<pre><code>fn verify_and_store(store: &amp;mut Store, txs: Vec&lt;Tx&gt;) {\n    let result = txs.iter().map_with(|| store.clone(), |store, tx| {\n         tx.verify_and_store(store)\n    }).collect();\n    ...\n}\n</code></pre>\n\n<p>Or use the scoped <code>ThreadLocal</code> from the <a href=\"https://crates.io/crates/thread_local\" rel=\"nofollow noreferrer\">thread_local</a> crate. This will ensure that you only use as many objects as there are threads, and that they are destroyed once the <code>ThreadLocal</code> object goes out of scope.</p>\n\n<pre><code>fn verify_and_store(store: &amp;mut Store, txs: Vec&lt;Tx&gt;) {\n    let tl = ThreadLocal::new();\n    let result = txs.iter().map(|tx| {\n         let store = tl.get_or(|| Box::new(RefCell::new(store.clone)));\n         tx.verify_and_store(store.get_mut());\n    }).collect();\n    ...\n}\n</code></pre>\n"}], "owner": {"reputation": 4825, "user_id": 181894, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/e734b1b426a713c8a0a7cfe6713e86e3?s=128&d=identicon&r=PG", "display_name": "Tomas", "link": "https://stackoverflow.com/users/181894/tomas"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1148, "favorite_count": 1, "accepted_answer_id": 42656422, "answer_count": 2, "score": 10, "last_activity_date": 1565549214, "creation_date": 1488888430, "last_edit_date": 1488890202, "question_id": 42647900, "link": "https://stackoverflow.com/questions/42647900/per-thread-initialization-in-rayon", "title": "Per-thread initialization in Rayon", "body": "<p>I am trying to optimize my function using Rayon's <code>par_iter()</code>.</p>\n\n<p>The single threaded version is something like:</p>\n\n<pre><code>fn verify_and_store(store: &amp;mut Store, txs: Vec&lt;Tx&gt;) {\n\n    let result = txs.iter().map(|tx| {\n\n         tx.verify_and_store(store)\n\n    }).collect();\n\n    ...\n}\n</code></pre>\n\n<p>Each <code>Store</code> instance must be used only by one thread, but multiple instances of <code>Store</code> can be used concurrently, so I can make this multithreaded by <code>clone</code>-ing <code>store</code>:</p>\n\n<pre><code>fn verify_and_store(store: &amp;mut Store, txs: Vec&lt;Tx&gt;) {\n\n    let result = txs.par_iter().map(|tx| {\n\n         let mut local_store = store.clone();\n\n         tx.verify_and_store(&amp;mut local_store)\n\n    }).collect();\n\n    ...\n}\n</code></pre>\n\n<p>However, this clones the <code>store</code> on <em>every</em> iteration, which is way too slow. I would like to use one store instance per thread.</p>\n\n<p>Is this possible with Rayon? Or should I resort to manual threading and a work-queue?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1488881426, "post_id": 42645273, "comment_id": 72417464, "body": "Is <code>Object</code> hashable or <code>Ord</code>?  I think I&#39;d collect into a map (<code>HashMap</code> or <code>BTreeMap</code>) with key/value swapped first to merge the keys, and then flatten that into a <code>Vec</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1488881513, "post_id": 42645273, "comment_id": 72417515, "body": "A simple example showing (1) the content of <code>aliases</code> and (2) the expected content of the resulting <code>Vec</code> would go a long way to making this question slightly more understandable."}, {"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1488881917, "post_id": 42645273, "comment_id": 72417755, "body": "@MatthieuM. I have simplified the question a lot and I hope it is much clearer now."}], "answers": [{"tags": [], "owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "is_accepted": false, "score": 2, "last_activity_date": 1488884465, "last_edit_date": 1488884465, "creation_date": 1488883802, "answer_id": 42646274, "question_id": 42645273, "link": "https://stackoverflow.com/questions/42645273/how-to-reverse-map-of-objects-to-vector-of-tuples-by-using-an-iterator/42646274#42646274", "title": "How to reverse map of objects to vector of tuples by using an iterator?", "body": "<p>It's not trivial, certainly not as trivial as it would be with some other stream libraries that provide the necessary functions.</p>\n\n<p>You can use the itertools crate's <code>group_by</code> to group elements by some key. However, it only groups adjacent elements, so you have to sort them first. Here's my result:</p>\n\n<pre><code>impl A {\n    pub fn get_aliases(&amp;self) -&gt; Vec&lt;(String, Vec&lt;String&gt;)&gt; {\n        // Get a Vec of string references for sorting. Reverse element\n        // order for clarity.\n        let mut v = self.aliases.iter()\n            .map(|(a, c)| (&amp;c[..], &amp;a[..])).collect::&lt;Vec&lt;_&gt;&gt;();\n        v.sort_by_key(|t| t.0); // Make identical keys adjacent.\n        let g = v.into_iter().group_by(|t| t.0); // Create grouping.\n        g.into_iter()\n            .map(|(key, group)| // key is the str with the key\n                                // group is a subiterator that just visits\n                                // elements with that key, Item=&amp;(&amp;str,&amp;str)\n                (key.to_string(), // result is a tuple of the key as String\n                 group.map(|t| t.1.to_string()).collect())\n                   // and the subiterator turned into a Vec&lt;String&gt;\n                )\n            .collect() // finally, turn Iterator&lt;Item=(String, Vec&lt;String&gt;) into Vec\n    }\n}\n</code></pre>\n\n<p>Going back to your original problem, you have the additional issue that <code>Arc&lt;Object&gt;</code> is only <code>PartialEq</code> (needed by <code>group_by</code>) if <code>Object</code> is; same for <code>Ord</code> (needed by <code>sort_by_key</code>). If your <code>Object</code> type cannot be compared that way and you want to use the pointer identity, your intermediate vector will need to store some newtype wrapper around <code>Arc</code> that uses pointer values for comparison.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1488894847, "creation_date": 1488894847, "answer_id": 42650146, "question_id": 42645273, "link": "https://stackoverflow.com/questions/42645273/how-to-reverse-map-of-objects-to-vector-of-tuples-by-using-an-iterator/42650146#42650146", "title": "How to reverse map of objects to vector of tuples by using an iterator?", "body": "<blockquote>\n  <p>I could write a lot of code with <code>for</code> and <code>find</code>s but it seems to me this would be less efficient and I think there is a way to do that by using iterators only.</p>\n</blockquote>\n\n<p>I wouldn't call it <em>a lot</em> of code, and remember that <code>for</code> loops <strong>operate on iterators</strong>. I've not done any benchmarking, but this is far simpler and I'd expect it to be more performant:</p>\n\n<pre><code>use std::collections::HashMap;\n\nfn get_aliases(aliases: HashMap&lt;String, String&gt;) -&gt; Vec&lt;(String, Vec&lt;String&gt;)&gt; {\n    let mut x = HashMap::new();\n\n    for (k, v) in aliases {\n        x.entry(v).or_insert_with(Vec::new).push(k)\n    }\n\n    x.into_iter().collect()\n}\n\nfn main() {\n    let mut aliases = HashMap::new();\n    aliases.insert(\"a\".to_owned(), \"test\".to_owned());\n    aliases.insert(\"b\".to_owned(), \"test\".to_owned());\n    aliases.insert(\"c\".to_owned(), \"test2\".to_owned());\n\n    println!(\"{:?}\", get_aliases(aliases));\n}\n</code></pre>\n"}], "owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2203, "favorite_count": 0, "accepted_answer_id": 42650146, "answer_count": 2, "score": 3, "last_activity_date": 1488894847, "creation_date": 1488881063, "last_edit_date": 1488894535, "question_id": 42645273, "link": "https://stackoverflow.com/questions/42645273/how-to-reverse-map-of-objects-to-vector-of-tuples-by-using-an-iterator", "title": "How to reverse map of objects to vector of tuples by using an iterator?", "body": "<p>What is the easiest way to convert <code>HashMap&lt;String, String&gt;</code> to <code>Vec&lt;(String, Vec&lt;String&gt;)&gt;</code> by using an iterator ? I want to reverse the map.</p>\n\n<p>I've tried to use <code>iter()</code> methods but have no idea how to do a correct <code>map</code> closure implementation for collecting values after:</p>\n\n<pre><code>fn get_aliases(&amp;self) -&gt; Vec&lt;(String, Vec&lt;String&gt;)&gt; {\n    let mut aliases: HashMap&lt;String, String&gt; = HashMap::new();\n    aliases.insert(\"a\".to_owned(), \"test\".to_owned());\n    aliases.insert(\"b\".to_owned(), \"test\".to_owned());\n    aliases.insert(\"c\".to_owned(), \"test2\".to_owned());\n\n    aliases.iter().map(|(ref a, ref c)| {\n        // what to do here?\n    }).collect()\n\n    // the expected return value is:\n    // [(\"test\", [\"a\", \"b\"]), (\"test2\", [\"c\"])]\n}\n</code></pre>\n\n<p>This function will return a vector which says what <code>String</code> keys belong to some object.</p>\n\n<p>I could write a lot of code with <code>for</code> and <code>find</code>s but it seems to me this would be less efficient and I think there is a way to do that by using iterators only.</p>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 75, "user_id": 7448702, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/054aaf4bc3ed29dc13fa6434123a3d96?s=128&d=identicon&r=PG&f=1", "display_name": "Chris", "link": "https://stackoverflow.com/users/7448702/chris"}, "edited": false, "score": 0, "creation_date": 1488914467, "post_id": 42644711, "comment_id": 72438854, "body": "Awesome, thanks! <code>into_iter()</code> and not using <code>collect()</code> was what I was missing. It now works."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 3, "last_activity_date": 1488880890, "last_edit_date": 1495540436, "creation_date": 1488879487, "answer_id": 42644711, "question_id": 42644319, "link": "https://stackoverflow.com/questions/42644319/returning-a-struct-created-by-serde-json-in-a-function/42644711#42644711", "title": "Returning a struct created by serde_json in a function", "body": "<p>Without knowing more about your project (please produce an <a href=\"https://stackoverflow.com/help/mcve\">MCVE</a> next time), I'd say that you can change the <code>.iter()</code> call into <code>.into_iter()</code>. Instead of collecting into a <code>Vec</code> and then using <code>get</code>, I'd simply work with the iterator directly:</p>\n\n<pre><code>let m = data.deploy_info.value.into_iter().filter(|&amp;x| x.app == \"myapp\").fuse();\n\nmatch (m.next(), m.next()) {\n    (None, None) =&gt; Err(Error::NoDeployInfo),\n    (Some(x), None) =&gt; Ok(x),\n    (Some(_), Some(_)) =&gt; Err(Error::MultipleDeployInfo),\n    (None, Some(_)) =&gt; panic!(\"Iterator::fuse broken\"),\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 75, "user_id": 7448702, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/054aaf4bc3ed29dc13fa6434123a3d96?s=128&d=identicon&r=PG&f=1", "display_name": "Chris", "link": "https://stackoverflow.com/users/7448702/chris"}, "edited": false, "score": 0, "creation_date": 1488914568, "post_id": 42645089, "comment_id": 72438927, "body": "Excellent, thanks for the detailed explanation! I totally understand it now."}], "tags": [], "owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "is_accepted": false, "score": 2, "last_activity_date": 1488880582, "creation_date": 1488880582, "answer_id": 42645089, "question_id": 42644319, "link": "https://stackoverflow.com/questions/42644319/returning-a-struct-created-by-serde-json-in-a-function/42645089#42645089", "title": "Returning a struct created by serde_json in a function", "body": "<p>Observe the types of your snippet.</p>\n\n<pre><code>let m = data.deploy_info.value // value is a Vec&lt;MyAppDeployInfo&gt;\n    .iter() // returns a Iterator&lt;Item=&amp;MyAppDeployInfo&gt;\n    .filter(|&amp;x| x.app == \"myapp\")\n    .collect::&lt;Vec&lt;_&gt;&gt;(); // collects into a Vec&lt;&amp;MyAppDeployInfo&gt;\n\nif m.len() &gt; 1 {\n    return Err(Error::MultipleDeployInfo);\n}\n\nmatch m.get(0) { // get() returns a reference to an element\n                 // i.e. a &amp;&amp;MyAppDeployInfo\n        Some(&amp;x) // pattern match says x : &amp;MyAppDeployInfo\n            =&gt; Ok(x), // which matches the return type\n                      // but you get a borrowing error.\n        None =&gt; Err(Error::NoDeployInfo),\n    }\n}\n</code></pre>\n\n<p>Now if you change the return type to <code>Result&lt;MyAppDeployInfo, Error&gt;</code> as you should, you get the mismatched type issue, because <code>x</code> is a reference. If you dereference <code>x</code>, you get the error \"cannot move out of borrowed content\", because <code>MyAppDeployInfo</code> is not <code>Copy</code>, and you're trying to move. If you write <code>x.clone()</code>, it should work, unless you changed something else?</p>\n\n<p>Alternatively, you can, from the beginning, work with moving content around. If you write <code>data.deploy_info.value.into_iter().filter(|x| x.app == \"myapp\")</code>, you move out of the initial structure instead of copying it. Then the resulting <code>Vec</code> will have <code>MyAppDeployInfo</code> as its item type. Then you could make it <code>mut</code> and use <code>pop()</code> instead of <code>get(0)</code> to get the only element in a way that you can move out of.</p>\n\n<p>Or you can do what @ker recommended and not use <code>collect()</code> in the first place. I'd still switch to <code>into_iter()</code> though, making this the final code:</p>\n\n<pre><code>fn terraform_deploy_info(app: &amp;MyApp) // no explicit lifetime needed\n        -&gt; std::result::Result&lt;MyAppDeployInfo, Error&gt; {\n    let data = // ...\n\n    let mut m = data.deploy_info.value.into_iter()\n        .filter(|x| x.app == \"myapp\").fuse();\n\n    match (m.next(), m.next()) {\n        (None, None) =&gt; Err(Error::NoDeployInfo),\n        (Some(x), None) =&gt; Ok(x),\n        (Some(_), Some(_)) =&gt; Err(Error::MultipleDeployInfo),\n        (None, Some(_)) =&gt; panic!(\"Iterator::fuse broken\"),\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 75, "user_id": 7448702, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/054aaf4bc3ed29dc13fa6434123a3d96?s=128&d=identicon&r=PG&f=1", "display_name": "Chris", "link": "https://stackoverflow.com/users/7448702/chris"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 359, "favorite_count": 0, "accepted_answer_id": 42644711, "answer_count": 2, "score": 3, "last_activity_date": 1488894464, "creation_date": 1488878282, "last_edit_date": 1488894464, "question_id": 42644319, "link": "https://stackoverflow.com/questions/42644319/returning-a-struct-created-by-serde-json-in-a-function", "title": "Returning a struct created by serde_json in a function", "body": "<p>I'm stuck on what seems like a simple issue. I get <em>why</em> I am seeing the error but can't seem to resolve it. Obviously I am missing something fundamental.</p>\n\n<pre><code>fn terraform_deploy_info&lt;'a&gt;(app: &amp;'a MyApp) -&gt; std::result::Result&lt;&amp;MyAppDeployInfo, Error&gt; {\n    let terraform = process::Command::new(\"terraform\")\n          // We are querying output values.\n          .arg(\"output\")\n          // We want it in json format for easy processing.\n          .arg(\"-json\")\n          .output()\n          .expect(\"failed to execute terraform\");\n\n    let output = String::from_utf8_lossy(&amp;terraform.stdout);\n    let data: TerraformOutputs = serde_json::from_str(&amp;output).unwrap();\n\n    let m = data.deploy_info.value.iter().filter(|&amp;x| x.app == \"myapp\").collect::&lt;Vec&lt;_&gt;&gt;();\n\n    if m.len() &gt; 1 {\n        return Err(Error::MultipleDeployInfo);\n    }\n\n    match m.get(0) {\n        Some(&amp;x) =&gt; Ok(x),\n        None =&gt; Err(Error::NoDeployInfo),\n    }\n}\n</code></pre>\n\n<p>The error I get is:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>borrowed value must be valid for the lifetime 'a as defined on the body at\n</code></pre>\n\n<p>Which makes sense to me, as I am creating the struct in the function and returning a borrowed reference, which of course goes away when the function is finished.</p>\n\n<p><em>But</em>, when I change the return type be <code>std::result::Result&lt;MyAppDeployInfo, Error&gt;</code> (that is, not returning a reference) I can't seem to get <code>Ok(x)</code> to work...I get an error:</p>\n\n<pre><code>expected struct `MyAppDeployInfo`, found reference\n</code></pre>\n\n<p>Again, this makes sense as <code>serde_json</code> creates a structure and then I iterate through references, so when I index into the collection I am looking at a reference.</p>\n\n<p>So I tried all sorts of things to get the struct value like dereferencing, <code>Box::new</code>, <code>clone()</code>, <code>to_owned()</code>, etc and still can't get it to work. </p>\n\n<p>I've searched all the issues here, read the book, etc and it is still not clear to me how I can resolve this...any pointers would be appreciated.</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 838, "user_id": 3613212, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/NfaGR.png?s=128&g=1", "display_name": "Gr&#233;gory OBANOS", "link": "https://stackoverflow.com/users/3613212/gr%c3%a9gory-obanos"}, "edited": false, "score": 1, "creation_date": 1488846897, "post_id": 42637911, "comment_id": 72403859, "body": "Wow, that&#39;s strange ! Looking at the MIR for both hint functions, it looks like rust drop the &#39;a lifetime when using PhantomData&lt;fn(&amp;&#39;a ())&gt;. IDK if it&#39;s a feature or a bug :D"}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1488853187, "post_id": 42637911, "comment_id": 72405551, "body": "I suspect the answer has to do with <a href=\"https://doc.rust-lang.org/nightly/nomicon/subtyping.html\" rel=\"nofollow noreferrer\">variance</a>, specifically the offhand comment that <code>fn(T)</code> is <i>contravariant</i> in <code>T</code> -- however, I&#39;m not quite up to the task of explaining why."}], "answers": [{"comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 13, "creation_date": 1488861613, "post_id": 42639814, "comment_id": 72407991, "body": "This is quite possibly the single best answer in the Rust tag. There is so much information here it is amazing. Thank you for taking the time to write it. (I know &quot;thanks&quot; comments are frowned upon ... but come on... look at this answer)"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 69, "last_activity_date": 1488917792, "last_edit_date": 1488917792, "creation_date": 1488858359, "answer_id": 42639814, "question_id": 42637911, "link": "https://stackoverflow.com/questions/42637911/how-can-this-instance-seemingly-outlive-its-own-parameter-lifetime/42639814#42639814", "title": "How can this instance seemingly outlive its own parameter lifetime?", "body": "<p>Despite your best intentions, your <code>hint</code> function may not have the effect you expect. But we have quite a bit of ground to cover before we can understand what's going on.</p>\n\n<hr>\n\n<p>Let's begin with this:</p>\n\n<pre><code>fn ensure_equal&lt;'z&gt;(a: &amp;'z (), b: &amp;'z ()) {}\n\nfn main() {\n    let a = ();\n    let b = ();\n    ensure_equal(&amp;a, &amp;b);\n}\n</code></pre>\n\n<p>OK, so in <code>main</code>, we defining two variables, <code>a</code> and <code>b</code>. They have distinct lifetimes, by virtue of being introduced by distinct <code>let</code> statements. <code>ensure_equal</code> requires two references with <em>the same lifetime</em>. And yet, this code compiles. Why?</p>\n\n<p>That's because, given <code>'a: 'b</code> (read: <code>'a</code> outlives <code>'b</code>), <code>&amp;'a T</code> is a <a href=\"https://doc.rust-lang.org/nightly/nomicon/subtyping.html\" rel=\"noreferrer\"><em>subtype</em></a> of <code>&amp;'b T</code>.</p>\n\n<p>Let's say the lifetime of <code>a</code> is <code>'a</code> and the lifetime of <code>b</code> is <code>'b</code>. It's a fact that <code>'a: 'b</code>, because <code>a</code> is introduced first. On the call to <code>ensure_equal</code>, the arguments are typed <code>&amp;'a ()</code> and <code>&amp;'b ()</code>, respectively<sup>1</sup>. There's a type mismatch here, because <code>'a</code> and <code>'b</code> are not the same lifetime. But the compiler doesn't give up yet! It knows that <code>&amp;'a ()</code> is a subtype of <code>&amp;'b ()</code>. In other words, a <code>&amp;'a ()</code> <em>is a</em> <code>&amp;'b ()</code>. The compiler will therefore coerce the expression <code>&amp;a</code> to type <code>&amp;'b ()</code>, so that both arguments are typed <code>&amp;'b ()</code>. This resolves the type mismatch.</p>\n\n<p>If you're confused by the application of \"subtypes\" with lifetimes, then let me rephrase this example in Java terms. Let's replace <code>&amp;'a ()</code> with <code>Programmer</code> and <code>&amp;'b ()</code> with <code>Person</code>. Now let's say that <code>Programmer</code> is derived from <code>Person</code>: <code>Programmer</code> is therefore a subtype of <code>Person</code>. That means that we can take a variable of type <code>Programmer</code> and pass it as an argument to a function that expects a parameter of type <code>Person</code>. That's why the following code will successfully compile: the compiler will resolve <code>T</code> as <code>Person</code> for the call in <code>main</code>.</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>class Person {}\nclass Programmer extends Person {}\n\nclass Main {\n    private static &lt;T&gt; void ensureSameType(T a, T b) {}\n\n    public static void main(String[] args) {\n        Programmer a = null;\n        Person b = null;\n        ensureSameType(a, b);\n    }\n}\n</code></pre>\n\n<p>Perhaps the non-intuitive aspect of this subtyping relation is that the longer lifetime is a subtype of the shorter lifetime. But think of it this way: in Java, it's safe to pretend that a <code>Programmer</code> is a <code>Person</code>, but you can't assume that a <code>Person</code> is a <code>Programmer</code>. Likewise, it's safe to pretend that a variable has a <em>shorter</em> lifetime, but you can't assume that a variable with some known lifetime actually has a <em>longer</em> lifetime. After all, the whole point of lifetimes in Rust is to ensure that you don't access objects beyond their actual lifetime.</p>\n\n<hr>\n\n<p>Now, let's talk about <a href=\"https://doc.rust-lang.org/nightly/nomicon/subtyping.html#variance\" rel=\"noreferrer\">variance</a>. What's that?</p>\n\n<blockquote>\n  <p>Variance is a property that type constructors have with respect to their arguments. A type constructor in Rust is a generic type with unbound arguments. For instance <code>Vec</code> is a type constructor that takes a <code>T</code> and returns a <code>Vec&lt;T&gt;</code>. <code>&amp;</code> and <code>&amp;mut</code> are type constructors that take two inputs: a lifetime, and a type to point to.</p>\n</blockquote>\n\n<p>Normally, you would expect all elements of a <code>Vec&lt;T&gt;</code> to have the same type (and we're not talking about trait objects here). But variance lets us cheat with that.</p>\n\n<p><code>&amp;'a T</code> is <em>covariant</em> over <code>'a</code> and <code>T</code>. That means that wherever we see <code>&amp;'a T</code> in a type argument, we can substitute it with a subtype of <code>&amp;'a T</code>. Let's see how it works out:</p>\n\n<pre><code>fn main() {\n    let a = ();\n    let b = ();\n    let v = vec![&amp;a, &amp;b];\n}\n</code></pre>\n\n<p>We've already established that <code>a</code> and <code>b</code> have different lifetimes, and that the expressions <code>&amp;a</code> and <code>&amp;b</code> don't have the same type<sup>1</sup>. So why can we make a <code>Vec</code> out of these? The reasoning is the same as above, so I'll summarize: <code>&amp;a</code> is coerced to <code>&amp;'b ()</code>, so that the type of <code>v</code> is <code>Vec&lt;&amp;'b ()&gt;</code>.</p>\n\n<hr>\n\n<p><code>fn(T)</code> is a special case in Rust when it comes to variance. <code>fn(T)</code> is <em>contravariant</em> over <code>T</code>. Let's build a <code>Vec</code> of functions!</p>\n\n<pre><code>fn foo(_: &amp;'static ()) {}\nfn bar&lt;'a&gt;(_: &amp;'a ()) {}\n\nfn quux&lt;'a&gt;() {\n    let v = vec![\n        foo as fn(&amp;'static ()),\n        bar as fn(&amp;'a ()),\n    ];\n}\n\nfn main() {\n    quux();\n}\n</code></pre>\n\n<p>This compiles. But what's the type of <code>v</code> in <code>quux</code>? Is it <code>Vec&lt;fn(&amp;'static ())&gt;</code> or <code>Vec&lt;fn(&amp;'a ())&gt;</code>?</p>\n\n<p>I'll give you a hint:</p>\n\n<pre><code>fn foo(_: &amp;'static ()) {}\nfn bar&lt;'a&gt;(_: &amp;'a ()) {}\n\nfn quux&lt;'a&gt;(a: &amp;'a ()) {\n    let v = vec![\n        foo as fn(&amp;'static ()),\n        bar as fn(&amp;'a ()),\n    ];\n    v[0](a);\n}\n\nfn main() {\n    quux(&amp;());\n}\n</code></pre>\n\n<p>This <em>doesn't</em> compile. Here are the compiler messages:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n --&gt; &lt;anon&gt;:5:13\n  |\n5 |       let v = vec![\n  |  _____________^ starting here...\n6 | |         foo as fn(&amp;'static ()),\n7 | |         bar as fn(&amp;'a ()),\n8 | |     ];\n  | |_____^ ...ending here\n  |\nnote: first, the lifetime cannot outlive the lifetime 'a as defined on the body at 4:23...\n --&gt; &lt;anon&gt;:4:24\n  |\n4 |   fn quux&lt;'a&gt;(a: &amp;'a ()) {\n  |  ________________________^ starting here...\n5 | |     let v = vec![\n6 | |         foo as fn(&amp;'static ()),\n7 | |         bar as fn(&amp;'a ()),\n8 | |     ];\n9 | |     v[0](a);\n10| | }\n  | |_^ ...ending here\nnote: ...so that reference does not outlive borrowed content\n --&gt; &lt;anon&gt;:9:10\n  |\n9 |     v[0](a);\n  |          ^\n  = note: but, the lifetime must be valid for the static lifetime...\nnote: ...so that types are compatible (expected fn(&amp;()), found fn(&amp;'static ()))\n --&gt; &lt;anon&gt;:5:13\n  |\n5 |       let v = vec![\n  |  _____________^ starting here...\n6 | |         foo as fn(&amp;'static ()),\n7 | |         bar as fn(&amp;'a ()),\n8 | |     ];\n  | |_____^ ...ending here\n  = note: this error originates in a macro outside of the current crate\n\nerror: aborting due to previous error\n</code></pre>\n\n<p>We're trying to call one of the functions in the vector with a <code>&amp;'a ()</code> argument. But <code>v[0]</code> expects a <code>&amp;'static ()</code>, and there's no guarantee that <code>'a</code> is <code>'static</code>, so this is invalid. We can therefore conclude that the type of <code>v</code> is <code>Vec&lt;fn(&amp;'static ())&gt;</code>. As you can see, contravariance is the opposite of covariance: we can replace a short lifetime with a <em>longer</em> one.</p>\n\n<hr>\n\n<p>Whew, now back to your question. First, let's see what the compiler makes out of the call to <code>hint</code>. <code>hint</code> has the following signature:</p>\n\n<pre><code>fn hint&lt;'a, Arg&gt;(_: &amp;'a Arg) -&gt; Foo&lt;'a&gt;\n</code></pre>\n\n<p><code>Foo</code> is <em>contravariant</em> over <code>'a</code> because <code>Foo</code> wraps a <code>fn</code> (or rather, <em>pretends to</em>, thanks to the <code>PhantomData</code>, but that doesn't make a difference when we talk about variance; both have the same effect), <code>fn(T)</code> is contravariant over <code>T</code> and that <code>T</code> here is <code>&amp;'a ()</code>.</p>\n\n<p>When the compiler tries to resolve the call to <code>hint</code>, it only considers <code>shortlived</code>'s lifetime. Therefore, <code>hint</code> returns a <code>Foo</code> with <code>shortlived</code>'s lifetime. But when we try to assign that to the variable <code>foo</code>, we have a problem: a lifetime parameter on a type always outlives the type itself, and <code>shortlived</code>'s lifetime doesn't outlive <code>foo</code>'s lifetime, so clearly, we can't use that type for <code>foo</code>. If <code>Foo</code> was covariant over <code>'a</code>, that would be the end of it and you'd get an error. But <code>Foo</code> is <em>contravariant</em> over <code>'a</code>, so we can replace <code>shortlived</code>'s lifetime with a <em>larger</em> lifetime. That lifetime can be any lifetime that outlives <code>foo</code>'s lifetime. Note that \"outlives\" is not the same as \"strictly outlives\": the difference is that <code>'a: 'a</code> (<code>'a</code> outlives <code>'a</code>) is true, but <code>'a</code> strictly outlives <code>'a</code> is false (i.e. a lifetime is said to outlive itself, but it doesn't <em>strictly outlive</em> itself). Therefore, we might end up with <code>foo</code> having type <code>Foo&lt;'a&gt;</code> where <code>'a</code> is exactly the lifetime of <code>foo</code> itself.</p>\n\n<p>Now let's look at <code>check(&amp;foo, &amp;outlived);</code> (that's the second one). This one compiles because <code>&amp;outlived</code> is coerced so that the lifetime is shortened to match <code>foo</code>'s lifetime. That's valid because <code>outlived</code> has a longer lifetime than <code>foo</code>, and <code>check</code>'s second argument is covariant over <code>'a</code> because it's a reference.</p>\n\n<p>Why doesn't <code>check(&amp;foo, &amp;shortlived);</code> compile? <code>foo</code> has a longer lifetime than <code>&amp;shortlived</code>. <code>check</code>'s second argument is covariant over <code>'a</code>, but its first argument is <em>contravariant</em> over <code>'a</code>, because <code>Foo&lt;'a&gt;</code> is contravariant. That is, both arguments are trying to pull <code>'a</code> in opposite directions for this call: <code>&amp;foo</code> is trying to enlarge <code>&amp;shortlived</code>'s lifetime (which is illegal), while <code>&amp;shortlived</code> is trying to shorten <code>&amp;foo</code>'s lifetime (which is also illegal). There is no lifetime that will unify these two variables, therefore the call is invalid.</p>\n\n<hr>\n\n<p><em><sup>1</sup> That might actually be a simplification. I believe that the lifetime parameter of a reference actually represents the region in which the borrow is active, rather than the lifetime of the reference. In this example, both borrows would be active for the statement that contains the call to <code>ensure_equal</code>, so they would have the same type. But if you split the borrows to separate <code>let</code> statements, the code still works, so the explanation is still valid. That said, for a borrow to be valid, the referent must outlive the borrow's region, so when I'm thinking of lifetime parameters, I only care about the referent's lifetime and I consider borrows separately.</em></p>\n"}, {"tags": [], "owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "is_accepted": false, "score": 4, "last_activity_date": 1489200707, "creation_date": 1489200707, "answer_id": 42730784, "question_id": 42637911, "link": "https://stackoverflow.com/questions/42637911/how-can-this-instance-seemingly-outlive-its-own-parameter-lifetime/42730784#42730784", "title": "How can this instance seemingly outlive its own parameter lifetime?", "body": "<p>Another way of explaining this is to notice that <code>Foo</code> doesn't actually hold a reference to anything with a lifetime of <code>'a</code>. Rather, it holds a function that <strong><em>accepts</em></strong> a reference with lifetime <code>'a</code>.</p>\n\n<p>You can construct this same behaviour with an actual function instead of <code>PhantomData</code>. And you can even call that function:</p>\n\n<pre><code>struct Foo&lt;'a&gt;(fn(&amp;'a ()));\n\nfn hint&lt;'a, Arg&gt;(_: &amp;'a Arg) -&gt; Foo&lt;'a&gt; {\n    fn bar&lt;'a, T: Debug&gt;(value: &amp;'a T) {\n        println!(\"The value is {:?}\", value);\n    }\n    Foo(bar)\n}\n\nfn main() {\n    let outlived = ();\n    let foo;\n    {\n        let shortlived = ();\n        // &amp;shortlived is borrowed by hint() but NOT stored in foo\n        foo = hint(&amp;shortlived);\n    }\n    foo.0(&amp;outlived);\n}\n</code></pre>\n\n<p>As Francis explained in his excellent answer, the type of <code>outlived</code> is a subtype of the type of <code>shortlived</code> because its lifetime is longer. Therefore, the function inside <code>foo</code> can accept it because it can be coerced to <code>shortlived</code>'s (shorter) lifetime. </p>\n"}], "owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2989, "favorite_count": 18, "accepted_answer_id": 42639814, "answer_count": 2, "score": 31, "last_activity_date": 1489200707, "creation_date": 1488845458, "question_id": 42637911, "link": "https://stackoverflow.com/questions/42637911/how-can-this-instance-seemingly-outlive-its-own-parameter-lifetime", "title": "How can this instance seemingly outlive its own parameter lifetime?", "body": "<p>Before I stumbled upon the code below, I was convinced that a lifetime in a type's lifetime parameter would always outlive its own instances. In other words, given a <code>foo: Foo&lt;'a&gt;</code>, then <code>'a</code> would always outlive <code>foo</code>. Then I was introduced to this counter-argument code by @Luc Danton (<a href=\"https://play.rust-lang.org/?gist=77356b872435d476359ec1e0602cc54c&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Playground</a>):</p>\n\n<pre><code>#[derive(Debug)]\nstruct Foo&lt;'a&gt;(std::marker::PhantomData&lt;fn(&amp;'a ())&gt;);\n\nfn hint&lt;'a, Arg&gt;(_: &amp;'a Arg) -&gt; Foo&lt;'a&gt; {\n    Foo(std::marker::PhantomData)\n}\n\nfn check&lt;'a&gt;(_: &amp;Foo&lt;'a&gt;, _: &amp;'a ()) {}\n\nfn main() {\n    let outlived = ();\n    let foo;\n\n    {\n        let shortlived = ();\n        foo = hint(&amp;shortlived);\n        // error: `shortlived` does not live long enough\n        //check(&amp;foo, &amp;shortlived);\n    }\n\n    check(&amp;foo, &amp;outlived);\n}\n</code></pre>\n\n<p>Even though the <code>foo</code> created by <code>hint</code> appears to consider a lifetime that does not live for as long as itself, and a reference to it is passed to a function in a wider scope, the code compiles exactly as it is. Uncommenting the line stated in the code triggers a compilation error. Alternatively, changing <code>Foo</code> to the struct tuple <code>(PhantomData&lt;&amp;'a ()&gt;)</code> also makes the code no longer compile with the same kind of error (<a href=\"https://play.rust-lang.org/?gist=9ad22db8a7d7bd0f764602098ffae9f3&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Playground</a>).</p>\n\n<p>How is it valid Rust code? What is the reasoning of the compiler here?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1488873853, "post_id": 42635556, "comment_id": 72413310, "body": "&quot;Does not work&quot; is the least useful diagnosis I can think of. I suppose that you have an error message you could show off?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1488877866, "post_id": 42635556, "comment_id": 72415338, "body": "Are you sure it actually adds anything to the release binary, if nothing calls quickcheck?"}], "answers": [{"comments": [{"owner": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "edited": false, "score": 0, "creation_date": 1488835131, "post_id": 42635679, "comment_id": 72399050, "body": ".quickcheck(prop_use_c_struct as fn(c_struct) -&gt; bool);    |          ^^^^^^^^^^ the trait <code>quickcheck::Arbitrary</code> is not implemented for <code>rusty::rusty_c_struct::c_struct</code>"}, {"owner": {"reputation": 8378, "user_id": 124538, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/82159aeb57c52bc0c7bfe6e9c832c3ea?s=128&d=identicon&r=PG", "display_name": "Wesley Wiser", "link": "https://stackoverflow.com/users/124538/wesley-wiser"}, "reply_to_user": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "edited": false, "score": 1, "creation_date": 1488835992, "post_id": 42635679, "comment_id": 72399519, "body": "@laser_wizard that&#39;s very strange. The quickcheck documentation even mentions the <code>#[cfg(test)]</code> approach <a href=\"https://github.com/BurntSushi/quickcheck#simple-example\" rel=\"nofollow noreferrer\">github.com/BurntSushi/quickcheck#simple-example</a>"}, {"owner": {"reputation": 8378, "user_id": 124538, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/82159aeb57c52bc0c7bfe6e9c832c3ea?s=128&d=identicon&r=PG", "display_name": "Wesley Wiser", "link": "https://stackoverflow.com/users/124538/wesley-wiser"}, "reply_to_user": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "edited": false, "score": 0, "creation_date": 1488836121, "post_id": 42635679, "comment_id": 72399583, "body": "@laser_wizard how are you running quickcheck? <code>cargo test</code> or something else?"}, {"owner": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "edited": false, "score": 0, "creation_date": 1488836342, "post_id": 42635679, "comment_id": 72399683, "body": "<code>cargo test</code>, yes. I thought I had it by adding the macro to my prop function, but I had removed the macro from the <code>impl</code> definition."}, {"owner": {"reputation": 8378, "user_id": 124538, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/82159aeb57c52bc0c7bfe6e9c832c3ea?s=128&d=identicon&r=PG", "display_name": "Wesley Wiser", "link": "https://stackoverflow.com/users/124538/wesley-wiser"}, "reply_to_user": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "edited": false, "score": 0, "creation_date": 1488836559, "post_id": 42635679, "comment_id": 72399789, "body": "Hmm... The <code>test</code> symbol should be defined then so it should be picking up the implementation."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488853284, "post_id": 42635679, "comment_id": 72405581, "body": "As <a href=\"http://stackoverflow.com/questions/42635556/is-it-possible-to-implement-a-trait-for-a-struct-only-while-running-tests/42636226?noredirect=1#comment72405421_42636226\">Francis Gagn&#233; points out</a>, you could also put the <code>impl Arbitrary</code> into an existing <code>cfg(test)</code> block, which you are likely to have anyway for unit tests."}], "tags": [], "owner": {"reputation": 8378, "user_id": 124538, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/82159aeb57c52bc0c7bfe6e9c832c3ea?s=128&d=identicon&r=PG", "display_name": "Wesley Wiser", "link": "https://stackoverflow.com/users/124538/wesley-wiser"}, "is_accepted": false, "score": 3, "last_activity_date": 1488836603, "last_edit_date": 1488836603, "creation_date": 1488834837, "answer_id": 42635679, "question_id": 42635556, "link": "https://stackoverflow.com/questions/42635556/is-it-possible-to-implement-a-trait-for-a-struct-only-while-running-tests/42635679#42635679", "title": "Is it possible to implement a trait for a struct only while running tests?", "body": "<p>You can use the conditional compilation attribute <a href=\"https://doc.rust-lang.org/book/conditional-compilation.html\" rel=\"nofollow noreferrer\"><code>#[cfg()]</code></a> here:</p>\n\n<pre><code>pub struct c_struct {\n    pub i64_: i64,\n    pub u64_: u64,\n    pub u32_: u32,\n}\n\n#[cfg(test)]\nimpl quickcheck::Arbitrary for c_struct {\n    fn arbitrary&lt;G: quickcheck::Gen&gt;(g: &amp;mut G) -&gt; c_struct {\n        c_struct {\n            i64_: i64::arbitrary(g),\n            u64_: u64::arbitrary(g),\n            u32_: u32::arbitrary(g),\n        }\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1488852678, "post_id": 42636226, "comment_id": 72405421, "body": "If <code>c_struct</code> is defined in the same crate, it&#39;s not necessary to define a newtype. You can just write <code>impl quickcheck::Arbitrary for super::c_struct</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 1, "creation_date": 1488853207, "post_id": 42636226, "comment_id": 72405556, "body": "@FrancisGagn&#233; a good point; I do normally ignore the fact that that the implementation doesn&#39;t have to be &quot;right next&quot; to the type or the trait, so long as it&#39;s the the same crate as either. However, that&#39;s basically what <a href=\"http://stackoverflow.com/a/42635679/155423\">the other answer says</a>, so I won&#39;t edit this question to avoid stealing their answer."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1488836891, "last_edit_date": 1495541373, "creation_date": 1488836891, "answer_id": 42636226, "question_id": 42635556, "link": "https://stackoverflow.com/questions/42635556/is-it-possible-to-implement-a-trait-for-a-struct-only-while-running-tests/42636226#42636226", "title": "Is it possible to implement a trait for a struct only while running tests?", "body": "<p>A <a href=\"https://stackoverflow.com/q/25413201/155423\">common solution to this</a> is to use a <a href=\"https://doc.rust-lang.org/stable/book/structs.html#tuple-structs\" rel=\"nofollow noreferrer\"><em>newtype</em></a> that is only defined in the tests:</p>\n\n<pre><code>struct c_struct {\n    pub i64_: i64,\n    pub u64_: u64,\n    pub u32_: u32,\n}\n\n#[cfg(test)]\nmod test {\n    struct ArbitraryCStruct(c_struct);\n\n    impl quickcheck::Arbitrary for ArbitraryCStruct {\n        fn arbitrary&lt;G: quickcheck::Gen&gt;(g: &amp;mut G) -&gt; ArbitraryCStruct {\n            ArbitraryCStruct(c_struct {\n                i64_: i64::arbitrary(g),\n                u64_: u64::arbitrary(g),\n                u32_: u32::arbitrary(g),\n            })\n        }\n    }\n}\n</code></pre>\n\n<p>You can then accept this in your quickcheck function. If you need to, you can extract the value using <code>.0</code> or implement the <code>From</code> or <code>Into</code> trait as needed.</p>\n"}], "owner": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 371, "favorite_count": 0, "accepted_answer_id": 42636226, "answer_count": 2, "score": 1, "last_activity_date": 1488836891, "creation_date": 1488834433, "last_edit_date": 1488836564, "question_id": 42635556, "link": "https://stackoverflow.com/questions/42635556/is-it-possible-to-implement-a-trait-for-a-struct-only-while-running-tests", "title": "Is it possible to implement a trait for a struct only while running tests?", "body": "<p>I'm using <a href=\"https://github.com/BurntSushi/quickcheck\" rel=\"nofollow noreferrer\">quickcheck</a> and would like to implement <code>quickcheck::Arbitrary</code> for a struct. This trait has to exist in the same file/crate that the struct is defined, but I don't want it in the release binary.</p>\n\n<pre><code>pub struct c_struct {\n    pub i64_: i64,\n    pub u64_: u64,\n    pub u32_: u32,\n}\n\n// #[cfg(test)] does not work\nimpl quickcheck::Arbitrary for c_struct {\n    fn arbitrary&lt;G: quickcheck::Gen&gt;(g: &amp;mut G) -&gt; c_struct {\n        c_struct {\n            i64_: i64::arbitrary(g),\n            u64_: u64::arbitrary(g),\n            u32_: u32::arbitrary(g),\n        }\n    }\n}\n</code></pre>\n"}, {"tags": ["rust", "cross-compiling", "toolchain"], "answers": [{"comments": [{"owner": {"reputation": 1113, "user_id": 969295, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/dea809ef5ac9770fb400f1eb65544443?s=128&d=identicon&r=PG", "display_name": "Sassa", "link": "https://stackoverflow.com/users/969295/sassa"}, "edited": false, "score": 0, "creation_date": 1489064523, "post_id": 42644112, "comment_id": 72514099, "body": "This didn&#39;t work for me, what worked was creating the <code>config.toml</code> file with <code>[target.i686-unknown-linux-gnu] cc = &quot;i686-unknown-linux-gnu-gcc&quot; cxx = &quot;i686-unknown-linux-gnu-g++&quot;</code>"}], "tags": [], "owner": {"reputation": 3416, "user_id": 2484972, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/ea1c4b2c5aa3c7da2f2740bc1a643ee0?s=128&d=identicon&r=PG", "display_name": "Tatsuyuki Ishi", "link": "https://stackoverflow.com/users/2484972/tatsuyuki-ishi"}, "is_accepted": false, "score": 0, "last_activity_date": 1488877582, "creation_date": 1488877582, "answer_id": 42644112, "question_id": 42628715, "link": "https://stackoverflow.com/questions/42628715/how-do-i-specify-the-compiler-to-use-when-cross-compiling-rustc/42644112#42644112", "title": "How do I specify the compiler to use when cross-compiling rustc?", "body": "<p>It's specified using suffixed environment variables: see <a href=\"https://github.com/rust-lang/rust/blob/master/src/ci/docker/cross/Dockerfile#L69\" rel=\"nofollow noreferrer\">here</a> for what they do in CI.</p>\n"}], "owner": {"reputation": 1113, "user_id": 969295, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/dea809ef5ac9770fb400f1eb65544443?s=128&d=identicon&r=PG", "display_name": "Sassa", "link": "https://stackoverflow.com/users/969295/sassa"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 461, "favorite_count": 0, "answer_count": 1, "score": 4, "last_activity_date": 1488877582, "creation_date": 1488812160, "last_edit_date": 1488812280, "question_id": 42628715, "link": "https://stackoverflow.com/questions/42628715/how-do-i-specify-the-compiler-to-use-when-cross-compiling-rustc", "title": "How do I specify the compiler to use when cross-compiling rustc?", "body": "<p>When I compile <code>rustc</code>, there is a option in the configure script to specify other targets to the core libraries (<code>libcore</code>, <code>libstd</code>, etc), so for example:</p>\n\n<pre><code>./configure --target=x86_64-unknown-linux-gnu,i686-unknown-linux-gnu\n</code></pre>\n\n<p>will compile and install the <code>rustlibs</code> for both these architectures.</p>\n\n<p>My problem is that this command will use my default gcc to compile everything, (since my system is multilib, it will successfully compile to i686 too), but what I want is to use my toolchain compiler instead, so for example:</p>\n\n<p>I have 2 toolchains in my amd64 system: <code>i686-unknown-linux-gnu</code> and <code>arm-unknown-linux-gnueabi</code>.</p>\n\n<p>When I run configure with these parameters:</p>\n\n<pre><code>./configure --target=x86_64-unknown-linux-gnu,i686-unknown-linux-gnu,arm-unknown-linux-gnueabi\n</code></pre>\n\n<p>When compiling the <code>rustlibs</code>, I want the script to use x86_64-unknown-linux-gnu-<strong>gcc</strong> for <code>x86_64</code>, and i686-unknown-linux-gnu-<strong>gcc</strong> for <code>i686</code> and arm-unknown-linux-gnueabi-<strong>gcc</strong> for <code>arm</code>.</p>\n\n<p>That way the <code>rustlib</code> will be compiled using the <code>glibc</code> and other libraries from the toolchain and not the default from my system. Is that possible?</p>\n"}, {"tags": ["time", "rust", "jwt"], "answers": [{"comments": [{"owner": {"reputation": 1279, "user_id": 5130134, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/uNgFI.png?s=128&g=1", "display_name": "NotBad4U", "link": "https://stackoverflow.com/users/5130134/notbad4u"}, "edited": false, "score": 0, "creation_date": 1488815363, "post_id": 42629461, "comment_id": 72387643, "body": "You saved my day !"}], "tags": [], "owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "is_accepted": true, "score": 3, "last_activity_date": 1488815406, "last_edit_date": 1495542722, "creation_date": 1488814165, "answer_id": 42629461, "question_id": 42627267, "link": "https://stackoverflow.com/questions/42627267/how-to-convert-timetm-to-u64-for-jwt-expiration-date/42629461#42629461", "title": "How to convert time::Tm to u64 for JWT expiration date", "body": "<p>The <code>exp</code> field is of \"NumericDate\" type, which according to <a href=\"https://tools.ietf.org/html/rfc7519#section-2\" rel=\"nofollow noreferrer\">RFC 7519</a> is \"<em>number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds.</em>\"</p>\n\n<p>This description is the same as <a href=\"https://doc.rust-lang.org/time/time/struct.Tm.html#method.to_timespec\" rel=\"nofollow noreferrer\">the <code>to_timespec</code> method</a>, which \"<em>Convert time to the seconds from January 1, 1970</em>\" in the Tm's current timezone*.</p>\n\n<p>Thus:</p>\n\n<pre><code>let mut timer = time::now_utc();\ntimer = timer + Duration::days(1); \ntoken.claims.reg.exp = Some(timer.to_timespec().sec as u64);\n</code></pre>\n\n<p>(Note that while <code>time + duration</code> always return UTC time as of v0.1.36, it is arguably <a href=\"https://github.com/rust-lang-deprecated/time/blob/5d71ac97f31380d15af3abfc17618780522a1ad1/src/lib.rs#L342-L352\" rel=\"nofollow noreferrer\">a defect</a> that could be fixed in a future. To be forward-compatible, I used <code>now_utc()</code> instead of <code>now()</code>.)</p>\n\n<p>(*: <code>to_timespec</code> basically calls <code>gmtime()</code> on POSIX and the POSIX standard ignores leap seconds. On Windows it converts the structure to a FILETIME <a href=\"https://stackoverflow.com/questions/130573/does-the-windows-filetime-structure-include-leap-seconds\">which again ignores leap seconds</a>. So <code>to_timespec</code> is safe to use if you really care about the 27-second difference.) </p>\n\n<hr>\n\n<p>If you are using <code>std::time::SystemTime</code>, the same can be obtained using</p>\n\n<pre><code>let mut timer = SystemTime::now();\ntimer += Duration::from_secs(86400);\ntoken.claims.reg.exp = Some(timer.duration_since(UNIX_EPOCH).unwrap().as_secs());\n</code></pre>\n"}], "owner": {"reputation": 1279, "user_id": 5130134, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/uNgFI.png?s=128&g=1", "display_name": "NotBad4U", "link": "https://stackoverflow.com/users/5130134/notbad4u"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2275, "favorite_count": 0, "accepted_answer_id": 42629461, "answer_count": 1, "score": 2, "last_activity_date": 1488815406, "creation_date": 1488807973, "last_edit_date": 1488814820, "question_id": 42627267, "link": "https://stackoverflow.com/questions/42627267/how-to-convert-timetm-to-u64-for-jwt-expiration-date", "title": "How to convert time::Tm to u64 for JWT expiration date", "body": "<p>I'm using the <a href=\"http://mikkyang.github.io/rust-jwt/doc/jwt/index.html\" rel=\"nofollow noreferrer\">jwt crate</a> and I want to set the expiration date in the <code>Claims</code> struct. The <code>exp</code> field in <a href=\"http://mikkyang.github.io/rust-jwt/doc/jwt/claims/struct.Registered.html\" rel=\"nofollow noreferrer\"><code>Registered</code></a> took a <code>Option&lt;u64&gt;</code>.</p>\n\n<p>I can retrieve the current date and add 1 day to it by doing: </p>\n\n<pre><code>let mut timer = time::now();\ntimer = timer + Duration::days(1);\n</code></pre>\n\n<p>but I don't see how to convert this <code>time::Tm</code> to a <code>u64</code>.</p>\n"}, {"tags": ["arrays", "vector", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1488808565, "post_id": 42626321, "comment_id": 72382543, "body": "Quick note: you do not need to rush to accept an answer. Once an answer is accepted other people are less likely to come and try to answer, so sometimes waiting a bit to accept (say, a day or so, because timezones) will lead to you getting better answers."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 4, "last_activity_date": 1488807384, "creation_date": 1488807384, "answer_id": 42627052, "question_id": 42626321, "link": "https://stackoverflow.com/questions/42626321/how-do-i-store-a-800-row-25-column-file-in-an-n-dimensional-array/42627052#42627052", "title": "How do I store a 800 row, 25 column file in an N-dimensional array?", "body": "<p>I think you are misunderstanding what N-Dimensional means.</p>\n\n<p>An array with rows and columns only has <strong>2</strong> dimensions, and therefore can be represented easily as <code>Vec&lt;Vec&lt;f64&gt;&gt;</code>.</p>\n\n<p>I would therefore expect code like:</p>\n\n<pre><code>fn main() {\n    let mut rdr = csv::Reader::from_file(\"./data.csv\").unwrap();\n\n    let result = Vec::new();\n\n    for record in rdr.decode() {\n        let row: Vec&lt;f64&gt; = record.unwrap();\n        println!(\"{:?}\", row);\n        result.push(row);\n    }\n}\n</code></pre>\n\n<p>Taking advantage of the fact that <a href=\"http://burntsushi.net/rustdoc/rustc_serialize/trait.Decodable.html\" rel=\"nofollow noreferrer\"><code>Decodable</code></a> is implemented for <code>Vec&lt;T&gt;</code>.</p>\n"}], "owner": {"reputation": 3, "user_id": 7666477, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5929c61b987419dfbd8ec7ece9092fc2?s=128&d=identicon&r=PG&f=1", "display_name": "Eloyg", "link": "https://stackoverflow.com/users/7666477/eloyg"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 90, "favorite_count": 0, "accepted_answer_id": 42627052, "answer_count": 1, "score": 0, "last_activity_date": 1569988070, "creation_date": 1488805274, "last_edit_date": 1569988070, "question_id": 42626321, "link": "https://stackoverflow.com/questions/42626321/how-do-i-store-a-800-row-25-column-file-in-an-n-dimensional-array", "title": "How do I store a 800 row, 25 column file in an N-dimensional array?", "body": "<p>I am looking for a way to store a 800 row, 25 column file in an array. I have figured out how to store the data from a CSV in 25 different vectors, but the code looks really messy because I have to declare all the different vectors. </p>\n\n<p>I am very used to the <code>array</code> function in Python and I was wondering if there was a way to do this in Rust. I found the <a href=\"https://docs.rs/ndarray/0.12.1/ndarray/\" rel=\"nofollow noreferrer\">ndarray</a> external crate, but I can't figure out how to use it for 6+ dimensional arrays. This is what my code looks like for a 2-dimensional array, you can imagine how messy it would look with 25 different vectors, <code>f</code> declarations and <code>vector.push()</code> functions.</p>\n\n<pre><code>extern crate rand;\nextern crate csv;\n\nfn print(v: Vec&lt;f64&gt;) {\n    println!(\"New vector\");\n    for x in &amp;v {\n        println!(\"{}  \", x);\n    }\n}\n\nfn main() {\n    let mut rdr = csv::Reader::from_file(\"./data.csv\").unwrap();\n    let mut v1 = Vec::new();\n    let mut v2 = Vec::new();\n    for record in rdr.decode() {\n        let (f1, f2): (f64, f64) = record.unwrap();\n        println!(\"({}, {}, {}, {}, {}, {})\", f1, f2);\n        v1.push(f1);\n        v2.push(f2);\n\n    }\n    print(v1);\n    print(v2);\n}\n</code></pre>\n"}, {"tags": ["python", "rust", "clang", "llvm", "llvm-ir"], "comments": [{"owner": {"reputation": 394, "user_id": 1904113, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/c49a3e607adbba08dfad9127190585a9?s=128&d=identicon&r=PG", "display_name": "MKesper", "link": "https://stackoverflow.com/users/1904113/mkesper"}, "edited": false, "score": 0, "creation_date": 1488805989, "post_id": 42626107, "comment_id": 72380787, "body": "Possiby linked to: <a href=\"http://stackoverflow.com/questions/15169015/call-python-code-from-llvm-jit?rq=1\" title=\"call python code from llvm jit\">stackoverflow.com/questions/15169015/&hellip;</a>"}, {"owner": {"user_type": "does_not_exist", "display_name": "user7016017"}, "edited": false, "score": 0, "creation_date": 1488844329, "post_id": 42626107, "comment_id": 72403140, "body": "If you inspect the .ll source you should find references to externally defined functions in both Python and Rust cases. You need to link these in. The same might be true for the IR generated from C++ source, but <code>clang++</code> includes the C++ standard lib by default."}], "answers": [{"comments": [{"owner": {"reputation": 719, "user_id": 7435198, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9da8a157deffe2494a561b7de655e0bd?s=128&d=identicon&r=PG&f=1", "display_name": "Philipp", "link": "https://stackoverflow.com/users/7435198/philipp"}, "edited": false, "score": 1, "creation_date": 1489063992, "post_id": 42626498, "comment_id": 72513752, "body": "Thanks, I used <code>clang PATH&#47;TO&#47;RUSTLIB test.s -o test.native</code> and could generate and run it afterwards. Python should work like this, too. I will update when i find the solution for that as well."}, {"owner": {"reputation": 719, "user_id": 7435198, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9da8a157deffe2494a561b7de655e0bd?s=128&d=identicon&r=PG&f=1", "display_name": "Philipp", "link": "https://stackoverflow.com/users/7435198/philipp"}, "edited": false, "score": 1, "creation_date": 1492695916, "post_id": 42626498, "comment_id": 74096017, "body": "I was trying to get it to work with Python in a similar fashion, but i cant do it. As i generate the IR with numba, linking only the python lib isnt enough for clang. Linking numba though is not possible as there is no .so file for that. I could find the numba functions that clang is missing but they are only available localy. Also numba as an internal python script needs to be called in a python environment. I dont see a way to compile python IR with clang, by using numba to generate the IR. It might be possible, by generateing the IR without numba, but i dont think its possible with numba."}], "tags": [], "owner": {"reputation": 9778, "user_id": 598057, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/af77229cbfe1a0bff2b5ea064ef3271a?s=128&d=identicon&r=PG", "display_name": "Stanislav Pankevich", "link": "https://stackoverflow.com/users/598057/stanislav-pankevich"}, "is_accepted": true, "score": 6, "last_activity_date": 1488805774, "creation_date": 1488805774, "answer_id": 42626498, "question_id": 42626107, "link": "https://stackoverflow.com/questions/42626107/execute-llvm-ir-code-generated-from-rust-python-source-code/42626498#42626498", "title": "Execute LLVM IR code generated from Rust/Python source code", "body": "<p>I can speak of Rust code:</p>\n\n<p>You need to link Rust's std library something like this:</p>\n\n<pre><code>$(LLI) -load /Users/Stanislaw/.rustup/toolchains/stable-x86_64-apple-darwin/lib/libstd-f5a209a9.dylib ./target/debug/jitrust.bc\n</code></pre>\n\n<p>See the full example of Makefile I use <a href=\"https://github.com/mull-project/mull-jit-lab/blob/f1c1ddcfe3c88f3475379579683293871e2475f5/lab-jit-rust/Makefile\" rel=\"noreferrer\">here</a>.</p>\n\n<p>P.S. I would assume that the same goes about Python. You have to also supply libraries which contain this \"unreferenced\" stuff.</p>\n"}], "owner": {"reputation": 719, "user_id": 7435198, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9da8a157deffe2494a561b7de655e0bd?s=128&d=identicon&r=PG&f=1", "display_name": "Philipp", "link": "https://stackoverflow.com/users/7435198/philipp"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1609, "favorite_count": 3, "accepted_answer_id": 42626498, "answer_count": 1, "score": 8, "last_activity_date": 1503345316, "creation_date": 1488804599, "last_edit_date": 1503345316, "question_id": 42626107, "link": "https://stackoverflow.com/questions/42626107/execute-llvm-ir-code-generated-from-rust-python-source-code", "title": "Execute LLVM IR code generated from Rust/Python source code", "body": "<p>When I generate LLVM IR Code from C++, I can use the console command <code>clang++ -emit-llvm \u2013S test.cpp</code> to get a test.ll file which is the LLVM IR I want. </p>\n\n<p>To get an executable these are the steps to follow: </p>\n\n<ul>\n<li><p><code>llvm-as test.ll</code> -> gives me the test.bc file.</p></li>\n<li><p><code>llc test.bc --o test.s</code> -> gives me the test.s file.</p></li>\n<li><p><code>clang++ test.s -o test.native</code> -> gives me a native file that i can execute. </p></li>\n</ul>\n\n<p>For C++ this works just fine. </p>\n\n<p>In theory, should the same steps apply when I write Rust or Python Code?</p>\n\n<p>I take my Rust code and get the LLVM IR by typing <code>rustc test.rs --emit llvm-ir</code>. This gives me the test.ll file again. </p>\n\n<p>For Python, I use \"Numba\" and get the LLVM IR by typing <code>numba --dump-llvm test.py&gt; test.ll</code>which also gives me the test.ll file.</p>\n\n<p>The steps to generate an executable from those .ll files should be the same. </p>\n\n<p>They work up until the last step that creates the native executable:</p>\n\n<p><strong>Python Error</strong> </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>/tmp/test-9aa440.o: In function 'main':\ntest.bc:(.text+0x67): undefined reference to 'numba_gil_ensure'\ntest.bc:(.text+0x79): undefined reference to 'numba_unpickle'\ntest.bc:(.text+0x84): undefined reference to 'PyObject_Str'\ntest.bc:(.text+0x8f): undefined reference to 'PyString_AsString'\ntest.bc:(.text+0xa1): undefined reference to 'PySys_WriteStdout'\ntest.bc:(.text+0xa9): undefined reference to 'Py_DecRef'\ntest.bc:(.text+0xb1): undefined reference to 'Py_DecRef'\ntest.bc:(.text+0xbd): undefined reference to 'PySys_WriteStdout'\ntest.bc:(.text+0xc5): undefined reference to 'numba_gil_release'\ntest.bc:(.text+0xff): undefined reference to 'numba_gil_ensure'\ntest.bc:(.text+0x10b): undefined reference to 'PySys_WriteStdout'\ntest.bc:(.text+0x113): undefined reference to 'numba_gil_release'\nclang: error: linker command failed with exit code 1 (use -v to see     invocation)\n</code></pre>\n\n<p><strong>Rust Error</strong> </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>/tmp/main-5e59bd.o: In function \u2018main::sum::h514304ffa40dd7c3\u2019:\nmain.bc:(.text+0xf): undefined reference to \u2018core::panicking::panic::h2596388ccef1871c\u2019\n/tmp/main-5e59bd.o: In function \u2018main\u2019: main.bc:(.text+0x53): undefined reference to \u2018std::rt::lang_start::h65647f6e36cffdae\u2019\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre>\n\n<p>What I get from this is that clang doesn't understand the Rust/Python specific parts of the LLVM IR file (e.g. \"PyObject\" in Python or \"panic\" from Rust) that were used to generate the .bc, .s and in theory the .native files. </p>\n\n<p>But why are those even in the IR in the first place? Shouldn't the LLVM IR be uniform and those parts be transformed so the LLVM toolchain can work with them? \nAs far as I know LLVMs modularity should allow those steps by using LLVM IR. Is there maybe another way to do this i don't know about?</p>\n\n<p>Can I generate the IRs from those languages in some other way that gives \"pure\" LLVM IR that clang understands, or could I still generate executables from those files, but in some other way without clang? </p>\n"}, {"tags": ["generics", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 3, "creation_date": 1488788386, "post_id": 42620022, "comment_id": 72369667, "body": "This has to do with the notion of <a href=\"http://stackoverflow.com/search?q=%5Brust%5D+trait+object\">trait object</a> and &quot;object safety&quot; which have been discussed quite a bit... but I can&#39;t find a good duplicate which explains the issue in details."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1488788640, "post_id": 42620022, "comment_id": 72369793, "body": "The answers to <a href=\"http://stackoverflow.com/questions/34758233/working-with-trait-objects-requiring-sized\">this question</a> might be helpful."}, {"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "reply_to_user": {"reputation": 623, "user_id": 1955971, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/f1d7c2842d4d6be9c8f79e1384f284af?s=128&d=identicon&r=PG", "display_name": "Aleksander Fular", "link": "https://stackoverflow.com/users/1955971/aleksander-fular"}, "edited": false, "score": 0, "creation_date": 1488789189, "post_id": 42620022, "comment_id": 72370087, "body": "@AleksanderFular Did you try to correct the code on the playground? Because I have tried this before you have said and this did not help me unfortunately. And after your comment I have tried it again, <a href=\"https://play.rust-lang.org/?gist=4ade63728c3ad052f070c0937f0f779d&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">without any success</a>."}], "answers": [{"comments": [{"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1488789340, "post_id": 42620873, "comment_id": 72370177, "body": "Is not there a way to use lambda then? And what if I use it as <code>b.messenger.send_embed(0u64, &quot;ABRACADABRA&quot;, &amp;|s| s);</code> ? Is this okay?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1488789693, "post_id": 42620873, "comment_id": 72370364, "body": "@VictorPolevoy You can - I&#39;ve updated the answer to show how."}, {"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1488789764, "post_id": 42620873, "comment_id": 72370406, "body": "Thanks for this. The last question - should I always do that if I want to have a polymorphic object? Is this a normal practice or just a one-time fix for this specific problem?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1488789897, "post_id": 42620873, "comment_id": 72370476, "body": "If you need runtime polymorphism, then trait objects (optionally via <code>Box</code>, <code>Rc</code>, etc.) are how you do that in Rust."}, {"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1488790264, "post_id": 42620873, "comment_id": 72370689, "body": "Here is another question, what if I have <code>send_file&lt;R: std::io::Read&gt;(..)</code> method? If I try to do the same thing, I have another error: <code>the trait std::io::Read is not implemented for &amp;std::io::Read</code>"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1488790734, "post_id": 42620873, "comment_id": 72370971, "body": "@VictorPolevoy It should be analogous, so not sure without seeing the code.  Sounds like another question (if there isn&#39;t an existing question which covers it)."}, {"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1488790873, "post_id": 42620873, "comment_id": 72371064, "body": "okay, I have found a workaround for that, so, nevermind. But just letting you know, the same method did not work."}, {"owner": {"reputation": 678, "user_id": 1494700, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/9f0c7b2c2eab3cd08e72a17d997a5792?s=128&d=identicon&r=PG", "display_name": "prinsen", "link": "https://stackoverflow.com/users/1494700/prinsen"}, "edited": false, "score": 0, "creation_date": 1545696626, "post_id": 42620873, "comment_id": 94679727, "body": "Would a similar solution be possible if the Fn parameter references Self?"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 17, "last_activity_date": 1488815315, "last_edit_date": 1488815315, "creation_date": 1488789160, "answer_id": 42620873, "question_id": 42620022, "link": "https://stackoverflow.com/questions/42620022/why-does-a-generic-method-inside-a-trait-require-trait-object-to-be-sized/42620873#42620873", "title": "Why does a generic method inside a trait require trait object to be sized?", "body": "<p>Dynamic dispatch (i.e. calling methods through trait objects) works by calling through a vtable, (i.e. using a function pointer), since you don't know at compile time which function it will be.</p>\n\n<p>But if your function is generic, it needs to be compiled differently (monomorphised) for every instance of <code>F</code> which is actually used.  Which means you'll have a different copy of <code>send_embed</code> for every different closure type it's called with.  Every closure is a different type.</p>\n\n<p>These two models are incompatible: you can't have a function pointer which works with different types.</p>\n\n<p>However, you can change the method to use a trait object as well instead of being compile-time generic:</p>\n\n<pre><code>pub trait Messenger : Sync + Send {\n    fn send_embed(&amp;self, u64, &amp;str, f: &amp;Fn(String) -&gt; String)\n        -&gt; Option&lt;u64&gt; where Self: Sync + Send;\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=04e896d52887988925638fb12c463819&amp;version=stable&amp;backtrace=1\" rel=\"noreferrer\">Playground</a>)</p>\n\n<p>Instead of a different <code>send_embed</code> for every type which can be <code>Fn(String) -&gt; String</code>, it now accepts a trait object reference.  (You could also use a <code>Box&lt;Fn()&gt;</code> or similar).  You do have to use <code>Fn</code> or <code>FnMut</code> and not <code>FnOnce</code>, since the latter takes <code>self</code> by value, i.e. it's also not object safe (the caller doesn't know what size to pass in as the closure's <code>self</code> parameter).</p>\n\n<p>You can still call <code>send_embed</code> with a closure/lambda function, but it just needs to be by reference, like this:</p>\n\n<pre><code>self.messenger.send_embed(0, \"abc\", &amp;|x| x);\n</code></pre>\n\n<p>I've updated the playground to include an example of calling <code>send_embed</code> directly with a referenced closure, as well as the indirect route through a generic wrapper on <code>Bot</code>.</p>\n"}, {"comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1488790568, "post_id": 42621083, "comment_id": 72370859, "body": "I&#39;d forgotten about <code>FnBox</code>!"}], "tags": [], "owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "is_accepted": false, "score": 6, "last_activity_date": 1488789882, "last_edit_date": 1495542722, "creation_date": 1488789882, "answer_id": 42621083, "question_id": 42620022, "link": "https://stackoverflow.com/questions/42620022/why-does-a-generic-method-inside-a-trait-require-trait-object-to-be-sized/42621083#42621083", "title": "Why does a generic method inside a trait require trait object to be sized?", "body": "<p>A generic method cannot be made <a href=\"https://stackoverflow.com/questions/38318497/what-safety-guarantees-of-rust-would-be-lost-if-not-for-object-safety\">object-safe</a>, because you can't implement a vtable with it. <a href=\"https://stackoverflow.com/a/42620873/224671\">@ChrisEmerson's answer</a> explained in detail why.</p>\n\n<p>In your case, you could make <code>send_embed</code> object-trait, by making <code>f</code> take a trait-object instead of generic parameter. If your function accepts an <code>f: F where F: Fn(X) -&gt; Y</code>, you could make it accept <code>f: &amp;Fn(X) -&gt; Y</code>, similarly for FnMut <code>f: &amp;mut FnMut(X) -&gt; Y</code>. FnOnce is more tricky since Rust doesn't support moving unsized types, but you could try to Box it:</p>\n\n<pre><code>//           \u2193 no generic          \u2193~~~~~~~~~~~~~~~~~~~~~~~~~~~~ box the closure\nfn send_embed(&amp;self, u64, &amp;str, f: Box&lt;FnOnce(String) -&gt; String&gt;) -&gt; Option&lt;u64&gt; \n    where Self: Sync + Send\n{\n    f(\"hello\".to_string());\n    None\n}\n\nb.messenger.send_embed(1, \"234\", Box::new(|a| a));\n// note: does not work.\n</code></pre>\n\n<p>However, as of Rust 1.17.0 <a href=\"https://github.com/rust-lang/rust/issues/28796\" rel=\"nofollow noreferrer\">you cannot box an FnOnce and call it</a>, you have to use <a href=\"https://doc.rust-lang.org/std/boxed/trait.FnBox.html\" rel=\"nofollow noreferrer\">FnBox</a>:</p>\n\n<pre><code>#![feature(fnbox)]\nuse std::boxed::FnBox;\n\n//                                     \u2193~~~~\nfn send_embed(&amp;self, u64, &amp;str, f: Box&lt;FnBox(String) -&gt; String&gt;) -&gt; Option&lt;u64&gt; \n    where Self: Sync + Send \n{\n    f(\"hello\".to_string());\n    None\n}\n\nb.messenger.send_embed(1, \"234\", Box::new(|a| a));\n</code></pre>\n\n<p>If you don't want to use unstable feature, you could use the crate <a href=\"https://github.com/stbuehler/rust-boxfnonce\" rel=\"nofollow noreferrer\">boxfnonce</a> as a workaround:</p>\n\n<pre><code>extern crate boxfnonce;\nuse boxfnonce::BoxFnOnce;\n\nfn send_embed(&amp;self, u64, &amp;str, f: BoxFnOnce&lt;(String,), String&gt;) -&gt; Option&lt;u64&gt; \n    where Self: Sync + Send \n{\n    f.call(\"hello\".to_string());\n    None\n}\n\nb.messenger.send_embed(1, \"234\", BoxFnOnce::from(|a| a));\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1488793011, "post_id": 42621469, "comment_id": 72372489, "body": "I don&#39;t think <code>&amp;FnOnce()</code> can be called, so you still need to change to <code>Fn</code> or <code>FnMut</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1488793238, "post_id": 42621469, "comment_id": 72372665, "body": "@ChrisEmerson: Good point indeed. It would be impossible to move from a reference."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 20, "last_activity_date": 1488793309, "last_edit_date": 1488793309, "creation_date": 1488791125, "answer_id": 42621469, "question_id": 42620022, "link": "https://stackoverflow.com/questions/42620022/why-does-a-generic-method-inside-a-trait-require-trait-object-to-be-sized/42621469#42621469", "title": "Why does a generic method inside a trait require trait object to be sized?", "body": "<p><strong>Traits and Traits</strong></p>\n\n<p>In Rust, you can use <code>trait</code> to define an interface comprised of:</p>\n\n<ul>\n<li>associated types,</li>\n<li>associated constants,</li>\n<li>associated functions.</li>\n</ul>\n\n<p>and you can use traits either:</p>\n\n<ul>\n<li>as compile-time bounds for generic parameters</li>\n<li>as types, behind references or pointers.</li>\n</ul>\n\n<p>However... only <em>some</em> traits can be used directly as types. Those traits that do are labeled <em>Object Safe</em>.</p>\n\n<p>It is now considered unfortunate that a single <code>trait</code> keyword exists to define both full-featured and object-safe traits.</p>\n\n<hr>\n\n<p><strong>Interlude: How does run-time dispatch work?</strong></p>\n\n<p>When using a trait as a type: <code>&amp;Trait</code>, <code>Box&lt;Trait&gt;</code>, <code>Rc&lt;Trait&gt;</code>, ... the run-time implementation uses a fat pointer composed of:</p>\n\n<ul>\n<li>the data pointer,</li>\n<li>the virtual pointer.</li>\n</ul>\n\n<p>Method calls are dispatched through the virtual pointer to a virtual table.</p>\n\n<p>For a trait like:</p>\n\n<pre><code>trait A {\n    fn one(&amp;self) -&gt; usize;\n    fn two(&amp;self, other: usize) -&gt; usize;\n}\n</code></pre>\n\n<p>implemented for type <code>X</code>, the virtual table will look like <code>(&lt;X as A&gt;::one, &lt;X as A&gt;::two)</code>.</p>\n\n<p>The run-time dispatch is thus performed by:</p>\n\n<ul>\n<li>picking the right member of the table,</li>\n<li>calling it with the data pointer and arguments.</li>\n</ul>\n\n<p>This means that <code>&lt;X as A&gt;::two</code> looks like:</p>\n\n<pre><code>fn x_as_a_two(this: *const (), other: usize) -&gt; usize {\n    let x = unsafe { this as *const X as &amp;X };\n    x.two(other)\n}\n</code></pre>\n\n<hr>\n\n<p><strong>Why cannot I use any trait as a type? What's Object Safe?</strong></p>\n\n<p>It's a technical limitation.</p>\n\n<p>There are a number of traits capabilities that cannot be implemented for run-time dispatches:</p>\n\n<ul>\n<li>associated types,</li>\n<li>associated constants,</li>\n<li>associated generic functions,</li>\n<li>associated functions with <code>Self</code> in the signature.</li>\n<li><em>... maybe others ...</em>.</li>\n</ul>\n\n<p>There are two ways to signal this issue:</p>\n\n<ul>\n<li>early: refuse to use a <code>trait</code> as a type if it has any of the above,</li>\n<li>late: refuse to use any of the above on a <code>trait</code> as a type.</li>\n</ul>\n\n<p>For now, Rust chooses to signal the issue early on: traits that do not use any of the above features are call <em>Object Safe</em> and can be used as types.</p>\n\n<p>Traits that are not <em>Object Safe</em> cannot be used as types, and an error is immediately triggered.</p>\n\n<hr>\n\n<p><strong>Now what?</strong></p>\n\n<p>In your case, simply switch from compile-time polymorphism to run-time polymorphism for the method:</p>\n\n<pre><code>pub trait Messenger : Sync + Send {\n    fn send_embed(&amp;self, u64, &amp;str, f: &amp;FnOnce(String) -&gt; String)\n        -&gt; Option&lt;u64&gt;;\n}\n</code></pre>\n\n<p>There is a little wrinkle: <code>FnOnce</code> requires moving out of the <code>f</code> and it's only borrowed here, so instead you need to use <code>FnMut</code> or <code>Fn</code>. <code>FnMut</code> is next more generic method, so:</p>\n\n<pre><code>pub trait Messenger : Sync + Send {\n    fn send_embed(&amp;self, u64, &amp;str, f: &amp;FnMut(String) -&gt; String)\n        -&gt; Option&lt;u64&gt;;\n}\n</code></pre>\n\n<p>This makes the <code>Messenger</code> trait Object Safe and therefore allows you to use a <code>&amp;Messenger</code>, <code>Box&lt;Messenger&gt;</code>, ...</p>\n"}], "owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 7626, "favorite_count": 5, "accepted_answer_id": 42620873, "answer_count": 3, "score": 13, "last_activity_date": 1488815412, "creation_date": 1488785934, "last_edit_date": 1488815412, "question_id": 42620022, "link": "https://stackoverflow.com/questions/42620022/why-does-a-generic-method-inside-a-trait-require-trait-object-to-be-sized", "title": "Why does a generic method inside a trait require trait object to be sized?", "body": "<p>I have this code (<a href=\"https://play.rust-lang.org/?gist=44d0f4ac393f7244d29780e43b702fb1&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">playground</a>):</p>\n\n<pre><code>use std::sync::Arc;\n\npub trait Messenger : Sync + Send {\n    fn send_embed&lt;F: FnOnce(String) -&gt; String&gt;(&amp;self, u64, &amp;str, f: F)\n        -&gt; Option&lt;u64&gt; where Self: Sync + Send;\n}\n\nstruct MyMessenger {\n    prefix: String,\n}\nimpl MyMessenger {\n    fn new(s: &amp;str) -&gt; MyMessenger {\n        MyMessenger { prefix: s.to_owned(), }\n    }\n}\nimpl Messenger for MyMessenger {\n    fn send_embed&lt;F: FnOnce(String) -&gt; String&gt;(&amp;self, channel_id: u64, text: &amp;str, f: F) -&gt; Option&lt;u64&gt; {\n        println!(\"Trying to send embed: chid={}, text=\\\"{}\\\"\", channel_id, text);\n        None\n    }\n\n}\n\nstruct Bot {\n    messenger: Arc&lt;Messenger&gt;,\n}\nimpl Bot {\n    fn new() -&gt; Bot {\n        Bot {\n            messenger: Arc::new(MyMessenger::new(\"HELLO\")),\n        }\n    }\n}\n\nfn main() {\n    let b = Bot::new();\n}\n</code></pre>\n\n<p>I wanted to make a polymorphic object (trait <code>Messenger</code> and one of polymorphic implementations is <code>MyMessenger</code>). But when I try to compile it I have an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0038]: the trait `Messenger` cannot be made into an object\n  --&gt; &lt;anon&gt;:25:5\n   |\n25 |     messenger: Arc&lt;Messenger&gt;,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Messenger` cannot be made into an object\n   |\n   = note: method `send_embed` has generic type parameters\n</code></pre>\n\n<p>I have found that I must require <code>Sized</code> in this case, but this does not solve it. If I change my <code>send_embed</code> method to the following:</p>\n\n<pre><code>fn send_embed&lt;F: FnOnce(String) -&gt; String&gt;(&amp;self, u64, &amp;str, f: F)\n    -&gt; Option&lt;u64&gt; where Self: Sized + Sync + Send;\n</code></pre>\n\n<p>Then it compiles successfully but:</p>\n\n<ol>\n<li>Why do we need <code>Sized</code> here? This violates polymorphism if we can not use this method from a trait object.</li>\n<li><p>We actually can't use this method from <code>Arc&lt;Messenger&gt;</code> then:</p>\n\n<pre><code>fn main() {\n    let b = Bot::new();\n    b.messenger.send_embed(0u64, \"ABRACADABRA\", |s| s);\n}\n</code></pre>\n\n<p>Gives:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `Messenger + 'static: std::marker::Sized` is not satisfied\n  --&gt; &lt;anon&gt;:37:17\n   |\n37 |     b.messenger.send_embed(0u64, \"ABRACADABRA\", |s| s);\n   |                 ^^^^^^^^^^ the trait `std::marker::Sized` is not implemented for `Messenger + 'static`\n   |\n   = note: `Messenger + 'static` does not have a constant size known at compile-time\n</code></pre></li>\n</ol>\n\n<p>I am totally stuck here. No idea how to use polymorphism with generic method in a trait. Is there a way?</p>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 3416, "user_id": 2484972, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/ea1c4b2c5aa3c7da2f2740bc1a643ee0?s=128&d=identicon&r=PG", "display_name": "Tatsuyuki Ishi", "link": "https://stackoverflow.com/users/2484972/tatsuyuki-ishi"}, "is_accepted": false, "score": 2, "last_activity_date": 1488783906, "creation_date": 1488783906, "answer_id": 42619456, "question_id": 42618450, "link": "https://stackoverflow.com/questions/42618450/how-to-appease-the-borrow-checker-when-returning-reference-to-filtered-vector-of/42619456#42619456", "title": "How to appease the borrow checker when returning reference to filtered vector of external references", "body": "<p>You're returning <code>&amp;mut &amp;mut Vertex</code>.</p>\n\n<p>If you're discarding the rest of elements, you can do lazy computation:\n<code>\nself.verts.iter_mut().filter(|x| x.id == id).next()\n</code></p>\n"}, {"tags": [], "owner": {"reputation": 329, "user_id": 2395870, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/652437711761fc77465e03be05600bbd?s=128&d=identicon&r=PG&f=1", "display_name": "thelostlambda", "link": "https://stackoverflow.com/users/2395870/thelostlambda"}, "is_accepted": false, "score": 0, "last_activity_date": 1488808713, "last_edit_date": 1488808713, "creation_date": 1488785789, "answer_id": 42619971, "question_id": 42618450, "link": "https://stackoverflow.com/questions/42618450/how-to-appease-the-borrow-checker-when-returning-reference-to-filtered-vector-of/42619971#42619971", "title": "How to appease the borrow checker when returning reference to filtered vector of external references", "body": "<p>I suspected something like <code>&amp;mut &amp;mut Vertex</code>. Unfortunately, without the <code>&amp;mut</code> preceding the <code>vs</code> there were several other compiler errors. As is turns out, Rust returns references when indexing, something I didn't know. I had to check the <code>std::vec</code> module and I found that <code>remove()</code> returns the value directly. This code works:</p>\n\n<pre><code>pub fn lookup_id(&amp;mut self, id: &amp;str) -&gt; Option&lt;&amp;mut Vertex&gt; {\n    let mut vs:Vec&lt;&amp;mut Vertex&gt; = self.verts.iter_mut().filter(|x| x.id == id).collect();\n    if vs.len() &gt; 0 { Some(vs.remove(0)) } else { None }\n}\n</code></pre>\n\n<p>This version, however, is much cleaner:</p>\n\n<pre><code>pub fn lookup_id(&amp;self, id: &amp;str) -&gt; Option&lt;&amp;Vertex&gt; {\n    self.verts.iter().find(|x| x.id == id)\n}\n</code></pre>\n"}], "owner": {"reputation": 329, "user_id": 2395870, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/652437711761fc77465e03be05600bbd?s=128&d=identicon&r=PG&f=1", "display_name": "thelostlambda", "link": "https://stackoverflow.com/users/2395870/thelostlambda"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 383, "favorite_count": 0, "answer_count": 2, "score": 2, "last_activity_date": 1488808793, "creation_date": 1488779568, "last_edit_date": 1488808793, "question_id": 42618450, "link": "https://stackoverflow.com/questions/42618450/how-to-appease-the-borrow-checker-when-returning-reference-to-filtered-vector-of", "title": "How to appease the borrow checker when returning reference to filtered vector of external references", "body": "<p>I am trying to implement a lookup function that will return a mutable reference to a value contained within the <code>self</code> value. Normally, since the returned reference points to data that is owned outside of the <code>lookup</code> function (<code>self.verts</code>), the borrow checker sees no problem with that. In my case, however, I am filtering <code>self.verts</code> prior to returning the reference and binding it to a new, owned name. When I try to return a value from that locally owned array I get the compile time error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `vs` does not live long enough\n  --&gt; src/util/graph.rs:18:37\n   |\n18 |         if vs.len() &gt; 0 { Some(&amp;mut vs[0]) } else { None }\n   |                                     ^^ does not live long enough\n19 |     }\n   |     - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the lifetime 'a as defined on the body at 16:75...\n  --&gt; src/util/graph.rs:16:76\n   |\n16 |       pub fn lookup_id&lt;'a&gt;(&amp;'a mut self, id: &amp;str) -&gt; Option&lt;&amp;'a mut Vertex&gt; {\n   |  ____________________________________________________________________________^ starting here...\n17 | |         let vs:Vec&lt;&amp;mut Vertex&gt; = self.verts.iter_mut().filter(|x| x.id == id).collect();\n18 | |         if vs.len() &gt; 0 { Some(&amp;mut vs[0]) } else { None }\n19 | |     }\n   | |_____^ ...ending here\n</code></pre>\n\n<p>I understand that I can't return a reference to locally owned content, and I suspect that is how the compiler is interpreting my code, but that is not what I want to do. What a want to do is return a reference to a value in the <code>self.verts</code> vector so that the returned reference has the same lifetime and the struct the lookup is being performed on. Here is my current attempt:</p>\n\n<pre><code>pub fn lookup_id&lt;'a&gt;(&amp;'a mut self, id: &amp;str) -&gt; Option&lt;&amp;'a mut Vertex&gt; {\n    let vs:Vec&lt;&amp;'a mut Vertex&gt; = self.verts.iter_mut().filter(|x| x.id == id).collect();\n    if vs.len() &gt; 0 { Some(&amp;mut vs[0]) } else { None }\n}\n</code></pre>\n\n<p>This code does not compile because <code>vs does not live long enough</code>. How do I tell the compiler that a want to return a reference contained in <code>vs</code> and not a reference to <code>vs</code>?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 1, "last_activity_date": 1488754210, "creation_date": 1488754210, "answer_id": 42615021, "question_id": 42614589, "link": "https://stackoverflow.com/questions/42614589/create-variant-without-parameter-from-an-empty-tuple/42615021#42615021", "title": "Create variant without parameter from an empty tuple", "body": "<p>What about implementing <code>Fn</code> for <code>Variants</code>? (Note: <code>Fn</code> requires <code>FnMut</code> and <code>FnMut</code> requires <code>FnOnce</code>, so we have to implement all three.)</p>\n\n<pre><code>#![feature(fn_traits)]\n#![feature(unboxed_closures)]\n\nuse self::Variants::*;\n\n#[derive(Clone, Debug)]\nenum Variants {\n    Unit,\n    One(u8),\n}\n\nimpl FnOnce&lt;((),)&gt; for Variants {\n    type Output = Variants;\n\n    extern \"rust-call\" fn call_once(self, args: ((),)) -&gt; Self::Output {\n        self.call(args)\n    }\n}\n\nimpl FnMut&lt;((),)&gt; for Variants {\n    extern \"rust-call\" fn call_mut(&amp;mut self, args: ((),)) -&gt; Self::Output {\n        self.call(args)\n    }\n}\n\nimpl Fn&lt;((),)&gt; for Variants {\n    extern \"rust-call\" fn call(&amp;self, _: ((),)) -&gt; Self::Output {\n        self.clone()\n    }\n}\n\nfn emit&lt;C: Fn(S) -&gt; T, S, T&gt;(callback: &amp;C, value: S) -&gt; T {\n    callback(value)\n}\n\nfn main() {\n    let unit: Variants = emit(&amp;Unit, ());\n    println!(\"{:?}\", unit); // Prints Unit.\n    let one: Variants = emit(&amp;One, 10);\n    println!(\"{:?}\", one); // Prints One(10).\n}\n</code></pre>\n\n<p>The only weird aspect of this solution is that you could now pass values such as <code>&amp;One(10)</code> as the first argument to <code>emit</code> (though the second argument could only be <code>()</code>).</p>\n"}], "owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 241, "favorite_count": 0, "accepted_answer_id": 42615021, "answer_count": 1, "score": 3, "last_activity_date": 1488754210, "creation_date": 1488751205, "last_edit_date": 1488752103, "question_id": 42614589, "link": "https://stackoverflow.com/questions/42614589/create-variant-without-parameter-from-an-empty-tuple", "title": "Create variant without parameter from an empty tuple", "body": "<p>I want to be able to construct enum values by giving the variant constructor a value:</p>\n\n<pre><code>use self::Variants::*;\n\n#[derive(Clone, Debug)]\nenum Variants {\n    Unit(()),\n    One(u8),\n}\n\nfn emit&lt;C: Fn(S) -&gt; T, S, T&gt;(constructor: C, value: S) -&gt; T {\n    constructor(value)\n}\n\nfn main() {\n    let unit: Variants = emit(&amp;Unit, ());\n    println!(\"{:?}\", unit); // Prints Unit(()).\n    let one: Variants = emit(&amp;One, 10);\n    println!(\"{:?}\", one); // Prints One(10).\n}\n</code></pre>\n\n<p>The issue with this example is that I need <code>()</code> in <code>Unit(())</code> instead of the more normal <code>Unit</code> (without parameter).</p>\n\n<p>I tried using specialization:</p>\n\n<pre><code>#![feature(specialization)]\n\ntrait Constructor&lt;S, T&gt; {\n    fn construct(self, value: S) -&gt; T;\n}\n\nimpl&lt;T&gt; Constructor&lt;(), T&gt; for T {\n    fn construct(self, _value: ()) -&gt; T {\n        self\n    }\n}\n\nimpl&lt;F: Fn(S) -&gt; T, S, T&gt; Constructor&lt;S, T&gt; for F {\n    default fn construct(self, value: S) -&gt; T {\n        self(value)\n    }\n}\n\nfn emit&lt;C: Constructor&lt;I, R&gt;, I, R&gt;(callback: &amp;C, value: I) -&gt; R {\n    callback.construct(value)\n}\n\nuse self::Variants::*;\n\n#[derive(Clone, Debug)]\nenum Variants {\n    Unit,\n    One(u8),\n}\n\nfn main() {\n    let unit: Variants = emit(&amp;Unit, ());\n    println!(\"{:?}\", unit); // Should prints Unit.\n    let one: Variants = emit(&amp;One, 10);\n    println!(\"{:?}\", one); // Prints One(10).\n}\n</code></pre>\n\n<p>but this fails at compile time with:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>conflicting implementations of trait `Constructor&lt;(), _&gt;`:\n</code></pre>\n\n<p>From my understanding of the <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md\" rel=\"nofollow noreferrer\">RFC</a>, this fails because no one of these <code>impl</code>s is a subset of the other. I think it is because the <code>T</code> in <code>for T</code> of the first <code>impl</code> is more generic than the <code>F</code> of the <code>for F</code> of the second implementation. Hence, it cannot be the specialization.</p>\n\n<p>On the other hand, it cannot be the general (<code>default</code>) implementation because <code>Constructor&lt;(), T&gt; for T</code> (and even <code>Constructor&lt;S, T&gt; for T</code>) is more specific than <code>Constructor&lt;S, T&gt; for F</code> because <code>T</code> is written twice in the former.</p>\n\n<p>This is my understanding from reading the RFC. Please tell me if I'm wrong.</p>\n\n<p>How could I make the first example work without having to give a useless parameter to <code>Unit</code>?</p>\n\n<p>I am open to solutions that require the nightly compiler.</p>\n"}, {"tags": ["generics", "rust", "traits", "type-parameter"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 12, "last_activity_date": 1557572142, "last_edit_date": 1557572142, "creation_date": 1488751746, "answer_id": 42614667, "question_id": 42613974, "link": "https://stackoverflow.com/questions/42613974/why-cant-i-add-a-blanket-impl-on-a-trait-with-a-type-parameter/42614667#42614667", "title": "Why can&#39;t I add a blanket impl on a trait with a type parameter?", "body": "<p>The problem is that a single type could implement <code>Bar&lt;P&gt;</code> for multiple values of <code>P</code>. If you had a struct <code>Baz</code> that implemented <code>Bar&lt;i32&gt;</code> and <code>Bar&lt;String&gt;</code>, which type should <code>Foo::new</code> use for <code>P</code>?</p>\n\n<p>The only solution is to ensure that a single type cannot implement <code>Bar</code> more than once (if that's not what you want, then you have a flaw in your design!). To do so, we must replace the <code>P</code> type parameter with an associated type.</p>\n\n<pre><code>pub trait Bar: Foo {\n    type Parameter;\n\n    fn with_parameter(arg: u32, parameter: Self::Parameter) -&gt; Self;\n}\n\nimpl&lt;T&gt; Foo for T\nwhere\n    T: Bar,\n    T::Parameter: Default,\n{\n    fn new(arg: u32) -&gt; Self {\n        Self::with_parameter(arg, T::Parameter::default())\n    }\n}\n</code></pre>\n\n<p>An implementation of <code>Bar</code> would look like this:</p>\n\n<pre><code>struct Baz;\n\nimpl Bar for Baz {\n    type Parameter = i32;\n\n    fn with_parameter(arg: u32, parameter: Self::Parameter) -&gt; Self {\n        unimplemented!()\n    }\n}\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/37377490/155423\">Why do I get &quot;the type parameter is not constrained&quot; when creating a blanket implementation for a closure trait (Fn)?</a></li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 975, "user_id": 7687388, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Xhm3T.png?s=128&g=1", "display_name": "CodeSandwich", "link": "https://stackoverflow.com/users/7687388/codesandwich"}, "is_accepted": false, "score": 4, "last_activity_date": 1557572216, "last_edit_date": 1557572216, "creation_date": 1550944118, "answer_id": 54844358, "question_id": 42613974, "link": "https://stackoverflow.com/questions/42613974/why-cant-i-add-a-blanket-impl-on-a-trait-with-a-type-parameter/54844358#54844358", "title": "Why can&#39;t I add a blanket impl on a trait with a type parameter?", "body": "<p>I've broken down and extended <a href=\"https://stackoverflow.com/a/42614667/155423\">Francis's explanation</a> of why the code does not compile. I may not be the smartest kid on the block, but it took me way too long to understand his concise reasoning.</p>\n\n<p>Let's create <code>Baz</code>, which implements <code>Bar</code> in 2 variants: <code>i32</code> and <code>String</code>:</p>\n\n<pre><code>struct Baz;\n\nimpl Bar&lt;i32&gt; for Baz { /* ... */ }\n\nimpl Bar&lt;String&gt; for Baz { /* ... */ }\n</code></pre>\n\n<p>Type dependency graph after blanket impl takes effect:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>           -&gt; trait Bar&lt;i32&gt;    -&gt; trait Foo (with i32 baked-in)\nstruct Baz\n           -&gt; trait Bar&lt;String&gt; -&gt; trait Foo (with String baked-in)\n</code></pre>\n\n<p>We end up with 2 different implementations of <code>Foo</code>: with baked-in <code>i32</code> and with baked-in <code>String</code>.\nWhen we write <code>&lt;Baz as Foo&gt;::new()</code>, compiler can't tell which version of <code>Foo</code> we mean; they are indistinguishable.</p>\n\n<p>The rule of a thumb is that trait A can have blanket implementation for trait B only if trait A is generic over all generic parameters of trait B.</p>\n"}], "owner": {"reputation": 2286, "user_id": 1981468, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/HnKNp.jpg?s=128&g=1", "display_name": "Others", "link": "https://stackoverflow.com/users/1981468/others"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1283, "favorite_count": 0, "accepted_answer_id": 42614667, "answer_count": 2, "score": 8, "last_activity_date": 1557572216, "creation_date": 1488747798, "last_edit_date": 1557572080, "question_id": 42613974, "link": "https://stackoverflow.com/questions/42613974/why-cant-i-add-a-blanket-impl-on-a-trait-with-a-type-parameter", "title": "Why can&#39;t I add a blanket impl on a trait with a type parameter?", "body": "<p>Consider these two traits:</p>\n\n<pre><code>pub trait Foo {\n    fn new(arg: u32) -&gt; Self;\n}\n\npub trait Bar&lt;P&gt;: Foo {\n    fn with_parameter(arg: u32, parameter: P) -&gt; Self;\n}\n</code></pre>\n\n<p>I'd like to add the blanket impl:</p>\n\n<pre><code>impl&lt;T: Bar&lt;P&gt;, P: Default&gt; Foo for T {\n    fn new(arg: u32) -&gt; Self {\n        Self::with_parameter(arg, P::default())\n    }\n}\n</code></pre>\n\n<p>But I get the compiler error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0207]: the type parameter `P` is not constrained by the impl trait, self type, or predicates\n --&gt; src/lib.rs:9:17\n  |\n9 | impl&lt;T: Bar&lt;P&gt;, P: Default&gt; Foo for T {\n  |                 ^ unconstrained type parameter\n</code></pre>\n\n<p>I think I get this error because I'm violating trait coherence rules, but I don't understand exactly what rule this would break. Why is this pattern not allowed? And, more importantly, can I achieve what I want without getting an error?</p>\n"}, {"tags": ["rust", "ffi", "lifetime"], "comments": [{"owner": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "edited": false, "score": 0, "creation_date": 1488748712, "post_id": 42613798, "comment_id": 72357184, "body": "I asked on IRC and it seems that the answer is: yes it is possible, but it&#39;s going to get better <a href=\"https://github.com/rust-lang/rfcs/pull/1861\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/pull/1861</a>"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1546455066, "last_edit_date": 1546455066, "creation_date": 1488750162, "answer_id": 42614430, "question_id": 42613798, "link": "https://stackoverflow.com/questions/42613798/how-do-i-handle-an-ffi-unsized-type-that-could-be-owned-or-borrowed/42614430#42614430", "title": "How do I handle an FFI unsized type that could be owned or borrowed?", "body": "<p>This appears to work, but it does require using a small <code>unsafe</code> block, so you should test under the normal tools like Miri and Valgrind. The primary assumption made here<sup>1</sup> is that <code>c_void</code> cannot be constructed normally. <a href=\"https://doc.rust-lang.org/reference/type-layout.html#the-transparent-representation\" rel=\"nofollow noreferrer\"><code>#[repr(transparent)]</code></a> is used to ensure that the <code>FooBorrowed</code> newtype has the same memory layout as a <code>c_void</code>. Everything should end up as \"just a pointer\":</p>\n\n<pre><code>use std::{ffi::c_void, mem, ops::Deref};\n\n#[repr(transparent)]\nstruct FooBorrowed(c_void);\nstruct FooOwned(*mut c_void);\n\nfn fake_foo_new(v: u8) -&gt; *mut c_void {\n    println!(\"C new called\");\n    Box::into_raw(Box::new(v)) as *mut c_void\n}\n\nfn fake_foo_free(p: *mut c_void) {\n    println!(\"C free called\");\n    let p = p as *mut u8;\n    if !p.is_null() {\n        unsafe { Box::from_raw(p) };\n    }\n}\n\nfn fake_foo_value(p: *const c_void) -&gt; u8 {\n    println!(\"C value called\");\n    let p = p as *const u8;\n    unsafe {\n        p.as_ref().map_or(255, |p| *p)\n    }\n}\n\nimpl FooBorrowed {\n    fn value(&amp;self) -&gt; u8 {\n        fake_foo_value(&amp;self.0)\n    }\n}\n\nimpl FooOwned {\n    fn new(v: u8) -&gt; FooOwned {\n        FooOwned(fake_foo_new(v))\n    }\n}\n\nimpl Deref for FooOwned {\n    type Target = FooBorrowed;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        unsafe { mem::transmute(self.0) }\n    }\n}\n\nimpl Drop for FooOwned {\n    fn drop(&amp;mut self) {\n        fake_foo_free(self.0)\n    }\n}\n\nfn use_it(foo: &amp;FooBorrowed) {\n    println!(\"{}\", foo.value())\n}\n\nfn main() {\n    let f = FooOwned::new(42);\n    use_it(&amp;f);\n}\n</code></pre>\n\n<p>If the C library actually hands you a pointer, you would need to do some more <code>unsafe</code>:</p>\n\n<pre><code>fn fake_foo_borrowed() -&gt; *const c_void {\n    println!(\"C borrow called\");\n    static VALUE_OWNED_ELSEWHERE: u8 = 99;\n    &amp;VALUE_OWNED_ELSEWHERE as *const u8 as *const c_void\n}\n\nimpl FooBorrowed {\n    unsafe fn new&lt;'a&gt;(p: *const c_void) -&gt; &amp;'a FooBorrowed {\n        mem::transmute(p)\n    }\n}\n\nfn main() {\n    let f2 = unsafe { FooBorrowed::new(fake_foo_borrowed()) };\n    use_it(f2);\n}\n</code></pre>\n\n<p>As you identified, <code>FooBorrowed::new</code> returns a reference with an unrestricted lifetime; this is pretty dangerous. In many cases, you can construct a smaller scope and use something that provides a lifetime:</p>\n\n<pre><code>impl FooBorrowed {\n    unsafe fn new&lt;'a&gt;(p: &amp;'a *const c_void) -&gt; &amp;'a FooBorrowed {\n        mem::transmute(*p)\n    }\n}\n\nfn main() {\n    let p = fake_foo_borrowed();\n    let f2 = unsafe { FooBorrowed::new(&amp;p) };\n    use_it(f2);\n}\n</code></pre>\n\n<p>This prevents you from using the reference beyond when the pointer variable is valid, which is <em>not</em> guaranteed to be the true lifetime, but is \"close enough\" in many cases. It's more important to be too short and not too long!</p>\n\n<hr>\n\n<p><strong>1</strong> \u2014 In future versions of Rust, you should use extern types to create a guaranteed opaque type:</p>\n\n<pre><code>extern \"C\" {\n    type my_opaque_t;\n}\n</code></pre>\n"}], "owner": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 232, "favorite_count": 0, "accepted_answer_id": 42614430, "answer_count": 1, "score": 4, "last_activity_date": 1546455066, "creation_date": 1488746944, "last_edit_date": 1488749374, "question_id": 42613798, "link": "https://stackoverflow.com/questions/42613798/how-do-i-handle-an-ffi-unsized-type-that-could-be-owned-or-borrowed", "title": "How do I handle an FFI unsized type that could be owned or borrowed?", "body": "<p><code>c_strange_t</code> is an opaque C type that is only seen behind a pointer. When wrapping this type, there are times when it is our responsibility to free memory using <code>c_free_strange_t(*c_strange_t)</code>, and other times when we are not responsible for freeing the data, we are only responsible for accurately controlling the lifetime.</p>\n\n<p>It would be ergonomic if this type could be mapped into 2 types in Rust that work in a similar way to <code>str</code> and <code>String</code>, where there is <code>impl Deref&lt;Target=str&gt; for String</code>. The borrowed type would need to be marked as only valid behind a reference.</p>\n\n<p>Is this possible, and how would it be done?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 36166, "user_id": 393701, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/250889c646cd2a916920d9252f7c6f42?s=128&d=identicon&r=PG", "display_name": "SirDarius", "link": "https://stackoverflow.com/users/393701/sirdarius"}, "edited": false, "score": 1, "creation_date": 1488730907, "post_id": 42610685, "comment_id": 72350748, "body": "Why is the <code>parse</code> function part of the InputParser implementation? It doesn&#39;t return an InputParser nor takes a self reference."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488731462, "post_id": 42610685, "comment_id": 72350932, "body": "Why are you taking <code>self</code> by value (<code>fn end(mut self)</code>) everywhere?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488732579, "post_id": 42610685, "comment_id": 72351308, "body": "<code>self.consumed_quote = self.consumed_quote;</code> is a <i>very</i> dubious line."}, {"owner": {"reputation": 563, "user_id": 3366443, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/68857b02d2a34389d07fba497e41e7ba?s=128&d=identicon&r=PG&f=1", "display_name": "rykeeboy", "link": "https://stackoverflow.com/users/3366443/rykeeboy"}, "edited": false, "score": 0, "creation_date": 1488733875, "post_id": 42610685, "comment_id": 72351809, "body": "Thanks for saving me some confusion, should be <code>self.consumed_quote = !self.consumed_quote;</code>"}], "answers": [{"comments": [{"owner": {"reputation": 36166, "user_id": 393701, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/250889c646cd2a916920d9252f7c6f42?s=128&d=identicon&r=PG", "display_name": "SirDarius", "link": "https://stackoverflow.com/users/393701/sirdarius"}, "edited": false, "score": 0, "creation_date": 1488732001, "post_id": 42611005, "comment_id": 72351103, "body": "Wouldn&#39;t <code>current</code> better be implemented as an <code>Option&lt;String&gt;</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 36166, "user_id": 393701, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/250889c646cd2a916920d9252f7c6f42?s=128&d=identicon&r=PG", "display_name": "SirDarius", "link": "https://stackoverflow.com/users/393701/sirdarius"}, "edited": false, "score": 0, "creation_date": 1488732424, "post_id": 42611005, "comment_id": 72351257, "body": "@SirDarius that would work, but I think it comes down to the semantics you wish to have. If it&#39;s important to distinguish between an empty string and a missing string, then sure, but there will be annoyances everywhere it&#39;s used. However, if you are thinking about using <code>Option</code> for <code>Option::take</code>, note that it is implemented with <code>mem::replace</code>! An empty <code>String</code> is pretty lightweight as well, just a few pointer-sized integers, no heap allocation. There&#39;s nothing really scary about <code>mem::replace</code>."}, {"owner": {"reputation": 36166, "user_id": 393701, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/250889c646cd2a916920d9252f7c6f42?s=128&d=identicon&r=PG", "display_name": "SirDarius", "link": "https://stackoverflow.com/users/393701/sirdarius"}, "edited": false, "score": 0, "creation_date": 1488735614, "post_id": 42611005, "comment_id": 72352442, "body": "That makes sense here indeed."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1488733112, "last_edit_date": 1488733112, "creation_date": 1488731883, "answer_id": 42611005, "question_id": 42610685, "link": "https://stackoverflow.com/questions/42610685/move-non-copyable-struct-across-iterations/42611005#42611005", "title": "Move non-copyable struct across iterations", "body": "<blockquote>\n  <p>[How do I] move [a] non-copyable struct across iterations</p>\n</blockquote>\n\n<p>You <strong>don't</strong>, at least not trivially. Once you've moved the struct to a function, it's <em>gone</em>. The only way to get it back is for the function to give it back to you.</p>\n\n<p>Instead, you most likely want to modify an existing struct inside the loop. You need to use a mutable reference for this:</p>\n\n<pre><code>use std::mem;\n\n#[derive(Clone)]\nstruct InputParser {\n    args: Vec&lt;String&gt;,\n    current: String,\n    consumed_quote: bool,\n}\n\nimpl InputParser {\n    fn consume_space(&amp;mut self) {\n        if !self.consumed_quote {\n            self.push_current();\n        }\n    }\n\n    fn consume_quote(&amp;mut self) {\n        self.consumed_quote = self.consumed_quote;\n        if self.consumed_quote {\n            self.push_current();\n        }\n    }\n\n    fn consume_char(&amp;mut self, c: char) {\n        self.current.push(c);\n    }\n\n    fn end(&amp;mut self) {\n        self.push_current();\n    }\n\n    fn push_current(&amp;mut self) {\n        if self.current.len() &gt; 0 {\n            let arg = mem::replace(&amp;mut self.current, String::new());\n            self.args.push(arg);\n        }\n    }\n}\n\nfn parse(input: String) -&gt; Vec&lt;String&gt; {\n    let mut parser = InputParser {\n        args: Vec::new(),\n        current: String::new(),\n        consumed_quote: false,\n    };\n    for c in input.chars() {\n        match c {\n            '\"' =&gt; parser.consume_quote(),\n            ' ' =&gt; parser.consume_space(),\n            _ =&gt; parser.consume_char(c),\n        }\n    }\n    parser.end();\n\n    parser.args\n}\n\nfn main() {}\n</code></pre>\n\n<p>Note that the previous way of taking the current argument would result in <code>error[E0507]: cannot move out of borrowed content</code>, so I switched to <code>mem::replace</code>. This prevents <code>self.current</code> from ever becoming an undefined value (which it was previously).</p>\n\n<hr>\n\n<p>If you really want to pass everything by value, you need to return by value as well.</p>\n\n<pre><code>#[derive(Clone)]\nstruct InputParser {\n    args: Vec&lt;String&gt;,\n    current: String,\n    consumed_quote: bool,\n}\n\nimpl InputParser {\n    fn consume_space(mut self) -&gt; Self {\n        if !self.consumed_quote {\n            return self.push_current();\n        }\n        self\n    }\n\n    fn consume_quote(mut self) -&gt; Self {\n        self.consumed_quote = self.consumed_quote;\n        if self.consumed_quote {\n            return self.push_current();\n        }\n        self\n    }\n\n    fn consume_char(mut self, c: char) -&gt; Self {\n        self.current.push(c);\n        self\n    }\n\n    fn end(mut self) -&gt; Self {\n        self.push_current()\n    }\n\n    fn push_current(mut self) -&gt; Self {\n        if self.current.len() &gt; 0 {\n            self.args.push(self.current);\n            self.current = String::new();\n        }\n        self\n    }\n}\n\nfn parse(input: String) -&gt; Vec&lt;String&gt; {\n    let mut parser = InputParser {\n        args: Vec::new(),\n        current: String::new(),\n        consumed_quote: false,\n    };\n    for c in input.chars() {\n        parser = match c {\n            '\"' =&gt; parser.consume_quote(),\n            ' ' =&gt; parser.consume_space(),\n            _ =&gt; parser.consume_char(c),\n        }\n    }\n    parser = parser.end();\n\n    parser.args\n}\n\nfn main() {}\n</code></pre>\n\n<p>I believe this makes the API objectively worse in this case. However, you will see this style somewhat frequently with a <em>builder</em>. In that case, the methods tend to be chained together, so you never see a reassignment to the variable.</p>\n"}], "owner": {"reputation": 563, "user_id": 3366443, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/68857b02d2a34389d07fba497e41e7ba?s=128&d=identicon&r=PG&f=1", "display_name": "rykeeboy", "link": "https://stackoverflow.com/users/3366443/rykeeboy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 78, "favorite_count": 0, "accepted_answer_id": 42611005, "answer_count": 1, "score": 0, "last_activity_date": 1488733112, "creation_date": 1488730217, "last_edit_date": 1488731488, "question_id": 42610685, "link": "https://stackoverflow.com/questions/42610685/move-non-copyable-struct-across-iterations", "title": "Move non-copyable struct across iterations", "body": "<p>I am trying to access a variable inside a <code>for</code> loop. I can't implement <code>Copy</code> on the struct because it contains a <code>String</code>. How would I use the variable across iterations?</p>\n\n<p>I get error E0382 when compiling. When I looked at the Rust documentation for the error, they mentioned using reference counting to solve the problem. Is this the only solution in my case?</p>\n\n<pre><code>#[derive(Clone)]\nstruct InputParser {\n    args: Vec&lt;String&gt;,\n    current: String,\n    consumed_quote: bool,\n}\n\nimpl InputParser {\n    pub fn parse(input: String) -&gt; Vec&lt;String&gt; {\n        let parser = InputParser {\n            args: Vec::new(),\n            current: String::new(),\n            consumed_quote: false,\n        };\n        for c in input.chars() {\n            match c {\n                '\"' =&gt; parser.consume_quote(),\n                ' ' =&gt; parser.consume_space(),\n                _ =&gt; parser.consume_char(c),\n            }\n        }\n        parser.end();\n\n        return parser.args;\n    }\n\n    pub fn consume_space(mut self) {\n        if !self.consumed_quote {\n            self.push_current();\n        }\n    }\n\n    pub fn consume_quote(mut self) {\n        self.consumed_quote = self.consumed_quote;\n        if self.consumed_quote {\n            self.push_current();\n        }\n    }\n\n    pub fn consume_char(mut self, c: char) {\n        self.current.push(c);\n    }\n\n    pub fn end(mut self) {\n        self.push_current();\n    }\n\n    pub fn push_current(mut self) {\n        if self.current.len() &gt; 0 {\n            self.args.push(self.current);\n            self.current = String::new();\n        }\n    }\n}\n</code></pre>\n\n<p>I want to access <code>parser</code> across iterations of the <code>for</code> loop.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1488713750, "post_id": 42607736, "comment_id": 72345292, "body": "If my answer doesn&#39;t help, could you add the output of <code>rustup component list</code> to your question?"}, {"owner": {"reputation": 14308, "user_id": 2106207, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/960430ab7aba908bb9aa62d530618a75?s=128&d=identicon&r=PG", "display_name": "Nan Xiao", "link": "https://stackoverflow.com/users/2106207/nan-xiao"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1488714901, "post_id": 42607736, "comment_id": 72345670, "body": "@LukasKalbertodt: Works like a charm!"}], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 5, "last_activity_date": 1488713644, "creation_date": 1488713644, "answer_id": 42607887, "question_id": 42607736, "link": "https://stackoverflow.com/questions/42607736/how-can-i-read-the-rust-documentation-offline/42607887#42607887", "title": "How can I read the Rust documentation offline?", "body": "<p>Maybe you need to add the <code>rust-docs</code> component, like this:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>rustup component add rust-docs\n</code></pre>\n\n<p>This will add the component if it's not installed already and will keep it up to date, whenever you update the toolchain it belongs to.</p>\n"}], "owner": {"reputation": 14308, "user_id": 2106207, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/960430ab7aba908bb9aa62d530618a75?s=128&d=identicon&r=PG", "display_name": "Nan Xiao", "link": "https://stackoverflow.com/users/2106207/nan-xiao"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2649, "favorite_count": 0, "closed_date": 1488726582, "accepted_answer_id": 42607887, "answer_count": 1, "score": 5, "last_activity_date": 1488726619, "creation_date": 1488712843, "last_edit_date": 1488726619, "question_id": 42607736, "link": "https://stackoverflow.com/questions/42607736/how-can-i-read-the-rust-documentation-offline", "closed_reason": "Duplicate", "title": "How can I read the Rust documentation offline?", "body": "<p>I use the default installation of Rust and want to read the doc following this <a href=\"http://rust-lang.github.io/book/second-edition/ch01-01-installation.html#local-documentation\" rel=\"nofollow noreferrer\">tutorial</a>:</p>\n\n<pre><code>$ rustup doc\n</code></pre>\n\n<p>But the above command outputs the following error:<br>\n<a href=\"https://i.stack.imgur.com/lH1BS.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/lH1BS.jpg\" alt=\"enter image description here\"></a></p>\n\n<p>There is indeed no <code>html</code> directory:  </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ ls /home/xiaonan/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/\nCOPYRIGHT  LICENSE-APACHE  LICENSE-MIT  README.md\n</code></pre>\n\n<p>How can I read the Rust documentation offline?</p>\n"}, {"tags": ["lambda", "rust", "closures"], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 2, "last_activity_date": 1488712109, "creation_date": 1488712109, "answer_id": 42607621, "question_id": 42606536, "link": "https://stackoverflow.com/questions/42606536/how-to-return-an-anonymous-function-lambda-that-receives-a-lambda-function/42607621#42607621", "title": "How to return an anonymous function/lambda that receives a lambda/function?", "body": "<p>First little mistake: you added a semicolon at the end of your function body. This means that</p>\n\n<pre><code>Box::new(move |m|m(x,y));\n</code></pre>\n\n<p>is just a statement without side effects, much like <code>3 + 4;</code>. When you remove the semicolon, you will get a better compiler error, because now the compiler starts to connect your expression type with the return type.</p>\n\n<p>Speaking of which: your return type is wrong, unfortunately. What you want, is to capture the two parameters <code>x</code> and <code>y</code> and return a closure which accepts <em>another</em> closure which is then called with the two parameters. This code works:</p>\n\n<pre><code>fn cons(x: i32, y: i32) -&gt;  Box&lt;Fn(&amp;Fn(i32, i32))&gt; {\n    Box::new(move |m| m(x, y))\n}\n</code></pre>\n\n<p>As you can see, the type of the returned closure is: <code>Fn(&amp;Fn(i32, i32))</code>. A closure which accepts <em>another</em> closure as argument. You can use it like this:</p>\n\n<pre><code>let fun = cons(3, 7);\nfun(&amp;|x, y| println!(\"{}\", x));\n</code></pre>\n\n<p>But we have two problems here:</p>\n\n<ol>\n<li><p>Why the reference <code>&amp;</code>? Closures in Rust are Voldemort types and you can only talk about them in terms of the traits they implement (e.g. the <code>Fn</code> trait). Usually, you have two ways to accept an arbitrary type which implements a trait <code>Foo</code>: with static dispatch and monomorphization (<code>fn bar&lt;T: Foo&gt;(x: T)</code>) or as trait object and with dynamic dispatch (<code>fn bar(x: &amp;Foo)</code>). However, you are already returning a trait object (<code>Box&lt;Fn(...)&gt;</code>) and a trait object can't have generic methods (they can't be monomorphized for various reasons). This means that you <em>need</em> to accept a trait object yourself and since trait objects are unsized, they need to hide behind a reference or something like <code>Box</code>.</p></li>\n<li><p>The closures don't return anything! Correct, because this again would require monomorphization, because Rust is statically typed. The examples you showed/linked are in dynamically typed language, where things like these are not a problem. In Rust, it's a different story. You <em>can</em> fake dynamic typing in Rust by using <a href=\"https://doc.rust-lang.org/std/any/index.html\" rel=\"nofollow noreferrer\"><code>Box&lt;Any&gt;</code></a> or something like that. But this is not really idiomatic and should be avoided. <em>Maybe</em> you really need it, but <em>maybe</em> you also want to incorrectly use patterns from other language in Rust and should instead think in a more rusty way about your problem ;-)</p></li>\n</ol>\n"}], "owner": {"reputation": 65, "user_id": 6053457, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dc15388cedf50b40b524173a851dd3cd?s=128&d=identicon&r=PG&f=1", "display_name": "Tan Kian-teng", "link": "https://stackoverflow.com/users/6053457/tan-kian-teng"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1316, "favorite_count": 0, "accepted_answer_id": 42607621, "answer_count": 1, "score": 0, "last_activity_date": 1488727591, "creation_date": 1488705395, "last_edit_date": 1495541829, "question_id": 42606536, "link": "https://stackoverflow.com/questions/42606536/how-to-return-an-anonymous-function-lambda-that-receives-a-lambda-function", "title": "How to return an anonymous function/lambda that receives a lambda/function?", "body": "<p>It's possible to create a ordered pair (cons in Lisp) using a lambda and a function, as shown in <a href=\"https://stackoverflow.com/questions/21769348/use-of-lambda-for-cons-car-cdr-definition-in-sicp\">Use of lambda for cons/car/cdr definition in SICP</a></p>\n\n<p>It also works in Python:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>def cons(x,y):\n    return lambda m:m(x,y)\ndef car(z):\n    return z(lambda x, y: x)\ndef cdr(z):\n    return z(lambda x, y: y)\n</code></pre>\n\n<p>When I implement it in Rust, which is a statically-typed language:</p>\n\n<pre><code>fn cons(x: i32, y: i32) -&gt; Box&lt;Fn() -&gt; Fn(i32, i32)&gt; {\n    Box::new(move |m| m(x, y));\n}\n</code></pre>\n\n<p>it shows the errors:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: the type of this value must be known in this context\n --&gt; src/main.rs:2:23\n  |\n2 |     Box::new(move |m| m(x, y));\n  |                       ^^^^^^^\n\nerror[E0308]: mismatched types\n --&gt; src/main.rs:1:54\n  |\n1 |   fn cons(x: i32, y: i32) -&gt; Box&lt;Fn() -&gt; Fn(i32, i32)&gt; {\n  |  ______________________________________________________^ starting here...\n2 | |     Box::new(move |m| m(x, y));\n3 | | }\n  | |_^ ...ending here: expected box, found ()\n  |\n  = note: expected type `Box&lt;std::ops::Fn() -&gt; std::ops::Fn(i32, i32) + 'static + 'static&gt;`\n  = note:    found type `()`\n</code></pre>\n\n<p>How do I define the type of <code>m</code>?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1488712614, "post_id": 42606443, "comment_id": 72344953, "body": "Could you further simplify your code? It&#39;s still quite a big chunk of code and it&#39;s easier to answer and easier for you to understand when we&#39;re only dealing with a small piece of code. Thanks :)"}, {"owner": {"reputation": 566, "user_id": 4247881, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh6.googleusercontent.com/-Yc0botpVHKw/AAAAAAAAAAI/AAAAAAAAAAA/1vXyVePSuKM/photo.jpg?sz=128", "display_name": "Glenn Pierce", "link": "https://stackoverflow.com/users/4247881/glenn-pierce"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1488716161, "post_id": 42606443, "comment_id": 72345996, "body": "I tried to reduce the size a little. I could reduce more but that would remove some of the errors and I wasn&#39;t sure whether I should as I don&#39;t know if they are separate errors or all related to one fix. What do you think ?"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1488722559, "post_id": 42606443, "comment_id": 72347984, "body": "Why are you using <code>Box&lt;&amp;&#39;a Element&gt;</code>? <code>Box</code> already heap allocates and is basically just a pointer, thus <code>Box&lt;Element&gt;</code> should be sufficient. This would also solve your lifetime problem (but shine light on other problems). Also note, that a spawned thread can outlive everything else, so the threads spawned in <code>Pipeline::run()</code> can live longer than the <code>Pipeline</code> object! This is not an answer, but a nudge into the right direction, I hope."}, {"owner": {"reputation": 566, "user_id": 4247881, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh6.googleusercontent.com/-Yc0botpVHKw/AAAAAAAAAAI/AAAAAAAAAAA/1vXyVePSuKM/photo.jpg?sz=128", "display_name": "Glenn Pierce", "link": "https://stackoverflow.com/users/4247881/glenn-pierce"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1488727079, "post_id": 42606443, "comment_id": 72349412, "body": "I was using Box here as without I get errors about not knowing the size of Element as it is a trait."}], "answers": [{"comments": [{"owner": {"reputation": 566, "user_id": 4247881, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh6.googleusercontent.com/-Yc0botpVHKw/AAAAAAAAAAI/AAAAAAAAAAA/1vXyVePSuKM/photo.jpg?sz=128", "display_name": "Glenn Pierce", "link": "https://stackoverflow.com/users/4247881/glenn-pierce"}, "edited": false, "score": 0, "creation_date": 1488731732, "post_id": 42609428, "comment_id": 72351030, "body": "Thanks in the end I used crossbeam. The multiple errors were confusing me.  Shame they can&#39;t reintroduce crossbeam into the standard library."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 566, "user_id": 4247881, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh6.googleusercontent.com/-Yc0botpVHKw/AAAAAAAAAAI/AAAAAAAAAAA/1vXyVePSuKM/photo.jpg?sz=128", "display_name": "Glenn Pierce", "link": "https://stackoverflow.com/users/4247881/glenn-pierce"}, "edited": false, "score": 0, "creation_date": 1488737962, "post_id": 42609428, "comment_id": 72353282, "body": "They certainly could introduce <code>crossbeam</code>&#39;s functionality in the standard library, but developing new features as an external library has several advantages. It gives the authors more flexibility to change the API in the early days and it gives them more audience, as new features introduced in the standard library are first introduced as <i>unstable</i>, which means only those who use a nightly compiler can use them."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 1, "last_activity_date": 1488723283, "creation_date": 1488723283, "answer_id": 42609428, "question_id": 42606443, "link": "https://stackoverflow.com/questions/42606443/lifetime-errors-i-dont-know-how-to-solve/42609428#42609428", "title": "Lifetime errors I don&#39;t know how to solve", "body": "<p>Each <code>note</code> reported by the compiler <em>adds context</em> to the preceding error or warning. It's not a separate error; fixing the error will make the notes go away.</p>\n\n<p>Now unfortunately, the error message isn't all that clear. The problem is that you're trying to move <code>e</code>, which is of type <code>Box&lt;&amp;'a Element&gt;</code>, into the closure passed to <code>thread::spawn</code>, but <code>thread::spawn</code> requires a closure that is valid for the <code>'static</code> lifetime; i.e. it doesn't contain references that are shorter than <code>'static</code> (and <code>'static</code> is the longest lifetime available: it corresponds to the duration of the whole program). <code>'a</code> is not guaranteed to be equal to <code>'static</code>, hence the error.</p>\n\n<p>Your code is invalid because the thread may continue running after the <code>Element</code> the reference is referring to has been freed.</p>\n\n<p>One possible solution is to simply not use references inside the <code>elements</code> vector: use <code>Vec&lt;Box&lt;Element&gt;&gt;</code>. That only works if you don't need to reuse the elements afterwards, though.</p>\n\n<p>Another option is to use thread-safe reference counters (<a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html\" rel=\"nofollow noreferrer\"><code>Arc</code></a>) instead of simple references. This eliminates lifetime concerns, but introduces a bit of runtime overhead.</p>\n\n<p>One last option is to use <a href=\"https://aturon.github.io/crossbeam-doc/crossbeam/\" rel=\"nofollow noreferrer\"><code>crossbeam</code></a> to <a href=\"https://aturon.github.io/crossbeam-doc/crossbeam/struct.Scope.html#method.spawn\" rel=\"nofollow noreferrer\">spawn</a> <a href=\"https://aturon.github.io/crossbeam-doc/crossbeam/fn.scope.html\" rel=\"nofollow noreferrer\">scoped</a> threads. With this option, you can continue using references. One thing you can't do with this is return the join handles before the scope has ended. You could still return the join handles from <code>Pipeline::run</code>, but <code>crossbeam</code> will join all the threads before <code>scope</code> returns.</p>\n\n<p><em>Historical note: Just before Rust reached 1.0, there used to be an implementation of scoped threads in the standard library. But instead of using a closure for the scope, it would simply return a <code>JoinHandle</code>, and the safety of this implementation relied on the program calling the destructor on the <code>JoinHandle</code>. If the destructor wasn't run at the appropriate time (e.g. you called <code>mem::forget</code>), then the thread would keep running and potentially reference deallocated objects. <code>crossbeam</code> still relies on the destructor being called, but it's written so that users of the library can never obtain ownership of the <code>Scope</code>, so the library can guarantee that the destructor will be run.</em></p>\n"}], "owner": {"reputation": 566, "user_id": 4247881, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh6.googleusercontent.com/-Yc0botpVHKw/AAAAAAAAAAI/AAAAAAAAAAA/1vXyVePSuKM/photo.jpg?sz=128", "display_name": "Glenn Pierce", "link": "https://stackoverflow.com/users/4247881/glenn-pierce"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 299, "favorite_count": 0, "accepted_answer_id": 42609428, "answer_count": 1, "score": 0, "last_activity_date": 1488723283, "creation_date": 1488704683, "last_edit_date": 1488722286, "question_id": 42606443, "link": "https://stackoverflow.com/questions/42606443/lifetime-errors-i-dont-know-how-to-solve", "title": "Lifetime errors I don&#39;t know how to solve", "body": "<p>Hi I am having issues with lifetimes in a fairly simple test case\nand I can't seem to understand what the compiler is telling me.\nThe code below pastes into Rust playground.</p>\n\n<p>The idea about the code is that <code>Element</code>s are strung together into a pipeline. Data eventually will be pass one one element to the next. Each stage has a <code>(rx, tx)</code> pair on which it receives input from previous stage and sends data to next stage. I can mark the <code>Element</code>s as <code>Sync</code> as only one <code>Element</code> will ever process one part of the data at one time.</p>\n\n<p>The errors are:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n  --&gt; &lt;anon&gt;:56:18\n   |\n56 |         for e in self.elements {\n   |                  ^^^^^^^^^^^^^\n   |\nnote: first, the lifetime cannot outlive the lifetime 'a as defined on the body at 53:53...\n  --&gt; &lt;anon&gt;:53:54\n   |\n53 |     pub fn run(&amp;self) -&gt; Vec&lt;thread::JoinHandle&lt;()&gt;&gt; {\n   |                                                      ^\nnote: ...so that expression is assignable (expected std::vec::Vec&lt;Box&lt;&amp;Element&gt;&gt;, found std::vec::Vec&lt;Box&lt;&amp;'a Element + 'a&gt;&gt;)\n  --&gt; &lt;anon&gt;:56:18\n   |\n56 |         for e in self.elements {\n   |                  ^^^^^^^^^^^^^\n   = note: but, the lifetime must be valid for the static lifetime...\nnote: ...so that the type `[closure@&lt;anon&gt;:62:41: 64:15 e:Box&lt;&amp;Element&gt;, sender:std::sync::Arc&lt;std::sync::Mutex&lt;std::sync::mpsc::SyncSender&lt;(std::string::String, std::string::String)&gt;&gt;&gt;, receiver:std::sync::Arc&lt;std::sync::Mutex&lt;std::sync::mpsc::Receiver&lt;(std::string::String, std::string::String)&gt;&gt;&gt;]` will meet its required lifetime bounds\n  --&gt; &lt;anon&gt;:62:27\n   |\n62 |              handles.push(thread::spawn(move || {\n   |                           ^^^^^^^^^^^^^\n</code></pre>\n\n<p>The first error I am confused by as <code>Element</code>s are defined as\n<code>&amp;'a Element</code> so should they not tell the compiler that they stick around\nfor along as <code>Pipeline</code>?</p>\n\n<p>The second error I guess is telling me <code>Vec&lt;thread::JoinHandle&lt;()&gt;&gt;</code> as to be told it depends on the lifetime <code>'a</code> ? I am not sure how to convey that though.</p>\n\n<p>I hope the third will make more sense after I correct the first two. At the moment I just don't know what its telling me.</p>\n\n<pre><code>use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::result::Result;\nuse std::sync::mpsc::{SyncSender, Receiver, sync_channel};\n\npub trait Element: Send + Sync {\n    fn run(&amp;self, output: Arc&lt;Mutex&lt;SyncSender&lt;i32&gt;&gt;&gt;,\n                   input: Arc&lt;Mutex&lt;Receiver&lt;i32&gt;&gt;&gt;);\n}\n\npub struct TestElement {}\n\nimpl TestElement {\n    pub fn new() -&gt; Self {\n        TestElement {}\n    }\n}\n\nimpl Element for TestElement {\n    fn run(&amp;self, output: Arc&lt;Mutex&lt;SyncSender&lt;i32&gt;&gt;&gt;,\n                   input: Arc&lt;Mutex&lt;Receiver&lt;i32&gt;&gt;&gt;) {\n        println!(\"Hello\");\n    }\n}\n\npub struct Pipeline&lt;'a&gt; {\n    elements: Vec&lt;Box&lt;&amp;'a Element&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Pipeline&lt;'a&gt; {\n    pub fn new(name: String) -&gt; Self {\n        Pipeline {\n            elements: Vec::new(),\n        }\n    }\n\n    pub fn run(&amp;self) -&gt; Vec&lt;thread::JoinHandle&lt;()&gt;&gt; {\n        let mut handles = Vec::with_capacity(self.elements.len());\n\n        for e in self.elements {\n             let channel = sync_channel::&lt;i32&gt;(1000);\n             let sender = Arc::new(Mutex::new(channel.0)).clone();\n             let receiver = Arc::new(Mutex::new(channel.1)).clone();\n\n             handles.push(thread::spawn(move || {\n                 e.run(sender, receiver);\n             }));\n        }\n\n        handles\n    }\n}\n\nfn main() {\n    let mut test_element = TestElement::new();\n    let mut pipeline = Pipeline::new(\"example pipeline\".to_string());\n\n    let handles = pipeline.run();\n}\n</code></pre>\n"}, {"tags": ["rust", "immutability", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 521, "user_id": 1031060, "user_type": "registered", "accept_rate": 93, "profile_image": "https://i.stack.imgur.com/UQH9F.jpg?s=128&g=1", "display_name": "neogeek23", "link": "https://stackoverflow.com/users/1031060/neogeek23"}, "edited": false, "score": 0, "creation_date": 1488706890, "post_id": 42605325, "comment_id": 72343228, "body": "This is very helpful thank you.  Something I don&#39;t understand though is in your example, location_set is passed to has_location directly (so the function owns it, right?).  This in my mind means that at the end of has_location&#39;s scope, location_set should be destroyed, no?  How does location_set continue to exist to be used in the if block?  Also if location_set is immutable, how is push_back able to add to the end of the list, is it because the function coerces the mutable borrow into an immutable borrow?    Thanks!"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 521, "user_id": 1031060, "user_type": "registered", "accept_rate": 93, "profile_image": "https://i.stack.imgur.com/UQH9F.jpg?s=128&g=1", "display_name": "neogeek23", "link": "https://stackoverflow.com/users/1031060/neogeek23"}, "edited": false, "score": 0, "creation_date": 1488724342, "post_id": 42605325, "comment_id": 72348538, "body": "See my reply at the end of the answer."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 2, "last_activity_date": 1488724320, "last_edit_date": 1488724320, "creation_date": 1488696060, "answer_id": 42605325, "question_id": 42605042, "link": "https://stackoverflow.com/questions/42605042/what-is-the-best-practice-with-the-borrow-checker-for-inspecting-mutable-referen/42605325#42605325", "title": "What is the best practice with the borrow checker for inspecting mutable references?", "body": "<p>If you have a mutable borrow, you can always <em>reborrow</em> it as an immutable borrow. This even happens implicitly (a <code>&amp;mut T</code> will coerce to <code>&amp;T</code>). Therefore, you can just pass <code>location_set</code> to <code>has_location</code> directly. Or if you want to make it clear that the function doesn't mutate its argument, you can write <code>&amp;*location_set</code> instead of <code>location_set</code> (though I find this to be unnecessary).</p>\n\n<p>Also, note that you can't use the mutable borrow while the immutable borrow exists; the immutable borrow freezes the data structure while it's in scope. Likewise, you can't use a variable while there's a mutable borrow on that variable in scope. In your first code sample, you can't refer to <code>locations</code> while <code>location_set</code> is in scope, because <code>location_set</code> takes a mutable borrow on <code>locations</code>, but you can just use <code>location_set</code> again, because <code>push_back</code> only requires a mutable borrow (it doesn't take a <code>LinkedList</code> by value).</p>\n\n<p>A function that merely inspects a data structure will usually receive an immutable borrow to the data structure. If the data structure was passed by value instead, the function would take ownership of it and would therefore destroy it before returning (unless it's moved elsewhere). Therefore, yes, you want <code>has_location</code> to accept an immutable borrow to the <code>LinkedList</code>. By accepting an immutable borrow (as opposed to a mutable borrow), the compiler will prevent you from modifying the <code>LinkedList</code> (unless you use unsafe code).</p>\n\n<p>Putting it all together:</p>\n\n<pre><code>use std::collections::LinkedList;\n\nstruct Location {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let mut locations = LinkedList::new();\n    let next_checkpoint_x = 0;\n    let next_checkpoint_y = 0;\n\n    loop {\n        let location_set = &amp;mut locations;\n        // Scanner stuff happens.\n        if !has_location(location_set, &amp;next_checkpoint_x, &amp;next_checkpoint_y) {\n            let point = Location { x: next_checkpoint_x, y: next_checkpoint_y };\n            location_set.push_back(point);\n        }\n    }\n}\n\nfn has_location(location_list: &amp;LinkedList&lt;Location&gt;, target_x: &amp;i32, target_y: &amp;i32) -&gt; bool {\n    true\n}\n</code></pre>\n\n<hr>\n\n<blockquote>\n  <p>Something I don't understand though is in your example, <code>location_set</code> is passed to <code>has_location</code> directly (so the function owns it, right?). This in my mind means that at the end of <code>has_location</code>'s scope, <code>location_set</code> should be destroyed, no? How does <code>location_set</code> continue to exist to be used in the <code>if</code> block?</p>\n</blockquote>\n\n<p>No, <code>has_location</code> doesn't own <code>location_set</code>. If this was any other type that doesn't implement <code>Copy</code> (e.g. <code>String</code>), then you would be right, but references have special rules to make them more convenient to use.</p>\n\n<p>When you pass a reference to a function, the compiler will automatically <em>reborrow</em> that reference to produce a new reference, generally with a shorter lifetime. Here, the compiler is reborrowing the mutable reference and producing an immutable reference; the mutable reference cannot be used until the immutable reference goes out of scope (the immutable reference is not bound to a variable here, so you don't really notice that). Conceptually, it's as if you were passing an immutable reference to the mutable reference (in Rust, a <code>&amp; &amp;mut T</code> doesn't let you mutate the <code>T</code>, because there could be multiple copies of that outer reference), it's just that the two references are \"flattened\".</p>\n\n<blockquote>\n  <p>Also if <code>location_set</code> is immutable, how is <code>push_back</code> able to add to the end of the list, is it because the function coerces the mutable borrow into an immutable borrow?</p>\n</blockquote>\n\n<p><code>location_set</code> is still a mutable reference (because we create it with the <code>&amp;mut</code> operator). The fact that <code>has_location</code> operates on an immutable reference doesn't change the fact that <code>location_set</code> is a mutable reference. Once the call to <code>has_location</code> has been evaluated, <code>location_set</code> can be reused as a mutable reference, so mutation operations such as <code>push_back</code> are allowed.</p>\n\n<p>Remember that mutability is Rust is purely a compile-time concept; the <code>mut</code> or lack of <code>mut</code> simply lets the compiler validate that your code doesn't do illegal operations, but once your code is compiled, these markers are nowhere to be seen.</p>\n"}], "owner": {"reputation": 521, "user_id": 1031060, "user_type": "registered", "accept_rate": 93, "profile_image": "https://i.stack.imgur.com/UQH9F.jpg?s=128&g=1", "display_name": "neogeek23", "link": "https://stackoverflow.com/users/1031060/neogeek23"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 209, "favorite_count": 0, "accepted_answer_id": 42605325, "answer_count": 1, "score": 0, "last_activity_date": 1488727075, "creation_date": 1488693411, "last_edit_date": 1488727075, "question_id": 42605042, "link": "https://stackoverflow.com/questions/42605042/what-is-the-best-practice-with-the-borrow-checker-for-inspecting-mutable-referen", "title": "What is the best practice with the borrow checker for inspecting mutable references?", "body": "<p>I want to take a linked list and populate it with instances of a struct, but only if the list doesn't already contain the item I'm considering adding.</p>\n\n<p>I'm working with points so if (3,5) is in the list I don't want to add it, otherwise I do.</p>\n\n<p>My current code:</p>\n\n<pre><code>use std::collections::LinkedList;\n\nstruct Location {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let mut locations = LinkedList::new();\n\n    loop {\n        let location_set = &amp;mut locations;\n        // Scanner stuff happens.\n        if !has_location(location_set, &amp;next_checkpoint_x, &amp;next_checkpoint_y) {\n            let point = Location {\n                x: next_checkpoint_x,\n                y: next_checkpoint_y,\n            };\n            locations.push_back(point);\n        }\n    }\n}\n\nfn has_location(location_list: LinkedList&lt;Location&gt;, target_x: &amp;i32, target_y: &amp;i32) -&gt; bool {\n    true // Just until I can figure out this mutability stuff\n}\n</code></pre>\n\n<p>I've been able to get it to run by these changes, but this seems wrong to me.</p>\n\n<pre><code>loop {\n    if !has_location(&amp;mut locations, &amp;next_checkpoint_x, &amp;next_checkpoint_y) {\n        // stuff\n    }\n}\n</code></pre>\n\n\n\n<pre><code>fn has_location(location_list: &amp;LinkedList&lt;Location&gt;, target_x: &amp;i32, target_y: &amp;i32) -&gt; bool {\n    true\n}\n</code></pre>\n\n<p>I don't want <code>has_location</code> to be able to mutate the linked list, I just want it to be able to borrow it so that it can look inside of it.  I don't want to have to think about <code>has_location</code> (or a similar function) affecting the linked lists it inspects.  This is why I created the <code>location_set</code>.  I want something to refer to locations in a read-only sense and that to be passed to the <code>has_location</code> function and for what is being referred to (locations) to not be destroyed after calling the <code>has_location</code> function.  I include the <code>&amp;</code> in the passing of the parameters in the call of the function, because I don't want the parameters passed destroyed - so I want them borrowed?  </p>\n\n<p>Is what I'm wanting something that makes sense - if I originally declare locations as a mutable linked list can I pass an immutable version of it to a function to evaluate?</p>\n"}, {"tags": ["rust", "rust-cargo"], "answers": [{"tags": [], "owner": {"reputation": 74890, "user_id": 246776, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/PZwCJ.jpg?s=128&g=1", "display_name": "eonil", "link": "https://stackoverflow.com/users/246776/eonil"}, "is_accepted": false, "score": 2, "last_activity_date": 1488662253, "last_edit_date": 1488662253, "creation_date": 1488661523, "answer_id": 42601407, "question_id": 42601406, "link": "https://stackoverflow.com/questions/42601406/cargo-fails-to-link-with-cc-due-to-signal-10-when-run-from-inside-xcode-8/42601407#42601407", "title": "Cargo fails to link with `cc` due to signal 10 when run from inside Xcode 8", "body": "<p>The environment variable <code>MallocNanoZone</code> is set to <code>1</code>. Remove it or set it to <code>0</code> and the problem magically disappears.</p>\n\n<p>I don't know why this happens. In my case, the error occurred while running cargo under an Xcode debugging context using <code>NSTask</code>. Xcode sets <code>MallocNanoZone=1</code> automatically, and it changes some memory management behavior which is not friendly with <code>cargo</code> execution.</p>\n"}], "owner": {"reputation": 74890, "user_id": 246776, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/PZwCJ.jpg?s=128&g=1", "display_name": "eonil", "link": "https://stackoverflow.com/users/246776/eonil"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 111, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1488662253, "creation_date": 1488661523, "last_edit_date": 1488662116, "question_id": 42601406, "link": "https://stackoverflow.com/questions/42601406/cargo-fails-to-link-with-cc-due-to-signal-10-when-run-from-inside-xcode-8", "title": "Cargo fails to link with `cc` due to signal 10 when run from inside Xcode 8", "body": "<p>I got a strange error while running <code>cargo</code> in an macOS app from inside Xcode 8:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Eonil$ cargo clean\n[~/Temp/repotest1/ag] (master)\nEonil$ cargo build\n   Compiling ag v0.1.0 (file:///Users/Eonil/Temp/repotest1/ag)\nerror: linking with `cc` failed: signal: 10\n  |\n  = note: \"cc\" \"-m64\" \"-L\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib\" \"/Users/Eonil/Temp/repotest1/ag/target/debug/ag.0.o\" \"-o\" \"/Users/Eonil/Temp/repotest1/ag/target/debug/ag\" \"-Wl,-dead_strip\" \"-nodefaultlibs\" \"-L\" \"/Users/Eonil/Temp/repotest1/ag/target/debug/deps\" \"-L\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libstd-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libpanic_unwind-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libunwind-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/librand-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libcollections-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/librustc_unicode-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/liballoc-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/liballoc_jemalloc-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/liblibc-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libcore-f5a209a9.rlib\" \"/Users/Eonil/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/x86_64-apple-darwin/lib/libcompiler_builtins-f5a209a9.rlib\" \"-l\" \"System\" \"-l\" \"pthread\" \"-l\" \"c\" \"-l\" \"m\"\n  = note: \n\nerror: aborting due to previous error\n\nerror: Could not compile `ag`.\n\nTo learn more, run the command again with --verbose.\n</code></pre>\n\n<p>Why do I get this error and how to fix this?</p>\n\n<ul>\n<li><code>cargo 0.15.0-nightly (298a012 2016-12-20)</code></li>\n<li><code>rustc 1.14.0 (e8a012324 2016-12-16)</code></li>\n</ul>\n"}, {"tags": ["vector", "rust", "lifetime"], "comments": [{"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1488658412, "post_id": 42600519, "comment_id": 72332362, "body": "I suggest you use a library like <a href=\"https://docs.rs/petgraph/0.4.3/petgraph/\" rel=\"nofollow noreferrer\"><code>petgraph</code></a> to construct a graph structure."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1488658426, "post_id": 42600519, "comment_id": 72332369, "body": "Welcome to Stack Overflow! Being a part of this community involves some basic guidelines, such as providing a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a> when asking a question. This question does not currently provide the proper imports, it omits the declaration of <code>util</code>, and it doesn&#39;t define <code>Csv</code>. It also had all sorts of &quot;junk&quot; in the code. Please provide a <b>minimal</b> reproduction as well. I doubt you need a &quot;<code>StopWatch</code>&quot; to show us the problem. Also, there are <a href=\"http://stackoverflow.com/search?q=%5Brust%5D+is%3Aq+does+not+live+long+enough\"><b>297 existing questions with this error</b></a>. Please tell us how this is different."}], "answers": [{"tags": [], "owner": {"reputation": 3495, "user_id": 36585, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a0ccd55542e51b1b98f5a72b30c815dc?s=128&d=identicon&r=PG", "display_name": "pnkfelix", "link": "https://stackoverflow.com/users/36585/pnkfelix"}, "is_accepted": false, "score": 0, "last_activity_date": 1489498951, "last_edit_date": 1489498951, "creation_date": 1489495421, "answer_id": 42786376, "question_id": 42600519, "link": "https://stackoverflow.com/questions/42600519/need-vector-slices-to-live-longer/42786376#42786376", "title": "Need vector slices to live longer", "body": "<p>I can tell you from your function signature that you're going to have big problems trying to write this function, at least if you want it to contain non-empty <code>HashSet</code>s in the result.</p>\n\n<pre><code>fn populate_chain(file_path: &amp;str) -&gt; HashMap&lt;String, HashSet&lt;&amp;String&gt;&gt;\n</code></pre>\n\n<p>This function signature has references in it; they have elided lifetimes. If you make the inferred lifetimes explicit, it would look like this:</p>\n\n<pre><code>fn populate_chain&lt;'a&gt;(file_path: &amp;'a str) -&gt; HashMap&lt;String, HashSet&lt;&amp;'a String&gt;&gt;\n</code></pre>\n\n<p>In other words: This function claims that, given some string slice with lifetime <code>'a</code>, it will give back a collection that holds <code>String</code> objects with lifetime <code>'a</code>.</p>\n\n<p>But you have no means for allocating such <code>String</code> objects within your code. :(</p>\n\n<p>So, you're stuck; no matter what you put into that function body, you're not going to be able to supply an implementation that returns a non-trivial result with respect to the <code>HashSet</code>s.</p>\n\n<p>However, all is not lost. You could, for example, revise your function so that it also takes as an additional parameter a reference to a <code>TypedArena</code> with an appropriate lifetime, and then allocate the strings there. Another (simpler) option would be to use <code>HashSet&lt;String&gt;</code> instead of <code>HashSet&lt;&amp;String&gt;</code>...</p>\n"}], "owner": {"reputation": 11, "user_id": 6668729, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/53a97752383d04b7a4b10258905c1999?s=128&d=identicon&r=PG&f=1", "display_name": "Andrew Breidenbach", "link": "https://stackoverflow.com/users/6668729/andrew-breidenbach"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 66, "favorite_count": 0, "answer_count": 1, "score": -2, "last_activity_date": 1489498951, "creation_date": 1488656455, "last_edit_date": 1488658149, "question_id": 42600519, "link": "https://stackoverflow.com/questions/42600519/need-vector-slices-to-live-longer", "title": "Need vector slices to live longer", "body": "<p>Is there any way to get the slices of this vector to last long enough so that I can use them in this kind of circular structure?</p>\n\n<pre><code>fn populate_chain(file_path: &amp;str) -&gt; HashMap&lt;String, HashSet&lt;&amp;String&gt;&gt; {\n    println!(\"loading...\");\n    let time = util::StopWatch::new();\n    let mut words = HashMap::new();\n    {\n        let f = |mut x: Vec&lt;String&gt;| {\n            let word = x.pop().unwrap();\n            words.insert(word, HashSet::new());\n        };\n        Csv::process_rows(f, file_path, \"\\t\");\n    }\n\n    let col: Vec&lt;(String, HashSet&lt;&amp;String&gt;)&gt; = words.clone().into_iter().collect();\n    let m: usize = col.len() - 1;\n    for i in 0..m {\n        let ref k: String = col[i].0;\n        for j in i..m {\n            let ref nk: String = col[j].0;\n            if check_link(k, nk) {\n                words.get_mut(k).unwrap().insert(nk);\n                words.get_mut(nk).unwrap().insert(k);\n            }\n        }\n    }\n\n    time.print_time();\n    words\n}\n</code></pre>\n\n<p>I'm using the double for loops to chain words together which are related so that they can be quickly looked up later.</p>\n\n<p>Here are the compiler errors...</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `col` does not live long enough\n  --&gt; src/main.rs:28:29\n   |\n28 |         let ref k: String = col[i].0;\n   |                             ^^^ does not live long enough\n...\n40 | }\n   | - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the anonymous lifetime #1 defined on the block at 13:72...\n  --&gt; src/main.rs:13:73\n   |\n13 | fn populate_chain(file_path: &amp;str) -&gt; HashMap&lt;String, HashSet&lt;&amp; String&gt;&gt;{\n   |                                                                         ^\n\nerror: `col` does not live long enough\n  --&gt; src/main.rs:30:34\n   |\n30 |             let ref nk: String = col[j].0;\n   |                                  ^^^ does not live long enough\n...\n40 | }\n   | - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the anonymous lifetime #1 defined on the block at 13:72...\n  --&gt; src/main.rs:13:73\n   |\n13 | fn populate_chain(file_path: &amp;str) -&gt; HashMap&lt;String, HashSet&lt;&amp; String&gt;&gt;{\n   |  \n</code></pre>\n"}, {"tags": ["rust", "ffi"], "comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1488638792, "post_id": 42596430, "comment_id": 72325679, "body": "Off topic, are you sure it&#39;s possible to treat <code>va_list</code> as a <code>void *</code>? My understanding is that it can be pretty much anything and doesn&#39;t even need to be a pointer. What it is on platforms supported by llvm+rust is a different matter, of course"}, {"owner": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "reply_to_user": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1488645538, "post_id": 42596430, "comment_id": 72327916, "body": "I just mean I&#39;m not handling it. I think it&#39;s guaranteed to be pointer width for me. If it isn&#39;t then the program won&#39;t compile, so there&#39;s no chance of UB because of this."}, {"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1488646289, "post_id": 42596430, "comment_id": 72328200, "body": "@derekdreery I suggest you use the <a href=\"https://github.com/thepowersgang/va_list-rs\" rel=\"nofollow noreferrer\"><code>va_list</code> crate</a> instead of relying it to be <code>void*</code>."}, {"owner": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "edited": false, "score": 0, "creation_date": 1488646484, "post_id": 42596430, "comment_id": 72328267, "body": "I could do this, but since in my case I just send it straight back to C (pass to vsnprintf), I can avoid an extra crate. Also, at the moment, va_list only supports platforms where <code>sizeof(va_list) == sizeof(void*)</code>."}, {"owner": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "edited": false, "score": 0, "creation_date": 1488646591, "post_id": 42596430, "comment_id": 72328306, "body": "Also if you are the owner of that crate, I&#39;ve put in a PR for float support on x86_64"}, {"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 1, "creation_date": 1488646959, "post_id": 42596430, "comment_id": 72328425, "body": "@derekdreery I&#39;m not the owner of the crate, you could file an issue though :)"}], "owner": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 90, "favorite_count": 0, "closed_date": 1488639675, "answer_count": 0, "score": 0, "last_activity_date": 1488639947, "creation_date": 1488633184, "last_edit_date": 1488639947, "question_id": 42596430, "link": "https://stackoverflow.com/questions/42596430/is-it-possible-for-an-extern-c-function-to-have-access-to-a-rust-closure", "closed_reason": "Duplicate", "title": "Is it possible for an extern &quot;C&quot; function to have access to a Rust closure?", "body": "<p>I wish to wrap a library where there is a function with the following type signature:</p>\n\n<pre><code>int fn_name(void (*cb)(*char, va_list));\n</code></pre>\n\n<p>I want the callback I pass to have access to some context in Rust. My idea was to create a closure with access to the context, and then convert this closure into an <code>extern \"C\"</code> raw function pointer. I don't think this is going to work.</p>\n\n<p>Is it possible to do what I am trying to do, and if so how do I do it?</p>\n\n<blockquote>\n  <p>Note that the function uses <code>va_list</code> from <code>stdarg.h</code>, but I'm happy to treat it as a <code>*void</code> - handling that is out of scope of this question.</p>\n</blockquote>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "is_accepted": true, "score": 6, "last_activity_date": 1488624020, "last_edit_date": 1495539968, "creation_date": 1488623413, "answer_id": 42594912, "question_id": 42594102, "link": "https://stackoverflow.com/questions/42594102/return-type-for-rusqlite-mappedrows/42594912#42594912", "title": "Return type for rusqlite MappedRows", "body": "<p>I'll divide the answer in two parts, the first about how to fix the return type without considering borrow-checker, the second about why it doesn't work even if you fixed the return type.</p>\n\n<hr>\n\n<h1>\u00a71.</h1>\n\n<p>Every closure has a unique, anonymous type, so <code>c</code> cannot be of any type <code>F</code> the <em>caller</em> provides. That means this line will never compile:</p>\n\n<pre><code>let c: F = |row: &amp;Row| { ... } // no, wrong, always.\n</code></pre>\n\n<p>Instead, the type should be propagated out from the <code>dump</code> function, i.e. something like:</p>\n\n<pre><code>//         \u2193 no generics\npub fn dump(&amp;self) -&gt; MappedRows&lt;\u201ctype of that c\u201d&gt; {\n    ..\n}\n</code></pre>\n\n<p>Stable Rust does not provide a way to name that type. But we could do so in nightly with the \"impl Trait\" feature:</p>\n\n<pre><code>#![feature(conservative_impl_trait)]\n\n//                               \u2193~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\npub fn dump(&amp;self) -&gt; MappedRows&lt;impl FnMut(&amp;Row) -&gt; DateTime&lt;UTC&gt;&gt; {\n    ..\n}\n// note: wrong, see \u00a72.\n</code></pre>\n\n<p>The <code>impl F</code> here means that, \u201cwe are going to return a <code>MappedRows&lt;T&gt;</code> type where <code>T: F</code>, but we are not going to specify what exactly is <code>T</code>; the caller should be ready to treat anything satisfying <code>F</code> as a candidate of <code>T</code>\u201d.</p>\n\n<p>As your closure does not capture any variables, you could in fact turn <code>c</code> into a function. We could name a function pointer type, without needing \"impl Trait\".</p>\n\n<pre><code>//                               \u2193~~~~~~~~~~~~~~~~~~~~~~~~\npub fn dump(&amp;self) -&gt; MappedRows&lt;fn(&amp;Row) -&gt; DateTime&lt;UTC&gt;&gt; {\n    let mut stmt = self.conn.prepare(\"SELECT created_at FROM work ORDER BY created_at ASC\").unwrap();\n\n    fn c(row: &amp;Row) -&gt; DateTime&lt;UTC&gt; {\n        row.get(0)\n    }\n\n    stmt.query_map(&amp;[], c as fn(&amp;Row) -&gt; DateTime&lt;UTC&gt;).unwrap()\n}\n// note: wrong, see \u00a72.\n</code></pre>\n\n<p>Anyway, if we do use \"impl Trait\", since <code>MappedRows</code> is used as an Iterator, it is more appropriate to just say so:</p>\n\n<pre><code>#![feature(conservative_impl_trait)]\n\npub fn dump&lt;'c&gt;(&amp;'c self) -&gt; impl Iterator&lt;Item = Result&lt;DateTime&lt;UTC&gt;&gt;&gt; + 'c {\n    ..\n}\n// note: wrong, see \u00a72.\n</code></pre>\n\n<p>(without the <code>'c</code> bounds the compiler will complain E0564, seems lifetime elision doesn't work with impl Trait yet)</p>\n\n<p>If you are stuck with Stable Rust, you cannot use the \"impl Trait\" feature. You could wrap the trait object in a Box, at the cost of heap allocation and dynamic  dispatch:</p>\n\n<pre><code>pub fn dump(&amp;self) -&gt; Box&lt;Iterator&lt;Item = Result&lt;DateTime&lt;UTC&gt;&gt;&gt;&gt; {\n    ...\n    Box::new(stmt.query_map(&amp;[], c).unwrap())\n}\n// note: wrong, see \u00a72.\n</code></pre>\n\n<hr>\n\n<h1>\u00a72.</h1>\n\n<p>The above fix works if you want to, say, just <a href=\"https://stackoverflow.com/questions/25445761/returning-a-closure-from-a-function\">return an independent closure or iterator</a>. But it does not work if you return <code>rusqlite::MappedRows</code>. The compiler will not allow the above to work due to <em>lifetime</em> issue:</p>\n\n<pre><code>error: `stmt` does not live long enough\n  --&gt; 1.rs:23:9\n   |\n23 |         stmt.query_map(&amp;[], c).unwrap()\n   |         ^^^^ does not live long enough\n24 | }\n   | - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the anonymous lifetime #1 defined on the body at 15:80...\n  --&gt; 1.rs:15:81\n   |\n15 | pub fn dump(conn: &amp;Connection) -&gt; MappedRows&lt;impl FnMut(&amp;Row) -&gt; DateTime&lt;UTC&gt;&gt; {\n   |                                                                                 ^\n</code></pre>\n\n<p>And this is correct. <a href=\"https://jgallagher.github.io/rusqlite/rusqlite/struct.MappedRows.html\" rel=\"nofollow noreferrer\"><code>MappedRows&lt;F&gt;</code></a> is actually <code>MappedRows&lt;'stmt, F&gt;</code>, this type is valid only when the original SQLite statement object (having <code>'stmt</code> lifetime) outlives it \u2014 thus the compiler complains that <code>stmt</code> is dead when you return the function. </p>\n\n<p>Indeed, if the statement is dropped before we iterate on those rows, we will get garbage results. Bad!</p>\n\n<p>What we need to do is to <strong>make sure all rows are read before dropping the statement</strong>. </p>\n\n<p>You could collect the rows into a vector, thus disassociating the result from the statement, at the cost of storing everything in memory:</p>\n\n<pre><code>//                    \u2193~~~~~~~~~~~~~~~~~~~~~~~~~\npub fn dump(&amp;self) -&gt; Vec&lt;Result&lt;DateTime&lt;UTC&gt;&gt;&gt; {\n    ..\n    let it = stmt.query_map(&amp;[], c).unwrap();\n    it.collect()\n}\n</code></pre>\n\n<p>Or invert the control, let <code>dump</code> accept a function, which <code>dump</code> will call while keeping <code>stmt</code> alive, at the cost of making the calling syntax weird:</p>\n\n<pre><code>//                    \u2193~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\npub fn dump&lt;F&gt;(&amp;self, mut f: F) where F: FnMut(Result&lt;DateTime&lt;UTC&gt;&gt;) {\n    ...\n    for res in stmt.query_map(&amp;[], c).unwrap() {\n        f(res);\n    }\n}\n\nx.dump(|res| println!(\"{:?}\", res));\n</code></pre>\n\n<p>Or split <code>dump</code> into two functions, and let the caller keep the statement alive, at the cost of exposing an intermediate construct to the user:</p>\n\n<pre><code>#![feature(conservative_impl_trait)]\n\npub fn create_dump_statement(&amp;self) -&gt; Statement {\n    self.conn.prepare(\"SELECT '2017-03-01 12:34:56'\").unwrap()\n}\n\npub fn dump&lt;'s&gt;(&amp;self, stmt: &amp;'s mut Statement) -&gt; impl Iterator&lt;Item = Result&lt;DateTime&lt;UTC&gt;&gt;&gt; + 's {\n    stmt.query_map(&amp;[], |row| row.get(0)).unwrap()\n}\n\n...\n\nlet mut stmt = x.create_dump_statement();\nfor res in x.dump(&amp;mut stmt) {\n    println!(\"{:?}\", res);\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 143, "user_id": 5673010, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/eb78390568a1c374588c01c63253cd07?s=128&d=identicon&r=PG&f=1", "display_name": "dippi", "link": "https://stackoverflow.com/users/5673010/dippi"}, "is_accepted": false, "score": 1, "last_activity_date": 1488623934, "last_edit_date": 1488623934, "creation_date": 1488623478, "answer_id": 42594922, "question_id": 42594102, "link": "https://stackoverflow.com/questions/42594102/return-type-for-rusqlite-mappedrows/42594922#42594922", "title": "Return type for rusqlite MappedRows", "body": "<p>The issue here is that you are implicitly trying to return a closure, so to find explanations and examples you can search for that.</p>\n\n<p>The use of the generic <code>&lt;F&gt;</code> means that the caller decides the concrete type of <code>F</code> and <strong>not</strong> the function <code>dump</code>.</p>\n\n<p>What you would like to achieve instead requires the long awaited feature <code>impl trait</code>.</p>\n"}], "owner": {"reputation": 12061, "user_id": 87191, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/5a32c1cfc71ebf97967c5d6fd2cf2cf2?s=128&d=identicon&r=PG", "display_name": "simao", "link": "https://stackoverflow.com/users/87191/simao"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 932, "favorite_count": 0, "accepted_answer_id": 42594912, "answer_count": 2, "score": 2, "last_activity_date": 1488640485, "creation_date": 1488617909, "last_edit_date": 1488640485, "question_id": 42594102, "link": "https://stackoverflow.com/questions/42594102/return-type-for-rusqlite-mappedrows", "title": "Return type for rusqlite MappedRows", "body": "<p>I am trying to write a method that returns a <code>rusqlite::MappedRows</code>:</p>\n\n<pre><code>pub fn dump&lt;F&gt;(&amp;self) -&gt; MappedRows&lt;F&gt;\n    where F: FnMut(&amp;Row) -&gt; DateTime&lt;UTC&gt;\n{\n    let mut stmt =\n        self.conn.prepare(\"SELECT created_at FROM work ORDER BY created_at ASC\").unwrap();\n\n    let c: F = |row: &amp;Row| {\n        let created_at: DateTime&lt;UTC&gt; = row.get(0);\n        created_at\n    };\n\n    stmt.query_map(&amp;[], c).unwrap()\n}\n</code></pre>\n\n<p>I am getting stuck on a compiler error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:70:20\n   |\n70 |           let c: F = |row: &amp;Row| {\n   |  ____________________^ starting here...\n71 | |             let created_at: DateTime&lt;UTC&gt;  = row.get(0);\n72 | |             created_at\n73 | |         };\n   | |_________^ ...ending here: expected type parameter, found closure\n   |\n   = note: expected type `F`\n   = note:    found type `[closure@src/main.rs:70:20: 73:10]`\n</code></pre>\n\n<p>What am I doing wrong here?</p>\n\n<p>I tried passing the closure directly to <code>query_map</code> but I get the same compiler error.</p>\n"}, {"tags": ["rust", "rust-cargo"], "answers": [{"comments": [{"owner": {"reputation": 463, "user_id": 5956418, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/c1e4d59c950208e2ebb83fc021f2278d?s=128&d=identicon&r=PG&f=1", "display_name": "Qoros", "link": "https://stackoverflow.com/users/5956418/qoros"}, "edited": false, "score": 0, "creation_date": 1488608260, "post_id": 42592768, "comment_id": 72317227, "body": "Thanks, very great!"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 3, "last_activity_date": 1488607696, "creation_date": 1488607696, "answer_id": 42592768, "question_id": 42592285, "link": "https://stackoverflow.com/questions/42592285/how-to-load-rust-compiler-plugins-without-modifying-the-source-code/42592768#42592768", "title": "How to load Rust compiler plugins without modifying the source code?", "body": "<p><code>rustc</code> has a command-line parameter for loading additional plugins: <code>-Z extra-plugins=&lt;plugins&gt;</code>. However, this option also requires that the path to the compiled plugin library be passed to the compiler. This is done automatically if the plugin library is declared as a dependency in Cargo.toml. If it's not in Cargo.toml, then you can compile it independently and reference it manually with <code>--extern my_plugin=/path/to/plugin.rlib</code>, in addition to the <code>-Z extra-plugins=&lt;plugins&gt;</code> option.</p>\n\n<p>There's another option. <a href=\"https://github.com/Manishearth/rust-clippy\" rel=\"nofollow noreferrer\">Clippy</a>, a large collection of general lints for Rust, provides a program that can be invoked as <code>cargo clippy</code>. That program basically acts as a fake <code>rustc</code>, implementing a compiler frontend (using internal crates used by <code>rustc</code>) that loads Clippy directly into the compiler's plugin registry (for the main project only, not for the project's dependencies). <a href=\"https://github.com/Manishearth/rust-clippy/blob/master/src/main.rs\" rel=\"nofollow noreferrer\">You can see the code on GitHub (licensed under MPLv2).</a> The advantage of this approach is that you don't have to give a path to the plugin, because the plugin is built in the frontend. This makes it very convenient to use for the plugin's users. The disadvantage is that such a program relies on unstable compiler internals. This means that your program can stop compiling at any time due to a breaking change in <code>rustc</code>'s unstable API.</p>\n"}], "owner": {"reputation": 463, "user_id": 5956418, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/c1e4d59c950208e2ebb83fc021f2278d?s=128&d=identicon&r=PG&f=1", "display_name": "Qoros", "link": "https://stackoverflow.com/users/5956418/qoros"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 290, "favorite_count": 0, "answer_count": 1, "score": 2, "last_activity_date": 1488639812, "creation_date": 1488603531, "last_edit_date": 1488639812, "question_id": 42592285, "link": "https://stackoverflow.com/questions/42592285/how-to-load-rust-compiler-plugins-without-modifying-the-source-code", "title": "How to load Rust compiler plugins without modifying the source code?", "body": "<p>Rust provides various ways to write plugins. To extend checks on Rust code, it allows developer to write <a href=\"https://doc.rust-lang.org/book/compiler-plugins.html\" rel=\"nofollow noreferrer\">Lint Plugins</a>. A typical way to use the plugin is to add a line to the source code indicating the use of this plugin:</p>\n\n<pre><code>#![plugin(myplugin)]\n</code></pre>\n\n<p>You also need to edit the <code>Cargo.toml</code> file to include your plugin project in the <code>dependencies</code> section:</p>\n\n<pre><code>myplugin = {path = \"/path/to/myproject\"}\n</code></pre>\n\n<p>However, if you want to analyze big projects, these modifications seem to be troubling, I wonder if <code>cargo build</code> or <code>rustc</code> provides any way to load my plugins without modifying the source code.</p>\n"}, {"tags": ["error-handling", "rust"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1488560133, "post_id": 42584368, "comment_id": 72301249, "body": "I suppose you already read the <a href=\"https://doc.rust-lang.org/stable/book/error-handling.html#defining-your-own-error-type\" rel=\"nofollow noreferrer\">relevant section from the book</a>. :) But given the multiple error boilerplate crates out there, answers might wish to expand on more than just this entry."}, {"owner": {"reputation": 16556, "user_id": 839689, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/eed3ee2db841be15bdb120f3ff38f02e?s=128&d=identicon&r=PG", "display_name": "Nayuki", "link": "https://stackoverflow.com/users/839689/nayuki"}, "edited": false, "score": 0, "creation_date": 1540517114, "post_id": 42584368, "comment_id": 92904872, "body": "<a href=\"https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/define_error_type.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/rust-by-example/error/multiple_error_types&zwnj;&#8203;/&hellip;</a>"}], "answers": [{"tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 1, "last_activity_date": 1488560419, "creation_date": 1488560419, "answer_id": 42584586, "question_id": 42584368, "link": "https://stackoverflow.com/questions/42584368/how-do-you-define-custom-error-types-in-rust/42584586#42584586", "title": "How do you define custom `Error` types in Rust?", "body": "<blockquote>\n  <p>Is that the most idiomatic way to go about it? And how do I implement the Error trait?</p>\n</blockquote>\n\n<p>It's a common way, yes. \"idiomatic\" depends on how strongly typed you want your errors to be, and how you want this to interoperate with other things.</p>\n\n<blockquote>\n  <p>And how do I implement the Error trait?</p>\n</blockquote>\n\n<p>Strictly speaking, you don't need to here. You might for interoperability with other things that require <code>Error</code>, but since you've defined your return type as this enum directly, your code should work without it.</p>\n"}, {"comments": [{"owner": {"reputation": 28407, "user_id": 109618, "user_type": "registered", "accept_rate": 84, "profile_image": "https://www.gravatar.com/avatar/84a4143803eafa1966191c604864a7b5?s=128&d=identicon&r=PG", "display_name": "David J.", "link": "https://stackoverflow.com/users/109618/david-j"}, "edited": false, "score": 2, "creation_date": 1536511287, "post_id": 42584607, "comment_id": 91441257, "body": "Thanks for another detailed, helpful answer -- especially the suggestion about starting by rolling-your-own and then moving to some crates to reduce boilerplate. Much appreciated!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 68, "last_activity_date": 1582032113, "last_edit_date": 1582032113, "creation_date": 1488560482, "answer_id": 42584607, "question_id": 42584368, "link": "https://stackoverflow.com/questions/42584368/how-do-you-define-custom-error-types-in-rust/42584607#42584607", "title": "How do you define custom `Error` types in Rust?", "body": "<p>You implement <a href=\"https://doc.rust-lang.org/std/error/trait.Error.html\" rel=\"noreferrer\"><code>Error</code></a> exactly like you would <a href=\"https://doc.rust-lang.org/stable/book/ch10-02-traits.html\" rel=\"noreferrer\">any other trait</a>; there's nothing extremely special about it:</p>\n\n<pre><code>pub trait Error: Debug + Display {\n    fn description(&amp;self) -&gt; &amp;str { /* ... */ }\n    fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { /* ... */ }\n    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + 'static)&gt; { /* ... */ }\n}\n</code></pre>\n\n<p><code>description</code>, <code>cause</code>, and <code>source</code> all have default implementations<sup>1</sup>, and your type must also implement <code>Debug</code> and <code>Display</code>, as they are supertraits.</p>\n\n<pre><code>use std::{error::Error, fmt};\n\n#[derive(Debug)]\nstruct Thing;\n\nimpl Error for Thing {}\n\nimpl fmt::Display for Thing {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Oh no, something bad went down\")\n    }\n}\n</code></pre>\n\n<p>Of course, what <code>Thing</code> contains, and thus the implementations of the methods, is highly dependent on what kind of errors you wish to have. Perhaps you want to include a filename in there, or maybe an integer of some kind. Perhaps you want to have an <code>enum</code> instead of a <code>struct</code> to represent multiple types of errors.</p>\n\n<p>If you end up wrapping existing errors, then I'd recommend implementing <code>From</code> to convert between those errors and your error. That allows you to use <code>try!</code> and <code>?</code> and have a pretty ergonomic solution.</p>\n\n<blockquote>\n  <p>Is that the most idiomatic way to go about it?</p>\n</blockquote>\n\n<p>Idiomatically, I'd say that a library will have a small (maybe 1-3) number of primary error types that are exposed. These are likely to be enumerations of other error types. This allows consumers of your crate to not deal with an explosion of types. Of course, this depends on your API and whether it makes sense to lump some errors together or not.</p>\n\n<p>Another thing to note is that when you choose to embed data in the error, that can have wide-reaching consequences. For example, the standard library doesn't include a filename in file-related errors. Doing so would add overhead to every file error. The caller of the method usually has the relevant context and can decide if that context needs to be added to the error or not.</p>\n\n<hr>\n\n<p>I'd recommend doing this by hand a few times to see how all the pieces go together. Once you have that, you will grow tired of doing it manually. Then you can check out crates which provide macros to reduce the boilerplate:</p>\n\n<ul>\n<li><a href=\"https://crates.io/crates/error-chain\" rel=\"noreferrer\">error-chain</a></li>\n<li><a href=\"https://crates.io/crates/failure\" rel=\"noreferrer\">failure</a> </li>\n<li><a href=\"https://crates.io/crates/quick-error\" rel=\"noreferrer\">quick-error</a></li>\n<li><a href=\"https://crates.io/crates/anyhow\" rel=\"noreferrer\">Anyhow</a></li>\n<li><a href=\"https://crates.io/crates/snafu\" rel=\"noreferrer\">SNAFU</a></li>\n</ul>\n\n<p>My preferred library is SNAFU (because I wrote it), so here's an example of using that with your original error type:</p>\n\n<pre><code>// This example uses the simpler syntax supported in Rust 1.34\nuse snafu::Snafu; // 0.2.0\n\n#[derive(Debug, Snafu)]\nenum MyError {\n    #[snafu(display(\"Refrob the Gizmo\"))]\n    Gizmo,\n    #[snafu(display(\"The widget '{}' could not be found\", widget_name))]\n    WidgetNotFound { widget_name: String }\n}\n\nfn foo() -&gt; Result&lt;(), MyError&gt; {\n    WidgetNotFound { widget_name: \"Quux\" }.fail()\n}\n\nfn main() {\n    if let Err(e) = foo() {\n        println!(\"{}\", e);\n        // The widget 'Quux' could not be found\n    }\n}\n</code></pre>\n\n<p>Note I've removed the redundant <code>Error</code> suffix on each enum value. It's also common to just call the type <code>Error</code> and allow the consumer to prefix the type (<code>mycrate::Error</code>) or rename it on import (<code>use mycrate::Error as FooError</code>).</p>\n\n<hr>\n\n<p><sup>1</sup> Before <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md\" rel=\"noreferrer\">RFC 2504</a> was implemented, <code>description</code> was a required method.</p>\n"}, {"tags": [], "owner": {"reputation": 5038, "user_id": 3579309, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/Wn5ES.jpg?s=128&g=1", "display_name": "lovasoa", "link": "https://stackoverflow.com/users/3579309/lovasoa"}, "is_accepted": false, "score": 10, "last_activity_date": 1547742820, "last_edit_date": 1547742820, "creation_date": 1541205138, "answer_id": 53127353, "question_id": 42584368, "link": "https://stackoverflow.com/questions/42584368/how-do-you-define-custom-error-types-in-rust/53127353#53127353", "title": "How do you define custom `Error` types in Rust?", "body": "<p>The crate <a href=\"https://crates.io/crates/custom_error\" rel=\"noreferrer\">custom_error</a> allows the definition of custom error types with less boilerplate than what was proposed above:</p>\n\n<pre><code>custom_error!{MyError\n     Io{source: io::Error}             = \"input/output error\",\n     WidgetNotFoundError{name: String} = \"could not find widget '{name}'\",\n     GizmoError                        = \"A gizmo error occurred!\"\n}\n</code></pre>\n\n<p>Disclaimer: I am the author of this crate.</p>\n"}], "owner": {"reputation": 24273, "user_id": 525872, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/4d6f74711436cfe252bf4fc8f3cf4971?s=128&d=identicon&r=PG", "display_name": "Jo Liss", "link": "https://stackoverflow.com/users/525872/jo-liss"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 20974, "favorite_count": 13, "accepted_answer_id": 42584607, "answer_count": 3, "score": 51, "last_activity_date": 1582032113, "creation_date": 1488559775, "last_edit_date": 1488559992, "question_id": 42584368, "link": "https://stackoverflow.com/questions/42584368/how-do-you-define-custom-error-types-in-rust", "title": "How do you define custom `Error` types in Rust?", "body": "<p>I'm writing a function that could return several one of several different errors.</p>\n\n<pre><code>fn foo(...) -&gt; Result&lt;..., MyError&gt; {}\n</code></pre>\n\n<p>I'll probably need to define my own error type to represent such errors. I'm presuming it would be an <code>enum</code> of possible errors, with some of the <code>enum</code> variants having diagnostic data attached to them:</p>\n\n<pre><code>enum MyError {\n    GizmoError,\n    WidgetNotFoundError(widget_name: String)\n}\n</code></pre>\n\n<p>Is that the most idiomatic way to go about it? And how do I implement the <code>Error</code> trait?</p>\n"}, {"tags": ["rust", "lifetime", "associated-types"], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 4, "last_activity_date": 1488556454, "last_edit_date": 1488556454, "creation_date": 1488556152, "answer_id": 42583137, "question_id": 42583027, "link": "https://stackoverflow.com/questions/42583027/define-a-trait-with-a-function-that-returns-an-associated-type-with-the-same-lif/42583137#42583137", "title": "Define a trait with a function that returns an associated type with the same lifetime as one parameter", "body": "<p>This is currently impossible, even in nightly Rust.</p>\n\n<p>This requires some form of Higher Kinded Types (HKT), and the current approach envisaged is dubbed Associated Type Constructor (ATC).</p>\n\n<p>The main motivation for introducing ATC is actually this very usecase.</p>\n\n<p>With ATC, the syntax would be:</p>\n\n<pre><code>trait Trait {\n    type Output&lt;'a&gt;;\n    fn get_output&lt;'a&gt;(&amp;self, input: &amp;'a i32) -&gt; Self::Output&lt;'a&gt;;\n}\n</code></pre>\n\n<p><em>Note: if you wish to learn about ATCs, see <a href=\"http://smallcultfollowing.com/babysteps/blog/2016/11/02/associated-type-constructors-part-1-basic-concepts-and-introduction/\" rel=\"nofollow noreferrer\">Niko's series of articles</a>.</em></p>\n\n<hr>\n\n<p>For the particular example you have, you can work around this with HRTB (Higher Ranked Traits Bounds) as noted by Shepmaster:</p>\n\n<pre><code>fn f&lt;T&gt;(var: &amp;T)\n    where for&lt;'a&gt; T: Trait&lt;'a&gt;\n{ ... }\n</code></pre>\n\n<p>however this is fairly limited (notably, limited to trait bounds).</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 3, "last_activity_date": 1488556174, "last_edit_date": 1495541369, "creation_date": 1488556174, "answer_id": 42583144, "question_id": 42583027, "link": "https://stackoverflow.com/questions/42583027/define-a-trait-with-a-function-that-returns-an-associated-type-with-the-same-lif/42583144#42583144", "title": "Define a trait with a function that returns an associated type with the same lifetime as one parameter", "body": "<p>This requires using <a href=\"https://doc.rust-lang.org/nomicon/hrtb.html\" rel=\"nofollow noreferrer\"><em>higher-ranked trait bounds</em></a>:</p>\n\n<pre><code>fn f&lt;T&gt;(var: &amp;T)\n    where for&lt;'a&gt; T: Trait&lt;'a&gt;\n{\n    let input = 0i32;\n    let output = var.get_output(&amp;input);\n}\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/35592750/155423\">How does for&lt;&gt; syntax differ from a regular lifetime bound?</a></li>\n</ul>\n"}], "owner": {"reputation": 23991, "user_id": 300805, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/16633fb54ed0f92814a6e07aa536fa0c?s=128&d=identicon&r=PG", "display_name": "peoro", "link": "https://stackoverflow.com/users/300805/peoro"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 298, "favorite_count": 0, "accepted_answer_id": 42583137, "answer_count": 2, "score": 4, "last_activity_date": 1488556454, "creation_date": 1488555833, "last_edit_date": 1488556088, "question_id": 42583027, "link": "https://stackoverflow.com/questions/42583027/define-a-trait-with-a-function-that-returns-an-associated-type-with-the-same-lif", "title": "Define a trait with a function that returns an associated type with the same lifetime as one parameter", "body": "<p>I'm trying to define a trait with a function that returns an associated type with the same lifetime as one parameter.</p>\n\n<p>Conceptually something like the following (which doesn't work: <code>lifetime parameter not allowed on this type [Self::Output]</code>):</p>\n\n<pre><code>trait Trait {\n    type Output;\n    fn get_output&lt;'a&gt;(&amp;self, input: &amp;'a i32) -&gt; Self::Output&lt;'a&gt;;\n}\n</code></pre>\n\n<p>I found several questions about lifetimes for associated types on Stack Overflow and the Internet, but none seem to help. Some suggested defining the lifetime on the whole trait:</p>\n\n<pre><code>trait Trait&lt;'a&gt; {\n    type Output;\n    fn get_output(&amp;self, input: &amp;'a i32) -&gt; Self::Output;\n}\n</code></pre>\n\n<p>but this doesn't work either: it compiles, but then the following function fails to compile:</p>\n\n<pre><code>fn f&lt;'a, T&gt;(var: &amp;T)\n    where T: Trait&lt;'a&gt;\n{\n    let input = 0i32;\n    let output = var.get_output(&amp;input);\n}\n</code></pre>\n\n<p>giving an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `input` does not live long enough\n  --&gt; &lt;anon&gt;:9:35\n   |\n   |     let output = var.get_output( &amp;input );\n   |                                   ^^^^^ does not live long enough\n   | }\n   | - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the lifetime 'a as defined on the body at 7:48...\n  --&gt; &lt;anon&gt;:7:49\n   |\n   |   fn f&lt;'a, T&gt;( var : &amp;T ) where T : Trait&lt;'a&gt; {\n   |  _________________________________________________^ starting here...\n   | |     let input = 0i32;\n   | |     let output = var.get_output( &amp;input );\n   | | }\n   | |_^ ...ending here\n</code></pre>\n\n<p>How should I define the trait so that it behaves the way I want?</p>\n"}, {"tags": ["time", "rust", "rust-chrono"], "answers": [{"comments": [{"owner": {"reputation": 1611, "user_id": 7526319, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/aUMpl.jpg?s=128&g=1", "display_name": "Sajuuk", "link": "https://stackoverflow.com/users/7526319/sajuuk"}, "edited": false, "score": 2, "creation_date": 1488527035, "post_id": 42573159, "comment_id": 72279796, "body": "I managed to find a similar usage in <a href=\"https://docs.rs/chrono/%2A/src/chrono/datetime.rs.html#42\" rel=\"nofollow noreferrer\">thisplace</a>, but apparently your answer is more concise and friendly. thank you!"}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": true, "score": 9, "last_activity_date": 1520995377, "last_edit_date": 1520995377, "creation_date": 1488526505, "answer_id": 42573159, "question_id": 42572107, "link": "https://stackoverflow.com/questions/42572107/how-to-convert-unix-time-time-since-the-epoch-to-standard-date-and-time/42573159#42573159", "title": "How to convert Unix time / time since the epoch to standard date and time?", "body": "<p>You first need to create a <code>NaiveDateTime</code> and then use it to create a <code>DateTime</code> again:</p>\n\n<pre><code>extern crate chrono;\nuse chrono::prelude::*;\n\nfn main() {\n    let datetime = Utc.ymd(2020, 1, 1).and_hms(0, 0, 0);\n    let timestamp = datetime.timestamp();\n    let naive_datetime = NaiveDateTime::from_timestamp(timestamp, 0);\n    let datetime_again: DateTime&lt;Utc&gt; = DateTime::from_utc(naive_datetime, Utc);\n\n    println!(\"{}\", datetime_again);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=d8a143e54bce5fd039fa52773a1855c6&amp;version=stable\" rel=\"noreferrer\">Playground</a></p>\n"}, {"tags": [], "owner": {"reputation": 5700, "user_id": 4934640, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/2f69527ae459cbbda0ab5c2e08686a50?s=128&d=identicon&r=PG&f=1", "display_name": "user", "link": "https://stackoverflow.com/users/4934640/user"}, "is_accepted": false, "score": 1, "last_activity_date": 1588042324, "creation_date": 1588042324, "answer_id": 61471835, "question_id": 42572107, "link": "https://stackoverflow.com/questions/42572107/how-to-convert-unix-time-time-since-the-epoch-to-standard-date-and-time/61471835#61471835", "title": "How to convert Unix time / time since the epoch to standard date and time?", "body": "<p>You can use the <a href=\"https://github.com/zeta12ti/parse_duration/\" rel=\"nofollow noreferrer\"><code>parse_duration</code></a> crate: <a href=\"https://docs.rs/parse_duration/2.1.0/parse_duration/\" rel=\"nofollow noreferrer\">https://docs.rs/parse_duration/2.1.0/parse_duration/</a></p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>extern crate parse_duration;\nuse parse_duration::parse;\nuse std::time::Duration;\n\nfn main() {\n    // 1587971749 seconds since UNIX_EPOCH\n    assert_eq!(parse(\"1587971749\"), Ok(Duration::new(1587971749, 0)));\n\n    // One hour less than a day\n    assert_eq!(parse(\"1 day -1 hour\"), Ok(Duration::new(82_800, 0)));\n\n    // Using exponents\n    assert_eq!(\n        parse(\"1.26e-1 days\"),\n        Ok(Duration::new(10_886, 400_000_000))\n    );\n\n    // Extra things will be ignored\n    assert_eq!(\n        parse(\"Duration: 1 hour, 15 minutes and 29 seconds\"),\n        Ok(Duration::new(4529, 0))\n    );\n}\n</code></pre>\n"}], "owner": {"reputation": 1611, "user_id": 7526319, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/aUMpl.jpg?s=128&g=1", "display_name": "Sajuuk", "link": "https://stackoverflow.com/users/7526319/sajuuk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3750, "favorite_count": 1, "accepted_answer_id": 42573159, "answer_count": 2, "score": 13, "last_activity_date": 1588042324, "creation_date": 1488522540, "last_edit_date": 1524929467, "question_id": 42572107, "link": "https://stackoverflow.com/questions/42572107/how-to-convert-unix-time-time-since-the-epoch-to-standard-date-and-time", "title": "How to convert Unix time / time since the epoch to standard date and time?", "body": "<p>I'm using the chrono crate; after some digging I discovered the <code>DateTime</code> type has a function <code>timestamp()</code> which could generate epoch time of type <code>i64</code>. However, I couldn't find out how to convert it back to <code>DateTime</code>.</p>\n\n<pre><code>extern crate chrono;\nuse chrono::*;\n\nfn main() {\n    let date = chrono::UTC.ymd(2020, 1, 1).and_hms(0, 0, 0);\n    println!(\"{}\", start_date.timestamp());\n    // ...how to convert it back?\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 1, "creation_date": 1488491704, "post_id": 42566669, "comment_id": 72267400, "body": "<a href=\"https://github.com/rust-lang/rust/issues/21232\" rel=\"nofollow noreferrer\">It is a known issue</a> that doesn&#39;t seem to have a conclusion as of yet."}, {"owner": {"reputation": 8378, "user_id": 124538, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/82159aeb57c52bc0c7bfe6e9c832c3ea?s=128&d=identicon&r=PG", "display_name": "Wesley Wiser", "link": "https://stackoverflow.com/users/124538/wesley-wiser"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 1, "creation_date": 1488492730, "post_id": 42566669, "comment_id": 72267876, "body": "Ah, this is a duplicate. I tried searching before posting but couldn&#39;t find anything."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1488493162, "post_id": 42566669, "comment_id": 72268074, "body": "Ah, very nice. I knew this was asked but couldn&#39;t find the duplicate either, so this will be a very nice signpost."}], "owner": {"reputation": 8378, "user_id": 124538, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/82159aeb57c52bc0c7bfe6e9c832c3ea?s=128&d=identicon&r=PG", "display_name": "Wesley Wiser", "link": "https://stackoverflow.com/users/124538/wesley-wiser"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 47, "favorite_count": 0, "closed_date": 1488493108, "answer_count": 0, "score": 2, "last_activity_date": 1488492161, "creation_date": 1488491402, "last_edit_date": 1488492161, "question_id": 42566669, "link": "https://stackoverflow.com/questions/42566669/why-is-this-field-mutation-allowed-after-drop", "closed_reason": "Duplicate", "title": "Why is this field mutation allowed after drop?", "body": "<p>Why does the Rust compiler allow the field <code>A.b</code> to be mutated after the the value <code>a</code> has been moved into <code>drop</code>?</p>\n\n<pre><code>struct A {\n    b: usize\n}\n\nfn main() {\n    let mut a = A { b: 0 };\n\n    drop(a);\n\n    a.b = 1; // &lt;---- Why is this allowed?\n}\n</code></pre>\n\n<p>Shouldn't the compiler give an error on that line? </p>\n\n<p>(The compiler does give an error if you attempt to use the value after calling <code>drop()</code>)</p>\n\n<p><strong>Further Investigation:</strong>\nI thought perhaps this was just because the compiler knew that the write was \"dead\" but it seems to be generating code to actually perform the write. The <code>MIR</code> for <code>main()</code> contains this:</p>\n\n<pre><code>bb0: {\n    StorageLive(_1);                 // scope 0 at &lt;anon&gt;:6:9: 6:14\n    _1 = A { b: const 0usize };      // scope 0 at &lt;anon&gt;:6:17: 6:27\n    StorageLive(_3);                 // scope 1 at &lt;anon&gt;:8:10: 8:11\n    _3 = _1;                         // scope 1 at &lt;anon&gt;:8:10: 8:11\n    _2 = std::mem::drop::&lt;A&gt;(_3) -&gt; bb1; // scope 1 at &lt;anon&gt;:8:5: 8:12\n}\n\nbb1: {\n    StorageDead(_3);                 // scope 1 at &lt;anon&gt;:8:13: 8:13\n    (_1.0: usize) = const 1usize;    // scope 1 at &lt;anon&gt;:10:5: 10:12\n    _0 = ();                         // scope 1 at &lt;anon&gt;:5:11: 11:2\n    StorageDead(_1);                 // scope 0 at &lt;anon&gt;:11:2: 11:2\n    return;                          // scope 0 at &lt;anon&gt;:11:2: 11:2\n}\n</code></pre>\n\n<p>(notice the <code>(_1.0: usize) = const 1usize;</code> line in <code>bb1</code>)</p>\n\n<p>and a Debug build contains this assembly:</p>\n\n<pre><code>example::main:\n    push    rbp\n    mov     rbp, rsp\n    sub     rsp, 32\n    mov     qword ptr [rbp - 16], 0\n    mov     qword ptr [rbp - 24], 0\n    mov     qword ptr [rbp - 32], 0\n    mov     rdi, qword ptr [rbp - 32]\n    call    core::mem::drop\n    mov     qword ptr [rbp - 16], 1 # &lt;-- Notice this write\n    add     rsp, 32\n    pop     rbp\n    ret\n</code></pre>\n"}, {"tags": ["casting", "rust", "traits"], "comments": [{"owner": {"reputation": 5181, "user_id": 3257165, "user_type": "registered", "accept_rate": 44, "profile_image": "https://www.gravatar.com/avatar/b8fb0f063a874c9b72694597a2246541?s=128&d=identicon&r=PG&f=1", "display_name": "Georg", "link": "https://stackoverflow.com/users/3257165/georg"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488493393, "post_id": 42566245, "comment_id": 72268172, "body": "@Shepmaster Thanks for pointing out my mistake to forget the braces when creating a new object. I do not get the error regarding the trait bound that <code>A</code> should be <code>Sized</code>, though."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1488493550, "post_id": 42566245, "comment_id": 72268241, "body": "Perhaps a duplicate of <a href=\"http://stackoverflow.com/q/28632968/155423\">Why doesn&#39;t Rust support trait object upcasting?</a>, or <a href=\"http://stackoverflow.com/q/40024093/155423\">Downcast traits inside Rc for AST manipulation</a>. Note that the term you are probably searching for is &quot;downcast&quot; or &quot;upcast&quot;, depending on direction."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488493589, "post_id": 42566245, "comment_id": 72268259, "body": "FWIW, <code>struct Impl;</code> allows for <code>let a = Impl</code>. The lack of braces on the definition has meaning."}], "owner": {"reputation": 5181, "user_id": 3257165, "user_type": "registered", "accept_rate": 44, "profile_image": "https://www.gravatar.com/avatar/b8fb0f063a874c9b72694597a2246541?s=128&d=identicon&r=PG&f=1", "display_name": "Georg", "link": "https://stackoverflow.com/users/3257165/georg"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 245, "favorite_count": 0, "closed_date": 1583935383, "answer_count": 0, "score": 3, "last_activity_date": 1614961309, "creation_date": 1488489824, "last_edit_date": 1488493254, "question_id": 42566245, "link": "https://stackoverflow.com/questions/42566245/how-to-safely-cast-a-rcboxa-into-rcboxb-if-trait-b-a", "closed_reason": "Duplicate", "title": "How to safely cast a Rc&lt;Box&lt;A&gt;&gt; into Rc&lt;Box&lt;B&gt;&gt; if trait B : A", "body": "<p>I have a situation similar to the following:</p>\n\n<pre><code>use std::rc::Rc;\ntrait A {}\ntrait B: A {}\nstruct Impl {}\n\nimpl A for Impl {}\nimpl B for Impl {}\n</code></pre>\n\n<p>I would like to be able to cast trait objects of these traits like in the following:</p>\n\n<pre><code>fn main() {\n    let val: Rc&lt;Box&lt;A&gt;&gt; = Rc::new(Box::new(Impl {}));\n    let test: Rc&lt;Box&lt;B&gt;&gt; = val as Rc&lt;Box&lt;B&gt;&gt;;\n}\n</code></pre>\n\n<p>This gives me a compiler-error that this is a non-scalar cast. I guess I am doing the wrong sort of cast, but I do not see how this is supported. Further, I would like the cast to be safe, i.e. returning me an <code>Option&lt;Rc&lt;Box&lt;B&gt;&gt;</code>. Is this possible or is the dynamic dispatch implemented such that trait objects cannot be converted between traits?</p>\n\n<p><em>Edit:</em> I forgot to say, I am using the nightly version, in case this should matter.</p>\n"}, {"tags": ["vector", "rust"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1488548768, "post_id": 42565964, "comment_id": 72293521, "body": "Do know that you can declare a moved function argument as <code>mut</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1488602832, "post_id": 42565964, "comment_id": 72316125, "body": "@FrancisGagn&#233; struct field re-initialization after drop / move is strange in general. See <a href=\"http://stackoverflow.com/q/42566669/155423\">this recent question and the linked duplicate</a>"}], "answers": [{"comments": [{"owner": {"reputation": 21, "user_id": 6195233, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9bc8681f2d83326b46859174f3e5e85d?s=128&d=identicon&r=PG&f=1", "display_name": "dandyvica", "link": "https://stackoverflow.com/users/6195233/dandyvica"}, "edited": false, "score": 0, "creation_date": 1488645379, "post_id": 42582004, "comment_id": 72327867, "body": "Thanks for your comment, I was not (still) aware of the <b>mut</b> keyword in the fn argument. I wanted to make <b>origin</b> &amp; <b>p1</b> mutable in order to play with them afterwards."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 21, "user_id": 6195233, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9bc8681f2d83326b46859174f3e5e85d?s=128&d=identicon&r=PG&f=1", "display_name": "dandyvica", "link": "https://stackoverflow.com/users/6195233/dandyvica"}, "edited": false, "score": 0, "creation_date": 1488645454, "post_id": 42582004, "comment_id": 72327884, "body": "@Coeurdanis There is no afterwards; once they&#39;ve been moved, they are gone from the caller."}, {"owner": {"reputation": 21, "user_id": 6195233, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9bc8681f2d83326b46859174f3e5e85d?s=128&d=identicon&r=PG&f=1", "display_name": "dandyvica", "link": "https://stackoverflow.com/users/6195233/dandyvica"}, "edited": false, "score": 0, "creation_date": 1488748059, "post_id": 42582004, "comment_id": 72356955, "body": "Yep, Rust is a mindset shift: when using bindings and not refs, I have to keep in mind that once a fn grabs a value, it&#39;s gone for the caller. It a definitive move."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1488555569, "last_edit_date": 1488555569, "creation_date": 1488552862, "answer_id": 42582004, "question_id": 42565964, "link": "https://stackoverflow.com/questions/42565964/how-do-i-write-a-function-that-adds-an-element-to-a-vector-allowing-the-element/42582004#42582004", "title": "How do I write a function that adds an element to a vector, allowing the element to be changed before insertion?", "body": "<p>Let's read the error messages together:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:10:12\n   |\n10 |     v.push(elem);\n   |            ^^^^ expected struct `Point`, found &amp;Point\n   |\n   = note: expected type `Point`\n   = note:    found type `&amp;Point`\n</code></pre>\n\n<p>The code is attempting to store a reference to a <code>Point</code> in a <code>Vec</code> that is declared to hold entire <code>Point</code>s. Since Rust is a statically- and strongly- typed language, the compiler tells you that you cannot do that. The fix is to accept a <code>Point</code> by value:</p>\n\n<pre><code>fn add_element(v: &amp;mut Vec&lt;Point&gt;, elem: Point)\n</code></pre>\n\n<p>This leads to the next error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: cannot assign to immutable field `elem.x`\n --&gt; src/main.rs:9:5\n  |\n9 |     elem.x = 0;\n  |     ^^^^^^^^^^\n</code></pre>\n\n<p>You cannot change members of <code>elem</code> because it is not marked as mutable. Mutability of a value is a property of the binding, so let's do that:</p>\n\n<pre><code>fn add_element(v: &amp;mut Vec&lt;Point&gt;, mut elem: Point)\n</code></pre>\n\n<p>Then change the calling of that function to adapt:</p>\n\n<pre><code>fn main() {\n    let origin = Point { x: 0, y: 0 };\n    let p1 = Point { x: 1, y: 1 };\n\n    let mut v = Vec::new();\n\n    add_element(&amp;mut v, origin);\n    add_element(&amp;mut v, p1);\n}\n</code></pre>\n\n<p>Note that neither <code>origin</code> nor <code>p1</code> need to be mutable because this function doesn't modify either while it owns it. It <em>transfers ownership</em> to <code>add_element</code>, which chooses to make it mutable.</p>\n\n<blockquote>\n  <p>but if I want to modify <code>elem</code>, I need to pass a (mutable?) reference</p>\n</blockquote>\n\n<p>As you can see, you can simply make the <code>elem</code> parameter mutable when transferring the entire value to the function. Since the function owns that value, it has full control over it, including choosing to make it mutable.</p>\n"}], "owner": {"reputation": 21, "user_id": 6195233, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9bc8681f2d83326b46859174f3e5e85d?s=128&d=identicon&r=PG&f=1", "display_name": "dandyvica", "link": "https://stackoverflow.com/users/6195233/dandyvica"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 712, "favorite_count": 0, "answer_count": 1, "score": 2, "last_activity_date": 1488555569, "creation_date": 1488488823, "last_edit_date": 1488553053, "question_id": 42565964, "link": "https://stackoverflow.com/questions/42565964/how-do-i-write-a-function-that-adds-an-element-to-a-vector-allowing-the-element", "title": "How do I write a function that adds an element to a vector, allowing the element to be changed before insertion?", "body": "<p>I'm trying to make a simple example involving a vector of structs to learn Rust. All examples of vectors in the Rust literature I've found only use vectors of integers.</p>\n\n<p>I want to write a function aimed at filling a vector, allowing the possibility of the element to be inserted to be changed, I can't figure out what to do. I always got a compiler <code>error[E0308]: mismatched types</code> on \nthe <code>push</code> method, because <code>elem</code> is a reference to a <code>Point</code>. So</p>\n\n<ul>\n<li><code>push()</code> needs a <code>Point</code> structure because <code>v</code> is a vector of <code>Point</code></li>\n<li>but if I want to modify <code>elem</code>, I need to pass a (mutable?) reference</li>\n</ul>\n\n<p>What is the right thing to do?</p>\n\n<pre><code>// structure used everywhere in Rust examples\n#[derive(Debug)]\nstruct Point {\n    x: i16,\n    y: i16\n}\n\nfn add_element(v: &amp;mut Vec&lt;Point&gt;, elem: &amp;Point) {\n    // modify element\n    elem.x = 0;\n\n    // add element\n    v.push(elem);\n}\n\n// this example is meant to study a vector of structs\nfn main() {\n    // declare 2 points. By default, live on the stack\n    let origin = Point {x:0, y:0};\n    println!(\"origin address\\t: {:p}\", &amp;origin);\n    let mut p1 = Point {x:1, y:1};\n    println!(\"p1 address\\t: {:p}\", &amp;p1);    \n\n    // declare a new vector of structs. Allocation is made in the heap\n    // declare mutable because we'll add elements to vector\n    let mut v: Vec&lt;Point&gt; = Vec::new();\n\n    // add points\n    add_element(&amp;mut v, &amp;origin);\n    add_element(&amp;mut v, &amp;p1);    \n\n    // change p1\n    p1.x = 2;\n    p1.y = 2;\n}\n</code></pre>\n"}, {"tags": ["c", "rust", "command-line-arguments", "ffi"], "answers": [{"tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 8, "last_activity_date": 1488522448, "last_edit_date": 1488522448, "creation_date": 1488484236, "answer_id": 42564657, "question_id": 42564449, "link": "https://stackoverflow.com/questions/42564449/is-there-a-more-idiomatic-way-to-keep-an-optional-argument-string-from-being-fre/42564657#42564657", "title": "Is there a more idiomatic way to keep an optional argument string from being freed?", "body": "<p>The problem is that your code is creating a temporary <code>CString</code> but holding on to just a pointer. The actual <code>CString</code> is dropped, while the dangling pointer is passed to the C function. To understand what's going on, it is useful to expand the pattern match to a more verbose form:</p>\n\n<pre><code>let arg_ptr = match possible_arg {\n    Some(arg) =&gt; {\n        let tmp = CString::new(arg).unwrap();\n        tmp.as_ptr()\n    } // &lt;-- tmp gets destructed here, arg_ptr is dangling\n    None =&gt; std::ptr::null(),\n};\n</code></pre>\n\n<p>Safe Rust prevents dangling pointers by only supporting pointer indirection through <em>references</em>, whose lifetimes are carefully tracked by the compiler. Any use of a reference that outlives the object is automatically rejected at compile time. But you are using raw pointers and an <code>unsafe</code> block which prevents those checks from taking place, so you need to manually ensure proper lifetimes. And indeed, the second snippet fixes the problem by creating a local variable that stores the <code>CString</code> for long enough for its value to outlive the pointer.</p>\n\n<p>The prolonged lifetime comes at the cost of an additional local variable. But fortunately it can be avoided - since you already have a local variable that holds the pointer, you can modify that to store the actual <code>CString</code>, and extract the pointer only when actually needed:</p>\n\n<pre><code>let arg_cstring = possible_arg.map(|arg| CString::new(arg).unwrap());\nunsafe {\n    print_in_c(arg_cstring.as_ref()\n               .map(|cs| cs.as_ptr())\n               .unwrap_or(std::ptr::null()));\n}\n</code></pre>\n\n<p>There are several things to notice here:</p>\n\n<ul>\n<li><code>arg_cstring</code> holds an <code>Option&lt;CString&gt;</code>, which ensures that <code>CString</code> has storage that can outlive the pointer passed to the C function;</li>\n<li><code>Option::as_ref()</code> is used to prevent <code>arg_cstring</code> from being <em>moved</em> into <code>map</code>, which would again free it before the pointer was actually used;</li>\n<li><code>Option::map()</code> is used as an alternative to pattern matching when you want to express \"do something with <code>Option</code> if <code>Some</code>, otherwise just leave it as <code>None</code>\".</li>\n<li>The pattern <code>x.as_ref().map(|x| x.as_ptr().unwrap_or(null())</code> can and probably should be moved into a utility function if it is used more than once in the program. Be careful that the function takes reference to <code>Option</code> to avoid a move.</li>\n</ul>\n"}], "owner": {"reputation": 738, "user_id": 4496839, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/050b67773c3fcf861e786289b932daeb?s=128&d=identicon&r=PG&f=1", "display_name": "Ryan1729", "link": "https://stackoverflow.com/users/4496839/ryan1729"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 206, "favorite_count": 0, "accepted_answer_id": 42564657, "answer_count": 1, "score": 3, "last_activity_date": 1488522448, "creation_date": 1488483538, "last_edit_date": 1488484315, "question_id": 42564449, "link": "https://stackoverflow.com/questions/42564449/is-there-a-more-idiomatic-way-to-keep-an-optional-argument-string-from-being-fre", "title": "Is there a more idiomatic way to keep an optional argument string from being freed?", "body": "<p>I want to take command-line arguments in a Rust program and pass them to a C function. However, these arguments are optional and the program should behave differently if no arguments are supplied. I have read the docs for <a href=\"https://doc.rust-lang.org/std/ffi/struct.CString.html#method.as_ptr\" rel=\"nofollow noreferrer\"><code>CString::as_ptr</code></a> but I had hoped that keeping a local variable containing an <code>Option</code> containing the argument, (if it exists,) would keep that <code>String</code> from being freed as in the following example. </p>\n\n<p>This Rust code:</p>\n\n<pre><code>extern crate libc;\n\nuse std::ffi::CString;\n\nextern \"C\" {\n    fn print_in_c(opt_class: *const libc::c_char) -&gt; libc::c_int;\n}\n\nfn main() {\n    let mut args = std::env::args();\n    //skip execuatble name\n    args.next();\n\n    let possible_arg = args.next();\n\n    println!(\"{:?}\", possible_arg);\n\n    let arg_ptr = match possible_arg {\n        Some(arg) =&gt; CString::new(arg).unwrap().as_ptr(),\n\n        None =&gt; std::ptr::null(),\n    };\n\n    unsafe {\n        print_in_c(arg_ptr);\n    };\n}\n</code></pre>\n\n<p>Along with this C code:</p>\n\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt;\nint\nprint_in_c(const char *bar)\n{\n  puts(\"C:\");\n  puts(bar);\n\n  return 0;\n}\n</code></pre>\n\n<p>But this didn't work.\nThe code prints out the following when passed an argument of \"foo\":</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Some(\"foo\")\nC:\n</code></pre>\n\n<p>Followed by a blank line.</p>\n\n<p>I got the program to print the correct text if I change the Rust code to the following:</p>\n\n<pre><code>extern crate libc;\n\nuse std::ffi::CString;\n\nextern \"C\" {\n    fn print_in_c(opt_class: *const libc::c_char) -&gt; libc::c_int;\n}\n\nfn main() {\n    let mut args = std::env::args();\n    //skip execuatble name\n    args.next();\n\n    let possible_arg = args.next();\n\n    println!(\"{:?}\", possible_arg);\n\n    let mut might_be_necessary = CString::new(\"\").unwrap();\n\n    let arg_ptr = match possible_arg {\n        Some(arg) =&gt; {\n            might_be_necessary = CString::new(arg).unwrap();\n            might_be_necessary.as_ptr()\n        }\n\n        None =&gt; std::ptr::null(),\n    };\n\n    unsafe {\n        print_in_c(arg_ptr);\n    };\n}\n</code></pre>\n\n<p>When run, this prints </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Some(\"foo\")\nC:\nfoo\n</code></pre>\n\n<p>as expected.</p>\n\n<p>This method technically works, but it is awkward to extend to multiple arguments and results in a compiler warning:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>warning: value assigned to `might_be_necessary` is never read\n  --&gt; src/main.rs:19:9\n   |\n19 |     let mut might_be_necessary = CString::new(\"\").unwrap();\n   |         ^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: #[warn(unused_assignments)] on by default\n</code></pre>\n\n<p>Is there a better way to do this?</p>\n"}, {"tags": ["rust", "ffi", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 1468, "user_id": 2057700, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/bc3457b0253983abc2427306e89114e1?s=128&d=identicon&r=PG&f=1", "display_name": "ianks", "link": "https://stackoverflow.com/users/2057700/ianks"}, "edited": false, "score": 0, "creation_date": 1488486366, "post_id": 42564847, "comment_id": 72264482, "body": "Ok the error makes sense now. However, I do not know how to make the parser live past the lifetime of the function. What is the best practice for doing this?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1468, "user_id": 2057700, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/bc3457b0253983abc2427306e89114e1?s=128&d=identicon&r=PG&f=1", "display_name": "ianks", "link": "https://stackoverflow.com/users/2057700/ianks"}, "edited": false, "score": 1, "creation_date": 1488496659, "post_id": 42564847, "comment_id": 72269561, "body": "@ianks the only solution to ensuring that the parser lives longer than the function call is to create the parser outside the function and then pass in the reference. By construction, the parser will live longer than the function."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1488535967, "post_id": 42564847, "comment_id": 72285064, "body": "There is another option; return the parser as well as the <code>WootheeResult</code>.  One way to do this is using <a href=\"https://crates.io/crates/owning_ref\" rel=\"nofollow noreferrer\">owning_ref</a>, which lets you return an object which behaves as a reference to <code>WootheeResult</code> but contains an owned parser."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1488553481, "post_id": 42564847, "comment_id": 72296809, "body": "@ChrisEmerson a good point, but since this is an <code>extern</code> function, I don&#39;t think that returning complex structs is going to be a great fit. Also, the function cannot mutate anything to be valid for owning_ref, which is true in this case but doesn&#39;t make sense..."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1488555687, "last_edit_date": 1495541831, "creation_date": 1488484872, "answer_id": 42564847, "question_id": 42564300, "link": "https://stackoverflow.com/questions/42564300/return-struct-with-lifetime-for-ffi/42564847#42564847", "title": "Return struct with lifetime for FFI", "body": "<p>After expanding lifetime elision, the signature of <a href=\"https://docs.rs/woothee/0.6.0/woothee/parser/struct.Parser.html#method.parse\" rel=\"nofollow noreferrer\"><code>Parser::parse</code></a> is</p>\n\n<pre><code>fn parse&lt;'a, 'b&gt;(&amp;'a self, agent: &amp;'b str) -&gt; Option&lt;WootheeResult&lt;'a&gt;&gt;\n</code></pre>\n\n<p>In words, that is:</p>\n\n<blockquote>\n  <p>Given a reference to a <code>Parser</code> and a reference to a <code>str</code>, maybe return a <code>WootheeResult</code> that contains one or more references to the <code>Parser</code> or some component of it.</p>\n</blockquote>\n\n<p>However, you immediately destroy the <code>Parser</code> when the function exits. So, no, you cannot do this because to do so would allow accessing a reference to undefined memory. Rust has prevented you from introducing a security hole into your program.</p>\n\n<p>Returning to the error message, hopefully it makes more sense now:</p>\n\n<ul>\n<li>\"<code>parser</code> does not live long enough\"</li>\n<li>\"borrowed value must be valid for the lifetime 'a\"</li>\n</ul>\n\n<hr>\n\n<p>I haven't dug into the implementation of woothee, but this signature is pretty surprising. I could understand if it returned references to the string that was parsed, but not to the <em>parser</em>. This is especially surprising as the method takes <code>&amp;self</code> \u2014 it's unlikely to be modifying the internals based on the parsing, so why would it return a reference to itself?</p>\n\n<p>Looking at the implementation of <a href=\"https://github.com/hhatto/woothee-rust/blob/fbecc94a71c184d88bd07d4b86f9499601154ccf/src/parser.rs#L113\" rel=\"nofollow noreferrer\"><code>Parser::new</code></a>, the lifetime appears to be driven from <a href=\"https://github.com/hhatto/woothee-rust/blob/fbecc94a71c184d88bd07d4b86f9499601154ccf/src/dataset.rs#L5\" rel=\"nofollow noreferrer\"><code>dataset::get_default_dataset</code></a>:</p>\n\n<pre><code>pub fn get_default_dataset&lt;'a&gt;() -&gt; HashMap&lt;&amp;'a str, WootheeResult&lt;'a&gt;&gt;\n</code></pre>\n\n<p>As stated in <a href=\"https://stackoverflow.com/q/32682876/155423\">Is there any way to return a reference to a variable created in a function?</a>, you <strong>can't</strong> return a reference to a local variable unless that local variable is <code>'static</code>. With the caveat that I haven't tried this, I'm 80% sure that the crate could be changed to return <code>'static</code> strings from <code>get_default_dataset</code>, then <code>parse</code> would be</p>\n\n<pre><code>impl&lt;'a&gt; Parser&lt;'a&gt; {\n    fn parse&lt;'b&gt;(&amp;'b self, agent: &amp;'b str) -&gt; Option&lt;WootheeResult&lt;'a&gt;&gt;\n}\n</code></pre>\n\n<p>And the <code>WootheeResult</code> would be <code>WootheeResult&lt;'static&gt;</code>, and then things would \"just work\".</p>\n"}], "owner": {"reputation": 1468, "user_id": 2057700, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/bc3457b0253983abc2427306e89114e1?s=128&d=identicon&r=PG&f=1", "display_name": "ianks", "link": "https://stackoverflow.com/users/2057700/ianks"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 612, "favorite_count": 0, "accepted_answer_id": 42564847, "answer_count": 1, "score": 2, "last_activity_date": 1488555687, "creation_date": 1488482993, "last_edit_date": 1488484529, "question_id": 42564300, "link": "https://stackoverflow.com/questions/42564300/return-struct-with-lifetime-for-ffi", "title": "Return struct with lifetime for FFI", "body": "<p>I am trying to expose a function from the <code>woothee-rust</code> crate to Ruby. To do this, I am parsing an input string and attempting to return the result as a C struct. I run into an issue where the lifetime of the parser \"does not live long enough\". I am not sure why the parser's lifetime must live past the function.</p>\n\n<pre><code>#![feature(libc)]\n#![feature(cstr_to_str)]\n#![feature(cstr_memory)]\nextern crate libc;\nextern crate woothee;\n\nuse woothee::parser::{Parser,WootheeResult};\nuse std::ffi::{CStr,CString};\n\n#[no_mangle]\npub extern fn parse&lt;'a&gt;(ua_string: *const libc::c_char) -&gt; WootheeResult&lt;'a&gt; {\n    let input = unsafe { CStr::from_ptr(ua_string) };\n    let parser = Parser::new();\n    parser.parse(input.to_str().unwrap()).unwrap()\n}\n</code></pre>\n\n<p>Here is the error I get:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `parser` does not live long enough\n  --&gt; src/lib.rs:14:5\n   |\n14 |     parser.parse(input.to_str().unwrap()).unwrap()\n   |     ^^^^^^ does not live long enough\n15 | }\n   | - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the lifetime 'a as defined on the body at 11:77...\n  --&gt; src/lib.rs:11:78\n   |\n11 |   pub extern fn parse&lt;'a&gt;(ua_string: *const libc::c_char) -&gt; WootheeResult&lt;'a&gt; {\n   |  ______________________________________________________________________________^ starting here...\n12 | |     let input = unsafe { CStr::from_ptr(ua_string) };\n13 | |     let parser = Parser::new();\n14 | |     parser.parse(input.to_str().unwrap()).unwrap()\n15 | | }\n   | |_^ ...ending here\n</code></pre>\n"}, {"tags": ["rust", "fold"], "answers": [{"comments": [{"owner": {"reputation": 627, "user_id": 3987763, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/5edbe17788bc835fa4f08ac4977e67d1?s=128&d=identicon&r=PG&f=1", "display_name": "basic_bgnr", "link": "https://stackoverflow.com/users/3987763/basic-bgnr"}, "edited": false, "score": 0, "creation_date": 1488508189, "post_id": 42562607, "comment_id": 72273139, "body": "could you explain further why the original code was giving error? There&#39;s always a solution using clone/copy or using into_iter(), but can it be solved using references only"}, {"owner": {"reputation": 33, "user_id": 7648395, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cbc8bcbd28c3c7ec6ab49171ee272046?s=128&d=identicon&r=PG&f=1", "display_name": "gumininja", "link": "https://stackoverflow.com/users/7648395/gumininja"}, "edited": false, "score": 0, "creation_date": 1488579661, "post_id": 42562607, "comment_id": 72311146, "body": "I wanted to get another immutable borrow on the item. I started with <code>Option&lt;&amp;A&gt;</code> but did not understand the lifetime problem. The whole thing started by that the compiler could not interfere the type of <code>a</code> in <code>Some(a)</code> and I just realised that if I have the <code>None</code> matching line first than the whole thing works without type annotation as <code>None =&gt; Some(item)</code> will help the compiler to infer the return type of match to <code>Option&lt;&amp;A&gt;</code> with correct lifetimes."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 3, "last_activity_date": 1488534036, "last_edit_date": 1488534036, "creation_date": 1488477557, "answer_id": 42562607, "question_id": 42561774, "link": "https://stackoverflow.com/questions/42561774/is-it-possible-to-use-fold-in-rust-if-the-accumulator-is-neither-copy-type-nor-m/42562607#42562607", "title": "Is it possible to use fold in Rust if the accumulator is neither copy type nor mutable", "body": "<p>The iterator you get from <code>Vec::iter()</code> produces immutable borrowed references (<code>&amp;A</code> in this case) to the elements in the vector; the vector will be unchanged afterwards.</p>\n\n<p>As a reminder, by default in Rust using a value <a href=\"https://doc.rust-lang.org/book/ownership.html#move-semantics\" rel=\"nofollow noreferrer\">moves it out</a>, leaving the orignal unusable; you can only do this if you own the item, i.e. you can't move out of a borrowed reference.  The exception to this is with types which are <code>Copy</code>, which means that they're \"simple enough\" that a raw memory copy is ok and doesn't invalidate the original object.</p>\n\n<p>So for any type which is not <code>Copy</code>, you can't assign directly from an immutable reference.</p>\n\n<p>There are several options.</p>\n\n<p>First, if you can implement or derive <code>Clone</code> (which means you provide a method which can copy the object, possibly doing more than just a raw copy) without <code>Copy</code>, you can do explicitly clone:</p>\n\n<pre><code>let max = v.iter().fold(None, |res: Option&lt;A&gt;, item| match res {\n    Some(a) =&gt; if a.v &gt;= item.v { Some(a) } else { Some(item.clone()) },\n    None =&gt; Some(item.clone()),\n});\n</code></pre>\n\n<p>You could manually construct the new items inline (<code>Some(A { v: item.v })</code>), but if you're doing that you may as well derive or implement <code>Clone</code>.</p>\n\n<p>If you can consume (i.e. destroy) your vector of items to get the result, then you can move after all by calling the <code>into_iter()</code> method instead of <code>iter()</code>; the iterator in that case owns the items (the original owner, the <code>Vec</code>, is consumed in the process) so you can move them:</p>\n\n<pre><code>let max = v.into_iter().fold(None, |res: Option&lt;A&gt;, item| match res {\n    Some(a) =&gt; if a.v &gt;= item.v { Some(a) } else { Some(item) },\n    None =&gt; Some(item),\n});\n</code></pre>\n\n<p>Moving works fine there, but the <code>Vec</code> no longer exists.</p>\n\n<p>Either way, you either need to make a copy (via <code>Copy</code>, <code>Clone</code>, or something more manual) or move - it's up to your application which is more appropriate.</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1488529547, "post_id": 42571361, "comment_id": 72280966, "body": "Do you have a link for the bug?"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1488544512, "post_id": 42571361, "comment_id": 72290559, "body": "Edited the question with the closest match I could find. There are so many bugs reported against closures and some contradict each other! e.g. in <a href=\"https://github.com/rust-lang/rust/issues/24680\" rel=\"nofollow noreferrer\">issue 24680</a>, you <i>need</i> to specify the argument&#39;s type to avoid a compiler error, which is the opposite from the problem here!"}, {"owner": {"reputation": 33, "user_id": 7648395, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cbc8bcbd28c3c7ec6ab49171ee272046?s=128&d=identicon&r=PG&f=1", "display_name": "gumininja", "link": "https://stackoverflow.com/users/7648395/gumininja"}, "edited": false, "score": 0, "creation_date": 1488577850, "post_id": 42571361, "comment_id": 72310310, "body": "Thanks, I had a map after the fold in the original code that is why I could not specify the type on max and failed to do it on None. Now it works perfectly, <code>max_by_key</code> is actually what I needed, was focusing on the fold too much."}, {"owner": {"reputation": 33, "user_id": 7648395, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cbc8bcbd28c3c7ec6ab49171ee272046?s=128&d=identicon&r=PG&f=1", "display_name": "gumininja", "link": "https://stackoverflow.com/users/7648395/gumininja"}, "edited": false, "score": 0, "creation_date": 1488579750, "post_id": 42571361, "comment_id": 72311189, "body": "As I commented on the other answer also, I just realised that if I have the <code>None =&gt; Some(item)</code> match first then it helps the compiler to infer the type of the accumulator correctly and I do not need type hints."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 3, "last_activity_date": 1488544375, "last_edit_date": 1488544375, "creation_date": 1488519064, "answer_id": 42571361, "question_id": 42561774, "link": "https://stackoverflow.com/questions/42561774/is-it-possible-to-use-fold-in-rust-if-the-accumulator-is-neither-copy-type-nor-m/42571361#42571361", "title": "Is it possible to use fold in Rust if the accumulator is neither copy type nor mutable", "body": "<p>There are several bugs in the compiler regarding the inference of lifetime parameters on closure parameters; the one you've encountered here has been reported as <a href=\"https://github.com/rust-lang/rust/issues/36867\" rel=\"nofollow noreferrer\">issue 36867</a>. In <code>res: Option&lt;&amp;A&gt;</code>, the lifetime inferred for <code>&amp;A</code> is wrong, and it seems to be caused by the return type (which is <code>Option&lt;&amp;A&gt;</code>) also having a lifetime parameter. The workaround is to let the compiler infer <strong>the whole type</strong>, which works fine, and instead either give a type hint on the initial accumulator value (<code>None</code>):</p>\n\n<pre><code>#[derive(Debug)]\nstruct A {\n    v: i32,\n}\n\nfn main() {\n    let v = vec![A { v: 1 }, A { v: 2 }, A { v: 3 }];\n    let max = v.iter().fold(None::&lt;&amp;A&gt;, |res, item| { match res {\n        Some(a) =&gt; if a.v &gt;= item.v { Some(a) } else { Some(item) },\n        None =&gt; Some(item)\n    }});\n    println!(\"{:?}\", max);\n}\n</code></pre>\n\n<p>or on the <code>max</code> variable:</p>\n\n<pre><code>fn main() {\n    let v = vec![A { v: 1 }, A { v: 2 }, A { v: 3 }];\n    let max: Option&lt;&amp;A&gt; = v.iter().fold(None, |res, item| { match res {\n        Some(a) =&gt; if a.v &gt;= item.v { Some(a) } else { Some(item) },\n        None =&gt; Some(item)\n    }});\n    println!(\"{:?}\", max);\n}\n</code></pre>\n\n<p><strong>Bonus:</strong> For the particular problem of finding the maximum, you can also use <a href=\"https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.max_by_key\" rel=\"nofollow noreferrer\"><code>Iterator::max_by_key</code></a>. No annotations required!</p>\n\n<pre><code>fn main() {\n    let v = vec![A { v: 1 }, A { v: 2 }, A { v: 3 }];\n    let max = v.iter().max_by_key(|item| item.v);\n    println!(\"{:?}\", max);\n}\n</code></pre>\n"}], "owner": {"reputation": 33, "user_id": 7648395, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cbc8bcbd28c3c7ec6ab49171ee272046?s=128&d=identicon&r=PG&f=1", "display_name": "gumininja", "link": "https://stackoverflow.com/users/7648395/gumininja"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1959, "favorite_count": 0, "accepted_answer_id": 42571361, "answer_count": 2, "score": 3, "last_activity_date": 1488544375, "creation_date": 1488474840, "question_id": 42561774, "link": "https://stackoverflow.com/questions/42561774/is-it-possible-to-use-fold-in-rust-if-the-accumulator-is-neither-copy-type-nor-m", "title": "Is it possible to use fold in Rust if the accumulator is neither copy type nor mutable", "body": "<p>I am trying to make a fold work and encountered with lifetime issues. Here is the simplified version of my code:</p>\n\n<pre><code>struct A {\n  v: i32,\n}\nlet v = vec![A { v: 1 }, A { v: 2 }, A { v: 3 }];\nlet max = v.iter().fold(None, |res: Option&lt;A&gt;, &amp;item| { match res {\n    Some(a) =&gt; if a.v &gt;= item.v { Some(a) } else { Some(item) },\n    None =&gt; Some(item)\n}});\n</code></pre>\n\n<p>This results in <code>error[E0507]: cannot move out of borrowed content</code>.</p>\n\n<p>If I change the closure to <code>|res: Option&lt;A&gt;, ref item| ...</code> as adviced by the previous error, I get a type mismatch at <code>Some(item)</code> and solving that dereference gets back to the original error.</p>\n\n<p>I tried to have a reference in the option but then I get lifetime issues:</p>\n\n<pre><code>error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n --&gt; &lt;anon&gt;:6:67\n  |\n6 |   let maxV = v.iter().fold(None, |res: Option&lt;&amp;A&gt;, &amp;item| { match res {\n  |                                                                   ^^^\n  |\nnote: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the body at 6:58...\n --&gt; &lt;anon&gt;:6:59\n  |\n6 |     let maxV = v.iter().fold(None, |res: Option&lt;&amp;A&gt;, &amp;item| { match res {\n  |  ___________________________________________________________^ starting here...\n7 | |       Some(a) =&gt; if a.v &gt;= item.v { Some(a) } else { Some(&amp;item) },\n8 | |       None =&gt; Some(&amp;item)\n9 | |   }});\n  | |____^ ...ending here\nnote: ...so that types are compatible (expected std::option::Option&lt;&amp;main::A&gt;, found std::option::Option&lt;&amp;main::A&gt;)\n --&gt; &lt;anon&gt;:6:67\n  |\n6 |   let maxV = v.iter().fold(None, |res: Option&lt;&amp;A&gt;, &amp;item| { match res {\n  |                                                                   ^^^\nnote: but, the lifetime must be valid for the method call at 6:13...\n --&gt; &lt;anon&gt;:6:14\n  |\n6 |     let maxV = v.iter().fold(None, |res: Option&lt;&amp;A&gt;, &amp;item| { match res {\n  |  ______________^ starting here...\n7 | |       Some(a) =&gt; if a.v &gt;= item.v { Some(a) } else { Some(&amp;item) },\n8 | |       None =&gt; Some(&amp;item)\n9 | |   }});\n  | |_____^ ...ending here\nnote: ...so that argument is valid for the call\n --&gt; &lt;anon&gt;:6:28\n  |\n6 |   let maxV = v.iter().fold(None, |res: Option&lt;&amp;A&gt;, &amp;item| { match res {\n  |                            ^^^^\n</code></pre>\n\n<p>The first version works if I make A a copy type by adding <code>#[derive (Copy, Clone)]</code> but that is not always an option.</p>\n\n<p>I tried to search for fold examples in rust, but I either found ones where the accumulator is a copy type (i32 sums implemented with fold) or where the accumulator is a container and the fold is manipulating the content (extending a vector or similar).</p>\n\n<p>I also found <a href=\"https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src/libsyntax/attr.rs#L421\" rel=\"nofollow noreferrer\">an example that folds into an Option</a> but that does not match on the current value of the accumulator.</p>\n\n<p>I can do it with a for loop but would prefer the fold syntax.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1488473599, "post_id": 42560865, "comment_id": 72256734, "body": "The two functions do not even have the same prototype. <code>function_with_two_arguments</code> is not a <code>fn(i64) -&gt; bool</code>. What exactly are you trying to achieve here?"}, {"owner": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1488474337, "post_id": 42560865, "comment_id": 72257256, "body": "@E_net4 I would like change the return type <code>get_function_pointer</code> to return a more generic signature for a function. The goal is to dynamically feed different shaped functions as test properties to quickcheck."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 2, "creation_date": 1488476955, "post_id": 42560865, "comment_id": 72258885, "body": "How would quickcheck call the function it receives?"}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1488477064, "post_id": 42560865, "comment_id": 72258944, "body": "Could you not replace the argument passed in with a single array or struct?"}, {"owner": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1488479792, "post_id": 42560865, "comment_id": 72260586, "body": "@ChrisEmerson quickcheck takes a function <code>where function is Testable</code>. Source is here: <a href=\"https://github.com/BurntSushi/quickcheck/blob/master/src/tester.rs\" rel=\"nofollow noreferrer\">github.com/BurntSushi/quickcheck/blob/master/src/tester.rs</a>"}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1488492436, "post_id": 42560865, "comment_id": 72267748, "body": "<code>quickcheck&lt;A&gt;</code> is a generic function, meaning <code>A</code> must be resolved to a concrete type at compile time. If you <i>could</i> write <code>get_function_pointer</code>, it would <a href=\"https://en.wikipedia.org/wiki/Type_erasure\" rel=\"nofollow noreferrer\">erase</a> the type, which requires runtime polymorphism (i.e., some additional piece of runtime data about the type that gets passed around with it). You can&#39;t call <code>quickcheck</code>, a <i>compile-time-qualified</i> function, by using information that isn&#39;t available until runtime."}], "answers": [{"comments": [{"owner": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "edited": false, "score": 0, "creation_date": 1488476092, "post_id": 42561797, "comment_id": 72258368, "body": "This looks promising, I&#39;ll play with it a bit! It could potentially get a little burdensome as the list of function signatures grows, but we might be limited without the concept of variadics."}], "tags": [], "owner": {"reputation": 627, "user_id": 3987763, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/5edbe17788bc835fa4f08ac4977e67d1?s=128&d=identicon&r=PG&f=1", "display_name": "basic_bgnr", "link": "https://stackoverflow.com/users/3987763/basic-bgnr"}, "is_accepted": true, "score": 5, "last_activity_date": 1488554069, "last_edit_date": 1488554069, "creation_date": 1488474917, "answer_id": 42561797, "question_id": 42560865, "link": "https://stackoverflow.com/questions/42560865/function-that-returns-generic-function-pointers/42561797#42561797", "title": "Function that returns generic function pointers", "body": "<p>You can use an enum to represent the output of the function</p>\n\n<pre><code>enum Either&lt;T, U&gt; {\n    Left(T),\n    Right(U),\n}\n\nfn function_with_one_argument(one: i64) -&gt; bool {\n    one == one // irrelevant\n}\n\nfn function_with_two_arguments(one: i64, two: i64) -&gt; bool {\n    one == two // irrelevant\n}\n\nfn get_function_pointer(id: i64) -&gt; Either&lt;fn(i64) -&gt; bool, fn(i64, i64) -&gt; bool&gt; {\n    match id {\n        1 =&gt; Either::Left(function_with_one_argument),\n        2 =&gt; Either::Right(function_with_two_arguments),\n        _ =&gt; panic!(\"!?!?!\"),\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "is_accepted": false, "score": 2, "last_activity_date": 1488554092, "last_edit_date": 1488554092, "creation_date": 1488496931, "answer_id": 42567886, "question_id": 42560865, "link": "https://stackoverflow.com/questions/42560865/function-that-returns-generic-function-pointers/42567886#42567886", "title": "Function that returns generic function pointers", "body": "<p>Here's a complete solution after using the suggestion above for <code>enum</code>.</p>\n\n<pre><code>extern crate quickcheck;\nuse quickcheck::{QuickCheck, Testable};\nuse std::collections::HashMap;\n\nfn main() {\n    let mut property_map = HashMap::new();\n    property_map.insert(\"one\", Property::One { func: one_argument });\n    property_map.insert(\"two\", Property::Two { func: two_arguments });\n\n    test_property(\"one\", &amp;property_map);\n    test_property(\"two\", &amp;property_map);\n}\n\nenum Property {\n    One { func: fn(i64) -&gt; bool },\n    Two { func: fn(i64, i64) -&gt; bool },\n}\n\nfn test_property(property: &amp;str, property_map: &amp;HashMap&lt;&amp;str, Property&gt;) {\n    match property_map.get(property) {\n        Some(p) =&gt; fetch_property_and_run_quickcheck(p),\n        None =&gt; println!(\"No matching property in property_map\"),\n    };\n}\n\nfn fetch_property_and_run_quickcheck(property: &amp;Property) {\n    match *property {\n        Property::One { func: prop_to_test } =&gt; run_quickcheck(prop_to_test),\n        Property::Two { func: prop_to_test } =&gt; run_quickcheck(prop_to_test),\n    };\n}\n\nfn run_quickcheck&lt;A&gt;(property: A)\n    where A: Testable\n{\n    QuickCheck::new().quickcheck(property);\n}\n\nfn one_argument(one: i64) -&gt; bool {\n    println!(\"testing one_argument() with {}\", one);\n    one == one // irrelevant\n}\n\nfn two_arguments(one: i64, two: i64) -&gt; bool {\n    println!(\"testing two_arguments() with {} and {}\", one, two);\n    one == one &amp;&amp; two == two // irrelevant\n}\n</code></pre>\n"}], "owner": {"reputation": 2200, "user_id": 1519323, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/zUWVH.png?s=128&g=1", "display_name": "davepmiller", "link": "https://stackoverflow.com/users/1519323/davepmiller"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 793, "favorite_count": 0, "accepted_answer_id": 42561797, "answer_count": 2, "score": 0, "last_activity_date": 1488554092, "creation_date": 1488472358, "last_edit_date": 1488472967, "question_id": 42560865, "link": "https://stackoverflow.com/questions/42560865/function-that-returns-generic-function-pointers", "title": "Function that returns generic function pointers", "body": "<p>Say I have two functions:</p>\n\n<pre><code>fn function_with_one_argument(one: i64) -&gt; bool{\n    one==one // irrelevant\n}\n\nfn function_with_two_arguments(one: i64, two: i64) -&gt; bool {\n    one==two // irrelevant\n}\n</code></pre>\n\n<p>Given a different input value, I'd like to return a different function pointer:</p>\n\n<pre><code>fn main() {\n    println!(\"\\n\\n{:?}\\n\\n\", get_function_pointer(1)(321));\n    println!(\"{:?}\", get_function_pointer(2)(321/*, 321*/));\n}\n</code></pre>\n\n<p>How can I represent the return value to return a pointer to different shaped functions?</p>\n\n<pre><code>fn get_function_pointer(id: i64) -&gt; /***/(fn(i64) -&gt; bool)/***/ {\n    match id {\n        1 =&gt; function_with_one_argument,\n        // 2 =&gt; function_with_two_arguments, /*How do we make this work?*?\n        _ =&gt; panic!(\"!?!?!\")\n    }\n}\n</code></pre>\n"}, {"tags": ["rust", "rust-diesel"], "answers": [{"tags": [], "owner": {"reputation": 187, "user_id": 2703854, "user_type": "registered", "profile_image": "https://graph.facebook.com/1014225391/picture?type=large", "display_name": "John T", "link": "https://stackoverflow.com/users/2703854/john-t"}, "is_accepted": false, "score": 1, "last_activity_date": 1586403282, "last_edit_date": 1586403282, "creation_date": 1543048540, "answer_id": 53456525, "question_id": 42557528, "link": "https://stackoverflow.com/questions/42557528/querying-a-diesel-table-with-dynamic-parameters/53456525#53456525", "title": "Querying a Diesel table with dynamic parameters", "body": "<p>Using a boxed trait:</p>\n\n<pre><code>let mut q = dsl::constants.into_boxed();\n\nif let Some(sid) = msg.0 {\n    q = q.filter(dsl::id.eq(sid));\n}\n\nlet items = q\n    .order(dsl::id)\n    .load::&lt;Constant&gt;(conn)\n    .expect(\"Can't load Constant\");\n\nOk(items)\n</code></pre>\n"}], "owner": {"reputation": 8357, "user_id": 89509, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/cd7501ce7690d916269249ed9feac68b?s=128&d=identicon&r=PG", "display_name": "Blake Pettersson", "link": "https://stackoverflow.com/users/89509/blake-pettersson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1399, "favorite_count": 0, "answer_count": 1, "score": 6, "last_activity_date": 1586403282, "creation_date": 1488463450, "question_id": 42557528, "link": "https://stackoverflow.com/questions/42557528/querying-a-diesel-table-with-dynamic-parameters", "title": "Querying a Diesel table with dynamic parameters", "body": "<p>I was starting to look into using Diesel for querying a database. I have a table that looks something like the struct below (this is just a toy project to help me understand how Diesel works). </p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>#[derive(Queryable, Insertable)]\n#[table_name=\"posts\"]\nstruct Post {\n    id: String,\n    title: String,\n    body: String,\n    published: bool\n}\n</code></pre>\n\n<p>Doing queries that are fully determined at compile time is easy enough, for example</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>posts.select(id, title).order(title.desc());\n</code></pre>\n\n<p>What is not clear to me is how to build a query depending on some runtime parameters, without having to fall back to SQL. For example <a href=\"http://jsonapi.org\" rel=\"noreferrer\">JSONAPI</a> allows for dynamically selecting fields and sorting them based on query parameters. How would I do this in Diesel?</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1488450578, "post_id": 42552764, "comment_id": 72240594, "body": "Please check whether the linked question answers your questions. If not, please describe what you still don&#39;t understand. If you know other programming languages (notably C and C++), it would be great to let us know as we could possibly phrase the explanations in a more tailored way."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1488450632, "post_id": 42552764, "comment_id": 72240628, "body": "The duplicate tells you why this is not possible, you should definitely read it! In your case, the simple solution is to return <code>Vec&lt;u8&gt;</code> instead of <code>&amp;[u8]</code>. The former is an <i>owned</i> type, while the latter is <i>borrowed</i>."}, {"owner": {"reputation": 636, "user_id": 4091722, "user_type": "registered", "accept_rate": 25, "profile_image": "https://i.stack.imgur.com/kQuJG.jpg?s=128&g=1", "display_name": "rajiv_", "link": "https://stackoverflow.com/users/4091722/rajiv"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1488544042, "post_id": 42552764, "comment_id": 72290207, "body": "@LukasKalbertodt Thanks! That helped. Anyways, I think I have to read the ownership module again."}, {"owner": {"reputation": 636, "user_id": 4091722, "user_type": "registered", "accept_rate": 25, "profile_image": "https://i.stack.imgur.com/kQuJG.jpg?s=128&g=1", "display_name": "rajiv_", "link": "https://stackoverflow.com/users/4091722/rajiv"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1488544130, "post_id": 42552764, "comment_id": 72290264, "body": "@MatthieuM. I know C and C++. I think I&#39;ll read the concepts again and comeback if I still can&#39;t figure out. Thanks."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1488545066, "post_id": 42552764, "comment_id": 72290922, "body": "@Rajivteja: Coming from C and C++, Rust&#39;s <code>String</code> is C++ <code>std::string</code> and Rust&#39;s <code>&amp;[u8]</code> is roughly C++ <code>char const*</code> (with size). Here, you would be returning a pointer into a local <code>std::string</code>, and the <code>std::string</code> would be destroyed at the end of the function... thus leading to a dangling pointer."}], "owner": {"reputation": 636, "user_id": 4091722, "user_type": "registered", "accept_rate": 25, "profile_image": "https://i.stack.imgur.com/kQuJG.jpg?s=128&g=1", "display_name": "rajiv_", "link": "https://stackoverflow.com/users/4091722/rajiv"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 33, "favorite_count": 0, "closed_date": 1488450469, "answer_count": 0, "score": 1, "last_activity_date": 1488485256, "creation_date": 1488450278, "last_edit_date": 1488485256, "question_id": 42552764, "link": "https://stackoverflow.com/questions/42552764/variable-doesnt-live-long-enough", "closed_reason": "Duplicate", "title": "Variable doesn&#39;t live long enough", "body": "<p>I am a beginner in Rust and I am having a little trouble in understanding the concepts of <b>borrow</b> and <b>lifetime</b>. </p>\n\n<p>I wrote this pretty straightforward code to read the contents of a file into a byte array. </p>\n\n<pre><code>fn file_to_bytes(filepath: &amp;str)-&gt; &amp;[u8] {\n    let mut s = String::new();\n    let mut f = File::open(\"/home/rajiv/CodingIsFun/server/src/\".to_owned()+filepath).unwrap();\n\n    f.read_to_string(&amp;mut s);\n    let slice = s.as_str() ; \n    let bytes :&amp;[u8] = slice.as_bytes() ;\n    bytes\n}\n</code></pre>\n\n<p>Its giving the following error. </p>\n\n<pre><code> error: `s` does not live long enough\n  --&gt; src/main.rs:36:17\n   |\n36 |     let slice = s.as_str() ; \n   |                 ^ does not live long enough\n...\n40 | }\n   | - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the anonymous lifetime #1 defined on the block at 31:41...\n  --&gt; src/main.rs:31:42\n   |\n31 | fn file_to_bytes(filepath: &amp;str)-&gt; &amp;[u8] {\n</code></pre>\n\n<p>I referred this <a href=\"https://www.reddit.com/r/rust/comments/361vy6/how_to_get_around_with_does_not_live_long_enough/%20thread\" rel=\"nofollow noreferrer\">thread</a> on reddit which says that the variables declared later are destroyed first and therefore their lifetime will be shorter than the ones declared above, and this causes the error. But I still couldn't understand what is wrong with my code. </p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 4, "creation_date": 1488447037, "post_id": 42551386, "comment_id": 72238142, "body": "That&#39;s very useful - it&#39;s weird that it&#39;s not better exposed in the docs."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 64, "last_activity_date": 1521666714, "last_edit_date": 1521666714, "creation_date": 1488446714, "answer_id": 42551386, "question_id": 42551113, "link": "https://stackoverflow.com/questions/42551113/is-it-possible-to-conditionally-enable-an-attribute-like-derive/42551386#42551386", "title": "Is it possible to conditionally enable an attribute like `derive`?", "body": "<p>You can use the <code>cfg_attr(a, b)</code> attribute:</p>\n\n<pre><code>#[derive(Debug, Clone)]\n#[cfg_attr(feature = \"serde_support\", derive(Serialize, Deserialize))]\npub struct MyStruct;\n</code></pre>\n\n<p>It's described in the <a href=\"https://doc.rust-lang.org/reference/attributes.html#conditional-compilation\" rel=\"noreferrer\">Rust reference about \"conditional compilation\"</a>:</p>\n\n<blockquote>\n<pre><code>#[cfg_attr(a, b)]\nitem\n</code></pre>\n  \n  <p>Will be the same as <code>#[b] item</code> if <code>a</code> is set by <code>cfg</code>, and <code>item</code> otherwise.</p>\n</blockquote>\n"}], "owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5119, "favorite_count": 3, "accepted_answer_id": 42551386, "answer_count": 1, "score": 41, "last_activity_date": 1533129063, "creation_date": 1488445931, "last_edit_date": 1533129063, "question_id": 42551113, "link": "https://stackoverflow.com/questions/42551113/is-it-possible-to-conditionally-enable-an-attribute-like-derive", "title": "Is it possible to conditionally enable an attribute like `derive`?", "body": "<p>I have added a feature in my crate which adds <code>serde</code> support. However, I don't quite understand how to use it properly:</p>\n\n<pre><code>// #[derive(Debug, Serialize, Deserialize, Clone)] // goes to:\n\n#[derive(Debug, Clone)]\n#[cfg(feature = \"serde_support\")]\n#[derive(Serialize, Deserialize)]\npub struct MyStruct;\n</code></pre>\n\n<p>This code treats everything below <code>cfg(feature)</code> as conditionally compiled, so without my <code>serde_support</code> feature my crate does not have <code>MyStruct</code> also.</p>\n\n<p>I have tried to wrap it with braces but it gives another error:</p>\n\n<p>Code:</p>\n\n<pre><code>#[derive(Debug, Clone)]\n#[cfg(feature = \"serde_support\")] {\n#[derive(Serialize, Deserialize)]\n}\npub struct MyStruct;\n</code></pre>\n\n<p>Error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: expected item after attributes\n  --&gt; mycrate/src/lib.rs:65:33\n   |\n65 | #[cfg(feature = \"serde_support\")] {\n   |                                 ^\n</code></pre>\n\n<p>So how to do this?</p>\n"}, {"tags": ["iterator", "rust", "match"], "answers": [{"comments": [{"owner": {"reputation": 1, "user_id": 7644640, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3f45073774c062e47c8a82f07d92cee6?s=128&d=identicon&r=PG&f=1", "display_name": "Caleb Jasik", "link": "https://stackoverflow.com/users/7644640/caleb-jasik"}, "edited": false, "score": 0, "creation_date": 1488423422, "post_id": 42545854, "comment_id": 72227557, "body": "Thanks a lot. Why does range only iterate forward?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1, "user_id": 7644640, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3f45073774c062e47c8a82f07d92cee6?s=128&d=identicon&r=PG&f=1", "display_name": "Caleb Jasik", "link": "https://stackoverflow.com/users/7644640/caleb-jasik"}, "edited": false, "score": 2, "creation_date": 1488462182, "post_id": 42545854, "comment_id": 72248429, "body": "@CalebJasik: It&#39;s not really that it only iterates forward, and more than it models a typical half-open range: <code>[start end)</code>. In this sense, <code>start == end</code> represents an empty range and <code>start &gt;= end</code> a bug. It also makes the Range code simpler (and thus faster). For reverse iteration, you call <code>rev</code> explicitly, and you&#39;re done."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 7, "last_activity_date": 1545179236, "last_edit_date": 1545179236, "creation_date": 1488422427, "answer_id": 42545854, "question_id": 42545548, "link": "https://stackoverflow.com/questions/42545548/how-can-i-iterate-over-a-backwards-range/42545854#42545854", "title": "How can I iterate over a backwards range?", "body": "<p>Your problem has nothing to do with string concatenation. It has to do with the fact that <code>8..6</code> is an empty iterator, because a range only iterates forwards. Because <code>8 &gt;= 6</code>, the iterator yields <code>None</code> on the first call to <code>next</code>.</p>\n\n<pre><code>fn main() {\n    for i in 8..6 {\n        println!(\"{}\", i); // never reached\n    }\n}\n</code></pre>\n\n<p>This can be fixed by swapping <code>start</code> and <code>end</code> and calling <code>rev()</code> to iterate backwards.</p>\n\n<pre><code>fn main() {\n    for i in (6..8).rev() {\n        println!(\"{}\", i);\n    }\n}\n</code></pre>\n\n<p>However, there's still another problem. In a range <code>start..end</code>, <code>start</code> is inclusive but <code>end</code> is exclusive. For example, the code above prints <code>7</code> and <code>6</code>; <code>8</code> is not printed. See <a href=\"https://stackoverflow.com/q/43698191/155423\">How do I include the end value in a range?</a></p>\n\n<p>Putting it all together, <code>sing</code> should look like:</p>\n\n<pre><code>pub fn sing(start: i32, end: i32) -&gt; String {\n    (end..=start)\n        .rev()\n        .fold(String::new(), |ans, x| ans + &amp;verse(x))\n}\n</code></pre>\n\n<p>Note: Your test still fails because it expects two newlines between each verse, but your code only generates one. I'll leave this up to you to fix. \ud83d\ude42</p>\n"}], "owner": {"reputation": 1, "user_id": 7644640, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3f45073774c062e47c8a82f07d92cee6?s=128&d=identicon&r=PG&f=1", "display_name": "Caleb Jasik", "link": "https://stackoverflow.com/users/7644640/caleb-jasik"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 832, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1545179236, "creation_date": 1488420289, "last_edit_date": 1495540434, "question_id": 42545548, "link": "https://stackoverflow.com/questions/42545548/how-can-i-iterate-over-a-backwards-range", "title": "How can I iterate over a backwards range?", "body": "<p>I'm attempting to create <code>pub fn sing(start: i32, end: i32) -&gt; String</code> that returns a concatenated string of the results of calling <code>pub fn verse(num: i32) -&gt; String</code> repeatedly on each number between <code>start</code> and <code>end</code>.</p>\n\n<p>I've googled for the answer and it seems that <a href=\"https://stackoverflow.com/questions/30714058/rust-string-concatenation\">Rust String concatenation</a> answers my question, and if I even write my code in <a href=\"https://play.rust-lang.org/?gist=e0de6de609d9619e0ea5f10114d058cf&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">playground</a> it works, but:</p>\n\n<p>my code:</p>\n\n<pre><code>pub fn verse(num: i32) -&gt; String {\n    match num {\n        0 =&gt; \"No more bottles of beer on the wall, no more bottles of beer.\\nGo to the store and buy some more, 99 bottles of beer on the wall.\\n\".to_string(),\n        1 =&gt; \"1 bottle of beer on the wall, 1 bottle of beer.\\nTake it down and pass it around, no more bottles of beer on the wall.\\n\".to_string(),\n        2 =&gt; \"2 bottles of beer on the wall, 2 bottles of beer.\\nTake one down and pass it around, 1 bottle of beer on the wall.\\n\".to_string(),\n        num =&gt; format!(\"{0} bottles of beer on the wall, {0} bottles of beer.\\nTake one down and pass it around, {1} bottles of beer on the wall.\\n\",num,(num-1)),\n    }\n}\n\npub fn sing(start: i32, end: i32) -&gt; String {\n    (start..end).fold(String::new(), |ans, x| ans+&amp;verse(x))\n}\n</code></pre>\n\n<p>The problem is that</p>\n\n<pre><code>#[test]\nfn test_song_8_6() {\n    assert_eq!(beer::sing(8, 6), \"8 bottles of beer on the wall, 8 bottles of beer.\\nTake one down and pass it around, 7 bottles of beer on the wall.\\n\\n7 bottles of beer on the wall, 7 bottles of beer.\\nTake one down and pass it around, 6 bottles of beer on the wall.\\n\\n6 bottles of beer on the wall, 6 bottles of beer.\\nTake one down and pass it around, 5 bottles of beer on the wall.\\n\");\n}\n</code></pre>\n\n<p>fails with <code>beer::sing(8,6)</code> returning <code>\"\"</code>.</p>\n"}, {"tags": ["performance", "exception", "rust", "divide-by-zero"], "comments": [{"owner": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "edited": false, "score": 0, "creation_date": 1488414194, "post_id": 42544491, "comment_id": 72225010, "body": "I&#39;m confused. Do you want to use checked division or disable checking if the divisor is zero?"}, {"owner": {"reputation": 22432, "user_id": 634919, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6f4a87fe094961af20263d8e7ff445b2?s=128&d=identicon&r=PG", "display_name": "Nate Eldredge", "link": "https://stackoverflow.com/users/634919/nate-eldredge"}, "edited": false, "score": 1, "creation_date": 1615565084, "post_id": 42544491, "comment_id": 117738625, "body": "&quot;Why not use our CPUs ability to detect this stuff for us?&quot; Not all CPUs have that ability.  x86 raises an exception on division by zero, but others don&#39;t; e.g. ARM silently returns a result of 0."}], "answers": [{"comments": [{"owner": {"reputation": 938, "user_id": 4163506, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/57e96b2432b47a690aecb5f532739f8c?s=128&d=identicon&r=PG&f=1", "display_name": "Lazarus535", "link": "https://stackoverflow.com/users/4163506/lazarus535"}, "edited": false, "score": 2, "creation_date": 1488462438, "post_id": 42549889, "comment_id": 72248613, "body": "<i>integer division is ~100 cycles</i> &lt;- That was really the key point for me. With such a cost, the branch is really negligible. I had different numbers in my head (2-4 cycles). Very good answer, thx!"}, {"owner": {"reputation": 938, "user_id": 4163506, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/57e96b2432b47a690aecb5f532739f8c?s=128&d=identicon&r=PG&f=1", "display_name": "Lazarus535", "link": "https://stackoverflow.com/users/4163506/lazarus535"}, "edited": false, "score": 0, "creation_date": 1488462655, "post_id": 42549889, "comment_id": 72248802, "body": "I did some tests with C/C++ and a similar scenario and both do not check anything. Also compiled with Clang(++). It somehow puzzles me that Clang does not honor this recommendation of LLVM, given how &quot;close&quot; they are."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 938, "user_id": 4163506, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/57e96b2432b47a690aecb5f532739f8c?s=128&d=identicon&r=PG&f=1", "display_name": "Lazarus535", "link": "https://stackoverflow.com/users/4163506/lazarus535"}, "edited": false, "score": 2, "creation_date": 1488462904, "post_id": 42549889, "comment_id": 72248976, "body": "@Lazarus535: Ah, but in C and C++ integer division has undefined behavior (as per specs), therefore it&#39;s &quot;normal&quot; for Clang to invoke <code>udiv</code> and <code>sdiv</code> without checking beforehand."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 938, "user_id": 4163506, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/57e96b2432b47a690aecb5f532739f8c?s=128&d=identicon&r=PG&f=1", "display_name": "Lazarus535", "link": "https://stackoverflow.com/users/4163506/lazarus535"}, "edited": false, "score": 2, "creation_date": 1488462947, "post_id": 42549889, "comment_id": 72249019, "body": "@Lazarus535 Clang is explicitly allowed by the C standard to produce undefined behavior when dividing by zero. Rust on the other hand avoids undefined behavior in safe code. Rust would remain within its promises if it offered an <code>unsafe fn divide_unchecked(divisor: T)</code> method on integer types, but it doesn&#39;t exist, likely for reasons explained in the answer."}, {"owner": {"reputation": 18645, "user_id": 50385, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/2faf0c72f6a7f65431e7df489878be24?s=128&d=identicon&r=PG", "display_name": "Joseph Garvin", "link": "https://stackoverflow.com/users/50385/joseph-garvin"}, "edited": false, "score": 0, "creation_date": 1615822104, "post_id": 42549889, "comment_id": 117803879, "body": "This cost analysis is missing the largest cost: this checking makes your functions much larger so they are less likely to be inlined, which can be arbitrarily expensive because of the opportunity cost of other lost optimizations. There are also a finite number of entries in the branch prediction table, and if systemically every single division in your program is generating this extra code it becomes much more likely to be a significant effect. Rust already uses a SIGSEGV handler for zero-cost stack overflow detection, why not SIGFPE for zero cost divide by zero detection?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 18645, "user_id": 50385, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/2faf0c72f6a7f65431e7df489878be24?s=128&d=identicon&r=PG", "display_name": "Joseph Garvin", "link": "https://stackoverflow.com/users/50385/joseph-garvin"}, "edited": false, "score": 0, "creation_date": 1615824343, "post_id": 42549889, "comment_id": 117805086, "body": "@JosephGarvin: With LLVM, that&#39;s indeed a concern, as AFAIK LLVM is not yet able of performing selective outlining of cold code blocks. At the same time, inlining is based on heuristics to start with, so if it matters you need to use manual hints. With regard to your second remark, you are mistaken in assuming that SIGFPE can handle this =&gt; it cannot. The problem of Undefined Behavior is that it affects the behavior of the optimizer; because dividing by 0 is UB, LLVM is allowed to assume that the dividend is not 0, and optimize accordingly. No signal will catch that."}, {"owner": {"reputation": 18645, "user_id": 50385, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/2faf0c72f6a7f65431e7df489878be24?s=128&d=identicon&r=PG", "display_name": "Joseph Garvin", "link": "https://stackoverflow.com/users/50385/joseph-garvin"}, "edited": false, "score": 0, "creation_date": 1615824718, "post_id": 42549889, "comment_id": 117805297, "body": "@MatthieuM seems like LLVM IR needs a new instruction for division where divide by zero is defined to trap :)"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 18645, "user_id": 50385, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/2faf0c72f6a7f65431e7df489878be24?s=128&d=identicon&r=PG", "display_name": "Joseph Garvin", "link": "https://stackoverflow.com/users/50385/joseph-garvin"}, "edited": false, "score": 0, "creation_date": 1615826540, "post_id": 42549889, "comment_id": 117806167, "body": "@JosephGarvin Yes, there&#39;s definitely a gap in LLVM IR for &quot;poisoning&quot; arithmetic instructions. This applies to divide by 0, but also all additions/subtractions/multiplications that may overflow. You essentially have the choice between UB and the debug instructions used by UBSan. It would be great to have a middle tier that poisons the value/sets a flag causing the computation to fail later -- with fuzzy reporting of what went wrong, they could likely be faster than the debug instructions."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 12, "last_activity_date": 1488463051, "last_edit_date": 1488463051, "creation_date": 1488442046, "answer_id": 42549889, "question_id": 42544491, "link": "https://stackoverflow.com/questions/42544491/can-i-disable-checking-for-zero-division-every-time-the-division-happens/42549889#42549889", "title": "Can I disable checking for zero division every time the division happens?", "body": "<blockquote>\n  <p>I think checking every division beforehand is far away from \"zero-cost\". What do you think?</p>\n</blockquote>\n\n<p>What have you measured?</p>\n\n<p>The number of instructions executed is a very poor proxy of performance; vectorized code is generally more verbose, yet faster.</p>\n\n<p>So the real question is: what is the cost of this branch?</p>\n\n<p>Since intentionally dividing by 0 is rather unlikely, and doing it by accident is only slightly more likely, the branch will always be predicted correctly <em>except</em> when a division by 0 occurs. But then, given the cost of a panic, a mispredicted branch is the least of your worries.</p>\n\n<p>Thus, the cost is:</p>\n\n<ul>\n<li>a slightly fatter assembly,</li>\n<li>an occupied slot in the branch predictor.</li>\n</ul>\n\n<p>The exact impact is hard to qualify, and for math-heavy code it might have an impact. Though I would remind you that an integer division is ~100 cycles<sup>1</sup> to start with, so math-heavy code will shy away from it as much as possible (it's maybe THE single most time consuming instruction in your CPU).</p>\n\n<p><sup>1</sup> <em>See <a href=\"http://www.agner.org/optimize/instruction_tables.pdf\" rel=\"noreferrer\">Agner Fog's Instruction Table</a>: for example on Intel Nehalem DIV and IDIV on 64-bits integrals have a latency of 28 to 90 cycles and 37 to 100 cycles respectively.</em></p>\n\n<hr>\n\n<p>Beyond that, rustc is implemented on top of LLVM, to which it delegates actual code generation. Thus, rustc is at the mercy of LLVM for a number of cases, and this is one of them.</p>\n\n<p>LLVM has two integer division instructions: <a href=\"http://llvm.org/docs/LangRef.html#udiv-instruction\" rel=\"noreferrer\">udiv and sdiv</a>.</p>\n\n<p>Both have Undefined Behavior with a divisor of 0.</p>\n\n<p>Rust aims at eliminating Undefined Behavior, so <em>has</em> to prevent division by 0 to occur, lest the optimizer mangles the emitted code beyond repair.</p>\n\n<p>It uses a check, as recommended in the LLVM manual.</p>\n"}, {"comments": [{"owner": {"reputation": 938, "user_id": 4163506, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/57e96b2432b47a690aecb5f532739f8c?s=128&d=identicon&r=PG&f=1", "display_name": "Lazarus535", "link": "https://stackoverflow.com/users/4163506/lazarus535"}, "edited": false, "score": 0, "creation_date": 1533553121, "post_id": 51687802, "comment_id": 90372757, "body": "Thank you for this very interesting answer! Tough decision, but i would accept this now. Any objections?"}, {"owner": {"reputation": 46, "user_id": 5023193, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/300852481159c2326c2923e8332071ee?s=128&d=identicon&r=PG&f=1", "display_name": "spackogesicht", "link": "https://stackoverflow.com/users/5023193/spackogesicht"}, "reply_to_user": {"reputation": 938, "user_id": 4163506, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/57e96b2432b47a690aecb5f532739f8c?s=128&d=identicon&r=PG&f=1", "display_name": "Lazarus535", "link": "https://stackoverflow.com/users/4163506/lazarus535"}, "edited": false, "score": 0, "creation_date": 1533572063, "post_id": 51687802, "comment_id": 90384829, "body": "@Lazarus535 I think you asked two questions: &quot;<i>Long story short: Can I disable this behaviour?</i>&quot; and &quot;<i>I think checking every division beforehand is far away from &quot;zero-cost&quot;. What do you think? Am I missing something obvious?</i>&quot;. I answered the first one and Matthieu M. answered the second one. No objections from me though :)."}], "tags": [], "owner": {"reputation": 46, "user_id": 5023193, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/300852481159c2326c2923e8332071ee?s=128&d=identicon&r=PG&f=1", "display_name": "spackogesicht", "link": "https://stackoverflow.com/users/5023193/spackogesicht"}, "is_accepted": true, "score": 3, "last_activity_date": 1533405572, "last_edit_date": 1592644375, "creation_date": 1533402062, "answer_id": 51687802, "question_id": 42544491, "link": "https://stackoverflow.com/questions/42544491/can-i-disable-checking-for-zero-division-every-time-the-division-happens/51687802#51687802", "title": "Can I disable checking for zero division every time the division happens?", "body": "<blockquote>\n<p>Long story short: Can I disable this behaviour?</p>\n</blockquote>\n<p>Yes you can: <a href=\"https://doc.rust-lang.org/nightly/std/intrinsics/fn.unchecked_div.html\" rel=\"nofollow noreferrer\"><code>std::intrinsics::unchecked_div(a, b)</code></a>.\nYour question also applies to remainder (thats how Rust calls <a href=\"https://en.wikipedia.org/wiki/Modulo_operation\" rel=\"nofollow noreferrer\">modulo</a>): <a href=\"https://doc.rust-lang.org/nightly/std/intrinsics/fn.unchecked_rem.html\" rel=\"nofollow noreferrer\"><code>std::intrinsics::unchecked_rem(a, b)</code></a>.\nI checked the assembly output <a href=\"https://godbolt.org/g/dm1UAE\" rel=\"nofollow noreferrer\">here</a> to compare it to C++.</p>\n<p>In the documentation it states:</p>\n<blockquote>\n<p>This is a nightly-only experimental API. (core_intrinsics)</p>\n<p>intrinsics are unlikely to ever be stabilized, instead they should be used through stabilized interfaces in the rest of the standard library</p>\n</blockquote>\n<p>So you have to use the nightly build and it is unlikely to ever come in a stabilized form to the standard library for the reasons <a href=\"https://stackoverflow.com/a/42549889/5023193\">Matthieu M.</a> already pointed out.</p>\n"}], "owner": {"reputation": 938, "user_id": 4163506, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/57e96b2432b47a690aecb5f532739f8c?s=128&d=identicon&r=PG&f=1", "display_name": "Lazarus535", "link": "https://stackoverflow.com/users/4163506/lazarus535"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2726, "favorite_count": 1, "accepted_answer_id": 51687802, "answer_count": 2, "score": 10, "last_activity_date": 1533405572, "creation_date": 1488413100, "last_edit_date": 1488485187, "question_id": 42544491, "link": "https://stackoverflow.com/questions/42544491/can-i-disable-checking-for-zero-division-every-time-the-division-happens", "title": "Can I disable checking for zero division every time the division happens?", "body": "<p>In order to better understand Rusts panic/exception mechanisms, I wrote the following piece of code:</p>\n\n<pre><code>#![feature(libc)]\n\nextern crate libc;\n\nfn main() {\n    let mut x: i32;\n    unsafe {\n      x = libc::getchar();\n    }\n\n    let y = x - 65;\n    println!(\"{}\", x);\n\n    let z = 1 / y;\n    println!(\"{}\", z);\n}\n</code></pre>\n\n<p>I wanted to check how Rust deals with division by zero cases. Originally I assumed it was either taking an unhandled SIGFPE to the face and dying or it implemented a handler and rerouted it to a panic (which can be dealt with nowadays?).</p>\n\n<p>The code is verbose because I wanted to make sure that Rust does not do anything \"smart\" when it knows at compile-time that something is zero, hence the user input. Just give it an 'A' and it should do the trick.</p>\n\n<p>I found out that Rust actually produces code that checks for zero division every time before the division happens. I even looked at the assembly for once. :-)</p>\n\n<p>Long story short: Can I disable this behaviour? I imagine for larger datasets this can have quite a performance impact. Why not use our CPUs ability to detect this stuff for us? Can I set up my own signal handler and deal with the SIGFPE instead?</p>\n\n<p>According to <a href=\"https://github.com/rust-lang/rust/issues/944\" rel=\"noreferrer\">an issue on Github</a> the situation must have been different some time ago.</p>\n\n<p>I think checking every division beforehand is far away from \"zero-cost\". What do you think? Am I missing something obvious?</p>\n"}]