[{"tags": ["rust", "rust-cargo"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1460567904, "post_id": 36604010, "comment_id": 60807662, "body": "Highly relevant: <a href=\"http://stackoverflow.com/q/26946646/155423\">Rust package with both a library and a binary?</a>."}, {"owner": {"reputation": 1403, "user_id": 5630582, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/63ae958f28933689533e27cccea95e07?s=128&d=identicon&r=PG&f=1", "display_name": "RallionRl", "link": "https://stackoverflow.com/users/5630582/rallionrl"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460569539, "post_id": 36604010, "comment_id": 60808612, "body": "In complement of <a href=\"http://stackoverflow.com/questions/36604010/how-can-i-build-multiple-binaries-with-cargo/36604610#36604610\">Dognert&#39;s</a> answer, they answer all the questions I got. Thank you a lot!"}], "answers": [{"comments": [{"owner": {"reputation": 13014, "user_id": 4140572, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2uRSa.png?s=128&g=1", "display_name": "Angel Angel", "link": "https://stackoverflow.com/users/4140572/angel-angel"}, "edited": false, "score": 0, "creation_date": 1460631943, "post_id": 36604610, "comment_id": 60838155, "body": "I have looked at the documentation Cargo, but I can not see anything, you can specify the output to store the binary ? for example pathTo: &quot;/some/path&quot; I&#39;m sorry for my English."}, {"owner": {"reputation": 13014, "user_id": 4140572, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2uRSa.png?s=128&g=1", "display_name": "Angel Angel", "link": "https://stackoverflow.com/users/4140572/angel-angel"}, "edited": false, "score": 0, "creation_date": 1460632345, "post_id": 36604610, "comment_id": 60838466, "body": "if you think it is better to create a question about this, I can do it without any problem, it might be easier to find others with the same question ?"}, {"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "reply_to_user": {"reputation": 13014, "user_id": 4140572, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2uRSa.png?s=128&g=1", "display_name": "Angel Angel", "link": "https://stackoverflow.com/users/4140572/angel-angel"}, "edited": false, "score": 0, "creation_date": 1460634502, "post_id": 36604610, "comment_id": 60840132, "body": "@AngelAngel you want to customize the output path? By default it&#39;ll be stored in <code>target&#47;debug&#47;$name</code> where <code>$name</code> is the <code>name</code> you specify in Cargo.toml."}, {"owner": {"reputation": 13014, "user_id": 4140572, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2uRSa.png?s=128&g=1", "display_name": "Angel Angel", "link": "https://stackoverflow.com/users/4140572/angel-angel"}, "edited": false, "score": 0, "creation_date": 1460635275, "post_id": 36604610, "comment_id": 60840712, "body": "I just wondered if you could say where to install a copy of the binary elsewhere other than the default. A copy in $name and another copy in another path. Not that it is trivial, just curious, thanks for your time."}, {"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "reply_to_user": {"reputation": 13014, "user_id": 4140572, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2uRSa.png?s=128&g=1", "display_name": "Angel Angel", "link": "https://stackoverflow.com/users/4140572/angel-angel"}, "edited": false, "score": 0, "creation_date": 1460635778, "post_id": 36604610, "comment_id": 60841109, "body": "@AngelAngel I think you&#39;re looking for the <code>cargo install</code> command. Try reading the output of <code>cargo help install</code>."}], "tags": [], "owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "is_accepted": true, "score": 156, "last_activity_date": 1460565583, "creation_date": 1460565583, "answer_id": 36604610, "question_id": 36604010, "link": "https://stackoverflow.com/questions/36604010/how-can-i-build-multiple-binaries-with-cargo/36604610#36604610", "title": "How can I build multiple binaries with Cargo?", "body": "<p>You can specify multiple binaries using <code>[[bin]]</code>, as mentioned <a href=\"http://doc.crates.io/manifest.html#configuring-a-target\">here</a>:</p>\n\n<pre><code>[[bin]]\nname = \"daemon\"\npath = \"src/daemon/bin/main.rs\"\n\n[[bin]]\nname = \"client\"\npath = \"src/client/bin/main.rs\"\n</code></pre>\n\n<p>Tip: If you instead put these files in <code>src/bin/daemon.rs</code> and <code>src/bin/client.rs</code>, you'll get two executables named <code>daemon</code> and <code>client</code> as Cargo compiles all files in <code>src/bin</code> into executables with the same name automatically. You need to specify names and paths like in the snippet above only if you don't follow this convention.</p>\n"}, {"comments": [{"owner": {"reputation": 397, "user_id": 1319652, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/718858dd982eea3852b1df58cb8a6bff?s=128&d=identicon&r=PG", "display_name": "Kenny Bambridge", "link": "https://stackoverflow.com/users/1319652/kenny-bambridge"}, "edited": false, "score": 1, "creation_date": 1588536503, "post_id": 57630418, "comment_id": 108929830, "body": "I could not get this to work. I had to move the binary rust source in the src/ folder and specify another target in <code>[[bin]]</code>. Could you give more details about what you did to get this to work?  I was getting the following error:  <code>use ::engine::RuleEngine;</code> <code>could not find engine in {{root}}</code>"}, {"owner": {"reputation": 1683, "user_id": 1829232, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/3fdd30877095f67a858777ac1b393259?s=128&d=identicon&r=PG", "display_name": "UltimaWeapon", "link": "https://stackoverflow.com/users/1829232/ultimaweapon"}, "reply_to_user": {"reputation": 397, "user_id": 1319652, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/718858dd982eea3852b1df58cb8a6bff?s=128&d=identicon&r=PG", "display_name": "Kenny Bambridge", "link": "https://stackoverflow.com/users/1319652/kenny-bambridge"}, "edited": false, "score": 0, "creation_date": 1592837859, "post_id": 57630418, "comment_id": 110560800, "body": "@KennyBambridge I have not worked on Rust for awhile. IIRC when I have created this answer I tried on my local machine and it work as intended."}, {"owner": {"reputation": 1426, "user_id": 401059, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/bad9a53bf9fb1eab27f66b04de0e092d?s=128&d=identicon&r=PG", "display_name": "Caesar", "link": "https://stackoverflow.com/users/401059/caesar"}, "reply_to_user": {"reputation": 397, "user_id": 1319652, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/718858dd982eea3852b1df58cb8a6bff?s=128&d=identicon&r=PG", "display_name": "Kenny Bambridge", "link": "https://stackoverflow.com/users/1319652/kenny-bambridge"}, "edited": false, "score": 0, "creation_date": 1602930764, "post_id": 57630418, "comment_id": 113879115, "body": "@KennyBambridge You do have to add crates in other workspaces as dependencies in the Cargo.toml where you want to use them."}], "tags": [], "owner": {"reputation": 1683, "user_id": 1829232, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/3fdd30877095f67a858777ac1b393259?s=128&d=identicon&r=PG", "display_name": "UltimaWeapon", "link": "https://stackoverflow.com/users/1829232/ultimaweapon"}, "is_accepted": false, "score": 23, "last_activity_date": 1603130849, "last_edit_date": 1603130849, "creation_date": 1566579628, "answer_id": 57630418, "question_id": 36604010, "link": "https://stackoverflow.com/questions/36604010/how-can-i-build-multiple-binaries-with-cargo/57630418#57630418", "title": "How can I build multiple binaries with Cargo?", "body": "<p>Another way is to use <a href=\"https://doc.rust-lang.org/cargo/reference/manifest.html#the-workspace-section\" rel=\"noreferrer\">the workspace feature</a>. This will provide more flexibility due to the fact that we can have more than one library. Example project structure:</p>\n<pre><code>.\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 cli\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.rs\n\u251c\u2500\u2500 core\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 lib.rs\n\u251c\u2500\u2500 daemon\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.rs\n\u251c\u2500\u2500 gui\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.rs\n\u2514\u2500\u2500 rpc\n    \u251c\u2500\u2500 Cargo.toml\n    \u2514\u2500\u2500 src\n        \u2514\u2500\u2500 lib.rs\n</code></pre>\n<p>Contents of the root <code>Cargo.toml</code>:</p>\n<pre><code>[workspace]\nmembers = [&quot;cli&quot;, &quot;core&quot;, &quot;daemon&quot;, &quot;gui&quot;, &quot;rpc&quot;]\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 29, "user_id": 4602323, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/019fd245686fb0c4b85042d8688fcf6f?s=128&d=identicon&r=PG", "display_name": "Robust Systems 8472-1488", "link": "https://stackoverflow.com/users/4602323/robust-systems-8472-1488"}, "is_accepted": false, "score": 1, "last_activity_date": 1567901623, "creation_date": 1567901623, "answer_id": 57838288, "question_id": 36604010, "link": "https://stackoverflow.com/questions/36604010/how-can-i-build-multiple-binaries-with-cargo/57838288#57838288", "title": "How can I build multiple binaries with Cargo?", "body": "<p>Another format could be to replicate what the <a href=\"https://github.com/rust-lang/crates.io/tree/master/src\" rel=\"nofollow noreferrer\">Crates.io source code</a> has done, if you have a massive project, something like:</p>\n\n<p>Main Library in src, with a Bin folder with your executables.\nThen make calls to your main library crate from your executables.</p>\n\n<p>That way you library is centralized so easier to find things as it's cached. </p>\n"}], "owner": {"reputation": 1403, "user_id": 5630582, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/63ae958f28933689533e27cccea95e07?s=128&d=identicon&r=PG&f=1", "display_name": "RallionRl", "link": "https://stackoverflow.com/users/5630582/rallionrl"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 34300, "favorite_count": 27, "accepted_answer_id": 36604610, "answer_count": 3, "score": 121, "last_activity_date": 1603130849, "creation_date": 1460563801, "last_edit_date": 1460567837, "question_id": 36604010, "link": "https://stackoverflow.com/questions/36604010/how-can-i-build-multiple-binaries-with-cargo", "title": "How can I build multiple binaries with Cargo?", "body": "<p>I'd like to make a project with a <code>daemon</code> and a <code>client</code>, connecting through a unix socket. </p>\n\n<p>A <code>client</code> and a <code>daemon</code> requires two binaries, so how do I tell <code>Cargo</code> to build two targets from two different sources?</p>\n\n<p>To add a bit of fantasy, I'd like to have a <code>library</code> for the main part of the <code>daemon</code>, and just have a binary to wrap around it and communicate through sockets.</p>\n\n<p>So, we have this kind of tree architecture:</p>\n\n<pre><code>\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 target\n|   \u2514\u2500\u2500 debug\n|       \u251c\u2500\u2500 daemon\n\u2502       \u2514\u2500\u2500 client\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 daemon\n    \u2502   \u251c\u2500\u2500 bin\n    \u2502   \u2502   \u2514\u2500\u2500 main.rs\n    \u2502   \u2514\u2500\u2500 lib\n    \u2502       \u2514\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 client\n        \u2514\u2500\u2500 bin\n            \u2514\u2500\u2500 main.rs\n</code></pre>\n\n<p>I could make one executable which manages both concerns, but that's not what I want to do, unless it's very good practice.</p>\n"}, {"tags": ["hashmap", "rust", "match"], "answers": [{"tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": true, "score": 3, "last_activity_date": 1460564563, "creation_date": 1460564563, "answer_id": 36604278, "question_id": 36603867, "link": "https://stackoverflow.com/questions/36603867/how-to-workaround-rusts-borrow-check-of-hashmap/36604278#36604278", "title": "How to workaround Rust&#39;s borrow check of HashMap?", "body": "<p>You want to use <a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry\" rel=\"nofollow\"><code>entry</code></a>:</p>\n\n<pre><code>match pat_mapping.entry(c) {\n    Occupied(phrase) =&gt; {\n        if phrase.get().to_string() != word.to_string() {\n            return false;\n        }\n    },\n    Vacant(vacant) =&gt; {\n        vacant.insert(word);\n    }\n}\n</code></pre>\n\n<p>It also has the advantage of looking up the key only once.</p>\n"}], "owner": {"reputation": 89, "user_id": 4837852, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b7179ba8db61f24485ef85461f0dd268?s=128&d=identicon&r=PG&f=1", "display_name": "divinites", "link": "https://stackoverflow.com/users/4837852/divinites"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 190, "favorite_count": 0, "closed_date": 1460567740, "accepted_answer_id": 36604278, "answer_count": 1, "score": 1, "last_activity_date": 1460567712, "creation_date": 1460563420, "last_edit_date": 1460567712, "question_id": 36603867, "link": "https://stackoverflow.com/questions/36603867/how-to-workaround-rusts-borrow-check-of-hashmap", "closed_reason": "Duplicate", "title": "How to workaround Rust&#39;s borrow check of HashMap?", "body": "<p>I have this code where <code>pat_vec</code> and <code>str_vec</code> are two iterators:</p>\n\n<pre><code>let mut pat_mapping: HashMap&lt;char, &amp;str&gt; = HashMap::new();\n\nfor combi in pat_vec.zip(str_vec) {\n    let (c, word) = combi;\n\n    match pat_mapping.get(&amp;c) {\n        Some(phrase) =&gt; {\n            if phrase.to_string() != word.to_string() {\n                return false;\n            }\n        }\n\n        None =&gt; {\n            pat_mapping.insert(c, word);\n        }\n    }\n}\n</code></pre>\n\n<p>This does not work, and the compiler complains that:</p>\n\n<pre><code>cannot borrow `pat_mapping` as mutable because it is also borrowed as immutable [E0502]\n</code></pre>\n\n<p>I understand that it might because <code>pat_mapping.get(&amp;c)</code> borrowed <code>&amp;self</code> as immutable, while the <code>insert()</code> method falls into the same scope but needs to borrow <code>&amp;self</code> as mutable.</p>\n\n<p>I have a work around:</p>\n\n<pre><code>match word_mapping.get(&amp;c) {\n    Some(phrase) =&gt; {\n        if phrase.to_string() != word.to_string() {\n            return false;\n        }\n    }\n    None =&gt; {\n\n        pat_trigger = true;\n    }\n\n};\n\nif pat_trigger {\n    pat_mapping.insert(c, word);\n}\n</code></pre>\n\n<p>But introducing a boolean flag is redundant. Is there a way to work around the borrow check so as to do the match and insert in the same code block?</p>\n"}, {"tags": ["vector", "iterator", "rust"], "comments": [{"owner": {"reputation": 9369, "user_id": 71079, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/3e302415f77b6c398abc0b16efc653f3?s=128&d=identicon&r=PG", "display_name": "Ralph Caraveo", "link": "https://stackoverflow.com/users/71079/ralph-caraveo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460562304, "post_id": 36603260, "comment_id": 60803852, "body": "Thank you, I edited the post...and your link does actually clarify my question.  This can be closed."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460562408, "post_id": 36603260, "comment_id": 60803939, "body": "I like that you used the same example data as the other question (<code>vec![1, 2, 3, 4, 5]</code>) ^_^."}, {"owner": {"reputation": 9369, "user_id": 71079, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/3e302415f77b6c398abc0b16efc653f3?s=128&d=identicon&r=PG", "display_name": "Ralph Caraveo", "link": "https://stackoverflow.com/users/71079/ralph-caraveo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460562446, "post_id": 36603260, "comment_id": 60803963, "body": "Haha, yep, I also like that you actually answered the link you posted.  Thx again."}], "owner": {"reputation": 9369, "user_id": 71079, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/3e302415f77b6c398abc0b16efc653f3?s=128&d=identicon&r=PG", "display_name": "Ralph Caraveo", "link": "https://stackoverflow.com/users/71079/ralph-caraveo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 36, "favorite_count": 0, "closed_date": 1460562311, "answer_count": 0, "score": 2, "last_activity_date": 1460562256, "creation_date": 1460561822, "last_edit_date": 1460562256, "question_id": 36603260, "link": "https://stackoverflow.com/questions/36603260/in-rust-which-iterator-method-is-preferred-when-wanting-a-non-mutable-reference", "closed_reason": "Duplicate", "title": "In Rust, which iterator method is preferred when wanting a non-mutable reference?", "body": "<p>I have the following code:</p>\n\n<pre><code>fn main() {\n    let mut v = vec![1, 2, 3, 4, 5];\n\n    for i in &amp;v {\n        println!(\"A reference to {}\", i);\n    }\n    for i in v.iter(){\n        println!(\"A ?? to {}\", i);\n    }\n}\n</code></pre>\n\n<p>I am trying to understand what the difference is between the first for/in loop vs the second for/in loop.  Is the second one equivalent to the first one and if so, which is the preferred more idiomatic choice?</p>\n\n<p>I have been reading contradictory information on this because I think some articles refer to older versions of Rust so I'm getting a bit confused.</p>\n"}, {"tags": ["rust", "smart-pointers", "lifetime", "borrowing", "interior-mutability"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1460552513, "post_id": 36597987, "comment_id": 60795388, "body": "Note: the borrow checker is not too strict, it prevents aliasing to occur here. If not for this, you could have mutability + aliasing, and thus crashes or memory corruption."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1460553460, "post_id": 36597987, "comment_id": 60796238, "body": "@MatthieuM. where would aliasing occur here?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460553584, "post_id": 36597987, "comment_id": 60796354, "body": "Have you had an opportunity to read <a href=\"http://cglab.ca/~abeinges/blah/too-many-lists/book/\" rel=\"nofollow noreferrer\"><i>Learning Rust With Entirely Too Many Linked Lists</i></a>?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1460553652, "post_id": 36597987, "comment_id": 60796417, "body": "@Shepmaster: If you can get <code>curr</code> without borrowing <code>self</code>, what prevents you from getting <code>curr</code> again in the same method body? Nothing. This is dynamically prevented by getting <code>RefCell::borrow</code> to only lend references valid during the lifetime of its result."}], "answers": [{"comments": [{"owner": {"reputation": 285, "user_id": 6198487, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lUrJE.png?s=128&g=1", "display_name": "Tsukki", "link": "https://stackoverflow.com/users/6198487/tsukki"}, "edited": false, "score": 0, "creation_date": 1460552990, "post_id": 36599326, "comment_id": 60795825, "body": "Thanks for the answer. Are you saying that there is no way to do this in a loop? I&#39;m not sure if your example is a solution to my problem."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 285, "user_id": 6198487, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lUrJE.png?s=128&g=1", "display_name": "Tsukki", "link": "https://stackoverflow.com/users/6198487/tsukki"}, "edited": false, "score": 0, "creation_date": 1460554056, "post_id": 36599326, "comment_id": 60796758, "body": "@Tsukki I wouldn&#39;t say no way, but <b>I</b> don&#39;t know it. When you do it recursively, I assume that there is an implicit hierarchy of outstanding borrows that allows it to proceed."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1460552728, "creation_date": 1460552728, "answer_id": 36599326, "question_id": 36597987, "link": "https://stackoverflow.com/questions/36597987/cyclic-reference-of-refcell-borrows-in-traversal/36599326#36599326", "title": "Cyclic reference of RefCell borrows in traversal", "body": "<p>Here's a smaller reproduction that I believe shows the same problem:</p>\n\n<pre><code>use std::cell::RefCell;\n\nfn main() {\n    let foo = RefCell::new(Some(42));\n    let x = foo.borrow().as_ref().unwrap();\n}\n</code></pre>\n\n<p>As I read it:</p>\n\n<ol>\n<li><code>foo.borrow()</code> returns a <a href=\"http://doc.rust-lang.org/std/cell/struct.Ref.html\" rel=\"nofollow\"><code>cell::Ref</code></a>, a type of <em>smart pointer</em>. In this case, the smart pointer acts like an <code>&amp;Option&lt;i32&gt;</code>.</li>\n<li><code>as_ref()</code> creates an <code>Option&lt;&amp;i32&gt;</code> where the inner reference has the same lifetime as the smart pointer.</li>\n<li>The <code>Option</code> is discarded, yielding only an <code>&amp;i32</code>, still with a lifetime of the smart pointer.</li>\n</ol>\n\n<p>Notably, the smart pointer <code>Ref</code> only lasts for the statement, but the code attempts to return a reference into the <code>Ref</code> that would outlive the statement.</p>\n\n<p>Generally, the solution would be to do something like this:</p>\n\n<pre><code>let foo_borrow = foo.borrow();\nlet x = foo_borrow.as_ref().unwrap();\n</code></pre>\n\n<p>This keeps the smart pointer around longer, allowing the lifetime of the reference to be valid for as long as <code>foo_borrow</code> (representing the borrow itself) exists.</p>\n\n<p>In the case of a loop, there's not much you can do, as you essentially want to borrow every previous node until you get to the next one.</p>\n"}, {"comments": [{"owner": {"reputation": 285, "user_id": 6198487, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lUrJE.png?s=128&g=1", "display_name": "Tsukki", "link": "https://stackoverflow.com/users/6198487/tsukki"}, "edited": false, "score": 0, "creation_date": 1460700985, "post_id": 36614733, "comment_id": 60873493, "body": "Thanks, that worked! However, when I need to borrow mut from <code>curr</code> in the following lines, I had to do <code>let next = curr.borrow_mut().next.take(); match next {...}</code> instead of simply <code>match curr.borrow_mut().next.take() {...}</code>. The compiler doesn&#39;t try hard to infer things eh."}], "tags": [], "owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "is_accepted": true, "score": 2, "last_activity_date": 1557413479, "last_edit_date": 1557413479, "creation_date": 1460612861, "answer_id": 36614733, "question_id": 36597987, "link": "https://stackoverflow.com/questions/36597987/cyclic-reference-of-refcell-borrows-in-traversal/36614733#36614733", "title": "Cyclic reference of RefCell borrows in traversal", "body": "<p>You can clone <code>Rc</code> to avoid lifetime issues:</p>\n\n<pre><code>let mut curr = self.head.as_ref().unwrap().clone();\nfor _ in 1..idx {\n    let t = curr.borrow().next.as_ref().unwrap().clone();\n    curr = t;\n}\n</code></pre>\n"}], "owner": {"reputation": 285, "user_id": 6198487, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lUrJE.png?s=128&g=1", "display_name": "Tsukki", "link": "https://stackoverflow.com/users/6198487/tsukki"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 315, "favorite_count": 0, "accepted_answer_id": 36614733, "answer_count": 2, "score": 3, "last_activity_date": 1557413479, "creation_date": 1460549566, "last_edit_date": 1557413440, "question_id": 36597987, "link": "https://stackoverflow.com/questions/36597987/cyclic-reference-of-refcell-borrows-in-traversal", "title": "Cyclic reference of RefCell borrows in traversal", "body": "<p>I'm learning Rust and tried coding a doubly-linked list. However, I'm stuck already at a typical iterative traversal implementation. I'm getting the impression that the borrow checker / drop checker is too strict and cannot infer the correct lifetime for the borrow when it crosses the function boundary from <code>RefCell</code>. I need to repeatedly set a variable binding (<code>curr</code> in this case) to the borrow of its current contents:</p>\n\n<pre><code>use std::cell::RefCell;\nuse std::rc::Rc;\n\npub struct LinkedList&lt;T&gt; {\n    head: Option&lt;Rc&lt;RefCell&lt;LinkedNode&lt;T&gt;&gt;&gt;&gt;,\n    // ...\n}\n\nstruct LinkedNode&lt;T&gt; {\n    value: T,\n    next: Option&lt;Rc&lt;RefCell&lt;LinkedNode&lt;T&gt;&gt;&gt;&gt;,\n    // ...\n}\n\nimpl&lt;T&gt; LinkedList&lt;T&gt; {\n    pub fn insert(&amp;mut self, value: T, idx: usize) -&gt; &amp;mut LinkedList&lt;T&gt; {\n        // ... some logic ...\n\n        // This is the traversal that fails to compile.\n        let mut curr = self.head.as_ref().unwrap();\n        for _ in 1..idx {\n            curr = curr.borrow().next.as_ref().unwrap()\n        }\n\n        // I want to use curr here.\n        // ...\n        unimplemented!()\n    }\n}\n</code></pre>\n\n<p>The compiler complains:</p>\n\n<p><strong>Without NLL</strong></p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0597]: borrowed value does not live long enough\n  --&gt; src/lib.rs:22:20\n   |\n22 |             curr = curr.borrow().next.as_ref().unwrap()\n   |                    ^^^^^^^^^^^^^ temporary value does not live long enough\n23 |         }\n   |         - temporary value dropped here while still borrowed\n...\n28 |     }\n   |     - temporary value needs to live until here\n   |\n   = note: consider using a `let` binding to increase its lifetime\n</code></pre>\n\n<p><strong>With NLL</strong></p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0716]: temporary value dropped while borrowed\n  --&gt; src/lib.rs:22:20\n   |\n22 |             curr = curr.borrow().next.as_ref().unwrap()\n   |                    ^^^^^^^^^^^^^\n   |                    |\n   |                    creates a temporary which is freed while still in use\n   |                    a temporary with access to the borrow is created here ...\n23 |         }\n   |         -\n   |         |\n   |         temporary value is freed at the end of this statement\n   |         ... and the borrow might be used here, when that temporary is dropped and runs the destructor for type `std::cell::Ref&lt;'_, LinkedNode&lt;T&gt;&gt;`\n   |\n   = note: consider using a `let` binding to create a longer lived value\n   = note: The temporary is part of an expression at the end of a block. Consider adding semicolon after the expression so its temporaries are dropped sooner, before the local variables declared by the block are dropped.\n</code></pre>\n\n<p>I would really appreciate a <strong>iterative solution</strong> (<em>non-recursive</em>) to this problem.</p>\n"}, {"tags": ["rust", "docopt"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1460543428, "post_id": 36595574, "comment_id": 60788087, "body": "Please show the code you have tried and what issues you had with it"}, {"owner": {"reputation": 13, "user_id": 5430657, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lEmXa.png?s=128&g=1", "display_name": "Bump the Trump", "link": "https://stackoverflow.com/users/5430657/bump-the-trump"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460543831, "post_id": 36595574, "comment_id": 60788397, "body": "@ker I&#39;ve added it to the edit"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460545122, "post_id": 36595574, "comment_id": 60789290, "body": "I don&#39;t think your docopt spec does what you think it does. How would you know which flag was set for which value? The <code>Args</code> struct you get would have the same values for <code>program -a &quot;hi&quot; -b 2</code> and <code>program -b &quot;hi&quot; -a 2</code>"}, {"owner": {"reputation": 13, "user_id": 5430657, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lEmXa.png?s=128&g=1", "display_name": "Bump the Trump", "link": "https://stackoverflow.com/users/5430657/bump-the-trump"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460545518, "post_id": 36595574, "comment_id": 60789592, "body": "@ker ok I see what&#39;s wrong with it."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1460547647, "post_id": 36595574, "comment_id": 60791143, "body": "There is another problem, however. You mentioned that you use <code>cargo run</code>, right? In order for it to pass arguments to the program correctly, you need to specify them after a double dash, like this: <code>cargo run -- -a &quot;hi&quot; -b 2</code>. Otherwise <code>cargo run</code> won&#39;t be able to decide which options are directed to itself and which to the program. But regardless, @ker&#39;s concerns are absolutely valid. Frankly, I&#39;m not sure if any arguments parsing libraries can do what you want (up to four arguments, with different flags for each). It is likely you&#39;d need to implement parsing yourself."}], "answers": [{"comments": [{"owner": {"reputation": 13, "user_id": 5430657, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lEmXa.png?s=128&g=1", "display_name": "Bump the Trump", "link": "https://stackoverflow.com/users/5430657/bump-the-trump"}, "edited": false, "score": 0, "creation_date": 1460552047, "post_id": 36598845, "comment_id": 60794940, "body": "This is very informative. So whenever you parse in command line arguments that use a flag you must always use -- as the first command line argument?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 13, "user_id": 5430657, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lEmXa.png?s=128&g=1", "display_name": "Bump the Trump", "link": "https://stackoverflow.com/users/5430657/bump-the-trump"}, "edited": false, "score": 0, "creation_date": 1460553001, "post_id": 36598845, "comment_id": 60795833, "body": "@BumptheTrump no, that&#39;s not quite correct. I&#39;ve added a note."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1460552977, "last_edit_date": 1495541751, "creation_date": 1460551568, "answer_id": 36598845, "question_id": 36595574, "link": "https://stackoverflow.com/questions/36595574/parsing-command-line-flags-with-arguments-using-docopt-and-rust-similar-to-geto/36598845#36598845", "title": "Parsing command line flags with arguments using docopt and Rust, similar to getopt", "body": "<p>Something like this is likely to get you pretty close:</p>\n\n<pre><code>const USAGE: &amp;'static str = \"\nProgram.\n\nUsage: program [options]\n\nOptions:\n    -a VALUE\n    -b VALUE\n    -c VALUE\n    -d VALUE\n\";\n\n#[derive(Debug, RustcDecodable)]\nstruct Args {\n    flag_a: Option&lt;String&gt;,\n    flag_b: Option&lt;i32&gt;,\n    flag_c: Option&lt;String&gt;,\n    flag_d: Option&lt;String&gt;,\n}\n</code></pre>\n\n<p>When run with <code>cargo run -- -a \"hello\" -b 3</code> (see note below), the output is:</p>\n\n<pre><code>Args { flag_a: Some(\"hello\"), flag_b: Some(3), flag_c: None, flag_d: None }\n</code></pre>\n\n<p>You can then pattern match on <code>flag_a</code> to tell if it was provided (and thus get the value). There's no need to have separate boolean flags, an <code>Option</code> is way better in this case.</p>\n\n<hr>\n\n<p>As <a href=\"https://stackoverflow.com/questions/36595574/parsing-command-line-flags-with-arguments-using-docopt-and-rust-similar-to-geto/36598845?noredirect=1#comment60791143_36595574\">Vladimir Matveev points out</a>, when you execute your program through <code>cargo run</code>, you have to distinguish arguments to <code>cargo</code> from arguments to your program. Most (all?) programs that do this do so with the special flag <code>--</code>. This separates arguments between the programs. You could also run the program directly after it is built:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ cargo build\n$ ./target/debug/program_name -a \"hello\" -b 3 \n</code></pre>\n"}], "owner": {"reputation": 13, "user_id": 5430657, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lEmXa.png?s=128&g=1", "display_name": "Bump the Trump", "link": "https://stackoverflow.com/users/5430657/bump-the-trump"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 910, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1460552977, "creation_date": 1460543167, "last_edit_date": 1460551798, "question_id": 36595574, "link": "https://stackoverflow.com/questions/36595574/parsing-command-line-flags-with-arguments-using-docopt-and-rust-similar-to-geto", "title": "Parsing command line flags with arguments using docopt and Rust, similar to getopt", "body": "<p>I'm looking for a way to emulate how C uses <code>getopt</code>. I want to convert the following C snippet to Rust using docopt. I can't seem to pass flags into the command line argument:</p>\n\n<pre><code>char in;\nchar* stringName;\nwhile(( in = getopt( argc, argv, \"a:b:c:d:e:\")) != EOF) {\n    switch(in) {\n        case 'a':\n            stringName = optarg;\n            break;\n     // ... and so on\n</code></pre>\n\n<p>Then I want to run</p>\n\n<pre><code>cargo run -a \"hello\" -b 3 ... and so on\n</code></pre>\n\n<p>I have written this so far:</p>\n\n<pre><code>extern crate rustc_serialize;\nextern crate docopt;\n\nuse docopt::Docopt;\n\n// Define a USAGE string\nconst USAGE: &amp;'static str = \"\nProgram.\n\nUsage: [options] [&lt;value1&gt;] [options] [&lt;value2&gt;] [options] [&lt;value3&gt;] [options] [&lt;value4&gt;]\n\nOptions:\n    -a, \n    -b, \n    -c,\n    -d,  \n\";\n\n#[derive(Debug, RustcDecodable)]\nstruct Args {\n    arg_value1: Option&lt;String&gt;,\n    flag_a: bool,\n    flag_b: bool,\n    flag_c: bool,\n    arg_value2: Option&lt;String&gt;,\n    arg_value3: Option&lt;String&gt;,\n    arg_value4: Option&lt;String&gt;,\n}\n\nfn main() {\n    let args: Args = Docopt::new(USAGE)\n                            .and_then(|d| d.decode())\n                            .unwrap_or_else(|e| e.exit());\n    println!(\"{:?}\", args);\n}\n</code></pre>\n\n<p>When I <code>cargo run</code> I get </p>\n\n<blockquote>\n  <p>unknown flag -a</p>\n</blockquote>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 2964, "user_id": 98689, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/8c02e19bccfaf3ef0782a9aa2901e063?s=128&d=identicon&r=PG", "display_name": "Andrew Webb", "link": "https://stackoverflow.com/users/98689/andrew-webb"}, "edited": false, "score": 0, "creation_date": 1511455502, "post_id": 36590549, "comment_id": 81874821, "body": "It&#39;s on the <a href=\"https://github.com/rust-lang/rust-roadmap/issues/24\" rel=\"nofollow noreferrer\">Rust roadmap</a> to improve the situation here."}, {"owner": {"reputation": 28156, "user_id": 1026, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/ea331e778d54effc15b5fbc694bc8232?s=128&d=identicon&r=PG", "display_name": "Nickolay", "link": "https://stackoverflow.com/users/1026/nickolay"}, "edited": false, "score": 0, "creation_date": 1552251278, "post_id": 36590549, "comment_id": 96929191, "body": "And as of Rust 1.26, the situation has improved, see <a href=\"https://stackoverflow.com/a/51111291/1026\">Shepmaster&#39;s answer</a>."}], "answers": [{"tags": [], "owner": {"reputation": 70803, "user_id": 28128, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/4e974a514f0764fdfe99a8915f192002?s=128&d=identicon&r=PG", "display_name": "David Grayson", "link": "https://stackoverflow.com/users/28128/david-grayson"}, "is_accepted": false, "score": 13, "last_activity_date": 1460551859, "last_edit_date": 1460551859, "creation_date": 1460530300, "answer_id": 36590693, "question_id": 36590549, "link": "https://stackoverflow.com/questions/36590549/what-is-the-syntax-to-match-on-a-reference-to-an-enum/36590693#36590693", "title": "What is the syntax to match on a reference to an enum?", "body": "<p>I figured it out thanks to helpful compiler messages:</p>\n\n<pre><code>match self {\n    &amp;Animal::Cat(ref c) =&gt; f.write_str(\"c\"),\n    &amp;Animal::Dog =&gt; f.write_str(\"d\"),\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 4, "creation_date": 1460551844, "post_id": 36592628, "comment_id": 60794752, "body": "Or <code>..</code> to ignore multiple values."}, {"owner": {"reputation": 4093, "user_id": 86381, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/9b9101201d96a4a5eec2cb81c633c3c5?s=128&d=identicon&r=PG", "display_name": "ehdv", "link": "https://stackoverflow.com/users/86381/ehdv"}, "edited": false, "score": 0, "creation_date": 1475011000, "post_id": 36592628, "comment_id": 66766771, "body": "Is there any difference between this and the answer below (<a href=\"http://stackoverflow.com/a/36590693/86381\">stackoverflow.com/a/36590693/86381</a>) where each branch of the match is prefaced by <code>&amp;</code>?"}, {"owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "reply_to_user": {"reputation": 4093, "user_id": 86381, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/9b9101201d96a4a5eec2cb81c633c3c5?s=128&d=identicon&r=PG", "display_name": "ehdv", "link": "https://stackoverflow.com/users/86381/ehdv"}, "edited": false, "score": 0, "creation_date": 1475154495, "post_id": 36592628, "comment_id": 66836786, "body": "@ehdv I wouldn&#39;t think so, but I haven&#39;t compared the generated assembly yet."}, {"owner": {"reputation": 1517, "user_id": 275984, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/620339c024f25dbc2597a9d33c6eef54?s=128&d=identicon&r=PG", "display_name": "b0fh", "link": "https://stackoverflow.com/users/275984/b0fh"}, "edited": false, "score": 5, "creation_date": 1490011684, "post_id": 36592628, "comment_id": 72905762, "body": "I&#39;ve seen at least on one occasion code where the other answer would compile fine, but this one would complain that &quot;cannot move out of borrowed content&quot;."}, {"owner": {"reputation": 1679, "user_id": 267874, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/007a9c64b82a001443ff463ef326366b?s=128&d=identicon&r=PG", "display_name": "Paul-Sebastian Manole", "link": "https://stackoverflow.com/users/267874/paul-sebastian-manole"}, "edited": false, "score": 0, "creation_date": 1579709398, "post_id": 36592628, "comment_id": 105859096, "body": "How do you reference the inner type c in the first match branch arm?"}], "tags": [], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "is_accepted": false, "score": 27, "last_activity_date": 1592266295, "last_edit_date": 1592266295, "creation_date": 1460535905, "answer_id": 36592628, "question_id": 36590549, "link": "https://stackoverflow.com/questions/36590549/what-is-the-syntax-to-match-on-a-reference-to-an-enum/36592628#36592628", "title": "What is the syntax to match on a reference to an enum?", "body": "<p><strong>Edit: Please see Shepmaster's answer for the latest idiom</strong></p>\n\n<p>The idiomatic way would be</p>\n\n<pre><code>match *self {\n    Animal::Cat(ref c) =&gt; f.write_str(\"c\"),\n    Animal::Dog =&gt; f.write_str(\"d\"),\n}\n</code></pre>\n\n<p>You can  use <code>_</code> instead of <code>ref c</code> to silence the \"unused\" warning.</p>\n"}, {"comments": [{"owner": {"reputation": 570, "user_id": 3256073, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a0f9a1e93018776d149054dc2ccbe57f?s=128&d=identicon&r=PG&f=1", "display_name": "hsandt", "link": "https://stackoverflow.com/users/3256073/hsandt"}, "edited": false, "score": 0, "creation_date": 1545841832, "post_id": 51111291, "comment_id": 94709277, "body": "I found a few extra subtleties by playing around:  1. You can keep <code>ref</code> in front of the inner value <code>c</code>, it will do the same as without (as long as you remove the <code>&amp;</code> in front of the enum variant). 2. If you keep <code>&amp;</code> in front of the enum variant <code>Cat</code> but remove <code>ref c</code>, it will try to move/copy the inner value <code>c</code>! For a borrowed content it can&#39;t move out, and will fail to compile. 3. You can also skip <code>&amp;mut</code> and <code>ref mut</code> in <code>&amp;mut Enum::Variant(ref mut value)</code>. You must still write <code>*value = new_value</code>. And sorry for the bad formatting due to comment limitations."}, {"owner": {"reputation": 570, "user_id": 3256073, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a0f9a1e93018776d149054dc2ccbe57f?s=128&d=identicon&r=PG&f=1", "display_name": "hsandt", "link": "https://stackoverflow.com/users/3256073/hsandt"}, "edited": false, "score": 0, "creation_date": 1545842122, "post_id": 51111291, "comment_id": 94709382, "body": "Found an example in the Rust Book (not mut though): <a href=\"https://doc.rust-lang.org/book/ch15-06-reference-cycles.html#reference-cycles-can-leak-memory\" rel=\"nofollow noreferrer\">doc.rust-lang.org/book/&hellip;</a> Listing 15-25"}, {"owner": {"reputation": 531, "user_id": 1824330, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/34b432f35c94a1eae60ee17bdfb9490f?s=128&d=identicon&r=PG", "display_name": "chylli", "link": "https://stackoverflow.com/users/1824330/chylli"}, "edited": false, "score": 0, "creation_date": 1550975467, "post_id": 51111291, "comment_id": 96468811, "body": "But why ? Is there an explanation for that rule ?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 531, "user_id": 1824330, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/34b432f35c94a1eae60ee17bdfb9490f?s=128&d=identicon&r=PG", "display_name": "chylli", "link": "https://stackoverflow.com/users/1824330/chylli"}, "edited": false, "score": 1, "creation_date": 1551019534, "post_id": 51111291, "comment_id": 96477752, "body": "@chylli updated with a link to <a href=\"https://rust-lang.github.io/rfcs/2005-match-ergonomics.html\" rel=\"nofollow noreferrer\">the RFC that make the changes</a>. Is that what you were looking for?"}, {"owner": {"reputation": 1527, "user_id": 5387972, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d6b6d9239d09a67878e860ac414c4970?s=128&d=identicon&r=PG&f=1", "display_name": "Jay", "link": "https://stackoverflow.com/users/5387972/jay"}, "edited": false, "score": 0, "creation_date": 1594274032, "post_id": 51111291, "comment_id": 111069415, "body": "What do we do if we the Dog variant is say Dog(u32), and I want to write the number to f as well in this case?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1527, "user_id": 5387972, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d6b6d9239d09a67878e860ac414c4970?s=128&d=identicon&r=PG&f=1", "display_name": "Jay", "link": "https://stackoverflow.com/users/5387972/jay"}, "edited": false, "score": 1, "creation_date": 1594294361, "post_id": 51111291, "comment_id": 111079069, "body": "@Jay <code>Dog(v) =&gt; write!(f, \u201cblah {}\u201d, v),</code>. <a href=\"https://doc.rust-lang.org/book/ch06-02-match.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/book/ch06-02-match.html</a>"}, {"owner": {"reputation": 1527, "user_id": 5387972, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d6b6d9239d09a67878e860ac414c4970?s=128&d=identicon&r=PG&f=1", "display_name": "Jay", "link": "https://stackoverflow.com/users/5387972/jay"}, "edited": false, "score": 0, "creation_date": 1594312135, "post_id": 51111291, "comment_id": 111088995, "body": "Thanks, apparently my problem was with the <a href=\"https://stackoverflow.com/questions/62819390/difficulty-aggregating-matches-with\">or pipe</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 22, "last_activity_date": 1551019509, "last_edit_date": 1551019509, "creation_date": 1530326543, "answer_id": 51111291, "question_id": 36590549, "link": "https://stackoverflow.com/questions/36590549/what-is-the-syntax-to-match-on-a-reference-to-an-enum/51111291#51111291", "title": "What is the syntax to match on a reference to an enum?", "body": "<p>As of Rust 1.26, the idiomatic way is <em>the way that you originally wrote it</em> <a href=\"https://rust-lang.github.io/rfcs/2005-match-ergonomics.html\" rel=\"noreferrer\">because <code>match</code> ergonomics have been improved</a>:</p>\n\n<pre><code>use std::fmt;\n\npub enum Animal {\n    Cat(String),\n    Dog,\n}\n\nimpl fmt::Display for Animal {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match self {\n            Animal::Cat(_) =&gt; f.write_str(\"c\"),\n            Animal::Dog =&gt; f.write_str(\"d\"),\n        }\n    }\n}\n\nfn main() {\n    let p: Animal = Animal::Cat(\"whiskers\".to_owned());\n    println!(\"{}\", p);\n}\n</code></pre>\n"}], "owner": {"reputation": 70803, "user_id": 28128, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/4e974a514f0764fdfe99a8915f192002?s=128&d=identicon&r=PG", "display_name": "David Grayson", "link": "https://stackoverflow.com/users/28128/david-grayson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 15137, "favorite_count": 9, "accepted_answer_id": 51111291, "answer_count": 3, "score": 38, "last_activity_date": 1592266295, "creation_date": 1460529849, "last_edit_date": 1530326622, "question_id": 36590549, "link": "https://stackoverflow.com/questions/36590549/what-is-the-syntax-to-match-on-a-reference-to-an-enum", "title": "What is the syntax to match on a reference to an enum?", "body": "<p>It seems like every introductory document for Rust's <a href=\"https://doc.rust-lang.org/book/first-edition/enums.html\" rel=\"noreferrer\">enum types</a> explains how to <a href=\"https://doc.rust-lang.org/book/first-edition/match.html\" rel=\"noreferrer\">match</a> on an enum object that you <em>own</em>, but what if you do not own the enum object and you just have a reference to it that you want to match against?  I don't know what the syntax would be.</p>\n\n<p>Here is some code where I attempt to match on a reference to an enum:</p>\n\n<pre><code>use std::fmt;\nuse std::io::prelude::*;\n\npub enum Animal {\n    Cat(String),\n    Dog,\n}\n\nimpl fmt::Display for Animal {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match self {\n            Animal::Cat(c) =&gt; f.write_str(\"c\"),\n            Animal::Dog =&gt; f.write_str(\"d\"),\n        }\n    }\n}\n\nfn main() {\n    let p: Animal = Animal::Cat(\"whiskers\".to_owned());\n    println!(\"{}\", p);\n}\n</code></pre>\n\n<p>The <a href=\"https://play.rust-lang.org/?gist=373dbfb15757f49f65082e29ba724a47&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Rust Playground</a> gives errors on the first two cases of the match when trying to compile it:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:12:13\n   |\n12 |             Animal::Cat(c) =&gt; f.write_str(\"c\"),\n   |             ^^^^^^^^^^^^^^ expected &amp;Animal, found enum `Animal`\n   |\n   = note: expected type `&amp;Animal`\n   = note:    found type `Animal`\n\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:13:13\n   |\n13 |             Animal::Dog =&gt; f.write_str(\"d\"),\n   |             ^^^^^^^^^^^ expected &amp;Animal, found enum `Animal`\n   |\n   = note: expected type `&amp;Animal`\n   = note:    found type `Animal`\n</code></pre>\n\n<p>How can I change that code to get it to compile?  I tried adding ampersands in lots of different places without any luck.  Is it even possible to match on a reference to an enum?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "edited": false, "score": 0, "creation_date": 1460473055, "post_id": 36576464, "comment_id": 60752794, "body": "Thanks for the answer and the link! That&#39;s very helpful"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1460472135, "last_edit_date": 1460472135, "creation_date": 1460471767, "answer_id": 36576464, "question_id": 36575894, "link": "https://stackoverflow.com/questions/36575894/why-can-i-use-the-same-lifetime-label-for-variables-that-have-different-lifetime/36576464#36576464", "title": "Why can I use the same lifetime label for variables that have different lifetimes?", "body": "<blockquote>\n  <p>My understanding of these lifetime labels is that the slice and the individual <code>&amp;strs</code> have the same lifetime.</p>\n</blockquote>\n\n<p>This is a common misconception. It really means that there has to be <strong>a</strong> lifetime that applies to both. When instantiated, the <code>Foo</code> struct's <code>'a</code> corresponds to the lines of the inner block after <code>let v = vec![t];</code> as that is a lifetime that both variables share.</p>\n\n<p>If this flexibility didn't exist, lifetimes would be super painful to use. Variables defined on two lines have different actual lifetimes (the one defined first outlives the one defined second). If the lifetimes had to actually match, we'd always have to define all the variables on the same line!</p>\n\n<p>Some more detailed information is available in <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md#what-variance-is\">RFC #738 \u2014 Variance</a>.</p>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 2, "last_activity_date": 1460549399, "creation_date": 1460549399, "answer_id": 36597921, "question_id": 36575894, "link": "https://stackoverflow.com/questions/36575894/why-can-i-use-the-same-lifetime-label-for-variables-that-have-different-lifetime/36597921#36597921", "title": "Why can I use the same lifetime label for variables that have different lifetimes?", "body": "<p>The syntax <code>'a</code> is actually used in two different situations:</p>\n\n<ul>\n<li>labeling a loop</li>\n<li>indicating a <em>bound</em></li>\n</ul>\n\n<p>The first situation, labeling a loop:</p>\n\n<pre><code>fn main() {\n    'a: loop {\n        println!(\"{}\", 3);\n        break 'a;\n    }\n}\n</code></pre>\n\n<p>Here, <code>'a</code> clearly delineates the lifetime of the loop body, and allows breaking from multiple layers of loops in one fell swoop.</p>\n\n<p>The second, and more similar situation, is using <code>'a</code> to represent a <em>bound</em>:</p>\n\n<pre><code>fn&lt;'a&gt; susbtr(haystack: &amp;'a str, offset: usize) -&gt; &amp;'a str;\n</code></pre>\n\n<p>In this case, the lifetime <code>'a</code> does not represent the actual lifetime of the variable, it represents a <em>bound</em> on the lifetime of the referenced variable and allows <em>tying together</em> the bounds of various variables.</p>\n\n<p>Note that the caller and callee interpret the bound differently:</p>\n\n<ul>\n<li>from the perspective of the caller, <code>'a</code> is an <em>upper-bound</em>, a promise that the return value will live <em>at least as long</em> as the parameter (maybe longer, no guarantee)</li>\n<li>from the perspective of the callee (ie, <code>substr</code>), <code>'a</code> is a <em>lower-bound</em>, a check that any returned value must live <em>at least as long</em> as the parameter (maybe longer, not necessary)</li>\n</ul>\n\n<p>We can have variance since the bound does not represent the actual lifetime, when a single bound is used for multiple lifetimes, the compiler will simply deduce the lowest/highest bound that makes sense for the situation:</p>\n\n<ul>\n<li>the caller gets the lowest <em>upper-bound</em> feasible (ie, the least guarantee)</li>\n<li>the caller gets the highest <em>lower-bound</em> feasible (ie, the least constraint)</li>\n</ul>\n\n<p>For example:</p>\n\n<pre><code>fn&lt;'b&gt; either(one: &amp;'b str, two: &amp;'b str, flag: bool) -&gt; &amp;'b str {\n    if flag { one } else { two }\n}\n</code></pre>\n\n<p>can be called with:</p>\n\n<pre><code>fn&lt;'a&gt; call(o: &amp;'a str, flag: bool) -&gt; &amp;'a str {\n    either(o, \"Hello, World\", flag)\n}\n</code></pre>\n\n<p>Here, the lifetime of <code>o</code> is unknown (some <code>'a</code>) whilst the lifetime of <code>\"Hello, World\"</code> is known (<code>'static</code>), <code>'static</code> is by definition the greater of the lifetimes (it lives for all the program).</p>\n\n<ul>\n<li>the caller of <code>call</code> only knows that the return value lives at least as long as <code>o</code></li>\n<li><code>call</code> must guarantee this, it supplies <code>o</code> and <code>\"Hello, World\"</code> to <code>either</code> where <code>'b</code> is deduced to be the lowest bound between <code>'a</code> and <code>'static</code> (thus <code>'a</code>)</li>\n<li><code>either</code> simply must return something that lives as long as either one of its arguments; it's unaware that their lifetime may differ, and cares not</li>\n</ul>\n"}], "owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 122, "favorite_count": 0, "accepted_answer_id": 36576464, "answer_count": 2, "score": 1, "last_activity_date": 1460549399, "creation_date": 1460470453, "last_edit_date": 1460471961, "question_id": 36575894, "link": "https://stackoverflow.com/questions/36575894/why-can-i-use-the-same-lifetime-label-for-variables-that-have-different-lifetime", "title": "Why can I use the same lifetime label for variables that have different lifetimes?", "body": "<p>Why does this code compile? </p>\n\n<pre><code>#[derive(Debug)]\npub struct Foo&lt;'a&gt; {\n    pub x: &amp;'a [&amp;'a str],\n}\n\nfn main() {\n    let s = \"s\".to_string();\n    let t: &amp;str = s.as_ref();\n    {\n        let v = vec![t];\n        let foo = Foo { x: &amp;v[..] };\n        println!(\"{:?}\", &amp;foo);\n    }\n}\n</code></pre>\n\n<p>In my <code>Foo</code> struct, my <code>x</code> field contains a slice of <code>&amp;strs</code>. My understanding of these lifetime labels is that the slice and the individual <code>&amp;strs</code> have the same lifetime.</p>\n\n<p>However, in my example the <code>&amp;str</code> <code>t</code> (in the outer block) does not have the same lifetime as the container slice (in the inner block).</p>\n"}, {"tags": ["rust", "lifetime", "borrowing"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460445161, "post_id": 36565833, "comment_id": 60731668, "body": "your code example is too simple for us to give you good advice. You can simply put the <code>let n1 = graph.add_node(111);</code> into a block and then your code works, but I&#39;m fairly sure that&#39;s not what you want."}, {"owner": {"reputation": 1204, "user_id": 3241447, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/unNbh.jpg?s=128&g=1", "display_name": "Haru Atari", "link": "https://stackoverflow.com/users/3241447/haru-atari"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460445448, "post_id": 36565833, "comment_id": 60731870, "body": "@ker It&#39;s not example. It&#39;s training project. I want to create a simple graph. But i can&#39;t add some nodes to it."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460445894, "post_id": 36565833, "comment_id": 60732149, "body": "Couldn&#39;t you simply return the <code>Key</code> instead of a <code>&amp;Node</code>? It&#39;s not like you need anything but the key to create edges"}], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 4, "last_activity_date": 1460515612, "creation_date": 1460515612, "answer_id": 36587655, "question_id": 36565833, "link": "https://stackoverflow.com/questions/36565833/how-should-i-restructure-my-graph-code-to-avoid-an-cannot-borrow-variable-as-mu/36587655#36587655", "title": "How should I restructure my graph code to avoid an &quot;Cannot borrow variable as mutable more than once at a time&quot; error?", "body": "<p>By returning a <code>&amp;Node&lt;T&gt;</code> from <code>add_node</code>, you are effectively locking the whole <code>Graph&lt;T&gt;</code> object, because you're borrowing from it. And for a good reason; try running this <code>main</code>:</p>\n\n<pre><code>fn main() {\n    let mut graph = Graph::&lt;i32&gt;::new();\n    let n1 = graph.add_node(111) as *const _;\n    let mut inserts = 0;\n    loop {\n        inserts += 1;\n        graph.add_node(222);\n        let n1bis = graph.list.get(&amp;0).unwrap() as *const _;\n        if n1 != n1bis {\n            println!(\"{:p} {:p} ({} inserts)\", n1, n1bis, inserts);\n            break;\n        }\n    }\n}\n</code></pre>\n\n<p>Here's a possible output from this program:</p>\n\n<pre><code>0x7f86c6c302e0 0x7f86c6c3a6e0 (29 inserts)\n</code></pre>\n\n<p>This program adds a first node and stores its address as a raw pointer (raw pointers don't have a lifetime parameter, so the borrow on <code>Graph</code> is released). Then, it adds more nodes, one at a time, then fetches the address of the first node again. If the address of the first node changed, it prints both addresses as well as the number of additional nodes that were inserted into the graph.</p>\n\n<p><code>HashMap</code> uses a randomized hash, so the number of inserts will vary on each execution. However, it <em>will</em> eventually need to reallocate memory to store more entries, so eventually, the address of the nodes in the map change. If you tried to dereference an old pointer (such as <code>n1</code>) after this happened, then you'd be accessing freed memory, which may return garbage data or cause an error (usually a segmentation fault).</p>\n\n<p>Knowing all this, it should be clear that <code>add_node</code> should not return a <code>&amp;Node&lt;T&gt;</code>. Here are a few alternatives:</p>\n\n<ul>\n<li>Make <code>add_node</code> return nothing, or return the <code>Key</code>, and provide a separate method to obtain a <code>&amp;Node&lt;T&gt;</code> given a key.</li>\n<li>Wrap your nodes in <a href=\"http://doc.rust-lang.org/stable/std/rc/struct.Rc.html\" rel=\"nofollow\"><code>Rc&lt;T&gt;</code></a> or <a href=\"http://doc.rust-lang.org/stable/std/sync/struct.Arc.html\" rel=\"nofollow\"><code>Arc&lt;T&gt;</code></a>. That is, instead of <code>list</code> being a <code>HashMap&lt;Key, Node&lt;T&gt;&gt;</code>, it would be a <code>HashMap&lt;Key, Rc&lt;Node&lt;T&gt;&gt;&gt;</code>. You can <code>clone()</code> an <code>Rc</code> or <code>Arc</code> to copy the pointer and increment the reference count; store one copy in the <code>HashMap</code> and return the other copy from <code>add_node</code>.\n\n<ul>\n<li>If you also need to mutate the nodes while retaining the ability to mutate the graph, you may need to combine <code>Rc</code> with <a href=\"http://doc.rust-lang.org/stable/std/cell/struct.RefCell.html\" rel=\"nofollow\"><code>RefCell</code></a>, or <code>Arc</code> with <a href=\"http://doc.rust-lang.org/stable/std/sync/struct.Mutex.html\" rel=\"nofollow\"><code>Mutex</code></a>.</li>\n</ul></li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1512313275, "creation_date": 1512313275, "answer_id": 47619654, "question_id": 36565833, "link": "https://stackoverflow.com/questions/36565833/how-should-i-restructure-my-graph-code-to-avoid-an-cannot-borrow-variable-as-mu/47619654#47619654", "title": "How should I restructure my graph code to avoid an &quot;Cannot borrow variable as mutable more than once at a time&quot; error?", "body": "<p>I solved problem by using <code>std::rc::Rc</code>:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::rc::Rc;\n\ntype Key = usize;\ntype Weight = usize;\n\n#[derive(Debug)]\npub struct Node&lt;T&gt; {\n    key: Key,\n    value: T,\n}\nimpl&lt;T&gt; Node&lt;T&gt; {\n    fn new(key: Key, value: T) -&gt; Self {\n        Node {\n            key: key,\n            value: value,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct Graph&lt;T&gt; {\n    map: HashMap&lt;Key, HashMap&lt;Key, Weight&gt;&gt;,\n    list: HashMap&lt;Key, Rc&lt;Node&lt;T&gt;&gt;&gt;, // &lt;-- Changed\n    next_key: Key,\n}\nimpl&lt;T&gt; Graph&lt;T&gt; {\n    pub fn new() -&gt; Self {\n        Graph {\n            map: HashMap::new(),\n            list: HashMap::new(),\n            next_key: 0,\n        }\n    }\n\n    pub fn add_node(&amp;mut self, value: T) -&gt; Rc&lt;Node&lt;T&gt;&gt; {\n        // &lt;-- Changed\n        let key = self.get_next_key();\n        let node = Rc::new(Node::new(key, value)); // &lt;-- Changed\n        self.list.insert(key, node.clone()); // &lt;-- Changed\n        self.map.insert(key, HashMap::new());\n        node\n    }\n\n    fn get_next_key(&amp;mut self) -&gt; Key {\n        let key = self.next_key;\n        self.next_key += 1;\n        key\n    }\n}\n\nfn main() {\n    let mut graph = Graph::&lt;i32&gt;::new();\n    let n1 = graph.add_node(111);\n    let n2 = graph.add_node(222);\n}\n</code></pre>\n"}], "owner": {"reputation": 1204, "user_id": 3241447, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/unNbh.jpg?s=128&g=1", "display_name": "Haru Atari", "link": "https://stackoverflow.com/users/3241447/haru-atari"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 402, "favorite_count": 0, "accepted_answer_id": 36587655, "answer_count": 2, "score": 2, "last_activity_date": 1544287297, "creation_date": 1460444531, "last_edit_date": 1544287297, "question_id": 36565833, "link": "https://stackoverflow.com/questions/36565833/how-should-i-restructure-my-graph-code-to-avoid-an-cannot-borrow-variable-as-mu", "title": "How should I restructure my graph code to avoid an &quot;Cannot borrow variable as mutable more than once at a time&quot; error?", "body": "<p>I have a simple graph that successfully compiles:</p>\n\n<pre><code>use std::collections::HashMap;\n\ntype Key = usize;\ntype Weight = usize;\n\n#[derive(Debug)]\npub struct Node&lt;T&gt; {\n    key: Key,\n    value: T,\n}\nimpl&lt;T&gt; Node&lt;T&gt; {\n    fn new(key: Key, value: T) -&gt; Self {\n        Node {\n            key: key,\n            value: value,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct Graph&lt;T&gt; {\n    map: HashMap&lt;Key, HashMap&lt;Key, Weight&gt;&gt;,\n    list: HashMap&lt;Key, Node&lt;T&gt;&gt;,\n    next_key: Key,\n}\nimpl&lt;T&gt; Graph&lt;T&gt; {\n    pub fn new() -&gt; Self {\n        Graph {\n            map: HashMap::new(),\n            list: HashMap::new(),\n            next_key: 0,\n        }\n    }\n    pub fn add_node(&amp;mut self, value: T) -&gt; &amp;Node&lt;T&gt; {\n        let node = self.create_node(value);\n        node\n    }\n\n    fn create_node(&amp;mut self, value: T) -&gt; &amp;Node&lt;T&gt; {\n        let key = self.get_next_key();\n        let node = Node::new(key, value);\n        self.list.insert(key, node);\n        self.map.insert(key, HashMap::new());\n        self.list.get(&amp;key).unwrap()\n    }\n\n    fn get_next_key(&amp;mut self) -&gt; Key {\n        let key = self.next_key;\n        self.next_key += 1;\n        key\n    }\n}\n</code></pre>\n\n<p>But it fails to compile when I use it:</p>\n\n<pre><code>fn main() {\n    let mut graph = Graph::&lt;i32&gt;::new();\n    let n1 = graph.add_node(111);\n    let n2 = graph.add_node(222);\n}\n</code></pre>\n\n<p>Error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0499]: cannot borrow `graph` as mutable more than once at a time\n  --&gt; src/main.rs:57:14\n   |\n56 |     let n1 = graph.add_node(111);\n   |              ----- first mutable borrow occurs here\n57 |     let n2 = graph.add_node(222);\n   |              ^^^^^ second mutable borrow occurs here\n58 | }\n   | - first borrow ends here\n</code></pre>\n\n<p>I have seen all similar questions. I know that is failing because method <code>Graph::add_node()</code> uses <code>&amp;mut self</code>. In all similar questions, the general answer is \"restructure your code\". I can't understand what should I do? How should I restructure this code?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1460446924, "post_id": 36565194, "comment_id": 60732857, "body": "This is <i>really</i> strange. <a href=\"https://gist.github.com/netvl/4c7afffc7ed8ec72717acd3e8617d1c0\" rel=\"nofollow noreferrer\">This</a> program contains only your structure, and it compiles just fine. Try to extract your struct in a separate module, with as little <code>use</code>s as possible, and check whether it compiles. It also <i>may</i> be some interference with dependency crates, although as far as I understand, Rust trait rules were designed exactly to avoid problems like this."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 2, "creation_date": 1460452777, "post_id": 36565194, "comment_id": 60736768, "body": "<a href=\"https://play.rust-lang.org/?gist=4855336da123370b3fdd9ef689917453&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">MCVE</a> This is a hygiene bug in the expansion of <code>derive(RustcEncodable)</code>."}, {"owner": {"reputation": 345, "user_id": 1041831, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/63542ac25e09115c3ba823097a1c825f?s=128&d=identicon&r=PG", "display_name": "NougatRillettes", "link": "https://stackoverflow.com/users/1041831/nougatrillettes"}, "edited": false, "score": 0, "creation_date": 1460453894, "post_id": 36565194, "comment_id": 60737570, "body": "Thanks, reported <a href=\"https://github.com/rust-lang-nursery/rustc-serialize/issues/151\" rel=\"nofollow noreferrer\">here</a>."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1460472874, "post_id": 36565194, "comment_id": 60752650, "body": "and fixed <a href=\"https://github.com/rust-lang/rust/pull/32908\" rel=\"nofollow noreferrer\">here</a>"}], "answers": [{"tags": [], "owner": {"reputation": 345, "user_id": 1041831, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/63542ac25e09115c3ba823097a1c825f?s=128&d=identicon&r=PG", "display_name": "NougatRillettes", "link": "https://stackoverflow.com/users/1041831/nougatrillettes"}, "is_accepted": false, "score": 0, "last_activity_date": 1460516302, "creation_date": 1460516302, "answer_id": 36587759, "question_id": 36565194, "link": "https://stackoverflow.com/questions/36565194/multiple-impl-candidate-while-deriving-an-instance-in-rust/36587759#36587759", "title": "Multiple impl candidate while deriving an instance in Rust", "body": "<p>As said under the comments on the original post, this is actually <a href=\"https://github.com/rust-lang-nursery/rustc-serialize/issues/151\" rel=\"nofollow\">bug</a>. A fix is now <a href=\"https://github.com/rust-lang/rust/pull/32908\" rel=\"nofollow\">available</a>.</p>\n"}], "owner": {"reputation": 345, "user_id": 1041831, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/63542ac25e09115c3ba823097a1c825f?s=128&d=identicon&r=PG", "display_name": "NougatRillettes", "link": "https://stackoverflow.com/users/1041831/nougatrillettes"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 263, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1460516302, "creation_date": 1460442633, "last_edit_date": 1460464610, "question_id": 36565194, "link": "https://stackoverflow.com/questions/36565194/multiple-impl-candidate-while-deriving-an-instance-in-rust", "title": "Multiple impl candidate while deriving an instance in Rust", "body": "<p>When trying to use <code>rustc-serialize</code> to (d)e(n)code a <code>struct</code> containing two <code>String</code>s in Rust 1.7, the compiler complains that there are too many impl candidates and doesn't know which one to choose.</p>\n\n<p>The code:</p>\n\n<pre><code>#[derive(RustcDecodable, RustcEncodable, Debug)]\nstruct gonet {\n    ip: String,\n    mask: String,\n}\n</code></pre>\n\n<p>The complaint:</p>\n\n<pre><code>src/bin/measurer.rs:18:5: 18:15 error: multiple applicable items in scope [E0034]\nsrc/bin/measurer.rs:18     ip: String,\n                           ^~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\nsrc/bin/measurer.rs:18:5: 18:15 help: run `rustc --explain E0034` to see a detailed explanation\nsrc/bin/measurer.rs:18:5: 18:15 note: candidate #1 is defined in an impl of the trait `rustc_serialize::serialize::Encodable` for the type `str`\nsrc/bin/measurer.rs:18     ip: String,\n                           ^~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\nsrc/bin/measurer.rs:18:5: 18:15 note: candidate #2 is defined in an impl of the trait `rustc_serialize::serialize::Encodable` for the type `collections::string::String`\nsrc/bin/measurer.rs:18     ip: String,\n                           ^~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\nsrc/bin/measurer.rs:18:5: 18:15 note: candidate #3 is defined in an impl of the trait `rustc_serialize::serialize::Encodable` for the type `&amp;_`\nsrc/bin/measurer.rs:18     ip: String,\n                           ^~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\nsrc/bin/measurer.rs:18:5: 18:15 note: candidate #4 is defined in an impl of the trait `radix_trie::keys::TrieKey` for the type `_`\nsrc/bin/measurer.rs:18     ip: String,\n                           ^~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\nsrc/bin/measurer.rs:19:5: 19:17 error: multiple applicable items in scope [E0034]\nsrc/bin/measurer.rs:19     mask: String,\n                           ^~~~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\nsrc/bin/measurer.rs:19:5: 19:17 help: run `rustc --explain E0034` to see a detailed explanation\nsrc/bin/measurer.rs:19:5: 19:17 note: candidate #1 is defined in an impl of the trait `rustc_serialize::serialize::Encodable` for the type `str`\nsrc/bin/measurer.rs:19     mask: String,\n                           ^~~~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\nsrc/bin/measurer.rs:19:5: 19:17 note: candidate #2 is defined in an impl of the trait `rustc_serialize::serialize::Encodable` for the type `collections::string::String`\nsrc/bin/measurer.rs:19     mask: String,\n                           ^~~~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\nsrc/bin/measurer.rs:19:5: 19:17 note: candidate #3 is defined in an impl of the trait `rustc_serialize::serialize::Encodable` for the type `&amp;_`\nsrc/bin/measurer.rs:19     mask: String,\n                           ^~~~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\nsrc/bin/measurer.rs:19:5: 19:17 note: candidate #4 is defined in an impl of the trait `radix_trie::keys::TrieKey` for the type `_`\nsrc/bin/measurer.rs:19     mask: String,\n                           ^~~~~~~~~~~~\nsrc/bin/measurer.rs:16:26: 16:40 note: in this expansion of #[derive_RustcEncodable] (defined in src/bin/measurer.rs)\n</code></pre>\n\n<p>My code also use the <a href=\"https://michaelsproul.github.io/rust_radix_trie/src/radix_trie/keys.rs.html#55\" rel=\"nofollow\"><code>TrieKey</code></a> trait from the <code>radix_tree</code> crate, which also has an <code>encode()</code> method.</p>\n\n<p>I'd like to have both traits in scope as I use them both, but they conflict, so how can I specify which trait of <code>String</code> to use for deriving (if it is even possible)?</p>\n\n<p>Not <code>use</code>ing <code>TrieKey</code> works, but I'd like a solution that allows me to <code>use</code> both.</p>\n"}, {"tags": ["hash", "rust", "hashset"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1460428882, "post_id": 36562686, "comment_id": 60725665, "body": "Minor nits: <code>Vec&lt;_&gt;</code> and <code>for s in a</code>."}, {"owner": {"reputation": 559, "user_id": 2358968, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/c924ddc496c7ec283fdbfb8f2c594539?s=128&d=identicon&r=PG", "display_name": "franleplant", "link": "https://stackoverflow.com/users/2358968/franleplant"}, "edited": false, "score": 0, "creation_date": 1460469311, "post_id": 36562686, "comment_id": 60749659, "body": "Thanks a lot Dogbert! Im going to mark your answer as the correct one. Here is a little working example using your code <a href=\"https://play.rust-lang.org/?gist=faad68f658e11f94ada25b6b0e8704f4&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>  I will be reading more about BTreeSet to see if it fits my use case, thanks a lot!"}, {"owner": {"reputation": 559, "user_id": 2358968, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/c924ddc496c7ec283fdbfb8f2c594539?s=128&d=identicon&r=PG", "display_name": "franleplant", "link": "https://stackoverflow.com/users/2358968/franleplant"}, "edited": false, "score": 1, "creation_date": 1460471743, "post_id": 36562686, "comment_id": 60751658, "body": "Dogbert: I&#39;ve tested BTreeSet and they are <i>exactly</i> what I was looking for. Because the set&#39;s Im dealing with require ordering in some parts of my code so they fit naturally. Also, I dont need to implement the Hash trait with which make things even easier. Thanks a lot!"}], "tags": [], "owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "is_accepted": true, "score": 3, "last_activity_date": 1460428736, "creation_date": 1460428736, "answer_id": 36562686, "question_id": 36562419, "link": "https://stackoverflow.com/questions/36562419/hashset-as-key-for-other-hashset/36562686#36562686", "title": "HashSet as key for other HashSet", "body": "<p>There were several problems with your code, the main ones being that you were trying to access methods on <code>HashSet</code> by calling them on your newtype wrapper. You need to call them on the <code>HashSet</code> directly by replacing <code>self</code> with <code>self.0</code>. Here's the final working code:</p>\n\n<pre><code>use std::collections::{HashMap,HashSet};\nuse std::hash::{Hash,Hasher};\n\ntype State = String;\nstruct StateSet(HashSet&lt;State&gt;);\n\nimpl PartialEq for StateSet {\n    fn eq(&amp;self, other: &amp;StateSet) -&gt; bool {\n        self.0.is_subset(&amp;other.0) &amp;&amp; other.0.is_subset(&amp;self.0) \n    }\n}\n\nimpl Eq for StateSet {}\n\nimpl Hash for StateSet {\n    fn hash&lt;H&gt;(&amp;self, state: &amp;mut H) where H: Hasher {\n        let mut a: Vec&lt;&amp;State&gt; = self.0.iter().collect();\n        a.sort();\n        for s in a.iter() {\n            s.hash(state);\n        }\n    }\n\n}\n\nfn main() {\n    let hmap: HashSet&lt;StateSet&gt; = HashSet::new(); \n}\n</code></pre>\n\n<p>Also, I would highly recommend you to use <a href=\"https://doc.rust-lang.org/std/collections/struct.BTreeSet.html\" rel=\"nofollow\"><code>BTreeSet</code></a> here, which implements <code>Hash</code> as it stores the elements in a sorted order. Its <code>Hash</code> implementation should definitely be faster than your implementation which does an <code>O(n log(n))</code> sort of all items.</p>\n"}], "owner": {"reputation": 559, "user_id": 2358968, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/c924ddc496c7ec283fdbfb8f2c594539?s=128&d=identicon&r=PG", "display_name": "franleplant", "link": "https://stackoverflow.com/users/2358968/franleplant"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 531, "favorite_count": 0, "accepted_answer_id": 36562686, "answer_count": 1, "score": 2, "last_activity_date": 1460428736, "creation_date": 1460426868, "last_edit_date": 1495539911, "question_id": 36562419, "link": "https://stackoverflow.com/questions/36562419/hashset-as-key-for-other-hashset", "title": "HashSet as key for other HashSet", "body": "<p>Im trying to use a <code>HashSet&lt;String&gt;</code> as a key for other <code>HashSet</code>.\nI have found <a href=\"https://stackoverflow.com/questions/27828487/hashmap-with-hashset-as-key\">this question and answer</a> that points out to implement the <code>Hash</code> trait for <code>HashSet&lt;String&gt;</code>, but I couldn't make my specific case to work.</p>\n\n<p>My case is luckily more bound so what I need is:</p>\n\n<ul>\n<li>Implement the <code>hash</code> trait <strong>only</strong> for the type <code>HashSet&lt;String&gt;</code></li>\n<li>The hashing should be very simple for now:</li>\n</ul>\n\n<p>The set <code>{\"q3\", \"q1\", \"q2\"}</code> should be hashed as a simple ordered, joined string version of it, something like <code>hash(\"q1-q2-q3\")</code>. Obtaining <code>\"q1-q2-q3\"</code> is not a problem but using it inside a <code>hash</code> throws all sort of errors I could not deal with. </p>\n\n<p>This is my attempt of implementation, but it doesn't work. I think that the <code>StateSet</code> wrapper is not the right way of doing it, because I lose all the important <code>HashSet</code> methods</p>\n\n<pre><code>use std::collections::{HashMap,HashSet};\nuse std::hash::{Hash,Hasher};\n\ntype State = String;\nstruct StateSet(HashSet&lt;State&gt;);\n\nimpl PartialEq for StateSet {\n    fn eq(&amp;self, other: &amp;StateSet) -&gt; bool {\n        self.is_subset(&amp;other) &amp;&amp; other.is_subset(&amp;self) \n    }\n}\n\nimpl Eq for StateSet {}\n\nimpl Hash for StateSet {\n    fn hash&lt;H&gt;(&amp;self, state: &amp;mut H) where H: Hasher {\n        let a: Vec&lt;State&gt; = self.iter().collect();\n        a.sort();\n        for s in a.iter() {\n            s.hash(state);\n        }\n    }\n\n}\n\nfn main() {\n    let hmap: HashSet&lt;StateSet&gt; = HashSet::new(); \n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=8a2b74b444d3e3ad652f77487b235d55&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">playground</a>)</p>\n"}, {"tags": ["rust", "calling-convention"], "answers": [{"comments": [{"owner": {"reputation": 43226, "user_id": 61342, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/3e8d217e0ecf6db31de80b698726a50a?s=128&d=identicon&r=PG", "display_name": "\u0141ukasz Lew", "link": "https://stackoverflow.com/users/61342/%c5%81ukasz-lew"}, "edited": false, "score": 0, "creation_date": 1460427501, "post_id": 36562409, "comment_id": 60725289, "body": "I agree on 2. But this seems like type-checking level, so after type-checking - can the code-generation be identical?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 43226, "user_id": 61342, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/3e8d217e0ecf6db31de80b698726a50a?s=128&d=identicon&r=PG", "display_name": "\u0141ukasz Lew", "link": "https://stackoverflow.com/users/61342/%c5%81ukasz-lew"}, "edited": false, "score": 0, "creation_date": 1460442988, "post_id": 36562409, "comment_id": 60730390, "body": "@\u0141ukaszLew: Yes, although whether it <i>does</i> is another issue entirely :)"}], "tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": true, "score": 11, "last_activity_date": 1460426847, "creation_date": 1460426847, "answer_id": 36562409, "question_id": 36562262, "link": "https://stackoverflow.com/questions/36562262/why-does-rust-have-both-call-by-value-and-call-by-reference/36562409#36562409", "title": "Why does Rust have both call by value and call by reference?", "body": "<p>Two things:</p>\n\n<ol>\n<li>Rust will transform certain pass-by-value calls into pass-by-reference, based on a similar heuristic.</li>\n<li>Pass-by-value indicates ownership transfer, while pass-by-reference indicates borrowing. These are very different, and totally orthogonal from the asm-level concern you're asking about.</li>\n</ol>\n\n<p>In other words, in Rust, these two forms have different semantics. That doesn't preclude also doing the optimization, though.</p>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1460429305, "post_id": 36562445, "comment_id": 60725796, "body": "You do not seem to be compiling with optimizations. Using <a href=\"https://play.rust-lang.org/?gist=6fd877dbbaa0cded95220a00afc1b6e2&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">this version of your code</a> (note all the gyrations to prevent the optimizer from removing the function entirely) and <i>compiling in release mode</i>, both functions compile down to the assembly <code>leaq\t1(%rdi), %rax; retq</code>. Note all the junk about pushing and popping registers has been optimized away."}, {"owner": {"reputation": 3504, "user_id": 861306, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6e7554bdaabd25dbf90752e4233b284f?s=128&d=identicon&r=PG", "display_name": "reinerp", "link": "https://stackoverflow.com/users/861306/reinerp"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460432517, "post_id": 36562445, "comment_id": 60726663, "body": "You&#39;re right, in optimized mode they become the same. I&#39;ve now changed to a slightly more involved example which shows different behavior."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460508986, "post_id": 36562445, "comment_id": 60772015, "body": "With the most recent change, you aren&#39;t comparing apples-to-apples. <a href=\"https://play.rust-lang.org/?gist=02d1017d548d2d5ea6ee0cb6cf25a511&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Checking the size of the values</a> shows that a tuple of two <code>u64</code> is 16 bytes, the reference is 8 bytes. It&#39;s entirely possible that the optimizer has decided that 8 bytes is better than 16."}], "tags": [], "owner": {"reputation": 3504, "user_id": 861306, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6e7554bdaabd25dbf90752e4233b284f?s=128&d=identicon&r=PG", "display_name": "reinerp", "link": "https://stackoverflow.com/users/861306/reinerp"}, "is_accepted": false, "score": 0, "last_activity_date": 1460432464, "last_edit_date": 1460432464, "creation_date": 1460427025, "answer_id": 36562445, "question_id": 36562262, "link": "https://stackoverflow.com/questions/36562262/why-does-rust-have-both-call-by-value-and-call-by-reference/36562445#36562445", "title": "Why does Rust have both call by value and call by reference?", "body": "<p>[<strong>Edited</strong>: changed exampled to work in release mode]</p>\n\n<p>It isn't syntactic sugar, as one can see by looking at the generated code.</p>\n\n<p>Given these functions:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn by_value(v: (u64, u64)) -&gt; u64 {\n  v.0 + v.1\n}\n\nfn by_ref(v: &amp;(u64, u64)) -&gt; u64 {\n  v.0 + v.1\n}\n</code></pre>\n\n<p>then if one was syntactic sugar for another, we'd expect them to generate identical assembly code, or at least identical calling conventions. But actually, we find that <code>by_ref</code> passes <code>v</code> in the <code>rdi</code> and <code>rsi</code> registers, whereas <code>by_value</code> passes a pointer to <code>v</code> in the <code>rdi</code> register and has to follow that pointer to get the value: (<a href=\"https://play.rust-lang.org/?gist=46f628468f8d2db9728f221417ed570f&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">see details</a>, use release mode):</p>\n\n<pre><code>by_value:\n  movq  8(%rdi), %rax\n  addq  (%rdi), %rax\n  retq\n\nby_ref:\n  leaq  (%rdi,%rsi), %rax\n  retq\n</code></pre>\n"}], "owner": {"reputation": 43226, "user_id": 61342, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/3e8d217e0ecf6db31de80b698726a50a?s=128&d=identicon&r=PG", "display_name": "\u0141ukasz Lew", "link": "https://stackoverflow.com/users/61342/%c5%81ukasz-lew"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1372, "favorite_count": 0, "accepted_answer_id": 36562409, "answer_count": 2, "score": 3, "last_activity_date": 1460432464, "creation_date": 1460425945, "last_edit_date": 1460429483, "question_id": 36562262, "link": "https://stackoverflow.com/questions/36562262/why-does-rust-have-both-call-by-value-and-call-by-reference", "title": "Why does Rust have both call by value and call by reference?", "body": "<p>Some languages, like Haskell, make no distinction between pass-by-value and pass-by-reference. The compiler can then approximately choose the most efficient calling convention with a heuristic. One example heuristic would be for the Linux x64 ABI: if the size of parameter is greater than 16 bytes, pass a pointer to the stack otherwise pass the value in registers.  </p>\n\n<p>What is the advantage of keeping both notions of pass-by-value and pass-by-reference (non-mutable of course) in Rust and forcing the user to choose?  </p>\n\n<p>Could it be the case that pass-by-value is syntactic sugar for pass-by-reference + copy if the value is seen to be modified?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "edited": false, "score": 3, "creation_date": 1460402935, "post_id": 36557412, "comment_id": 60715461, "body": "In the case of <code>String</code>, you can <code>mem::replace</code> an empty string into the field, and use the result to form the new variant. Just a few moves. But this only works for types that have a cheap form like empty strings."}, {"owner": {"reputation": 5397, "user_id": 1178806, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f8f0734a3d7563e5504433dbef483472?s=128&d=identicon&r=PG", "display_name": "Vlad Frolov", "link": "https://stackoverflow.com/users/1178806/vlad-frolov"}, "edited": false, "score": 1, "creation_date": 1548959389, "post_id": 36557412, "comment_id": 95742037, "body": "FYI, I have <a href=\"https://github.com/rust-lang/rfcs/pull/2490#issuecomment-459448752\" rel=\"nofollow noreferrer\">proposed <code>std::mem::replace_with</code></a>, which should help in situations like this."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 17, "last_activity_date": 1604332881, "last_edit_date": 1604332881, "creation_date": 1460403446, "answer_id": 36557734, "question_id": 36557412, "link": "https://stackoverflow.com/questions/36557412/change-enum-variant-while-moving-the-field-to-the-new-variant/36557734#36557734", "title": "Change enum variant while moving the field to the new variant", "body": "<blockquote>\n<p>This doesn't work because we can't move <code>s</code> from <code>&amp;mut X</code>.</p>\n</blockquote>\n<p>Then don't do that... take the struct by value and return a new one:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>enum X {\n    X1(String),\n    X2(String),\n}\n\nfn increment_x(x: X) -&gt; X {\n    match x {\n        X::X1(s) =&gt; X::X2(s),\n        X::X2(s) =&gt; X::X1(s),\n    }\n}\n</code></pre>\n<p>Ultimately, the compiler is protecting you because if you <em>could</em> move the string out of the enumeration, then it would be in some half-constructed state. Who would be responsible for freeing the string if the function were to panic at that exact moment? Should it free the string in the enum or the string in the local variable? It can't be both as a double-free is a memory-safety issue.</p>\n<p>If you <strong>had</strong> to implement it on a mutable reference, you could store a dummy value in there temporarily:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>use std::mem;\n\nfn increment_x_inline(x: &amp;mut X) {\n    let old = mem::replace(x, X::X1(String::new()));\n    *x = increment_x(old);\n}\n</code></pre>\n<p>Creating an empty <code>String</code> isn't too bad (it's just a few pointers, no heap allocation), but it's not always possible. In that case, you can use <code>Option</code>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>fn increment_x_inline(x: &amp;mut Option&lt;X&gt;) {\n    let old = x.take();\n    *x = old.map(increment_x);\n}\n</code></pre>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/27098694/155423\">How can I swap in a new value for a field in a mutable reference to a structure?</a></li>\n<li><a href=\"https://stackoverflow.com/q/29570781/155423\">Temporarily move out of borrowed content</a></li>\n<li><a href=\"https://stackoverflow.com/q/52031002/155423\">How do I move out of a struct field that is an Option?</a></li>\n</ul>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1500130839, "post_id": 45119209, "comment_id": 77209998, "body": "You have to be <b>very careful</b> here. Any panic that happens between <code>mem::uninitialized()</code> and <code>mem::forget</code> will allow the uninitialized value to leak out to the rest of the program. In this example, <i>I</i> don&#39;t see such a possibility. However, it&#39;s very likely that someone modifies the example to be able to call code that can panic. FWIW, I&#39;d have <a href=\"https://play.integer32.com/?gist=46b4233e57b243819bf0ef2bd1cda799&amp;version=stable\" rel=\"nofollow noreferrer\">extracted the second <code>mem::replace</code></a>."}, {"owner": {"reputation": 3653, "user_id": 786102, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/15fbc7eac0e190a249d7495cc9cdf156?s=128&d=identicon&r=PG", "display_name": "kralyk", "link": "https://stackoverflow.com/users/786102/kralyk"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1500289857, "post_id": 45119209, "comment_id": 77253931, "body": "Well obviously you need to be very careful with <code>unsafe</code> code no matter what. I needed to do this in a performance-critical path so <code>unsafe</code> was the way to go. If someone wants to insert some non-trivial / potentially panicking code in there, they should make a &quot;forgetting object&quot;, ie. one that stores the interim object and forgets it on <code>drop()</code>."}, {"owner": {"reputation": 5397, "user_id": 1178806, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f8f0734a3d7563e5504433dbef483472?s=128&d=identicon&r=PG", "display_name": "Vlad Frolov", "link": "https://stackoverflow.com/users/1178806/vlad-frolov"}, "edited": false, "score": 0, "creation_date": 1548959685, "post_id": 45119209, "comment_id": 95742178, "body": "While I completely agree that one should always be very careful with unsafe, this specific use of <code>uninitialized</code> gets compiled out in release mode and the &quot;toggle&quot; operation gets applied in-place. Yet, I would love to see a safe implementation for this intent, which is why I <a href=\"https://github.com/rust-lang/rfcs/pull/2490#issuecomment-459448752\" rel=\"nofollow noreferrer\">proposed <code>std::mem::replace_with</code></a>."}], "tags": [], "owner": {"reputation": 3653, "user_id": 786102, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/15fbc7eac0e190a249d7495cc9cdf156?s=128&d=identicon&r=PG", "display_name": "kralyk", "link": "https://stackoverflow.com/users/786102/kralyk"}, "is_accepted": false, "score": 5, "last_activity_date": 1559668678, "last_edit_date": 1559668678, "creation_date": 1500128529, "answer_id": 45119209, "question_id": 36557412, "link": "https://stackoverflow.com/questions/36557412/change-enum-variant-while-moving-the-field-to-the-new-variant/45119209#45119209", "title": "Change enum variant while moving the field to the new variant", "body": "<p>If you want to do this without moving out of the value in a zero-cost way, you have to resort to a bit of unsafe code (AFAIK):</p>\n\n<pre><code>use std::mem;\n\n#[derive(Debug)]\nenum X {\n    X1(String),\n    X2(String),\n}\n\nfn increment_x(x: &amp;mut X) {\n    let interim = unsafe { mem::uninitialized() };\n    let prev = mem::replace(x, interim);\n    let next = match prev {\n        X::X1(s) =&gt; X::X2(s),\n        X::X2(s) =&gt; X::X1(s),\n    };\n    let interim = mem::replace(x, next);\n    mem::forget(interim); // Important! interim was never initialized\n}\n</code></pre>\n"}], "owner": {"reputation": 6262, "user_id": 691032, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/04fa8b0cca5a7dfef2d281be67a2b7a2?s=128&d=identicon&r=PG", "display_name": "sinan", "link": "https://stackoverflow.com/users/691032/sinan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3010, "favorite_count": 0, "accepted_answer_id": 36557734, "answer_count": 2, "score": 14, "last_activity_date": 1604332881, "creation_date": 1460402382, "last_edit_date": 1559668492, "question_id": 36557412, "link": "https://stackoverflow.com/questions/36557412/change-enum-variant-while-moving-the-field-to-the-new-variant", "title": "Change enum variant while moving the field to the new variant", "body": "<p>I want to update an enum variant while moving a field of the old variant to the new one without any cloning:</p>\n\n<pre><code>enum X {\n    X1(String),\n    X2(String),\n}\n\nfn increment_x(x: &amp;mut X) {\n    *x = match *x {\n        X::X1(s) =&gt; X::X2(s),\n        X::X2(s) =&gt; X::X1(s),\n    }\n}\n</code></pre>\n\n<p>This doesn't work because we can't move <code>s</code> from <code>&amp;mut X</code>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n --&gt; src/lib.rs:7:16\n  |\n7 |     *x = match *x {\n  |                ^^\n  |                |\n  |                cannot move out of borrowed content\n  |                help: consider removing the `*`: `x`\n8 |         X::X1(s) =&gt; X::X2(s),\n  |               - data moved here\n9 |         X::X2(s) =&gt; X::X1(s),\n  |               - ...and here\n</code></pre>\n\n<p>Please don't suggest things like implementing an <code>enum X { X1, X2 }</code> and using <code>struct S { variant: X, str: String }</code> etc. This is a simplified example, imagine having lots of other fields in variants, and wanting to move one field from one variant to another.</p>\n"}, {"tags": ["rust", "lifetime", "ownership", "borrowing"], "comments": [{"owner": {"reputation": 217, "user_id": 6189743, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/99f741f9304c500014cb55f92edca4d9?s=128&d=identicon&r=PG&f=1", "display_name": "FizzBazer", "link": "https://stackoverflow.com/users/6189743/fizzbazer"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460402778, "post_id": 36557150, "comment_id": 60715368, "body": "So i&#39;m trying not to assume too much, and just going by what the error messages have led me to thus far. Which, so far has not mentioned anything about the struct fields lifetime."}], "answers": [{"tags": [], "owner": {"reputation": 15480, "user_id": 105760, "user_type": "registered", "accept_rate": 97, "profile_image": "https://i.stack.imgur.com/HjFvK.jpg?s=128&g=1", "display_name": "Clark Gaebel", "link": "https://stackoverflow.com/users/105760/clark-gaebel"}, "is_accepted": true, "score": 3, "last_activity_date": 1460404825, "last_edit_date": 1460404825, "creation_date": 1460403978, "answer_id": 36557897, "question_id": 36557150, "link": "https://stackoverflow.com/questions/36557150/embedding-a-borrowed-value-into-an-enum/36557897#36557897", "title": "Embedding a borrowed value into an enum?", "body": "<p>The confusion here is an unfortunate side effect of lifetime elision. It helps in 99% of cases, but isn't very discoverable.</p>\n\n<p>You need to annotate <code>GetHelloResult</code> with a lifetime:</p>\n\n<pre><code>pub enum GetHelloResult&lt;'a, H: 'a + HelloPhrase&gt; {\n    Matched(&amp;'a H),\n    NoMatch,\n}\n\npub fn get_hello(&amp;self, lang: &amp;'static str) -&gt; GetHelloResult&lt;H&gt; {\n    match self.hello_phrases.get(lang) {\n        Some(hello_phrase) =&gt; return GetHelloResult::Matched(hello_phrase),\n        _ =&gt; return GetHelloResult::NoMatch,\n    };\n}\n</code></pre>\n\n<p>This ties the lifetime of the <code>GetHelloResult</code> to the lifetime of the <code>Phrases</code> struct, so that if the <code>Phrases</code> struct is mutated (or destructed!), the returned reference will be invalidated. The lifetime is inferred, in this case, to be the same as <code>self</code>, which isn't obvious by reading it, but true! In less obvious situations, you might want to explicitly annotate by using <code>GetHelloResult&lt;'a, H&gt;</code>.</p>\n\n<p><a href=\"https://play.rust-lang.org/?code=%0Apub%20trait%20HelloPhrase%20%7B%0A%20%20%20%20fn%20hello(%26self%2C%20to%3A%20%26&#39;static%20str)%3B%0A%7D%0A%0Apub%20enum%20GetHelloResult%3C&#39;a%2C%20H%3A%20&#39;a%20%2B%20HelloPhrase%3E%20%7B%0A%20%20%20%20Matched(%26&#39;a%20H)%2C%0A%20%20%20%20NoMatch%2C%0A%7D%0A%0Astruct%20English%3B%0A%0Aimpl%20English%20%7B%0A%20%20%20%20pub%20fn%20new()%20-%3E%20English%20%7B%0A%20%20%20%20%20%20%20%20English%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20HelloPhrase%20for%20English%20%7B%0A%20%20%20%20fn%20hello(%26self%2C%20to%3A%20%26&#39;static%20str)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hello%20%7B%7D.%22%2C%20to)%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20Phrases%3CH%3A%20HelloPhrase%3E%20%7B%0A%20%20%20%20hello_phrases%3A%20std%3A%3Acollections%3A%3AHashMap%3C%26&#39;static%20str%2C%20H%3E%2C%0A%7D%0A%0Aimpl%3CH%3A%20HelloPhrase%3E%20Phrases%3CH%3E%20%7B%0A%20%20%20%20pub%20fn%20new()%20-%3E%20Phrases%3CH%3E%20%7B%0A%20%20%20%20%20%20%20%20Phrases%20%7B%20hello_phrases%3A%20std%3A%3Acollections%3A%3AHashMap%3A%3Anew()%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20pub%20fn%20add_hello_phrase(%26mut%20self%2C%20lang%3A%20%26&#39;static%20str%2C%20hello_phrase%3A%20H)%20%7B%0A%20%20%20%20%20%20%20%20self.hello_phrases.insert(lang%2C%20hello_phrase)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20pub%20fn%20get_hello(%26self%2C%20lang%3A%20%26&#39;static%20str)%20-%3E%20GetHelloResult%3CH%3E%20%7B%0A%20%20%20%20%20%20%20%20match%20self.hello_phrases.get(lang)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(hello_phrase)%20%3D%3E%20return%20GetHelloResult%3A%3AMatched(hello_phrase)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20return%20GetHelloResult%3A%3ANoMatch%2C%0A%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20hs%20%3D%20Phrases%3A%3Anew()%3B%0A%20%20%20%20hs.add_hello_phrase(%22english%22%2C%20English%3A%3Anew())%3B%0A%0A%20%20%20%20match%20hs.get_hello(%22english%22)%20%7B%0A%20%20%20%20%20%20%20%20GetHelloResult%3A%3AMatched(hello_phrase)%20%3D%3E%20hello_phrase.hello(%22Tom%22)%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22HelloPhrase%20not%20found%22)%2C%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow\">Play link.</a></p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1460404264, "creation_date": 1460404264, "answer_id": 36557971, "question_id": 36557150, "link": "https://stackoverflow.com/questions/36557150/embedding-a-borrowed-value-into-an-enum/36557971#36557971", "title": "Embedding a borrowed value into an enum?", "body": "<p>The code works fine when you return a reference (<code>fn get_hello(&amp;self, lang: &amp;'static str) -&gt; GetHelloResult&lt;&amp;H&gt;</code>) so long as you implement the trait for references to types that also implement the trait:</p>\n\n<pre><code>impl&lt;'a, H&gt; HelloPhrase for &amp;'a H \n    where H: HelloPhrase\n{\n    fn hello(&amp;self, to: &amp;'static str) {\n        (**self).hello(to)\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 217, "user_id": 6189743, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/99f741f9304c500014cb55f92edca4d9?s=128&d=identicon&r=PG&f=1", "display_name": "FizzBazer", "link": "https://stackoverflow.com/users/6189743/fizzbazer"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 641, "favorite_count": 0, "accepted_answer_id": 36557897, "answer_count": 2, "score": 2, "last_activity_date": 1460404825, "creation_date": 1460401532, "last_edit_date": 1460403697, "question_id": 36557150, "link": "https://stackoverflow.com/questions/36557150/embedding-a-borrowed-value-into-an-enum", "title": "Embedding a borrowed value into an enum?", "body": "<p>I'm having difficulty with the following code:</p>\n\n<pre><code>trait HelloPhrase {\n    fn hello(&amp;self, to: &amp;'static str);\n}\n\npub enum GetHelloResult&lt;H: HelloPhrase&gt; {\n    Matched(H),\n    NoMatch,\n}\n\nstruct English;\n\nimpl English {\n    pub fn new() -&gt; English {\n        English\n    }\n}\n\nimpl HelloPhrase for English {\n    fn hello(&amp;self, to: &amp;'static str) {\n        println!(\"Hello {}.\", to)\n    }\n}\n\nstruct Phrases&lt;H: HelloPhrase&gt; {\n    hello_phrases: std::collections::HashMap&lt;&amp;'static str, H&gt;,\n}\n\nimpl&lt;H: HelloPhrase&gt; Phrases&lt;H&gt; {\n    pub fn new() -&gt; Phrases&lt;H&gt; {\n        Phrases { hello_phrases: std::collections::HashMap::new() }\n    }\n\n    pub fn add_hello_phrase(&amp;mut self, lang: &amp;'static str, hello_phrase: H) {\n        self.hello_phrases.insert(lang, hello_phrase);\n    }\n\n    pub fn get_hello(&amp;self, lang: &amp;'static str) -&gt; GetHelloResult&lt;H&gt; {\n        match self.hello_phrases.get(lang) {\n            Some(hello_phrase) =&gt; return GetHelloResult::Matched(hello_phrase),\n            _ =&gt; return GetHelloResult::NoMatch,\n        };\n    }\n}\n\nfn main() {\n    let mut hs = Phrases::new();\n    hs.add_hello_phrase(\"english\", English::new());\n\n    match hs.get_hello(\"english\") {\n        GetHelloResult::Matched(hello_phrase) =&gt; hello_phrase.hello(\"Tom\"),\n        _ =&gt; println!(\"HelloPhrase not found\"),\n    }\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=8d37aa99377a4eb31ba5d53e7a0cc666&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow\">play link</a>)</p>\n\n<p><code>HelloPhrase</code> is a trait for a language to implement, English, Russian, etc. <code>Phrases</code> is a manager struct, which could have many maps of language-to-phrase. This is a contrived example, but you could think of this as an event manager (that is, get the event handlers for X input), or as an HTTP handler and router.</p>\n\n<p>With that said, I'm having difficulty understanding how to borrow ownership of a <code>HelloPhrase</code> to return it to the caller. Running it, returns the following error:</p>\n\n<pre><code>&lt;anon&gt;:40:66: 40:78 error: mismatched types:\n expected `H`,\n    found `&amp;H`\n(expected type parameter,\n    found &amp;-ptr) [E0308]\n&lt;anon&gt;:40             Some(hello_phrase) =&gt; return GetHelloResult::Matched(hello_phrase),\n                                                                           ^~~~~~~~~~~~\n</code></pre>\n\n<p>I've tried adding:</p>\n\n<pre><code>pub fn get_hello(&amp;self, lang: &amp;'static str) -&gt; GetHelloResult&lt;&amp;H&gt; {\n</code></pre>\n\n<p>and</p>\n\n<pre><code>pub enum GetHelloResult&lt;H: HelloPhrase&gt; {\n    Matched(&amp;H),\n    NoMatch,\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=7c497838328961397583c6b1236a9cc9&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow\">play link</a>)</p>\n\n<p>which results in the following error:</p>\n\n<pre><code>&lt;anon&gt;:7:13: 7:15 error: missing lifetime specifier [E0106]\n&lt;anon&gt;:7     Matched(&amp;H),\n</code></pre>\n\n<p>I'm having trouble adding a lifetime to the enum - in theory I want the lifetime of the returned value to be that of the <code>Phrases</code> struct - but the lifetime syntax is quite confusing to me so far. To sum this up into two questions:</p>\n\n<ol>\n<li>How do I add a lifetime to <code>GetHelloResult</code>, to satisfy this error?</li>\n<li>Based on ownership rules with Rust, is what I'm trying to do an anti-pattern with Rust? What might be a better design for something like this?</li>\n</ol>\n\n<p>Based on the documentation, I know how to use a lifetime on a struct, but I do not know how to add a lifetime to an enum (syntax wise). I only mentioned struct lifetime because I assume that's a missing part, but I honestly don't know. Furthermore, if I add a lifetime to the struct and impl and attempt to add it to the <code>hello_phrases</code> map, I get the error </p>\n\n<blockquote>\n<pre><code>the parameter type `H` may not live long enough [E0309]\n</code></pre>\n</blockquote>\n"}, {"tags": ["rust", "rust-compiler-plugin"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1460390473, "post_id": 36553526, "comment_id": 60707779, "body": "When doing this, I&#39;ve found it useful to create a <code>key</code> method that returns the tuple which is then used to keep <code>hash</code> and <code>eq</code> (and whatever else) all synchronized in order and count."}, {"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460391798, "post_id": 36553526, "comment_id": 60708669, "body": "@Shepmaster thanks, that seems to be a good idea, especially when you want to include &gt; 2 fields."}], "tags": [], "owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "is_accepted": true, "score": 6, "last_activity_date": 1460391739, "last_edit_date": 1460391739, "creation_date": 1460390020, "answer_id": 36553526, "question_id": 36553139, "link": "https://stackoverflow.com/questions/36553139/derive-attribute-for-specific-fields-only-like-serde-does/36553526#36553526", "title": "Derive attribute for specific fields only, like serde does", "body": "<p>No, there is no such feature in Rust at this moment. What I would suggest is to use the implementation for tuples available for these traits, like this:</p>\n\n<pre><code>use std::hash::{Hash, Hasher};\n\n#[derive(Debug)]\nstruct MyStruct {\n    id: i32,\n    name: String,\n    aux_data1: f64,\n    aux_data2: f64,\n    aux_data3: String,\n}\n\nimpl Hash for MyStruct {\n    fn hash&lt;H&gt;(&amp;self, state: &amp;mut H) where H: Hasher {\n        (&amp;self.id, &amp;self.name).hash(state);\n    }\n}\n\nimpl PartialEq for MyStruct {\n    fn eq(&amp;self, other: &amp;Self) -&gt; bool {\n        (&amp;self.id, &amp;self.name) == (&amp;other.id, &amp;other.name)\n    }\n}\n</code></pre>\n\n<p>Edit: or as @Shepmaster suggested in a comment below, you can create a <code>key</code> function which returns a tuple of all useful fields and use it.</p>\n\n<pre><code>impl MyStruct {\n    fn key(&amp;self) -&gt; (&amp;i32, &amp;String) {\n        (&amp;self.id, &amp;self.name)\n    }\n}\n\nimpl Hash for MyStruct {\n    fn hash&lt;H&gt;(&amp;self, state: &amp;mut H) where H: Hasher {\n        self.key().hash(state);\n    }\n}\n\nimpl PartialEq for MyStruct {\n    fn eq(&amp;self, other: &amp;Self) -&gt; bool {\n        self.key() == other.key()\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 529, "user_id": 1081184, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/a0e509fc265b1faea3d0d63db256495a?s=128&d=identicon&r=PG", "display_name": "willir", "link": "https://stackoverflow.com/users/1081184/willir"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1132, "favorite_count": 1, "accepted_answer_id": 36553526, "answer_count": 1, "score": 3, "last_activity_date": 1460391739, "creation_date": 1460389032, "last_edit_date": 1460390426, "question_id": 36553139, "link": "https://stackoverflow.com/questions/36553139/derive-attribute-for-specific-fields-only-like-serde-does", "title": "Derive attribute for specific fields only, like serde does", "body": "<p>Using <code>derive</code> syntax, can I implement traits like <code>Hash</code> or <code>PartialEq</code> using specific fields, not all of them?</p>\n\n<p>It could look like:</p>\n\n<pre><code>#[derive(Debug, Hash, Eq, PartialEq)]\nstruct MyStruct {\n    id: i32,\n    name: String,\n\n    #[derive(hash_skip, eq_skip)] \n    aux_data1: f64,\n    #[derive(hash_skip, eq_skip)]\n    aux_data2: f64,\n    #[derive(hash_skip, eq_skip)]\n    aux_data3: String,\n}\n</code></pre>\n\n<p>I want the <code>hash</code> method to only use <code>id</code>, and <code>name</code> and no others.</p>\n\n<p>The <a href=\"https://github.com/serde-rs/serde\" rel=\"nofollow\">serde</a> library allows something like this for serialization.</p>\n"}, {"tags": ["vector", "error-handling", "rust"], "comments": [{"owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "edited": false, "score": 0, "creation_date": 1460388992, "post_id": 36553066, "comment_id": 60706690, "body": "You probably want the following function: <code>pub fn visit_dirs(dir: &amp;Path, cb: &amp;Fn(&amp;DirEntry)) -&gt; io::Result&lt;Vec&lt;String&gt;&gt;</code>. Notice how the <code>Vec&lt;String&gt;</code> is now contained in the result."}, {"owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "edited": false, "score": 0, "creation_date": 1460390232, "post_id": 36553066, "comment_id": 60707612, "body": "By the way, I think the title of your question is not completely accurate, since it is not about returning multiple values in a function, right?"}, {"owner": {"reputation": 109, "user_id": 4564050, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/ffc30316a079c38b1ba6901e560f4316?s=128&d=identicon&r=PG&f=1", "display_name": "jh44tx", "link": "https://stackoverflow.com/users/4564050/jh44tx"}, "reply_to_user": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "edited": false, "score": 1, "creation_date": 1460390878, "post_id": 36553066, "comment_id": 60708059, "body": "Probably not. I&#39;ll change it."}], "answers": [{"comments": [{"owner": {"reputation": 109, "user_id": 4564050, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/ffc30316a079c38b1ba6901e560f4316?s=128&d=identicon&r=PG&f=1", "display_name": "jh44tx", "link": "https://stackoverflow.com/users/4564050/jh44tx"}, "edited": false, "score": 1, "creation_date": 1460389643, "post_id": 36553201, "comment_id": 60707158, "body": "Excellent, thank you. That makes sense. Your earlier comment helped me get there independently(well..somewhat independently), but the confirmation is good."}, {"owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "reply_to_user": {"reputation": 109, "user_id": 4564050, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/ffc30316a079c38b1ba6901e560f4316?s=128&d=identicon&r=PG&f=1", "display_name": "jh44tx", "link": "https://stackoverflow.com/users/4564050/jh44tx"}, "edited": false, "score": 0, "creation_date": 1460389726, "post_id": 36553201, "comment_id": 60707221, "body": "Happy to help. Are you following <a href=\"https://doc.rust-lang.org/book/\" rel=\"nofollow noreferrer\">The Book</a> to learn Rust?"}, {"owner": {"reputation": 109, "user_id": 4564050, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/ffc30316a079c38b1ba6901e560f4316?s=128&d=identicon&r=PG&f=1", "display_name": "jh44tx", "link": "https://stackoverflow.com/users/4564050/jh44tx"}, "edited": false, "score": 1, "creation_date": 1460389962, "post_id": 36553201, "comment_id": 60707403, "body": "Yes I am. Not totally done learning, but I am finding the language very compelling."}], "tags": [], "owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "is_accepted": true, "score": 2, "last_activity_date": 1460389572, "last_edit_date": 1460389572, "creation_date": 1460389189, "answer_id": 36553201, "question_id": 36553066, "link": "https://stackoverflow.com/questions/36553066/returning-error-enumeration-with-an-arbitrary-variable/36553201#36553201", "title": "Returning Error Enumeration with an Arbitrary Variable", "body": "<p>The return type of <code>visit_dirs</code> is wrong. The function should return a <code>Result</code>, but right now it returns a tuple. Since <code>try!</code> only works for functions returning a <code>Result</code>, your code doesn't compile. You can change the return value of <code>visit_dirs</code> in order to fix it:</p>\n\n<pre><code>pub fn visit_dirs(dir: &amp;Path, cb: &amp;Fn(&amp;DirEntry)) -&gt; io::Result&lt;Vec&lt;String&gt;&gt;\n</code></pre>\n\n<p>The new definition means that a <code>Vec&lt;String&gt;</code> will be stored in the <code>Result</code> upon success. With some minor tweaks, the code is accepted by the compiler (see below)</p>\n\n<pre><code>mod os{\n    use std::io;\n    use std::fs::{self, DirEntry};\n    //use std::fs;\n    use std::path::Path;\n    // one possible implementation of walking a directory only visiting files\n    pub fn visit_dirs(dir: &amp;Path, cb: &amp;Fn(&amp;DirEntry)) -&gt; io::Result&lt;Vec&lt;String&gt;&gt; {\n        let mut filevec: Vec&lt;String&gt; = Vec::new();\n        if try!(fs::metadata(dir)).is_dir() {\n            for entry in try!(fs::read_dir(dir)) {\n                let entry = try!(entry);\n                if try!(fs::metadata(entry.path())).is_dir() {\n                    try!(visit_dirs(&amp;entry.path(), cb));\n                } else {\n                    cb(&amp;entry);\n                }\n            }\n        }\n        Ok(filevec)\n    }\nfn push_path_to_vec(p:&amp;DirEntry,mut v:Vec&lt;String&gt;){\n    v.push(p.path().to_str().unwrap().to_string());\n}}\n</code></pre>\n"}], "owner": {"reputation": 109, "user_id": 4564050, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/ffc30316a079c38b1ba6901e560f4316?s=128&d=identicon&r=PG&f=1", "display_name": "jh44tx", "link": "https://stackoverflow.com/users/4564050/jh44tx"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 74, "favorite_count": 0, "accepted_answer_id": 36553201, "answer_count": 1, "score": 2, "last_activity_date": 1460391012, "creation_date": 1460388827, "last_edit_date": 1460391012, "question_id": 36553066, "link": "https://stackoverflow.com/questions/36553066/returning-error-enumeration-with-an-arbitrary-variable", "title": "Returning Error Enumeration with an Arbitrary Variable", "body": "<p>I have a function in Rust using <code>try!</code> that attempts to collect all files in a directory recursively and insert them into a vector. Because the function uses <code>try!</code> to check errors, the compiler seems to expect an <code>io::Result</code> return from the function, and doesn't let me include the vector because the <code>try!</code> macro only returns a result. I need the vector to be returned.</p>\n\n<p>Code is as follows:</p>\n\n<pre><code>mod os{\n    use std::io;\n    use std::fs::{self, DirEntry};\n    //use std::fs;\n    use std::path::Path;\n    // one possible implementation of walking a directory only visiting files\n    pub fn visit_dirs(dir: &amp;Path, cb: &amp;Fn(&amp;DirEntry)) -&gt; (io::Result&lt;()&gt;,Vec&lt;String&gt;) {\n        let mut filevec: Vec&lt;String&gt; = Vec::new();\n        if try!(fs::metadata(dir)).is_dir() {\n            for entry in try!(fs::read_dir(dir)) {\n                let entry = try!(entry);\n                if try!(fs::metadata(entry.path())).is_dir() {\n                    try!(visit_dirs(&amp;entry.path(), cb));\n                } else {\n                    cb(&amp;entry);\n                }\n            }\n        }\n        (Ok(()),filevec)\n\n    }\nfn push_path_to_vec(p:&amp;DirEntry,v:Vec&lt;String&gt;){\n    v.push(p.path().to_str().unwrap().to_string());\n}}\n</code></pre>\n\n<p>Here is the error:</p>\n\n<pre><code>&lt;std macros&gt;:5:8: 6:42 error: mismatched types:\n expected `(core::result::Result&lt;(), std::io::error::Error&gt;, collections::vec::Vec&lt;collections::string::String&gt;)`\n    found `core::result::Result&lt;_, _&gt;`\n(expected tuple,\n    found enum `core::result::Result`) [E0308]\n</code></pre>\n\n<p>I wonder if there's any idiomatic way to do this that I've missed.</p>\n"}, {"tags": ["rust", "traits", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 3, "last_activity_date": 1460390613, "last_edit_date": 1460390613, "creation_date": 1460369045, "answer_id": 36545565, "question_id": 36543836, "link": "https://stackoverflow.com/questions/36543836/how-do-i-upgrade-my-slicable-trait-to-satisfy-the-borrow-checker-in-repeated-cal/36545565#36545565", "title": "How do I upgrade my Slicable trait to satisfy the borrow checker in repeated calls", "body": "<p>There's two things going on. Lets look at your trait implementation first:</p>\n\n<pre><code>impl&lt;'a&gt; Slicable for Vector&lt;'a&gt; {\n   fn slice(self : &amp;Self) -&gt; &amp;[u32]{\n       return self.buf;\n   }\n}\n</code></pre>\n\n<p>The method's signature is expanded to</p>\n\n<pre><code>fn slice&lt;'b&gt;(self : &amp;'b Self) -&gt; &amp;'b[u32]\n</code></pre>\n\n<p>which means that the lifetime of the resulting slice is shorter than the lifetime of <code>self</code>. At the call site, this means that <code>s.other_tables[2].slice()</code> borrows <code>s</code> while <code>&amp;s.other_tables[2].buf[..]</code> borrows something that has lifetime <code>'a</code>, completely ignoring the lifetime of <code>s</code>. To replicate this behavior, you can add a lifetime to your trait:</p>\n\n<pre><code>trait Slicable&lt;'a&gt; {\n   fn slice(self: &amp;Self) -&gt; &amp;'a [u32];\n}\n\nimpl&lt;'a&gt; Slicable&lt;'a&gt; for Vector&lt;'a&gt; {\n   fn slice(self: &amp;Self) -&gt; &amp;'a [u32] {\n       self.buf\n   }\n}\n</code></pre>\n\n<p>Now you should be set, but the compiler still has a minor limitation with respect to method call lifetimes, so you need to split your call into two lines:</p>\n\n<pre><code>let slice = s.other_tables[2].slice();\nlet ret0 = process_with_table_fn(&amp;mut s, slice, &amp;mut outval0);\n</code></pre>\n"}], "owner": {"reputation": 483, "user_id": 4280035, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e442215473aa322da127ee74c79c7477?s=128&d=identicon&r=PG&f=1", "display_name": "hellcatv", "link": "https://stackoverflow.com/users/4280035/hellcatv"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 77, "favorite_count": 0, "accepted_answer_id": 36545565, "answer_count": 1, "score": 2, "last_activity_date": 1460390613, "creation_date": 1460364317, "last_edit_date": 1460364639, "question_id": 36543836, "link": "https://stackoverflow.com/questions/36543836/how-do-i-upgrade-my-slicable-trait-to-satisfy-the-borrow-checker-in-repeated-cal", "title": "How do I upgrade my Slicable trait to satisfy the borrow checker in repeated calls", "body": "<p>I have an IO library that has a big <code>State</code> struct and I am writing a function that requires two phases.\nIn the first phase, only the reader class is touched, but the call-site chooses a read-only table slice to pass in.</p>\n\n<p>In the second phase, the whole <code>State</code> struct is modified but the read-only table is no longer needed.</p>\n\n<p>I've split the function into two functions--and that works, but when I try to combine those functions, the borrow checker breaks down when I replace a concrete <code>Vector</code> class with a custom trait <code>Slicable</code></p>\n\n<p>Is there any way to make <code>process_with_table_fn</code> operate on <code>Slicable</code> values in the State struct rather than directly on Vectors?</p>\n\n<p>tl;dr I'd like fn <code>what_i_want_to_work</code> to compile, but instead I have only gotten <code>what_works</code> to build. Is my trait definition for <code>Slicable</code> badly crafted for this use case? Why does the concrete type operate better than the trait?</p>\n\n<pre><code>pub struct MemReader {\n    buf : [u8; 1024],\n    off : usize,\n}\npub struct Vector&lt;'a&gt; {\n   buf : &amp;'a [u32],\n}\ntrait Slicable {\n   fn slice(self : &amp;Self) -&gt; &amp;[u32];\n\n}\nimpl&lt;'a&gt; Slicable for Vector&lt;'a&gt; {\n   fn slice(self : &amp;Self) -&gt; &amp;[u32]{\n       return self.buf;\n   }\n}\nimpl MemReader {\n    fn read(self : &amp;mut Self, how_much : usize, output : &amp;mut u8) -&gt; bool {\n        if self.off + how_much &gt; self.buf.len() {\n            return false;\n        }\n        self.off += how_much;\n        *output = self.buf[self.off - 1];\n        return true;\n    }\n}\n\npub struct State&lt;'a&gt; {\n   pub mr : MemReader,\n   pub translation_tables : [Vector&lt;'a&gt;; 4],\n   pub other_tables : [Vector&lt;'a&gt;; 4],\n   pub state : i32,\n}\n\nfn process_first(mr : &amp;mut MemReader, table : &amp;[u32]) -&gt; (bool, u32) {\n    let mut temp : u8 = 0;\n    let ret = mr.read(8, &amp;mut temp);\n    if !ret {\n        return (false, 0);\n    }\n    return (true, table[temp as usize]);\n}\n\nfn process_second(s : &amp;mut State, ret_index : (bool, u32), mut outval : &amp;mut u8) -&gt; bool {\n    let (ret, index) = ret_index;\n    if ! ret {\n        return false;\n    }\n    s.state += 1;\n    return s.mr.read(index as usize, &amp;mut outval);\n}\n\npub fn process_with_table_fn(mut s : &amp;mut State, table : &amp;[u32], mut outval : &amp;mut u8) -&gt; bool {\n    let ret = process_first(&amp;mut s.mr, table);\n    return process_second(&amp;mut s, ret, &amp;mut outval);\n}\n\nmacro_rules! process_with_table_mac(\n    ($state : expr, $table : expr, $outval : expr) =&gt; {\n        process_second(&amp;mut $state, process_first(&amp;mut $state.mr, &amp;$table), &amp;mut $outval)\n    };\n);\n\npub fn what_works(mut s : &amp;mut State) {\n   let mut outval0 : u8 = 0;\n   let _ret0 = process_with_table_fn(&amp;mut s, &amp;s.other_tables[2].buf[..], &amp;mut outval0);\n}\n\n/*\npub fn what_i_want_to_work(mut s : &amp;mut State) {\n   let mut outval0 : u8 = 0;\n   let ret0 = process_with_table_fn(&amp;mut s, s.other_tables[2].slice(), &amp;mut outval0);\n\n   // OR\n\n   let mut outval1 : u8 = 0;\n   //let ret1 = process_with_table_mac!(s, s.other_tables[2].slice(), outval1);\n}\n*/\n\n\nfn main() {\n\n}\n</code></pre>\n"}, {"tags": ["gtk", "rust"], "comments": [{"owner": {"reputation": 10424, "user_id": 3408572, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/0f3a08b145553b98749d3d0572d01265?s=128&d=identicon&r=PG&f=1", "display_name": "andlabs", "link": "https://stackoverflow.com/users/3408572/andlabs"}, "edited": false, "score": 0, "creation_date": 1460323512, "post_id": 36534388, "comment_id": 60675065, "body": "Is <code>set_labels()</code> called <i>after</i> <code>window.show_all()</code>?"}, {"owner": {"reputation": 1342, "user_id": 3033123, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/bfb390ac1abb471ac1090039109d14a0?s=128&d=identicon&r=PG&f=1", "display_name": "zrneely", "link": "https://stackoverflow.com/users/3033123/zrneely"}, "reply_to_user": {"reputation": 10424, "user_id": 3408572, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/0f3a08b145553b98749d3d0572d01265?s=128&d=identicon&r=PG&f=1", "display_name": "andlabs", "link": "https://stackoverflow.com/users/3408572/andlabs"}, "edited": false, "score": 0, "creation_date": 1460329878, "post_id": 36534388, "comment_id": 60676837, "body": "Yes, it is. That&#39;s why I considered calling <code>queue_draw</code> to invalidate the widget - it had already been validated by the the <code>show_all()</code> call."}, {"owner": {"reputation": 10424, "user_id": 3408572, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/0f3a08b145553b98749d3d0572d01265?s=128&d=identicon&r=PG&f=1", "display_name": "andlabs", "link": "https://stackoverflow.com/users/3408572/andlabs"}, "edited": false, "score": 1, "creation_date": 1460333574, "post_id": 36534388, "comment_id": 60678349, "body": "It&#39;s not that the labels are not drawn, it&#39;s that all new widgets are invisible initially. Add <code>label.show()</code> to your <code>set_labels()</code> for loop (or <code>self.layout.show_all()</code> below it) and you should see your labels."}, {"owner": {"reputation": 1342, "user_id": 3033123, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/bfb390ac1abb471ac1090039109d14a0?s=128&d=identicon&r=PG&f=1", "display_name": "zrneely", "link": "https://stackoverflow.com/users/3033123/zrneely"}, "reply_to_user": {"reputation": 10424, "user_id": 3408572, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/0f3a08b145553b98749d3d0572d01265?s=128&d=identicon&r=PG&f=1", "display_name": "andlabs", "link": "https://stackoverflow.com/users/3408572/andlabs"}, "edited": false, "score": 0, "creation_date": 1460336679, "post_id": 36534388, "comment_id": 60679031, "body": "That was it! In retrospect it makes sense for newly created things to be invisible, but it&#39;s a bit unintuitive at first. Could you post that as an answer so I can accept it?"}], "answers": [{"tags": [], "owner": {"reputation": 10424, "user_id": 3408572, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/0f3a08b145553b98749d3d0572d01265?s=128&d=identicon&r=PG&f=1", "display_name": "andlabs", "link": "https://stackoverflow.com/users/3408572/andlabs"}, "is_accepted": true, "score": 2, "last_activity_date": 1460342724, "creation_date": 1460342724, "answer_id": 36539011, "question_id": 36534388, "link": "https://stackoverflow.com/questions/36534388/using-gtk-how-do-i-add-a-label-to-a-box-after-its-created/36539011#36539011", "title": "Using GTK+, how do I add a Label to a Box after it&#39;s created?", "body": "<p>Newly created GtkWidgets are initially hidden. You need to call <code>show()</code> or <code>show_all()</code> on them to make them visible (the latter will recursively show a container's children). This means you have to issue that call yourself if you add widgets after you call <code>show_all()</code> on a window. In your case, you can either call <code>show()</code> individually for each label or call <code>show_all()</code> on <code>self.layout</code> after adding all the labels.</p>\n"}], "owner": {"reputation": 1342, "user_id": 3033123, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/bfb390ac1abb471ac1090039109d14a0?s=128&d=identicon&r=PG&f=1", "display_name": "zrneely", "link": "https://stackoverflow.com/users/3033123/zrneely"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 541, "favorite_count": 0, "accepted_answer_id": 36539011, "answer_count": 1, "score": 1, "last_activity_date": 1460342724, "creation_date": 1460315905, "question_id": 36534388, "link": "https://stackoverflow.com/questions/36534388/using-gtk-how-do-i-add-a-label-to-a-box-after-its-created", "title": "Using GTK+, how do I add a Label to a Box after it&#39;s created?", "body": "<p>Here's some code I've been working on (in Rust, using the excellent gtk-rs bindings):</p>\n\n<pre><code>use gtk;\nuse gtk::prelude::*;\n\nstruct LabelViewer {\n    pub container: gtk::ScrolledWindow,\n    layout: gtk::Box,\n    fields: Vec&lt;gtk::Label&gt;,\n}\nimpl LabelViewer {  \n    pub fn new() -&gt; Self {\n        let container = gtk::ScrolledWindow::new(None, None);\n        let layout = gtk::Box::new(gtk::Orientation::Vertical, 5);\n        container.add(&amp;layout);\n        LabelViewer {\n            container: container,\n            layout: layout,\n            fields: Vec::new(),\n        }\n    }\n    pub fn set_labels(&amp;mut self, labels: &amp;[String]) {\n        for label in self.fields.drain(..) {\n            self.layout.remove(&amp;label);\n        }\n        for label in labels.iter().map(|l| gtk::Label::new(Some(l))) {\n            self.layout.pack_start(&amp;label, false, false, 0);\n            self.fields.push(label);\n        }\n    }\n}\n</code></pre>\n\n<p>When I create a <code>LabelViewer</code> and add its container to my Window, I see the border of the ScrolledWindow, indicating that it is indeed being added. However, when I call <code>set_labels</code>, no labels are actually rendered.</p>\n\n<p>I have some experience with Swing (from Java), but this is my first time using GTK. Based on my past experience I tried invalidating the container with <code>queue_draw</code>, after calling <code>set_labels</code>, but that didn't have any effect. It may not be relevant, but I call <code>set_labels</code> <em>before</em> <code>gtk::main()</code>.</p>\n"}, {"tags": ["rust", "ownership"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1460378856, "post_id": 36531671, "comment_id": 60698907, "body": "<i>I can think of only one example, a destructor method</i> \u2014 Amusingly, <a href=\"http://doc.rust-lang.org/std/ops/trait.Drop.html\" rel=\"nofollow noreferrer\">the closest equivalent to a destructor</a> takes the item by mutable reference."}], "answers": [{"tags": [], "owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "is_accepted": false, "score": 6, "last_activity_date": 1554652066, "last_edit_date": 1554652066, "creation_date": 1460303340, "answer_id": 36531912, "question_id": 36531671, "link": "https://stackoverflow.com/questions/36531671/when-would-an-implementation-want-to-take-ownership-of-self-in-rust/36531912#36531912", "title": "When would an implementation want to take ownership of self in Rust?", "body": "<p>Conversion from type A to type B commonly involves functions taking self by value. See the implementors of <a href=\"https://doc.rust-lang.org/std/convert/trait.Into.html\" rel=\"nofollow noreferrer\"><code>Into</code></a> and <a href=\"https://doc.rust-lang.org/std/convert/trait.From.html\" rel=\"nofollow noreferrer\"><code>From</code></a> traits for concrete examples.</p>\n"}, {"tags": [], "owner": {"reputation": 345, "user_id": 1041831, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/63542ac25e09115c3ba823097a1c825f?s=128&d=identicon&r=PG", "display_name": "NougatRillettes", "link": "https://stackoverflow.com/users/1041831/nougatrillettes"}, "is_accepted": true, "score": 10, "last_activity_date": 1554652059, "last_edit_date": 1554652059, "creation_date": 1460303506, "answer_id": 36531940, "question_id": 36531671, "link": "https://stackoverflow.com/questions/36531671/when-would-an-implementation-want-to-take-ownership-of-self-in-rust/36531940#36531940", "title": "When would an implementation want to take ownership of self in Rust?", "body": "<p>The idiomatic way to refer to a method that \"takes control\" of self in the Rust standard library documentation is to say that it \"consumes\" it. If you search for this, you should find some examples:</p>\n\n<ul>\n<li><a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default\" rel=\"nofollow noreferrer\"><code>Option::unwrap_or_default</code></a></li>\n<li>A <strong>lot</strong> in the <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\" rel=\"nofollow noreferrer\"><code>Iterator</code></a> trait.</li>\n</ul>\n\n<p>As to why: you can try rewriting <code>Iterator::map</code> \u2014 you would end up having a lifetime parameter wandering around that would quickly become unmanageable. Why? Because the <code>Map</code> iterator is based upon the previous one, so the borrow checker will enforce that you can only use one of the two at the same time.</p>\n"}], "owner": {"reputation": 42480, "user_id": 148423, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/6ed1f9b5afd258d0b73ad1eae10ac384?s=128&d=identicon&r=PG", "display_name": "Joe", "link": "https://stackoverflow.com/users/148423/joe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1207, "favorite_count": 2, "accepted_answer_id": 36531940, "answer_count": 2, "score": 8, "last_activity_date": 1554652066, "creation_date": 1460302151, "last_edit_date": 1554651990, "question_id": 36531671, "link": "https://stackoverflow.com/questions/36531671/when-would-an-implementation-want-to-take-ownership-of-self-in-rust", "title": "When would an implementation want to take ownership of self in Rust?", "body": "<p>I'm reading through the Rust documentation on lifetimes. I tried something like:</p>\n\n<pre><code>struct S {\n    x: i8,\n}\n\nimpl S {\n    fn fun(self) {}\n\n    fn print(&amp;self) {\n        println!(\"{}\", self.x);\n    }\n}\n\nfn main() {\n    let s = S { x: 1 };\n    s.fun();\n    s.print();\n}\n</code></pre>\n\n<p>I get the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: borrow of moved value: `s`\n  --&gt; src/main.rs:16:5\n   |\n15 |     s.fun();\n   |     - value moved here\n16 |     s.print();\n   |     ^ value borrowed here after move\n   |\n   = note: move occurs because `s` has type `S`, which does not implement the `Copy` trait\n</code></pre>\n\n<p>This is because the <code>fun(self)</code> method takes ownership of the <code>s</code> instance. This is solved by changing to <code>fun(&amp;self)</code>.</p>\n\n<p>I can't see why you would ever want to have a method on an object take control of itself. I can think of only one example, a destructor method, but if you wanted to do dispose of the object then it would be taken care of by the owner of the object anyway (i.e. scope of <code>main</code> in this example). </p>\n\n<p>Why is it possible to write a method that takes ownership of the struct? Is there ever any circumstance where you would want this? </p>\n"}, {"tags": ["closures", "rust", "function-pointers", "lifetime"], "answers": [{"tags": [], "owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "is_accepted": true, "score": 6, "last_activity_date": 1460228938, "creation_date": 1460228938, "answer_id": 36521419, "question_id": 36519622, "link": "https://stackoverflow.com/questions/36519622/use-function-pointer-parameter-inside-closure-rust/36521419#36521419", "title": "Use function pointer parameter inside closure Rust", "body": "<p>The type parameter <code>F</code> to your function has an associated lifetime (just like every other type). But implicitly, the return value of your function, <code>Box&lt;FnMut(&amp;CowRow) -&gt; i32&gt;</code>, is really <code>Box&lt;FnMut(&amp;CowRow) -&gt; i32 + 'static&gt;</code>. That is, unless you specify a lifetime for a box, it assumes its contents can live forever. Of course if <code>F</code> only lives for <code>'a</code>, then the borrow checker is going to complain. To fix this, either</p>\n\n<ul>\n<li><p>Force <code>F</code> to have a static lifetime so that it can live forever inside the box (<a href=\"https://play.rust-lang.org/?gist=16dfb91e4ef1ea63e70866b1c0a07d34&amp;version=stable&amp;backtrace=1\" rel=\"noreferrer\">playpen</a>):</p>\n\n<pre><code>fn agg&lt;F&gt;(col: F) -&gt; Box&lt;FnMut(&amp;CowRow) -&gt; i32&gt;\n    where F: Fn(&amp;CowRow) -&gt; i32 + 'static\n{\n    ...\n}\n</code></pre></li>\n<li><p>Explicitly state that <code>F</code> has lifetime <code>'a</code> and so does the <code>Box</code> (<a href=\"https://play.rust-lang.org/?gist=fc4abdc705185e852401cc63a81ea017&amp;version=stable&amp;backtrace=1\" rel=\"noreferrer\">playpen</a>):</p>\n\n<pre><code>fn agg&lt;'a, F&gt;(col: F) -&gt; Box&lt;FnMut(&amp;CowRow) -&gt; i32 + 'a&gt;\n    where F: Fn(&amp;CowRow) -&gt; i32 + 'a\n{\n    ...\n}\n</code></pre></li>\n</ul>\n\n<p>The second version is more general than the first and will accept more closures as arguments.</p>\n"}], "owner": {"reputation": 1356, "user_id": 828394, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/81f88fce4709acf2047a0da477a4134f?s=128&d=identicon&r=PG", "display_name": "josh", "link": "https://stackoverflow.com/users/828394/josh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 480, "favorite_count": 1, "accepted_answer_id": 36521419, "answer_count": 1, "score": 2, "last_activity_date": 1460228938, "creation_date": 1460219424, "question_id": 36519622, "link": "https://stackoverflow.com/questions/36519622/use-function-pointer-parameter-inside-closure-rust", "title": "Use function pointer parameter inside closure Rust", "body": "<p>I am looking to create a function, <code>agg</code>, which takes, as a parameter, another function, <code>get_id</code>, and returns an <code>FnMut</code> closure that uses the <code>get_id</code> function.</p>\n\n<p>Concrete example:</p>\n\n<pre><code>struct CowRow {\n    pub id : i32,\n}\nimpl CowRow {\n    fn get_id(&amp;self) -&gt; i32       { self.id }\n}\n\npub fn agg&lt;F&gt;(col: F) -&gt; Box&lt;FnMut(&amp;CowRow) -&gt; i32&gt;\n    where F: Fn(&amp;CowRow) -&gt; i32 {\n    let mut res = 0;\n    Box::new(move |r| { res += col(&amp;r); return res })\n}\n\nfn main() {\n    let mut cow = CowRow { id: 0 };\n    let a = agg(CowRow::get_id);\n    a(&amp;cow);\n</code></pre>\n\n<p>Which produces the error:</p>\n\n<pre><code>the parameter type `F` may not live long enough [E0310]\n\nrun `rustc --explain E0310` to see a detailed explanation\n\nconsider adding an explicit lifetime bound `F: 'static`...\n\n...so that the type `[closure@main.rs:23:14: 23:53 col:F, res:i32]` will meet its required lifetime bounds\n</code></pre>\n\n<p>The idea here is that I want a generic function that allows for creating closures which operate on different fields in the struct. So, my thought was to pass a function in that is a getter for the struct and use this in the closure to extract the appropriate field. </p>\n\n<p>I've tried various combinations of adding <code>'static</code> to the <code>agg</code> signature but I'm not sure what that actually means and where it would need to go syntactically. Additionally, I've tried a number of techniques from: <a href=\"https://github.com/nrc/r4cppp/blob/master/closures.md\" rel=\"nofollow\">https://github.com/nrc/r4cppp/blob/master/closures.md</a> such as adding the <code>get_id</code> method as a trait but have been unable to get that working either.</p>\n"}, {"tags": ["iterator", "rust", "lazy-evaluation", "borrowing"], "comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1460166390, "post_id": 36511683, "comment_id": 60630059, "body": "Likely the issue has to do with your attempt at closing over a variable that is somewhere in another scope (<code>v</code>). This is very important in Rust.. so we&#39;ll need to see where <code>v</code> comes from, how its declared and how you&#39;re referencing it within the current scope."}, {"owner": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1460176934, "post_id": 36511683, "comment_id": 60631828, "body": "@SimonWhitehead edited to include <code>v</code>. Must&#39;ve left it out earlier."}], "answers": [{"comments": [{"owner": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 0, "creation_date": 1460269892, "post_id": 36513992, "comment_id": 60657530, "body": "This is a good explanation, however, both your solutions break the iterator for some reason. I can&#39;t figure it out. It&#39;s almost as if the <code>skip_while</code> isn&#39;t stopping the iteration in the way it usually does and it searches forever. Either that or it&#39;s over 100x slower (I waited ~1min and it never finished)."}, {"owner": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 0, "creation_date": 1460269980, "post_id": 36513992, "comment_id": 60657545, "body": "I was able to implement a solution by moving all the <code>push</code>/<code>contains</code> logic into the iterator <code>next()</code> function: <a href=\"https://github.com/JacksonGariety/euler.rs/blob/master/src/solution_074.rs\" rel=\"nofollow noreferrer\">github.com/JacksonGariety/euler.rs/blob/master/src/&hellip;</a>"}, {"owner": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 0, "creation_date": 1460270099, "post_id": 36513992, "comment_id": 60657565, "body": "That&#39;s pretty efficient, however, I&#39;d like to move the logic into a <code>skip_while</code> if possible. When I use both your implementations, the <code>skip_while</code> either skips all iterations or the iterator just runs forever."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 0, "creation_date": 1460298234, "post_id": 36513992, "comment_id": 60665674, "body": "@JacksonGariety, I&#39;ve just written an example program using this approach and understood that it can&#39;t work. When you ask an iterator chain for a next element, it works through the entire chain. So suppose you&#39;re calling <code>next()</code> on the above chain with <code>inspect()</code> and <code>skip_while()</code> (I think that it should actually be <code>take_while()</code> with an inverted condition, otherwise it doesn&#39;t make sense). An element is taken from the original iterator and written to the collection. And then the collection is queried for this element. Naturally, it is already there, so the iteration stops immediately."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 1, "creation_date": 1460298283, "post_id": 36513992, "comment_id": 60665691, "body": "@JacksonGariety therefore, your approach for internalizing the collection into the iterator is <i>the</i> way to go. Although I would use <code>HashSet</code> instead of <code>Vec</code> because <code>contains()</code> is much more efficient on <code>HashSet</code> than on <code>Vec</code>."}, {"owner": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 0, "creation_date": 1460318389, "post_id": 36513992, "comment_id": 60673332, "body": "Your explanation <i>really</i> changed the way I look at iterators in Rust. Thanks! In this case, however, the HashSet performs about 2x slower than Vec. Not sure why."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 0, "creation_date": 1460318855, "post_id": 36513992, "comment_id": 60673514, "body": "Ah, I think that HashSet is slower because it uses SipHash which is rather slow for small keys but cryptographically strong hash function. For integer keys it makes sense to use something else, like <a href=\"https://crates.io/crates/fnv\" rel=\"nofollow noreferrer\"><code>fnv</code></a>."}, {"owner": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 0, "creation_date": 1460322445, "post_id": 36513992, "comment_id": 60674754, "body": "okay I tried using a <code>HashSet&lt;u32, BuildHasherDefault&lt;FnvHasher&gt;&gt;</code> instead of a vector and it ran ~1.17x slow. How can that be? Here&#39;s a gist: <a href=\"https://gist.github.com/JacksonGariety/a6bb4672a549e381c06415398a78ffc3\" rel=\"nofollow noreferrer\">gist.github.com/JacksonGariety/a6bb4672a549e381c06415398a78f&zwnj;&#8203;fc3</a>"}, {"owner": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 0, "creation_date": 1460325791, "post_id": 36513992, "comment_id": 60675717, "body": "Tried XxHash also and it was wayyyyy slower."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "edited": false, "score": 0, "creation_date": 1460364515, "post_id": 36513992, "comment_id": 60688873, "body": "@JacksonGariety, sorry, I&#39;m afraid I won&#39;t be able to help more on this one, I&#39;m not very strong in performance analysis :) I suspect that a vector may be more efficient on small numbers of elements than a hash set regardless of a hash function, but I cannot say for sure. You can try asking on <a href=\"http://www.reddit.com/r/rust/\" rel=\"nofollow noreferrer\">reddit</a> or on <a href=\"https://users.rust-lang.org/\" rel=\"nofollow noreferrer\">discussions forum</a> if you&#39;re interested in this."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 3, "last_activity_date": 1460186836, "creation_date": 1460186836, "answer_id": 36513992, "question_id": 36511683, "link": "https://stackoverflow.com/questions/36511683/rust-inspect-iterator-cannot-borrow-as-immutable-because-it-is-also-borrowe/36513992#36513992", "title": "Rust Inspect Iterator: cannot borrow `*` as immutable because it is also borrowed as mutable", "body": "<p>The problem here is that you're attempting to create both a mutable and an immutable reference to the same variable, which is a violation of Rust borrowing rules. And rustc actually does say this to you very clearly.</p>\n\n<pre><code>let mut v = Vec::with_capacity(terms);\nChain::new(i)\n    .inspect(|&amp;x| {\n        v.push(x)\n    })\n    .skip_while(|&amp;x| {\n        return v.contains(&amp;x);\n    })\n</code></pre>\n\n<p>Here you're trying to use <code>v</code> in two closures, first in <code>inspect()</code> argument, second in <code>skip_while()</code> argument. Non-<code>move</code> closures capture their environment by reference, so the environment of the first closure contains <code>&amp;mut v</code>, and that of the second closure contains <code>&amp;v</code>. Closures are created in the same expression, so even if it was guaranteed that <code>inspect()</code> ran and dropped the borrow before <code>skip_while()</code> (which I is not the actual case, because these are iterator adapters and they won't be run at all until the iterator is consumed), due to lexical borrowing rules this is prohibited.</p>\n\n<p>Unfortunately, this is one of those examples when the borrow checker is overly strict. What you can do is to use <a href=\"http://doc.rust-lang.org/std/cell/struct.RefCell.html\" rel=\"nofollow\"><code>RefCell</code></a>, which allows mutation through a shared reference but introduces some run-time cost:</p>\n\n<pre><code>use std::cell::RefCell;\n\nlet mut v = RefCell::new(Vec::with_capacity(terms));\nChain::new(i)\n    .inspect(|x| v.borrow_mut().push(*x))\n    .skip_while(|x| v.borrow().contains(x))\n</code></pre>\n\n<p>I <em>think</em> it may be possible to avoid runtime penalty of <code>RefCell</code> and use <a href=\"http://doc.rust-lang.org/std/cell/struct.UnsafeCell.html\" rel=\"nofollow\"><code>UnsafeCell</code></a> instead, because when the iterator is consumed, these closures will only run one after another, not at the same time, so there should never be a mutable and an immutable references outstanding at the same time. It could look like this:</p>\n\n<pre><code>use std::cell::UnsafeCell;\n\nlet mut v = UnsafeCell::new(Vec::with_capacity(terms));\nChain::new(i)\n    .inspect(|x| unsafe { (&amp;mut *v.get()).push(*x) })\n    .skip_while(|x| unsafe { (&amp;*v.get()).contains(x) })\n</code></pre>\n\n<p>But I may be wrong, and anyway, the overhead of <code>RefCell</code> is not that high unless this code is running in a <em>really</em> tight loop, so you should only use <code>UnsafeCell</code> as a last resort, only when nothing else works, and exercise extreme caution when working with it.</p>\n"}], "owner": {"reputation": 11828, "user_id": 743561, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/2b097fbc2dc3b0f18727c422a5ab89b6?s=128&d=identicon&r=PG", "display_name": "alt", "link": "https://stackoverflow.com/users/743561/alt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 744, "favorite_count": 0, "accepted_answer_id": 36513992, "answer_count": 1, "score": 1, "last_activity_date": 1460186836, "creation_date": 1460164960, "last_edit_date": 1460176941, "question_id": 36511683, "link": "https://stackoverflow.com/questions/36511683/rust-inspect-iterator-cannot-borrow-as-immutable-because-it-is-also-borrowe", "title": "Rust Inspect Iterator: cannot borrow `*` as immutable because it is also borrowed as mutable", "body": "<p>Why can't I <code>push</code> to this vector during <code>inspect</code> and do <code>contains</code> on it during <code>skip_while</code>?</p>\n\n<p>I've implemented my own iterator for my own struct <code>Chain</code> like this:</p>\n\n<pre><code>struct Chain {\n    n: u32,\n}\n\nimpl Chain {\n    fn new(start: u32) -&gt; Chain {\n        Chain { n: start }\n    }\n}\n\nimpl Iterator for Chain {\n    type Item = u32;\n\n    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {\n        self.n = digit_factorial_sum(self.n);\n        Some(self.n)\n    }\n}\n</code></pre>\n\n<p>Now what I'd like to do it <code>take</code> while the iterator is producing unique values. So I'm <code>inspect</code>-ing the chain and pushing to a vector and then checking it in a <code>take_while</code> scope:</p>\n\n<pre><code>let mut v = Vec::with_capacity(terms);\nChain::new(i)\n    .inspect(|&amp;x| {\n        v.push(x)\n    })\n    .skip_while(|&amp;x| {\n        return v.contains(&amp;x);\n    })\n</code></pre>\n\n<p>However, the Rust compile spits out this error:</p>\n\n<pre><code>error: cannot borrow `v` as immutable because it is also borrowed as mutable [E0502]\n...\nborrow occurs due to use of `v` in closure\n    return v.contains(&amp;x);\n           ^\nprevious borrow of `v` occurs here due to use in closure; the mutable borrow prevents subsequent moves, borrows, or modification of `v` until the borrow ends\n    .inspect(|&amp;x| {\n        v.push(x)\n    })\n</code></pre>\n\n<p>Obviously I don't understand the concept of \"borrowing\". What am I doing wrong?</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1460297053, "post_id": 36514013, "comment_id": 60665221, "body": "You can consider <code>struct PeekableRead&lt;&#39;a, R: &#39;a + Read&gt;</code> the externally visible API for the struct, while the fields are implementation details. Yet this motivation is not a general rule, because we can think of some properties of the struct that are not explicitly spelled out like this (variance of each generic parameter and auto traits)."}], "tags": [], "owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "is_accepted": false, "score": 2, "last_activity_date": 1460187012, "creation_date": 1460187012, "answer_id": 36514013, "question_id": 36511601, "link": "https://stackoverflow.com/questions/36511601/why-does-this-struct-member-need-two-lifetimes/36514013#36514013", "title": "Why does this struct member need two lifetimes?", "body": "<blockquote>\n  <p>Doesn't the 'a on the reference specify the lifetime?</p>\n</blockquote>\n\n<p>It specifies the lifetime of <em>the reference</em>, but not the lifetime of the value being pointed to. Which explains your observation that</p>\n\n<blockquote>\n  <p>if I add 'a to R and remove it from the reference, I still get error: missing lifetime specifier.</p>\n</blockquote>\n\n<p>For the struct to be valid we need both: the value being pointed to must still be alive, and so must the reference. (Although logically, the first condition is implied by the second, since a reference can never outlive the value it points to.).</p>\n"}, {"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 1, "last_activity_date": 1460240120, "creation_date": 1460240120, "answer_id": 36523365, "question_id": 36511601, "link": "https://stackoverflow.com/questions/36511601/why-does-this-struct-member-need-two-lifetimes/36523365#36523365", "title": "Why does this struct member need two lifetimes?", "body": "<p>The lifetime parameter on a reference designates the lifetime of the referent (i.e. the object the reference points to). That object may be a reference, or a complex object that contains one or more references. However, when you use a trait, the lifetime of the objects behind those references are somewhat hidden (the trait itself doesn't know about those lifetimes); lifetime bounds are what lets the compiler reason correctly about those lifetimes.</p>\n\n<p>When you use a generic type behind a reference, you need to add a bound to ensure that instances of that type don't contain references that are shorter than the reference to that those instances. Bounds are not implicitly added just based on how you use types: the bounds should not change based on the details of what fields are in the struct and what type you define them to be.</p>\n\n<p>For example, the type <code>&amp;'f File</code> (for each <code>'f</code>) implements <code>Read</code>. We can instantiate <code>PeekableRead</code> with that type: this gives us a <code>PeekableRead&lt;&amp;'f File&gt;</code>. <code>PeekableRead&lt;&amp;'f File&gt;</code> stores a mutable reference to a <code>&amp;'f File</code>, so the concrete type of the <code>reader</code> field is <code>&amp;'a mut &amp;'f File</code>. In order for such a reference to be valid, <code>'a</code> must be shorter or equal to <code>'f</code>. If <code>'f</code> was shorter than <code>'a</code>, then you could replace the <code>&amp;'f File</code> with one that would be dropped before the reference is dropped, leading to a dangling pointer. When you add the <code>'a</code> bound to <code>R</code> (i.e. when you write <code>R: Read + 'a</code>), you say \"<em>instances of <code>R</code> must outlive <code>'a</code></em>\" (i.e. <code>R</code> may not contain references shorter than <code>'a</code>).</p>\n"}], "owner": {"reputation": 37636, "user_id": 101999, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/ab9e16b1296c16bc63f02f6dff5e3dc6?s=128&d=identicon&r=PG", "display_name": "Thanatos", "link": "https://stackoverflow.com/users/101999/thanatos"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 462, "favorite_count": 1, "answer_count": 2, "score": 4, "last_activity_date": 1460240120, "creation_date": 1460164052, "question_id": 36511601, "link": "https://stackoverflow.com/questions/36511601/why-does-this-struct-member-need-two-lifetimes", "title": "Why does this struct member need two lifetimes?", "body": "<p>I have the following <code>struct</code>:</p>\n\n<pre><code>struct PeekableRead&lt;'a, R: Read&gt; {\n    reader: &amp;'a mut R,\n    peeked_octet: Option&lt;u8&gt;,\n}\n</code></pre>\n\n<p>Which <code>rustc</code> does not like:</p>\n\n<pre><code>\u2026:27:1: 30:2 error: the parameter type `R` may not live long enough [E0309]\n\u2026:27 struct PeekableRead&lt;'a, R: Read&gt; {\n\u2026:28    reader: &amp;'a mut R,\n\u2026:29    peeked_octet: Option&lt;u8&gt;,\n\u2026:30 }\n\u2026:27:1: 30:2 help: run `rustc --explain E0309` to see a detailed explanation\n\u2026:27:1: 30:2 help: consider adding an explicit lifetime bound `R: 'a`...\n\u2026:27:1: 30:2 note: ...so that the reference type `&amp;'a mut R` does not outlive the data it points at\n\u2026:27 struct PeekableRead&lt;'a, R: Read&gt; {\n\u2026:28    reader: &amp;'a mut R,\n\u2026:29    peeked_octet: Option&lt;u8&gt;,\n\u2026:30 }\n</code></pre>\n\n<p>If I add the lifetime to <code>R</code>, as in, <code>R: Read + 'a</code>, it works. But <em>why</em>? Doesn't the <code>'a</code> on the reference specify the lifetime? Must not <code>reader: &amp;'a mut R</code>, in a <code>struct PeekableRead&lt;'a&gt;</code> live as long as the struct itself, and thus, \"long enough\"?</p>\n\n<p>Oddly, I seem to need <em>both</em>; if I add <code>'a</code> to <code>R</code> and remove it from the reference, I still get <code>error: missing lifetime specifier</code>. The only way I get a successful compilation is with both, but to me, they appear to specify the same thing redundantly.</p>\n\n<p>(Also, why does <code>rustc</code> output the <code>struct</code> twice in the output? The second one looks like a suggestion of what to do, but appears to be exactly the same as what I have\u2026)</p>\n"}, {"tags": ["multithreading", "rust"], "answers": [{"tags": [], "owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "is_accepted": true, "score": 3, "last_activity_date": 1460235204, "last_edit_date": 1460235204, "creation_date": 1460233314, "answer_id": 36522230, "question_id": 36511332, "link": "https://stackoverflow.com/questions/36511332/rust-lifetimes-with-mpscsenderta-and-threads/36522230#36522230", "title": "Rust Lifetimes with mpsc::Sender&lt;T&lt;&#39;a&gt;&gt; and threads", "body": "<p>When you spawn a thread it can potentially live forever; certainly outliving your <code>Transport&lt;'a&gt;</code> type for any lifetime <code>'a</code> other than <code>'static</code> (the error messages are very confusing though). When you call <code>thread::spawn</code> with a closure, that closure must have the <code>'static</code> lifetime, which is only true if <code>'a == 'static</code>.</p>\n\n<p>As you are not actually sending an object with a lifetime across the channel, consider using the <code>'static</code> lifetime explicitly:</p>\n\n<pre><code>impl Connector for Transport&lt;'static&gt; {\n    ...\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=449d7da7ded6f8b1f0d5da0e1f852739&amp;version=stable&amp;backtrace=1\" rel=\"nofollow\">Playpen</a></p>\n\n<p>Edit:</p>\n\n<p>Manually annotating the types for the sender and receiver</p>\n\n<pre><code>    let (tx, rx): (mpsc::Sender&lt;Message&lt;'a&gt;&gt;, mpsc::Receiver&lt;Message&lt;'a&gt;&gt;) = mpsc::channel();\n    let tx_send: mpsc::Sender&lt;Message&lt;'a&gt;&gt; = tx.clone();\n</code></pre>\n\n<p>shows you a much more sensible error</p>\n\n<pre><code>&lt;anon&gt;:27:22: 27:35 error: the type `[closure@&lt;anon&gt;:27:36: 29:10 tx_send:std::sync::mpsc::Sender&lt;Message&lt;'a&gt;&gt;]` does not fulfill the required lifetime [E0477]\n&lt;anon&gt;:27         let handle = thread::spawn(move || {\n                               ^~~~~~~~~~~~~\nnote: type must outlive the static lifetime\nerror: aborting due to previous error\nplaypen: application terminated with error code 101\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=0b7ba2a58494c65c35cc7fa4a1a56068&amp;version=stable&amp;backtrace=1\" rel=\"nofollow\">Playpen</a></p>\n"}], "owner": {"reputation": 63, "user_id": 6179470, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-WWRfd_pzdKk/AAAAAAAAAAI/AAAAAAAAAMY/ujmx743voe8/photo.jpg?sz=128", "display_name": "alainh", "link": "https://stackoverflow.com/users/6179470/alainh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 862, "favorite_count": 0, "accepted_answer_id": 36522230, "answer_count": 1, "score": 5, "last_activity_date": 1460235204, "creation_date": 1460161453, "last_edit_date": 1460162329, "question_id": 36511332, "link": "https://stackoverflow.com/questions/36511332/rust-lifetimes-with-mpscsenderta-and-threads", "title": "Rust Lifetimes with mpsc::Sender&lt;T&lt;&#39;a&gt;&gt; and threads", "body": "<p>I'm creating a multi-threaded application where I create a receiving channel and a structure to hold the sending channel (to be used later by the implementation). However, the type I'm sending through the channel has a lifetime specification. This type is <code>websocket::message:Message</code>\nfrom the rusts-weboscket library. Because of this specification, rust can't seem to correctly infer lifetimes when it gets passed through a thread.</p>\n\n<p>Here's a rust playground example of this error: \n<a href=\"https://play.rust-lang.org/?gist=7e37547d1c811185654f10a6a461e1ef&amp;version=stable&amp;backtrace=1\" rel=\"nofollow\">https://play.rust-lang.org/?gist=7e37547d1c811185654f10a6a461e1ef&amp;version=stable&amp;backtrace=1</a></p>\n\n<p>Now, I have tried using crossbeam to scope the lifetime, and this seems to solve that immediate issue, but in practically just delegates the lifetime specification issue somewhere else.</p>\n\n<p>In my code I get the error:</p>\n\n<pre><code>   $ cargo check\n   Compiling rump v0.1.0 (file:///home/alainh/UPenn/CIS198/Rump)\ntransport.rs:200:42: 200:57 error: cannot infer an appropriate lifetime for autoref due to conflicting requirements [E0495]\ntransport.rs:200         self.sender.send(self.serializer.encode(message));\n                                                          ^~~~~~~~~~~~~~~\ntransport.rs:199:5: 202:6 help: consider using an explicit lifetime parameter as shown: fn send&lt;T: Encodable&gt;(&amp;'a mut self, message: &amp;T) -&gt; WampResult&lt;()&gt;\ntransport.rs:199     fn send&lt;T: Encodable&gt;(&amp;mut self, message: &amp;T) -&gt; WampResult&lt;()&gt; {\ntransport.rs:200         self.sender.send(self.serializer.encode(message));\ntransport.rs:201         Ok(())\ntransport.rs:202     }\nerror: aborting due to previous error\nCould not compile `rump`.\n</code></pre>\n\n<p>The line in question is this one:\n<a href=\"https://github.com/aehernandez/Rump/blob/ad717c7ef11857e94d0e1c02539667c8034676c4/src/transport.rs#L199\" rel=\"nofollow\">https://github.com/aehernandez/Rump/blob/ad717c7ef11857e94d0e1c02539667c8034676c4/src/transport.rs#L199</a></p>\n\n<p>At this point I'm unsure how to exactly solve this lifetime issue. I don't want to keep delegating it somewhere else. Is there a good solution to this?</p>\n"}, {"tags": ["closures", "rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 1356, "user_id": 828394, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/81f88fce4709acf2047a0da477a4134f?s=128&d=identicon&r=PG", "display_name": "josh", "link": "https://stackoverflow.com/users/828394/josh"}, "edited": false, "score": 0, "creation_date": 1460210483, "post_id": 36511686, "comment_id": 60640986, "body": "Perfect, thanks. In this case is it correct that when we <code>move</code> the closure to the heap we are also moving a mutable version of it&#39;s environment because we have declared this as an <code>FnMut</code>? So, declaring the return type as <code>FnMut</code> has changed the semantics of <code>move</code>? Also, I&#39;m not what you mean by <code>interior mutability</code>."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 1356, "user_id": 828394, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/81f88fce4709acf2047a0da477a4134f?s=128&d=identicon&r=PG", "display_name": "josh", "link": "https://stackoverflow.com/users/828394/josh"}, "edited": false, "score": 0, "creation_date": 1460210884, "post_id": 36511686, "comment_id": 60641123, "body": "@Josh Data <i>itself</i> is not mutable or immutable in Rust; that&#39;s a property of how you access it.  That said, yes; the closure captures <code>res</code> by value, and since we move the closure on to the heap, the captured <code>res</code> goes with it.  Also, see <a href=\"http://doc.rust-lang.org/book/mutability.html#interior-vs-exterior-mutability\" rel=\"nofollow noreferrer\">Interior vs. Exterior Mutability</a> from the book."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 4, "last_activity_date": 1460164988, "creation_date": 1460164988, "answer_id": 36511686, "question_id": 36511141, "link": "https://stackoverflow.com/questions/36511141/returning-closures-which-capture-outer-variables-in-rust/36511686#36511686", "title": "Returning closures which capture outer variables in Rust", "body": "<p>You need to do two things here: make <code>res</code> mutable, and return an <code>FnMut</code> closure, not an <code>Fn</code> one:</p>\n\n<pre><code>pub struct CowRow {\n    time: u64,\n}\n\npub fn agg1() -&gt; Box&lt;FnMut(&amp;CowRow) -&gt; u64&gt; {\n    let mut res = 0;\n    Box::new(move |r| { res += r.time; res })\n}\n\nfn main() {\n    let mut c = agg1();\n    let moo = CowRow { time: 2 };\n    println!(\"{:?}\", c(&amp;moo));\n    println!(\"{:?}\", c(&amp;moo));\n    println!(\"{:?}\", c(&amp;moo));\n}\n</code></pre>\n\n<p>The <code>Fn</code> trait forbids the implementor from changing itself when invoked.  Since this closure is modifying its own state, this means it cannot be <code>Fn</code> [1].  Instead, you need to use <code>FnMut</code> which <em>does</em> allow mutation of the closure's captured environment.</p>\n\n<hr>\n\n<p>[1]: Unless you involve interior mutability, of course.</p>\n"}, {"comments": [{"owner": {"reputation": 1356, "user_id": 828394, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/81f88fce4709acf2047a0da477a4134f?s=128&d=identicon&r=PG", "display_name": "josh", "link": "https://stackoverflow.com/users/828394/josh"}, "edited": false, "score": 0, "creation_date": 1460301637, "post_id": 36523586, "comment_id": 60666923, "body": "This is great. Thanks for adding more details to the answer!"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 2, "last_activity_date": 1460241689, "last_edit_date": 1495540783, "creation_date": 1460241689, "answer_id": 36523586, "question_id": 36511141, "link": "https://stackoverflow.com/questions/36511141/returning-closures-which-capture-outer-variables-in-rust/36523586#36523586", "title": "Returning closures which capture outer variables in Rust", "body": "<p><a href=\"https://stackoverflow.com/a/36511686/234590\">DK.</a> already said how to fix <code>agg1</code>, but I wanted to explain what's wrong with <code>agg0</code>, for completeness.</p>\n\n<pre><code>pub fn agg0() -&gt; Box&lt;Fn(&amp;CowRow, &amp;mut i32)&gt; {\n    Box::new(move |r, &amp;mut acc| { acc += r.time; })\n}\n</code></pre>\n\n<p>We can infer from <code>agg0</code>'s return type that the type of the closure's second parameter is <code>&amp;mut i32</code>. <code>&amp;mut acc</code> is a pattern that deconstructs the mutable reference, defining <code>acc</code> as an <code>i32</code>, initialized to a <em>copy</em> of the referenced value. You can't mutate it, because you didn't define <code>acc</code> to be mutable (you'd need to write <code>&amp;mut mut acc</code> instead of <code>&amp;mut acc</code>), but that's not what you want anyway, because then you'd be mutating a copy. What you want is to mutate the pointed-to integer, so you need to define your closure like this:</p>\n\n<pre><code>pub fn agg0() -&gt; Box&lt;Fn(&amp;CowRow, &amp;mut i32)&gt; {\n    Box::new(move |r, acc| { *acc += r.time; })\n}\n</code></pre>\n\n<p>Here, the type of <code>acc</code> is <code>&amp;mut i32</code>, so in order to mutate the <code>i32</code>, we need to dereference the pointer first (this yields an lvalue that refers to the <code>i32</code> behind the pointer; it's <em>not</em> a copy!).</p>\n"}], "owner": {"reputation": 1356, "user_id": 828394, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/81f88fce4709acf2047a0da477a4134f?s=128&d=identicon&r=PG", "display_name": "josh", "link": "https://stackoverflow.com/users/828394/josh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1420, "favorite_count": 1, "accepted_answer_id": 36511686, "answer_count": 2, "score": 4, "last_activity_date": 1460241689, "creation_date": 1460159862, "last_edit_date": 1495540783, "question_id": 36511141, "link": "https://stackoverflow.com/questions/36511141/returning-closures-which-capture-outer-variables-in-rust", "title": "Returning closures which capture outer variables in Rust", "body": "<p>As the title states I am looking to return a closure from a function which has some initial, mutable state. In the following examples <code>CowRow</code> is a <code>struct</code> with a <code>time</code> field. It also has a <code>String</code> field, so is thus not copyable. Concretely, I would like a function that looks something like:</p>\n\n<pre><code>pub fn agg1() -&gt; Box&lt;Fn(&amp;CowRow)&gt; {\n    let res = 0;\n    Box::new(move |r| { res += r.time; })\n}\n</code></pre>\n\n<p>Of course, this produces the error:</p>\n\n<pre><code>src/queries.rs:9:25: 9:38 error: cannot assign to captured outer variable in an `Fn` closure\nsrc/queries.rs:9     Box::new(move |r| { res += r.time; })\n                                         ^~~~~~~~~~~~~\nsrc/queries.rs:9:14: 9:41 help: consider changing this closure to take self by mutable reference\nsrc/queries.rs:9     Box::new(move |r| { res += r.time; })\n                              ^~~~~~~~\n</code></pre>\n\n<p>It is my understanding that Rust needs to know about the size of returned values and because closures borrow their stack frame from their environment we need to introduce the <code>Box</code> and <code>move</code> to get a size for the return and put the closure on the heap.</p>\n\n<p>Is there some way to also put <code>res</code> on the heap in this closures environment? Or otherwise allow for this behaviour? Of course I have looked at: <a href=\"https://stackoverflow.com/questions/30559073/cannot-borrow-captured-outer-variable-in-an-fn-closure-as-mutable\">Cannot borrow captured outer variable in an `Fn` closure as mutable</a> but this seems overly complicated and it's not clear to me how this would perform in the case of multiple threads running this function simultaneously. </p>\n\n<p>Another technique I tried was to change the closure to take a mutable reference to an <code>i32</code> which I can initialise outside of the <code>agg</code> function. Example:</p>\n\n<pre><code>pub fn agg0() -&gt; Box&lt;Fn(&amp;CowRow, &amp;mut i32)&gt; {\n    Box::new(move |r, &amp;mut acc| { acc += r.time; })\n}\n</code></pre>\n\n<p>However, this produces the error:</p>\n\n<pre><code>src/queries.rs:4:35: 4:48 error: re-assignment of immutable variable `acc` [E0384]\nsrc/queries.rs:4     Box::new(move |r, &amp;mut acc| { acc += r.time; })\n                                                   ^~~~~~~~~~~~~\nsrc/queries.rs:4:35: 4:48 help: run `rustc --explain E0384` to see a detailed explanation\nsrc/queries.rs:4:28: 4:31 note: prior assignment occurs here\nsrc/queries.rs:4     Box::new(move |r, &amp;mut acc| { acc += r.time; })\n</code></pre>\n\n<p>This one is a total mystery to me.</p>\n"}, {"tags": ["string", "rust", "dereference"], "comments": [{"owner": {"reputation": 37741, "user_id": 3425536, "user_type": "registered", "accept_rate": 72, "profile_image": "https://graph.facebook.com/1484495923/picture?type=large", "display_name": "emlai", "link": "https://stackoverflow.com/users/3425536/emlai"}, "edited": false, "score": 2, "creation_date": 1460154974, "post_id": 36510340, "comment_id": 60627419, "body": "See <a href=\"https://doc.rust-lang.org/book/deref-coercions.html\" rel=\"nofollow noreferrer\"><code>Deref</code> coercions</a>. The second code sample is almost exactly what you have."}, {"owner": {"reputation": 13014, "user_id": 4140572, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2uRSa.png?s=128&g=1", "display_name": "Angel Angel", "link": "https://stackoverflow.com/users/4140572/angel-angel"}, "edited": false, "score": 0, "creation_date": 1460159143, "post_id": 36510340, "comment_id": 60628689, "body": "maybe this help you <a href=\"http://stackoverflow.com/questions/36437375/why-i-can-use-sort-by-key-with-a-vec\" title=\"why i can use sort by key with a vec\">stackoverflow.com/questions/36437375/&hellip;</a> for Deref"}], "answers": [{"tags": [], "owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "is_accepted": true, "score": 3, "last_activity_date": 1460155074, "creation_date": 1460155074, "answer_id": 36510425, "question_id": 36510340, "link": "https://stackoverflow.com/questions/36510340/why-does-applying-to-a-string-return-a-str/36510425#36510425", "title": "Why does applying &amp; to a String return a &amp;str?", "body": "<p>What's going on here is called <a href=\"https://doc.rust-lang.org/book/deref-coercions.html\" rel=\"nofollow\">deref coercions</a>. These allow references to types that implement the <a href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html\" rel=\"nofollow\">Deref trait</a> to be used in place of references to other types. As your example shows, <code>&amp;String</code> can be used anywhere a <code>&amp;str</code> is required, because <code>String</code> implements <code>Deref</code> to <code>str</code>.</p>\n"}], "owner": {"reputation": 1137, "user_id": 595228, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/c10759c95ccd09685b5e4cc9fdfee1d8?s=128&d=identicon&r=PG", "display_name": "Tim McLean", "link": "https://stackoverflow.com/users/595228/tim-mclean"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 63, "favorite_count": 0, "accepted_answer_id": 36510425, "answer_count": 1, "score": 0, "last_activity_date": 1460378585, "creation_date": 1460154607, "last_edit_date": 1460378585, "question_id": 36510340, "link": "https://stackoverflow.com/questions/36510340/why-does-applying-to-a-string-return-a-str", "title": "Why does applying &amp; to a String return a &amp;str?", "body": "<p>In this example code <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" rel=\"nofollow\">from the Rust documentation</a>:</p>\n\n<pre><code>fn takes_str(s: &amp;str) { }\n\nlet s = String::from(\"Hello\");\n\ntakes_str(&amp;s);\n</code></pre>\n\n<p>What exactly is going on behind the scenes that causes <code>&amp;s</code> to become a <code>&amp;str</code> instead of a <code>&amp;String</code>?  The documentation seems to suggest that there's some dereferencing going on, but I thought <code>*</code> was for dereferencing, not <code>&amp;</code>?</p>\n"}, {"tags": ["enums", "casting", "rust"], "comments": [{"owner": {"reputation": 125, "user_id": 2262126, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/768939c954a89140c8d0c5b975c860f4?s=128&d=identicon&r=PG", "display_name": "Sergey ", "link": "https://stackoverflow.com/users/2262126/sergey"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460148528, "post_id": 36508580, "comment_id": 60624961, "body": "@Shepmaster yes, you are right it doesn&#39;t compile. I think I should mention it in original post. I was trying to match random string slice to specific enum."}], "answers": [{"comments": [{"owner": {"reputation": 125, "user_id": 2262126, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/768939c954a89140c8d0c5b975c860f4?s=128&d=identicon&r=PG", "display_name": "Sergey ", "link": "https://stackoverflow.com/users/2262126/sergey"}, "edited": false, "score": 0, "creation_date": 1460148742, "post_id": 36509053, "comment_id": 60625060, "body": "Thanks @Shepmaster, it looks perfect."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 18, "last_activity_date": 1544541875, "last_edit_date": 1544541875, "creation_date": 1460148343, "answer_id": 36509053, "question_id": 36508580, "link": "https://stackoverflow.com/questions/36508580/how-to-convert-a-string-to-an-enum/36509053#36509053", "title": "How to convert a string to an enum?", "body": "<p>The correct thing is to implement <a href=\"http://doc.rust-lang.org/std/str/trait.FromStr.html\" rel=\"noreferrer\"><code>FromStr</code></a>. Here, I'm matching against the string literals that represent each enum variant:</p>\n\n<pre><code>#[derive(Debug)]\nenum WSType {\n    Ack,\n    Request,\n    Response,\n}\n\nimpl std::str::FromStr for WSType {\n    type Err = String;\n\n    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {\n        match s {\n            \"ACK\" =&gt; Ok(WSType::Ack),\n            \"REQUEST\" =&gt; Ok(WSType::Request),\n            \"RESPONSE\" =&gt; Ok(WSType::Response),\n            _ =&gt; Err(format!(\"'{}' is not a valid value for WSType\", s)),\n        }\n    }\n}\n\nfn main() {\n    let as_enum: WSType = \"ACK\".parse().unwrap();\n    println!(\"{:?}\", as_enum);\n\n    let as_enum: WSType = \"UNKNOWN\".parse().unwrap();\n    println!(\"{:?}\", as_enum);\n}\n</code></pre>\n\n<p>To print a value, implement <a href=\"https://doc.rust-lang.org/std/fmt/trait.Display.html\" rel=\"noreferrer\"><code>Display</code></a> or <a href=\"https://doc.rust-lang.org/std/fmt/trait.Debug.html\" rel=\"noreferrer\"><code>Debug</code></a> (I've derived <code>Debug</code> here). Implementing <code>Display</code> also gives you <code>.to_string()</code>.</p>\n\n<hr>\n\n<p>In certain cases, there are crates that can reduce some of the tedium of this type of conversion. <a href=\"https://crates.io/crates/strum\" rel=\"noreferrer\">strum</a> is one such crate:</p>\n\n<pre><code>use strum_macros::EnumString;\n\n#[derive(Debug, EnumString)]\n#[strum(serialize_all = \"shouty_snake_case\")]\nenum WSType {\n    Ack,\n    Request,\n    Response,\n}\n</code></pre>\n"}], "owner": {"reputation": 125, "user_id": 2262126, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/768939c954a89140c8d0c5b975c860f4?s=128&d=identicon&r=PG", "display_name": "Sergey ", "link": "https://stackoverflow.com/users/2262126/sergey"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1729, "favorite_count": 1, "accepted_answer_id": 36509053, "answer_count": 1, "score": 8, "last_activity_date": 1544541875, "creation_date": 1460146533, "last_edit_date": 1544541432, "question_id": 36508580, "link": "https://stackoverflow.com/questions/36508580/how-to-convert-a-string-to-an-enum", "title": "How to convert a string to an enum?", "body": "<p>My <a href=\"https://play.rust-lang.org/?gist=08f08974535dcbbab05a870695c0dcc8&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">original approach</a> was to create method called <code>to_str()</code> which will return a slice, but I am not sure that it is correct approach because this code doesn't compile.</p>\n\n<pre><code>enum WSType {\n    ACK,\n    REQUEST,\n    RESPONSE,\n}\n\nimpl WSType {\n    fn to_str(&amp;self) -&gt; &amp;str {\n        match self {\n            ACK =&gt; \"ACK\",\n            REQUEST =&gt; \"REQUEST\",\n            RESPONSE =&gt; \"RESPONSE\",            \n        }\n    }\n}\n\nfn main() {\n    let val = \"ACK\";\n    // test\n    match val {\n        ACK.to_str() =&gt; println!(\"ack\"),\n        REQUEST.to_str() =&gt; println!(\"ack\"),\n        RESPONSE.to_str() =&gt; println!(\"ack\"),\n        _ =&gt; println!(\"unexpected\"),\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 25756, "user_id": 39648, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/0d9ffb2252f073517660f2d0bf71d0db?s=128&d=identicon&r=PG", "display_name": "Autodidact", "link": "https://stackoverflow.com/users/39648/autodidact"}, "edited": false, "score": 0, "creation_date": 1460137024, "post_id": 36505505, "comment_id": 60618731, "body": "&quot;Specifically, the T parameter for std::slice::Iter is different from the T declared on reversed&quot;  This is probably true in the general case when there is no link between the two but I was under the impression that saying <code>Item=&amp;&#39;a T</code> in <code>DoubleEndedIterator&lt;Item=&amp;&#39;a T&gt;</code> linked these separate <code>T</code>s.  Anyway thanks for your response, the second part answers my question."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1460135569, "creation_date": 1460135569, "answer_id": 36505505, "question_id": 36505268, "link": "https://stackoverflow.com/questions/36505268/how-does-the-cloned-iterator-adapter-work-with-iteratort/36505505#36505505", "title": "How does the `Cloned` iterator adapter work with `Iterator&lt;T&gt;`?", "body": "<p><code>T</code> is generic parameter, and it has a scope in which it applies. Specifically, the <code>T</code> parameter for <a href=\"http://doc.rust-lang.org/std/slice/struct.Iter.html\" rel=\"nofollow\"><code>std::slice::Iter</code></a> is <strong>different</strong> from the <code>T</code> declared on <code>reversed</code>. If this were not the case, I think that it would basically be impossible for humans to ever use generics. It would be like if every variable called <code>name</code> referred to the same thing!</p>\n\n<blockquote>\n  <p>but <code>iter()</code> returns an <code>Iterator&lt;T&gt;</code></p>\n</blockquote>\n\n<p>This isn't true; you can't currently return a trait. You can only return a type that <strong>implements</strong> a trait. Additionally, <code>std::slice::Iter&lt;T&gt;</code> implements <code>Iterator</code> by returning references to <code>T</code>: </p>\n\n<pre><code>impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {\n    type Item = &amp;'a T\n }\n</code></pre>\n"}], "owner": {"reputation": 25756, "user_id": 39648, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/0d9ffb2252f073517660f2d0bf71d0db?s=128&d=identicon&r=PG", "display_name": "Autodidact", "link": "https://stackoverflow.com/users/39648/autodidact"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 129, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1460135569, "creation_date": 1460134680, "last_edit_date": 1460135210, "question_id": 36505268, "link": "https://stackoverflow.com/questions/36505268/how-does-the-cloned-iterator-adapter-work-with-iteratort", "title": "How does the `Cloned` iterator adapter work with `Iterator&lt;T&gt;`?", "body": "<p>Why does the following code work when <code>Cloned</code> expects a <code>DoubleEndedIterator&lt;Item=&amp;'a T&gt;</code> but <code>iter()</code> returns an <code>Iterator&lt;T&gt;</code> (instead of an <code>Iterator&lt;&amp;T&gt;</code> as it expects)?</p>\n\n<pre><code>use std::clone::Clone;\nuse std::iter::{Rev, Cloned};\nuse std::fmt::Debug;\n\nfn reversed&lt;'a, U, T&gt;(iter: U) -&gt; Rev&lt;Cloned&lt;U&gt;&gt;\n    where U: DoubleEndedIterator&lt;Item=&amp;'a T&gt;,\n          T: 'a + Clone + Debug\n{\n    iter.cloned().rev()\n}\n\nfn main() {\n    let v0 = (0..10).collect::&lt;Vec&lt;u32&gt;&gt;();\n    let mut v0r = v0.clone();\n    v0r.reverse();\n\n    assert_eq!(v0r, reversed(v0.iter()).collect::&lt;Vec&lt;_&gt;&gt;());\n}\n</code></pre>\n"}, {"tags": ["rust", "rust-cargo", "nickel"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460104527, "post_id": 36494766, "comment_id": 60597962, "body": "have you read the instructions for openssl? <a href=\"https://github.com/sfackler/rust-openssl#osx\" rel=\"nofollow noreferrer\">github.com/sfackler/rust-openssl#osx</a>"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460104660, "post_id": 36494766, "comment_id": 60598038, "body": "also someone having a similar issue on osx: <a href=\"https://github.com/sfackler/rust-openssl/issues/366\" rel=\"nofollow noreferrer\">github.com/sfackler/rust-openssl/issues/366</a>"}], "owner": {"reputation": 369, "user_id": 5173659, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/624d5aeb91c736829677f5ecd9f7bde6?s=128&d=identicon&r=PG&f=1", "display_name": "menawi", "link": "https://stackoverflow.com/users/5173659/menawi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 56, "favorite_count": 0, "closed_date": 1460118931, "answer_count": 0, "score": 0, "last_activity_date": 1460757571, "creation_date": 1460103459, "last_edit_date": 1460757571, "question_id": 36494766, "link": "https://stackoverflow.com/questions/36494766/cargo-fails-to-build-openssl", "closed_reason": "Duplicate", "title": "Cargo fails to build openssl", "body": "<p>I'm building a web application using nickel.rs. Everything's going fine but when I execute <code>cargo run</code>, I get the following error because of the hyper dependancy:</p>\n\n<pre><code>   Compiling openssl-sys-extras v0.7.9\n   Compiling openssl-sys v0.7.9\n   Compiling openssl v0.7.9\nBuild failed, waiting for other jobs to finish...\nfailed to run custom build command for `openssl v0.7.9`\nProcess didn't exit successfully: `/Users/menawi/Developer/rust/nickelodean/target/debug/build/openssl-66237fc32eb1ac40/build-script-build` (exit code: 101)\n--- stdout\nTARGET = Some(\"x86_64-apple-darwin\")\nOPT_LEVEL = Some(\"0\")\nPROFILE = Some(\"debug\")\nTARGET = Some(\"x86_64-apple-darwin\")\ndebug=true opt-level=0\nHOST = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nHOST = Some(\"x86_64-apple-darwin\")\nCC_x86_64-apple-darwin = None\nCC_x86_64_apple_darwin = None\nHOST_CC = None\nCC = None\nHOST = Some(\"x86_64-apple-darwin\")\nTARGET = Some(\"x86_64-apple-darwin\")\nHOST = Some(\"x86_64-apple-darwin\")\nCFLAGS_x86_64-apple-darwin = None\nCFLAGS_x86_64_apple_darwin = None\nHOST_CFLAGS = None\nCFLAGS = None\nrunning: \"cc\" \"-O0\" \"-ffunction-sections\" \"-fdata-sections\" \"-g\" \"-m64\" \"-fPIC\" \"-o\" \"/Users/menawi/Developer/rust/nickelodean/target/debug/build/openssl-66237fc32eb1ac40/out/src/c_helpers.o\" \"-c\" \"src/c_helpers.c\"\nExitStatus(ExitStatus(256))\n\n\ncommand did not execute successfully, got: exit code: 1\n\n\n\n--- stderr\nsrc/c_helpers.c:1:10: fatal error: 'openssl/ssl.h' file not found\n#include &lt;openssl/ssl.h&gt;\n         ^\n1 error generated.\nthread '&lt;main&gt;' panicked at 'explicit panic', /Users/menawi/.cargo/registry/src/github.com-88ac128001ac3a9a/gcc-0.3.26/src/lib.rs:818\n</code></pre>\n\n<p>I need openssl because my web application needs to make <code>https</code> requests. How can I fix this error? I've attached a copy of my <code>Cargo.toml</code> file below:</p>\n\n<pre><code>[package]\nname = \"nickelodean\"\nversion = \"0.1.0\"\n\n[dependencies]\nnickel = \"0.8.0\"\nmustache = \"0.7.0\"\nrustc-serialize = \"0.3.18\"\nhyper=\"0.8\"\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 2482, "user_id": 1129436, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/09511512293a4e31936309f2c6aee08e?s=128&d=identicon&r=PG", "display_name": "River Tam", "link": "https://stackoverflow.com/users/1129436/river-tam"}, "edited": false, "score": 0, "creation_date": 1460083772, "post_id": 36490602, "comment_id": 60589822, "body": "My hero! If I may ask another question, because we&#39;re doing pattern matching inside the match block, does that cause a move, a copy, or neither? I&#39;m very new to Rust. =)"}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 2482, "user_id": 1129436, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/09511512293a4e31936309f2c6aee08e?s=128&d=identicon&r=PG", "display_name": "River Tam", "link": "https://stackoverflow.com/users/1129436/river-tam"}, "edited": false, "score": 1, "creation_date": 1460088901, "post_id": 36490602, "comment_id": 60591062, "body": "It depends on how you capture them. Your original was causing a move (or trying to move it) because you were capturing <code>p</code> by value. Using <code>ref</code> captures it by reference and therefore doesn&#39;t move it. There are other things to consider here but they&#39;ll only need explaining as your match blocks become actual blocks of code and have some complexity to them. Other things to consider is whether your type is <code>Copy</code> or not.. but again, worry about that later on :)"}, {"owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "edited": false, "score": 1, "creation_date": 1460099348, "post_id": 36490602, "comment_id": 60595026, "body": "It&#39;s considered idiomatic to write <code>match *token { ... }</code>."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "edited": false, "score": 0, "creation_date": 1460166245, "post_id": 36490602, "comment_id": 60630031, "body": "Thanks @A.B. I have updated the answer. I never know what is idiomatic in that instance because different codebases seem to do different things in that regard."}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": true, "score": 3, "last_activity_date": 1460166203, "last_edit_date": 1460166203, "creation_date": 1460083200, "answer_id": 36490602, "question_id": 36490526, "link": "https://stackoverflow.com/questions/36490526/destructuring-while-iterating-through-a-vecenumstring/36490602#36490602", "title": "Destructuring while iterating through a Vec&lt;Enum(String)&gt;", "body": "<p>Your enum owns the strings that are passed in and so destructuring them will attempt to capture them by value (and move it out of the enum).</p>\n\n<p>You can fix this by using <code>ref p</code> while destructuring to capture by reference.. stopping the move. </p>\n\n<pre><code>match *token {\n    Token::Paren(ref p) =&gt; println!(\"Token::Paren({})\", p),\n    Token::Number(ref p) =&gt; println!(\"Token::Number({})\", p),\n    Token::Name(ref p) =&gt; println!(\"Token::Name({})\", p),\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?code=enum%20Token%20%7B%0D%0A%20%20%20%20Paren(String)%2C%0D%0A%20%20%20%20Number(String)%2C%0D%0A%20%20%20%20Name(String)%2C%0D%0A%7D%0D%0A%0D%0Afn%20tokenizer(input%3A%20String)%20-%3E%20Vec%3CToken%3E%20%7B%0D%0A%20%20%20%20vec!%5BToken%3A%3ANumber(%2255%22.to_string())%5D%0D%0A%7D%0D%0A%0D%0Afn%20main()%20%7B%0D%0A%20%20%20%20let%20tokens%20%3D%20tokenizer(%22(add%2044%205)%22.to_owned())%3B%0D%0A%20%20%20%20let%20mut%20iter%20%3D%20tokens.iter()%3B%0D%0A%20%20%20%20while%20let%20Some(token)%20%3D%20iter.next()%20%7B%0D%0A%20%20%20%20%20%20%20%20match%20token%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%26Token%3A%3AParen(ref%20p)%20%3D%3E%20println!(%22Token%3A%3AParen(%7B%7D)%22%2C%20p)%2C%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%26Token%3A%3ANumber(ref%20p)%20%3D%3E%20println!(%22Token%3A%3ANumber(%7B%7D)%22%2C%20p)%2C%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%26Token%3A%3AName(ref%20p)%20%3D%3E%20println!(%22Token%3A%3AName(%7B%7D)%22%2C%20p)%2C%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%7D&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">Working sample on the Playpen</a></p>\n\n<p>Note that you'll also need to dereference the token because you're using <code>iter()</code> which returns references to the tokens in the vector. If you used <code>into_iter()</code>, it would transfer ownership out and you can match on non-references.. however your <code>tokens</code> variable is now broken as the values are moved.</p>\n"}], "owner": {"reputation": 2482, "user_id": 1129436, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/09511512293a4e31936309f2c6aee08e?s=128&d=identicon&r=PG", "display_name": "River Tam", "link": "https://stackoverflow.com/users/1129436/river-tam"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 240, "favorite_count": 0, "accepted_answer_id": 36490602, "answer_count": 1, "score": 1, "last_activity_date": 1460166203, "creation_date": 1460082632, "question_id": 36490526, "link": "https://stackoverflow.com/questions/36490526/destructuring-while-iterating-through-a-vecenumstring", "title": "Destructuring while iterating through a Vec&lt;Enum(String)&gt;", "body": "<p>I have an enum called <code>Token</code> (can you guess what I'm trying to build? :P)</p>\n\n<p>It looks an awful lot like this:</p>\n\n<pre><code>enum Token {\n    Paren(String),\n    Number(String),\n    Name(String),\n}\n</code></pre>\n\n<p>Now, I have a function with the following signature:</p>\n\n<p><code>fn tokenizer(input: String) -&gt; Vec&lt;Token&gt;</code></p>\n\n<p>I have no reason to believe it's not basically working, so I obviously have a <code>Vec&lt;Token&gt;</code>.</p>\n\n<p>Now, in my main function I have this:</p>\n\n<pre><code>let tokens = tokenizer(\"(add 44 5)\".to_owned());\n</code></pre>\n\n<p>and I'd like to do something <em>like</em> the following:</p>\n\n<pre><code>let mut iter = tokens.iter();\nwhile let Some(token) = iter.next() {\n    match token {\n        Token::Paren(p) =&gt; println!(\"Token::Paren({})\", p),\n        Token::Number(p) =&gt; println!(\"Token::Number({})\", p),\n        Token::Name(p) =&gt; println!(\"Token::Name({})\", p),\n    }\n}\n</code></pre>\n\n<p>But obviously the borrow-checker isn't letting me get off so easily.</p>\n\n<p>What's the proper way to do this? Obviously, as you can hopefully tell by the nature of this project, I'm just trying to learn Rust, so any advice would be helpful, even if it's not really related directly to the problem. =)</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 2584, "user_id": 1094609, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/2f03a85e1167ccb340e3d1cb2da67995?s=128&d=identicon&r=PG", "display_name": "Craig M. Brandenburg", "link": "https://stackoverflow.com/users/1094609/craig-m-brandenburg"}, "edited": false, "score": 0, "creation_date": 1460073721, "post_id": 36486921, "comment_id": 60587334, "body": "I&#39;m gonna need a day or two to digest this. It&#39;s simple, yet it blows my mind. My main concern is that in my particular case <code>Complex</code> is exposed in my crate&#39;s API, so I need to make sure I can burden the type with a lifetime parameter without muddying my interface too much. My initial reaction is that <code>Cow</code>&#39;s copy-on-write functionality is too heavy because I&#39;m never doing any copying, but in a sense I almost am, because sometimes I&#39;m using instances and sometimes I&#39;m using references. After I finish digesting your answer, I&#39;ll let you know how it works."}, {"owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "reply_to_user": {"reputation": 2584, "user_id": 1094609, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/2f03a85e1167ccb340e3d1cb2da67995?s=128&d=identicon&r=PG", "display_name": "Craig M. Brandenburg", "link": "https://stackoverflow.com/users/1094609/craig-m-brandenburg"}, "edited": false, "score": 0, "creation_date": 1460097747, "post_id": 36486921, "comment_id": 60594230, "body": "You might be able to get rid of the lifetime parameters. See my edit."}, {"owner": {"reputation": 2584, "user_id": 1094609, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/2f03a85e1167ccb340e3d1cb2da67995?s=128&d=identicon&r=PG", "display_name": "Craig M. Brandenburg", "link": "https://stackoverflow.com/users/1094609/craig-m-brandenburg"}, "edited": false, "score": 0, "creation_date": 1460143766, "post_id": 36486921, "comment_id": 60622529, "body": "I cannot eliminate the lifetime parameter because I sometimes borrow from a non-static <code>str</code>. Nonetheless, I really like your idea because it would simplify code elsewhere because the new <code>Complex</code> covers both the owning and borrowing cases\u2014no need for a unique type for each case. One thing that intrigues me is that the Rust Standard Library didn&#39;t go the route of using <code>Cow</code> in instead of having two types to cover the owning and borrowing cases for <code>Path</code>/<code>PathBuf</code> et al. The <code>Cow</code> idea seems more generalized because it works for complex types, too. Was this done for run-time efficiency?"}], "tags": [], "owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "is_accepted": true, "score": 7, "last_activity_date": 1571681726, "last_edit_date": 1571681726, "creation_date": 1460062111, "answer_id": 36486921, "question_id": 36480845, "link": "https://stackoverflow.com/questions/36480845/how-to-avoid-temporary-allocations-when-using-a-complex-key-for-a-hashmap/36486921#36486921", "title": "How to avoid temporary allocations when using a complex key for a HashMap?", "body": "<p>It sounds like you want this.</p>\n\n<p><code>Cow</code> will accept a <code>&amp;str</code> or <code>String</code>. </p>\n\n<pre><code>use std::borrow::Cow;\n\n#[derive(Debug, Eq, Hash, PartialEq)]\nstruct Complex&lt;'a&gt; {\n    n: i32,\n    s: Cow&lt;'a, str&gt;,\n}\n\nimpl&lt;'a&gt; Complex&lt;'a&gt; {\n    fn new&lt;S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(n: i32, s: S) -&gt; Self {\n        Complex { n: n, s: s.into() }\n    }\n}\n\nfn main() {\n    let mut m = std::collections::HashMap::&lt;Complex&lt;'_&gt;, i32&gt;::new();\n    m.insert(Complex::new(42, \"foo\"), 123);\n\n    assert_eq!(123, *m.get(&amp;Complex::new(42, \"foo\")).unwrap());\n}\n</code></pre>\n\n<p>A comment about lifetime parameters:</p>\n\n<p>If you don't like the lifetime parameter and you only need to work with <code>&amp;'static str</code> or <code>String</code> then you can use <code>Cow&lt;'static, str&gt;</code> and remove the other lifetime parameters from the impl block and struct definition.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 4, "last_activity_date": 1571681645, "last_edit_date": 1571681645, "creation_date": 1527033724, "answer_id": 50478038, "question_id": 36480845, "link": "https://stackoverflow.com/questions/36480845/how-to-avoid-temporary-allocations-when-using-a-complex-key-for-a-hashmap/50478038#50478038", "title": "How to avoid temporary allocations when using a complex key for a HashMap?", "body": "<p>You can follow the ideas described in <a href=\"https://stackoverflow.com/q/45786717/155423\">How to implement HashMap with two keys?</a>. Here's the <a href=\"https://stackoverflow.com/a/45795699/155423\">\"borrowed trait object\" answer</a> applied to your case:</p>\n\n<p>Create a trait that we can use as a common <code>Borrow</code> target:</p>\n\n<pre><code>trait Key {\n    fn to_key(&amp;self) -&gt; (i32, &amp;str);\n}\n</code></pre>\n\n<p>Implement the <code>HashMap</code>-required traits for the trait object:</p>\n\n<pre><code>use std::hash::{Hash, Hasher};\n\nimpl Hash for dyn Key + '_ {\n    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {\n        self.to_key().hash(state)\n    }\n}\n\nimpl PartialEq for dyn Key + '_ {\n    fn eq(&amp;self, other: &amp;Self) -&gt; bool {\n        self.to_key() == other.to_key()\n    }\n}\n\nimpl Eq for dyn Key + '_ {}\n</code></pre>\n\n<p>Implement the trait for our primary type and any secondary lookup types:</p>\n\n<pre><code>impl Key for Complex {\n    fn to_key(&amp;self) -&gt; (i32, &amp;str) {\n        (self.n, &amp;self.s)\n    }\n}\n\nimpl&lt;'a&gt; Key for (i32, &amp;'a str) {\n    fn to_key(&amp;self) -&gt; (i32, &amp;str) {\n        (self.0, self.1)\n    }\n}\n</code></pre>\n\n<p>Implement <code>Borrow</code> for all the lookup types as returning our trait object:</p>\n\n<pre><code>impl&lt;'a&gt; Borrow&lt;dyn Key + 'a&gt; for Complex {\n    fn borrow(&amp;self) -&gt; &amp;(dyn Key + 'a) {\n        self\n    }\n}\n\nimpl&lt;'a&gt; Borrow&lt;dyn Key + 'a&gt; for (i32, &amp;'a str) {\n    fn borrow(&amp;self) -&gt; &amp;(dyn Key + 'a) {\n        self\n    }\n}\n</code></pre>\n\n<p>Convert to the trait object at query time:</p>\n\n<pre><code>assert_eq!(Some(&amp;123), m.get((42, \"foo\").borrow() as &amp;dyn Key));\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f2073bd67e04c8e21a875e4183a2c79c\" rel=\"nofollow noreferrer\">The complete code in the playground</a></p>\n\n<hr>\n\n<p>One important \"gotcha\" is that all of your primary key and your secondary keys <strong>must</strong> hash in the same manner. This means that the same values need to go into the hash computation in the same order and amount.</p>\n\n<p>You may wish to define <code>Hash</code> by hand to ensure that your primary and secondary keys hash the same!</p>\n\n<p>Here's another example, this time with an enum:</p>\n\n<pre><code>#[derive(Debug, PartialEq, Eq)]\nenum ConfigKey {\n    Text(String),\n    Binary(Vec&lt;u8&gt;),\n}\n</code></pre>\n\n<p>We create a parallel enum that is composed of only references, so it's lightweight to create. It's important that we define the same variants and in the same order as the primary enum so they will hash the same. We rely on the fact that <code>String</code> and <code>&amp;str</code> hash using the same algorithm, as do <code>Vec&lt;T&gt;</code> and <code>&amp;[T]</code>:</p>\n\n<pre><code>impl ConfigKey {\n    fn as_ref(&amp;self) -&gt; ConfigKeyRef&lt;'_&gt; {\n        match self {\n            ConfigKey::Text(t) =&gt; ConfigKeyRef::Text(t),\n            ConfigKey::Binary(b) =&gt; ConfigKeyRef::Binary(b),\n        }\n    }\n}\n\n#[derive(Hash, PartialEq, Eq)]\nenum ConfigKeyRef&lt;'a&gt; {\n    Text(&amp;'a str),\n    Binary(&amp;'a [u8]),\n}\n</code></pre>\n\n<p>We use this new enum as our common underlying key type:</p>\n\n<pre><code>trait Key {\n    fn to_key(&amp;self) -&gt; ConfigKeyRef&lt;'_&gt;;\n}\n</code></pre>\n\n<p>And implement our trait for our primary and secondary keys:</p>\n\n<pre><code>impl Key for ConfigKey {\n    fn to_key(&amp;self) -&gt; ConfigKeyRef&lt;'_&gt; {\n        self.as_ref()\n    }\n}\n\nimpl&lt;'a&gt; Key for &amp;'a str {\n    fn to_key(&amp;self) -&gt; ConfigKeyRef&lt;'_&gt; {\n        ConfigKeyRef::Text(self)\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e17fe5054ad3124ff3c0c70749983bc0\" rel=\"nofollow noreferrer\">The complete code in the playground</a></p>\n"}], "owner": {"reputation": 2584, "user_id": 1094609, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/2f03a85e1167ccb340e3d1cb2da67995?s=128&d=identicon&r=PG", "display_name": "Craig M. Brandenburg", "link": "https://stackoverflow.com/users/1094609/craig-m-brandenburg"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1537, "favorite_count": 3, "accepted_answer_id": 36486921, "answer_count": 2, "score": 13, "last_activity_date": 1571681726, "creation_date": 1460043193, "last_edit_date": 1527817572, "question_id": 36480845, "link": "https://stackoverflow.com/questions/36480845/how-to-avoid-temporary-allocations-when-using-a-complex-key-for-a-hashmap", "title": "How to avoid temporary allocations when using a complex key for a HashMap?", "body": "<p>I'm using a complex key for <code>HashMap</code> such that the key comprises two parts and one part is a <code>String</code>, and I can't figure out how to do lookups via the <code>HashMap::get</code> method without allocating a new <code>String</code> for each lookup.</p>\n\n<p>Here's some code:</p>\n\n<pre><code>#[derive(Debug, Eq, Hash, PartialEq)]\nstruct Complex {\n    n: i32,\n    s: String,\n}\n\nimpl Complex {\n    fn new&lt;S: Into&lt;String&gt;&gt;(n: i32, s: S) -&gt; Self {\n        Complex { n: n, s: s.into() }\n    }\n}\n\nfn main() {\n    let mut m = std::collections::HashMap::&lt;Complex, i32&gt;::new();\n    m.insert(Complex::new(42, \"foo\"), 123);\n\n    // OK, but allocates temporary String\n    assert_eq!(123, *m.get(&amp;Complex::new(42, \"foo\")).unwrap());\n}\n</code></pre>\n\n<p>The problem is with the final assertion. It passes, but it requires a temporary heap allocation because I cannot construct a <code>Complex</code> without constructing a <code>String</code>.</p>\n\n<p>To eliminate temporary allocations like this, Rust provides the <a href=\"https://doc.rust-lang.org/std/borrow/trait.Borrow.html\" rel=\"nofollow noreferrer\"><code>Borrow</code></a> trait, which the <code>HashMap::get</code> method makes use of. I understand how to make <code>Borrow</code> work for simple keys. For example, the Rust Standard Library's <code>PathBuf</code> implements <code>Borrow&lt;Path&gt;</code> by making use of <code>std::mem::transmute</code> under the hood, but I can't figure out how to make it work for my <code>Complex</code> type:</p>\n\n<pre><code>#[derive(Debug)]\nstruct Borrowable {\n    // ??? -- What goes here? Perhaps something like:\n    n: i32,\n    s1: &amp;str, // ??? -- But what would the lifetime be? Or maybe:\n    s2: str,  // ??? -- But how would I extend this to a complex type\n              //        containing two or more strings?\n}\n\nimpl Borrowable {\n    fn new(n: i32, s: &amp;str) -&gt; &amp;Self {\n         // ??? -- What goes here? It must not allocate.\n        unimplemented!();\n    }\n}\n\nimpl std::borrow::Borrow&lt;Borrowable&gt; for Complex {\n    fn borrow(&amp;self) -&gt; &amp;Borrowable {\n        // ??? -- What goes here? How can I transmute a Complex into a\n        //        &amp;Borrowable?\n        unimplemented!();\n    }\n}\n</code></pre>\n\n<p>This seems like a common use case, and I suspect I'm missing something important about <code>Borrow</code>, but I'm at a total loss.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460040091, "post_id": 36477505, "comment_id": 60569133, "body": "I&#39;d disagree with <i>a zero duration, which is a sensible default</i>, but the others, sure."}, {"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460040848, "post_id": 36477505, "comment_id": 60569763, "body": "Why? Do you think that there is no sensible default at all or do you think there&#39;s a more sensible one?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1460041096, "post_id": 36477505, "comment_id": 60569931, "body": "I&#39;d say there is no sensible default. Most of the times I think about duration in regards to timeouts, and a timeout of zero doesn&#39;t make sense to me and neither would picking any other value. Although I do see that numbers implement <code>Default</code> as <code>0</code>, so &#175;\\_(\u30c4)_/&#175;."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1460042145, "post_id": 36477505, "comment_id": 60570702, "body": "@Shepmaster: An in-house framework I use has a default timeout of 0. Strangely enough if you forget to override it the reply generally does not come fast enough..."}], "answers": [{"comments": [{"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "edited": false, "score": 0, "creation_date": 1460069411, "post_id": 36487475, "comment_id": 60586063, "body": "There&#39;s issue #31865 (at least for CondVar, I made a note of the others). I&#39;ve pushed <a href=\"https://github.com/rust-lang/rust/pull/32807\" rel=\"nofollow noreferrer\">PR #32807</a>"}], "tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": true, "score": 1, "last_activity_date": 1460064173, "creation_date": 1460064173, "answer_id": 36487475, "question_id": 36477505, "link": "https://stackoverflow.com/questions/36477505/why-is-default-not-implemented-for-mutex-rwlock-condvar-duration/36487475#36487475", "title": "Why is Default not implemented for Mutex, RWLock, CondVar, Duration?", "body": "<p>Some people have asked a similar question with <code>Debug</code> implementations, see <a href=\"https://github.com/rust-lang/rust/issues/31869\" rel=\"nofollow\">\u201cMissing Debug Implementations \u2014 #31869\u201d</a> which can also only be deriving under similar conditions as <code>Default</code>.</p>\n\n<p>Unfortunately the corresponding PR \u201c<a href=\"https://github.com/rust-lang/rust/issues/32054\" rel=\"nofollow\">libcore: add Debug implementations to most missing types #32054</a>\u201d seems to suggest that some types were not <code>Debug</code> simply because no-one had written a <code>Debug</code> implementation for them. Some other types are kind of controversial about what the implementation should do and there is some fear about adding them in the standard library.</p>\n\n<p>It reasonable to assume that at least some types are not <code>Default</code> for the same non-technical reasons.</p>\n"}], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 151, "favorite_count": 0, "accepted_answer_id": 36487475, "answer_count": 1, "score": 5, "last_activity_date": 1460064173, "creation_date": 1460035268, "last_edit_date": 1460050066, "question_id": 36477505, "link": "https://stackoverflow.com/questions/36477505/why-is-default-not-implemented-for-mutex-rwlock-condvar-duration", "title": "Why is Default not implemented for Mutex, RWLock, CondVar, Duration?", "body": "<p>The <code>Default</code> trait can be <code>#[derive(..)]</code>d only if the contents of the deriving type also implement <code>Default</code>. This means the trait gets easier to use the more it is implemented. However, I notice some types from <code>std</code> are missing implementations, although they have perfectly valid defaults (sometimes depending on generic params).</p>\n\n<ul>\n<li><code>Mutex&lt;T&gt;</code> and <code>RWLock&lt;T&gt;</code> could implement by <code>new(_)</code> (<code>where T: Default</code>)</li>\n<li><code>CondVar</code> could simply implement by <code>CondVar::new()</code></li>\n<li><code>Duration</code> could derive (to get a zero duration, <s>which is a sensible default</s>)</li>\n</ul>\n\n<p>Is there a technical reason for those omissions?</p>\n"}, {"tags": ["windows", "rust", "libsodium"], "answers": [{"tags": [], "owner": {"reputation": 917, "user_id": 4808573, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/oFwhb.jpg?s=128&g=1", "display_name": "pengowen123", "link": "https://stackoverflow.com/users/4808573/pengowen123"}, "is_accepted": false, "score": 6, "last_activity_date": 1460587639, "last_edit_date": 1492086165, "creation_date": 1460587639, "answer_id": 36610888, "question_id": 36477047, "link": "https://stackoverflow.com/questions/36477047/how-to-make-libsodium-available-to-rust-on-windows-beginners-guide/36610888#36610888", "title": "How to make Libsodium Available to Rust on Windows (beginner&#39;s guide)?", "body": "<p>When I try to build <a href=\"https://github.com/dnaq/sodiumoxide\" rel=\"nofollow noreferrer\">sodiumoxide</a>, it fails because pkg-config cannot find libsodium. To install it, go <a href=\"https://download.libsodium.org/libsodium/releases/\" rel=\"nofollow noreferrer\">here</a> and download the latest version named <code>libsodium-x.x.x-mingw.tar.gz</code>, where <code>x.x.x</code> is the version number. Extract it using a tool such as 7-zip, and copy <code>libsodium-win64</code> (or win32 for 32-bit systems) to a place of your choice.</p>\n\n<p>For pkg-config to find libsodium, you need to copy <code>libsodium.pc</code> from <code>libsodium-win64/lib/pkgconfig</code> (or win32) to somewhere pkg-config will look. To find where pkg-config looks, run this command:</p>\n\n<p><code>pkg-config --variable pc_path pkg-config</code></p>\n\n<p>Copy <code>libsodium.pc</code> to one of the directories listed. If no directories are listed, you must add a directory (see <a href=\"https://askubuntu.com/questions/210210/pkg-config-path-environment-variable/373217#373217\">this</a> answer). pkg-config should now be able to find libsodium, so you can build libraries that require it.</p>\n"}], "owner": {"reputation": 31, "user_id": 6172241, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6ef2009a81825b504b016129a0bfbeef?s=128&d=identicon&r=PG&f=1", "display_name": "rvenner", "link": "https://stackoverflow.com/users/6172241/rvenner"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 729, "favorite_count": 0, "answer_count": 1, "score": 3, "last_activity_date": 1460587639, "creation_date": 1460034171, "question_id": 36477047, "link": "https://stackoverflow.com/questions/36477047/how-to-make-libsodium-available-to-rust-on-windows-beginners-guide", "title": "How to make Libsodium Available to Rust on Windows (beginner&#39;s guide)?", "body": "<p>I can't find any clear answers to this.</p>\n\n<p>I'm a beginning Rust programmer (read the book, wrote and compiled simple programs). Almost no knowledge of C/C++. The platform is Windows 7 64-bit. Rust stable (managed by Rustup) and I'd prefer the GNU ABI.</p>\n\n<p>I'm compiling a git repository that requires libsodium, and compiling exits with an error that libsodium is not found.</p>\n\n<p>Is there a step-by-step guide to installing libsodium for my Rust setup? The documentation that I've found assumes a bit too much about the knowledge of the reader.</p>\n\n<p>I did manage to compile and \"install\" libsodium in MSYS2, but then Rust (which I can't see from inside MSYS2) still can't find it.</p>\n\n<p>What is the better way to do this?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1460037015, "post_id": 36476775, "comment_id": 60566466, "body": "When asking questions on SO, please provide a <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a> if possible, so that answers can be objectively checked to solve the issue. For your example, this could be <a href=\"https://play.rust-lang.org/?gist=43e3a4de6103ca986767bd304f54fe5e&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">this simple program</a>."}], "answers": [{"comments": [{"owner": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 0, "creation_date": 1460036060, "post_id": 36477586, "comment_id": 60565676, "body": "I have a new problem with it that these solutions don&#39;t fix. I edited the main post."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 0, "creation_date": 1460036312, "post_id": 36477586, "comment_id": 60565889, "body": "Please ask only one question per SO-thread. So you should in theory create a separate question for your edit. But: this question has already been answered on SO, so better search for that. Spoiler: just read the whole error message of the compiler (including the note)."}, {"owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "edited": false, "score": 1, "creation_date": 1460092871, "post_id": 36477586, "comment_id": 60592274, "body": "Do we have rationale in making &quot;use&quot; different, which is absolute, instead of relative to the current module?"}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 20, "last_activity_date": 1460035503, "creation_date": 1460035503, "answer_id": 36477586, "question_id": 36476775, "link": "https://stackoverflow.com/questions/36476775/why-is-the-std-module-undeclared/36477586#36477586", "title": "Why is the `std` module undeclared?", "body": "<p>I assume that <code>befunge.rs</code> is not your crate root, but a submodule. Paths like <code>std::io::stdin()</code> that are used outside of a <code>use ...;</code> declaration are relative to the current module, not absolute. To make the path absolute, <strong>prefix <code>::</code></strong> (like a prefixed <code>/</code> in unix paths) -> <code>::std::io::stdin()</code>. Alternatively you can <code>use</code> some part of the path, like:</p>\n\n<pre><code>use std;\nstd::io::stdin();\n</code></pre>\n\n<p>or </p>\n\n<pre><code>use std::io;\nio::stdin();\n</code></pre>\n\n<p>If you are using a subpath, like <code>std::io</code> more than once in your module, it's usually best to <code>use</code> it at the top.</p>\n\n<p>If you are in the crate root, there is no difference between <code>::std</code> and <code>std</code>, because the relative lookup path is the root. It only matters in submodules. Also: paths in <code>use</code> declarations are always absolute -- to make them relative to the current module prefix <code>self::</code>.</p>\n"}], "owner": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5728, "favorite_count": 1, "closed_date": 1472580777, "accepted_answer_id": 36477586, "answer_count": 1, "score": 11, "last_activity_date": 1460036737, "creation_date": 1460033525, "last_edit_date": 1460036737, "question_id": 36476775, "link": "https://stackoverflow.com/questions/36476775/why-is-the-std-module-undeclared", "closed_reason": "Duplicate", "title": "Why is the `std` module undeclared?", "body": "<p>I'm trying to read a single character from <code>stdin</code>, but I can't get it working. In different program, I used this exact same method and it worked.</p>\n\n<pre><code>let mut buffer = [0];\nlet _ = std::io::stdin().read(&amp;mut buffer);\nlet a = buffer[0];\n</code></pre>\n\n<p>Compiling it gives this error:</p>\n\n<pre><code>src/befunge.rs:220:17: 220:31 error: failed to resolve. Use of undeclared type or module `std::io` [E0433]\nsrc/befunge.rs:220      let _ = std::io::stdin().read(&amp;mut buffer);\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1460017295, "post_id": 36470413, "comment_id": 60551774, "body": "This is not a singly linked list then..."}, {"owner": {"reputation": 3978, "user_id": 1274367, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/SPiPI.jpg?s=128&g=1", "display_name": "Svetlin Mladenov", "link": "https://stackoverflow.com/users/1274367/svetlin-mladenov"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1460017371, "post_id": 36470413, "comment_id": 60551821, "body": "No, it&#39;s not. &quot;Singly linked list with references to random nodes&quot; is the best name I could come up with."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460017676, "post_id": 36470413, "comment_id": 60551994, "body": "Possible duplicate of <a href=\"http://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct\">Why can&#39;t I store a value and a reference to that value in the same struct?</a>"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1460017925, "post_id": 36470413, "comment_id": 60552146, "body": "@ker: The issue is similar, however the recommended solution (not put the items in the same struct) does not hold for data structures I fear."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 5, "last_activity_date": 1460017848, "creation_date": 1460017848, "answer_id": 36470740, "question_id": 36470413, "link": "https://stackoverflow.com/questions/36470413/singly-linked-list-with-references-to-random-nodes-in-rust/36470740#36470740", "title": "Singly linked list with references to random nodes in Rust", "body": "<p>Unfortunately, what you are trying to achieve is inherently unsafe as far as the compiler is concerned because you are creating <em>aliases</em> to <em>mutable</em> nodes. Two possible issues that the compiler will complain about:</p>\n\n<ul>\n<li>there is no proof that the node will not move, so the reference you take might be invalidated</li>\n<li>there is no proof that the node will not be mutated, so having two aliases to it (and being able to hand over two aliases to it) create a safety hole</li>\n</ul>\n\n<hr>\n\n<p>Now what?</p>\n\n<p>There are various approaches. If you are sure of yourself you could use <code>unsafe</code> and raw pointers, for example. However, the simpler solutions would be:</p>\n\n<ul>\n<li>use a <code>Vec</code> to store the nodes, and indexes to link them</li>\n<li>use <code>Rc</code> and <code>Weak</code></li>\n</ul>\n\n<p>The former is:</p>\n\n<pre><code>struct Node&lt;T&gt; {\n    data: T,\n    next: Option&lt;usize&gt;,\n    random: Option&lt;usize&gt;,\n}\n\npub struct List&lt;T&gt; {\n    store: Vec&lt;Node&lt;T&gt;&gt;,\n}\n</code></pre>\n\n<p>And the latter would be:</p>\n\n<pre><code>struct Node&lt;T&gt; {\n    data: T,\n    next: Option&lt;Rc&lt;Node&lt;T&gt;&gt;,\n    random: Option&lt;Weak&lt;Node&lt;T&gt;&gt;,\n}\n\npub struct List&lt;T&gt; {\n    head: Option&lt;Rc&lt;Node&lt;T&gt;&gt;,\n}\n</code></pre>\n\n<p>the latter however will not allow mutation of the internal nodes (because there is inherent aliasing) so you may need to wrap the <code>T</code> into <code>RefCell&lt;T&gt;</code>.</p>\n"}], "owner": {"reputation": 3978, "user_id": 1274367, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/SPiPI.jpg?s=128&g=1", "display_name": "Svetlin Mladenov", "link": "https://stackoverflow.com/users/1274367/svetlin-mladenov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 251, "favorite_count": 0, "accepted_answer_id": 36470740, "answer_count": 1, "score": 1, "last_activity_date": 1460027631, "creation_date": 1460016965, "last_edit_date": 1460027631, "question_id": 36470413, "link": "https://stackoverflow.com/questions/36470413/singly-linked-list-with-references-to-random-nodes-in-rust", "title": "Singly linked list with references to random nodes in Rust", "body": "<p>I am trying to create a singly linked list composed of nodes each having a reference to the next node, data associated with the node and, this is the interesting bit, a reference to a random node in the list. The random node of a given node can appear before the node itself or after it in the list. The random node is optional. Here is a diagram:</p>\n\n<pre><code>       +---------+  +-------------------+\n       |         v  v                   |\n     +-+--+     ++--++     +----+     +-+--+\n+---&gt;+Data+----&gt;+Data+----&gt;+Data+----&gt;+Data|\n     +-+--+     +----+     +--+-+     +----+\n       ^                      |\n       +----------------------+\n</code></pre>\n\n<p>The diagram demonstrates a list with four nodes. The random reference of the first node points to the second node. The second node's random reference is missing. The random reference of the third node is to the first one. The random reference of the forth node points to the second one.</p>\n\n<p>The list needs to support only adding new nodes. Once a node has been added it lives as long as the list so random references cannot get invalidated by removing a node.</p>\n\n<p>What I tried:</p>\n\n<p>I am stuck at the absolute beginning - I cannot figure out how to design the struct and how to construct the list. Here is the code I ended up with after wrestling with the compiler for a while:</p>\n\n<pre><code>type NodePtr&lt;'a, T&gt; = Option&lt;Box&lt;Node&lt;'a, T&gt;&gt;&gt;;\n\npub struct Node&lt;'a, T: 'a&gt; {\n    data: T,\n    next: NodePtr&lt;'a, T&gt;,\n    random: Option&lt;&amp;'a Node&lt;'a, T&gt;&gt;,\n}\n\npub struct List&lt;'a, T: 'a&gt; {\n    root: NodePtr&lt;'a, T&gt;,\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn construct() {\n        let mut list:List&lt;i32&gt; = List {root: Some(Box::new(Node {data: 5, next: None, random: None}))};\n        let mut f: &amp;mut Node&lt;i32&gt; = &amp;mut **list.root.as_mut().unwrap();\n        f.random = Some(&amp;f);\n    }\n}\n</code></pre>\n\n<p>The compiles refuses to compile it with:</p>\n\n<pre><code>src/topology_copy.rs:21:26: 21:27 error: `f` does not live long enough\nsrc/topology_copy.rs:21         f.random = Some(&amp;f);\n</code></pre>\n\n<p>And the code is very messy. Obviously I am doing it wrong.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 7, "last_activity_date": 1460040293, "last_edit_date": 1460040293, "creation_date": 1460013321, "answer_id": 36469199, "question_id": 36467034, "link": "https://stackoverflow.com/questions/36467034/why-does-the-address-of-a-variable-change-when-i-add-multiple/36469199#36469199", "title": "Why does the address of a variable change when I add multiple &#39;&amp;&#39;?", "body": "<p>When you use the <code>&amp;</code> operator on an expression that is not just a path to a variable, Rust actually creates a temporary unnamed variable, assigns it the result of the expression and gives you a reference to the temporary variable. So if you do <code>&amp;&amp;test</code>, Rust creates a temporary (let's call it <code>tmp</code>):</p>\n\n<pre><code>let tmp = &amp;test;\n</code></pre>\n\n<p>and then Rust gives you <code>&amp;tmp</code>, which obviously has a new memory location.</p>\n"}], "owner": {"reputation": 13014, "user_id": 4140572, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2uRSa.png?s=128&g=1", "display_name": "Angel Angel", "link": "https://stackoverflow.com/users/4140572/angel-angel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 85, "favorite_count": 0, "accepted_answer_id": 36469199, "answer_count": 1, "score": 2, "last_activity_date": 1460040569, "creation_date": 1460005046, "last_edit_date": 1460040569, "question_id": 36467034, "link": "https://stackoverflow.com/questions/36467034/why-does-the-address-of-a-variable-change-when-i-add-multiple", "title": "Why does the address of a variable change when I add multiple &#39;&amp;&#39;?", "body": "<p>I'm trying to understand when to use <code>ref</code> and <code>&amp;</code> as well as when they are interchangeable. In another code example I used the wrong amount of <code>&amp;</code>, but doing some tests I saw that this works sometimes. Take this code as an example:</p>\n\n<pre><code>fn main() {\n    let test        = 5;\n    let ref testRef = test;\n\n    println!(\"&amp;test             as *const _ {:?}\", &amp;test     as *const _);\n    println!(\"&amp;testRef          as *const _ {:?}\", &amp;testRef  as *const _);\n    println!(\"&amp;*testRef         as *const _ {:?}\", &amp;*testRef as *const _);\n\n    println!(\"&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;testRef as *const _ {:?}\", &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;testRef as *const _);\n    println!(\"&amp;&amp;&amp;&amp;&amp;testRef      as *const _ {:?}\", &amp;&amp;&amp;&amp;&amp;testRef      as *const _);\n    println!(\"&amp;&amp;&amp;&amp;&amp;&amp;*testRef    as *const _ {:?}\", &amp;&amp;&amp;&amp;&amp;&amp;*testRef    as *const _);\n\n    println!(\"&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;testRef             {:?}\", &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;testRef);\n    println!(\"&amp;&amp;&amp;&amp;&amp;testRef                  {:?}\", &amp;&amp;&amp;&amp;&amp;testRef);\n    println!(\"&amp;&amp;&amp;&amp;&amp;&amp;*testRef                {:?}\", &amp;&amp;&amp;&amp;&amp;&amp;*testRef);\n}\n</code></pre>\n\n<p>Shell:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>&amp;test             as *const _ 0x7fffac2d5be4   &lt;- this no problem I understand\n&amp;testRef          as *const _ 0x7fffac2d5bd8   &lt;- this no problem I understand\n&amp;*testRef         as *const _ 0x7fffac2d5be4   &lt;- this no problem I understand\n\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;testRef as *const _ 0x7fffac2d5998   &lt;- why this found and \n&amp;&amp;&amp;&amp;&amp;testRef      as *const _ 0x7fffac2d58f0   &lt;- It changes every \n&amp;&amp;&amp;&amp;&amp;&amp;*testRef    as *const _ 0x7fffac2d5840   &lt;- time you add &amp;\n\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;testRef             5\n&amp;&amp;&amp;&amp;&amp;testRef                  5\n&amp;&amp;&amp;&amp;&amp;&amp;*testRef                5\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 748, "user_id": 91909, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/546f20e4042e433d9bcbf0dc6c1a1cf5?s=128&d=identicon&r=PG", "display_name": "Bill Fraser", "link": "https://stackoverflow.com/users/91909/bill-fraser"}, "edited": false, "score": 0, "creation_date": 1459999391, "post_id": 36465116, "comment_id": 60543558, "body": "Ah, thanks! I&#39;d never seen this <code>&amp;(MyTrait + &#39;a)</code> syntax before. I&#39;ve seen that in generic parameters to other types, or in type bounds, but never by itself before."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 7, "last_activity_date": 1459992385, "creation_date": 1459992385, "answer_id": 36465116, "question_id": 36465009, "link": "https://stackoverflow.com/questions/36465009/implementing-borrowtrait-for-a-type-that-implements-trait/36465116#36465116", "title": "Implementing Borrow&lt;Trait&gt; for a type that implements Trait", "body": "<p>The correct way to write the implementation is this:</p>\n\n<pre><code>impl&lt;'a&gt; Borrow&lt;MyTrait + 'a&gt; for MyStruct {\n    fn borrow(&amp;self) -&gt; &amp;(MyTrait + 'a) {\n        self\n    }\n}\n</code></pre>\n\n<p>Trait objects can be restricted with a lifetime bound. That's because a type that implements a trait might contain references, and in some situations, we need to be able to differentiate an object that depends on borrowed objects from an object that doesn't. If the lifetime bound is not specified, I think it defaults to <code>'static</code>; however, specifying <code>&amp;(MyTrait + 'static)</code> as the return type compiles (it's less generic, so you should favor the generic solution above), so the issue you encountered is more subtle than that...</p>\n"}, {"comments": [{"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 2, "creation_date": 1460003278, "post_id": 36466416, "comment_id": 60544619, "body": "The <code>Borrowed</code> type parameter is necessary because a type can implement multiple instances of <code>Borrow&lt;T&gt;</code>. If <code>Borrow</code> had an associated type, rather than a type parameter, then the extra type parameter on your <code>impl</code> wouldn&#39;t be necessary; you could use a <code>where</code> clause to add a bound like <code>T::Target: MyTrait</code>. <code>Deref</code> has an associated type, but it&#39;s not implemented for <code>T</code> with <code>Target = T</code>. You could probably define your own trait, but you couldn&#39;t leverage an existing trait to provide implementations until either specialization or negative trait bounds are implemented."}], "tags": [], "owner": {"reputation": 748, "user_id": 91909, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/546f20e4042e433d9bcbf0dc6c1a1cf5?s=128&d=identicon&r=PG", "display_name": "Bill Fraser", "link": "https://stackoverflow.com/users/91909/bill-fraser"}, "is_accepted": false, "score": 4, "last_activity_date": 1460001316, "creation_date": 1460001316, "answer_id": 36466416, "question_id": 36465009, "link": "https://stackoverflow.com/questions/36465009/implementing-borrowtrait-for-a-type-that-implements-trait/36466416#36466416", "title": "Implementing Borrow&lt;Trait&gt; for a type that implements Trait", "body": "<p>As an aside, I found an alternative way to do this, that doesn't require implementing <code>Borrow&lt;MyTrait&gt;</code> at all:</p>\n\n<p>Instead of having <code>impl&lt;T: Borrow&lt;MyTrait&gt; Consumer&lt;T&gt;</code>, we can make <code>Consumer</code> take an additional parameter that designates what the actual borrowed type will be, and then constrain that type to implement the trait. Like this:</p>\n\n<pre><code>impl&lt;T: Borrow&lt;Borrowed&gt;, Borrowed: MyTrait&gt; Consumer&lt;T, Borrowed&gt; {\n</code></pre>\n\n<p>This requires <code>Consumer</code> to have a <code>PhantomData</code> member that references the otherwise unused <code>Borrowed</code> type parameter. Here's a full implementation:</p>\n\n<pre><code>struct Consumer&lt;T, Borrowed&gt; {\n    inner: T,\n    phantom: PhantomData&lt;Borrowed&gt;\n}\n\nimpl&lt;T: Borrow&lt;Borrowed&gt;, Borrowed: MyTrait&gt; Consumer&lt;T, Borrowed&gt; {\n    fn new(inner: T) -&gt; Consumer&lt;T, Borrowed&gt; {\n        Consumer {\n            inner: inner,\n            phantom: PhantomData\n        }\n    }\n    pub fn do_stuff(&amp;self) { // this function is the same as before.\n        self.inner.borrow().function1();\n    }\n}\n</code></pre>\n\n<p>This alternative has the nice property that it allows using traits with generic methods inside them, because it doesn't require creating any trait objects (trait objects can't be made for traits that have generic functions: see <a href=\"https://doc.rust-lang.org/error-index.html#method-has-generic-type-parameters\" rel=\"nofollow\">https://doc.rust-lang.org/error-index.html#method-has-generic-type-parameters</a>).</p>\n\n<p>The one downside is that <code>Consumer</code> now has to be given hints as to its generic parameters. You have to tell it the concrete type involved:</p>\n\n<pre><code>fn main() {\n    let x = MyStruct { number: 42 };\n    let c = Consumer::&lt;_, MyStruct&gt;::new(x);\n    c.do_stuff();\n}\n</code></pre>\n"}], "owner": {"reputation": 748, "user_id": 91909, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/546f20e4042e433d9bcbf0dc6c1a1cf5?s=128&d=identicon&r=PG", "display_name": "Bill Fraser", "link": "https://stackoverflow.com/users/91909/bill-fraser"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1729, "favorite_count": 2, "accepted_answer_id": 36465116, "answer_count": 2, "score": 8, "last_activity_date": 1460001316, "creation_date": 1459991669, "question_id": 36465009, "link": "https://stackoverflow.com/questions/36465009/implementing-borrowtrait-for-a-type-that-implements-trait", "title": "Implementing Borrow&lt;Trait&gt; for a type that implements Trait", "body": "<p>Let's say I have some trait:</p>\n\n<pre><code>trait MyTrait {\n    fn function1(&amp;self);\n}\n</code></pre>\n\n<p>and some type that implements it:</p>\n\n<pre><code>struct MyStruct {\n    number: i32,\n}\nimpl MyTrait for MyStruct {\n    fn function1(&amp;self) {\n        printn!(\"{}\", self.number);\n    }\n}\n</code></pre>\n\n<p>Now I have another type, which wants to take things that implement <code>MyTrait</code>. It doesn't care whether they're owned or not. From reading around, it sounds like the right way to accomplish this is to have it take <code>Borrow&lt;X&gt;</code> instead of <code>X</code> or <code>&amp;X</code> or whatever. This lets it take things of type <code>X</code>, or <code>Rc&lt;X&gt;</code> or <code>Box&lt;X&gt;</code>, etc...</p>\n\n<p>I've got this working when <code>X</code> is a concrete type, but how do I make it work when <code>X</code> is a trait?</p>\n\n<p>Here's what I tried first:</p>\n\n<pre><code>struct Consumer&lt;T&gt; {\n    inner: T\n}\n\nimpl&lt;T: Borrow&lt;MyTrait&gt;&gt; Consumer&lt;T&gt; {\n    pub fn new(inner: T) -&gt; Consumer&lt;T&gt; {\n        Consumer {\n            inner: inner\n        }\n    }\n    pub fn do_stuff(&amp;self) {\n        self.inner.borrow().function1();\n    }\n}\n\nfn main() {\n    // I want to eventually be able to swap this out for x = Rc::new(MyStruct ...\n    // but I'll keep it simple for now.\n    let x = MyStruct { number: 42 };\n    let c = Consumer::new(x);\n    c.do_stuff();\n}\n</code></pre>\n\n<p>This doesn't work yet, because <code>MyStruct</code> implements <code>Borrow&lt;MyStruct&gt;</code>, but not <code>Borrow&lt;MyTrait&gt;</code>. Okay, so let's try to implement that:</p>\n\n<pre><code>impl Borrow&lt;MyTrait&gt; for MyStruct {\n    fn borrow(&amp;self) -&gt; &amp;MyTrait {\n        self\n    }\n}\n</code></pre>\n\n<p>This gives me the following error, which I don't understand:</p>\n\n<blockquote>\n<pre><code>&lt;anon&gt;:33:5: 35:6 error: method `borrow` has an incompatible type for trait:\n expected bound lifetime parameter ,\n    found concrete lifetime [E0053]\n&lt;anon&gt;:33     fn borrow(&amp;self) -&gt; &amp;MyTrait {\n&lt;anon&gt;:34         self\n&lt;anon&gt;:35     }\n&lt;anon&gt;:33:5: 35:6 help: see the detailed explanation for E0053\nerror: aborting due to previous error\nplaypen: application terminated with error code 101\n</code></pre>\n</blockquote>\n\n<p>What? There aren't any concrete lifetimes mentioned at all in there, and <code>Borrow</code> is defined without any lifetimes mentioned either. I'm stumped.</p>\n\n<p>Firstly, are my assumptions correct that using <code>Borrow</code> is the right way to go? And if so, how do I implement <code>Borrow</code> of a trait?</p>\n"}]