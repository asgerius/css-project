[{"tags": ["struct", "rust"], "answers": [{"comments": [{"owner": {"reputation": 2434, "user_id": 508716, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/77d190c42f3d57f3ee3ea864ab216016?s=128&d=identicon&r=PG", "display_name": "Tommi Komulainen", "link": "https://stackoverflow.com/users/508716/tommi-komulainen"}, "edited": false, "score": 0, "creation_date": 1475693745, "post_id": 39881558, "comment_id": 67050179, "body": "I think you&#39;re missing an <code>.unwrap()</code> after the take, but with that it works. /me slaps forehead"}, {"owner": {"reputation": 2434, "user_id": 508716, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/77d190c42f3d57f3ee3ea864ab216016?s=128&d=identicon&r=PG", "display_name": "Tommi Komulainen", "link": "https://stackoverflow.com/users/508716/tommi-komulainen"}, "edited": false, "score": 0, "creation_date": 1475694429, "post_id": 39881558, "comment_id": 67050577, "body": "Is there a way to make it a compile error if the function tries to exit without restoring a <code>Some</code> back to the reader?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 2434, "user_id": 508716, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/77d190c42f3d57f3ee3ea864ab216016?s=128&d=identicon&r=PG", "display_name": "Tommi Komulainen", "link": "https://stackoverflow.com/users/508716/tommi-komulainen"}, "edited": false, "score": 1, "creation_date": 1475735917, "post_id": 39881558, "comment_id": 67064371, "body": "@TommiKomulainen: Not that I know of, no. There used to be proposals for giving Rust the ability to &quot;punch holes&quot; in <code>struct</code>/<code>enum</code> and then restore them... but this is tricky to ensure in the presence of <code>panic!</code> and unwinding."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 2, "last_activity_date": 1475737817, "last_edit_date": 1475737817, "creation_date": 1475693293, "answer_id": 39881558, "question_id": 39881365, "link": "https://stackoverflow.com/questions/39881365/how-to-capture-self-consuming-variable-in-a-struct/39881558#39881558", "title": "How to capture self consuming variable in a struct?", "body": "<p>The simpler solution is to use an <code>Option</code> to wrap the <code>Reader</code>.</p>\n\n<p>An <code>Option</code> has a <code>take</code> method which returns the content (and puts <code>None</code> in the <code>Option</code>), then you can place the <code>Reader</code> back by assigning.</p>\n\n<pre><code>struct Container&lt;'a&gt; {\n    reader: Option&lt;Reader&lt;'a, File&gt;&gt;\n}\n\nfn update(&amp;mut self) {\n    let writer = self.reader.take().unwrap().as_writer();\n                             ^~~~~~~\n    writer.write_something();\n    self.reader = Some(writer.as_reader());\n                  ^~~~~                  ^\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 0, "creation_date": 1476280454, "post_id": 39965776, "comment_id": 67278679, "body": "Well, if it panics before returning from the closure there will be a <code>None</code> in it."}], "tags": [], "owner": {"reputation": 2434, "user_id": 508716, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/77d190c42f3d57f3ee3ea864ab216016?s=128&d=identicon&r=PG", "display_name": "Tommi Komulainen", "link": "https://stackoverflow.com/users/508716/tommi-komulainen"}, "is_accepted": false, "score": 1, "last_activity_date": 1476129956, "last_edit_date": 1495535652, "creation_date": 1476129219, "answer_id": 39965776, "question_id": 39881365, "link": "https://stackoverflow.com/questions/39881365/how-to-capture-self-consuming-variable-in-a-struct/39965776#39965776", "title": "How to capture self consuming variable in a struct?", "body": "<p>Building on <a href=\"https://stackoverflow.com/a/39881558/508716\">Matthieu's answer</a> I figured it's straightforward to add a (trivial) wrapper around the <code>Option</code> to enforce compile time checks that only allow \"borrowing\" the <code>Reader</code> instance while requiring another one is returned afterwards.</p>\n\n<pre><code>struct State&lt;T&gt;(Option&lt;T&gt;);\n\nimpl&lt;T&gt; State&lt;T&gt; {\n    pub fn new(val: T) -&gt; Self {\n        State(Some(val))\n    }\n    pub fn modify&lt;F&gt;(&amp;mut self, fun: F)\n        where F: FnOnce(T) -&gt; T\n    {\n        self.0 = Some(fun(self.0.take().unwrap()));\n    }\n}\n</code></pre>\n\n<p>Usage:</p>\n\n<pre><code>fn modify(&amp;mut self) {\n    self.state.modify(|reader| {\n        let writer = reader.as_writer();\n        writer.write_something();\n        writer.as_reader()\n    }\n}\n</code></pre>\n\n<p>Should be good enough to avoid accidental misuses. No idea about <code>panic!</code> unwindings though.</p>\n\n<p>Probably not following Rust naming conventions, <code>state</code> and <code>modify</code> come from Haskell's <code>State</code>.</p>\n"}], "owner": {"reputation": 2434, "user_id": 508716, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/77d190c42f3d57f3ee3ea864ab216016?s=128&d=identicon&r=PG", "display_name": "Tommi Komulainen", "link": "https://stackoverflow.com/users/508716/tommi-komulainen"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 423, "favorite_count": 0, "accepted_answer_id": 39881558, "answer_count": 2, "score": 3, "last_activity_date": 1476129956, "creation_date": 1475692488, "last_edit_date": 1475733587, "question_id": 39881365, "link": "https://stackoverflow.com/questions/39881365/how-to-capture-self-consuming-variable-in-a-struct", "title": "How to capture self consuming variable in a struct?", "body": "<p>I have a Reader instance with a method that <a href=\"https://github.com/estebank/galvanize/blob/0abafb62fec98f257ebd27124b66131ec5d6216f/src/reader.rs#L320\" rel=\"nofollow\">consumes the Reader and returns a Writer</a> and the Writer can similarly get back to a Reader again. It's trivial to use immutably, but I can't figure out how to hide the immutability from callers and just do the reader-writer-reader dance behind the scenes with a mutable Self.</p>\n\n<p>Essentially I'd like something like:</p>\n\n<pre><code>struct Container&lt;'a&gt; {\n    reader: Reader&lt;'a, File&gt;\n}\n\nfn update(&amp;mut self) {\n    let writer = self.reader.as_writer();\n    writer.write_something();\n    self.reader = writer.as_reader();\n}\n</code></pre>\n\n<p>which just gives <code>cannot move out of borrowed content</code> error. Tried to add a Box, Cell, or RefCell around the Reader which just lead to other errors.</p>\n\n<p>Can the <code>reader</code> be hidden behind a mutable interface or does it force the whole struct hierarchy to be mutable as well? (i.e. similar to IO in Haskell)</p>\n\n<hr>\n\n<p>Self contained sample with the types matching the real thing (I think)</p>\n\n<pre><code>#[derive(Debug)]\nstruct NoCopy(u32);\n\n#[derive(Debug)]\nstruct Flipper&lt;'a, T: 'a&gt; {\n    data: &amp;'a mut T,\n}\n#[derive(Debug)]\nstruct Flopper&lt;'a, T: 'a&gt; {\n    data: &amp;'a mut T,\n}\nimpl&lt;'a, T&gt; Flipper&lt;'a, T&gt; {\n    fn flip(self) -&gt; Flopper&lt;'a, T&gt; {\n        Flopper{data: self.data}\n    }\n}\nimpl&lt;'a, T&gt; Flopper&lt;'a, T&gt; {\n    fn flop(self) -&gt; Flipper&lt;'a, T&gt; {\n        Flipper{data: self.data}\n    }\n}\n\n#[derive(Debug)]\nstruct Container&lt;'a, T: 'a&gt; {\n    flipper: Flipper&lt;'a, T&gt;,\n}\nimpl&lt;'a, T&gt; Container&lt;'a, T&gt; {\n    fn run(&amp;mut self) {\n        self.flipper = self.flipper.flip().flop();\n    }\n}\n\nfn main() {\n    let f = Flipper{data: &amp;mut NoCopy(42)};\n    let f = f.flip().flop();\n    println!(\"f={:?}\", f);\n\n    let mut c = Container{flipper: f};\n    c.run();\n    println!(\"c={:?}\", c);\n}\n</code></pre>\n\n<pre>\nerror[E0507]: cannot move out of borrowed content\n  --> src/main.rs:29:24\n   |\n29 |         self.flipper = self.flipper.flip().flop();\n   |                        ^^^^ cannot move out of borrowed content\n</pre>\n"}, {"tags": ["string", "rust"], "comments": [{"owner": {"reputation": 21262, "user_id": 456434, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/3f7480fbdad6c08d04139e3120474f27?s=128&d=identicon&r=PG", "display_name": "Mazyod", "link": "https://stackoverflow.com/users/456434/mazyod"}, "edited": false, "score": 0, "creation_date": 1475686107, "post_id": 39879531, "comment_id": 67045907, "body": "@Neikos I am sending the string &quot;hello&quot; down the write using <code>nc</code>, that verifies it is reading something, right?"}, {"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 0, "creation_date": 1475686329, "post_id": 39879531, "comment_id": 67046027, "body": "Yes, I misread the code and didn&#39;t see you used <code>format</code> instead of <code>println</code>"}], "answers": [{"comments": [{"owner": {"reputation": 21262, "user_id": 456434, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/3f7480fbdad6c08d04139e3120474f27?s=128&d=identicon&r=PG", "display_name": "Mazyod", "link": "https://stackoverflow.com/users/456434/mazyod"}, "edited": false, "score": 0, "creation_date": 1475687361, "post_id": 39879901, "comment_id": 67046588, "body": "Both answers are great, but since this was first ... I also discovered <code>read_line</code>, which may work without dealing with this low level representation."}], "tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": true, "score": 10, "last_activity_date": 1475687075, "creation_date": 1475687075, "answer_id": 39879901, "question_id": 39879531, "link": "https://stackoverflow.com/questions/39879531/unable-to-trim-string-received-from-tcp-stream/39879901#39879901", "title": "Unable to trim string received from TCP stream", "body": "<p>So, what's happening here?\nLet's see that example:</p>\n\n<pre><code>fn main() {\n    let mut buffer = [0; 32];\n    buffer[0] = b'H';\n    buffer[1] = b'i';\n    buffer[2] = b'!';\n    buffer[3] = b'\\n';\n\n    println!(\"{:?}\", String::from_utf8_lossy(&amp;buffer));\n}\n</code></pre>\n\n<p>This shows:</p>\n\n<pre><code>\"Hi!\\n\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\\u{0}\"\n</code></pre>\n\n<p>No wonder <code>trim</code> does not work!</p>\n\n<p><a href=\"https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read\"><code>Read::read</code></a> returns the number of read characters, use it, don't ignore it!</p>\n"}, {"comments": [{"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 2, "creation_date": 1475687318, "post_id": 39879913, "comment_id": 67046569, "body": "As a side note, it is generally a bad idea to hard-ignore errors, handle them or bubble them up. (With <code>try!</code> for example)"}], "tags": [], "owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "is_accepted": false, "score": 10, "last_activity_date": 1475687107, "creation_date": 1475687107, "answer_id": 39879913, "question_id": 39879531, "link": "https://stackoverflow.com/questions/39879531/unable-to-trim-string-received-from-tcp-stream/39879913#39879913", "title": "Unable to trim string received from TCP stream", "body": "<p>Using the code provided in the gist this seems to be wrong:</p>\n\n<ol>\n<li><a href=\"https://doc.rust-lang.org/stable/std/io/trait.Read.html#tymethod.read\"><code>Read::read</code></a> returns a result which you are ignoring, this could be a problem later on.</li>\n<li>You are giving <code>String::from_utf8_lossy</code> the whole buffer even if it might only be be somewhat full. So what might happen that it scans from the end, but your string is all at the beginning. \nImagine a buffer like this: <code>['H','e','\\n',\\0,'4','d']</code> you only put in  the <code>\"He\\n\"</code> but String doesn't care and still uses the whole length of the buffer.</li>\n</ol>\n\n<p>To fix it you can do something like this:</p>\n\n<pre><code>let n = try!(stream.read(&amp;mut buffer));\nlet s = format!(\"{}, Rust!\", String::from_utf8_lossy(&amp;buffer[0..n]).trim());\n\nprintln!(\"Received string: {} ..\", s);\n</code></pre>\n\n<p>Which uses the <a href=\"https://doc.rust-lang.org/stable/std/ops/struct.Range.html\">Range</a> syntax to take a slice up to the last actually read character.</p>\n"}], "owner": {"reputation": 21262, "user_id": 456434, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/3f7480fbdad6c08d04139e3120474f27?s=128&d=identicon&r=PG", "display_name": "Mazyod", "link": "https://stackoverflow.com/users/456434/mazyod"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 245, "favorite_count": 0, "accepted_answer_id": 39879901, "answer_count": 2, "score": 3, "last_activity_date": 1475687107, "creation_date": 1475685714, "last_edit_date": 1475686856, "question_id": 39879531, "link": "https://stackoverflow.com/questions/39879531/unable-to-trim-string-received-from-tcp-stream", "title": "Unable to trim string received from TCP stream", "body": "<p>I just started learning Rust today, but I've been programming for a while now ... Yet, I can't seem to trim a simple string in Rust. I tried using slicing <code>&amp;[0 .. length - 2]</code>, <code>trim()</code>, <code>trim_right()</code>, nothing seems to help...</p>\n\n<p>So, <code>stream</code> here is a <code>TCPStream</code>, and even though I am using <code>trim()</code>, the output of the following code is:</p>\n\n<pre class=\"lang-sh prettyprint-override\"><code># client\n$ nc localhost 3500\nhello\n$ ...\n# server output\nReceived string: hello\n, Rust! ..\n</code></pre>\n\n<hr>\n\n<pre><code>let mut buffer = [0; 2048];\nlet _ = stream.read(&amp;mut buffer);\nlet s = format!(\"{}, Rust!\", String::from_utf8_lossy(&amp;buffer).trim());\n\nprintln!(\"Received string: {} ..\", s);\n</code></pre>\n\n<p><strong>Update:</strong> Seems like the <code>from_utf8_lossy</code> is returning a string of length 2048! When I send a string long enough, and take a slice, it finally works...</p>\n\n<p>Just in case, here is the full source:</p>\n\n<p><a href=\"https://gist.github.com/Mazyod/8f6807e2c859b3457eaa4bcf24d5d703\" rel=\"nofollow\">https://gist.github.com/Mazyod/8f6807e2c859b3457eaa4bcf24d5d703</a></p>\n"}, {"tags": ["rust", "tuples"], "answers": [{"comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 5, "creation_date": 1475683041, "post_id": 39878473, "comment_id": 67043944, "body": "I upvoted, but this answer would be better if it explicitly answered the question rather than just offering alternative code."}], "tags": [], "owner": {"reputation": 133611, "user_id": 152602, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7f370b4bd787fc68f9f62d9c6781cb79?s=128&d=identicon&r=PG", "display_name": "Lee", "link": "https://stackoverflow.com/users/152602/lee"}, "is_accepted": false, "score": 5, "last_activity_date": 1475682321, "creation_date": 1475682321, "answer_id": 39878473, "question_id": 39878382, "link": "https://stackoverflow.com/questions/39878382/is-it-possible-to-unpack-a-tuple-into-function-arguments/39878473#39878473", "title": "Is it possible to unpack a tuple into function arguments?", "body": "<pre><code>let (a, b) = (10, Vec::new());\nfoo(a, b);\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1475686847, "post_id": 39878701, "comment_id": 67046311, "body": "But there is, see my answer."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 6, "creation_date": 1475687202, "post_id": 39878701, "comment_id": 67046503, "body": "@ljedrz I assumed he did not want/could not change the function signature."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1475687356, "post_id": 39878701, "comment_id": 67046582, "body": "In that case yes, I wouldn&#39;t see any other way either."}], "tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": true, "score": 18, "last_activity_date": 1475683037, "creation_date": 1475683037, "answer_id": 39878701, "question_id": 39878382, "link": "https://stackoverflow.com/questions/39878382/is-it-possible-to-unpack-a-tuple-into-function-arguments/39878701#39878701", "title": "Is it possible to unpack a tuple into function arguments?", "body": "<p>On a nightly compiler:</p>\n\n<pre><code>#![feature(fn_traits)]\n\nfn main() {\n    let tuple = (10, Vec::new());\n    std::ops::Fn::call(&amp;foo, tuple);\n}\nfn foo(a: i32, b: Vec&lt;i32&gt;) {\n}\n</code></pre>\n\n<p>There is AFAIK no stable way to do that.</p>\n"}, {"comments": [{"owner": {"reputation": 244, "user_id": 867921, "user_type": "registered", "accept_rate": 17, "profile_image": "https://www.gravatar.com/avatar/0e18bee08462857a8ffbf8e6ca6d26a1?s=128&d=identicon&r=PG&f=1", "display_name": "piotao", "link": "https://stackoverflow.com/users/867921/piotao"}, "edited": false, "score": 5, "creation_date": 1595543295, "post_id": 39879622, "comment_id": 111520140, "body": "can you elaborate about this a little bit more? Isn&#39;t it then like a calling a function with a single argument which happened to be a tuple?"}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 13, "last_activity_date": 1475686660, "last_edit_date": 1475686660, "creation_date": 1475686095, "answer_id": 39879622, "question_id": 39878382, "link": "https://stackoverflow.com/questions/39878382/is-it-possible-to-unpack-a-tuple-into-function-arguments/39879622#39879622", "title": "Is it possible to unpack a tuple into function arguments?", "body": "<p>There is a way, using the magic of pattern matching:</p>\n\n<pre><code>fn main() {\n    let tuple = (10, Vec::new());\n    foo(tuple);\n}\n\nfn foo((a, b): (i32, Vec&lt;i32&gt;)) {\n    // do stuff\n}\n</code></pre>\n\n<p>As per <a href=\"https://doc.rust-lang.org/reference.html#functions\" rel=\"noreferrer\">Rust reference</a>: </p>\n\n<blockquote>\n  <p>As with let bindings, function arguments are irrefutable patterns, so\n  any pattern that is valid in a let binding is also valid as an\n  argument.</p>\n</blockquote>\n\n<p>So you can specify an argument like:</p>\n\n<pre><code>(a, b): (i32, Vec&lt;i32&gt;)\n</code></pre>\n\n<p>just like you would in a <code>let</code> statement.</p>\n"}], "owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 8214, "favorite_count": 0, "accepted_answer_id": 39878701, "answer_count": 3, "score": 37, "last_activity_date": 1582567993, "creation_date": 1475682089, "last_edit_date": 1582567993, "question_id": 39878382, "link": "https://stackoverflow.com/questions/39878382/is-it-possible-to-unpack-a-tuple-into-function-arguments", "title": "Is it possible to unpack a tuple into function arguments?", "body": "<p>If I want to unpack a tuple and pass it as arguments is there a way to do this:</p>\n\n<pre><code>//Does not compile\nfn main() {\n    let tuple = (10, Vec::new());\n    foo(tuple);\n}\nfn foo(a: i32, b: Vec&lt;i32&gt;) {\n    //Does stuff.\n}\n</code></pre>\n\n<p>Instead of having to do this:</p>\n\n<pre><code>fn main() {\n    let tuple = (10, Vec::new());\n    foo(tuple.0, tuple.1);\n}\nfn foo(a: i32, b: Vec&lt;i32&gt;) {\n    //Does stuff.\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 4, "creation_date": 1475668384, "post_id": 39873206, "comment_id": 67033038, "body": "I cannot reproduce your issue, so I cannot help. Please produce a <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a>, ideally on an online Rust compiler such as <a href=\"https://play.rust-lang.org/\" rel=\"nofollow noreferrer\">the Rust Playground</a>."}, {"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 0, "creation_date": 1475668498, "post_id": 39873206, "comment_id": 67033102, "body": "Also, post the <i>full</i> error message that <code>rustc</code> emits (and preferably use 1.12 to get the clearer error messages that should explain the issue to you)."}, {"owner": {"reputation": 3474, "user_id": 497398, "user_type": "registered", "accept_rate": 41, "profile_image": "https://www.gravatar.com/avatar/1dac2c810e7a6d0787aadc020caa4d71?s=128&d=identicon&r=PG", "display_name": "mfirry", "link": "https://stackoverflow.com/users/497398/mfirry"}, "edited": false, "score": 0, "creation_date": 1475669235, "post_id": 39873206, "comment_id": 67033589, "body": "It&#39;s basically not very different from <a href=\"https://github.com/spicavigo/kafka-rust/blob/master/examples/example-consume.rs\" rel=\"nofollow noreferrer\">github.com/spicavigo/kafka-rust/blob/master/examples/&hellip;</a> where there HashSet would be declared around line 32 and used around line 42"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1475669538, "post_id": 39873206, "comment_id": 67033793, "body": "Goodness, attempting to find a good duplicate in the mass of borrow-checker issues on stackoverflow is like looking for a needle in a pile of hay :("}, {"owner": {"reputation": 3474, "user_id": 497398, "user_type": "registered", "accept_rate": 41, "profile_image": "https://www.gravatar.com/avatar/1dac2c810e7a6d0787aadc020caa4d71?s=128&d=identicon&r=PG", "display_name": "mfirry", "link": "https://stackoverflow.com/users/497398/mfirry"}, "edited": false, "score": 0, "creation_date": 1475669837, "post_id": 39873206, "comment_id": 67034008, "body": "Yep. a simple <code>.to_string()</code> fixed it. Thanks!"}, {"owner": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1475673682, "post_id": 39873206, "comment_id": 67036805, "body": "@Matthieu M. If it&#39;s hard to see an obvious duplicate, maybe it&#39;s better to leave the question open and provide an answer. It may be even harder for future readers to see the similarity."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "edited": false, "score": 1, "creation_date": 1475675301, "post_id": 39873206, "comment_id": 67038122, "body": "@PavelStrakhov: The problem is finding the duplicate (because there are so many different situations the borrow-checker complains about). I believe that the two questions linked here are duplicates enough that they ought to be marked as such. Case in point, the OP found the solution to his issue following the duplicate mark :)"}], "owner": {"reputation": 3474, "user_id": 497398, "user_type": "registered", "accept_rate": 41, "profile_image": "https://www.gravatar.com/avatar/1dac2c810e7a6d0787aadc020caa4d71?s=128&d=identicon&r=PG", "display_name": "mfirry", "link": "https://stackoverflow.com/users/497398/mfirry"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 42, "favorite_count": 0, "closed_date": 1475669844, "answer_count": 0, "score": 0, "last_activity_date": 1475675684, "creation_date": 1475668284, "last_edit_date": 1475675684, "question_id": 39873206, "link": "https://stackoverflow.com/questions/39873206/visibility-of-set-outside-of-infinite-loop-filling-it", "closed_reason": "Duplicate", "title": "Visibility of set outside of infinite loop filling it", "body": "<p>I'm defining a <code>HashSet</code> just outside of a <code>loop</code> that will eventually fill it.</p>\n\n<p>Something like:</p>\n\n<pre><code>let mut keys = HashSet::new();\nloop {\n    let mss = try!(con.poll()); // taken from kafka-rust\n    // some code\n    keys.insert(stuff);\n    // some code\n    try!(con.commit_consumed());\n}\n</code></pre>\n\n<p>Now I have the obvious <code>reference must be valid for the block suffix following statement</code>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>note: reference must be valid for the block suffix following statement 1 at 28:34...\n  --&gt; src/main.rs:28:35\n   |\n28 |     let mut keys = HashSet::new();\n   |                                   ^\nnote: ...but borrowed value is only valid for the block suffix following statement 0 at 30:35\n  --&gt; src/main.rs:30:36\n   |\n30 |         let mss = try!(con.poll());\n   |                                    ^\n\nerror: aborting due to previous error\n</code></pre>\n\n<p>What's the correct way of doing this?</p>\n"}, {"tags": ["multithreading", "rust"], "answers": [{"comments": [{"owner": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "edited": false, "score": 0, "creation_date": 1475653985, "post_id": 39867918, "comment_id": 67023825, "body": "Thanks for the suggestion. Unfortunately it seems to not work well with threads. A given thread owns Box&lt;Handler&gt; but not Handler which implies Handler needs to implement Send. Rust can&#39;t figure out that the Handler object doesn&#39;t have references outside of the thread. This forces me to make Handler thread safe."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "edited": false, "score": 0, "creation_date": 1475654327, "post_id": 39867918, "comment_id": 67024035, "body": "Copying and thread-safety are different issues, indeed if you wish to send the handler across threads you need either add the <code>Send</code> bound to <code>Handler</code> (and probably the <code>&#39;static</code> bound as well) or you can add them to the Box as in <code>Box&lt;Handler + Send + &#39;static&gt;</code>. I would recommend the former, for convenience."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1475665175, "post_id": 39867918, "comment_id": 67030874, "body": "Naming that method <code>clone</code> would probably be confusing here."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1475665750, "post_id": 39867918, "comment_id": 67031248, "body": "@mcarton: How does <code>duplicate</code> sounds?"}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1475666474, "post_id": 39867918, "comment_id": 67031766, "body": "@MatthieuM. Less confusing :)"}, {"owner": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "edited": false, "score": 0, "creation_date": 1475673428, "post_id": 39867918, "comment_id": 67036605, "body": "Having a method that&#39;s essentially <code>clone()</code> but belongs to another trait and has different name is still confusing. Why can&#39;t you just add <code>Clone</code> bound or derive <code>Handler</code> from <code>Clone</code> instead of creating new method?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "edited": false, "score": 0, "creation_date": 1475675390, "post_id": 39867918, "comment_id": 67038201, "body": "@PavelStrakhov: Ah... that&#39;s a tricky one. <code>Clone</code> is not object safe, so it cannot be used virtually. Note here that I do not return <code>Handler</code> but <code>Box&lt;Handler&gt;</code> to make the method object safe."}, {"owner": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "edited": false, "score": 0, "creation_date": 1475679858, "post_id": 39867918, "comment_id": 67041836, "body": "@MatthieuM I understand your point about thread safety but why is it needed here? The point is to clone the handlers so that thread safety is not a worry anymore. This is what I mention in 3) of my original question."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "edited": false, "score": 0, "creation_date": 1475680025, "post_id": 39867918, "comment_id": 67041974, "body": "@ElefEnt: I think that you are misunderstanding what <code>Send</code> and <code>Sync</code> are about =&gt; <a href=\"https://doc.rust-lang.org/nomicon/send-and-sync.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/nomicon/send-and-sync.html</a> ; in short <code>Send</code> means &quot;I hold nothing that would be unsafe to be shared, so you can send me safely to another thread&quot; whereas <code>Sync</code> means &quot;I can be shared across threads safely&quot;. Thus, it makes sense to require that your handlers be <code>Send</code> if they will be sent to other threads."}, {"owner": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "edited": false, "score": 0, "creation_date": 1475680669, "post_id": 39867918, "comment_id": 67042408, "body": "@MatthieuM while I am at it, is there a solution with FnMut at all?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "edited": false, "score": 0, "creation_date": 1475680908, "post_id": 39867918, "comment_id": 67042561, "body": "@ElefEnt: With sharing, yes, with cloning no (you cannot modify it to be clone friendly). Sharing would involve something such as <code>Arc&lt;Mutex&lt;FnMut(...) -&gt; ...&gt;&gt;</code> and would require locking the whole handler during processing. Note that you may be able to send them across threads without cloning them (for example by assigning two handlers to one thread and two to another thread, or one handler per thread, ...)"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "edited": false, "score": 0, "creation_date": 1475688016, "post_id": 39867918, "comment_id": 67046927, "body": "Let us <a href=\"http://chat.stackoverflow.com/rooms/125020/discussion-between-matthieu-m-and-elefent\">continue this discussion in chat</a>."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 1, "last_activity_date": 1475665741, "last_edit_date": 1475665741, "creation_date": 1475652678, "answer_id": 39867918, "question_id": 39867556, "link": "https://stackoverflow.com/questions/39867556/how-do-i-share-handlers-between-threads/39867918#39867918", "title": "How do I share handlers between threads?", "body": "<p>The simplest solution is to request the user to define a clone method.</p>\n\n<pre><code>trait Handler {\n    fn process(&amp;mut self, r: Request) -&gt; Response;\n    fn duplicate(&amp;self) -&gt; Box&lt;Handler&gt;;\n}\n</code></pre>\n\n<p>And then you can copy your <code>Vec&lt;Box&lt;Handler&gt;&gt;</code> quite easily.</p>\n"}], "owner": {"reputation": 1599, "user_id": 2441230, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4a3fe1d786c575a3b6aaa872604d1d13?s=128&d=identicon&r=PG", "display_name": "ElefEnt", "link": "https://stackoverflow.com/users/2441230/elefent"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 94, "favorite_count": 0, "accepted_answer_id": 39867918, "answer_count": 1, "score": 1, "last_activity_date": 1475665741, "creation_date": 1475651450, "last_edit_date": 1475651666, "question_id": 39867556, "link": "https://stackoverflow.com/questions/39867556/how-do-i-share-handlers-between-threads", "title": "How do I share handlers between threads?", "body": "<p>I am writing a multithreaded webserver and basically I need to copy a <code>Vec&lt;Handler&gt;</code> of user-provided handler objects across multiple threads on server startup. I tried several approaches:</p>\n\n<p>1) Define Handler as a trait with a <code>fn process(&amp;mut self, Request) -&gt; Response</code> method. Users would implement it for each handler struct. This approach is very common in languages like C++ or python. The problem is that rust doesn't allow me to copy or clone a trait object as it would imply the <code>Sized</code> bound on it which is forbidden on trait objects.</p>\n\n<p>2) Define Handler as a <code>Box&lt;FnMut(Request) -&gt; Response&gt;</code>. This doesn't work as closures are not copyable.</p>\n\n<p>3) I could share the same objects between threads but this makes very little sense to me as I would need a mutex which would introduce useless contention when I actually just need separate copies across threads.</p>\n\n<p>How can I implement this properly?</p>\n"}, {"tags": ["rust", "rust-cargo"], "comments": [{"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1475556768, "post_id": 39844260, "comment_id": 66977952, "body": "What&#39;s your rust version? On the current nightly I can&#39;t even get c_vec to build to help test this out."}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "reply_to_user": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1475557758, "post_id": 39844260, "comment_id": 66978220, "body": "@Jsor, added details"}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1475559023, "post_id": 39844260, "comment_id": 66978590, "body": "thanks, and what exactly are you doing to trigger the panic?"}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "reply_to_user": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1475559915, "post_id": 39844260, "comment_id": 66978899, "body": "@Jsor, nothing, its not even building."}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 1, "creation_date": 1475561474, "post_id": 39844260, "comment_id": 66979465, "body": "Pretty sure this is a bug see <a href=\"https://github.com/rust-lang/rust/issues/32837\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/32837</a> I&#39;m thinking it wasn&#39;t actually totally fixed. I&#39;m trying to add a comment, but Github&#39;s servers are dying right now."}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1475564694, "post_id": 39844260, "comment_id": 66980958, "body": "Sorry, this issue <a href=\"https://github.com/rust-lang/cargo/issues/2738\" rel=\"nofollow noreferrer\">github.com/rust-lang/cargo/issues/2738</a>"}], "answers": [{"comments": [{"owner": {"reputation": 13280, "user_id": 435253, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/80df0d0f2a1945a7bed366ff25f8ea5d?s=128&d=identicon&r=PG", "display_name": "ssokolow", "link": "https://stackoverflow.com/users/435253/ssokolow"}, "edited": false, "score": 2, "creation_date": 1479049918, "post_id": 39863793, "comment_id": 68386056, "body": "I don&#39;t remember the technique off-hand, but I remember reading that Cargo supports local dependency overlays, so I&#39;d assume you only need to fork <code>c_vec</code> if that&#39;s the only one specifying <code>dylib</code>."}], "tags": [], "owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "is_accepted": true, "score": 5, "last_activity_date": 1475628132, "creation_date": 1475628132, "answer_id": 39863793, "question_id": 39844260, "link": "https://stackoverflow.com/questions/39844260/how-to-use-panic-abort-with-external-dependencies/39863793#39863793", "title": "How to use panic=abort with external dependencies?", "body": "<p>Looks like it's because <code>c_vec</code> specifies <code>dylib</code> as one of its library types.</p>\n\n<p>I filed this as an issue on Github here: <a href=\"https://github.com/rust-lang/cargo/issues/2738\" rel=\"noreferrer\">https://github.com/rust-lang/cargo/issues/2738</a></p>\n\n<p>And got an answer from one of the devs:</p>\n\n<blockquote>\n  <p>ah unfortunately that's a bad error message but it's\n  because of crate-type = [\"dylib\", \"rlib\"] in the c_vec crate. This\n  causes Cargo to pass -C prefer-dynamic which links to the dylib that\n  we ship which is compiled against panic_unwind, meaning the abort mode\n  is indeed invalid (this error is coming from the compiler).</p>\n  \n  <p>The fix here would be to remove \"dylib\" from the c_vec crate.</p>\n</blockquote>\n\n<p>Of course, you'd have to fork your own <code>lodepng</code> and <code>c_vec</code> to take care of this.</p>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1893, "favorite_count": 0, "accepted_answer_id": 39863793, "answer_count": 1, "score": 8, "last_activity_date": 1475628132, "creation_date": 1475555957, "last_edit_date": 1475557734, "question_id": 39844260, "link": "https://stackoverflow.com/questions/39844260/how-to-use-panic-abort-with-external-dependencies", "title": "How to use panic=abort with external dependencies?", "body": "<p>For single crate projects, adding these lines to <code>Cargo.toml</code> works as expected.</p>\n\n<pre><code>[profile.release]\npanic = \"abort\"\n</code></pre>\n\n<p>Then build the project:</p>\n\n<pre><code>cargo build --release\n</code></pre>\n\n<hr>\n\n<p>However, on a project which has indirectly used dependencies, I'm getting an error.</p>\n\n<pre><code>    Compiling c_vec v1.0.12\nerror: the linked panic runtime `panic_unwind` is not compiled with this crate's panic strategy `abort`\n\nerror: aborting due to previous error\n\nBuild failed, waiting for other jobs to finish...\nerror: Could not compile `c_vec`.\n</code></pre>\n\n<p>The <code>c_vec</code> crate is an indirectly used dependency.</p>\n\n<p>How to use <code>panic=abort</code> on a multi-crate project without conflicts?</p>\n\n<hr>\n\n<p>Details incase they matter:</p>\n\n<ul>\n<li>Rustc 1.12.0</li>\n<li>Library with issue: <a href=\"https://github.com/pornel/lodepng-rust\">lodepng-rust</a></li>\n<li>Linux, 64bit</li>\n</ul>\n"}, {"tags": ["rust", "biginteger", "factorial", "bignum"], "answers": [{"comments": [{"owner": {"reputation": 620, "user_id": 2576287, "user_type": "registered", "accept_rate": 56, "profile_image": "https://lh5.googleusercontent.com/-VegFz4P9Ovc/AAAAAAAAAAI/AAAAAAAAATo/Z-69W9rBCno/photo.jpg?sz=128", "display_name": "mrLSD", "link": "https://stackoverflow.com/users/2576287/mrlsd"}, "edited": false, "score": 1, "creation_date": 1475530874, "post_id": 39840726, "comment_id": 66971457, "body": "Great answer! But there are another problem with loop for factorial bigint - extremly slow."}, {"owner": {"reputation": 40441, "user_id": 184499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9193db48f98cc6e0314a7c536a2c6330?s=128&d=identicon&r=PG", "display_name": "Matt", "link": "https://stackoverflow.com/users/184499/matt"}, "reply_to_user": {"reputation": 620, "user_id": 2576287, "user_type": "registered", "accept_rate": 56, "profile_image": "https://lh5.googleusercontent.com/-VegFz4P9Ovc/AAAAAAAAAAI/AAAAAAAAATo/Z-69W9rBCno/photo.jpg?sz=128", "display_name": "mrLSD", "link": "https://stackoverflow.com/users/2576287/mrlsd"}, "edited": false, "score": 1, "creation_date": 1475531057, "post_id": 39840726, "comment_id": 66971525, "body": "@mrLSD I don&#39;t doubt it! But recursion, at least in Rust, doesn&#39;t really offer any speed improvements over loops. At least I haven&#39;t heard of that."}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "reply_to_user": {"reputation": 620, "user_id": 2576287, "user_type": "registered", "accept_rate": 56, "profile_image": "https://lh5.googleusercontent.com/-VegFz4P9Ovc/AAAAAAAAAAI/AAAAAAAAATo/Z-69W9rBCno/photo.jpg?sz=128", "display_name": "mrLSD", "link": "https://stackoverflow.com/users/2576287/mrlsd"}, "edited": false, "score": 10, "creation_date": 1475540041, "post_id": 39840726, "comment_id": 66974195, "body": "@mrLSD Although LLVM <i>can</i> optimize certain tail calls, the function in the question does not have a tail call and would not be optimized anyway, even in a language that guaranteed TCO"}], "tags": [], "owner": {"reputation": 40441, "user_id": 184499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9193db48f98cc6e0314a7c536a2c6330?s=128&d=identicon&r=PG", "display_name": "Matt", "link": "https://stackoverflow.com/users/184499/matt"}, "is_accepted": true, "score": 22, "last_activity_date": 1556986894, "last_edit_date": 1556986894, "creation_date": 1475530232, "answer_id": 39840726, "question_id": 39840663, "link": "https://stackoverflow.com/questions/39840663/recursive-function-calculating-factorials-leads-to-stack-overflow/39840726#39840726", "title": "Recursive function calculating factorials leads to stack overflow", "body": "<p>Rust doesn't have tail call elimination, so your recursion is limited by your stack size. It may be a feature for Rust in the future (you can read more about it at the <a href=\"https://prev.rust-lang.org/en-US/faq.html#does-rust-do-tail-call-optimization\" rel=\"noreferrer\">Rust FAQ</a>), but in the meantime you will have to either not recurse so deep or use loops.</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 5, "creation_date": 1475563118, "post_id": 39841144, "comment_id": 66980133, "body": "Note: much like that famous cat, measuring stack frame size may increase it (before the address of <code>num</code> was taken, it could leave in a register, and <code>println!</code> requires some stack space too)."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 13, "last_activity_date": 1475532791, "last_edit_date": 1475532791, "creation_date": 1475532346, "answer_id": 39841144, "question_id": 39840663, "link": "https://stackoverflow.com/questions/39840663/recursive-function-calculating-factorials-leads-to-stack-overflow/39841144#39841144", "title": "Recursive function calculating factorials leads to stack overflow", "body": "<h3>Why?</h3>\n\n<p>This is a stack overflow which occurs whenever there is no stack memory left. For example, stack memory is used by </p>\n\n<ul>\n<li>local variables </li>\n<li>function arguments</li>\n<li>return values</li>\n</ul>\n\n<p>Recursion uses a lot of stack memory, because for every recursive call, the memory for all local variables, function arguments, ... has to be allocated on the stack. </p>\n\n<hr>\n\n<blockquote>\n  <h3>How to fix that?</h3>\n</blockquote>\n\n<p>The obvious solution is to write your algorithm in a non-recursive manner (you should do this when you want to use the algorithm in production!). But you can also just <strong>increase the stack size</strong>. While the stack size of the main thread <em>can't</em> be modified, you can create a new thread and set a specific stack size:</p>\n\n<pre><code>fn main() {\n    let num: u64 = 100_000;\n    // Size of one stack frame for `factorial()` was measured experimentally\n    thread::Builder::new().stack_size(num as usize * 0xFF).spawn(move || {\n        println!(\"Factorial {}! = {}\", num, factorial(num));\n    }).unwrap().join();\n}\n</code></pre>\n\n<p>This code <strong>works</strong> and, when executed via <code>cargo run --release</code> (with optimization!), outputs the solution after only a couple of seconds calculation.</p>\n\n<hr>\n\n<h3>Measuring stack frame size</h3>\n\n<p>In case you want to know how the stack frame size (memory requirement for <em>one</em> call) for <code>factorial()</code> was measured: I printed the address of the function argument <code>num</code> on each <code>factorial()</code> call:</p>\n\n<pre><code>fn factorial(num: u64) -&gt; BigUint {\n    println!(\"{:p}\", &amp;num);\n    // ...\n}\n</code></pre>\n\n<p>The difference between two successive call's addresses is (more or less) the stack frame size. On my machine, the difference was slightly less than <code>0xFF</code> (255), so I just used that as size.</p>\n\n<p>In case you're wondering why the stack frame size isn't smaller: the Rust compiler doesn't really optimize for this metric. Usually it's really not important, so optimizers tend to sacrifice this memory requirement for better execution speed. I took a look at the assembly and in this case many <code>BigUint</code> methods were inlined. This means that the local variables of other functions are using stack space as well! </p>\n"}, {"comments": [{"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 1, "creation_date": 1475571876, "post_id": 39841150, "comment_id": 66984759, "body": "<code>maybe_grow(1024 * 1024, 1024 * 1024</code> will allocate a new stack frame every call. I <a href=\"http://superuser.com/a/767491/57579\">measure</a> 1GB memory usage. If I change it into <code>maybe_grow(32 * 1024, 1024 * 1024</code>, it will not allocate a new stack until 32K is left. Now it uses just 20MB memory. That change does not really change the speed though."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 0, "creation_date": 1475580807, "post_id": 39841150, "comment_id": 66990189, "body": "Ah yes sorry - I did originally have it at a 64k boundary but bumped it up on my final test."}, {"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 2, "creation_date": 1475654166, "post_id": 39841150, "comment_id": 67023936, "body": "You say <code>I do not recommend</code>, but I think this is really a good option if you can&#39;t rewrite a recursive algorithm into an iterative algorithm. A runtime stack overflow is really bad. Of course the algorithm in this question is easy to write iterative."}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 7, "last_activity_date": 1475532383, "creation_date": 1475532383, "answer_id": 39841150, "question_id": 39840663, "link": "https://stackoverflow.com/questions/39840663/recursive-function-calculating-factorials-leads-to-stack-overflow/39841150#39841150", "title": "Recursive function calculating factorials leads to stack overflow", "body": "<p>Just as an alternative.. (I do not recommend)</p>\n\n<p>Matts answer is true to an extent. There is a crate called <code>stacker</code> (<a href=\"https://crates.io/crates/stacker/\" rel=\"noreferrer\">here</a>) that can artificially increase the stack size for usage in recursive algorithms. It does this by allocating some heap memory to overflow into.</p>\n\n<p>As a word of warning... this takes <em>a very long time to run</em> ... but, it runs, and it doesn't blow the stack. Compiling with optimizations brings it down but its still pretty slow. You're likely to get better perf from a loop as Matt suggests. I thought I would throw this out there anyway.</p>\n\n<pre><code>extern crate num_bigint;\nextern crate num_traits;\nextern crate stacker;\n\nuse num_bigint::{BigUint, ToBigUint};\nuse num_traits::One;\n\nfn factorial(num: u64) -&gt; BigUint {\n    // println!(\"Called with: {}\", num);\n    let current: BigUint = num.to_biguint().unwrap();\n    if num &lt;= 1 {\n        // println!(\"Returning...\");\n        return One::one();\n    }\n\n    stacker::maybe_grow(1024 * 1024, 1024 * 1024, || {\n        current * factorial(num - 1)\n    })\n}\n\nfn main() {\n    let num: u64 = 100000;\n    println!(\"Factorial {}! = {}\", num, factorial(num));\n}\n</code></pre>\n\n<p>I have commented out the debug <code>println</code>s.. you can uncomment them if you like.</p>\n"}], "owner": {"reputation": 620, "user_id": 2576287, "user_type": "registered", "accept_rate": 56, "profile_image": "https://lh5.googleusercontent.com/-VegFz4P9Ovc/AAAAAAAAAAI/AAAAAAAAATo/Z-69W9rBCno/photo.jpg?sz=128", "display_name": "mrLSD", "link": "https://stackoverflow.com/users/2576287/mrlsd"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 10412, "favorite_count": 4, "accepted_answer_id": 39840726, "answer_count": 3, "score": 16, "last_activity_date": 1556986894, "creation_date": 1475529959, "last_edit_date": 1475530557, "question_id": 39840663, "link": "https://stackoverflow.com/questions/39840663/recursive-function-calculating-factorials-leads-to-stack-overflow", "title": "Recursive function calculating factorials leads to stack overflow", "body": "<p>I tried a recursive factorial algorithm in Rust. I use this version of the compiler:</p>\n\n<pre><code>rustc 1.12.0 (3191fbae9 2016-09-23)\ncargo 0.13.0-nightly (109cb7c 2016-08-19)\n</code></pre>\n\n<p><strong>Code:</strong></p>\n\n<pre><code>extern crate num_bigint;\nextern crate num_traits;\n\nuse num_bigint::{BigUint, ToBigUint};\nuse num_traits::One;\n\nfn factorial(num: u64) -&gt; BigUint {\n    let current: BigUint = num.to_biguint().unwrap();\n    if num &lt;= 1 {\n        return One::one();\n    }\n    return current * factorial(num - 1);\n}\n\nfn main() {\n    let num: u64 = 100000;\n    println!(\"Factorial {}! = {}\", num, factorial(num))\n}\n</code></pre>\n\n<p>I got this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ cargo run\n\nthread 'main' has overflowed its stack\nfatal runtime error: stack overflow\nerror: Process didn't exit successfully\n</code></pre>\n\n<p>How to fix that? And why do I see this error when using Rust?</p>\n"}, {"tags": ["rust", "lifetime", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 1, "last_activity_date": 1475809264, "last_edit_date": 1475809264, "creation_date": 1475486588, "answer_id": 39828296, "question_id": 39827244, "link": "https://stackoverflow.com/questions/39827244/who-borrowed-a-variable/39828296#39828296", "title": "Who borrowed a variable?", "body": "<p>I put the body of <code>f4()</code> in a <code>main()</code> and implemented <code>Drop</code> for <code>Bar2</code> to find out when it is dropped (i.e. goes out of scope):</p>\n\n<pre><code>impl&lt;'b&gt; Drop for Bar2&lt;'b&gt; {\n    fn drop(&amp;mut self) { println!(\"dropping Bar2!\"); }\n}\n</code></pre>\n\n<p>And the result was:</p>\n\n<pre><code>error: `bar2` does not live long enough\n  --&gt; &lt;anon&gt;:24:5\n   |\n24 |     bar2.f();\n   |     ^^^^ does not live long enough\n25 | }\n   | - borrowed value dropped before borrower\n   |\n   = note: values in a scope are dropped in the opposite order they are created\n</code></pre>\n\n<p>Something's fishy; let's examine it in detail, with helper scopes:</p>\n\n<pre><code>fn main() {\n    {\n        let foo = Foo {}; // foo scope begins\n        {\n            let mut bar2 = Bar2 { x: &amp;foo }; // bar2 scope begins; bar2 borrows foo\n            bar2.f();\n        } // bar2 should be dropped here, but it has the same lifetime as foo, which is still live\n    } // foo is dropped (its scope ends)\n}\n</code></pre>\n\n<p>It looks to me that there is a leak here and <code>bar2</code> is never dropped (and thus <code>Drop</code> cannot be implemented for it). That's why you cannot re-borrow it.</p>\n"}, {"tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 9, "last_activity_date": 1475487318, "creation_date": 1475487318, "answer_id": 39828539, "question_id": 39827244, "link": "https://stackoverflow.com/questions/39827244/who-borrowed-a-variable/39828539#39828539", "title": "Who borrowed a variable?", "body": "<p>In case #2, you have this:</p>\n\n<pre><code>impl&lt;'b&gt; Bar2&lt;'b&gt; {\n    fn f(&amp;'b mut self) -&gt; &amp;'b Foo {\n        self.x\n    }\n}\n</code></pre>\n\n<p>To highlight: <code>&amp;'b mut self</code> and <code>&amp;'b Foo</code> have the same lifetime specified.</p>\n\n<p>This is saying that the reference to <code>self</code> and the returned reference to an instance of a <code>Foo</code> both have the same lifetime. Looking at the call site, you have this:</p>\n\n<pre><code>let foo = Foo {};\nlet mut bar2 = Bar2 { x: &amp;foo };\n</code></pre>\n\n<p>So the compiler is inferring that both <code>foo</code> and <code>bar2</code> have the same lifetime. The lifetime of <code>foo</code> is the scope of the <code>f4</code> function, and so the mutable reference to <code>bar2</code> shares this.</p>\n\n<p>One way to fix this, is to remove the explicit lifetime on the <code>self</code> reference:</p>\n\n<pre><code>fn f(&amp;mut self) -&gt; &amp;'b Foo\n</code></pre>\n\n<p>This compiles and the compiler correctly understands that the reference to <code>bar2</code> and the reference to <code>foo</code> have different lifetimes.</p>\n\n<p>Playground: <a href=\"https://play.rust-lang.org/?gist=caf262dd628cf14cc2884a3af842276a&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">https://play.rust-lang.org/?gist=caf262dd628cf14cc2884a3af842276a&amp;version=stable&amp;backtrace=0</a></p>\n\n<p>TLDR: Yes, having the same lifetime specifier on the self reference and the returned reference means that the entire scope of <code>f4</code> holds a mutable borrow of <code>bar2</code>.</p>\n"}, {"comments": [{"owner": {"reputation": 6367, "user_id": 6914441, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/bbc12c764b93fa915b8e5384f521fe12?s=128&d=identicon&r=PG&f=1", "display_name": "jferard", "link": "https://stackoverflow.com/users/6914441/jferard"}, "edited": false, "score": 0, "creation_date": 1475692455, "post_id": 39828602, "comment_id": 67049425, "body": "Accepted because of this valuable rule of thumb. Thanks."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 9, "last_activity_date": 1475487504, "creation_date": 1475487504, "answer_id": 39828602, "question_id": 39827244, "link": "https://stackoverflow.com/questions/39827244/who-borrowed-a-variable/39828602#39828602", "title": "Who borrowed a variable?", "body": "<p>Ah... you basically self-borrowed yourself.</p>\n\n<p>The issue hinges on the fact that you have the same lifetime (<code>'b</code>) used for both the lifetime of <code>Foo</code> and the lifetime of <code>Bar</code>. The compiler then dutifully unifies those lifetimes, and you end up in a strange situation where suddenly the lifetime of the borrow which should have ended at the end of the statement instead ends after the value should have gone out of scope.</p>\n\n<p>As a rule of thumb: <em>always</em> use a fresh lifetime for <code>self</code>. Anything else is weird.</p>\n\n<hr>\n\n<p>It's interesting to note that this pattern can actually be useful (though more likely with an immutable borrow): it allows <em>anchoring</em> a value to a stack frame, preventing any move after the call to the function, which is (sometimes) useful to represent a borrow that is not well-modeled by Rust (like passing a pointer to the value to FFI).</p>\n"}, {"tags": [], "owner": {"reputation": 429, "user_id": 5081997, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-GmesG-HGk2A/AAAAAAAAAAI/AAAAAAAACLI/lmInTd8OR3A/photo.jpg?sz=128", "display_name": "cotigao", "link": "https://stackoverflow.com/users/5081997/cotigao"}, "is_accepted": false, "score": 1, "last_activity_date": 1538029723, "last_edit_date": 1538029723, "creation_date": 1536385977, "answer_id": 52232458, "question_id": 39827244, "link": "https://stackoverflow.com/questions/39827244/who-borrowed-a-variable/52232458#52232458", "title": "Who borrowed a variable?", "body": "<p>I would like to add about the roles that subtyping/variance play here. </p>\n\n<p><code>&amp;mut T</code> is invariant over <code>T</code>. Given two types <code>T</code> and <code>U</code>, where <code>T</code> &lt; <code>U</code> (<code>T</code> is a subtype of <code>U</code>), then <code>&amp;mut T</code> has no subtyping relation with <code>&amp;mut U</code> (i.e they are invariant with each other), whereas <code>&amp;T</code> is a subtype of <code>&amp;U</code> (<code>&amp;T</code> &lt; <code>&amp;U</code>). But <code>&amp;'lifetime</code> and <code>&amp;'lifetime mut</code>, both are covariant over <code>'lifetime</code>. So given two lifetimes <code>'a</code> and <code>'b</code> for a type <code>T</code>, where <code>'a</code> outlives <code>'b</code>, then as per subtyping relation <code>&amp;'a T</code> &lt; <code>&amp;'b T</code>, similarly  <code>&amp;'a mut T</code> &lt; <code>&amp;'b mut T</code></p>\n\n<p>Coming to the question, in the call to function <code>f</code>, <code>self</code> is a reference to <code>Bar2&lt;'a&gt;</code>. The compiler will see if it can \"temporarily shorten\" the life of <code>bar2</code> to fit around the scope of the function <code>f</code>'s invocation say <code>'x</code>, as if <code>bar2</code> and <code>foo</code> were created just before <code>f</code> is called and go away immediately after <code>f</code> (i.e temporary shortening: assuming variable <code>bar2</code> created within <code>'x</code> and hence <code>Bar2&lt;'a&gt;</code> to <code>Bar2&lt;'x&gt;</code>, <code>'a</code> being the original (real) lifetime). But here, \"shortening\" is not possible; One, because of mutable reference to <code>self</code> and two, same lifetime on references to <code>Foo</code> as well as <code>Bar2</code> (<code>self</code>), in the function <code>f</code>'s definition. Firstly, since it is a mutable reference, it can't convert <code>Bar2&lt;'a&gt;</code> to <code>Bar2&lt;'x&gt;</code>, because <code>&amp;mut Bar2&lt;'a&gt;</code> and <code>&amp;mut Bar2&lt;'x&gt;</code> are invariant with each other. (remember even if <code>T &lt; U</code> or <code>T &gt; U</code>, then <code>&amp;mut T</code> is invariant with <code>&amp;mut U</code>). So the compiler has to go with <code>Bar2&lt;'a&gt;</code> and secondly, since the function <code>f</code> is having the same lifetimes for references to <code>Bar2</code> and <code>Foo</code>, can't convert <code>&amp;'a Bar2&lt;'a&gt;</code> to <code>&amp;'x Bar2&lt;'a&gt;</code>. So it means the references aren't \"shortened\" when calling the function <code>f</code> and they will remain valid till the end of the block.</p>\n\n<p>If <code>self</code>'s lifetime is elided, then the compiler will give a fresh lifetime to the <code>self</code> (disjoint with <code>'b</code>), which means it is free to \"temporarily shorten\" the life of <code>Bar2</code> and then pass it's <code>mut</code> reference to <code>f</code>. i.e It will do <code>&amp;'a mut Bar2&lt;'a&gt;</code> to <code>&amp;'x mut Bar2&lt;'a&gt;</code> and then pass it to <code>f</code>. (remember <code>&amp;'lifetime mut</code> is covariant over <code>'lifetime</code>) and hence it will work.</p>\n"}], "owner": {"reputation": 6367, "user_id": 6914441, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/bbc12c764b93fa915b8e5384f521fe12?s=128&d=identicon&r=PG&f=1", "display_name": "jferard", "link": "https://stackoverflow.com/users/6914441/jferard"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 643, "favorite_count": 3, "accepted_answer_id": 39828602, "answer_count": 4, "score": 12, "last_activity_date": 1538029723, "creation_date": 1475482825, "last_edit_date": 1475501373, "question_id": 39827244, "link": "https://stackoverflow.com/questions/39827244/who-borrowed-a-variable", "title": "Who borrowed a variable?", "body": "<p>I'm fighting with the borrow checker. I have two similar pieces of code, one working as I expect, and the other not.</p>\n\n<p>The one that works as I expect:</p>\n\n<pre><code>mod case1 {\n    struct Foo {}\n\n    struct Bar1 {\n        x: Foo,\n    }\n\n    impl Bar1 {\n        fn f&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a Foo {\n            &amp;self.x\n        }\n    }\n\n    // only for example\n    fn f1() {\n        let mut bar = Bar1 { x: Foo {} };\n        let y = bar.f(); // (1) 'bar' is borrowed by 'y'\n        let z = bar.f();  // error (as expected) : cannot borrow `bar` as mutable more\n                           // than once at a time [E0499]\n    }\n\n    fn f2() {\n        let mut bar = Bar1 { x: Foo {} };\n        bar.f(); // (2) 'bar' is not borrowed after the call\n        let z = bar.f();  // ok (as expected)\n    }\n}\n</code></pre>\n\n<p>The one that doesn't:</p>\n\n<pre><code>mod case2 {\n    struct Foo {}\n\n    struct Bar2&lt;'b&gt; {\n        x: &amp;'b Foo,\n    }\n\n    impl&lt;'b&gt; Bar2&lt;'b&gt; {\n        fn f(&amp;'b mut self) -&gt; &amp;'b Foo {\n            self.x\n        }\n    }\n\n    fn f4() {\n        let foo = Foo {};\n        let mut bar2 = Bar2 { x: &amp;foo };\n        bar2.f(); // (3) 'bar2' is borrowed as mutable, but who borrowed it?\n        let z = bar2.f(); // error: cannot borrow `bar2` as mutable more than once at a time [E0499]\n    }\n}\n</code></pre>\n\n<p>I hoped I could call <code>Bar2::f</code> twice without irritating the compiler, as in case 1.</p>\n\n<p>The question is in the comment (3): who borrowed <code>bar2</code>, whereas there is no affectation? </p>\n\n<p>Here's what I understand: </p>\n\n<ol>\n<li><p>In case 1, <code>f2</code> call: the lifetime parameter <code>'a</code> is the one of the receiving <code>&amp;Foo</code> value, so this lifetime is empty when there is no affectation, and <code>bar</code> is not borrowed after the <code>Bar1::f</code> call;</p></li>\n<li><p>In case 2, <code>bar2</code> borrows <code>foo</code> (as immutable), so the lifetime parameter <code>'b</code> in <code>Bar2</code> struct is the <code>foo</code> reference lifetime, which ends at the end of <code>f4</code> body. Calling <code>Bar2::f</code> borrows <code>bar2</code> for that lifetime, namely to the end of <code>f4</code>.</p></li>\n</ol>\n\n<p>But the question is still: who borrowed <code>bar2</code>? Could it be <code>Bar2::f</code>? How <code>Bar2::f</code> would hold the borrowed ownership after the call? What am I missing here?</p>\n\n<p>I'm using Rust 1.14.0-nightly (86affcdf6 2016-09-28) on x86_64-pc-windows-msvc.</p>\n"}, {"tags": ["types", "rust", "dereference"], "answers": [{"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 4, "last_activity_date": 1475430812, "creation_date": 1475430812, "answer_id": 39819915, "question_id": 39819874, "link": "https://stackoverflow.com/questions/39819874/type-usize-cannot-be-dereferenced/39819915#39819915", "title": "Type `usize` cannot be dereferenced", "body": "<p><a href=\"https://doc.rust-lang.org/std/primitive.usize.html\" rel=\"nofollow\"><code>usize</code></a> doesn't implement the <a href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html\" rel=\"nofollow\"><code>Deref</code></a> trait, so you can't apply <code>*</code> to it. <code>write()</code> returns a <code>Result&lt;usize&gt;</code>, so when you <code>unwrap()</code> it and apply the dereferencing asterisk:</p>\n\n<pre><code>*temp.write(data).unwrap()\n</code></pre>\n\n<p>You are attempting to do</p>\n\n<pre><code>*usize\n</code></pre>\n\n<p>Which is not possible.</p>\n"}, {"comments": [{"owner": {"reputation": 1600, "user_id": 771071, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/79354d20a5c400b2a8c31341fc7a3d39?s=128&d=identicon&r=PG", "display_name": "Joseph Callaars", "link": "https://stackoverflow.com/users/771071/joseph-callaars"}, "edited": false, "score": 0, "creation_date": 1475431385, "post_id": 39819932, "comment_id": 66930177, "body": "I&#39;ve updated my question, as I tried it to remove the <code>*</code>, but that results in another error."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 1600, "user_id": 771071, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/79354d20a5c400b2a8c31341fc7a3d39?s=128&d=identicon&r=PG", "display_name": "Joseph Callaars", "link": "https://stackoverflow.com/users/771071/joseph-callaars"}, "edited": false, "score": 8, "creation_date": 1475431543, "post_id": 39819932, "comment_id": 66930248, "body": "The Rust compiler usually will not report all errors right away; it&#39;s frequent that fixing an error makes other errors start appearing. Try to figure out how to fix the new errors, and if you still can&#39;t figure it out, please <a href=\"http://stackoverflow.com/questions/ask\">ask a new question</a>."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 10, "last_activity_date": 1475430973, "creation_date": 1475430973, "answer_id": 39819932, "question_id": 39819874, "link": "https://stackoverflow.com/questions/39819874/type-usize-cannot-be-dereferenced/39819932#39819932", "title": "Type `usize` cannot be dereferenced", "body": "<p>I think you may be getting the operator precedence wrong.</p>\n\n<p><code>*temp.write(data).unwrap()</code> is equivalent to <code>*(temp.write(data).unwrap())</code>, not to <code>(*temp).write(data).unwrap()</code>. You could write the latter, but it's unnecessary, because the compiler will automatically dereference pointers in the subject of a method call (i.e. the <code>x</code> in <code>x.f(..)</code>). So you should just remove the <code>*</code> altogether here.</p>\n"}], "owner": {"reputation": 1600, "user_id": 771071, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/79354d20a5c400b2a8c31341fc7a3d39?s=128&d=identicon&r=PG", "display_name": "Joseph Callaars", "link": "https://stackoverflow.com/users/771071/joseph-callaars"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5826, "favorite_count": 0, "accepted_answer_id": 39819932, "answer_count": 2, "score": 3, "last_activity_date": 1475431355, "creation_date": 1475430560, "last_edit_date": 1475431355, "question_id": 39819874, "link": "https://stackoverflow.com/questions/39819874/type-usize-cannot-be-dereferenced", "title": "Type `usize` cannot be dereferenced", "body": "<p>I've got some code that looks somewhat like the following:</p>\n\n<pre><code>let incoming: Vec&lt;u8&gt; = Vec::new();\n\nmatch some_function(|data| {\n    let temp = &amp;mut incoming;\n    Ok(*temp.write(data).unwrap())\n}) {\n    Ok(v) =&gt; v,\n    Err(err) =&gt; return false,\n};\n</code></pre>\n\n<p>Now the error I'm getting is the following:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: type `usize` cannot be dereferenced\n   --&gt; src/stripe_connection.rs:127:16\n     |\n 127 |             Ok(*temp.write(data).unwrap())\n</code></pre>\n\n<p>For some reason I can't get my head around what I'm doing wrong, as the borrowing/lifecycle is still very new to me.</p>\n"}, {"tags": ["macros", "rust"], "answers": [{"comments": [{"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 1, "creation_date": 1475412599, "post_id": 39817053, "comment_id": 66924499, "body": "It&#39;s just a shorthand. Basically, I can&#39;t ask of you to download <code>string-cache</code> to solve this example, so this is MVP for this problem."}, {"owner": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "reply_to_user": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1475413114, "post_id": 39817053, "comment_id": 66924632, "body": "@DanielFath Ah! I guess I didn&#39;t understand your intention correctly... So you absolutely wanted compile-time matching..."}], "tags": [], "owner": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "is_accepted": false, "score": 0, "last_activity_date": 1475411672, "creation_date": 1475411672, "answer_id": 39817053, "question_id": 39816895, "link": "https://stackoverflow.com/questions/39816895/ordering-macro-argument-execution/39817053#39817053", "title": "Ordering macro argument execution", "body": "<p>Your definition of <code>string_intern!</code> is expecting a literal <code>\"d\"</code> and nothing else, but you are passing in these tokens: <code>stringify</code>, <code>!</code>, ... which why it fails. The definition of <code>string_intern!</code> that you want is probably:</p>\n\n<pre><code>macro_rules! string_intern {\n    ($e:expr) =&gt; {\n        match $e {\n            \"d\" =&gt; \"Found D\",\n            _ =&gt; \"Not found\",\n        }\n    }\n}\n</code></pre>\n\n<p>which can accept any expression that evaluates to a string type.</p>\n"}, {"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 9, "last_activity_date": 1475411908, "creation_date": 1475411908, "answer_id": 39817079, "question_id": 39816895, "link": "https://stackoverflow.com/questions/39816895/ordering-macro-argument-execution/39817079#39817079", "title": "Ordering macro argument execution", "body": "<p><code>println!</code> lets you do this because it uses <a href=\"https://doc.rust-lang.org/std/macro.format_args!.html\"><code>format_args!</code></a> under the covers, which is a compiler-provided \"intrinsic\" that forcibly evaluates its first argument <em>before</em> using it.  You cannot do this from a user-defined macro; you'd have to write a compiler plugin (which requires a nightly compiler and no guarantee of stability).</p>\n\n<p>So, yeah; you can't.  Sorry.  The only thing you can do is redefine the macro in such a way that you don't <em>need</em> an actual string literal, or change how you invoke it.</p>\n"}], "owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 154, "favorite_count": 0, "accepted_answer_id": 39817079, "answer_count": 2, "score": 4, "last_activity_date": 1475419953, "creation_date": 1475410532, "last_edit_date": 1475419953, "question_id": 39816895, "link": "https://stackoverflow.com/questions/39816895/ordering-macro-argument-execution", "title": "Ordering macro argument execution", "body": "<p>I'm using a library for string interning (<a href=\"https://github.com/servo/string-cache\" rel=\"nofollow\">string-cache</a>), that uses macros to efficient create elements (<code>atom!</code>). However for simplification here is a similar macro that demonstrates the problem</p>\n\n<pre><code>macro_rules! string_intern {\n   (\"d\") =&gt; (\"Found D\");\n}\n</code></pre>\n\n<p>say I need to call this macro from another macro and give it a string version of an identifier.</p>\n\n<pre><code>macro_rules! print_ident {\n    ($id:ident) =&gt; (\n        string_intern!(stringify!($id));\n    );\n}\n</code></pre>\n\n<p>However calling this macro</p>\n\n<pre><code>fn main() {\n    print_ident!(d);\n}\n</code></pre>\n\n<p>Fails with error:</p>\n\n<pre><code>error: no rules expected the token `stringify`\n --&gt; &lt;anon&gt;:7:24\n  |\n7 |         string_intern!(stringify!($id));\n  |                        ^^^^^^^^^\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?code=macro_rules!%20string_intern%20%7B%0A%20%20%20%20%28%22d%22%29%20%3D%3E%20%28%22Found%20D%22%29%3B%0A%7D%0A%0Amacro_rules!%20print_ident%20%7B%0A%20%20%20%20%28%24id%3Aident%29%20%3D%3E%20%28%0A%20%20%20%20%20%20%20%20string_intern!%28stringify!%28%24id%29%29%3B%0A%20%20%20%20%29%3B%0A%7D%0A%0Afn%20main%28%29%20%7B%0A%20%20%20%20let%20hello%20%3D%20%22%22%3B%0A%20%20%20%20print_ident!%28d%29%3B%0A%7D&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow\">Playground link</a></p>\n\n<p>I know <code>stringify!</code> correctly converts to identifier <code>d</code> to string <code>\"d\"</code>, because giving it to <code>println!</code> works as expected. Is there a way to pass the identifier I want turned into string to <code>string_intern</code>?</p>\n"}, {"tags": ["pattern-matching", "rust"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 4, "creation_date": 1475401957, "post_id": 39815635, "comment_id": 66922128, "body": "I can&#39;t think of a better way to do it. However, take a look at your type: <code>Left(3)</code> and <code>Right(-3)</code> would encode exactly the same information, right? So your type is somewhat redundant. Maybe you could just replace <code>Left</code> and <code>Right</code> with <code>Sideways(isize)</code>. Sure, it doesn&#39;t solve what you&#39;re asking for, but <i>I</i> think the type should be redesigned... Or am I wrong?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 1, "creation_date": 1475404117, "post_id": 39815635, "comment_id": 66922546, "body": "That&#39;s just a shortcoming of my simplified example. The real type is nom::Input."}], "answers": [{"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 2, "last_activity_date": 1475403586, "creation_date": 1475403586, "answer_id": 39815980, "question_id": 39815635, "link": "https://stackoverflow.com/questions/39815635/similar-but-distinct-match-clauses/39815980#39815980", "title": "Similar but distinct match clauses", "body": "<p>I would probably go with the suggestion made by Lukas, but I tried to devise something anyway. It might help you if you can't change the way <code>Foo</code> is built.</p>\n\n<p>I wouldn't say it is super-elegant, but an attempt was made:</p>\n\n<pre><code>use self::Foo::*;\n\n#[derive(Copy, Clone)]\nenum Foo {\n    Left(isize),\n    Right(isize),\n    Other,\n    //...\n}\n\nimpl From&lt;Foo&gt; for Option&lt;isize&gt; {\n    fn from(foo: Foo) -&gt; Option&lt;isize&gt; {\n        match foo {\n            Left(i) =&gt; Some(-i),\n            Right(i) =&gt; Some(i),\n            _ =&gt; None\n        }\n    }\n}\n\nfn main() {\n    let foo = Left(4);\n\n    if let Some(i) = &lt;Option&lt;isize&gt;&gt;::from(foo) {\n        move_sideways(i);\n    } else {\n        match foo {\n            Other =&gt; { },\n            _ =&gt; unreachable!()\n        }\n    };\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 2107, "user_id": 5864190, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c27e1fa0fec82b12af3e1020ed1780c4?s=128&d=identicon&r=PG&f=1", "display_name": "dth", "link": "https://stackoverflow.com/users/5864190/dth"}, "is_accepted": false, "score": 1, "last_activity_date": 1475409422, "creation_date": 1475409422, "answer_id": 39816753, "question_id": 39815635, "link": "https://stackoverflow.com/questions/39815635/similar-but-distinct-match-clauses/39816753#39816753", "title": "Similar but distinct match clauses", "body": "<p>The first idea that comes to mind is to wrap your <code>enum</code> into <code>Option</code> instead of using the <code>Other</code> constructor:</p>\n\n<pre><code>enum Foo {\n    Left(isize),\n    Right(isize)\n}\n\nlet foo = Some(Left(1));\nlet x = match foo {\n    Some(y) =&gt; {\n        let i2 = match y {\n            Left(i) =&gt; -i,\n            Right(i) =&gt; i\n        };\n        do_something(i2)\n    },\n    None =&gt; 0\n};\n</code></pre>\n\n<p>If you do not want to do that, you could chain two <code>match</code>-expressions and use the first to handle the preprocessing of <code>Left</code> and <code>Right</code>:</p>\n\n<pre><code>let bar = Right(2);\nlet z = match match bar {\n    Left(i) =&gt; Some(-i),\n    Right(i) =&gt; Some(i),\n    Other =&gt; None \n} {\n    Some(i) =&gt; do_something(i),\n    None =&gt; 0\n};\n</code></pre>\n\n<p>If that does not help either because your case is even more complicated, I would just use one <code>match</code>-expression with separate cases for <code>Left</code>, <code>Right</code> and <code>Other</code> and move the common code into a function.</p>\n"}, {"comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1475774623, "post_id": 39816938, "comment_id": 67089644, "body": "I couldn&#39;t decide between the answers; picking this one because I&#39;d forgotten about the @ syntax!"}], "tags": [], "owner": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "is_accepted": true, "score": 2, "last_activity_date": 1475411157, "last_edit_date": 1475411157, "creation_date": 1475410851, "answer_id": 39816938, "question_id": 39815635, "link": "https://stackoverflow.com/questions/39815635/similar-but-distinct-match-clauses/39816938#39816938", "title": "Similar but distinct match clauses", "body": "<p>It's not possible to avoid duplicating the rule without having to modify the data structure. But if you want to avoid making <code>Foo</code> be a <code>Copy</code> type (leaving all else as is), here's a slight modification:</p>\n\n<pre><code>let foo = Left(34);\nmatch foo {\n    foo2 @ Left(_) | foo2 @ Right(_) =&gt; {\n        let i = match foo2 {\n            Left(i) =&gt; -i,\n            Right(i) =&gt; i,\n            _ =&gt; unreachable!(),\n        };\n        // ... non-trivial code\n    }\n    Other =&gt; (),\n}\n</code></pre>\n\n<p>The value in <code>foo</code> will move to <code>foo2</code>.</p>\n\n<p>(Perhaps it looks cleaner to use shadowing -- <code>foo</code> instead of <code>foo2</code>...)</p>\n"}], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 110, "favorite_count": 0, "accepted_answer_id": 39816938, "answer_count": 3, "score": 3, "last_activity_date": 1475411157, "creation_date": 1475400614, "last_edit_date": 1475408979, "question_id": 39815635, "link": "https://stackoverflow.com/questions/39815635/similar-but-distinct-match-clauses", "title": "Similar but distinct match clauses", "body": "<p>Let's say I have an <code>enum</code> with a few variants:</p>\n\n<pre><code>#[derive(Copy,Clone)]\nenum Foo {\n    Left(isize),\n    Right(isize),\n    Other,\n    //...\n}\n</code></pre>\n\n<p>And I want to pattern match on this, with very similar but not identical treatment of <code>Left</code> and <code>Right</code>.</p>\n\n<p>I've ended up with:</p>\n\n<pre><code>match foo {\n     Left(i) | Right(i) =&gt; {\n          let i2 = match foo {\n               Left(_) =&gt; -i,\n               Right(_) =&gt; i,\n               _  =&gt; unreachable!(),\n          };\n          move_sideways(i2);\n          // non-trivial code, ie not a simple function call\n     },\n     Other =&gt; { ... }\n}\n</code></pre>\n\n<p>Which isn't very satisfactory, and relies on not consuming <code>foo</code> the first time.  Is there a good idiom I'm missing to avoid re-matching or duplicating the rule?</p>\n"}, {"tags": ["rust", "traits"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 6, "last_activity_date": 1475372666, "last_edit_date": 1475372666, "creation_date": 1475372019, "answer_id": 39813052, "question_id": 39812947, "link": "https://stackoverflow.com/questions/39812947/calling-specific-trait-implementation-on-a-non-generic-struct/39813052#39813052", "title": "Calling specific trait implementation on a non-generic struct", "body": "<p>You have several options.</p>\n\n<ol>\n<li><p>You can specify on which specific trait you want to invoke the <code>attach</code> method.</p>\n\n<pre><code>fn main() {\n    let mut cpu = Cpu::new(SimpleMemory, NoOpDebugger);\n    Debugger::&lt;SimpleMemory&gt;::attach(&amp;mut cpu.debugger);\n}\n</code></pre>\n\n<p>or</p>\n\n<pre><code>fn main() {\n    let mut cpu = Cpu::new(SimpleMemory, NoOpDebugger);\n    &lt;NoOpDebugger as Debugger&lt;SimpleMemory&gt;&gt;::attach(&amp;mut cpu.debugger);\n}\n</code></pre></li>\n<li><p>You can move the <code>attach</code> method to a supertrait that is not generic.</p>\n\n<pre><code>trait DebuggerBase {\n    fn attach(&amp;mut self) {}\n}\n\ntrait Debugger&lt;M: Memory&gt;: DebuggerBase {\n    fn step(mem: &amp;M) {}\n}\n\nimpl DebuggerBase for NoOpDebugger {}\nimpl&lt;M: Memory&gt; Debugger&lt;M&gt; for NoOpDebugger {}\n</code></pre></li>\n<li><p>You can add a <a href=\"https://doc.rust-lang.org/stable/std/marker/struct.PhantomData.html\" rel=\"nofollow\"><code>PhantomData</code></a> member to <code>NoOpDebugger</code> and make <code>NoOpDebugger</code> itself generic, so that each <code>NoOpDebugger&lt;M&gt;</code> only implements <code>Debugger&lt;M&gt;</code> for the same <code>M</code>. In your example, the <code>M</code> for <code>NoOpDebugger</code> will be inferred from the call to <code>Cpu::new</code>.</p>\n\n<pre><code>use std::marker::PhantomData;\n\nstruct NoOpDebugger&lt;M&gt;(PhantomData&lt;M&gt;);\n\nimpl&lt;M: Memory&gt; Debugger&lt;M&gt; for NoOpDebugger&lt;M&gt; {}\n\nfn main() {\n    let mut cpu = Cpu::new(SimpleMemory, NoOpDebugger(PhantomData));\n    cpu.debugger.attach();\n}\n</code></pre></li>\n<li><p>If the implementations of <code>Debugger</code> don't depend on <code>M</code>, and if you don't use <code>Debugger</code> as a trait object, then you can move the type parameter to the methods that need it and omit it on the methods that don't need it.</p>\n\n<pre><code>trait Debugger {\n    fn attach(&amp;mut self) {}\n    fn step&lt;M: Memory&gt;(mem: &amp;M) {}\n}\n</code></pre></li>\n</ol>\n"}], "owner": {"reputation": 13635, "user_id": 547365, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/ddefbca930fdd39846b698bab7ac3146?s=128&d=identicon&r=PG", "display_name": "w.brian", "link": "https://stackoverflow.com/users/547365/w-brian"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 715, "favorite_count": 0, "accepted_answer_id": 39813052, "answer_count": 1, "score": 5, "last_activity_date": 1475418147, "creation_date": 1475370596, "last_edit_date": 1475418147, "question_id": 39812947, "link": "https://stackoverflow.com/questions/39812947/calling-specific-trait-implementation-on-a-non-generic-struct", "title": "Calling specific trait implementation on a non-generic struct", "body": "<p>I have a non-generic struct that implements a generic trait.  When I call a function on the struct, I get the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0282]: unable to infer enough type information about `_`\n  --&gt; src/main.rs:35:18\n   |\n35 |     cpu.debugger.attach();\n   |                  ^^^^^^ cannot infer type for `_`\n   |\n   = note: type annotations or generic parameter binding required\n</code></pre>\n\n<p>I've tried adding type annotations and generic parameter bindings, but I'm obviously doing something wrong; I still can't get it to compile.  I have similar code elsewhere with a generic struct that works, presumably because the generic-bounds shared by the struct and trait impl allow the compiler to infer the actual method implementation to call.</p>\n\n<p>The best way to illustrate the issue is with a reduced example:</p>\n\n<pre><code>struct Cpu&lt;M: Memory, D: Debugger&lt;M&gt;&gt; {\n    mem: M,\n    debugger: D,\n}\n\nimpl&lt;M: Memory, D: Debugger&lt;M&gt;&gt; Cpu&lt;M, D&gt; {\n    fn new(mem: M, debugger: D) -&gt; Self {\n        Cpu {\n            mem: mem,\n            debugger: debugger,\n        }\n    }\n}\n\ntrait Memory {}\n\nstruct SimpleMemory;\n\nimpl Memory for SimpleMemory {}\n\ntrait Debugger&lt;M: Memory&gt; {\n    fn attach(&amp;mut self) {}\n    fn step(mem: &amp;M) {}\n}\n\nstruct NoOpDebugger;\n\nimpl&lt;M: Memory&gt; Debugger&lt;M&gt; for NoOpDebugger {}\n\nfn main() {\n    let mut cpu = Cpu::new(SimpleMemory, NoOpDebugger);\n    cpu.debugger.attach(); // &lt;-- cannot infer type for `_`\n}\n</code></pre>\n\n<p>Please excuse the poor title, but it's the best way I know how to describe the problem.  </p>\n"}, {"tags": ["coding-style", "rust"], "answers": [{"tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": false, "score": 4, "last_activity_date": 1526317093, "last_edit_date": 1526317093, "creation_date": 1475320943, "answer_id": 39805991, "question_id": 39805834, "link": "https://stackoverflow.com/questions/39805834/what-is-the-idiomatic-way-to-handle-unwrap-nested-result-types/39805991#39805991", "title": "What is the idiomatic way to handle/unwrap nested Result types?", "body": "<p><a href=\"https://doc.rust-lang.org/std/result/enum.Result.html#methods\" rel=\"nofollow noreferrer\"><code>Result</code> happens to have a lot of convenience methods</a> for these kinds of things:</p>\n\n<pre><code>use std::fs;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new(\".\");\n    match fs::read_dir(&amp;path) {\n        Ok(entries) =&gt; {\n            for entry in entries {\n                match entry.and_then(|e| e.metadata()).map(|m| m.accessed()) {\n                    Ok(time) =&gt; {\n                        println!(\"{:?}\", time);\n                    },\n                    Err(_) =&gt; panic!(\"will be handled\")\n                }\n            }\n        },\n        Err(_) =&gt; panic!(\"will be handled\")\n    }\n}\n</code></pre>\n\n<p>And usually you will not have so much logic in <code>main</code> and will simply be able to use <code>?</code> or <a href=\"https://doc.rust-lang.org/std/macro.try!.html\" rel=\"nofollow noreferrer\"><code>try!</code></a> in another function:</p>\n\n<pre><code>use std::fs;\nuse std::path::Path;\n\nfn print_filetimes(path: &amp;Path) -&gt; Result&lt;(), std::io::Error&gt; {\n    for entry in fs::read_dir(&amp;path)? {\n        let time = entry.and_then(|e| e.metadata()).map(|m| m.accessed())?;\n        println!(\"{:?}\", time);\n    }\n\n    Ok(())\n}\n\nfn main() {\n    let path = Path::new(\".\");\n    match print_filetimes(path) {\n        Ok(()) =&gt; (),\n        Err(_) =&gt; panic!(\"will be handled\"),\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 2, "creation_date": 1475322095, "post_id": 39806123, "comment_id": 66903760, "body": "Another good source is the <a href=\"http://blog.burntsushi.net/rust-error-handling/\" rel=\"nofollow noreferrer\">&quot;Error Handling in Rust&quot;</a> article by BurntSushi."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 1, "creation_date": 1475330558, "post_id": 39806123, "comment_id": 66906317, "body": "<code>and_then(|_| { foo; Ok(()) });</code> could just be <code>map(|_| { foo; });</code>."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1475331252, "post_id": 39806123, "comment_id": 66906541, "body": "@mcarton thanks! I simplified the code to avoid that issue."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 12, "last_activity_date": 1526317500, "last_edit_date": 1526317500, "creation_date": 1475321735, "answer_id": 39806123, "question_id": 39805834, "link": "https://stackoverflow.com/questions/39805834/what-is-the-idiomatic-way-to-handle-unwrap-nested-result-types/39806123#39806123", "title": "What is the idiomatic way to handle/unwrap nested Result types?", "body": "<blockquote>\n  <p>I read that using <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap\" rel=\"nofollow noreferrer\"><code>unwrap</code></a> on a Result is not a good practice in Rust.</p>\n</blockquote>\n\n<p>It's not that easy. For example, read <a href=\"https://stackoverflow.com/questions/39477684/should-i-avoid-unwrap-in-production-application/39478185#39478185\">my answer here</a> to learn a bit more. Now to your main problem:</p>\n\n<hr>\n\n<h3>Reduce right shift by passing <code>Ok</code> value to the outside</h3>\n\n<p>One big issue with your code is the right shift: for example, the <code>meta.accessed()</code> call is indented a whole lot. We can avoid this by passing the value we want to work with out of the <code>match</code>:</p>\n\n<pre><code>let entries = match fs::read_dir(&amp;path) {\n    Ok(entries) =&gt; entries, // \"return\" from match\n    Err(_) =&gt; panic!(\"will be handled\"),\n};\n\nfor entry in entries {  // no indentation! :)\n    // ...\n}\n</code></pre>\n\n<p>That's already a very good way to make the code more readable.</p>\n\n<h3>Using the <code>?</code> operator to pass the error to the calling function</h3>\n\n<p>Your function could return a <code>Result&lt;_, _&gt;</code> type in order to pass the error to the calling function (yes, <a href=\"https://doc.rust-lang.org/stable/std/process/trait.Termination.html\" rel=\"nofollow noreferrer\">even <code>main()</code> can return <code>Result</code></a>). In this case you can use the <code>?</code> operator:</p>\n\n<pre><code>use std::{fs, io};\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    for entry in fs::read_dir(\".\")? {\n        println!(\"{:?}\", entry?.metadata()?.accessed()?);\n    }\n    Ok(())\n}\n</code></pre>\n\n<h3>Use helper methods of <code>Result</code></h3>\n\n<p>There are also many helper methods, like <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html#method.map\" rel=\"nofollow noreferrer\"><code>map()</code></a> or <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then\" rel=\"nofollow noreferrer\"><code>and_then()</code></a>, for the <code>Result</code> type. <code>and_then</code> is helpful if you want to do something, if the result is <code>Ok</code> and this something will return a result of the same type. Here is your code with <code>and_then()</code> and manual handling of the error:</p>\n\n<pre><code>fn main() {\n    let path = Path::new(\".\");\n    let result = fs::read_dir(&amp;path).and_then(|entries| {\n        for entry in entries {\n            let time = entry?.metadata()?.accessed()?;\n            println!(\"{:?}\", time);\n        }\n        Ok(())\n    });\n\n    if let Err(e) = result {\n        panic!(\"will be handled\");\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>There really isn't only <em>one</em> way to do this kind of error handling. You have to get to know all the tools you can use and then need to choose the best for your situation. However, in most situations, the <code>?</code> operator is the right tool.</p>\n"}], "owner": {"reputation": 3567, "user_id": 4019871, "user_type": "registered", "accept_rate": 65, "profile_image": "https://www.gravatar.com/avatar/7db9ac6bdc0a996dd01da64b3660f8b6?s=128&d=identicon&r=PG&f=1", "display_name": "Mas Bagol", "link": "https://stackoverflow.com/users/4019871/mas-bagol"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2489, "favorite_count": 2, "accepted_answer_id": 39806123, "answer_count": 2, "score": 6, "last_activity_date": 1526317500, "creation_date": 1475319972, "last_edit_date": 1526317203, "question_id": 39805834, "link": "https://stackoverflow.com/questions/39805834/what-is-the-idiomatic-way-to-handle-unwrap-nested-result-types", "title": "What is the idiomatic way to handle/unwrap nested Result types?", "body": "<p>I read that using <code>unwrap</code> on a <code>Result</code> is not a good practice in Rust and that it's better to use pattern matching so any error that occurred can be handled appropriately. </p>\n\n<p>I get the point, but consider this snippet that reads a directory and prints the accessed time for each entry:</p>\n\n<pre><code>use std::fs;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new(\".\");\n    match fs::read_dir(&amp;path) {\n        Ok(entries) =&gt; {\n            for entry in entries {\n                match entry {\n                    Ok(ent) =&gt; {\n                        match ent.metadata() {\n                            Ok(meta) =&gt; {\n                                match meta.accessed() {\n                                    Ok(time) =&gt; {\n                                        println!(\"{:?}\", time);\n                                    },\n                                    Err(_) =&gt; panic!(\"will be handled\")\n                                }\n                            },\n                            Err(_) =&gt; panic!(\"will be handled\")\n                        }\n                    },\n                    Err(_) =&gt; panic!(\"will be handled\")\n                }\n            }\n        },\n        Err(_) =&gt; panic!(\"will be handled\")\n    }\n}\n</code></pre>\n\n<p>I want to handle every possible error in the code above (the <code>panic</code> macro is just a placeholder). While the code above works, I think it's ugly. What is the idiomatic way to handle a case like this?</p>\n"}, {"tags": ["vector", "rust", "hashset"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1475315567, "post_id": 39803237, "comment_id": 66902021, "body": "FYI: in your first code, you don&#39;t need to clone the vector, you just need to declare it as mutable. Either by <code>let mut victim = vec;</code> or in the argument list by: <code>fn vec_to_set(mut vec: Vec&lt;u8&gt;)</code>."}, {"owner": {"reputation": 9895, "user_id": 452775, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/88963e7cc58eabf150447e7b78a24793?s=128&d=identicon&r=PG", "display_name": "Lii", "link": "https://stackoverflow.com/users/452775/lii"}, "edited": false, "score": 5, "creation_date": 1475316332, "post_id": 39803237, "comment_id": 66902235, "body": "You&#39;re not using the <i>O</i> notation correctly. <i>O(n) = O(2n) = O(3n) = O(c*n)</i>. The point is that constants don&#39;t matter. I think that it is clear what you mean but you should probably say just &quot;<i>2n</i> memory&quot; or something instead."}, {"owner": {"reputation": 13756, "user_id": 567762, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/908c9abc72ab86111a153b11cb584f26?s=128&d=identicon&r=PG", "display_name": "Jared Beck", "link": "https://stackoverflow.com/users/567762/jared-beck"}, "edited": false, "score": 0, "creation_date": 1475459417, "post_id": 39803237, "comment_id": 66937351, "body": "Thanks Lii, if <code>O(n) == O(2n)</code> then what is the right way to express that something takes twice as long? It seems useful to be able to compare <code>n</code> and <code>2n</code>. Thanks."}], "answers": [{"tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 29, "last_activity_date": 1525103170, "last_edit_date": 1525103170, "creation_date": 1475300626, "answer_id": 39803426, "question_id": 39803237, "link": "https://stackoverflow.com/questions/39803237/build-hashset-from-a-vector-in-rust/39803426#39803426", "title": "Build HashSet from a vector in Rust", "body": "<p>The following should work nicely; it fulfills your requirements:</p>\n\n<pre><code>use std::collections::HashSet;\nuse std::iter::FromIterator;\n\nfn vec_to_set(vec: Vec&lt;u8&gt;) -&gt; HashSet&lt;u8&gt; {\n    HashSet::from_iter(vec)\n}\n</code></pre>\n\n<p><code>from_iter()</code> works on types implementing <a href=\"https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\" rel=\"noreferrer\"><code>IntoIterator</code></a>, so a <code>Vec</code> argument is sufficient.</p>\n\n<p>Additional remarks:</p>\n\n<ul>\n<li><p>you don't need to explicitly <code>return</code> function results; you only need to omit the semi-colon in the last expression in its body</p></li>\n<li><p>I'm not sure which version of Rust you are using, but on current stable (1.12) <code>to_iter()</code> doesn't exist</p></li>\n</ul>\n"}, {"comments": [{"owner": {"reputation": 29866, "user_id": 930450, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/se3CE.png?s=128&g=1", "display_name": "Ixx", "link": "https://stackoverflow.com/users/930450/ixx"}, "edited": false, "score": 0, "creation_date": 1589970238, "post_id": 39804262, "comment_id": 109501637, "body": "This doesn&#39;t compile anymore."}, {"owner": {"reputation": 486, "user_id": 10056727, "user_type": "registered", "profile_image": "https://lh5.googleusercontent.com/-CW6xO6R7Xt0/AAAAAAAAAAI/AAAAAAAAAEg/7sIN5LyyW_M/photo.jpg?sz=128", "display_name": "Niki", "link": "https://stackoverflow.com/users/10056727/niki"}, "edited": false, "score": 0, "creation_date": 1608261702, "post_id": 39804262, "comment_id": 115535628, "body": "works just fine for me"}], "tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": true, "score": 46, "last_activity_date": 1569401592, "last_edit_date": 1569401592, "creation_date": 1475308339, "answer_id": 39804262, "question_id": 39803237, "link": "https://stackoverflow.com/questions/39803237/build-hashset-from-a-vector-in-rust/39804262#39804262", "title": "Build HashSet from a vector in Rust", "body": "<p>Because the operation does not need to consume the vector\u00b9, I think it <em>should not</em> consume it. That only leads to extra copying somewhere else in the program:</p>\n\n<pre><code>use std::collections::HashSet;\nuse std::iter::FromIterator;\n\nfn hashset(data: &amp;[u8]) -&gt; HashSet&lt;u8&gt; {\n    HashSet::from_iter(data.iter().cloned())\n}\n</code></pre>\n\n<p>Call it like <code>hashset(&amp;v)</code> where <code>v</code> is a <code>Vec&lt;u8&gt;</code> or other thing that coerces to a slice.</p>\n\n<p>There are of course more ways to write this, to be generic and all that, but this answer sticks to just introducing the thing I wanted to focus on.</p>\n\n<p>\u00b9This is based on that the element type <code>u8</code> is <code>Copy</code>, i.e. it does not have ownership semantics.</p>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1554123148, "post_id": 55447994, "comment_id": 97624411, "body": "<code>collect</code> uses <code>FromIterator</code> \u2014 this is the same as the above two answers except more verbose."}, {"owner": {"reputation": 19712, "user_id": 418400, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/eca5ce283c385cc58d40708f6a97194b?s=128&d=identicon&r=PG&f=1", "display_name": "Ben", "link": "https://stackoverflow.com/users/418400/ben"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1554135315, "post_id": 55447994, "comment_id": 97631686, "body": "fixed type error. This code does not require repeating HashSet in the conversion code"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1554136362, "post_id": 55447994, "comment_id": 97632151, "body": "There&#39;s no repeating of <code>HashSet</code> in the original answers either. Their code: <code>let hash_set = HashSet::&lt;_&gt;::from_iter(vec);</code> vs yours: <code>let hash_set: HashSet&lt;usize&gt; = vec.into_iter().collect()</code>"}, {"owner": {"reputation": 19712, "user_id": 418400, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/eca5ce283c385cc58d40708f6a97194b?s=128&d=identicon&r=PG&f=1", "display_name": "Ben", "link": "https://stackoverflow.com/users/418400/ben"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1554224757, "post_id": 55447994, "comment_id": 97670222, "body": "You removed the type in your first example to hide the repeat of HashSet code 1: <code>let hash_set: HashSet&lt;usize&gt; = HashSet::&lt;_&gt;::from_iter(vec);</code> code 2: <code>let hash_set: HashSet&lt;usize&gt; = vec.into_iter().collect()</code>   Example restored"}], "tags": [], "owner": {"reputation": 19712, "user_id": 418400, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/eca5ce283c385cc58d40708f6a97194b?s=128&d=identicon&r=PG&f=1", "display_name": "Ben", "link": "https://stackoverflow.com/users/418400/ben"}, "is_accepted": false, "score": 14, "last_activity_date": 1554135239, "last_edit_date": 1554135239, "creation_date": 1554091775, "answer_id": 55447994, "question_id": 39803237, "link": "https://stackoverflow.com/questions/39803237/build-hashset-from-a-vector-in-rust/55447994#55447994", "title": "Build HashSet from a vector in Rust", "body": "<p>Moving data ownership</p>\n\n<pre><code>let vec: Vec&lt;usize&gt; = vec![1, 2, 3, 4];\nlet hash_set: HashSet&lt;usize&gt; = vec.into_iter().collect();\n</code></pre>\n\n<p>Cloning data</p>\n\n<pre><code>let vec: Vec&lt;usize&gt; = vec![1, 2, 3, 4];\nlet hash_set: HashSet&lt;usize&gt; = vec.iter().cloned().collect();\n</code></pre>\n"}], "owner": {"reputation": 13756, "user_id": 567762, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/908c9abc72ab86111a153b11cb584f26?s=128&d=identicon&r=PG", "display_name": "Jared Beck", "link": "https://stackoverflow.com/users/567762/jared-beck"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 17163, "favorite_count": 4, "accepted_answer_id": 39804262, "answer_count": 3, "score": 47, "last_activity_date": 1569401592, "creation_date": 1475298526, "last_edit_date": 1475460152, "question_id": 39803237, "link": "https://stackoverflow.com/questions/39803237/build-hashset-from-a-vector-in-rust", "title": "Build HashSet from a vector in Rust", "body": "<p>I want to build a <code>HashSet&lt;u8&gt;</code> from a <code>Vec&lt;u8&gt;</code>. I'd like to do this</p>\n\n<ol>\n<li>in one line of code,</li>\n<li>copying the data only once,</li>\n<li>using only <code>2n</code> memory, </li>\n</ol>\n\n<p>but the only thing I can get to compile is this piece of .. junk, which I think copies the data twice and uses <code>3n</code> memory.</p>\n\n<pre><code>fn vec_to_set(vec: Vec&lt;u8&gt;) -&gt; HashSet&lt;u8&gt; {\n    let mut victim = vec.clone();\n    let x: HashSet&lt;u8&gt; = victim.drain(..).collect();\n    return x;\n}\n</code></pre>\n\n<p>I was hoping to write something simple, like this:</p>\n\n<pre><code>fn vec_to_set(vec: Vec&lt;u8&gt;) -&gt; HashSet&lt;u8&gt; {\n    return HashSet::from_iter(vec.iter());\n}\n</code></pre>\n\n<p>but that won't compile:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; &lt;anon&gt;:5:12\n  |\n5 |     return HashSet::from_iter(vec.iter());\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected u8, found &amp;u8\n  |\n  = note: expected type `std::collections::HashSet&lt;u8&gt;`\n  = note:    found type `std::collections::HashSet&lt;&amp;u8, _&gt;`\n</code></pre>\n\n<p>.. and I don't really understand the error message, probably because I need to RTFM.</p>\n"}, {"tags": ["rust", "closures"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1475300263, "post_id": 39803231, "comment_id": 66898587, "body": "What is <code>I</code>? This doesn&#39;t compile. If <code>F</code> didn&#39;t return anything, though, why not just <code>#[derive(Clone)]</code>?"}, {"owner": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1475301094, "post_id": 39803231, "comment_id": 66898735, "body": "@ljedrz Ah! Sorry, fixed it... Please take a look at the playpen link that I added now."}], "answers": [{"comments": [{"owner": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "edited": false, "score": 0, "creation_date": 1475301995, "post_id": 39803512, "comment_id": 66898926, "body": "Thanks! Now that I think about it, I won&#39;t need to capture variables in the closure, though it would have been nicer (more readable) to use closures. Any idea why <code>Clone</code> is not implemented for closures in the compiler?"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "edited": false, "score": 1, "creation_date": 1475302162, "post_id": 39803512, "comment_id": 66898959, "body": "@John I believe that part of the issue is that, in order to implement <code>Clone</code>, the compiler has to know what <code>Clone</code> is.  Historically, it hasn&#39;t.  In addition, what about other traits?  Should a closure also be <code>Copy</code>?  <code>Eq</code>?  Where do you draw the line?  I don&#39;t think anyone is really sure what, <i>exactly</i>, should be done here."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 2, "creation_date": 1475310473, "post_id": 39803512, "comment_id": 66900748, "body": "<code>fn(usize) -&gt; f64</code> (a &quot;fn type&quot;) is not zero-sized, it&#39;s the equivalent of a function pointer. <code>fn(usize) -&gt; f64 {::some::specific::function}</code> (a &quot;fn item type&quot;) is zero-sized but you can&#39;t write out that type, so the only way you can make use of that is by accepting a generic type <code>F: Fn(u64) -&gt; f64 + Copy</code> (i.e., just add a <code>Copy</code> bound to the code in the question)."}, {"owner": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "edited": false, "score": 0, "creation_date": 1475314538, "post_id": 39803512, "comment_id": 66901744, "body": "@delnan Does that by any chance imply that &quot;fn types&quot; cannot be inlined, but taking an &quot;fn&quot; as <code>F: Fn(..) -&gt; .. + Copy</code> could make inlining possible?"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "edited": false, "score": 1, "creation_date": 1475319529, "post_id": 39803512, "comment_id": 66903073, "body": "@John In principle, if you have a <i>constant</i> function pointer somewhere, the compiler can optimize based on the value of that constant (as with any other value). But in practice, you&#39;ll probably pass in different function pointers from different call sites, so most callbacks specified via <code>fn</code> are indeed unlikely to be inlined."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1475321698, "post_id": 39803512, "comment_id": 66903670, "body": "@delnan Sorry, I meant the size of the captured environment (they don&#39;t have one).  I&#39;ve adjusted the answer."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 3, "last_activity_date": 1475321658, "last_edit_date": 1475321658, "creation_date": 1475301478, "answer_id": 39803512, "question_id": 39803231, "link": "https://stackoverflow.com/questions/39803231/how-do-i-clone-a-closure-so-that-their-types-are-the-same/39803512#39803512", "title": "How do I clone a closure, so that their types are the same?", "body": "<p>You can't <code>Clone</code> closures.  The only one in a position to implement <code>Clone</code> for a closure is the compiler... and it <em>doesn't</em>.  So, you're <em>kinda</em> stuck.</p>\n\n<p>There is <em>one</em> way around this, though: if you have a closure with <em>no</em> captured variables, you can force a copy via <code>unsafe</code> code.  That said, a simpler approach at <em>that</em> point is to accept a <code>fn(usize) -&gt; f64</code> <em>instead</em>, since they don't have a captured environment (any zero-sized closure can be rewritten as a function), and are <code>Copy</code>.</p>\n"}, {"comments": [{"owner": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "edited": false, "score": 0, "creation_date": 1475314204, "post_id": 39804317, "comment_id": 66901654, "body": "Yes, even though this is a valid option, I wanted to avoid dynamic dispatch. I&#39;m writing a simulator, so I want to give the compiler every possibility of inlining the closures..."}, {"owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "reply_to_user": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "edited": false, "score": 0, "creation_date": 1475316569, "post_id": 39804317, "comment_id": 66902313, "body": "I think that in this case, an inlining is impossible. Although the normal function call (as suggested by @DK.) cheaper than a call of trait object"}], "tags": [], "owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "is_accepted": false, "score": 0, "last_activity_date": 1475308839, "creation_date": 1475308839, "answer_id": 39804317, "question_id": 39803231, "link": "https://stackoverflow.com/questions/39803231/how-do-i-clone-a-closure-so-that-their-types-are-the-same/39804317#39804317", "title": "How do I clone a closure, so that their types are the same?", "body": "<p>You can use <a href=\"https://doc.rust-lang.org/book/trait-objects.html\" rel=\"nofollow\">trait objects</a> to be able to implement <code>\u0421lone</code> for your struct:</p>\n\n<pre><code>use std::rc::Rc;\n\n#[derive(Clone)]\npub struct MyStructRef&lt;'f&gt;  {\n    field: usize,\n    mapper: &amp;'f Fn(usize) -&gt; f64,\n}\n\n\n#[derive(Clone)]\npub struct MyStructRc  {\n    field: usize,\n    mapper: Rc&lt;Fn(usize) -&gt; f64&gt;,\n}\n\nfn main() {\n    //ref\n    let closure = |x| x as f64;\n    let f = MyStructRef { field: 34, mapper: &amp;closure };\n    let g = f.clone();\n    println!(\"{}\", (f.mapper)(3));\n    println!(\"{}\", (g.mapper)(3));\n\n    //Rc\n    let rcf = MyStructRc { field: 34, mapper: Rc::new(|x| x as f64 * 2.0) };\n    let rcg = rcf.clone();\n    println!(\"{}\", (rcf.mapper)(3));\n    println!(\"{}\", (rcg.mapper)(3));    \n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "edited": false, "score": 0, "creation_date": 1475353160, "post_id": 39810531, "comment_id": 66913518, "body": "Apart from the reference counting part, is this as good as a &quot;raw&quot; closure? Would the function body get inlined? (I assume it gets inlined in &quot;raw&quot; closures, though I&#39;m not sure about the necessary conditions for that.)"}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "reply_to_user": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "edited": false, "score": 0, "creation_date": 1475368851, "post_id": 39810531, "comment_id": 66916747, "body": "It&#39;s behind a pointer, so there&#39;s that indirection (but that&#39;s all). I guess it can be inlined fine, but you should verify."}], "tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": false, "score": 3, "last_activity_date": 1475349182, "creation_date": 1475349182, "answer_id": 39810531, "question_id": 39803231, "link": "https://stackoverflow.com/questions/39803231/how-do-i-clone-a-closure-so-that-their-types-are-the-same/39810531#39810531", "title": "How do I clone a closure, so that their types are the same?", "body": "<p>You can use <code>Rc</code> (or <code>Arc</code>!) to get multiple handles of the same unclonable value. Works well with <code>Fn</code> (callable through shared references) closures.</p>\n\n<pre><code>pub struct MyStruct&lt;F&gt; where F: Fn(usize) -&gt; f64 {\n    field: usize,\n    mapper: Rc&lt;F&gt;,\n    // fields omitted\n}\n\nimpl&lt;F&gt; Clone for MyStruct&lt;F&gt;\n    where F: Fn(usize) -&gt; f64,\n{\n    fn clone(&amp;self) -&gt; Self {\n        MyStruct {\n            field: self.field,\n            mapper: self.mapper.clone(),\n           ...\n        }\n    }\n}\n</code></pre>\n\n<p>Remember that <code>#[derive(Clone)]</code> is a very useful recipe for Clone, but its recipe doesn't always do the right thing for the situation; this is one such case.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1528116821, "last_edit_date": 1528116821, "creation_date": 1521928623, "answer_id": 49470366, "question_id": 39803231, "link": "https://stackoverflow.com/questions/39803231/how-do-i-clone-a-closure-so-that-their-types-are-the-same/49470366#49470366", "title": "How do I clone a closure, so that their types are the same?", "body": "<p>As of Rust 1.26.0, closures implement both <code>Copy</code> and <code>Clone</code> if all of the captured variables do:</p>\n\n<pre><code>#[derive(Clone)]\npub struct MyStruct&lt;F&gt;\nwhere\n    F: Fn(usize) -&gt; f64,\n{\n    field: usize,\n    mapper: F,\n}\n\nfn main() {\n    let f = MyStruct {\n        field: 34,\n        mapper: |x| x as f64,\n    };\n    let g = f.clone();\n    println!(\"{}\", (g.mapper)(3));\n}\n</code></pre>\n"}], "owner": {"reputation": 1457, "user_id": 2849934, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/3ff0a46f18c8d548fa91c12b922290b6?s=128&d=identicon&r=PG", "display_name": "John", "link": "https://stackoverflow.com/users/2849934/john"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 485, "favorite_count": 0, "accepted_answer_id": 49470366, "answer_count": 4, "score": 3, "last_activity_date": 1562425156, "creation_date": 1475298474, "last_edit_date": 1562425156, "question_id": 39803231, "link": "https://stackoverflow.com/questions/39803231/how-do-i-clone-a-closure-so-that-their-types-are-the-same", "title": "How do I clone a closure, so that their types are the same?", "body": "<p>I have a struct which looks something like this:</p>\n\n<pre><code>pub struct MyStruct&lt;F&gt;\nwhere\n    F: Fn(usize) -&gt; f64,\n{\n    field: usize,\n    mapper: F,\n    // fields omitted\n}\n</code></pre>\n\n<p>How do I implement <code>Clone</code> for this struct?</p>\n\n<p>One way I found to copy the function body is:</p>\n\n<pre><code>let mapper = |x| (mystruct.mapper)(x);\n</code></pre>\n\n<p>But this results in <code>mapper</code> having a different type than that of <code>mystruct.mapper</code>.</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=fdf8bec546f6e13f4e517d07e86d423b&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">playground</a></p>\n"}, {"tags": ["vector", "rust"], "answers": [{"comments": [{"owner": {"reputation": 444, "user_id": 1497593, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/r8bS2.jpg?s=128&g=1", "display_name": "Will Brickner", "link": "https://stackoverflow.com/users/1497593/will-brickner"}, "edited": false, "score": 0, "creation_date": 1578856648, "post_id": 39785759, "comment_id": 105566839, "body": "What&#39;s the behavior of the range with no explicit end index? Does it imply the range goes to the end of the vector (e.g. vector length)? I can&#39;t find this documented."}, {"owner": {"reputation": 287982, "user_id": 69755, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/6aa87e056bd2ee342fbd56eb2110603c?s=128&d=identicon&r=PG", "display_name": "Brian Campbell", "link": "https://stackoverflow.com/users/69755/brian-campbell"}, "reply_to_user": {"reputation": 444, "user_id": 1497593, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/r8bS2.jpg?s=128&g=1", "display_name": "Will Brickner", "link": "https://stackoverflow.com/users/1497593/will-brickner"}, "edited": false, "score": 0, "creation_date": 1580273018, "post_id": 39785759, "comment_id": 106039087, "body": "Yes, that&#39;s right. It&#39;s explicitly documented in the docs for the <code>SliceIndex</code> impls, for example, <a href=\"https://doc.rust-lang.org/std/ops/struct.RangeFrom.html#impl-SliceIndex%3Cstr%3E\" rel=\"nofollow noreferrer\"><code>impl SliceIndex&lt;str&gt; for RangeFrom&lt;usize&gt;</code></a>:  &quot;Returns a slice of the given string from the byte range <code>[begin, len)</code>. Equivalent to <code>&amp;self[begin .. len]</code> or <code>&amp;mut self[begin .. len]</code>.&quot;"}], "tags": [], "owner": {"reputation": 287982, "user_id": 69755, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/6aa87e056bd2ee342fbd56eb2110603c?s=128&d=identicon&r=PG", "display_name": "Brian Campbell", "link": "https://stackoverflow.com/users/69755/brian-campbell"}, "is_accepted": true, "score": 118, "last_activity_date": 1572986941, "last_edit_date": 1572986941, "creation_date": 1475219637, "answer_id": 39785759, "question_id": 39785597, "link": "https://stackoverflow.com/questions/39785597/how-do-i-get-a-slice-of-a-vect-in-rust/39785759#39785759", "title": "How do I get a slice of a Vec&lt;T&gt; in Rust?", "body": "<p>The documentation for <code>Vec</code> covers this in <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#slicing\" rel=\"noreferrer\">the section titled \"slicing\"</a>.</p>\n\n<p>You can create a <a href=\"https://doc.rust-lang.org/std/primitive.slice.html\" rel=\"noreferrer\"><code>slice</code></a> of a <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html\" rel=\"noreferrer\"><code>Vec</code></a> or <a href=\"https://doc.rust-lang.org/std/primitive.array.html\" rel=\"noreferrer\"><code>array</code></a> by indexing it with a <a href=\"https://doc.rust-lang.org/std/ops/struct.Range.html\" rel=\"noreferrer\"><code>Range</code></a> (or <a href=\"https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html\" rel=\"noreferrer\"><code>RangeInclusive</code></a>, <a href=\"https://doc.rust-lang.org/std/ops/struct.RangeFrom.html\" rel=\"noreferrer\"><code>RangeFrom</code></a>, <a href=\"https://doc.rust-lang.org/std/ops/struct.RangeTo.html\" rel=\"noreferrer\"><code>RangeTo</code></a>, <a href=\"https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html\" rel=\"noreferrer\"><code>RangeToInclusive</code></a>, or <a href=\"https://doc.rust-lang.org/std/ops/struct.RangeFull.html\" rel=\"noreferrer\"><code>RangeFull</code></a>), <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=712605c97fe6060f8d299f6e94d3bcb9\" rel=\"noreferrer\">for example</a>:</p>\n\n<pre><code>fn main() {\n    let a = vec![1, 2, 3, 4, 5];\n\n    // With a start and an end\n    println!(\"{:?}\", &amp;a[1..4]);\n\n    // With a start and an end, inclusive\n    println!(\"{:?}\", &amp;a[1..=3]);\n\n    // With just a start\n    println!(\"{:?}\", &amp;a[2..]);\n\n    // With just an end\n    println!(\"{:?}\", &amp;a[..3]);\n\n    // With just an end, inclusive\n    println!(\"{:?}\", &amp;a[..=2]);\n\n    // All elements\n    println!(\"{:?}\", &amp;a[..]);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 27770, "user_id": 476074, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/3ad32697402bb21379768728e8640a22?s=128&d=identicon&r=PG", "display_name": "AndreKR", "link": "https://stackoverflow.com/users/476074/andrekr"}, "edited": false, "score": 0, "creation_date": 1598956907, "post_id": 49322987, "comment_id": 112618063, "body": "+1 I like <code>.as_slice()</code> much better than <code>[..]</code> because it conveys the intent. (Converting the Vec into a slice because only slices, not Vecs, implement <code>io::Read</code>.)"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 22, "last_activity_date": 1590179900, "last_edit_date": 1590179900, "creation_date": 1521210060, "answer_id": 49322987, "question_id": 39785597, "link": "https://stackoverflow.com/questions/39785597/how-do-i-get-a-slice-of-a-vect-in-rust/49322987#49322987", "title": "How do I get a slice of a Vec&lt;T&gt; in Rust?", "body": "<p>If you wish to convert the entire <code>Vec</code> to a slice, you can use <em><a href=\"https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\" rel=\"noreferrer\">deref coercion</a></em>:</p>\n\n<pre><code>fn main() {\n    let a = vec![1, 2, 3, 4, 5];\n    let b: &amp;[i32] = &amp;a;\n\n    println!(\"{:?}\", b);\n}\n</code></pre>\n\n<p>This coercion is automatically applied when calling a function:</p>\n\n<pre><code>fn print_it(b: &amp;[i32]) {\n    println!(\"{:?}\", b);\n}\n\nfn main() {\n    let a = vec![1, 2, 3, 4, 5];\n    print_it(&amp;a);\n}\n</code></pre>\n\n<p>You can also call <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_slice\" rel=\"noreferrer\"><code>Vec::as_slice</code></a>, but it's a bit less common:</p>\n\n<pre><code>fn main() {\n    let a = vec![1, 2, 3, 4, 5];\n    let b = a.as_slice();\n    println!(\"{:?}\", b);\n}\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/40006219/155423\">Why is it discouraged to accept a reference to a String (&amp;String), Vec (&amp;Vec), or Box (&amp;Box) as a function argument?</a></li>\n</ul>\n"}], "owner": {"reputation": 3087, "user_id": 856142, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/5bfb729f6ac07e17c2326a7335a3f3be?s=128&d=identicon&r=PG", "display_name": "yageek", "link": "https://stackoverflow.com/users/856142/yageek"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 52567, "favorite_count": 9, "accepted_answer_id": 39785759, "answer_count": 2, "score": 61, "last_activity_date": 1590179900, "creation_date": 1475219031, "last_edit_date": 1521209623, "question_id": 39785597, "link": "https://stackoverflow.com/questions/39785597/how-do-i-get-a-slice-of-a-vect-in-rust", "title": "How do I get a slice of a Vec&lt;T&gt; in Rust?", "body": "<p>I can not find within the documentation of <code>Vec&lt;T&gt;</code> how to retrieve a slice from  a specified range.</p>\n\n<p>Is there something like this in the standard library:</p>\n\n<pre><code>let a = vec![1, 2, 3, 4];\nlet suba = a.subvector(0, 2); // Contains [1, 2];\n</code></pre>\n"}, {"tags": ["arrays", "rust"], "answers": [{"tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 2, "last_activity_date": 1475351265, "creation_date": 1475351265, "answer_id": 39810818, "question_id": 39781986, "link": "https://stackoverflow.com/questions/39781986/how-to-find-the-kth-smallest-element-in-an-unsorted-array-or-its-segment/39810818#39810818", "title": "How to find the kth smallest element in an unsorted array or its segment?", "body": "<p>I don't think there is such a function in <code>std</code>.</p>\n\n<p>However, you can use <a href=\"https://huonw.github.io/order-stat/order_stat/index.html\" rel=\"nofollow\">the crate <code>order_stat</code></a>, which offers <a href=\"https://huonw.github.io/order-stat/order_stat/fn.kth.html\" rel=\"nofollow\">a <code>kth</code> function</a>.</p>\n"}], "owner": {"reputation": 9601, "user_id": 1937197, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/cg7w6.jpg?s=128&g=1", "display_name": "bobcat", "link": "https://stackoverflow.com/users/1937197/bobcat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 274, "favorite_count": 0, "accepted_answer_id": 39810818, "answer_count": 1, "score": 4, "last_activity_date": 1475655607, "creation_date": 1475195798, "last_edit_date": 1475655607, "question_id": 39781986, "link": "https://stackoverflow.com/questions/39781986/how-to-find-the-kth-smallest-element-in-an-unsorted-array-or-its-segment", "title": "How to find the kth smallest element in an unsorted array or its segment?", "body": "<p>Does Rust have a function to find the <em>k</em>th smallest element in an array or a segment of an array? </p>\n\n<p>(Similar to <code>std::nth_element</code> in C++)</p>\n"}, {"tags": ["scala", "rust", "iron"], "comments": [{"owner": {"reputation": 11714, "user_id": 323221, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/036bc6990a7ba39ac82cbfa266b7d326?s=128&d=identicon&r=PG", "display_name": "Erik Pragt", "link": "https://stackoverflow.com/users/323221/erik-pragt"}, "edited": false, "score": 2, "creation_date": 1475195972, "post_id": 39781623, "comment_id": 66858111, "body": "In your Scala app, if you connect to 127.0.0.1, instead of localhost, would that work? (or similarly, if you start the rust app on 127.0.0.1?)"}, {"owner": {"reputation": 33796, "user_id": 45525, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/TKzgD.png?s=128&g=1", "display_name": "Synesso", "link": "https://stackoverflow.com/users/45525/synesso"}, "reply_to_user": {"reputation": 11714, "user_id": 323221, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/036bc6990a7ba39ac82cbfa266b7d326?s=128&d=identicon&r=PG", "display_name": "Erik Pragt", "link": "https://stackoverflow.com/users/323221/erik-pragt"}, "edited": false, "score": 0, "creation_date": 1475205409, "post_id": 39781623, "comment_id": 66860155, "body": "Thanks for the suggestion Erik. After taking lunch and coming back again, it is working. I don&#39;t know what could have been wrong, but I&#39;m assuming I made a simple mistake. Deleting this question..."}, {"owner": {"reputation": 33796, "user_id": 45525, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/TKzgD.png?s=128&g=1", "display_name": "Synesso", "link": "https://stackoverflow.com/users/45525/synesso"}, "reply_to_user": {"reputation": 11714, "user_id": 323221, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/036bc6990a7ba39ac82cbfa266b7d326?s=128&d=identicon&r=PG", "display_name": "Erik Pragt", "link": "https://stackoverflow.com/users/323221/erik-pragt"}, "edited": false, "score": 0, "creation_date": 1475216664, "post_id": 39781623, "comment_id": 66863687, "body": "Restored this question. It is an intermittent problem!"}, {"owner": {"reputation": 15219, "user_id": 1272950, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/O1MQy.jpg?s=128&g=1", "display_name": "y\u01dds\u029e\u01ddla", "link": "https://stackoverflow.com/users/1272950/y%c7%9ds%ca%9e%c7%9dla"}, "edited": false, "score": 0, "creation_date": 1475218653, "post_id": 39781623, "comment_id": 66864585, "body": "Guess 1: you are running on Windows and the firewall or antivirus is blocking Java from connecting anywhere."}, {"owner": {"reputation": 15219, "user_id": 1272950, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/O1MQy.jpg?s=128&g=1", "display_name": "y\u01dds\u029e\u01ddla", "link": "https://stackoverflow.com/users/1272950/y%c7%9ds%ca%9e%c7%9dla"}, "edited": false, "score": 0, "creation_date": 1475218917, "post_id": 39781623, "comment_id": 66864739, "body": "Guess 2: You have some weird network setup where localhost needs to be looked up from DNS rather than from hosts file. Maybe you are behind a corporate proxy and this messes up the lookup. curl can use proxy settings from the environment vars, java can&#39;t so you have to pass it through JVM args or to your application."}, {"owner": {"reputation": 33796, "user_id": 45525, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/TKzgD.png?s=128&g=1", "display_name": "Synesso", "link": "https://stackoverflow.com/users/45525/synesso"}, "edited": false, "score": 0, "creation_date": 1475218943, "post_id": 39781623, "comment_id": 66864753, "body": "OSX &amp; no proxy settings. Vanilla all the way down."}, {"owner": {"reputation": 15219, "user_id": 1272950, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/O1MQy.jpg?s=128&g=1", "display_name": "y\u01dds\u029e\u01ddla", "link": "https://stackoverflow.com/users/1272950/y%c7%9ds%ca%9e%c7%9dla"}, "edited": false, "score": 0, "creation_date": 1475219385, "post_id": 39781623, "comment_id": 66865015, "body": "Maybe it&#39;s time to fire up Wireshark and see what&#39;s going on. You can filter by localhost interface and HTTP or TCP/IP protocol."}, {"owner": {"reputation": 15219, "user_id": 1272950, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/O1MQy.jpg?s=128&g=1", "display_name": "y\u01dds\u029e\u01ddla", "link": "https://stackoverflow.com/users/1272950/y%c7%9ds%ca%9e%c7%9dla"}, "edited": false, "score": 0, "creation_date": 1475220426, "post_id": 39781623, "comment_id": 66865630, "body": "Check you don&#39;t have any weird invisible characters in the address string - could be a result of copy paste from somewhere"}, {"owner": {"reputation": 33796, "user_id": 45525, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/TKzgD.png?s=128&g=1", "display_name": "Synesso", "link": "https://stackoverflow.com/users/45525/synesso"}, "edited": false, "score": 0, "creation_date": 1475224872, "post_id": 39781623, "comment_id": 66867842, "body": "Aleksey, Erik sorry for the misinformation in the original question. I misdiagnosed the problem. Using <code>127.0.0.1</code> in the client must have worked (I guess I didn&#39;t wait for my extra long server initialisation before testing)."}, {"owner": {"reputation": 15219, "user_id": 1272950, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/O1MQy.jpg?s=128&g=1", "display_name": "y\u01dds\u029e\u01ddla", "link": "https://stackoverflow.com/users/1272950/y%c7%9ds%ca%9e%c7%9dla"}, "edited": false, "score": 1, "creation_date": 1475224969, "post_id": 39781623, "comment_id": 66867908, "body": "Thanks for the followup, interesting problem"}], "answers": [{"tags": [], "owner": {"reputation": 33796, "user_id": 45525, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/TKzgD.png?s=128&g=1", "display_name": "Synesso", "link": "https://stackoverflow.com/users/45525/synesso"}, "is_accepted": true, "score": 4, "last_activity_date": 1475225117, "last_edit_date": 1475225117, "creation_date": 1475224793, "answer_id": 39787179, "question_id": 39781623, "link": "https://stackoverflow.com/questions/39781623/curl-can-connect-to-an-iron-server-on-localhost-but-scala-intermittently-cannot/39787179#39787179", "title": "Curl can connect to an Iron server on localhost, but Scala intermittently cannot", "body": "<p>According to <a href=\"https://github.com/iron/iron/issues/476#issuecomment-241730172\" rel=\"nofollow\">this comment on this bug report</a>, \"Iron will resolve ('localhost') to IPv6 by default while your other services use IPv4\"</p>\n\n<p>Bind Iron to <code>127.0.0.1</code> whilst that bug is unresolved.</p>\n"}], "owner": {"reputation": 33796, "user_id": 45525, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/TKzgD.png?s=128&g=1", "display_name": "Synesso", "link": "https://stackoverflow.com/users/45525/synesso"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 345, "favorite_count": 0, "accepted_answer_id": 39787179, "answer_count": 1, "score": 1, "last_activity_date": 1475242130, "creation_date": 1475192465, "last_edit_date": 1475242130, "question_id": 39781623, "link": "https://stackoverflow.com/questions/39781623/curl-can-connect-to-an-iron-server-on-localhost-but-scala-intermittently-cannot", "title": "Curl can connect to an Iron server on localhost, but Scala intermittently cannot", "body": "<p>In my Rust app, I start Iron like so:</p>\n\n<pre><code>let host: &amp;str = &amp;format!(\"localhost:{}\", port);\ninfo!(\"Server running at http://{}\", host);\nIron::new(Chain::new(router)).http(host).expect(\"Could not start Iron server\");\n</code></pre>\n\n<p>It responds:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>INFO Server running at http://localhost:3000\n</code></pre>\n\n<p>I can curl it:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ curl \"http://localhost:3000/v1/foo\"\n{\"bar\":\"baz\"}\n</code></pre>\n\n<p>However, in Scala I cannot connect:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ scala\nWelcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_40).\nType in expressions for evaluation. Or try :help.\n\nscala&gt; scala.io.Source.fromURL(\"http://localhost:3000/v1/foo\").mkString\njava.net.ConnectException: Connection refused\n  at java.net.PlainSocketImpl.socketConnect(Native Method)\n</code></pre>\n\n<p>spray-client also cannot connect:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>spray.can.Http$ConnectionAttemptFailedException: Connection attempt to 127.0.0.1:3000 failed\n</code></pre>\n\n<p>Both of these attempts are from the same IP and localhost is correct. The Iron server logs nothing on a failed connection request.</p>\n\n<p><strike>Different combinations of <code>localhost</code> vs <code>127.0.0.1</code> in both client and server do not fix the problem.</strike> I misdiagnosed this. Using <code>127.0.0.1</code> in the Rust client does fix the problem.</p>\n\n<p>After taking a break, the code started working. I don't recall if I restarted Iron. I then did several hours of development against it. At some stage it stopped working again. Restarts of the JVM and/or Iron server are not helping to fix the issue.</p>\n\n<p>This is not specific to my Rust app;</p>\n\n<p>I can recreate the problem with the example hello world Iron app.</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ git clone https://github.com/iron/iron.git\n$ (cd iron &amp;&amp; cargo run --example hello)\n</code></pre>\n\n<p>and then</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ curl \"http://localhost:3000/\"\nHello world!\n</code></pre>\n\n<p>but</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ scala\nscala&gt; scala.io.Source.fromURL(\"http://localhost:3000/\").mkString\njava.net.ConnectException: Connection refused\n</code></pre>\n\n<ul>\n<li>OSX 10.11.6</li>\n<li>cargo 0.13.0-nightly (9399229 2016-09-14)</li>\n<li>also tested against cargo 0.13.0-nightly (19cfb67 2016-09-28)</li>\n</ul>\n"}, {"tags": ["vector", "collections", "rust"], "answers": [{"comments": [{"owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "edited": false, "score": 0, "creation_date": 1475178657, "post_id": 39778631, "comment_id": 66851982, "body": "No <code>HashMap::get_two_things(&amp;a, &amp;b)</code>, oh man! I need to rethink my data structures. I&#39;m really enjoying Rust, but I wonder if it is really as fast as C with all of these workarounds you need to implement."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "edited": false, "score": 3, "creation_date": 1475179063, "post_id": 39778631, "comment_id": 66852200, "body": "@HiDefender beware the <a href=\"http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem\">X-Y Problem</a>. Often, a problem can be solved in a different way that is both idiomatic and performant. That applies for most languages, not just Rust! It&#39;s reasonable to ask a question one step up that you think might be solved by &quot;multiple elements from a collection, one mutable&quot;, but allow the community more leeway in solutions. Normal question rules apply of course - create an <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a> and show research."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "edited": false, "score": 2, "creation_date": 1475226986, "post_id": 39778631, "comment_id": 66869137, "body": "@HiDefender: Rust is not &quot;as fast as C&quot;, it&#39;s <a href=\"http://blog.burntsushi.net/ripgrep/\" rel=\"nofollow noreferrer\"><b>faster</b></a>! While aliasing is used for safety at the moment, it can also be used for performance. The main reason that Fortran kernels for numeric libraries are still in use today is because they are faster than the C and C++ kernels. And why are they faster? Because Fortran is stricter about aliasing, giving more opportunity to the compiler for optimization."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1475177805, "creation_date": 1475177805, "answer_id": 39778631, "question_id": 39778297, "link": "https://stackoverflow.com/questions/39778297/how-can-i-pass-multiple-elements-from-a-collection-into-a-function-with-one-or-m/39778631#39778631", "title": "How can I pass multiple elements from a collection into a function with one or more of the elements being mutable?", "body": "<blockquote>\n  <p>How can I pass multiple elements from the same collection into a function with one or more of the elements being mutable?</p>\n</blockquote>\n\n<p>The short answer is that you cannot, at least not without support from the collection itself.</p>\n\n<p>Rust disallows <em>mutable aliases</em> - multiple names for the same thing, one of which allows mutation.</p>\n\n<p>It would be far too complicated (with the current state of programming languages) to verify that <code>(&amp;mut vec[0], &amp;vec[1])</code> does not introduce aliasing but <code>(&amp;mut vec[0], &amp;vec[0])</code> does. Adding to the complexity is the fact that the <code>[]</code> operator can be overloaded, which allows creating a type such that <code>foo[0]</code> and <code>foo[1]</code> actually point <em>at the same thing</em>.</p>\n\n<p>So, how can a collection help out? Each collection will have (or not have) a specific way of subdivision in an aliasing-safe manner.</p>\n\n<p>There can be methods like <a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut\"><code>slice::split_at_mut</code></a> which verify that that two halves cannot overlap and thus no aliasing can occur.</p>\n\n<p>Unfortunately, there's no <code>HashMap::get_two_things(&amp;a, &amp;b)</code> that I'm aware of. It would be pretty niche, but that doesn't mean it <em>couldn't</em> exist.</p>\n\n<blockquote>\n  <p><code>vec</code> is never borrowed by <code>foo</code> though</p>\n</blockquote>\n\n<p>It most certainly is. When you index a <code>Vec</code>, you are getting a reference to some chunk of memory inside the <code>Vec</code>. If the <code>Vec</code> were to change underneath you, such as when <em>someone adds or removes a value</em>, then the underlying memory may need to be reallocated, invalidating the reference. This is a prime example of why mutable aliasing is a bad thing.</p>\n"}], "owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 78, "favorite_count": 0, "accepted_answer_id": 39778631, "answer_count": 1, "score": 5, "last_activity_date": 1475177805, "creation_date": 1475176580, "last_edit_date": 1475177368, "question_id": 39778297, "link": "https://stackoverflow.com/questions/39778297/how-can-i-pass-multiple-elements-from-a-collection-into-a-function-with-one-or-m", "title": "How can I pass multiple elements from a collection into a function with one or more of the elements being mutable?", "body": "<p>When passing two elements from the same vector to a function, the borrow checker will not allow one of the elements to be mutable.</p>\n\n<pre><code>struct Point {\n    x: i32,\n    y: i32,\n}\nfn main() {\n    let mut vec: Vec&lt;Point&gt; = Vec::new();\n    foo(&amp;mut vec[0], &amp;vec[1]);\n}\nfn foo(pnt_1: &amp;mut Point, pnt_2: &amp;Point) {\n}\n</code></pre>\n\n<blockquote>\n  <p>error: cannot borrow <code>vec</code> as immutable because it is also borrowed as mutable</p>\n</blockquote>\n\n<p><code>vec</code> is never borrowed by <code>foo</code> though, <code>vec[0]</code> is borrowed and <code>vec[0]</code> is a <code>Point</code>.</p>\n\n<p>How can I pass multiple elements from the same collection into a function with one or more of the elements being mutable?</p>\n"}, {"tags": ["iterator", "rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 12, "last_activity_date": 1526133385, "last_edit_date": 1526133385, "creation_date": 1475165201, "answer_id": 39775139, "question_id": 39775060, "link": "https://stackoverflow.com/questions/39775060/reverse-iterating-over-a-vec-versus-vec-iter/39775139#39775139", "title": "Reverse iterating over a &amp;vec versus vec.iter()", "body": "<p>This is just basic precedence of the <code>&amp;</code> operator. In the first case, each method is called in turn:</p>\n\n<pre><code>vec.iter().rev()\n(vec.iter()).rev() // same\n</code></pre>\n\n<p>In the second case, the <code>&amp;</code> binds after all the methods:</p>\n\n<pre><code>&amp;vec.rev()\n&amp;(vec.rev()) // same\n</code></pre>\n\n<p>Generally, use <code>&amp;vec</code> when you can, but when you need to use <em>iterator adapter methods</em>, use <code>iter</code> or <code>into_iter</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 17, "last_activity_date": 1475165257, "last_edit_date": 1475165257, "creation_date": 1475165210, "answer_id": 39775142, "question_id": 39775060, "link": "https://stackoverflow.com/questions/39775060/reverse-iterating-over-a-vec-versus-vec-iter/39775142#39775142", "title": "Reverse iterating over a &amp;vec versus vec.iter()", "body": "<p>If you're just looping over the <code>Vec</code>, then <code>&amp;vec</code> is idiomatic.  This works because <code>&amp;Vec&lt;T&gt;</code> implements <code>IntoIterator</code>, which is what the for loop uses.</p>\n\n<p>However if you want to call <code>Iterator</code> methods such as <code>rev</code>, <code>filter</code>, etc., you need an actual <code>Iterator</code> (since <code>Vec</code> doesn't implement <code>Iterator</code>, only <code>IntoIterator</code>).</p>\n\n<p>So this:</p>\n\n<pre><code>for x in &amp;vec.rev() {\n    ...\n}\n</code></pre>\n\n<p>is equivalent to:</p>\n\n<pre><code>for x in (&amp;vec.rev()).into_iter() {\n    ...\n}\n</code></pre>\n\n<p>i.e. there's no chance to use <code>IntoIterator</code> before trying to call <code>Iterator</code> methods.</p>\n"}], "owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 8281, "favorite_count": 0, "accepted_answer_id": 39775142, "answer_count": 2, "score": 17, "last_activity_date": 1526133385, "creation_date": 1475164918, "last_edit_date": 1475165050, "question_id": 39775060, "link": "https://stackoverflow.com/questions/39775060/reverse-iterating-over-a-vec-versus-vec-iter", "title": "Reverse iterating over a &amp;vec versus vec.iter()", "body": "<p>This works because <code>Iterator</code> implements <code>rev()</code> where <code>self</code> is a <code>DoubleEndedIterator</code>:</p>\n\n<pre><code>let vec: Vec&lt;i32&gt; = Vec::new();\nfor x in vec.iter().rev() {\n    //Do stuff\n}\n</code></pre>\n\n<p>However, if I change <code>vec.iter().rev()</code> to <code>&amp;vec.rev()</code> it won't compile because:</p>\n\n<blockquote>\n<pre><code>no method named `rev` found for type `std::vec::Vec&lt;i32&gt;` in the current scope\n</code></pre>\n</blockquote>\n\n<p>Furthermore:</p>\n\n<blockquote>\n<pre><code>the method `rev` exists but the following trait bounds were not satisfied: `std::vec::Vec&lt;i32&gt; : std::iter::Iterator`, `[i32] : std::iter::Iterator`\n</code></pre>\n</blockquote>\n\n<p>But doesn't a for loop implicitly call <a href=\"https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\"><code>IntoIterator</code></a>? Is <code>&amp;vec</code> or <code>vec.iter()</code> considered idiomatic Rust?</p>\n"}, {"tags": ["c", "rust"], "comments": [{"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 1, "creation_date": 1475137402, "post_id": 39765039, "comment_id": 66824864, "body": "I&#39;m pretty sure libc&#39;s <code>memchr</code> (at least GNU libc) is written either mostly or completely in assembly."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1475137553, "post_id": 39765039, "comment_id": 66824944, "body": "As you can see in the link you provided, there is a <code>memchr</code> written in Rust, but it&#39;s only used on windows, because only on windows the Rust-<code>memchr</code> is faster than the <code>libc</code>-<code>memchr</code>"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1475138445, "post_id": 39765039, "comment_id": 66825572, "body": "Is the question specifically about C-bindings or is it about using only Rust? This would affect whether inlined assembly in Rust code is considered &quot;Rust&quot; or not."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1475152365, "post_id": 39765039, "comment_id": 66835188, "body": "It&#39;s an interesting twist on <a href=\"https://meta.wikimedia.org/wiki/Cunningham%27s_Law\" rel=\"nofollow noreferrer\">Cunningham&#39;s Law</a> \u2014 incorrectly state that something <i>can&#39;t</i> be done and watch the answers roll in!"}, {"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1475153970, "post_id": 39765039, "comment_id": 66836368, "body": "@Shepmaster Ha :) Then perhaps my question should have been &quot;why aren&#39;t&quot; rather than &quot;why can&#39;t&quot;."}, {"owner": {"reputation": 94713, "user_id": 1139697, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/5f136ddb684f39aaee1c028ee1950f6f?s=128&d=identicon&r=PG", "display_name": "Zeta", "link": "https://stackoverflow.com/users/1139697/zeta"}, "edited": false, "score": 1, "creation_date": 1475160344, "post_id": 39765039, "comment_id": 66841159, "body": "You can always <a href=\"https://stackoverflow.com/posts/39765039/edit\">edit</a> your question if you think that it&#39;s currently sub-par."}], "answers": [{"comments": [{"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "edited": false, "score": 0, "creation_date": 1475154303, "post_id": 39765239, "comment_id": 66836619, "body": "I think my actual assumption was different (and also incorrect). That is, I didn&#39;t consider the fairly obvious point that the C version is actually just a binding to assembly code targeting many hardware permutations. And you are right - it isn&#39;t convenient or worthwhile to bind to that assembly, when you can re-use the C at zero cost."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 8, "last_activity_date": 1475137860, "creation_date": 1475137860, "answer_id": 39765239, "question_id": 39765039, "link": "https://stackoverflow.com/questions/39765039/why-are-functions-like-memchr-bound-to-c-implementations-rather-than-being-writt/39765239#39765239", "title": "Why are functions like memchr bound to C implementations rather than being written in pure Rust?", "body": "<p>There is an assumption here that the <em>only</em> reason to link to a C library is for efficiency.</p>\n\n<p>I am afraid that you are forgetting <em>convenience</em> here. Just because a function <em>could</em> be implemented as efficiently in Rust as in C (possibly leveraging <code>unsafe</code> code and assembly) does not mean that it is convenient to do so.</p>\n\n<p>Rather than attempt to produce an optimized implementation for each and every platform under the sun, it is simply more convenient to be able to fallback to the already provided C function to start with, and then gradually tune for the platforms you care for if necessary.</p>\n\n<p>Producing an implementation that is tailored specifically to the hardware/OS is a lengthy job, and if someone already poured in the effort it might make sense to just reuse its result!</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 4, "creation_date": 1475137944, "post_id": 39765241, "comment_id": 66825226, "body": "That&#39;s a bit of a cop-out: why not simply port the optimized <code>memchr</code> to Rust? There is, in theory, nothing preventing Rust from reaching C/assembly speeds (especially as it can include assembly code, on nightly at least), and BurntSushi has gone to great extent to tune his Regex library, so why not for <code>memchr</code>?"}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1475138060, "post_id": 39765241, "comment_id": 66825314, "body": "This would not be <i>pure</i> Rust, though - and that is what the question was about."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1475138355, "post_id": 39765241, "comment_id": 66825509, "body": "Maybe, maybe not. First of all, SIMD can be used in pure Rust (on nightly) and second of all the question only refers to C-bindings, not inline assembly so it&#39;s unclear whether the OP judges it acceptable."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1475138417, "post_id": 39765241, "comment_id": 66825555, "body": "That&#39;s true; I&#39;ll include an additional note in my answer."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1475138545, "post_id": 39765241, "comment_id": 66825639, "body": "I&#39;ve asked the OP about this distinction, as far as I am concerned it should be OK; I mostly see C-bindings as an <i>inconvenience</i> (have to have the C lib available, configure cargo to link against it, etc...) so I don&#39;t consider inline assembly with the same stigma. Both are unsafe, but <code>unsafe</code> is part of Rust too :)"}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 2, "last_activity_date": 1475138770, "last_edit_date": 1475138770, "creation_date": 1475137862, "answer_id": 39765241, "question_id": 39765039, "link": "https://stackoverflow.com/questions/39765039/why-are-functions-like-memchr-bound-to-c-implementations-rather-than-being-writt/39765241#39765241", "title": "Why are functions like memchr bound to C implementations rather than being written in pure Rust?", "body": "<p>They can, but according to documentation in <a href=\"https://github.com/rust-lang/rust/blob/11946956a6352f49c6aadc1c13c39757a046e0c2/src/libstd/memchr.rs#L16-L23\" rel=\"nofollow\">Rust's GitHub</a> this is for performance reasons:</p>\n\n<blockquote>\n  <p>memchr reduces to super-optimized machine code at around an order of\n  magnitude faster than <code>haystack.iter().position(|&amp;b| b == needle)</code>.\n  (See benchmarks.)</p>\n</blockquote>\n\n<p>Since benchmarks indicate that <code>memchr()</code> from C-bindings results in a far better performance, that version is the preferred one. Trying to optimize a Rust variant further would probably result in including some assembly, so it would boil down to the same thing.</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1475138625, "post_id": 39765446, "comment_id": 66825693, "body": "<i>It&#39;s already there, no need to create everything anew.</i> =&gt; might be more convenient (for the user) not to have to link against libc, but otherwise I agree. DRY &amp; all that."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 4, "creation_date": 1475150922, "post_id": 39765446, "comment_id": 66834103, "body": "I think we need the proven and tuned low level functions like this from glibc to compete. They have literally hundreds of assembly implementations for various platforms of memcpy, memchr and so on."}, {"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "edited": false, "score": 0, "creation_date": 1475154529, "post_id": 39765446, "comment_id": 66836810, "body": "Thanks @Zeta. I don&#39;t have much knowledge of LLVM or C, and I assumed that this sort of low-level operation would be best implemented in LLVM, and be available to the Rust compiler."}], "tags": [], "owner": {"reputation": 94713, "user_id": 1139697, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/5f136ddb684f39aaee1c028ee1950f6f?s=128&d=identicon&r=PG", "display_name": "Zeta", "link": "https://stackoverflow.com/users/1139697/zeta"}, "is_accepted": true, "score": 10, "last_activity_date": 1475138437, "creation_date": 1475138437, "answer_id": 39765446, "question_id": 39765039, "link": "https://stackoverflow.com/questions/39765039/why-are-functions-like-memchr-bound-to-c-implementations-rather-than-being-writt/39765446#39765446", "title": "Why are functions like memchr bound to C implementations rather than being written in pure Rust?", "body": "<p>They can. If you look at glibc's implementation, it will look somewhat like <a href=\"https://github.com/BurntSushi/rust-memchr/blob/62eae0de4a5d231467b27ca6719f000c63f4edf2/src/lib.rs#L251\"><code>fallback:memchr</code></a>. However, that's only part of the story. The <a href=\"https://sourceware.org/git/?p=glibc.git;a=blob;f=string/memchr.c;h=ca9fd99f2105003d0b56285ff3f41ba10dad8685;hb=HEAD\">generic implementation</a> is used only when there isn't a more appropriate one available.</p>\n\n<p>For example, <a href=\"https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/memchr.S;h=132eacba8f88b691c35666c99f611a2a98727a13;hb=HEAD\">x68-64 has a variant written in assembly</a>. And so do <a href=\"https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/i386/i686/multiarch/memchr.S;hb=HEAD\">many</a> <a href=\"https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/i386/memchr.S;h=e8834349e6aba97b67928031c5616e5003b75507;hb=HEAD\">other</a> architectures, that provide sophisticated instructions.</p>\n\n<p>So to reach the same speed, Rust would have to provide something similar on instruction level, which essentially boils down to the same (or better) assembly. At that point you're just duplicating work. It's already there, no need to create everything anew.</p>\n"}], "owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 380, "favorite_count": 0, "accepted_answer_id": 39765446, "answer_count": 3, "score": 5, "last_activity_date": 1475167379, "creation_date": 1475137303, "last_edit_date": 1475167379, "question_id": 39765039, "link": "https://stackoverflow.com/questions/39765039/why-are-functions-like-memchr-bound-to-c-implementations-rather-than-being-writt", "title": "Why are functions like memchr bound to C implementations rather than being written in pure Rust?", "body": "<p>Functions like <code>memchr</code> seem quite simple but Rust projects use <a href=\"https://github.com/BurntSushi/rust-memchr/blob/master/src/lib.rs\" rel=\"noreferrer\">bindings to the C code</a> with only a Rust fallback, rather than implementing them in Rust. Can't <code>memchr</code> be efficiently implemented in Rust?</p>\n"}]