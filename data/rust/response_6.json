[{"tags": ["rust", "lifetime"], "answers": [{"tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 2, "last_activity_date": 1424300861, "creation_date": 1424300861, "answer_id": 28595712, "question_id": 28595151, "link": "https://stackoverflow.com/questions/28595151/why-does-14-in-a-14-only-live-one-statement/28595712#28595712", "title": "Why does &amp;14 in a = &amp;14 only live one statement?", "body": "<p>This is an edge case between the way that <code>let</code> acts and expressions act. Basically, <code>let</code> is a special case here.</p>\n\n<p>In the first example, Rust understands that you're taking a reference to a stack-allocated <code>i32</code>.</p>\n\n<p>In the second, you're introducing a binding, but then trying to use an assignment expression to update the binding. Because it's just a regular expression, things that it creates go out of scope at the end of the expression, and so, <code>14</code> here has the lifetime of just the expression, rather than the stack frame.</p>\n"}, {"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 4, "last_activity_date": 1424302322, "last_edit_date": 1424302322, "creation_date": 1424300892, "answer_id": 28595722, "question_id": 28595151, "link": "https://stackoverflow.com/questions/28595151/why-does-14-in-a-14-only-live-one-statement/28595722#28595722", "title": "Why does &amp;14 in a = &amp;14 only live one statement?", "body": "<p>I believe <code>let</code> has a special case that a plain <code>=</code> doesn't have (yet), where references assigned directly to the binding live for the closest enclosing block (approximately, the value is destroyed at the next <code>}</code>), rather than just the closest enclosing statement as they usually do (approximately, the value is destroyed at the next <code>;</code>). This explains the current error message:</p>\n\n<pre><code>&lt;anon&gt;:3:10: 3:12 error: borrowed value does not live long enough\n&lt;anon&gt;:3     i = &amp;14;\n                  ^~\n&lt;anon&gt;:2:14: 4:2 note: reference must be valid for the block suffix following statement 0 at 2:13...\n&lt;anon&gt;:2     let mut i;\n&lt;anon&gt;:3     i = &amp;14;\n&lt;anon&gt;:4 }\n&lt;anon&gt;:3:5: 3:13 note: ...but borrowed value is only valid for the statement at 3:4\n&lt;anon&gt;:3     i = &amp;14;\n             ^~~~~~~~\n&lt;anon&gt;:3:5: 3:13 help: consider using a `let` binding to increase its lifetime\n&lt;anon&gt;:3     i = &amp;14;\n             ^~~~~~~~\n</code></pre>\n\n<p>That said, this also interacts with the new destructor changes, where the precise ordering of declaration of data is important to ensure safety of references. The <code>&amp;14</code> expression currently means <code>let tmp = 14; &amp;tmp</code>, so making that desugaring gives</p>\n\n<pre><code>fn main() {\n    let mut i;\n    let tmp = 14;\n    i = &amp;tmp;\n}\n</code></pre>\n\n<p>which fails to compile with </p>\n\n<pre><code>&lt;anon&gt;:4:10: 4:13 error: `tmp` does not live long enough\n&lt;anon&gt;:4     i = &amp;tmp;\n                  ^~~\n&lt;anon&gt;:2:14: 5:2 note: reference must be valid for the block suffix following statement 0 at 2:13...\n&lt;anon&gt;:2     let mut i;\n&lt;anon&gt;:3     let tmp = 14;\n&lt;anon&gt;:4     i = &amp;tmp;\n&lt;anon&gt;:5 }\n&lt;anon&gt;:3:17: 5:2 note: ...but borrowed value is only valid for the block suffix following statement 1 at 3:16\n&lt;anon&gt;:3     let tmp = 14;\n&lt;anon&gt;:4     i = &amp;tmp;\n&lt;anon&gt;:5 }\n</code></pre>\n\n<p><a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md\" rel=\"nofollow\">The RFC</a> contains a lot of detail, but, in summary, to ensure safety for generic destructors, any data with references must point to something that strictly outlives itself, where \"outlives\" is considered at the statement level. In this case, <code>tmp</code> was declared after <code>i</code>, so it is illegal for <code>i</code> to contain a pointer to it.</p>\n\n<p>There are some changes that may cause this code to compile, incidentally. <code>14</code> is constant data, so it can be placed in static memory, meaning <code>&amp;14</code> could be a <code>&amp;'static i32</code> instead of just a <code>&amp;'short_stack_lifetime i32</code>. Both versions of the code would then be valid. This is <a href=\"https://github.com/rust-lang/rfcs/issues/827\" rel=\"nofollow\">RFC issue #827</a>.</p>\n"}], "owner": {"reputation": 75, "user_id": 4534809, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/siPrj.png?s=128&g=1", "display_name": "mrburne", "link": "https://stackoverflow.com/users/4534809/mrburne"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 118, "favorite_count": 1, "accepted_answer_id": 28595722, "answer_count": 2, "score": 3, "last_activity_date": 1424312942, "creation_date": 1424298314, "last_edit_date": 1424312942, "question_id": 28595151, "link": "https://stackoverflow.com/questions/28595151/why-does-14-in-a-14-only-live-one-statement", "title": "Why does &amp;14 in a = &amp;14 only live one statement?", "body": "<p>I don't understand why this works:</p>\n\n<pre><code>let mut i = &amp;14;\n</code></pre>\n\n<p>and this doesn't:</p>\n\n<pre><code>let mut i;\ni = &amp;14;\n</code></pre>\n\n<p>Why doesn't <code>&amp;14</code> get automatically the lifetime of <code>i</code> in this case? When is it useful to have \"something = some new thing with lifetime of only one statement\"?</p>\n"}, {"tags": ["pointers", "rust"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1424334600, "post_id": 28595854, "comment_id": 45508645, "body": "The use of &quot;moving bits&quot; is a bit confusing, as Rust moves by moving bits. Maybe &quot;copying bits&quot; would be clearer?"}, {"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1424347869, "post_id": 28595854, "comment_id": 45516376, "body": "@MatthieuM. Sure. Updated. For what it&#39;s worth, I took the previous wording straight from the language reference: &#39;Copy, for &quot;Plain Old Data&quot; types which can be copied by simply moving bits.&#39;"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1424348033, "post_id": 28595854, "comment_id": 45516474, "body": "@BurntSushi5: Interesting, maybe we should warn steve than using &quot;move&quot; in the context of &quot;copy&quot; is a bit confusing?"}], "tags": [], "owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "is_accepted": true, "score": 10, "last_activity_date": 1424359941, "last_edit_date": 1424359941, "creation_date": 1424301411, "answer_id": 28595854, "question_id": 28595075, "link": "https://stackoverflow.com/questions/28595075/cannot-move-out-of-borrowed-content-when-borrowing-a-generic-type/28595854#28595854", "title": "Cannot move out of borrowed content when borrowing a generic type", "body": "<p>The short answer is that <code>i32</code> implements the <code>Copy</code> trait, but <code>T</code> does not. If you use <code>fn generic_main&lt;T: Copy&gt;(t: Test&lt;T&gt;)</code>, then your immediate problem is fixed.</p>\n\n<p>The longer answer is that <code>Copy</code> is a special trait which means values can be copied by simply copying bits. Types like <code>i32</code> implement <code>Copy</code>. Types like <code>String</code> do <em>not</em> implement <code>Copy</code> because, for example, it requires a heap allocation. If you copied a <code>String</code> just by copying bits, you'd end up with two <code>String</code> values pointing to the same chunk of memory. That would not be good (it's unsafe!).</p>\n\n<p>Therefore, giving your <code>T</code> a <code>Copy</code> bound is quite restrictive. A less restrictive bound would be <code>T: Clone</code>. The <code>Clone</code> trait is similar to <code>Copy</code> (in that it copies values), but it's usually done by more than just \"copying bits.\" For example, the <code>String</code> type will implement <code>Clone</code> by creating a new heap allocation for the underlying memory.</p>\n\n<p>This requires you to change how your <code>generic_main</code> is written:</p>\n\n<pre><code>fn generic_main&lt;T: Clone&gt;(t: Test&lt;T&gt;) {\n    let x = t.get_first();\n    t.do_something_with_x(x.clone());\n}\n</code></pre>\n\n<p>Alternatively, if you don't want to have either the <code>Clone</code> or <code>Copy</code> bounds, then you could change your <code>do_something_with_x</code> method to take a <em>reference</em> to <code>T</code> rather than an owned <code>T</code>:</p>\n\n<pre><code>impl&lt;T&gt; Test&lt;T&gt; {\n    // other methods elided\n\n    fn do_something_with_x(&amp;self, x: &amp;T) {\n        // Irrelevant\n    }\n}\n</code></pre>\n\n<p>And your <code>generic_main</code> stays mostly the same, except you don't dereference <code>x</code>:</p>\n\n<pre><code>fn generic_main&lt;T&gt;(t: Test&lt;T&gt;) {\n    let x = t.get_first();\n    t.do_something_with_x(x);\n}\n</code></pre>\n\n<p>You can read more about <code>Copy</code> <a href=\"http://doc.rust-lang.org/std/marker/trait.Copy.html\" rel=\"noreferrer\">in the docs</a>. There are some nice examples, including how to implement <code>Copy</code> for your own types.</p>\n"}], "owner": {"reputation": 6499, "user_id": 1320374, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/b75569a6d70d16ef886a720fc0dc94cd?s=128&d=identicon&r=PG", "display_name": "IluTov", "link": "https://stackoverflow.com/users/1320374/ilutov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 777, "favorite_count": 0, "accepted_answer_id": 28595854, "answer_count": 1, "score": 5, "last_activity_date": 1424359941, "creation_date": 1424298015, "last_edit_date": 1592644375, "question_id": 28595075, "link": "https://stackoverflow.com/questions/28595075/cannot-move-out-of-borrowed-content-when-borrowing-a-generic-type", "title": "Cannot move out of borrowed content when borrowing a generic type", "body": "<p>I have a program that more or less looks like this</p>\n<pre><code>struct Test&lt;T&gt; {\n    vec: Vec&lt;T&gt;\n}\n\nimpl&lt;T&gt; Test&lt;T&gt; {\n    fn get_first(&amp;self) -&gt; &amp;T {\n        &amp;self.vec[0]\n    }\n\n    fn do_something_with_x(&amp;self, x: T) {\n        // Irrelevant\n    }\n}\n\nfn main() {\n    let t = Test { vec: vec![1i32, 2, 3] };\n    let x = t.get_first();\n    t.do_something_with_x(*x);\n}\n</code></pre>\n<p>Basically, we call a method on the struct <code>Test</code> that borrows some value. Then we call another method on the same struct, passing the previously obtained value.</p>\n<p>This example works perfectly fine. Now, when we make the content of <code>main</code> generic, it doesn't work anymore.</p>\n<pre><code>fn generic_main&lt;T&gt;(t: Test&lt;T&gt;) {\n    let x = t.get_first();\n    t.do_something_with_x(*x);\n}\n</code></pre>\n<p>Then I get the following error:</p>\n<blockquote>\n<p>error: cannot move out of borrowed content</p>\n<p>src/main.rs:14         let raw_x = *x;</p>\n</blockquote>\n<p>I'm not completely sure why this is happening. Can someone explain to me why <code>Test&lt;i32&gt;</code> isn't borrowed when calling <code>get_first</code> while <code>Test&lt;T&gt;</code> is?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 12395, "user_id": 320619, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/ee7d3e88b401e9eed01673443a726bc7?s=128&d=identicon&r=PG", "display_name": "Allyl Isocyanate", "link": "https://stackoverflow.com/users/320619/allyl-isocyanate"}, "edited": false, "score": 0, "creation_date": 1424281806, "post_id": 28590148, "comment_id": 45487330, "body": "Thanks @Shepmaster.  What is the meaning of &lt;&amp;&#39;static str&gt; in Vec&lt;&amp;&#39;static str&gt;?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 2, "creation_date": 1424282165, "post_id": 28590148, "comment_id": 45487555, "body": "<code>&amp;&#39;static str</code> is the type of elements contained in the <code>Vec</code>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1485660222, "last_edit_date": 1485660222, "creation_date": 1424281071, "answer_id": 28590148, "question_id": 28589764, "link": "https://stackoverflow.com/questions/28589764/returning-and-using-a-generic-type-with-match/28590148#28590148", "title": "Returning and using a generic type with match", "body": "<p>Here's a reduced testcase:</p>\n\n<pre><code>use std::path::PathBuf;\n\nfn main() {\n    let paths: Vec&lt;PathBuf&gt; = Vec::new();\n    let defaults: Vec&lt;&amp;'static str&gt; = Vec::new();\n\n    let result = match 1 {\n        1 =&gt; paths,\n        _ =&gt; defaults,\n    };\n}\n</code></pre>\n\n<p>As the error message is trying to say, Rust requires that a single variable will always have the same type. It simply doesn't make sense to have one variable be an unknown type out of a set.</p>\n\n<p>The most straight-forward thing you can do is create an <code>enum</code> that wraps both cases you have:</p>\n\n<pre><code>use std::path::PathBuf;\n\nenum MyThing&lt;'a&gt; {\n    Str(&amp;'a str),\n    Path(PathBuf),\n}\n\nfn main() {\n    let paths: Vec&lt;PathBuf&gt; = Vec::new();\n    let defaults: Vec&lt;&amp;'static str&gt; = Vec::new();\n\n    let result: Vec&lt;_&gt; = match 1 {\n        1 =&gt; paths.into_iter().map(MyThing::Path).collect(),\n        _ =&gt; defaults.into_iter().map(MyThing::Str).collect(),\n    };\n}\n</code></pre>\n\n<p>You could also just pick a middle ground and convert to that type, perhaps <code>String</code>:</p>\n\n<pre><code>use std::path::PathBuf;\n\nfn main() {\n    let paths: Vec&lt;PathBuf&gt; = Vec::new();\n    let defaults: Vec&lt;&amp;'static str&gt; = Vec::new();\n\n    let result: Vec&lt;_&gt; = match 1 {\n        1 =&gt; paths.into_iter().map(|p| p.to_string_lossy().into_owned()).collect(),\n        _ =&gt; defaults.into_iter().map(|s| s.to_string()).collect(),\n    };\n}\n</code></pre>\n\n<p>A third option is to create a <em>trait</em> and implement it for both types. You can then create a <em>trait object</em>. This option is closest to dynamic languages that you may be familiar with. It adds an extra layer of indirection, allowing for more flexibility:</p>\n\n<pre><code>use std::path::PathBuf;\n\ntrait MyTrait {\n    fn size(&amp;self) -&gt; u8;\n}\n\nimpl MyTrait for PathBuf {\n    fn size(&amp;self) -&gt; u8 {\n        15\n    }\n}\n\nimpl&lt;'a&gt; MyTrait for &amp;'a str {\n    fn size(&amp;self) -&gt; u8 {\n        88\n    }\n}\n\nfn main() {\n    let paths: Vec&lt;PathBuf&gt; = Vec::new();\n    let defaults: Vec&lt;&amp;'static str&gt; = Vec::new();\n\n    let result: Vec&lt;_&gt; = match 1 {\n        1 =&gt; paths.into_iter().map(|p| Box::new(p) as Box&lt;MyTrait&gt;).collect(),\n        _ =&gt; defaults.into_iter().map(|s| Box::new(s) as Box&lt;MyTrait&gt;).collect(),\n    };\n}\n</code></pre>\n"}], "owner": {"reputation": 12395, "user_id": 320619, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/ee7d3e88b401e9eed01673443a726bc7?s=128&d=identicon&r=PG", "display_name": "Allyl Isocyanate", "link": "https://stackoverflow.com/users/320619/allyl-isocyanate"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2604, "favorite_count": 0, "accepted_answer_id": 28590148, "answer_count": 1, "score": 4, "last_activity_date": 1485660222, "creation_date": 1424279928, "last_edit_date": 1485660190, "question_id": 28589764, "link": "https://stackoverflow.com/questions/28589764/returning-and-using-a-generic-type-with-match", "title": "Returning and using a generic type with match", "body": "<p>I'm working on a simple Rust app that accepts stdin and acts on the basis of it. I'd like to have each command return a vector of results.</p>\n\n<p>Different commands may return differently typed vectors; the <code>list</code> method returns a vector of <code>PathBuf</code>s, but the default match arm returns strings: </p>\n\n<pre><code>use std::{io, fs};\nuse std::path::PathBuf;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&amp;mut input).expect(\"Failed to read line\");\n    let chars_to_trim: &amp;[char] = &amp;['\\n'];\n    let trimmed_input: &amp;str = input.trim_matches(chars_to_trim);\n\n    let no_match = vec![\"No Match\"];\n\n    let result = match trimmed_input {\n        \"list\" =&gt; list(),\n        _ =&gt; no_match,\n    };\n}\n\nfn list() -&gt; Vec&lt;PathBuf&gt; {\n    println!(\"{}\", \"list of lockfiles here\");\n    let entries = fs::read_dir(\"/tmp\").expect(\"Failed to read /tmp\");\n    let all: Result&lt;_, _&gt; = entries.map(|entry| entry.map(|e| e.path())).collect();\n    all.expect(\"Unable to read an entry\")\n}\n</code></pre>\n\n<p>This causes compilation to fail:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: match arms have incompatible types\n  --&gt; src/main.rs:12:22\n   |\n12 |         let result = match trimmed_input {\n   |                      ^ expected struct `std::path::PathBuf`, found &amp;str\n   |\n   = note: expected type `std::vec::Vec&lt;std::path::PathBuf&gt;`\n   = note:    found type `std::vec::Vec&lt;&amp;str&gt;`\nnote: match arm with an incompatible type\n  --&gt; src/main.rs:14:18\n   |\n14 |             _ =&gt; no_match,\n   |                  ^^^^^^^^\n</code></pre>\n\n<p>What is the idiomatic Rust way to handle this? I've read through the documentation on generics but I'm not sure how to apply it.</p>\n"}, {"tags": ["variables", "syntax", "reference", "rust", "mutable"], "comments": [{"owner": {"reputation": 27478, "user_id": 183120, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/fc147f814e1473bb6105db3d924fb590?s=128&d=identicon&r=PG", "display_name": "legends2k", "link": "https://stackoverflow.com/users/183120/legends2k"}, "edited": false, "score": 1, "creation_date": 1600705259, "post_id": 28587698, "comment_id": 113165173, "body": "For C++ programmers: the difference is similar to <a href=\"https://stackoverflow.com/q/21476869/183120\">pointer <code>const</code> vs <code>pointee</code> const</a>."}], "answers": [{"comments": [{"owner": {"reputation": 3970, "user_id": 690061, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2aa0c6735cd7fd6285a009556e8f764f?s=128&d=identicon&r=PG", "display_name": "Jimmy Lu", "link": "https://stackoverflow.com/users/690061/jimmy-lu"}, "edited": false, "score": 12, "creation_date": 1424275052, "post_id": 28587902, "comment_id": 45482808, "body": "I see. I guess it&#39;s like in C++ where you can have <code>int const*</code> vs. <code>int *const</code> to achieve different things."}, {"owner": {"reputation": 3313, "user_id": 1535283, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca8a8e4326ecde562aad35781a0e4e2a?s=128&d=identicon&r=PG", "display_name": "Scott Olson", "link": "https://stackoverflow.com/users/1535283/scott-olson"}, "edited": false, "score": 4, "creation_date": 1424275140, "post_id": 28587902, "comment_id": 45482871, "body": "@Shepmaster You might want to add that <code>mut</code> on a binding allows you to mutate inside the structure (if it is a struct)."}, {"owner": {"reputation": 3970, "user_id": 690061, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2aa0c6735cd7fd6285a009556e8f764f?s=128&d=identicon&r=PG", "display_name": "Jimmy Lu", "link": "https://stackoverflow.com/users/690061/jimmy-lu"}, "edited": false, "score": 0, "creation_date": 1424275174, "post_id": 28587902, "comment_id": 45482897, "body": "I guess it stands out to me why rust doesn&#39;t seem to allow the syntax <code>let foo: mut Type</code>? It seems that since we already have the inevitable <code>&amp; mut</code> in which <code>mut</code> can&#39;t appear on the left hand side, it&#39;s more uniform to say that <code>mut</code> can only appear on the right hand side?"}, {"owner": {"reputation": 3970, "user_id": 690061, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2aa0c6735cd7fd6285a009556e8f764f?s=128&d=identicon&r=PG", "display_name": "Jimmy Lu", "link": "https://stackoverflow.com/users/690061/jimmy-lu"}, "reply_to_user": {"reputation": 3313, "user_id": 1535283, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca8a8e4326ecde562aad35781a0e4e2a?s=128&d=identicon&r=PG", "display_name": "Scott Olson", "link": "https://stackoverflow.com/users/1535283/scott-olson"}, "edited": false, "score": 0, "creation_date": 1424275300, "post_id": 28587902, "comment_id": 45482974, "body": "@ScottOlson, can you please elaborate or point me to a source to explain the <code>mut</code> binding before a structure?"}, {"owner": {"reputation": 3313, "user_id": 1535283, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca8a8e4326ecde562aad35781a0e4e2a?s=128&d=identicon&r=PG", "display_name": "Scott Olson", "link": "https://stackoverflow.com/users/1535283/scott-olson"}, "reply_to_user": {"reputation": 3970, "user_id": 690061, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2aa0c6735cd7fd6285a009556e8f764f?s=128&d=identicon&r=PG", "display_name": "Jimmy Lu", "link": "https://stackoverflow.com/users/690061/jimmy-lu"}, "edited": false, "score": 8, "creation_date": 1424275359, "post_id": 28587902, "comment_id": 45483016, "body": "@BeyondSora Don&#39;t think of <code>&amp;mut Type</code> as <code>&amp;(mut Type)</code>, but as <code>(&amp;mut) Type</code>. The keyword <code>mut</code> isn&#39;t used in types in general, but there is a type of reference called <code>&amp;mut</code>."}, {"owner": {"reputation": 3313, "user_id": 1535283, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca8a8e4326ecde562aad35781a0e4e2a?s=128&d=identicon&r=PG", "display_name": "Scott Olson", "link": "https://stackoverflow.com/users/1535283/scott-olson"}, "reply_to_user": {"reputation": 3970, "user_id": 690061, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2aa0c6735cd7fd6285a009556e8f764f?s=128&d=identicon&r=PG", "display_name": "Jimmy Lu", "link": "https://stackoverflow.com/users/690061/jimmy-lu"}, "edited": false, "score": 2, "creation_date": 1424275511, "post_id": 28587902, "comment_id": 45483124, "body": "@BeyondSora You can see the latest edit of the above answer. The basic explanation is when you can mutate a structure, you can mutate as far into the structure as you want (its fields, its fields&#39; fields, etc). There are no <code>const</code> fields. This is safe since Rust guarantees when you can mutate something, no one else can read or mutate it at the same time."}, {"owner": {"reputation": 14069, "user_id": 1769720, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5815db653a13a7122066f811caa020a7?s=128&d=identicon&r=PG", "display_name": "didierc", "link": "https://stackoverflow.com/users/1769720/didierc"}, "reply_to_user": {"reputation": 3313, "user_id": 1535283, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca8a8e4326ecde562aad35781a0e4e2a?s=128&d=identicon&r=PG", "display_name": "Scott Olson", "link": "https://stackoverflow.com/users/1535283/scott-olson"}, "edited": false, "score": 1, "creation_date": 1424289848, "post_id": 28587902, "comment_id": 45492238, "body": "@ScottOlson So, what you&#39;re saying is that <code>&amp;mut</code> is just a &quot;convenient&quot; notation to avoid introducing a new keyword, but actually it is a different concept from the lhs usual <code>mut</code> keyword ?"}, {"owner": {"reputation": 3313, "user_id": 1535283, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca8a8e4326ecde562aad35781a0e4e2a?s=128&d=identicon&r=PG", "display_name": "Scott Olson", "link": "https://stackoverflow.com/users/1535283/scott-olson"}, "reply_to_user": {"reputation": 14069, "user_id": 1769720, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5815db653a13a7122066f811caa020a7?s=128&d=identicon&r=PG", "display_name": "didierc", "link": "https://stackoverflow.com/users/1769720/didierc"}, "edited": false, "score": 2, "creation_date": 1424296593, "post_id": 28587902, "comment_id": 45496026, "body": "@didierc Yeah. You can think of <code>&amp;T</code> and <code>&amp;mut T</code> as sugar for <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> (types I just made up)."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 94, "last_activity_date": 1424275724, "last_edit_date": 1424275724, "creation_date": 1424274883, "answer_id": 28587902, "question_id": 28587698, "link": "https://stackoverflow.com/questions/28587698/whats-the-difference-between-placing-mut-before-a-variable-name-and-after-the/28587902#28587902", "title": "What&#39;s the difference between placing &quot;mut&quot; before a variable name and after the &quot;:&quot;?", "body": "<p><code>mut foo: T</code> means you have a variable called <code>foo</code> that is a <code>T</code>. You are allowed to change what the variable <strong>refers to</strong>:</p>\n\n<pre><code>let mut val1 = 2;\nval1 = 3; // OK\n\nlet val2 = 2;\nval2 = 3; // error: re-assignment of immutable variable\n</code></pre>\n\n<p>This also lets you modify fields of a struct that you own:</p>\n\n<pre><code>struct Monster { health: u8 }\n\nlet mut orc = Monster { health: 93 };\norc.health -= 54;\n\nlet goblin = Monster { health: 28 };\ngoblin.health += 10; // error: cannot assign to immutable field\n</code></pre>\n\n<p><code>foo: &amp;mut T</code> means you have a variable that refers to (<code>&amp;</code>) a value and you are allowed to change (<code>mut</code>) the <strong>referred value</strong> (including fields, if it is a struct):</p>\n\n<pre><code>let val1 = &amp;mut 2;\n*val1 = 3; // OK\n\nlet val2 = &amp;2;\n*val2 = 3; // error: cannot assign to immutable borrowed content\n</code></pre>\n\n<p>Note that <code>&amp;mut</code> only makes sense with a reference - <code>foo: mut T</code> is not valid syntax. You can also combine the two qualifiers (<code>let mut a: &amp;mut T</code>), when it makes sense.</p>\n"}, {"comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 4, "creation_date": 1570827831, "post_id": 29682542, "comment_id": 103051960, "body": "This is a great table. It may be worthwhile to note that <code>&amp;mut T</code> references are also analogous to <code>T* restrict</code> pointers in C: they may not be aliased. <code>&amp;T</code> references have no such constraint and there is no reference type analogous to non-<code>restrict</code>-qualified <code>T*</code> pointers."}, {"owner": {"reputation": 90, "user_id": 5363171, "user_type": "registered", "profile_image": "https://lh5.googleusercontent.com/-ObJu-LwAsUw/AAAAAAAAAAI/AAAAAAAADMI/tQOah-HwGVM/photo.jpg?sz=128", "display_name": "kres0345", "link": "https://stackoverflow.com/users/5363171/kres0345"}, "edited": false, "score": 1, "creation_date": 1602337209, "post_id": 29682542, "comment_id": 113691433, "body": "I don&#39;t have a C background, but I still think this explains it better (with the comments) as opposed to the accepted answer, sometimes simpler is better than longer."}], "tags": [], "owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "is_accepted": false, "score": 103, "last_activity_date": 1432477112, "last_edit_date": 1432477112, "creation_date": 1429207102, "answer_id": 29682542, "question_id": 28587698, "link": "https://stackoverflow.com/questions/28587698/whats-the-difference-between-placing-mut-before-a-variable-name-and-after-the/29682542#29682542", "title": "What&#39;s the difference between placing &quot;mut&quot; before a variable name and after the &quot;:&quot;?", "body": "<p>If you're coming from C/C++, it might also be helpful to think of it basically like this:</p>\n\n<pre><code>// Rust          C/C++\n    a: &amp;T     == const T* const a; // can't mutate either\nmut a: &amp;T     == const T* a;       // can't mutate what is pointed to\n    a: &amp;mut T == T* const a;       // can't mutate pointer\nmut a: &amp;mut T == T* a;             // can mutate both\n</code></pre>\n\n<p>You'll notice that these are inverses of each other. C/C++ take a \"blacklist\" approach, where if you want something to be immutable you have to say so explicitly, while Rust takes a \"whitelist\" approach, where if you want something to be mutable you have to say so explicitly.</p>\n"}], "owner": {"reputation": 3970, "user_id": 690061, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2aa0c6735cd7fd6285a009556e8f764f?s=128&d=identicon&r=PG", "display_name": "Jimmy Lu", "link": "https://stackoverflow.com/users/690061/jimmy-lu"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 10860, "favorite_count": 27, "accepted_answer_id": 28587902, "answer_count": 2, "score": 87, "last_activity_date": 1552906896, "creation_date": 1424274414, "last_edit_date": 1552906896, "question_id": 28587698, "link": "https://stackoverflow.com/questions/28587698/whats-the-difference-between-placing-mut-before-a-variable-name-and-after-the", "title": "What&#39;s the difference between placing &quot;mut&quot; before a variable name and after the &quot;:&quot;?", "body": "<p>Here are two function signatures I saw in the Rust documentation:</p>\n\n<pre><code>fn modify_foo(mut foo: Box&lt;i32&gt;) { *foo += 1; *foo }\nfn modify_foo(foo: &amp;mut i32) { *foo += 1; *foo }\n</code></pre>\n\n<p>Why the different placement of <code>mut</code>?</p>\n\n<p>It seems that the first function could also be declared as</p>\n\n<pre><code>fn modify_foo(foo: mut Box&lt;i32&gt;) { /* ... */ }\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "edited": false, "score": 1, "creation_date": 1424270538, "post_id": 28581903, "comment_id": 45479802, "body": "A really cool project is <a href=\"https://github.com/brson/multirust\" rel=\"nofollow noreferrer\">multirust</a> - it allows you to have multiple versions of rust installed (nightly, alpha, (the future) beta, custom-built), pings you when new versions of the nightlies are out, and automates the update process (<code>multirust update nightly</code>)"}], "answers": [{"comments": [{"owner": {"reputation": 4733, "user_id": 1068497, "user_type": "registered", "accept_rate": 84, "profile_image": "https://www.gravatar.com/avatar/32c20ce344a5b5edf654c9bdfb61b947?s=128&d=identicon&r=PG", "display_name": "swang", "link": "https://stackoverflow.com/users/1068497/swang"}, "edited": false, "score": 0, "creation_date": 1424303373, "post_id": 28586285, "comment_id": 45498943, "body": "thanks, installed nightly from the site, having fun right now."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1424270404, "creation_date": 1424270404, "answer_id": 28586285, "question_id": 28581903, "link": "https://stackoverflow.com/questions/28581903/should-i-use-rust-1-0-alpha-or-the-nightly-version/28586285#28586285", "title": "Should I use Rust 1.0-alpha or the nightly version?", "body": "<p>Start now, and use the nightlies as suggested by Dietrich. The biggest conceptual chunks of the language (such as lifetimes and ownership) are extremely unlikely to change between now and 1.0-beta or 1.0. The biggest \"issues\" you will experience will be with the standard library - what features it exposes and how. At worst, that means you have to change some code and read a changelog each time you update the compiler.</p>\n\n<p>As for how to install it, homebrew has a <code>--head</code> option you can use to install the newest code. You may just want to download the version from the website though or use rustup.sh.</p>\n"}], "owner": {"reputation": 4733, "user_id": 1068497, "user_type": "registered", "accept_rate": 84, "profile_image": "https://www.gravatar.com/avatar/32c20ce344a5b5edf654c9bdfb61b947?s=128&d=identicon&r=PG", "display_name": "swang", "link": "https://stackoverflow.com/users/1068497/swang"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 343, "favorite_count": 0, "accepted_answer_id": 28586285, "answer_count": 1, "score": 2, "last_activity_date": 1424270404, "creation_date": 1424257144, "last_edit_date": 1424270154, "question_id": 28581903, "link": "https://stackoverflow.com/questions/28581903/should-i-use-rust-1-0-alpha-or-the-nightly-version", "title": "Should I use Rust 1.0-alpha or the nightly version?", "body": "<p>Just started learning Rust. On Wikipedia it says pre-alpha stable version is not recommended because the language moves fast. But is 1.0-alpha stable now to use for learning?</p>\n\n<p>I wanted to install Rust using homebrew on mac, but it only has the 1.0-alpha version.</p>\n"}, {"tags": ["debugging", "rust", "rust-macros", "rust-proc-macros", "rust-decl-macros"], "answers": [{"comments": [{"owner": {"reputation": 696, "user_id": 8159982, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/vhr5o.jpg?s=128&g=1", "display_name": "lncr", "link": "https://stackoverflow.com/users/8159982/lncr"}, "edited": false, "score": 7, "creation_date": 1502273001, "post_id": 28580527, "comment_id": 78133711, "body": "As of 1.19 this command <code>cargo rustc -- -Z unstable-options --pretty=expanded</code> is now only available on nightly."}, {"owner": {"reputation": 400, "user_id": 716769, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/448f9df88102c83808f2cf401ecc1b51?s=128&d=identicon&r=PG", "display_name": "Bogdan Mart", "link": "https://stackoverflow.com/users/716769/bogdan-mart"}, "edited": false, "score": 2, "creation_date": 1548289702, "post_id": 28580527, "comment_id": 95492442, "body": "Why it&#39;s only in nightly?("}, {"owner": {"reputation": 2131, "user_id": 2343935, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/li569.png?s=128&g=1", "display_name": "grooveplex", "link": "https://stackoverflow.com/users/2343935/grooveplex"}, "reply_to_user": {"reputation": 400, "user_id": 716769, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/448f9df88102c83808f2cf401ecc1b51?s=128&d=identicon&r=PG", "display_name": "Bogdan Mart", "link": "https://stackoverflow.com/users/716769/bogdan-mart"}, "edited": false, "score": 1, "creation_date": 1564423708, "post_id": 28580527, "comment_id": 101017780, "body": "@BogdanMart Because it uses an unstable option, but fear not, you can easily use it. Run <code>rustup install nightly</code>, then <code>rustup run nightly cargo rustc -- -Z unstable-options --pretty=expanded</code>."}, {"owner": {"reputation": 865, "user_id": 318902, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/bd1abbefb37e6a91831bbc1ac7279456?s=128&d=identicon&r=PG", "display_name": "jhfrontz", "link": "https://stackoverflow.com/users/318902/jhfrontz"}, "edited": false, "score": 4, "creation_date": 1590786555, "post_id": 28580527, "comment_id": 109823790, "body": "So, for three (and counting) years, this capability has never been &quot;stabilized&quot;?"}, {"owner": {"reputation": 1332, "user_id": 7315204, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fbd675da0a10035c13697fbfa2f309ed?s=128&d=identicon&r=PG&f=1", "display_name": "Tumbleweed53", "link": "https://stackoverflow.com/users/7315204/tumbleweed53"}, "edited": false, "score": 0, "creation_date": 1609784201, "post_id": 28580527, "comment_id": 115925107, "body": "Likely less about stabilization and more that they don&#39;t want to commit to supporting it."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 49, "last_activity_date": 1435323254, "last_edit_date": 1435323254, "creation_date": 1424253223, "answer_id": 28580527, "question_id": 28580386, "link": "https://stackoverflow.com/questions/28580386/how-do-i-see-the-expanded-macro-code-thats-causing-my-compile-error/28580527#28580527", "title": "How do I see the expanded macro code that&#39;s causing my compile error?", "body": "<p>Yes, you can pass a special flag to <code>rustc</code>, called <code>--pretty=expanded</code>:</p>\n\n<pre><code>% cat test.rs\nfn main() {\n    println!(\"Hello world\");\n}\n% rustc -Z unstable-options --pretty=expanded test.rs\n#![feature(no_std)]\n#![no_std]\n#[prelude_import]\nuse std::prelude::v1::*;\n#[macro_use]\nextern crate \"std\" as std;\nfn main() {\n    ::std::old_io::stdio::println_args(::std::fmt::Arguments::new_v1({\n                                                                         static __STATIC_FMTSTR:\n                                                                                &amp;'static [&amp;'static str]\n                                                                                =\n                                                                             &amp;[\"Hello world\"];\n                                                                         __STATIC_FMTSTR\n                                                                     },\n                                                                     &amp;match ()\n                                                                          {\n                                                                          ()\n                                                                          =&gt;\n                                                                          [],\n                                                                      }));\n}\n</code></pre>\n\n<p>You need to allow it first, however, by passing <code>-Z unstable-options</code>.</p>\n\n<p>Since Rust 1.1 you can pass these arguments to Cargo, like this:</p>\n\n<pre><code>cargo rustc -- -Z unstable-options --pretty=expanded\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 730, "user_id": 3283003, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/969f644f75512332a20f0ea1ff6e64d0?s=128&d=identicon&r=PG&f=1", "display_name": "Squirrel", "link": "https://stackoverflow.com/users/3283003/squirrel"}, "edited": false, "score": 0, "creation_date": 1587884646, "post_id": 37639012, "comment_id": 108680523, "body": "cargo install cargo-expand \u2014features=prettyprint/regex-fancy will be slightly slower but avoids a c++ dependency so is more likely to build cleanly."}, {"owner": {"reputation": 6357, "user_id": 6086311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cb99289473f6393b89474785f2d294d1?s=128&d=identicon&r=PG", "display_name": "dtolnay", "link": "https://stackoverflow.com/users/6086311/dtolnay"}, "reply_to_user": {"reputation": 730, "user_id": 3283003, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/969f644f75512332a20f0ea1ff6e64d0?s=128&d=identicon&r=PG&f=1", "display_name": "Squirrel", "link": "https://stackoverflow.com/users/3283003/squirrel"}, "edited": false, "score": 0, "creation_date": 1587891646, "post_id": 37639012, "comment_id": 108682435, "body": "cargo-expand does not depend on prettyprint or any C++ dependencies."}], "tags": [], "owner": {"reputation": 6357, "user_id": 6086311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cb99289473f6393b89474785f2d294d1?s=128&d=identicon&r=PG", "display_name": "dtolnay", "link": "https://stackoverflow.com/users/6086311/dtolnay"}, "is_accepted": true, "score": 72, "last_activity_date": 1599590784, "last_edit_date": 1599590784, "creation_date": 1465107054, "answer_id": 37639012, "question_id": 28580386, "link": "https://stackoverflow.com/questions/28580386/how-do-i-see-the-expanded-macro-code-thats-causing-my-compile-error/37639012#37639012", "title": "How do I see the expanded macro code that&#39;s causing my compile error?", "body": "<p><code>cargo rustc -- -Zunstable-options --pretty=expanded</code>, but a more concise alternative is the <a href=\"https://github.com/dtolnay/cargo-expand\" rel=\"noreferrer\">cargo-expand</a> crate. It provides a Cargo subcommand <code>cargo expand</code> which prints the result of macro expansion. It also passes the expanded code through <a href=\"https://github.com/rust-lang/rustfmt\" rel=\"noreferrer\"><code>rustfmt</code></a> which generally results in much more readable code than the default output from rustc.</p>\n<p>Install by running <code>cargo install cargo-expand</code>.</p>\n"}], "owner": {"reputation": 5549, "user_id": 775982, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/87058ec6a2d1628e392fc444e8c159df?s=128&d=identicon&r=PG", "display_name": "Caspar", "link": "https://stackoverflow.com/users/775982/caspar"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 17531, "favorite_count": 15, "accepted_answer_id": 37639012, "answer_count": 2, "score": 60, "last_activity_date": 1614627381, "creation_date": 1424252840, "last_edit_date": 1614627381, "question_id": 28580386, "link": "https://stackoverflow.com/questions/28580386/how-do-i-see-the-expanded-macro-code-thats-causing-my-compile-error", "title": "How do I see the expanded macro code that&#39;s causing my compile error?", "body": "<p>I have a compile error involving a macro:</p>\n\n<pre><code>&lt;mdo macros&gt;:6:19: 6:50 error: cannot move out of captured outer variable in an `FnMut` closure\n&lt;mdo macros&gt;:6 bind ( $ e , move | $ p | mdo ! { $ ( $ t ) * } ) ) ; (\n                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n&lt;mdo macros&gt;:1:1: 14:36 note: in expansion of mdo!\n&lt;mdo macros&gt;:6:27: 6:50 note: expansion site\n&lt;mdo macros&gt;:1:1: 14:36 note: in expansion of mdo!\n&lt;mdo macros&gt;:6:27: 6:50 note: expansion site\n&lt;mdo macros&gt;:1:1: 14:36 note: in expansion of mdo!\nsrc/parser.rs:30:42: 37:11 note: expansion site\nerror: aborting due to previous error\n</code></pre>\n\n<p>Unfortunately, the macro is recursive so it's hard to figure out what the compiler is complaining about, plus it seems like the line numbers are for the expanded macro rather than my code.</p>\n\n<p>How can I see the expanded macro? Is there a flag I can pass to rustc (or even better, cargo) to dump this out?</p>\n\n<p>(This macro is from <a href=\"https://github.com/TeXitoi/rust-mdo\">rust-mdo</a>, though I don't think it matters.)</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424224646, "post_id": 28574458, "comment_id": 45458707, "body": "Welcome to Stack Overflow! To get the best quality answers, and maybe to help you understand your problem better, please take some time on future questions to make a <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a>. <a href=\"http://is.gd/YP5Vol\" rel=\"nofollow noreferrer\">Here is one</a> that I&#39;m currently working on making smaller, as an example."}, {"owner": {"reputation": 23, "user_id": 4577686, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/rYzPP.jpg?s=128&g=1", "display_name": "nogoma", "link": "https://stackoverflow.com/users/4577686/nogoma"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424289022, "post_id": 28574458, "comment_id": 45491714, "body": "@Shepmaster Thanks for the tip; I tried to make my snippet as minimal as possible, but as I wasn&#39;t sure what my issue was, I had a hard time trimming it to the bare essentials. BTW, I&#39;ve seen many of your answers for rust questions on SO, and they&#39;ve always been informative. Thanks!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424289829, "post_id": 28574458, "comment_id": 45492223, "body": "No worries, I know that making minimal examples can be hard! I just keep reminding people whenever possible. ^_^"}], "answers": [{"comments": [{"owner": {"reputation": 23, "user_id": 4577686, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/rYzPP.jpg?s=128&g=1", "display_name": "nogoma", "link": "https://stackoverflow.com/users/4577686/nogoma"}, "edited": false, "score": 0, "creation_date": 1424289250, "post_id": 28574642, "comment_id": 45491838, "body": "Both your explanations really helped my understanding of lifetimes; for my needs, I was unnecessarily tying it to the <code>IntoKey</code> trait. But your alternative solution for cases where <code>IntoKey</code> might need the lifetime constraint was very instructive; I hadn&#39;t understood the restriction I was putting on the <code>key</code> argument to <code>get</code>."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 0, "last_activity_date": 1424225364, "last_edit_date": 1424225364, "creation_date": 1424224313, "answer_id": 28574642, "question_id": 28574458, "link": "https://stackoverflow.com/questions/28574458/how-can-i-explicitly-specify-a-lifetime-when-implementing-a-trait/28574642#28574642", "title": "How can I explicitly specify a lifetime when implementing a trait?", "body": "<p>Do you intend on implementing <code>IntoKey</code> on struct's that are going to store references of lifetime <code>'a</code>? If not, you can change your trait and its implementations to:</p>\n\n<pre><code>trait IntoKey {\n    fn into_key&lt;'a&gt;(&amp;'a self) -&gt; Key&lt;'a&gt;;\n}\n</code></pre>\n\n<p>This is the generally recommended definition style, if you can use it. If you can't...</p>\n\n<p>Let's look at this smaller reproduction:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::ops::Index;\n\nstruct Key&lt;'a&gt;(&amp;'a u8);\n\ntrait IntoKey&lt;'a&gt; { //'\n    fn into_key(&amp;'a self) -&gt; Key&lt;'a&gt;;\n}\n\nstruct MapCollection;\n\nimpl MapCollection {\n    fn get&lt;'a, K&gt;(&amp;self, key: &amp;'a K) -&gt; &amp;u8\n        where K: IntoKey&lt;'a&gt; //'\n    {\n        unimplemented!()\n    }\n}\n\nimpl&lt;'a, K&gt; Index&lt;K&gt; for MapCollection //'\n    where K: IntoKey&lt;'a&gt; //'\n{\n    type Output = u8;\n\n    fn index&lt;'b&gt;(&amp;'b self, k: &amp;K) -&gt; &amp;'b u8 { //'\n        self.get(k)\n    }\n}\n\nfn main() {\n}\n</code></pre>\n\n<p>The problem lies in <code>get</code>:</p>\n\n<pre><code>fn get&lt;'a, K&gt;(&amp;self, key: &amp;'a K) -&gt; &amp;u8\n    where K: IntoKey&lt;'a&gt;\n</code></pre>\n\n<p>Here, we are taking a reference to <code>K</code> that must <em>live as long as</em> the <code>Key</code> we get out of it. However, the Index trait doesn't guarantee that:</p>\n\n<pre><code>fn index&lt;'b&gt;(&amp;'b self, k: &amp;K) -&gt; &amp;'b u8\n</code></pre>\n\n<p>You can fix this by simply giving a fresh lifetime to <code>key</code>:</p>\n\n<pre><code>fn get&lt;'a, 'b, K&gt;(&amp;self, key: &amp;'b K) -&gt; &amp;u8\n    where K: IntoKey&lt;'a&gt;\n</code></pre>\n\n<p>Or more succinctly:</p>\n\n<pre><code>fn get&lt;'a, K&gt;(&amp;self, key: &amp;K) -&gt; &amp;u8\n    where K: IntoKey&lt;'a&gt;\n</code></pre>\n"}], "owner": {"reputation": 23, "user_id": 4577686, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/rYzPP.jpg?s=128&g=1", "display_name": "nogoma", "link": "https://stackoverflow.com/users/4577686/nogoma"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 202, "favorite_count": 0, "accepted_answer_id": 28574642, "answer_count": 1, "score": 2, "last_activity_date": 1424225364, "creation_date": 1424223228, "question_id": 28574458, "link": "https://stackoverflow.com/questions/28574458/how-can-i-explicitly-specify-a-lifetime-when-implementing-a-trait", "title": "How can I explicitly specify a lifetime when implementing a trait?", "body": "<p>Given the implementation below, where essentially I have some collection of items that can be looked up via either a i32 id field or a string field. To be able to use either interchangeably, a trait \"IntoKey\" is used, and a <code>match</code> dispatches to the appropriate lookup map; this all works fine for my definition of <code>get</code> within the <code>MapCollection</code> impl:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::ops::Index;\n\nenum Key&lt;'a&gt; {\n    I32Key(&amp;'a i32),\n    StringKey(&amp;'a String),\n}\n\ntrait IntoKey&lt;'a&gt; {\n    fn into_key(&amp;'a self) -&gt; Key&lt;'a&gt;;\n}\n\nimpl&lt;'a&gt; IntoKey&lt;'a&gt; for i32 {\n    fn into_key(&amp;'a self) -&gt; Key&lt;'a&gt; { Key::I32Key(self) }\n}\n\nimpl&lt;'a&gt; IntoKey&lt;'a&gt; for String {\n    fn into_key(&amp;'a self) -&gt; Key&lt;'a&gt; { Key::StringKey(self) }\n}\n\n#[derive(Debug)]\nstruct Bar {\n    i: i32,\n    n: String,\n}\n\nstruct MapCollection\n{\n    items: Vec&lt;Bar&gt;,\n    id_map: HashMap&lt;i32, usize&gt;,\n    name_map: HashMap&lt;String, usize&gt;,\n}\n\nimpl MapCollection {\n    fn new(items: Vec&lt;Bar&gt;) -&gt; MapCollection {\n        let mut is = HashMap::new();\n        let mut ns = HashMap::new();\n        for (idx, item) in items.iter().enumerate() {\n            is.insert(item.i, idx);\n            ns.insert(item.n.clone(), idx);\n        }\n        MapCollection {\n            items: items,\n            id_map: is,\n            name_map: ns,\n        }\n    }\n\n    fn get&lt;'a, K&gt;(&amp;self, key: &amp;'a K) -&gt; Option&lt;&amp;Bar&gt;\n        where K: IntoKey&lt;'a&gt; //'\n    {\n        match key.into_key() {\n            Key::I32Key(i)    =&gt; self.id_map.get(i).and_then(|idx|     self.items.get(*idx)),\n            Key::StringKey(s) =&gt; self.name_map.get(s).and_then(|idx|     self.items.get(*idx)),\n        }\n    }\n}\n\nfn main() {\n    let bars = vec![Bar { i:1, n:\"foo\".to_string() }, Bar { i:2, n:\"far\".to_string() }];\n    let map = MapCollection::new(bars);\n    if let Some(bar) = map.get(&amp;1) {\n        println!(\"{:?}\", bar);\n    }\n    if map.get(&amp;3).is_none() {\n        println!(\"no item numbered 3\");\n    }\n    if let Some(bar) = map.get(&amp;\"far\".to_string()) {\n        println!(\"{:?}\", bar);\n    }\n    if map.get(&amp;\"baz\".to_string()).is_none() {\n        println!(\"no item named baz\");\n    }\n}\n</code></pre>\n\n<p>However, if I then want to implement <code>std::ops::Index</code> for this struct, if I attempt to do the below:</p>\n\n<pre><code>impl&lt;'a, K&gt; Index&lt;K&gt; for MapCollection\nwhere K: IntoKey&lt;'a&gt; {\n    type Output = Bar;\n\n    fn index&lt;'b&gt;(&amp;'b self, k: &amp;K) -&gt; &amp;'b Bar {\n        self.get(k).expect(\"no element\")\n    }\n}\n</code></pre>\n\n<p>I hit a compiler error:</p>\n\n<pre><code>src/main.rs:70:18: 70:19 error: cannot infer an appropriate lifetime for automatic coercion due to conflicting requirements\nsrc/main.rs:70         self.get(k).expect(\"no element\")\n                            ^\nsrc/main.rs:69:5: 71:6 help: consider using an explicit lifetime parameter as shown: fn index&lt;'b&gt;(&amp;'b self, k: &amp;'a K) -&gt; &amp;'b Bar\nsrc/main.rs:69     fn index&lt;'b&gt;(&amp;'b self, k: &amp;K) -&gt; &amp;'b Bar {\nsrc/main.rs:70         self.get(k).expect(\"no element\")\nsrc/main.rs:71     }\n</code></pre>\n\n<p>I can find no way to specify a distinct lifetime here; following the compiler's recommendation is not permitted as it changes the function signature and no longer matches the trait, and anything else I try fails to satisfy the lifetime specification.</p>\n\n<p>I understand that I can implement the trait for each case (i32, String) separately instead of trying to implement it once for IntoKey, but I am more generally trying to understand lifetimes and appropriate usage. Essentially:</p>\n\n<ul>\n<li>Is there actually an issue the compiler is preventing? Is there something unsound about this approach?</li>\n<li>Am I specifying my lifetimes incorrectly? To me, the lifetime <code>'a</code> in Key/IntoKey is dictating that the reference need only live long enough to do the lookup; the lifetime <code>'b</code> associated with the <code>index</code> fn is stating that the reference resulting from the lookup will live as long as the containing <code>MapCollection</code>.</li>\n<li>Or am I simply not utilizing the correct syntax to specify the needed information?</li>\n</ul>\n\n<p>(using <code>rustc 1.0.0-nightly (b63cee4a1 2015-02-14 17:01:11 +0000)</code>)</p>\n"}, {"tags": ["rust", "optional"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 50, "last_activity_date": 1546388591, "last_edit_date": 1546388591, "creation_date": 1424211388, "answer_id": 28572170, "question_id": 28572101, "link": "https://stackoverflow.com/questions/28572101/what-is-a-clean-way-to-convert-a-result-into-an-option/28572170#28572170", "title": "What is a clean way to convert a Result into an Option?", "body": "<p>Use <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html#method.ok\" rel=\"noreferrer\"><code>Result::ok</code></a>. Types added for clarity:</p>\n\n<pre><code>let res: Result&lt;u8, ()&gt; = Ok(42);\nlet opt: Option&lt;u8&gt; = res.ok();\nprintln!(\"{:?}\", opt);\n</code></pre>\n\n<p>For symmetry's sake, there's also <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or\" rel=\"noreferrer\"><code>Option::ok_or</code></a> and <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else\" rel=\"noreferrer\"><code>Option::ok_or_else</code></a> to go from an <code>Option</code> to a <code>Result</code>.</p>\n\n<hr>\n\n<p>In your case, you have an iterator. </p>\n\n<p>If you'd like to <em>ignore</em> failures, use <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map\" rel=\"noreferrer\"><code>Iterator::flat_map</code></a>. Since <code>Result</code> (and <code>Option</code>) implement <code>IntoIterator</code>, this works:</p>\n\n<pre><code>let parsed_value: Vec&lt;usize&gt; = val\n    .iter()\n    .flat_map(|e| e.parse())\n    .collect();\n</code></pre>\n\n<p>If you'd like to stop on the first failure, you can <code>collect</code> into one big <code>Result</code>. This is less obvious, but you can check out the implementors of <a href=\"https://doc.rust-lang.org/std/iter/trait.FromIterator.html#impl-FromIterator%3CResult%3CA%2C%20E%3E%3E\" rel=\"noreferrer\"><code>FromIterator</code></a> for the full list of <code>collect</code>-able items.</p>\n\n<pre><code>let parsed_value: Result&lt;Vec&lt;usize&gt;, _&gt; = val\n    .iter()\n    .map(|e| e.parse())\n    .collect();\n</code></pre>\n\n<p>Of course, you can then convert the one big <code>Result</code> into an <code>Option</code>, as the first example shows.</p>\n"}], "owner": {"reputation": 10805, "user_id": 262956, "user_type": "registered", "accept_rate": 97, "profile_image": "https://www.gravatar.com/avatar/7515cb5c8df2d07f6d3780346ec0da92?s=128&d=identicon&r=PG", "display_name": "vise", "link": "https://stackoverflow.com/users/262956/vise"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 14418, "favorite_count": 2, "accepted_answer_id": 28572170, "answer_count": 1, "score": 32, "last_activity_date": 1546388591, "creation_date": 1424211147, "last_edit_date": 1546388269, "question_id": 28572101, "link": "https://stackoverflow.com/questions/28572101/what-is-a-clean-way-to-convert-a-result-into-an-option", "title": "What is a clean way to convert a Result into an Option?", "body": "<p>Before updating to a more recent Rust version the following used to work:</p>\n\n<pre><code>fn example(val: &amp;[&amp;str]) {\n    let parsed_value: Vec&lt;usize&gt; = val\n        .iter()\n        .filter_map(|e| e.parse::&lt;usize&gt;())\n        .collect();\n}\n</code></pre>\n\n<p>However, now the parse method returns a <code>Result</code> type instead of an <code>Option</code> and I get the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; src/lib.rs:4:25\n  |\n4 |         .filter_map(|e| e.parse::&lt;usize&gt;())\n  |                         ^^^^^^^^^^^^^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n  |\n  = note: expected type `std::option::Option&lt;_&gt;`\n             found type `std::result::Result&lt;usize, std::num::ParseIntError&gt;`\n</code></pre>\n\n<p>I could create an <code>Option</code> through a conditional, but is there a better / cleaner way?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user3542327"}, "edited": false, "score": 0, "creation_date": 1424197165, "post_id": 28568263, "comment_id": 45446754, "body": "Yes, but there&#39;s no point in compiling the rust compiler with a downloaded rust compiler"}, {"owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "edited": false, "score": 1, "creation_date": 1424197274, "post_id": 28568263, "comment_id": 45446803, "body": "@joris_van_winden: Actually that is the only way to build the Rust compiler, as it is written in Rust. The thing is that you can build the latest version of the Rust compiler using an older one. It is not different with the GCC, it is written in C so you need a C compiler (C++ in newer versions) to build it."}], "answers": [{"comments": [{"owner": {"reputation": 6794, "user_id": 412808, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/3daaea0ebce68c00202f395eb796724c?s=128&d=identicon&r=PG", "display_name": "Giacomo Tesio", "link": "https://stackoverflow.com/users/412808/giacomo-tesio"}, "edited": false, "score": 0, "creation_date": 1424197518, "post_id": 28568341, "comment_id": 45446936, "body": "So I could not use llvm-cbe (<a href=\"https://github.com/draperlaboratory/llvm-cbe\" rel=\"nofollow noreferrer\">github.com/draperlaboratory/llvm-cbe</a>) to compile rust to c an then port it to an os without a c++ compiler, right?"}, {"owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "reply_to_user": {"reputation": 6794, "user_id": 412808, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/3daaea0ebce68c00202f395eb796724c?s=128&d=identicon&r=PG", "display_name": "Giacomo Tesio", "link": "https://stackoverflow.com/users/412808/giacomo-tesio"}, "edited": false, "score": 2, "creation_date": 1424197661, "post_id": 28568341, "comment_id": 45447014, "body": "@GiacomoTesio: Well, you might succeed with that. But I think you have better chances cross-compiling Rust from a supported platform."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 6794, "user_id": 412808, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/3daaea0ebce68c00202f395eb796724c?s=128&d=identicon&r=PG", "display_name": "Giacomo Tesio", "link": "https://stackoverflow.com/users/412808/giacomo-tesio"}, "edited": false, "score": 0, "creation_date": 1424199714, "post_id": 28568341, "comment_id": 45448125, "body": "@GiacomoTesio The platform not having a C++ compiler is a bad reason, since both rustc and LLVM have good cross compilation support. The platform not having an LLVM backend would be a better reason, but I am very doubtful whether this would work well."}, {"owner": {"reputation": 6794, "user_id": 412808, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/3daaea0ebce68c00202f395eb796724c?s=128&d=identicon&r=PG", "display_name": "Giacomo Tesio", "link": "https://stackoverflow.com/users/412808/giacomo-tesio"}, "edited": false, "score": 0, "creation_date": 1424205361, "post_id": 28568341, "comment_id": 45451115, "body": "@delnan can you elaborate a bit about your doubts? Any link to previous experiences? The target platform I&#39;m considering doesn&#39;t have an LLVM backend."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 6794, "user_id": 412808, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/3daaea0ebce68c00202f395eb796724c?s=128&d=identicon&r=PG", "display_name": "Giacomo Tesio", "link": "https://stackoverflow.com/users/412808/giacomo-tesio"}, "edited": false, "score": 2, "creation_date": 1424247313, "post_id": 28568341, "comment_id": 45466051, "body": "@GiacomoTesio For starters, the C backend would have to perfectly map the semantics of the LLVM IR, with all important corner cases, to standard C, and your target C compiler must honor the standard flawlessly. That&#39;s already two big assumptions. Furthermore, LLVM IR is not at all portable: The sizes of data types, the ABI, and various other platform assumptions are baked into the IR generated by the frontend."}], "tags": [], "owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "is_accepted": true, "score": 25, "last_activity_date": 1424197136, "creation_date": 1424197136, "answer_id": 28568341, "question_id": 28568263, "link": "https://stackoverflow.com/questions/28568263/why-do-i-need-a-c-compiler-to-compile-rust/28568341#28568341", "title": "Why do I need a C++ compiler to compile Rust?", "body": "<p>It is actually a reasonable question. The answer is that currently, the rust source includes a slightly patched version of <a href=\"https://github.com/rust-lang/llvm\" rel=\"noreferrer\">LLVM</a>, LLVM is written in C++, and that is not distributed in binary form. So you need a C++ compiler to build that.</p>\n"}], "owner": {"reputation": 6794, "user_id": 412808, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/3daaea0ebce68c00202f395eb796724c?s=128&d=identicon&r=PG", "display_name": "Giacomo Tesio", "link": "https://stackoverflow.com/users/412808/giacomo-tesio"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5030, "favorite_count": 1, "accepted_answer_id": 28568341, "answer_count": 1, "score": 16, "last_activity_date": 1424201713, "creation_date": 1424196919, "last_edit_date": 1424201713, "question_id": 28568263, "link": "https://stackoverflow.com/questions/28568263/why-do-i-need-a-c-compiler-to-compile-rust", "title": "Why do I need a C++ compiler to compile Rust?", "body": "<p>This could be a very dumb question, but I'm wondering why the Rust compiler (written in Rust itself) require a C++ compiler. </p>\n\n<p>I mean, a precompiled Rust compiler from the distribution should be enough, shouldn't it?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "edited": false, "score": 0, "creation_date": 1424193154, "post_id": 28566648, "comment_id": 45444316, "body": "awesome, thanks so much for the examples and the pointer to <code>and_then</code>, which is exactly what I wanted as <code>flat_map</code>. Would there be a way to allow <code>flatten</code> to arbitrary depth, e.g., for <code>Some(Some(Some(Some(3))))</code>, or would we have to implement traits for each level?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "edited": false, "score": 0, "creation_date": 1424198446, "post_id": 28566648, "comment_id": 45447461, "body": "@kardeiz that&#39;s an interesting question. To my knowledge, there&#39;s no way of dealing with arbitrary nesting of types. I&#39;d suggest opening a new question, as I&#39;d like to see the answer myself. ^_^"}, {"owner": {"reputation": 1532, "user_id": 864340, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/6882d82dfb7f22be1157ea1586ab8e43?s=128&d=identicon&r=PG", "display_name": "Dylan", "link": "https://stackoverflow.com/users/864340/dylan"}, "edited": false, "score": 0, "creation_date": 1424215999, "post_id": 28566648, "comment_id": 45456075, "body": "@Shepmaster I&#39;m pretty sure that this would require <a href=\"https://github.com/rust-lang/rfcs/pull/586\" rel=\"nofollow noreferrer\">negative bounds</a> to implement, since you would need a trait that is implemented for all types, but treated specially for <code>Option</code>s."}, {"owner": {"reputation": 25982, "user_id": 305973, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/cd49db0b676767ea4358b1047c4cddd2?s=128&d=identicon&r=PG", "display_name": "robinst", "link": "https://stackoverflow.com/users/305973/robinst"}, "edited": false, "score": 0, "creation_date": 1424245644, "post_id": 28566648, "comment_id": 45465351, "body": "I also had trouble finding flatmap, that&#39;s why there&#39;s a pull request for including it in the documentation of <code>and_then</code>: <a href=\"https://github.com/rust-lang/rust/pull/22111\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/pull/22111</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1537618223, "last_edit_date": 1537618223, "creation_date": 1424191883, "answer_id": 28566648, "question_id": 28566531, "link": "https://stackoverflow.com/questions/28566531/how-to-implement-some-convenient-methods-e-g-flat-map-flatten-on-option/28566648#28566648", "title": "How to implement some convenient methods (e.g., flat_map, flatten) on Option?", "body": "<p>These probably already exist, just as different names to what you expect. Check the <a href=\"http://doc.rust-lang.org/std/option/enum.Option.html#\" rel=\"nofollow noreferrer\">docs for Option</a>.</p>\n\n<p>You'll see <code>flat_map</code> more normally as <code>and_then</code>:</p>\n\n<pre><code>let x = Some(1);\nlet y = x.and_then(|v| Some(v + 1));\n</code></pre>\n\n<p>The bigger way of doing what you want is to declare a <em>trait</em> with the methods you want, then implement it for <code>Option</code>:</p>\n\n<pre><code>trait MyThings {\n    fn more_optional(self) -&gt; Option&lt;Self&gt;;\n}\n\nimpl&lt;T&gt; MyThings for Option&lt;T&gt; {\n    fn more_optional(self) -&gt; Option&lt;Option&lt;T&gt;&gt; {\n        Some(self)\n    }\n}\n\nfn main() {\n    let x = Some(1);\n    let y = x.more_optional();\n    println!(\"{:?}\", y);\n}\n</code></pre>\n\n<p>For <code>flatten</code>, I'd probably write:</p>\n\n<pre><code>fn flatten&lt;T&gt;(opt: Option&lt;Option&lt;T&gt;&gt;) -&gt; Option&lt;T&gt; {\n    match opt {\n        None =&gt; None,\n        Some(v) =&gt; v,\n    }\n}\n\nfn main() {\n    let x = Some(Some(1));\n    let y = flatten(x);\n    println!(\"{:?}\", y);\n}\n</code></pre>\n\n<p>But if you wanted a trait:</p>\n\n<pre><code>trait MyThings&lt;T&gt; {\n    fn flatten(self) -&gt; Option&lt;T&gt;;\n}\n\nimpl&lt;T&gt; MyThings&lt;T&gt; for Option&lt;Option&lt;T&gt;&gt; {\n    fn flatten(self) -&gt; Option&lt;T&gt; {\n        match self {\n            None =&gt; None,\n            Some(v) =&gt; v,\n        }\n    }\n}\n\nfn main() {\n    let x = Some(Some(1));\n    let y = x.flatten();\n    println!(\"{:?}\", y);\n}\n</code></pre>\n\n<blockquote>\n  <p>Would there be a way to allow flatten to arbitrary depth</p>\n</blockquote>\n\n<p>See <a href=\"https://stackoverflow.com/q/52453180/155423\">How do I unwrap an arbitrary number of nested Option types?</a></p>\n"}, {"tags": [], "owner": {"reputation": 361, "user_id": 4237232, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-9O5kKSPEl6Y/AAAAAAAAAAI/AAAAAAAAAB0/ht9QINTIVnQ/photo.jpg?sz=128", "display_name": "Demur Rumed", "link": "https://stackoverflow.com/users/4237232/demur-rumed"}, "is_accepted": false, "score": 4, "last_activity_date": 1474288567, "last_edit_date": 1474288567, "creation_date": 1474285397, "answer_id": 39572365, "question_id": 28566531, "link": "https://stackoverflow.com/questions/28566531/how-to-implement-some-convenient-methods-e-g-flat-map-flatten-on-option/39572365#39572365", "title": "How to implement some convenient methods (e.g., flat_map, flatten) on Option?", "body": "<pre><code>fn flatten&lt;T&gt;(x: Option&lt;Option&lt;T&gt;&gt;) -&gt; Option&lt;T&gt; {\n    x.unwrap_or(None)\n}\n</code></pre>\n\n<p>In my case, I was dealing with an <code>Option</code>-returning method in <code>unwrap_or_else</code> and forgot about plain <code>or_else</code> method.</p>\n"}], "owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1414, "favorite_count": 0, "accepted_answer_id": 28566648, "answer_count": 2, "score": 2, "last_activity_date": 1537618223, "creation_date": 1424191554, "last_edit_date": 1424192396, "question_id": 28566531, "link": "https://stackoverflow.com/questions/28566531/how-to-implement-some-convenient-methods-e-g-flat-map-flatten-on-option", "title": "How to implement some convenient methods (e.g., flat_map, flatten) on Option?", "body": "<p>It would be nice if Rust's <code>Option</code> provided some additional convenience methods like <code>Option#flatten</code> and <code>Option#flat_map</code>, where <code>flatten</code> would reduce an <code>&lt;Option&lt;Option&lt;T&gt;&gt;</code> to <code>Option&lt;T&gt;</code>, and <code>flat_map</code> would work like <code>map</code>, but takes a method/closure that returns an <code>Option</code> and flattens it.</p>\n\n<p><code>flat_map</code> is pretty straightforward:</p>\n\n<pre><code>fn opt_flat_map&lt; T, U, F: FnOnce(T) -&gt; Option&lt;U&gt; &gt;(opt: Option&lt;T&gt;, f: F) -&gt; Option&lt;U&gt; {\n  match opt {\n    Some(x) =&gt; f(x),\n    None =&gt; None\n  }\n}\n</code></pre>\n\n<p><code>flatten</code> is more complex, and I don't really know how to go about defining it. It might look something like:</p>\n\n<pre><code>fn opt_flatten&lt;T, U&gt;(opt: Option&lt;T&gt;) -&gt; Option&lt;U&gt; {\n  match opt {\n      Some( Some(x) ) =&gt; flatten_option( Some(x) ),\n      _ =&gt; opt\n  }\n}\n</code></pre>\n\n<p>But that certainly doesn't work. Any thoughts?</p>\n\n<p>Also, how would I go about implementing these methods on the <code>Option</code> enum, so that I can use them natively on an <code>Option</code> instance? I know I need to add the type signature in somewhere around <code>impl OptionExts for Option&lt;T&gt;</code>, but I'm at a loss...</p>\n\n<p>Hope this makes sense and I apologize for my imprecise terminology--I'm brand new to Rust.</p>\n"}, {"tags": ["generics", "int", "rust", "traits"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 4, "last_activity_date": 1528505241, "last_edit_date": 1528505241, "creation_date": 1424188968, "answer_id": 28565674, "question_id": 28565440, "link": "https://stackoverflow.com/questions/28565440/how-do-i-use-integer-number-literals-when-using-generic-types/28565674#28565674", "title": "How do I use integer number literals when using generic types?", "body": "<p>The problem is that the <code>Integer</code> trait can be implemented by <em>anything</em>. For example, you could choose to implement it on your own struct! There wouldn't be a way to convert the literal <code>0</code> or <code>1</code> to your struct. I'm too lazy to show an example of implementing it, because there's 10 or so methods. ^_^</p>\n\n<p>This is why <a href=\"https://docs.rs/num/0.1.37/num/trait.Zero.html\" rel=\"nofollow noreferrer\"><code>Zero::zero</code></a> and <a href=\"https://docs.rs/num/0.1.37/num/trait.One.html\" rel=\"nofollow noreferrer\"><code>One::one</code></a> exist. You can (very annoyingly) create all the other constants from repeated calls to those.</p>\n\n<hr>\n\n<p>You can also use the <code>From</code> and <code>Into</code> traits to convert to your generic type: </p>\n\n<pre><code>extern crate num;\n\nuse num::Integer;\nuse std::ops::{DivAssign, Neg};\n\nfn int_length&lt;T&gt;(mut x: T) -&gt; u8\nwhere\n    T: Integer + Neg&lt;Output = T&gt; + DivAssign,\n    u8: Into&lt;T&gt;,\n{\n    let zero = 0.into();\n    if x == zero {\n        return 1;\n    }\n\n    let mut length = 0u8;\n    if x &lt; zero {\n        length += 1;\n        x = -x;\n    }\n\n    while x &gt; zero {\n        x /= 10.into();\n        length += 1;\n    }\n\n    length\n}\n\nfn main() {\n    println!(\"{}\", int_length(45));\n    println!(\"{}\", int_length(-45));\n}\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/50767912/155423\">What is the proper way to get literals when using the Float trait?</a></li>\n</ul>\n"}, {"comments": [{"owner": {"reputation": 730, "user_id": 4382650, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e636f2f5c51d67a92f0505e5171757f7?s=128&d=identicon&r=PG&f=1", "display_name": "L&#233;o Ercolanelli", "link": "https://stackoverflow.com/users/4382650/l%c3%a9o-ercolanelli"}, "edited": false, "score": 0, "creation_date": 1424190157, "post_id": 28565814, "comment_id": 45442374, "body": "Thanks a lot for pointing all that out ! I guess I&#39;m better off replacing <code>Int + Neg &lt;...&gt;</code> by <code>SignedInt</code> !"}, {"owner": {"reputation": 730, "user_id": 4382650, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e636f2f5c51d67a92f0505e5171757f7?s=128&d=identicon&r=PG&f=1", "display_name": "L&#233;o Ercolanelli", "link": "https://stackoverflow.com/users/4382650/l%c3%a9o-ercolanelli"}, "edited": false, "score": 0, "creation_date": 1424196697, "post_id": 28565814, "comment_id": 45446461, "body": "And thus any number if changing a bit your function \\o/ Thanks a lot !"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1424197193, "post_id": 28565814, "comment_id": 45446767, "body": "SignedInt has one problem, you won&#39;t be able to use unsigned values ;) see playpen: <a href=\"http://is.gd/YPhjla\" rel=\"nofollow noreferrer\">is.gd/YPhjla</a>"}, {"owner": {"reputation": 730, "user_id": 4382650, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e636f2f5c51d67a92f0505e5171757f7?s=128&d=identicon&r=PG&f=1", "display_name": "L&#233;o Ercolanelli", "link": "https://stackoverflow.com/users/4382650/l%c3%a9o-ercolanelli"}, "edited": false, "score": 0, "creation_date": 1424209251, "post_id": 28565814, "comment_id": 45453031, "body": "@ker I thought that unsigned int didn&#39;t implemented the <code>Neg</code> traits... But I obviously didn&#39;t took a sufficient look at it ! Thanks ! I definitely  have some reading waiting for me..."}, {"owner": {"reputation": 711, "user_id": 327615, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/433bfbebdf686daf029714618b88b7d2?s=128&d=identicon&r=PG", "display_name": "Leif Arne Storset", "link": "https://stackoverflow.com/users/327615/leif-arne-storset"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1437312378, "post_id": 28565814, "comment_id": 50966152, "body": "@Shepmaster&#39;s example <a href=\"http://is.gd/m86OnY\" rel=\"nofollow noreferrer\">updated for 1.1 here</a>. Sadly, I&#39;m not savvy enough to detect the &quot;wow&quot; optimization ker mentions."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1437326856, "post_id": 28565814, "comment_id": 50970674, "body": "just add <code>#[inline(never)]</code> to your <code>ten</code> function, turn on release mode and generate the llvm code. Then you can see, that the monomorphised generic function for <code>i32</code> is optimized to a single <code>ret i32 10</code> statement"}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 14, "last_activity_date": 1528504403, "last_edit_date": 1528504403, "creation_date": 1424189435, "answer_id": 28565814, "question_id": 28565440, "link": "https://stackoverflow.com/questions/28565440/how-do-i-use-integer-number-literals-when-using-generic-types/28565814#28565814", "title": "How do I use integer number literals when using generic types?", "body": "<p>Many things are going wrong here:</p>\n\n<ol>\n<li><a href=\"https://stackoverflow.com/a/28565674/155423\">As Shepmaster says</a>, <code>0</code> and <code>1</code> cannot be converted to everything implementing <code>Integer</code>. Use <code>Zero::zero</code> and <code>One::one</code> instead.</li>\n<li><code>10</code> can definitely not be converted to anything implementing <code>Integer</code>, you need to use <code>NumCast</code> for that</li>\n<li><code>a /= b</code> is not sugar for <code>a = a / b</code> but an separate trait that <code>Integer</code> does not require.</li>\n<li><code>-x</code> is an unary operation which is not part of <code>Integer</code> but requires the <code>Neg</code> trait (since it only makes sense for signed types).</li>\n</ol>\n\n<p>Here's an implementation. Note that you need a bound on <code>Neg</code>, to make sure that it results in the same type as <code>T</code></p>\n\n<pre><code>extern crate num;\n\nuse num::{Integer, NumCast};\nuse std::ops::Neg;\n\nfn int_length&lt;T&gt;(mut x: T) -&gt; u8\nwhere\n    T: Integer + Neg&lt;Output = T&gt; + NumCast,\n{\n    if x == T::zero() {\n        return 1;\n    }\n\n    let mut length = 0;\n    if x &lt; T::zero() {\n        length += 1;\n        x = -x;\n    }\n\n    while x &gt; T::zero() {\n        x = x / NumCast::from(10).unwrap();\n        length += 1;\n    }\n\n    length\n}\n\nfn main() {\n    println!(\"{}\", int_length(45));\n    println!(\"{}\", int_length(-45));\n}\n</code></pre>\n"}], "owner": {"reputation": 730, "user_id": 4382650, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e636f2f5c51d67a92f0505e5171757f7?s=128&d=identicon&r=PG&f=1", "display_name": "L&#233;o Ercolanelli", "link": "https://stackoverflow.com/users/4382650/l%c3%a9o-ercolanelli"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2796, "favorite_count": 3, "accepted_answer_id": 28565814, "answer_count": 2, "score": 11, "last_activity_date": 1528549125, "creation_date": 1424188259, "last_edit_date": 1528549125, "question_id": 28565440, "link": "https://stackoverflow.com/questions/28565440/how-do-i-use-integer-number-literals-when-using-generic-types", "title": "How do I use integer number literals when using generic types?", "body": "<p>I wanted to implement a function computing the number of digits within any generic type of integer. Here is the code I came up with:</p>\n\n<pre><code>extern crate num;\nuse num::Integer;\n\nfn int_length&lt;T: Integer&gt;(mut x: T) -&gt; u8 {\n    if x == 0 {\n        return 1;\n    }\n\n    let mut length = 0u8;\n    if x &lt; 0 {\n        length += 1;\n        x = -x;\n    }\n\n    while x &gt; 0 {\n        x /= 10;\n        length += 1;\n    }\n\n    length\n}\n\nfn main() {\n    println!(\"{}\", int_length(45));\n    println!(\"{}\", int_length(-45));\n}\n</code></pre>\n\n<p>And here is the compiler output</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; src/main.rs:5:13\n  |\n5 |     if x == 0 {\n  |             ^ expected type parameter, found integral variable\n  |\n  = note: expected type `T`\n             found type `{integer}`\n\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:10:12\n   |\n10 |     if x &lt; 0 {\n   |            ^ expected type parameter, found integral variable\n   |\n   = note: expected type `T`\n              found type `{integer}`\n\nerror: cannot apply unary operator `-` to type `T`\n  --&gt; src/main.rs:12:13\n   |\n12 |         x = -x;\n   |             ^^\n\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:15:15\n   |\n15 |     while x &gt; 0 {\n   |               ^ expected type parameter, found integral variable\n   |\n   = note: expected type `T`\n              found type `{integer}`\n\nerror[E0368]: binary assignment operation `/=` cannot be applied to type `T`\n  --&gt; src/main.rs:16:9\n   |\n16 |         x /= 10;\n   |         ^ cannot use `/=` on type `T`\n</code></pre>\n\n<p>I understand that the problem comes from my use of constants within the function, but I don't understand why the trait specification as <code>Integer</code> doesn't solve this.</p>\n\n<p><a href=\"https://docs.rs/num/0.1.37/num/trait.Integer.html\" rel=\"noreferrer\">The documentation for <code>Integer</code></a> says it implements the <code>PartialOrd</code>, etc. traits with <code>Self</code> (which I assume refers to <code>Integer</code>). By using integer constants which also implement the <code>Integer</code> trait, aren't the operations defined, and shouldn't the compiler compile without errors?</p>\n\n<p>I tried suffixing my constants with <code>i32</code>, but the error message is the same, replacing <code>_</code> with <code>i32</code>.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 0, "creation_date": 1424164776, "post_id": 28557650, "comment_id": 45428611, "body": "This PR may be related to what you are trying to achieve : <a href=\"https://github.com/rust-lang/rust/pull/22319\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/pull/22319</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1424183547, "post_id": 28557650, "comment_id": 45437908, "body": "FYI, the Rust style is 4-space indents."}, {"owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424184744, "post_id": 28557650, "comment_id": 45438805, "body": "@Shepmaster please; I don&#39;t use implicit return statements either; for the same reason; I disagree with the &#39;standard&#39; style. Fine or not... I think we can all agree it&#39;s completely irrelevant to the question."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 0, "last_activity_date": 1425132418, "creation_date": 1425132418, "answer_id": 28782623, "question_id": 28557650, "link": "https://stackoverflow.com/questions/28557650/can-you-express-valid-for-lifetime-of-returned-value-in-the-lifetime-system/28782623#28782623", "title": "Can you express &#39;valid for lifetime of returned value&#39; in the lifetime system?", "body": "<p>The code as you wrote it now works:</p>\n\n<pre><code>use std::thread;\n\n#[derive(Debug)]\nstruct Foo&lt;'a&gt; {\n    fp: &amp;'a u32\n}\n\nimpl&lt;'a&gt; Foo&lt;'a&gt; {\n    fn new(v: &amp;'a u32) -&gt; Foo&lt;'a&gt; {\n        Foo { fp: v }\n    }\n}\n\nfn main() {\n    let value = 100;\n    let foo = Foo::new(&amp;value);\n    let guard = thread::scoped(|| {\n        println!(\"{:?}\", foo);\n    });\n\n    // We know foo is valid in the remote thread, because guard is in the same \n    // scope of foo... but how do we express that using lifetimes?\n    guard.join();\n}\n</code></pre>\n\n<p>This is likely due to <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0458-send-improvements.md\" rel=\"nofollow\">RFC 458</a>, which relaxes the restrictions on <code>Send</code> / <code>Sync</code>. Now, <a href=\"http://doc.rust-lang.org/std/thread/fn.scoped.html\" rel=\"nofollow\"><code>thread::scoped</code></a> returns a <code>JoinGuard</code> with the same lifetime as the closure.</p>\n"}], "owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 121, "favorite_count": 0, "accepted_answer_id": 28782623, "answer_count": 1, "score": 0, "last_activity_date": 1425132418, "creation_date": 1424161830, "question_id": 28557650, "link": "https://stackoverflow.com/questions/28557650/can-you-express-valid-for-lifetime-of-returned-value-in-the-lifetime-system", "title": "Can you express &#39;valid for lifetime of returned value&#39; in the lifetime system?", "body": "<p>This is an issue I've encountered several times.</p>\n\n<ul>\n<li><p>You have data that needs to go to a task.</p></li>\n<li><p>You want to safely send the data to the task and process it remotely.</p></li>\n<li><p>...and you what to wait for the result.</p></li>\n</ul>\n\n<p>Something like this playpen: <a href=\"http://is.gd/fnhRta\" rel=\"nofollow\">http://is.gd/fnhRta</a></p>\n\n<pre><code>use std::thread::Thread;\n\n#[derive(Debug)]\nstruct Foo&lt;'a&gt; {\n  fp: &amp;'a u32\n}\n\nimpl&lt;'a&gt; Foo&lt;'a&gt; {\n  fn new(v:&amp;'a u32) -&gt; Foo&lt;'a&gt; {\n    return Foo {\n      fp: v\n    };\n  }\n}\n\nfn main() {\n  let value = 100;\n  let foo = Foo::new(&amp;value);\n  let guard = Thread::scoped(|| {\n    println!(\"{:?}\", foo);\n  });\n\n  // We know foo is valid in the remote thread, because guard is in the same \n  // scope of foo... but how do we express that using lifetimes?\n  guard.join();\n}\n</code></pre>\n\n<p>Is it possible to express this using lifetimes?</p>\n\n<p>Something which would, in essence, only accept a Foo&lt;'a> where &lt;'a> is &lt;= the lifetime of the current <code>{ ... }</code> block.</p>\n"}, {"tags": ["c", "optimization", "64-bit", "bit-manipulation", "rust"], "comments": [{"owner": {"reputation": 310760, "user_id": 12711, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/c330bdee507c95c603a93ca91d9145a9?s=128&d=identicon&r=PG", "display_name": "Michael Burr", "link": "https://stackoverflow.com/users/12711/michael-burr"}, "edited": false, "score": 1, "creation_date": 1424149708, "post_id": 28555013, "comment_id": 45422662, "body": "In all likelihood, the operations on 64-bit words will perform better, but If the performance of your operation across the whole array is important you&#39;ll want to measure the possible approaches."}, {"owner": {"reputation": 2652, "user_id": 4564515, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/90733097a656c664a472c437678aad42?s=128&d=identicon&r=PG&f=1", "display_name": "jschultz410", "link": "https://stackoverflow.com/users/4564515/jschultz410"}, "edited": false, "score": 0, "creation_date": 1424149963, "post_id": 28555013, "comment_id": 45422727, "body": "There is no guarantee that every 64b processor will do any bitwise manipulation of a 64b integer in a single clock cycle.  However, it is likely that operating on a value smaller than 64b (e.g. - 32b, 8b, etc.) will be done using the same operations as on a 64b value -- but it really depends on the processor if that&#39;s true or not."}], "answers": [{"tags": [], "owner": {"reputation": 37414, "user_id": 204883, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ba29060be0758fa6537ff3d768a91757?s=128&d=identicon&r=PG", "display_name": "Arkku", "link": "https://stackoverflow.com/users/204883/arkku"}, "is_accepted": true, "score": 2, "last_activity_date": 1424156551, "last_edit_date": 1424156551, "creation_date": 1424155583, "answer_id": 28556185, "question_id": 28555013, "link": "https://stackoverflow.com/questions/28555013/is-the-cost-of-bitwise-operations-on-64-bit-integers-the-same-as-8-bit-integers/28556185#28556185", "title": "Is the cost of bitwise operations on 64-bit integers the same as 8-bit integers?", "body": "<p>The number of clock cycles taken on a 64-bit operation is not guaranteed to be 1 even on a 64-bit machine, but obviously the processor doesn't know whether the 64-bit value stands for one 64-bit or eight 8-bit integers, so the bitwise operation itself will be as fast for both cases. <em>This part</em> of the code will also almost certainly perform much better for the single 64-bit value, as the 64-bit processor probably works on 64- (or at least 32-bit) quantities even when you do the operations on smaller variables.</p>\n\n<p>For the overall performance of your program much depends on how often you'd then need to convert between the 8- and 64-bit data; the typical indexing of a single 8-bit integer stored within an array of 64-bit integers would be something like <code>(a[i / 8] &gt;&gt; ((i % 8) * 8)) &amp; 0xFF</code> - so at least on the C side\u2020 it would add complexity if done often, but if most of your operations are repeated for all elements of the array then the 64-bit solution is likely to win regardless (bearing in mind that the compiler may have to generate similar masking when working on 8-bit variables anyhow).</p>\n\n<p>\u2020 You may wish to look at the generated assembler to verify actual complexity, it may look quite different depending on the instruction set\u2026</p>\n"}, {"tags": [], "owner": {"reputation": 48421, "user_id": 1196549, "user_type": "registered", "accept_rate": 46, "profile_image": "https://www.gravatar.com/avatar/fa597bf0dc47449a25e1f7f5b57e3ef1?s=128&d=identicon&r=PG", "display_name": "Yves Daoust", "link": "https://stackoverflow.com/users/1196549/yves-daoust"}, "is_accepted": false, "score": 1, "last_activity_date": 1424164044, "creation_date": 1424164044, "answer_id": 28558202, "question_id": 28555013, "link": "https://stackoverflow.com/questions/28555013/is-the-cost-of-bitwise-operations-on-64-bit-integers-the-same-as-8-bit-integers/28558202#28558202", "title": "Is the cost of bitwise operations on 64-bit integers the same as 8-bit integers?", "body": "<p>Be prepared for blazing speed with vectorized operations: using the SSE2 or AVX2 intrinsics, you can process 128 or 256 bits in a single go (<code>_m128i _mm_and_si128</code>, <code>_mm256_and_si256</code> and similar). And the forthcoming AVX512 extensions will allow 512 bits at a time!</p>\n"}], "owner": {"reputation": 1295, "user_id": 62018, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/9c42912dba3527b8e4eac9f6c2d020ad?s=128&d=identicon&r=PG", "display_name": "ivanceras", "link": "https://stackoverflow.com/users/62018/ivanceras"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1049, "favorite_count": 0, "accepted_answer_id": 28556185, "answer_count": 2, "score": 1, "last_activity_date": 1424182964, "creation_date": 1424149587, "last_edit_date": 1424182964, "question_id": 28555013, "link": "https://stackoverflow.com/questions/28555013/is-the-cost-of-bitwise-operations-on-64-bit-integers-the-same-as-8-bit-integers", "title": "Is the cost of bitwise operations on 64-bit integers the same as 8-bit integers?", "body": "<p>My code involves doing bitwise operations on a huge array of integers.\nIf understand correctly, 64-bit computers do calculations on 64-bit integers in one clock cycle. If I am doing an 8-bit integer bitwise operation, it still consumes 1 clock cycle. If I do eight 8-bit integer operations, it will consume 8 clock cycles. Knowing that I can fit eight 8-bit integers into a 64-bit integer, and do the bitwise operation on the 64-bit integer, will I consume 1 clock cycle instead of 8 clock cycles?</p>\n"}, {"tags": ["syntax", "rust", "slice"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424183481, "post_id": 28554366, "comment_id": 45437863, "body": "For reference, the new syntax is referred to as <a href=\"http://doc.rust-lang.org/std/ops/trait.Index.html\" rel=\"nofollow noreferrer\">Index</a>, which is the trait that allows it."}], "answers": [{"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 5, "creation_date": 1424153726, "post_id": 28555126, "comment_id": 45423864, "body": "I think that due to the new deref coercion rules even just <code>&amp;program</code> (without brackets) will suffice (if <code>program</code> is a <code>String</code> or something else with <code>Deref&lt;Target=str&gt;</code>)."}], "tags": [], "owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "is_accepted": true, "score": 3, "last_activity_date": 1424183386, "last_edit_date": 1424183386, "creation_date": 1424150160, "answer_id": 28555126, "question_id": 28554366, "link": "https://stackoverflow.com/questions/28554366/how-do-i-change-from-as-slice-to-syntax/28555126#28555126", "title": "How do I change from as_slice() to [] syntax?", "body": "<p>You were near to success:</p>\n\n<pre><code>print_usage(&amp;program[], opts);\n</code></pre>\n\n<p>So yes, now we should use square brackets syntax as <code>&amp;[start .. end]</code> or <code>&amp;mut [start .. end]</code> instead of <code>as_slice</code>/<code>slice</code>/<code>slice_from</code>/<code>slice_to</code>.</p>\n"}], "owner": {"reputation": 1238, "user_id": 759901, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/56175c4faa3db6d594ed7a0688b0c296?s=128&d=identicon&r=PG", "display_name": "leshow", "link": "https://stackoverflow.com/users/759901/leshow"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 971, "favorite_count": 0, "accepted_answer_id": 28555126, "answer_count": 1, "score": 3, "last_activity_date": 1424183386, "creation_date": 1424145278, "last_edit_date": 1424183337, "question_id": 28554366, "link": "https://stackoverflow.com/questions/28554366/how-do-i-change-from-as-slice-to-syntax", "title": "How do I change from as_slice() to [] syntax?", "body": "<p>Recompiling some older code against the newer nightlies, I'm getting warnings on using the <code>as_slice()</code> syntax in favour of the <code>var[]</code> syntax.</p>\n\n<p>However when I replace <code>as_slice()</code> with <code>[]</code> as shown <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0198-slice-notation.md\" rel=\"nofollow\">in the RFC</a>, I get a compiler error saying:</p>\n\n<pre><code> expected `&amp;str`,\n    found `str`\n(expected &amp;-ptr,\n    found str) [E0308]\nsrc/main.rs:38         print_usage(program[], opts);\n</code></pre>\n\n<p>compared to my original</p>\n\n<pre><code>print_usage(program.as_slice(), opts);\n</code></pre>\n\n<p>Is the <code>as_slice()</code> syntax going away entirely, or is it just more idiomatic to write it as <code>vec[]</code>? What's the deal with the error I'm getting when I follow what the compiler is asking me to do?</p>\n"}, {"tags": ["rust", "lifetime", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1424130992, "last_edit_date": 1424130992, "creation_date": 1424130624, "answer_id": 28552367, "question_id": 28552334, "link": "https://stackoverflow.com/questions/28552334/storing-mutable-references-and-lifetimes/28552367#28552367", "title": "Storing mutable references and lifetimes", "body": "<p>The reason it works with immutable references is because those can be implicitly copied. When you switch to trying to return a <code>&amp;mut</code>, then there would be two places that have that reference - the Vec and the caller of your function. This would introduce <em>aliasing</em>, and mutable aliases are not allowed in Rust.</p>\n\n<p>You can even ignore the <code>Index</code> implementation and just try this:</p>\n\n<pre><code>fn main() {\n    let mut f = Foo::new(1,2,3);\n    f.add_t_ref(1);\n    f.add_t_ref(2);\n}\n</code></pre>\n\n<p>You'll get:</p>\n\n<pre><code>error: cannot borrow `f` as mutable more than once at a time\n</code></pre>\n\n<p>While all of the above is true, it doesn't really explain why you get the particular error messages you do.</p>\n"}], "owner": {"reputation": 16382, "user_id": 38803, "user_type": "registered", "accept_rate": 96, "profile_image": "https://www.gravatar.com/avatar/76e6530ed28dc38e4edf93be22e6ccf9?s=128&d=identicon&r=PG", "display_name": "J Cooper", "link": "https://stackoverflow.com/users/38803/j-cooper"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 289, "favorite_count": 0, "accepted_answer_id": 28552367, "answer_count": 1, "score": 0, "last_activity_date": 1424130992, "creation_date": 1424130352, "question_id": 28552334, "link": "https://stackoverflow.com/questions/28552334/storing-mutable-references-and-lifetimes", "title": "Storing mutable references and lifetimes", "body": "<p>I've now spent a number of fruitless hours trying to get this to work, but I'm afraid my only recourse now is to try and summarize my code and ask you all for help.</p>\n\n<p>The situation is, if I uncomment the two instances of <code>mut</code> in the following code, it no longer compiles (and not for a reason that makes sense to me):</p>\n\n<pre><code>use std::cell::RefCell;\nuse std::ops::Index;\n\nstruct Foo&lt;'a, T: 'a&gt; {\n    t_array: [T; 3],\n    t_refs: RefCell&lt;Vec&lt;&amp;'a /* mut */ T&gt;&gt;, //'           // 1\n}\nimpl&lt;'a, T&gt; Foo&lt;'a, T&gt; {\n    fn new(t1: T, t2: T, t3: T) -&gt; Foo&lt;'a, T&gt; { //'\n        Foo {\n            t_array: [t1, t2, t3],\n            t_refs: RefCell::new(Vec::with_capacity(3))\n        }\n    }\n    fn add_t_ref(&amp;'a mut self, at_index: usize) { //'\n        let t_ref = &amp; /* mut */ self.t_array[at_index];  // 2\n        let mut t_refs = self.t_refs.borrow_mut();\n        t_refs.push(t_ref);\n    }\n}\nimpl&lt;'a, T&gt; Index&lt;usize&gt; for Foo&lt;'a, T&gt; {\n    type Output = T;\n    #[inline]\n    fn index(&amp;self, index: &amp;usize) -&gt; &amp;T {\n        let t_refs = self.t_refs.borrow();\n        t_refs[*index]\n    }\n}\n</code></pre>\n\n<p>The error that occurs when instead storing <code>mut</code> refs in the <code>Vec</code> is:</p>\n\n<pre><code>blah3_mut.rs:26:9: 26:15 error: `t_refs` does not live long enough\nblah3_mut.rs:26         t_refs[*index]\n                        ^~~~~~\nblah3_mut.rs:24:42: 27:6 note: reference must be valid for the anonymous lifetime #1 defined on the block at 24:41...\nblah3_mut.rs:25:42: 27:6 note: ...but borrowed value is only valid for the block suffix following statement 0 at 25:41\n</code></pre>\n\n<p>I would love it if someone could explain why this is happening; intuitively it seems like it shouldn't be an issue that the <code>RefCell</code>'s borrow goes out of scope. The <code>Vec</code> (and thus the <code>RefCell</code> too) do not own the data pointed to by the reference, so why does the compiler care about the lifetime of <em>their</em> references?</p>\n\n<p><em>P.S. I know my simplified code excerpt doesn't make it obvious why I'm storing mutable references in a <code>Vec</code> or why I'm using a <code>RefCell</code>\u2014suffice to say it's not by accident though</em></p>\n\n<p><em>P.P.S. I tried messing around a bit with lifetime annotations on the <code>index</code> method and/or the trait's associated type, but thus far only managed to get different errors from doing that</em></p>\n"}, {"tags": ["debian", "server", "rust", "vps", "latency"], "comments": [{"owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "edited": false, "score": 2, "creation_date": 1424112356, "post_id": 28546466, "comment_id": 45409456, "body": "This sounds like a network latency issue, either on the client side or on digitalocean&#39;s datacenter. It&#39;s not abnormal for some package to get lost on the way, and then the whole request suffers from <a href=\"https://en.wikipedia.org/wiki/Head-of-line_blocking\" rel=\"nofollow noreferrer\">HOL blocking</a>"}, {"owner": {"reputation": 14069, "user_id": 1769720, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5815db653a13a7122066f811caa020a7?s=128&d=identicon&r=PG", "display_name": "didierc", "link": "https://stackoverflow.com/users/1769720/didierc"}, "edited": false, "score": 1, "creation_date": 1424127396, "post_id": 28546466, "comment_id": 45416610, "body": "One simple way to know if the issue comes from Rust is to set static pages up and ask beta testers about latency again."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1424127529, "post_id": 28546466, "comment_id": 45416665, "body": "&quot;Most of the time it&#39;s well below 0 seconds for load time&quot; - I feel like if you are less than 0 load time, then you are probably doing something way better than everyone else on the Internet!"}, {"owner": {"reputation": 1609, "user_id": 4233606, "user_type": "registered", "accept_rate": 62, "profile_image": "https://i.stack.imgur.com/rh3M0.jpg?s=128&g=1", "display_name": "Vikaton", "link": "https://stackoverflow.com/users/4233606/vikaton"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424129724, "post_id": 28546466, "comment_id": 45417385, "body": "@Shepmaster Im getting this from Pingdom.com, also the webpages arent alot, nor are the Rust functions, Rust is pretty fast, as I believe you know :P"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1424131911, "post_id": 28546466, "comment_id": 45418063, "body": "I assume you mean it is well below 1 second, since being below 0 (getting a response before it was requested) usually requires time travel."}, {"owner": {"reputation": 1609, "user_id": 4233606, "user_type": "registered", "accept_rate": 62, "profile_image": "https://i.stack.imgur.com/rh3M0.jpg?s=128&g=1", "display_name": "Vikaton", "link": "https://stackoverflow.com/users/4233606/vikaton"}, "edited": false, "score": 0, "creation_date": 1424134276, "post_id": 28546466, "comment_id": 45418697, "body": "Yes, below 1 second, I was kinda not really thinking about this"}], "answers": [{"tags": [], "owner": {"reputation": 147, "user_id": 830444, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e32a382d8fd68b68bf3e494d1c9272f4?s=128&d=identicon&r=PG", "display_name": "JumpandSpintoWin", "link": "https://stackoverflow.com/users/830444/jumpandspintowin"}, "is_accepted": false, "score": 1, "last_activity_date": 1424129591, "creation_date": 1424129591, "answer_id": 28552204, "question_id": 28546466, "link": "https://stackoverflow.com/questions/28546466/what-is-the-source-of-this-latency/28552204#28552204", "title": "What is the source of this latency?", "body": "<p>A few possibilities:</p>\n\n<ol>\n<li><p>Your application is getting swapped to disk</p>\n\n<p>Meaning the OS thinks there are better things to have in RAM than your application. Usually happens if your app doesn't receive any request for say, hours. Probably not your problem.</p></li>\n<li><p>Your upload is spiky or non-existent.</p>\n\n<p>Try downloading a large file from your server and watch the download speeds.</p></li>\n<li><p>Your network has packet loss or high latency</p>\n\n<p>Test with running ping for few minutes. A good connection shouldn't have any loss and not much variation in latency. This one is probably the issue based on what you've said.</p></li>\n<li><p>Your framework is slow</p>\n\n<p>I doubt this one. You can test yourself by building a test app to send lots of local requests and making sure latency stays low.</p></li>\n<li><p>You have a bad neighbor</p>\n\n<p>Since you are using a VPS, who like to oversubscribe hosts, chances are you may have a bad neighbor. Another user who likes to use up the entire physical network connection to the host or a ton of CPU could hurt everyone. There may be several users doing this to bring a host to its knees.</p></li>\n</ol>\n\n<p>For packet loss and high latency, you should complain to your provider and include tests that show the loss. VPS hosts are often oversold and the provider may not have proper monitoring of the host to re-balance load. Or they may not care until someone complains.</p>\n"}, {"tags": [], "owner": {"reputation": 1609, "user_id": 4233606, "user_type": "registered", "accept_rate": 62, "profile_image": "https://i.stack.imgur.com/rh3M0.jpg?s=128&g=1", "display_name": "Vikaton", "link": "https://stackoverflow.com/users/4233606/vikaton"}, "is_accepted": false, "score": 0, "last_activity_date": 1424212719, "creation_date": 1424212719, "answer_id": 28572521, "question_id": 28546466, "link": "https://stackoverflow.com/questions/28546466/what-is-the-source-of-this-latency/28572521#28572521", "title": "What is the source of this latency?", "body": "<p>It turned out to be the number of threads that Iron defaults to, which was 2 in this case because of my 1 core VPS, so the latency was because 1 person was trying to connect to the website while the other connection was still open.</p>\n"}], "owner": {"reputation": 1609, "user_id": 4233606, "user_type": "registered", "accept_rate": 62, "profile_image": "https://i.stack.imgur.com/rh3M0.jpg?s=128&g=1", "display_name": "Vikaton", "link": "https://stackoverflow.com/users/4233606/vikaton"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 93, "favorite_count": 0, "answer_count": 2, "score": -1, "last_activity_date": 1424212719, "creation_date": 1424105792, "last_edit_date": 1424127437, "question_id": 28546466, "link": "https://stackoverflow.com/questions/28546466/what-is-the-source-of-this-latency", "title": "What is the source of this latency?", "body": "<p>I have a website written in Rust that you can find the source code <a href=\"https://github.com/Ap0ph1s/Oxidized\" rel=\"nofollow\">here</a>, The website is running on a 512mb RAM VPS in NYC hosted by DigitalOcean.</p>\n\n<p>I have noticed, and have gotten complaints from beta testers, that sometimes the website takes a long time to load. I added timers to see which function of my code takes the longest, but every request is well below 0 milliseconds. I am timing the duration of the middleware component.</p>\n\n<p>I tried using Pingdom.com and Real User Monitoring (RUM) to see if the requests take longer than they should. Some take more than 15s to load, HOWEVER, this latency problem is not consistent. Most of the time it's well below 0 seconds for load time.</p>\n\n<p>When I observe those requests coming in using the developer console in Safari, I see that there's about 350 ms of latency on a request which takes 15 ms.</p>\n"}, {"tags": ["multithreading", "rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1424097792, "last_edit_date": 1424097792, "creation_date": 1424096885, "answer_id": 28543618, "question_id": 28543503, "link": "https://stackoverflow.com/questions/28543503/split-gather-pattern-for-jobs/28543618#28543618", "title": "Split/gather pattern for jobs", "body": "<p>You've got a couple compounding issues, but the first one is a misuse / misunderstanding of <code>Arc</code>. You need to give each thread it's own copy of the <code>Arc</code>. <code>Arc</code> itself will make sure that changes are synchronized. The main changes were the addition of <code>.clone()</code> and the <code>move</code> keyword:</p>\n\n<pre><code>for item in container.items {\n    let mrb = ringBuf.clone();\n\n    std::thread::Thread::spawn(move || {\n        item.foo(); //job\n        mrb.lock().unwrap().push_back(item); //push item back to caller\n    });\n}\n</code></pre>\n\n<p>After changing this, you'll run into some simpler errors about forgotten <code>mut</code> qualifiers, and then you hit another problem - you are trying to send mutable references across threads. Your <code>for</code> loop will need to return <code>&amp;mut Item</code> to call <code>foo</code>, but this doesn't match your <code>Vec</code>. Changing it, we can get to something that compiles:</p>\n\n<pre><code>for mut item in container.items.into_iter() {\n    let mrb = ringBuf.clone();\n\n    std::thread::Thread::spawn(move || {\n        item.foo(); //job\n        mrb.lock().unwrap().push_back(item); //push item back to caller\n    });\n}\n</code></pre>\n\n<p>Here, we consume the input vector, moving each of the <code>Item</code>s to the worker thread. Unfortunately, this hits the Playpen timeout, so there's probably some deeper issue.</p>\n\n<p>All that being said, I'd highly recommend using <a href=\"http://doc.rust-lang.org/std/sync/mpsc/fn.channel.html\" rel=\"nofollow\"><code>channel</code></a>s:</p>\n\n<pre><code>#![feature(std_misc)]\n\nuse std::sync::mpsc::channel;\n\n#[derive(Debug)]\nstruct Item {\n    x: i32\n}\n\nimpl Item {\n    fn foo(&amp;mut self) { self.x += 1; }\n}\n\nfn main() {\n    let items = vec![Item { x: 0 }, Item { x: 1 }];\n\n    let rx = {\n        let (tx, rx) = channel();\n\n        for item in items.into_iter() {\n            let my_tx = tx.clone();\n\n            std::thread::Thread::spawn(move || {\n                let mut item = item;\n                item.foo();\n                my_tx.send(item).unwrap();\n            });\n        }\n\n        rx\n    };\n\n    for item in rx.iter() {\n        println!(\"{:?}\", item);\n    }\n}\n</code></pre>\n\n<p>This also times-out in the playpen, but works fine when compiled and run locally.</p>\n"}], "owner": {"reputation": 7587, "user_id": 116834, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/a3ee59b76d1593605ffb5be0ddca035b?s=128&d=identicon&r=PG", "display_name": "Drew", "link": "https://stackoverflow.com/users/116834/drew"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 91, "favorite_count": 0, "accepted_answer_id": 28543618, "answer_count": 1, "score": 2, "last_activity_date": 1424097792, "creation_date": 1424096490, "question_id": 28543503, "link": "https://stackoverflow.com/questions/28543503/split-gather-pattern-for-jobs", "title": "Split/gather pattern for jobs", "body": "<p>I have a set of jobs that I am trying to run in parallel.  I want to run each task on its own thread and gather the responses on the calling thread.  </p>\n\n<p>Some jobs may take much longer than others, so I'd like to start using each result as it comes in, and not have to wait for all jobs to complete.</p>\n\n<p>Here is an attempt:</p>\n\n<pre><code>struct Container&lt;T&gt; {\n    items : Vec&lt;T&gt;\n}\n\n#[derive(Debug)]\nstruct Item {\n    x: i32\n}\n\nimpl Item {\n    fn foo (&amp;mut self) {\n        self.x  += 1; //consider an expensive mutating computation\n    }\n}\n\nfn main() {\n\n    use std;\n    use std::sync::{Mutex, Arc};\n    use std::collections::RingBuf;\n\n    //set up a container with 2 items\n    let mut item1 = Item { x: 0};\n    let mut item2 = Item { x: 1};\n    let container = Container { items: vec![item1, item2]};\n\n    //set a gather system for our results\n    let ringBuf = Arc::new(Mutex::new(RingBuf::&lt;Item&gt;::new()));\n\n    //farm out each job to its own thread...\n    for item in container.items {\n        std::thread::Thread::spawn(|| {\n            item.foo(); //job\n            ringBuf.lock().unwrap().push_back(item); //push item back to caller\n        });\n    }\n\n    loop {\n        let rb = ringBuf.lock().unwrap();\n        if rb.len() &gt; 0 { //gather results as soon as they are available\n            println!(\"{:?}\",rb[0]);\n            rb.pop_front();\n        }\n    }\n}\n</code></pre>\n\n<p>For starters, this does not compile due to the impenetrable <code>cannot infer an appropriate lifetime due to conflicting requirements</code> error.</p>\n\n<p>What am I doing wrong and how do I do it right?</p>\n"}, {"tags": ["data-structures", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424034200, "post_id": 28531026, "comment_id": 45377171, "body": "Do you want to return a <code>CC</code> that is distinct from the one in your tree, or a reference to the same one? Your return type of <code>nw</code> indicates it would be the former."}, {"owner": {"reputation": 487, "user_id": 172865, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/531c6371df68b999ea837f34dba366dd?s=128&d=identicon&r=PG", "display_name": "capitrane", "link": "https://stackoverflow.com/users/172865/capitrane"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424034635, "post_id": 28531026, "comment_id": 45377321, "body": "I want to return a reference to the same node present in the tree."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424034817, "post_id": 28531165, "comment_id": 45377375, "body": "I think for the first case, you can now just say <code>Node(_, _, _, ref nw, _, _, _) =&gt; nw</code>, due to more flexible coercions."}, {"owner": {"reputation": 487, "user_id": 172865, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/531c6371df68b999ea837f34dba366dd?s=128&d=identicon&r=PG", "display_name": "capitrane", "link": "https://stackoverflow.com/users/172865/capitrane"}, "edited": false, "score": 0, "creation_date": 1424079439, "post_id": 28531165, "comment_id": 45390694, "body": "Thanks! Of course it makes sense to return Rc&lt;CC&gt; instead of CC."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 3, "last_activity_date": 1424034758, "last_edit_date": 1424034758, "creation_date": 1424034337, "answer_id": 28531165, "question_id": 28531026, "link": "https://stackoverflow.com/questions/28531026/how-do-i-return-a-reference-to-a-part-of-a-recursive-data-structure/28531165#28531165", "title": "How do I return a reference to a part of a recursive data structure?", "body": "<p>You have two options here.</p>\n\n<p>First, you can return a reference to the subtree:</p>\n\n<pre><code>fn nw(&amp;self) -&gt; &amp;CC {\n    match *self {\n        Node(_, _, _, ref nw, _, _, _) =&gt; &amp;**nw,\n        _ =&gt; panic!()\n    }\n}\n</code></pre>\n\n<p>Second, you can return a reference-counted pointer:</p>\n\n<pre><code>fn nw(&amp;self) -&gt; Rc&lt;CC&gt; {\n    match *self {\n        Node(_, _, _, ref nw, _, _, _) =&gt; nw.clone()\n        _ =&gt; panic!()\n    }\n}\n</code></pre>\n\n<p>You can't return just <code>CC</code>, however, unless you are willing to clone the value itself. The reason is that this would mean moving out of <code>Rc</code>, leaving it in some undefined state, which is rightly prohibited.</p>\n"}], "owner": {"reputation": 487, "user_id": 172865, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/531c6371df68b999ea837f34dba366dd?s=128&d=identicon&r=PG", "display_name": "capitrane", "link": "https://stackoverflow.com/users/172865/capitrane"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 196, "favorite_count": 1, "accepted_answer_id": 28531165, "answer_count": 1, "score": 0, "last_activity_date": 1424038862, "creation_date": 1424033562, "last_edit_date": 1424038862, "question_id": 28531026, "link": "https://stackoverflow.com/questions/28531026/how-do-i-return-a-reference-to-a-part-of-a-recursive-data-structure", "title": "How do I return a reference to a part of a recursive data structure?", "body": "<p>I'm trying to define a recursive data structure in Rust, but there are some pieces missing in my understanding of Rust and memory - the only thing that I manage to do is pick a fight with the borrow checker.</p>\n\n<p>I have the following stub of a quad tree and want to project one of the quadrants as follows.</p>\n\n<pre><code>use CC::{Node, Leaf};\n\nenum CC {\n    Node(i32, bool, i32, Rc&lt;CC&gt;, Rc&lt;CC&gt;, Rc&lt;CC&gt;, Rc&lt;CC&gt;),\n    Leaf(bool),\n}\n\nimpl CC {\n    fn nw(&amp;self) -&gt; CC {\n        match *self {\n            Node(_, _, _, ref nw, _, _, _) =&gt; *nw.clone(),\n            _ =&gt; panic!()\n        }\n    }\n}\n</code></pre>\n\n<p>But all I end up with is</p>\n\n<pre><code>src/hashlife.rs:34:47: 34:58 error: cannot move out of borrowed content\nsrc/hashlife.rs:34             Node(_, _, _, ref nw, _, _, _) =&gt; *nw.clone(),\n                                                                 ^~~~~~~~~~~\n</code></pre>\n"}, {"tags": ["rust", "raii"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1424033292, "creation_date": 1424033292, "answer_id": 28530988, "question_id": 28530779, "link": "https://stackoverflow.com/questions/28530779/struct-field-is-never-used-but-needed-by-raii/28530988#28530988", "title": "&quot;struct field is never used&quot;, but needed by RAII", "body": "<p>You can annotate the specific field to ignore the dead-code warning:</p>\n\n<pre><code>struct Mmapped {\n    #[allow(dead_code)]\n    file: File,\n    map: MemoryMap,\n    map_len: usize,\n}\n</code></pre>\n\n<p>I don't believe that the optimizer will completely drop the field from the struct, and a quick look at the LLVM IR for a struct that has an unused String field shows that there is still space for that field and even calls the drop glue for that String.</p>\n"}, {"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 12, "last_activity_date": 1424034488, "creation_date": 1424034488, "answer_id": 28531192, "question_id": 28530779, "link": "https://stackoverflow.com/questions/28530779/struct-field-is-never-used-but-needed-by-raii/28531192#28531192", "title": "&quot;struct field is never used&quot;, but needed by RAII", "body": "<p>I believe that the idiomatic approach is to prefix the field name with <code>_</code>, which would also silence the warning:</p>\n\n<pre><code>struct Mmapped {\n    _file: File,\n    map: MemoryMap,\n    map_len: usize,\n}\n</code></pre>\n\n<p>I definitely noticed such pattern in the standard library code.</p>\n"}], "owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2309, "favorite_count": 0, "accepted_answer_id": 28530988, "answer_count": 2, "score": 4, "last_activity_date": 1424034488, "creation_date": 1424032066, "last_edit_date": 1424033326, "question_id": 28530779, "link": "https://stackoverflow.com/questions/28530779/struct-field-is-never-used-but-needed-by-raii", "title": "&quot;struct field is never used&quot;, but needed by RAII", "body": "<p>I'm trying to implement a memory mapped file by combining <code>os::MemoryMap</code> and <code>fs::File</code> in some kind of RAII style. Consider the following example:</p>\n\n<pre><code>#![feature(fs, os, io, path, std_misc, core)]\n\nuse std::{io, os, mem, raw};\nuse std::io::{Seek};\nuse std::fs::{File};\nuse std::path::{Path};\nuse std::os::{MemoryMap};\nuse std::borrow::{Cow};\nuse std::error::{FromError};\nuse std::os::unix::{AsRawFd};\n\nstruct Mmapped {\n    file: File,\n    map: MemoryMap,\n    map_len: usize,\n}\n\n#[derive(Debug)]\nenum Error {\n    IoError(io::Error),\n    MmapError(os::MapError),\n}\n\nimpl FromError&lt;io::Error&gt; for Error { \n    fn from_error(err: io::Error) -&gt; Error { Error::IoError(err) }\n}\n\nimpl FromError&lt;os::MapError&gt; for Error { \n    fn from_error(err: os::MapError) -&gt; Error { Error::MmapError(err) }\n}\n\nimpl Mmapped {\n    fn new(filename: &amp;str) -&gt; Result&lt;Mmapped, Error&gt; {\n        let mut file = try!(File::open(Path::new(filename)));\n        let map_len = try!(file.seek(io::SeekFrom::End(0))) as usize;\n        let map = try!(MemoryMap::new(map_len, &amp;[os::MapOption::MapReadable, os::MapOption::MapFd(file.as_raw_fd())]));\n        Ok(Mmapped { file: file, map: map, map_len: map_len })\n    }\n\n    unsafe fn as_string&lt;'a&gt;(&amp;self) -&gt; Cow&lt;'a, String, str&gt; {\n        String::from_utf8_lossy(mem::transmute(raw::Slice { data: self.map.data() as *const u8, \n                                                            len: self.map_len }))\n    }\n}\n\nfn main() {\n    let m = Mmapped::new(\"test.txt\").unwrap();\n    println!(\"File contents: {:?}\", unsafe { m.as_string() });\n}\n</code></pre>\n\n<p><a href=\"http://is.gd/h3tEY0\" rel=\"nofollow\">playpen</a></p>\n\n<p>It works, but compiler treats the <em>file</em> field in <em>Mmapped</em> object as dead code:</p>\n\n<pre><code>&lt;anon&gt;:13:5: 13:15 warning: struct field is never used: `file`, #[warn(dead_code)] on by default\n&lt;anon&gt;:13     file: File,\n              ^~~~~~~~~~\n</code></pre>\n\n<p>Could I be sure that it will not optimize it out, and file will be closed in <em>new</em> method? And is there any standard way to mark my field \"not dead\" code?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "is_accepted": true, "score": 5, "last_activity_date": 1514740526, "last_edit_date": 1514740526, "creation_date": 1424031243, "answer_id": 28530629, "question_id": 28530338, "link": "https://stackoverflow.com/questions/28530338/how-can-i-use-match-on-a-pair-of-borrowed-values-without-copying-them/28530629#28530629", "title": "How can I use match on a pair of borrowed values without copying them?", "body": "<p>You can  match over a tuple of two references by removing the dereference operator from the variables:</p>\n\n<pre><code>enum E {\n    E1,\n}\n\nfn f(e1: &amp;E, e2: &amp;E) {\n    match *e1 {\n        E::E1 =&gt; (),\n    }\n    match (e1, e2) {\n        (&amp;E::E1, &amp;E::E1) =&gt; (),\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 1117, "user_id": 1810193, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/4ff490527b19b60e12e2520654cf54ef?s=128&d=identicon&r=PG", "display_name": "Philippe", "link": "https://stackoverflow.com/users/1810193/philippe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 342, "favorite_count": 0, "accepted_answer_id": 28530629, "answer_count": 1, "score": 0, "last_activity_date": 1514740526, "creation_date": 1424029500, "last_edit_date": 1514740476, "question_id": 28530338, "link": "https://stackoverflow.com/questions/28530338/how-can-i-use-match-on-a-pair-of-borrowed-values-without-copying-them", "title": "How can I use match on a pair of borrowed values without copying them?", "body": "<p>I reduced my problem to the following code:</p>\n\n<pre><code>enum E {\n    E1,\n}\n\nfn f(e1: &amp;E, e2: &amp;E) {\n    match *e1 {\n        E::E1 =&gt; (),\n    }\n    match (*e1, *e2) {\n        (E::E1, E::E1) =&gt; (),\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>The first match is ok, but the second fails to compile:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n --&gt; src/main.rs:9:12\n  |\n9 |     match (*e1, *e2) {\n  |            ^^^ cannot move out of borrowed content\n\nerror[E0507]: cannot move out of borrowed content\n --&gt; src/main.rs:9:17\n  |\n9 |     match (*e1, *e2) {\n  |                 ^^^ cannot move out of borrowed content\n</code></pre>\n\n<p>It seems that this is because I'm constructing a pair of something borrowed and Rust tries to move <code>e1</code> and <code>e2</code> into it. I found out that if I put \"#[derive(Copy, Clone)]\" before my enum, my code compiles.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1284, "user_id": 844382, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/6b4d6446799865faa5e43488a565b894?s=128&d=identicon&r=PG", "display_name": "hyperman", "link": "https://stackoverflow.com/users/844382/hyperman"}, "edited": false, "score": 0, "creation_date": 1424075297, "post_id": 28531432, "comment_id": 45388459, "body": "This looks to easy to be true ;)  I&#39;ll check it out, and upvote tomorrow when i&#39;ve got a chance to test it.  Thanks!  Indeed, scary globals, but my C api has plenty of other scary stuff so I&#39;ll live with it.  If someone wants to use a variant of this multithreaded, [s]he&#39;ll probably need a thread local."}, {"owner": {"reputation": 1284, "user_id": 844382, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/6b4d6446799865faa5e43488a565b894?s=128&d=identicon&r=PG", "display_name": "hyperman", "link": "https://stackoverflow.com/users/844382/hyperman"}, "edited": false, "score": 0, "creation_date": 1424118219, "post_id": 28531432, "comment_id": 45412401, "body": "Update: Works perfectly. You truly have  a rusty brain.  Thanks.  Minor question:  Why the //&#39; comments ?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1284, "user_id": 844382, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/6b4d6446799865faa5e43488a565b894?s=128&d=identicon&r=PG", "display_name": "hyperman", "link": "https://stackoverflow.com/users/844382/hyperman"}, "edited": false, "score": 1, "creation_date": 1424118501, "post_id": 28531432, "comment_id": 45412518, "body": "The <code>&#47;&#47;&#39;</code> comments are to work around Stack Overflow&#39;s code highlighter, which doesn&#39;t currently handle the <code>&#39;a</code> of a namespace well. ^_^"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1424036004, "creation_date": 1424036004, "answer_id": 28531432, "question_id": 28530071, "link": "https://stackoverflow.com/questions/28530071/how-do-i-globally-store-a-trait-object-to-make-it-accessible-to-a-c-api-callback/28531432#28531432", "title": "How do I globally store a trait object to make it accessible to a C API callback?", "body": "<p>The <code>'static</code> lifetime actually isn't too complicated - it simply denotes that something is guaranteed to live for the <em>entire life of the program</em>. In this case, a global value, by definition, needs to be available for that long.</p>\n\n<p>A problem often occurs because people want to initialize that global value during runtime of the program, which means that it <em>isn't</em> available for the entire program.</p>\n\n<p>Now, the meat of the problem. Solution presented with very little guarantee on how safe it is.</p>\n\n<p>First, I think you are running into a <a href=\"https://github.com/rust-lang/rust/issues/21397\" rel=\"nofollow\">bug</a> that prevents you from directly storing the trait object. To work around that, we wrap the trait object in a little dummy struct (<code>Holder</code>) that gives the trait object somewhere to live.</p>\n\n<p>Then, we stick the reference to the holder into the <em>global, mutable, scary,</em> location. Call the callback, and wham, presto, there it is!</p>\n\n<pre><code>use std::mem;\n\nstruct Holder&lt;'a&gt;(&amp;'a mut (State + 'a)); //'\n\n// You'd truly better never use this in multiple threads!\nstatic mut static_state: *mut Holder&lt;'static&gt; = 0 as *mut _; //'\n\npub trait State {\n    fn called(&amp;mut self);\n}\n\nstruct MyState {\n    value: i32\n}\n\nimpl State for MyState{\n    fn called(&amp;mut self) {\n        println!(\"I hope this prints 123:{}\", self.value);\n    }\n}\n\nunsafe fn c_api(c_api_callback: extern fn()) {\n    c_api_callback();\n}\n\nextern fn my_callback_impl() {\n    // really should check that it's not 0 here...\n    let h = unsafe { &amp;mut *static_state };\n    h.0.called();\n}\n\npub fn do_call(state: &amp;mut State){\n    let h = Holder(state);\n    unsafe {\n        // Straight-up lie to the compiler: \"yeah, this is static\"\n        static_state = mem::transmute(&amp;h);\n        c_api(my_callback_impl);\n        static_state = 0 as *mut _;\n    }\n}\n\npub fn main(){\n    let mut mystate = MyState { value: 123 };\n    do_call(&amp;mut mystate);\n}\n</code></pre>\n"}], "owner": {"reputation": 1284, "user_id": 844382, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/6b4d6446799865faa5e43488a565b894?s=128&d=identicon&r=PG", "display_name": "hyperman", "link": "https://stackoverflow.com/users/844382/hyperman"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 523, "favorite_count": 0, "accepted_answer_id": 28531432, "answer_count": 1, "score": 2, "last_activity_date": 1424036354, "creation_date": 1424027837, "last_edit_date": 1424036354, "question_id": 28530071, "link": "https://stackoverflow.com/questions/28530071/how-do-i-globally-store-a-trait-object-to-make-it-accessible-to-a-c-api-callback", "title": "How do I globally store a trait object to make it accessible to a C API callback?", "body": "<p>Suppose a C API which calls a callback before returning.  Unfortunately, there is no way to send data to the callback except by global variables.  There is only 1 thread, by the way.</p>\n\n<p>To make this example compile, I've added a dummy implementation for it in Rust, the real thing is extern \"C\"</p>\n\n<pre><code>unsafe fn c_api(c_api_callback:extern fn()){\n  c_api_callback();\n}\n</code></pre>\n\n<p>I want to encapsulate some state for this API</p>\n\n<pre><code>pub trait State {\n    fn called(&amp;mut self); //c_api_callback should call this on self\n}\n</code></pre>\n\n<p>In a generic way.  Multiple independent implementations of State can exist</p>\n\n<pre><code>struct MyState {\n    value:i32\n}\n\nimpl State for MyState{\n    fn called(&amp;mut self){\n        println!(\"I hope this prints 123:{}\", self.value);\n    }\n}\n\npub fn main(){\n    let mut mystate = MyState { value: 123 };\n    do_call(&amp;mut mystate);\n}\n</code></pre>\n\n<p>The basic question: How do I implement what follows?</p>\n\n<pre><code>//rustc says: error: explicit lifetime bound required [E0228]\n static static_state:* mut State=0 as *mut State;\n\n//This doesn't work \n//static static_state:*'static mut State=0 as *mut State;\n//error: bare raw pointers are no longer allowed, you should likely use `*mut T`, but otherwise `*T` is now known as `*const T`\n\nextern fn my_callback_impl(){\n    static_state.called();\n}\n\npub fn do_call(state:&amp;mut State){\n    static_state=state;\n    unsafe{\n        c_api(my_callback_impl);\n    }\n    static_state=0 as *mut State;\n}\n</code></pre>\n\n<p>I tried all kinds of horrible workarounds, up to wrapping the trait in a struct and using transmute on it to cast it to <code>*u8</code>, and I have a nice collection of weird error messages and compiler crashes as a result.  </p>\n\n<p>As this is the second time I get confused by static in rust, I would also appreciate it if someone has some pointers to blogs or good example code clarifying what's going on here.</p>\n"}, {"tags": ["string", "rust", "stdin"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424022196, "post_id": 28528998, "comment_id": 45373278, "body": "Have you read <a href=\"http://doc.rust-lang.org/book/standard-input.html\" rel=\"nofollow noreferrer\">The Rust Book&#39;s section on standard input</a>?"}, {"owner": {"reputation": 1091, "user_id": 3745005, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/yvS7i.png?s=128&g=1", "display_name": "andrey", "link": "https://stackoverflow.com/users/3745005/andrey"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424022513, "post_id": 28528998, "comment_id": 45373362, "body": "@Shepmaster Yes, but I figured &#39;old_io&#39; means it&#39;s a deprecated feature. Is it other way around?"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 2, "creation_date": 1424025403, "post_id": 28528998, "comment_id": 45374355, "body": "The documentation you are referring to is for the first alpha release. The module then called <code>io</code> was renamed <code>old_io</code> <i>after</i> that release, and it is indeed on the way out, but not yet completely superseded by the new <code>io</code> module. First you need to figure out where you stand: Are you using 1.0.0-alpha or are you tracking nightlies?"}], "answers": [{"comments": [{"owner": {"reputation": 3393, "user_id": 1167555, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/k6jec.jpg?s=128&g=1", "display_name": "WDRust", "link": "https://stackoverflow.com/users/1167555/wdrust"}, "edited": false, "score": 0, "creation_date": 1432299879, "post_id": 28530909, "comment_id": 48882647, "body": "in the <code>read_line()</code> example, wouldn&#39;t it be more appropriate to use <code>.ok().expect()</code> pattern for the return value? You&#39;re not doing anything with the <code>unwrap()</code>ped value."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 3393, "user_id": 1167555, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/k6jec.jpg?s=128&g=1", "display_name": "WDRust", "link": "https://stackoverflow.com/users/1167555/wdrust"}, "edited": false, "score": 0, "creation_date": 1432301016, "post_id": 28530909, "comment_id": 48883419, "body": "@tilde I don&#39;t know about <i>more</i> appropriate, but I don&#39;t think it would be <i>less</i> appropriate either. When you <code>unwrap</code> a <code>Result</code>, the error value will be used as the panic message. With your example, you&#39;d need to provide an error message for <code>expect</code>, which might be more appropriate for your use case."}, {"owner": {"reputation": 3393, "user_id": 1167555, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/k6jec.jpg?s=128&g=1", "display_name": "WDRust", "link": "https://stackoverflow.com/users/1167555/wdrust"}, "edited": false, "score": 0, "creation_date": 1432301523, "post_id": 28530909, "comment_id": 48883802, "body": "I didn&#39;t think about the fact that the error value would be propagated to the panic anyways, thanks for the clarification!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 23, "last_activity_date": 1479303239, "last_edit_date": 1479303239, "creation_date": 1424032829, "answer_id": 28530909, "question_id": 28528998, "link": "https://stackoverflow.com/questions/28528998/how-do-i-read-a-single-string-from-standard-input/28530909#28530909", "title": "How do I read a single String from standard input?", "body": "<p>Here's the code you need to do what you are trying (no comments on if it is a good way to go about it:</p>\n\n<pre><code>use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let line = stdin.lock()\n        .lines()\n        .next()\n        .expect(\"there was no next line\")\n        .expect(\"the line could not be read\");\n}\n</code></pre>\n\n<p>If you want more control over where the line is read to, you can use <a href=\"http://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line\" rel=\"noreferrer\"><code>Stdin::read_line</code></a>. This accepts a <code>&amp;mut String</code> to append to. With this, you can ensure that the string has a large enough buffer, or append to an existing string:</p>\n\n<pre><code>use std::io::{self, BufRead};\n\nfn main() {\n    let mut line = String::new();\n    let stdin = io::stdin();\n    stdin.lock().read_line(&amp;mut line).expect(\"Could not read line\");\n    println!(\"{}\", line)\n}\n</code></pre>\n"}], "owner": {"reputation": 1091, "user_id": 3745005, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/yvS7i.png?s=128&g=1", "display_name": "andrey", "link": "https://stackoverflow.com/users/3745005/andrey"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 10275, "favorite_count": 1, "accepted_answer_id": 28530909, "answer_count": 1, "score": 11, "last_activity_date": 1479303239, "creation_date": 1424021904, "last_edit_date": 1424036237, "question_id": 28528998, "link": "https://stackoverflow.com/questions/28528998/how-do-i-read-a-single-string-from-standard-input", "title": "How do I read a single String from standard input?", "body": "<p>There isn't straightforward instruction on receiving a string as a variable in the <a href=\"http://doc.rust-lang.org/1.0.0-alpha/std/io/index.html\" rel=\"noreferrer\">std::io documentation</a>, but I figured this should work:</p>\n\n<pre><code>use std::io;\nlet line = io::stdin().lock().lines().unwrap();\n</code></pre>\n\n<p>But I'm getting this error:</p>\n\n<pre><code>src\\main.rs:28:14: 28:23 error: unresolved name `io::stdin`\nsrc\\main.rs:28          let line = io::stdin.lock().lines().unwrap();\n                                   ^~~~~~~~~\n</code></pre>\n\n<p>Why?</p>\n\n<p>I'm using a nightly Rust v1.0.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424014802, "post_id": 28527702, "comment_id": 45370945, "body": "Please create an <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a>. This both helps you understand the problem better and lets other people comprehend the problem faster, making the all-around result better."}, {"owner": {"reputation": 14069, "user_id": 1769720, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5815db653a13a7122066f811caa020a7?s=128&d=identicon&r=PG", "display_name": "didierc", "link": "https://stackoverflow.com/users/1769720/didierc"}, "edited": false, "score": 2, "creation_date": 1424015047, "post_id": 28527702, "comment_id": 45371031, "body": "Not related to the issue, but to your code: that function seems to assume that a difference of 2 between <code>self</code> direction and the given (perhaps new) direction always mean the same thing (1 or maybe a U-turn?), but my impression is that &quot;<code>Down - None</code>&quot; is not the same as &quot;<code>Up - Down</code>&quot;, or is it?"}, {"owner": {"reputation": 169, "user_id": 3318270, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/03ff48b06a7c0b5f2b00f7dacf2047a1?s=128&d=identicon&r=PG&f=1", "display_name": "c_spk", "link": "https://stackoverflow.com/users/3318270/c-spk"}, "reply_to_user": {"reputation": 14069, "user_id": 1769720, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5815db653a13a7122066f811caa020a7?s=128&d=identicon&r=PG", "display_name": "didierc", "link": "https://stackoverflow.com/users/1769720/didierc"}, "edited": false, "score": 0, "creation_date": 1424015288, "post_id": 28527702, "comment_id": 45371117, "body": "@didierc: Yes, difference of two between these two directions indicate that they are opposite. The None value is used only on creation of a Chain object and can be deleted, I guess."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 14069, "user_id": 1769720, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5815db653a13a7122066f811caa020a7?s=128&d=identicon&r=PG", "display_name": "didierc", "link": "https://stackoverflow.com/users/1769720/didierc"}, "edited": false, "score": 2, "creation_date": 1424015348, "post_id": 28527702, "comment_id": 45371138, "body": "Adding to @didierc&#39;s comment, you probably don&#39;t want to do math on enums, that&#39;s a very C-like paradigm. Also, you might want to not include <code>None</code> as part of your enum and just use <code>Option</code> instead. It also looks like you are trying to return a boolean from <code>turn</code>, so you should probably just do that."}, {"owner": {"reputation": 169, "user_id": 3318270, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/03ff48b06a7c0b5f2b00f7dacf2047a1?s=128&d=identicon&r=PG&f=1", "display_name": "c_spk", "link": "https://stackoverflow.com/users/3318270/c-spk"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424015602, "post_id": 28527702, "comment_id": 45371212, "body": "@Shepmaster: I made a mistake: the else-if branch should return -1. And yes, I&#39;m learning Rust by porting a C program almost line-to-line."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1424015737, "post_id": 28527702, "comment_id": 45371243, "body": "Gotcha. Once done porting, you may want to look into returning your own enum type to indicate the success, but I&#39;d also suggest checking out <code>Result</code>, which is most commonly used for error-handling stuff."}, {"owner": {"reputation": 169, "user_id": 3318270, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/03ff48b06a7c0b5f2b00f7dacf2047a1?s=128&d=identicon&r=PG&f=1", "display_name": "c_spk", "link": "https://stackoverflow.com/users/3318270/c-spk"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424015873, "post_id": 28527702, "comment_id": 45371280, "body": "@Shepmaster: Yeah, I thought about a special return type too. Thanks."}], "answers": [{"comments": [{"owner": {"reputation": 169, "user_id": 3318270, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/03ff48b06a7c0b5f2b00f7dacf2047a1?s=128&d=identicon&r=PG&f=1", "display_name": "c_spk", "link": "https://stackoverflow.com/users/3318270/c-spk"}, "edited": false, "score": 0, "creation_date": 1424015073, "post_id": 28527789, "comment_id": 45371040, "body": "Thank you! All these #[] directives really make things complicated\u2026"}], "tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "is_accepted": true, "score": 3, "last_activity_date": 1424014741, "creation_date": 1424014741, "answer_id": 28527789, "question_id": 28527702, "link": "https://stackoverflow.com/questions/28527702/cannot-move-out-of-borrowed-context-and-use-of-moved-value/28527789#28527789", "title": "&quot;cannot move out of borrowed context&quot; and &quot;use of moved value&quot;", "body": "<p>As the error message says:</p>\n\n<blockquote>\n  <p><code>dir</code> moved here because it has type <code>foo::Direction</code>, which is non-copyable</p>\n</blockquote>\n\n<p>No type is copyable by default, the author has to opt into the marker trait <code>Copy</code>. You almost certainly want <code>Direction</code> to be copyable, so add <code>#[derive(Copy)]</code> to the definition. <code>Point</code> can probably be <code>Copy</code> as well.</p>\n"}], "owner": {"reputation": 169, "user_id": 3318270, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/03ff48b06a7c0b5f2b00f7dacf2047a1?s=128&d=identicon&r=PG&f=1", "display_name": "c_spk", "link": "https://stackoverflow.com/users/3318270/c-spk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1059, "favorite_count": 0, "accepted_answer_id": 28527789, "answer_count": 1, "score": 1, "last_activity_date": 1424015619, "creation_date": 1424014181, "last_edit_date": 1424015619, "question_id": 28527702, "link": "https://stackoverflow.com/questions/28527702/cannot-move-out-of-borrowed-context-and-use-of-moved-value", "title": "&quot;cannot move out of borrowed context&quot; and &quot;use of moved value&quot;", "body": "<p>I have the following code:</p>\n\n<pre><code>pub enum Direction {\n    Up, Right, Down, Left, None\n}\n\nstruct Point {\n    y: i32,\n    x: i32\n}\n\npub struct Chain {\n    segments: Vec&lt;Point&gt;,\n    direction: Direction\n}\n</code></pre>\n\n<p>and later I implement the following function:</p>\n\n<pre><code>fn turn (&amp;mut self, dir: Direction) -&gt; i32 {\n    use std::num::SignedInt;\n\n    if dir == self.direction { return 0; }\n    else if SignedInt::abs(dir as i32 - self.direction as i32) == 2 { return -1; }\n    else {\n        self.direction = dir;\n        return 1;\n    }\n}\n</code></pre>\n\n<p>I get the error:</p>\n\n<pre><code>error: cannot move out of borrowed content\nfoo.rs:45       else if SignedInt::abs(dir as i32 - self.direction as i32) == 2 { return 1; }\n                                                        ^~~~\nfoo.rs:47:21: 47:24 error: use of moved value: `dir`\nfoo.rs:47           self.direction = dir;\n                                         ^~~\nfoo.rs:45:26: 45:29 note: `dir` moved here because it has type `foo::Direction`, which is non-copyable\nfoo.rs:45       else if SignedInt::abs(dir as i32 - self.direction as i32) == 2 { return 1; }\n</code></pre>\n\n<p>I've read about Rust ownership and borrowing, but I still don't really understand them, therefore I cannot fix this code. Could someone give me a working variant of what I pasted?</p>\n"}, {"tags": ["string", "rust"], "answers": [{"tags": [], "owner": {"reputation": 3313, "user_id": 1535283, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca8a8e4326ecde562aad35781a0e4e2a?s=128&d=identicon&r=PG", "display_name": "Scott Olson", "link": "https://stackoverflow.com/users/1535283/scott-olson"}, "is_accepted": true, "score": 6, "last_activity_date": 1424009235, "creation_date": 1424009235, "answer_id": 28526891, "question_id": 28526850, "link": "https://stackoverflow.com/questions/28526850/unable-to-coerce-string-to-str/28526891#28526891", "title": "Unable to coerce &amp;String to &amp;str", "body": "<p>That's a really old version of the nightly in Rust terms! Old enough that the <code>&amp;String</code> -> <code>&amp;str</code> coercion isn't available. You just need to upgrade to a newer version.</p>\n"}], "owner": {"reputation": 14666, "user_id": 12637, "user_type": "registered", "accept_rate": 97, "profile_image": "https://www.gravatar.com/avatar/2f3ca6058f9534dfed473cf31341c644?s=128&d=identicon&r=PG", "display_name": "Omar Abid", "link": "https://stackoverflow.com/users/12637/omar-abid"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 421, "favorite_count": 0, "accepted_answer_id": 28526891, "answer_count": 1, "score": 0, "last_activity_date": 1424012137, "creation_date": 1424008936, "last_edit_date": 1424012137, "question_id": 28526850, "link": "https://stackoverflow.com/questions/28526850/unable-to-coerce-string-to-str", "title": "Unable to coerce &amp;String to &amp;str", "body": "<p>I'm trying to compile the following code, from the Rust book at the Rust official website.</p>\n\n<pre><code>fn takes_slice(slice: &amp;str) {\n    println!(\"Got: {}\", slice);\n}\n\nfn main() {\n    let s = \"Hello\".to_string();\n    takes_slice(&amp;s);\n}\n</code></pre>\n\n<p>At compilation, it throws the following error</p>\n\n<blockquote>\n  <p>/devl/rust/bc_09/src/main.rs:7:17: 7:19 error: mismatched types:\n  expected <code>&amp;str</code>, found <code>&amp;collections::string::String</code> (expected str,\n  found struct collections::string::String)</p>\n  \n  <p>/devl/rust/bc_09/src/main.rs:7     takes_slice(&amp;s);\n                                                 ^~ error: aborting due to previous error Could not compile <code>hello_world</code>.</p>\n</blockquote>\n\n<p>Here is the Rust version I'm running: rustc 1.0.0-nightly (44a287e6e 2015-01-08 17:03:40 -0800)</p>\n"}, {"tags": ["rust", "hyper"], "comments": [{"owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "edited": false, "score": 2, "creation_date": 1424010499, "post_id": 28526180, "comment_id": 45369715, "body": "Looks like they haven&#39;t used <a href=\"http://doc.rust-lang.org/book/macros.html#the-variable-%24crate\" rel=\"nofollow noreferrer\"><code>$crate</code></a> when referencing their own modules. Should be a simple fix!"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1424018303, "creation_date": 1424018303, "answer_id": 28528372, "question_id": 28526180, "link": "https://stackoverflow.com/questions/28526180/unresolved-import-when-calling-a-macro-defined-in-an-external-crate/28528372#28528372", "title": "Unresolved import when calling a macro defined in an external crate", "body": "<p>I agree with Renato that this is an issue with hyper, and you should file a bug (or even better a pull request!). If you'd like to work around it for now though, you can re-export <code>header</code> as your own:</p>\n\n<pre><code>#[macro_use]\nextern crate hyper;\n\npub use hyper::header as header;\n\nstruct CustomHeader;\nimpl_header!(CustomHeader, \"value\", String);\n\nfn main() {}\n</code></pre>\n\n<p>Unfortunately, this simply unlocks a whole new wave of errors that I'll let you figure out!</p>\n"}], "owner": {"reputation": 1488, "user_id": 2417347, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/6be6de9a9f6d32c008ea322627ffacd6?s=128&d=identicon&r=PG", "display_name": "mhristache", "link": "https://stackoverflow.com/users/2417347/mhristache"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 866, "favorite_count": 0, "accepted_answer_id": 28528372, "answer_count": 1, "score": 1, "last_activity_date": 1424790380, "creation_date": 1424004430, "last_edit_date": 1424790380, "question_id": 28526180, "link": "https://stackoverflow.com/questions/28526180/unresolved-import-when-calling-a-macro-defined-in-an-external-crate", "title": "Unresolved import when calling a macro defined in an external crate", "body": "<p>I am trying to implement a custom HTTP header using <a href=\"http://hyperium.github.io/hyper/hyper/macro.impl_header!.html\" rel=\"nofollow\">impl_header</a> macro from hyper crate but it seems it cannot resolve the <code>hyper::header</code> module.</p>\n\n<p>Here is my code:</p>\n\n<pre><code>#[macro_use] extern crate hyper;\nuse hyper::header;\nstruct CustomHeader;\nimpl_header!(CustomHeader, \"value\", String);\n</code></pre>\n\n<p>And here is the compiler error:</p>\n\n<pre><code>&lt;hyper macros&gt;:11:14: 11:20 error: unresolved import `header::HeaderFormat`. Maybe a missing `extern crate header`?\n&lt;hyper macros&gt;:11 Result { use header:: HeaderFormat ; self . fmt_header ( f ) } } }\n                               ^~~~~~\n&lt;hyper macros&gt;:1:1: 11:67 note: in expansion of impl_header!\nlib.rs:4:1: 4:45 note: expansion site\nerror: aborting due to previous error\nCould not compile `macro_issue`.\n</code></pre>\n\n<p>Any clue why this happens and how can I fix it?</p>\n\n<p>Thank you</p>\n"}, {"tags": ["initialization", "rust", "lifetime"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424011175, "post_id": 28525270, "comment_id": 45369903, "body": "This was <a href=\"http://www.reddit.com/r/rust/comments/2vynfa/stackoverflow_resources_in_initialisers_help_is/\" rel=\"nofollow noreferrer\">cross-posted to Reddit</a>"}], "answers": [{"comments": [{"owner": {"reputation": 6499, "user_id": 1320374, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/b75569a6d70d16ef886a720fc0dc94cd?s=128&d=identicon&r=PG", "display_name": "IluTov", "link": "https://stackoverflow.com/users/1320374/ilutov"}, "edited": false, "score": 0, "creation_date": 1423999173, "post_id": 28525442, "comment_id": 45366860, "body": "Yes, it is a trait and actually generic and thus the size can vary, which is why the reference is needed in the first place. Any thoughts?"}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 6499, "user_id": 1320374, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/b75569a6d70d16ef886a720fc0dc94cd?s=128&d=identicon&r=PG", "display_name": "IluTov", "link": "https://stackoverflow.com/users/1320374/ilutov"}, "edited": false, "score": 1, "creation_date": 1423999478, "post_id": 28525442, "comment_id": 45366923, "body": "Yeah in that case, AFAIK, you have to provide a reference that outlives the initializer, so it would have to be passed into the initializer as an argument. Otherwise yeah you&#39;d have to use a Box, since in that case the lifetime wouldn&#39;t factor in because you&#39;d be moving it entirely into the new struct."}], "tags": [], "owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "is_accepted": true, "score": 3, "last_activity_date": 1423998626, "creation_date": 1423998626, "answer_id": 28525442, "question_id": 28525270, "link": "https://stackoverflow.com/questions/28525270/how-do-i-initialise-a-struct-that-contains-a-reference/28525442#28525442", "title": "How do I initialise a struct that contains a reference?", "body": "<p>It's difficult to say for sure without knowing what <code>Bar</code> is. If it's a trait, then yeah it needs to be a <code>&amp;Bar</code> or <code>Box&lt;Bar&gt;</code>. If it's just a regular type, then the normal thing to do is to store it directly:</p>\n\n<pre><code>struct Foo {\n    bar: Bar\n}\n</code></pre>\n\n<p>When you hear that <code>&amp;Bar</code> is preferred for flexibility, that's usually with respect to function parameters, e.g. <code>fn func(bar: &amp;Bar)</code>, and even then it really depends on what you're actually doing. However, when defining a field on a struct, storing the value directly is usually what you want, unless you know what you're doing. This conveys clearly that the <code>Foo</code> <em>owns</em> the <code>Bar</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 7, "last_activity_date": 1424011794, "creation_date": 1424011794, "answer_id": 28527271, "question_id": 28525270, "link": "https://stackoverflow.com/questions/28525270/how-do-i-initialise-a-struct-that-contains-a-reference/28527271#28527271", "title": "How do I initialise a struct that contains a reference?", "body": "<p>Your question doesn't really make sense. If you are constructing the object in your <code>new</code> method, then by definition <em>you know what the type is</em> (because you are calling that constructor), and you don't need to treat it as a trait object. You should just use the type!</p>\n\n<blockquote>\n  <p>The reason the reference is needed is because Bar is actually a generic trait in my case and thus the size can vary which means allocation on the stack won't work.</p>\n</blockquote>\n\n<p>This isn't completely true! If you wanted to accept a parameter, and you want to transfer ownership, then you can simply restrict the type to the trait you wish:</p>\n\n<pre><code>trait Talker { fn talk(&amp;self); }\n\nstruct Dog;\nimpl Talker for Dog { fn talk(&amp;self) { println!(\"Woof\") }}\n\nstruct Cat;\nimpl Talker for Cat { fn talk(&amp;self) { println!(\"Meow\") }}\n\nstruct OwnAGeneric&lt;T: Talker&gt; {\n    t: T\n}\n\nimpl&lt;T: Talker&gt; OwnAGeneric&lt;T&gt; {\n    fn new(t: T) -&gt; OwnAGeneric&lt;T&gt; { OwnAGeneric { t: t } }\n\n    fn talk(&amp;self) { println!(\"I own this:\"); self.t.talk(); }\n}\n\nfn main() {\n    let owned_cat = OwnAGeneric::new(Cat);  \n    owned_cat.talk();\n}\n</code></pre>\n\n<p>This should be monomorphized by the compiler and basically as fast as if you had written the code out by hand. This also allows everything to be allocated on the stack.</p>\n"}], "owner": {"reputation": 6499, "user_id": 1320374, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/b75569a6d70d16ef886a720fc0dc94cd?s=128&d=identicon&r=PG", "display_name": "IluTov", "link": "https://stackoverflow.com/users/1320374/ilutov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 585, "favorite_count": 0, "accepted_answer_id": 28525442, "answer_count": 2, "score": 3, "last_activity_date": 1424011968, "creation_date": 1423997180, "last_edit_date": 1424011968, "question_id": 28525270, "link": "https://stackoverflow.com/questions/28525270/how-do-i-initialise-a-struct-that-contains-a-reference", "title": "How do I initialise a struct that contains a reference?", "body": "<p>I want to write an initialiser for the following struct.</p>\n\n<pre><code>struct Foo {\n    bar: &amp;Bar\n}\n</code></pre>\n\n<p>It's recommended to use <code>&amp;T</code> over <code>Box&lt;T&gt;</code> for flexibility and that's what I'm going for here. Without an initialiser you'd use the struct like this.</p>\n\n<pre><code>{\n    let bar = ...;\n    let foo = Foo { bar: bar };\n\n    // use foo    \n\n    // dealloc bar and foo\n}\n</code></pre>\n\n<p>This works. But I want to allocate <code>&amp;Bar</code> in the initialiser. Now obviously allocating <code>bar</code> on the stack will not work because it goes out of scope once the initialiser returns. So I thought I could use <code>Box</code>.</p>\n\n<pre><code>fn new() -&gt; Foo {\n    let bar = Box::new(...);\n    Foo { bar: &amp;*bar }\n}\n</code></pre>\n\n<p>This does not work either because I guess we're just borrowing the value instead of transferring ownership which will still deallocate <code>bar</code> once <code>new</code> returns. </p>\n\n<p>Am I forced to use a <code>Box</code> in the struct in this case?</p>\n\n<h3>EDIT</h3>\n\n<p><em>Note</em>: The reason the reference is needed is because <code>Bar</code> is actually a generic trait in my case and thus the size can vary which means allocation on the stack won't work.</p>\n"}, {"tags": ["multithreading", "design-patterns", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1424013553, "post_id": 28523778, "comment_id": 45370552, "body": "Please reform your code to be a <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a>. As it is right now, it&#39;s very hard to compile it to see your error. Also, please add the error you get when you say &quot;&amp;self isn&#39;t Thread-safe&quot;. On top of all that, your code is inconsistent - you removed <code>&amp;self</code> from <code>handle_client</code>, but still use it as a method in <code>initialize</code>! Showing that you care about your question&#39;s quality is the first step to getting quality answers!"}, {"owner": {"reputation": 1313, "user_id": 764463, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/dad0a9bf7a0990e937a1d119971aa93b?s=128&d=identicon&r=PG", "display_name": "Temuz", "link": "https://stackoverflow.com/users/764463/temuz"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424033779, "post_id": 28523778, "comment_id": 45377031, "body": "Sir yes sir - the code in question is actually a lot bigger, I just cut out the good parts for the question. I&#39;ll update my question and make the above pieces compile."}, {"owner": {"reputation": 1313, "user_id": 764463, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/dad0a9bf7a0990e937a1d119971aa93b?s=128&d=identicon&r=PG", "display_name": "Temuz", "link": "https://stackoverflow.com/users/764463/temuz"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424034344, "post_id": 28523778, "comment_id": 45377220, "body": "Should be better now! Sorry about that. It was late at night :)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1424034396, "post_id": 28523778, "comment_id": 45377248, "body": "No worries! I&#39;m not trying to be a jerk, more like a lowly janitor, helping to make sure questions are clear and useful to people who come afterwards. ^_^"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424038072, "post_id": 28523778, "comment_id": 45378455, "body": "Here&#39;s a <a href=\"http://is.gd/oZQ0kU\" rel=\"nofollow noreferrer\">minimal example of the error</a>"}], "answers": [{"comments": [{"owner": {"reputation": 1313, "user_id": 764463, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/dad0a9bf7a0990e937a1d119971aa93b?s=128&d=identicon&r=PG", "display_name": "Temuz", "link": "https://stackoverflow.com/users/764463/temuz"}, "edited": false, "score": 0, "creation_date": 1424035383, "post_id": 28525062, "comment_id": 45377564, "body": "Thanks for the response! This works, but it means I need one thread to look at the socket and another looking at the channel to handle responses. This means I need two threads per socket (or having one thread per socket and have a &quot;listener&quot; thread that checks each channel maybe?). I was hoping for a way where I could keep one thread per socket."}, {"owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "reply_to_user": {"reputation": 1313, "user_id": 764463, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/dad0a9bf7a0990e937a1d119971aa93b?s=128&d=identicon&r=PG", "display_name": "Temuz", "link": "https://stackoverflow.com/users/764463/temuz"}, "edited": false, "score": 1, "creation_date": 1424039834, "post_id": 28525062, "comment_id": 45378996, "body": "There are some classic approaches for client/server architectures, for example, multiplexing (one thread + select/poll/kqueue/epoll), master thread accepting connection + one new fresh thread per each incoming connection, or mixed solutions with threads pools. If you really want threading, you should redesign your code somehow, because rust will not let you share &amp;self between threads. I suggest consider Shepmaster&#39;s solution with interface splitting."}], "tags": [], "owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "is_accepted": false, "score": 1, "last_activity_date": 1423995417, "creation_date": 1423995417, "answer_id": 28525062, "question_id": 28523778, "link": "https://stackoverflow.com/questions/28523778/using-trait-methods-in-threads/28525062#28525062", "title": "Using trait methods in threads", "body": "<p>I don't think that rust will allow you to invoke object methods directly from other thread because \"move\" closures cannot borrow anything, only move.</p>\n\n<p>So you have to use some kind of inter-thread communication tool, for example, channels:</p>\n\n<pre><code>use std::thread::Thread;\nuse std::sync::{Arc, Mutex};\nuse std::sync::mpsc::{channel, Sender, Receiver, RecvError};\nuse std::net::{TcpStream, TcpListener};\nuse std::io::{ErrorKind, Write};\n\ntrait Server {\n    fn new(port: u16) -&gt; Self;\n\n    fn hostname(&amp;self) -&gt; &amp;String;\n\n    fn initialize(&amp;mut self, _detached: bool) {\n        let acceptor = TcpListener::bind(self.hostname().as_slice()).unwrap();\n        let server_tx = self.make_pipe();\n        Thread::spawn(move|| {\n            for incoming_stream in acceptor.incoming() {\n                match incoming_stream {\n                    Ok(stream) =&gt; server_tx.send(Arc::new(Mutex::new(stream))).unwrap(),\n                    Err(ref e) if e.kind() == ErrorKind::NotConnected =&gt; break,\n                    Err(e) =&gt; panic!(\"Unexpected error: {}\", e),\n                }\n            }\n        });\n    }\n\n    fn handle_client(&amp;self, stream: Arc&lt;Mutex&lt;TcpStream&gt;&gt;);\n    fn make_pipe(&amp;mut self) -&gt; Sender&lt;Arc&lt;Mutex&lt;TcpStream&gt;&gt;&gt;;\n    fn run(&amp;self);\n}\n\npub struct InternodeServer {\n    hostname: String,\n    client_rx: Option&lt;Receiver&lt;Arc&lt;Mutex&lt;TcpStream&gt;&gt;&gt;&gt;,\n}\n\nimpl Server for InternodeServer {\n    fn new(port: u16) -&gt; InternodeServer {\n        let hostname = format!(\"127.0.0.1:{}\", port);\n        InternodeServer {\n            hostname: hostname,\n            client_rx: None,\n        }\n    }\n\n    fn make_pipe(&amp;mut self) -&gt; Sender&lt;Arc&lt;Mutex&lt;TcpStream&gt;&gt;&gt; {\n        let (server_tx, client_rx) = channel();\n        self.client_rx = Some(client_rx);\n        server_tx\n    }\n\n    fn hostname(&amp;self) -&gt; &amp;String {\n        &amp;self.hostname\n    }\n\n    fn handle_client(&amp;self, stream_arc: Arc&lt;Mutex&lt;TcpStream&gt;&gt;) {\n        println!(\"Received connection\");\n        let mut stream = stream_arc.lock().unwrap();\n        let response = b\"Hello\\r\\n\";\n        let _ = stream.write_all(response);\n        let _ = drop(stream);\n    }\n\n    fn run(&amp;self) {\n        loop {\n            match self.client_rx.as_ref().unwrap().recv() {\n                Ok(stream) =&gt; self.handle_client(stream),\n                Err(RecvError) =&gt; break,\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut s = &lt;InternodeServer as Server&gt;::new(10101);\n    s.initialize(false);\n    s.run();\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1424038568, "creation_date": 1424038568, "answer_id": 28531839, "question_id": 28523778, "link": "https://stackoverflow.com/questions/28523778/using-trait-methods-in-threads/28531839#28531839", "title": "Using trait methods in threads", "body": "<p>Here's a smaller reproduction of the error:</p>\n\n<pre><code>use std::thread::Thread;\n\ntrait Server {\n    fn initialize(&amp;self) {\n        Thread::spawn(move || self.handle_client());\n    }\n\n    fn handle_client(&amp;self);\n}\n\nfn main() {}\n</code></pre>\n\n<p>The problem is that the argument passed to <a href=\"http://doc.rust-lang.org/std/thread/struct.Thread.html#method.spawn\" rel=\"nofollow\"><code>Thread::spawn</code></a> must be <a href=\"http://doc.rust-lang.org/std/marker/trait.Send.html\" rel=\"nofollow\"><code>Send</code></a>. You are trying to move <code>self</code> into the closure, but your trait doesn't guarantee <code>Send</code>, so the closure can't be <code>Send</code>.</p>\n\n<p>We can attempt to go down that path with <code>trait Server: Send</code>, but then we get \"cannot infer an appropriate lifetime\" errors because <code>Send</code> also requires <code>'static</code> (<a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0458-send-improvements.md\" rel=\"nofollow\">for now</a>). Also, it seems very strange to <em>move yourself</em> into a closure.</p>\n\n<p>Really, I think you want to split up your code. Move <code>handle_client</code> into a separate trait and then ensure that implementations of that trait are <code>Send</code>:</p>\n\n<pre><code>use std::thread::Thread;\n\ntrait Server {\n    fn initialize&lt;D&gt;(&amp;self, driver: D)\n        where D: Driver + Send\n    {\n        Thread::spawn(move || driver.handle_client());\n    }\n}\n\ntrait Driver {\n    fn handle_client(&amp;self);\n}\n\nfn main() {}\n</code></pre>\n"}], "owner": {"reputation": 1313, "user_id": 764463, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/dad0a9bf7a0990e937a1d119971aa93b?s=128&d=identicon&r=PG", "display_name": "Temuz", "link": "https://stackoverflow.com/users/764463/temuz"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 290, "favorite_count": 0, "accepted_answer_id": 28531839, "answer_count": 2, "score": 0, "last_activity_date": 1424038568, "creation_date": 1423983465, "last_edit_date": 1424035955, "question_id": 28523778, "link": "https://stackoverflow.com/questions/28523778/using-trait-methods-in-threads", "title": "Using trait methods in threads", "body": "<p>Basically, I'm making a program that's listening to a bunch of ports and that handles incoming packets in different ways. I decide to bundle this code into a Trait:</p>\n\n<pre><code>use std::old_io::{TcpStream, TcpListener, Listener, Acceptor, EndOfFile, IoResult};\nuse std::thread::Thread;\n\ntrait Server {\n    fn new(port: u16) -&gt; Self;\n\n    fn hostname(&amp;self) -&gt; &amp;String;\n\n    fn initialize(&amp;self) {\n        let acceptor = TcpListener::bind(self.hostname().as_slice()).listen().unwrap();\n        Thread::spawn(move|| {\n            let mut acceptor = acceptor;\n            for incoming_stream in acceptor.incoming() {\n                match incoming_stream {\n                    Ok(stream) =&gt; {\n                        self.handle_client(stream);\n                    },\n                    Err(ref e) if e.kind == EndOfFile =&gt; break,\n                    Err(e) =&gt; panic!(\"Unexpected error: {}\", e),\n                }\n            }\n        });\n    }\n\n    fn handle_client(&amp;self, stream: TcpStream) -&gt; ();\n}\n\npub struct InternodeServer {\n    hostname: String,\n}\n\nimpl Server for InternodeServer {\n    fn new(port: u16) -&gt; InternodeServer {\n        let hostname = format!(\"127.0.0.1:{}\", port);\n        InternodeServer {\n            hostname: hostname,\n        }\n    }\n\n    fn hostname(&amp;self) -&gt; &amp;String {\n        &amp;self.hostname\n    }\n\n    fn handle_client(&amp;self, stream: TcpStream) {\n        println!(\"Received connection\");\n        let mut stream = stream;\n        let response = b\"Hello\\r\\n\";\n        let _ = stream.write_all(response);\n        let _ = stream.close_write();\n    }\n}\n\nfn main() {\n    let test_server = &lt;InternodeServer as Server&gt;::new(9337);\n    test_server.initialize();\n}\n</code></pre>\n\n<p>However, this code won't work because you can't send <code>Self</code>. This is the error I receive:</p>\n\n<pre><code>test.rs:11:9: 11:22 error: the trait `core::marker::Send` is not implemented for the type `Self` [E0277]\ntest.rs:11         Thread::spawn(move|| {\n                   ^~~~~~~~~~~~~\ntest.rs:11:9: 11:22 note: `Self` cannot be sent between threads safely\ntest.rs:11         Thread::spawn(move|| {\n                   ^~~~~~~~~~~~~\n</code></pre>\n\n<p>So I also tried making handle_client a static method to avoid self. To do this, I simply changed handle_client to:</p>\n\n<pre><code>fn handle_client(stream: TcpStream)\n</code></pre>\n\n<p>And referenced it by doing:</p>\n\n<pre><code>Server::handle_client(stream);\n</code></pre>\n\n<p>However, I can't reference InternodeServer's static methods from Server's initialize method. When compiling, I get an error like:</p>\n\n<pre><code>test.rs:16:25: 16:46 error: type annotations required: cannot resolve `_ : Server` [E0283]\ntest.rs:16                         Server::handle_client(stream);\n                                   ^~~~~~~~~~~~~~~~~~~~~\ntest.rs:16:25: 16:46 note: required by `Server::handle_client`\ntest.rs:16                         Server::handle_client(stream);\n</code></pre>\n\n<p>Is there any way around this?</p>\n"}, {"tags": ["closures", "rust"], "comments": [{"owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "edited": false, "score": 2, "creation_date": 1423961559, "post_id": 28521637, "comment_id": 45360616, "body": "You wouldn&#39;t need the <code>move</code>s, a mutable borrow would&#39;ve been fine. But for some reason I don&#39;t fully understand the borrow checker won&#39;t allow it (if the <code>seen.push</code> call is removed, it compiles fine). I suggest trying to boil the problem down a bit and filing an issue. <code>flat_map</code> is <i>the</i> cause for most of the confusing borrow checker errors I&#39;ve gotten so far"}], "answers": [{"tags": [], "owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "is_accepted": false, "score": 10, "last_activity_date": 1500568726, "last_edit_date": 1500568726, "creation_date": 1423961767, "answer_id": 28521985, "question_id": 28521637, "link": "https://stackoverflow.com/questions/28521637/how-can-i-move-a-captured-variable-into-a-closure-within-a-closure/28521985#28521985", "title": "How can I move a captured variable into a closure within a closure?", "body": "<p><del>It seems that the borrow checker is getting confused at the nested closures + mutable borrow. It might be worth filing an issue.</del> Edit: See <a href=\"https://stackoverflow.com/a/28526154/155423\">huon's answer</a> for why this isn't a bug.</p>\n\n<p>As a workaround, it's possible to resort to <code>RefCell</code> here:</p>\n\n<pre><code>use std::cell::RefCell;\n\nfn main() {\n    let seen = vec![];\n    let items = vec![vec![1i32, 2], vec![3], vec![1]];\n\n    let seen_cell = RefCell::new(seen);\n\n    let a: Vec&lt;_&gt; = items\n        .iter()\n        .flat_map(|inner_numbers| {\n            inner_numbers.iter().filter_map(|&amp;number| {\n                let mut borrowed = seen_cell.borrow_mut();\n\n                if !borrowed.contains(&amp;number) {\n                    borrowed.push(number);\n                    Some(number)\n                } else {\n                    None\n                }\n            })\n        })\n        .collect();\n\n    println!(\"{:?}\", a);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "edited": false, "score": 4, "creation_date": 1424010108, "post_id": 28526154, "comment_id": 45369606, "body": "Great answer! Very educational. An additional alternative would be to just write the code using for loops instead - it&#39;s arguably simpler than both workarounds, and probably more efficient"}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 32, "last_activity_date": 1500568660, "last_edit_date": 1500568660, "creation_date": 1424004226, "answer_id": 28526154, "question_id": 28521637, "link": "https://stackoverflow.com/questions/28521637/how-can-i-move-a-captured-variable-into-a-closure-within-a-closure/28526154#28526154", "title": "How can I move a captured variable into a closure within a closure?", "body": "<p>This is a little surprising, but isn't a bug.</p>\n\n<p><a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map\" rel=\"noreferrer\"><code>flat_map</code></a> takes a <code>FnMut</code> as it needs to call the closure multiple times. The code with <code>move</code> on the inner closure fails because that closure is created multiple times, once for each <code>inner_numbers</code>. If I write the closures in explicit form (i.e. a struct that stores the captures and an implementation of one of the closure traits) your code looks (a bit) like</p>\n\n<pre><code>struct OuterClosure {\n    seen: Vec&lt;i32&gt;\n}\nstruct InnerClosure {\n    seen: Vec&lt;i32&gt;\n}\nimpl FnMut(&amp;Vec&lt;i32&gt;) -&gt; iter::FilterMap&lt;..., InnerClosure&gt; for OuterClosure {\n    fn call_mut(&amp;mut self, (inner_numbers,): &amp;Vec&lt;i32&gt;) -&gt; iter::FilterMap&lt;..., InnerClosure&gt; {\n        let inner = InnerClosure {\n            seen: self.seen // uh oh! a move out of a &amp;mut pointer\n        };\n        inner_numbers.iter().filter_map(inner)\n    }\n}\nimpl FnMut(&amp;i32) -&gt; Option&lt;i32&gt; for InnerClosure { ... }\n</code></pre>\n\n<p>Which makes the illegality clearer: attempting to move out of the <code>&amp;mut OuterClosure</code> variable.</p>\n\n<hr>\n\n<p><em>Theoretically</em>, just capturing a mutable reference is sufficient, since the <code>seen</code> is only being modified (not moved) inside the closure. However things are too lazy for this to work...</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: lifetime of `seen` is too short to guarantee its contents can be safely reborrowed\n --&gt; src/main.rs:9:45\n  |\n9 |             inner_numbers.iter().filter_map(|&amp;number| {\n  |                                             ^^^^^^^^^\n  |\nnote: `seen` would have to be valid for the method call at 7:20...\n --&gt; src/main.rs:7:21\n  |\n7 |       let a: Vec&lt;_&gt; = items.iter()\n  |  _____________________^\n8 | |         .flat_map(|inner_numbers| {\n9 | |             inner_numbers.iter().filter_map(|&amp;number| {\n10| |                 if !seen.contains(&amp;number) {\n... |\n17| |         })\n18| |         .collect();\n  | |__________________^\nnote: ...but `seen` is only valid for the lifetime  as defined on the body at 8:34\n --&gt; src/main.rs:8:35\n  |\n8 |           .flat_map(|inner_numbers| {\n  |  ___________________________________^\n9 | |             inner_numbers.iter().filter_map(|&amp;number| {\n10| |                 if !seen.contains(&amp;number) {\n11| |                     seen.push(number);\n... |\n16| |             })\n17| |         })\n  | |_________^\n</code></pre>\n\n<p>Removing the <code>move</code>s makes the closure captures work like</p>\n\n<pre><code>struct OuterClosure&lt;'a&gt; {\n    seen: &amp;'a mut Vec&lt;i32&gt;\n}\nstruct InnerClosure&lt;'a&gt; {\n    seen: &amp;'a mut Vec&lt;i32&gt;\n}\nimpl&lt;'a&gt; FnMut(&amp;Vec&lt;i32&gt;) -&gt; iter::FilterMap&lt;..., InnerClosure&lt;??&gt;&gt; for OuterClosure&lt;'a&gt; {\n    fn call_mut&lt;'b&gt;(&amp;'b mut self, inner_numbers: &amp;Vec&lt;i32&gt;) -&gt; iter::FilterMap&lt;..., InnerClosure&lt;??&gt;&gt; {\n        let inner = InnerClosure {\n            seen: &amp;mut *self.seen // can't move out, so must be a reborrow\n        };\n        inner_numbers.iter().filter_map(inner)\n    }\n}\nimpl&lt;'a&gt; FnMut(&amp;i32) -&gt; Option&lt;i32&gt; for InnerClosure&lt;'a&gt; { ... }\n</code></pre>\n\n<p>(I've named the <code>&amp;mut self</code> lifetime in this one, for pedagogical purposes.)</p>\n\n<p>This case is definitely more subtle. The <code>FilterMap</code> iterator stores the closure internally, meaning any references in the closure value (that is, any references it captures) have to be valid as long as the <code>FilterMap</code> values are being thrown around, and, for <code>&amp;mut</code> references, any references have to be careful to be non-aliased.</p>\n\n<p>The compiler can't be sure <code>flat_map</code> won't, e.g. store all the returned iterators in a <code>Vec&lt;FilterMap&lt;...&gt;&gt;</code> which would result in a pile of aliased <code>&amp;mut</code>s... very bad! I <em>think</em> this specific use of <code>flat_map</code> happens to be safe, but I'm not sure it is in general, and there's certainly functions with the same style of signature as <code>flat_map</code> (e.g. <code>map</code>) would definitely be <code>unsafe</code>. (In fact, replacing <code>flat_map</code> with <code>map</code> in the code gives the <code>Vec</code> situation I just described.)</p>\n\n<p>For the error message: <code>self</code> is effectively (ignoring the struct wrapper) <code>&amp;'b mut (&amp;'a mut Vec&lt;i32&gt;)</code> where <code>'b</code> is the lifetime of <code>&amp;mut self</code> reference and <code>'a</code> is the lifetime of the reference in the <code>struct</code>. Moving the inner <code>&amp;mut</code> out is illegal: can't move an affine type like <code>&amp;mut</code> out of a reference (it would work with <code>&amp;Vec&lt;i32&gt;</code>, though), so the only choice is to reborrow. A reborrow is going through the outer reference and so cannot outlive it, that is, the <code>&amp;mut *self.seen</code> reborrow is a <code>&amp;'b mut Vec&lt;i32&gt;</code>, not a <code>&amp;'a mut Vec&lt;i32&gt;</code>.</p>\n\n<p>This makes the inner closure have type <code>InnerClosure&lt;'b&gt;</code>, and hence the <code>call_mut</code> method is trying to return a <code>FilterMap&lt;..., InnerClosure&lt;'b&gt;&gt;</code>. Unfortunately, <a href=\"https://doc.rust-lang.org/std/ops/trait.FnMut.html\" rel=\"noreferrer\">the <code>FnMut</code> trait</a> defines <code>call_mut</code> as just</p>\n\n<pre><code>pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {\n    extern \"rust-call\" fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;\n}\n</code></pre>\n\n<p>In particular, there's no connection between the lifetime of the <code>self</code> reference itself and the returned value, and so it is illegal to try to return <code>InnerClosure&lt;'b&gt;</code> which has that link. This is why the compiler is complaining that the lifetime is too short to be able to reborrow.</p>\n\n<p>This is extremely similar to the <code>Iterator::next</code> method, and the code here is failing for basically the same reason that one cannot have an iterator over references into memory that the iterator itself owns. (I imagine a <a href=\"https://github.com/emk/rust-streaming\" rel=\"noreferrer\">\"streaming iterator\"</a> (iterators with a link between <code>&amp;mut self</code> and the return value in <code>next</code>) library would be able to provide a <code>flat_map</code> that works with the code nearly written: would need \"closure\" traits with a similar link.)</p>\n\n<p>Work-arounds include:</p>\n\n<ul>\n<li>the <code>RefCell</code> suggested by Renato Zannon, which allows <code>seen</code> to be borrowed as a shared <code>&amp;</code>. The desugared closure code is basically the same other than changing the <code>&amp;mut Vec&lt;i32&gt;</code> to <code>&amp;Vec&lt;i32&gt;</code>. This change means \"reborrow\" of the <code>&amp;'b mut &amp;'a RefCell&lt;Vec&lt;i32&gt;&gt;</code> can just be a copy of the <code>&amp;'a ...</code> out of the <code>&amp;mut</code>. It's a literal copy, so the lifetime is retained.</li>\n<li>avoiding the laziness of iterators, to avoid returning the inner closure, specifically<code>.collect::&lt;Vec&lt;_&gt;&gt;()</code>ing inside the loop to run through the whole <code>filter_map</code> before returning.</li>\n</ul>\n\n    \n\n<pre><code>fn main() {\n    let mut seen = vec![];\n    let items = vec![vec![1i32, 2], vec![3], vec![1]];\n\n    let a: Vec&lt;_&gt; = items\n        .iter()\n        .flat_map(|inner_numbers| {\n            inner_numbers\n                .iter()\n                .filter_map(|&amp;number| if !seen.contains(&amp;number) {\n                    seen.push(number);\n                    Some(number)\n                } else {\n                    None\n                })\n                .collect::&lt;Vec&lt;_&gt;&gt;()\n                .into_iter()\n        })\n        .collect();\n\n    println!(\"{:?}\", a);\n}\n</code></pre>\n\n<p>I imagine the <code>RefCell</code> version is more efficient.</p>\n"}], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 12451, "favorite_count": 9, "accepted_answer_id": 28526154, "answer_count": 2, "score": 27, "last_activity_date": 1542165242, "creation_date": 1423958308, "last_edit_date": 1542165242, "question_id": 28521637, "link": "https://stackoverflow.com/questions/28521637/how-can-i-move-a-captured-variable-into-a-closure-within-a-closure", "title": "How can I move a captured variable into a closure within a closure?", "body": "<p>This code is an inefficient way of producing a unique set of items from an iterator. To accomplish this, I am attempting to use a <code>Vec</code> to keep track of values I've seen. I believe that this <code>Vec</code> needs to be owned by the innermost closure:</p>\n\n<pre><code>fn main() {\n    let mut seen = vec![];\n    let items = vec![vec![1i32, 2], vec![3], vec![1]];\n\n    let a: Vec&lt;_&gt; = items\n        .iter()\n        .flat_map(move |inner_numbers| {\n            inner_numbers.iter().filter_map(move |&amp;number| {\n                if !seen.contains(&amp;number) {\n                    seen.push(number);\n                    Some(number)\n                } else {\n                    None\n                }\n            })\n        })\n        .collect();\n\n    println!(\"{:?}\", a);\n}\n</code></pre>\n\n<p>However, compilation fails with:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of captured outer variable in an `FnMut` closure\n --&gt; src/main.rs:8:45\n  |\n2 |     let mut seen = vec![];\n  |         -------- captured outer variable\n...\n8 |             inner_numbers.iter().filter_map(move |&amp;number| {\n  |                                             ^^^^^^^^^^^^^^ cannot move out of captured outer variable in an `FnMut` closure\n</code></pre>\n"}, {"tags": ["rust", "reference", "language-lawyer"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1424094086, "post_id": 28519997, "comment_id": 45398881, "body": "I&#39;ve cross-posted this to the <a href=\"http://www.reddit.com/r/rust/comments/2w2ozm/what_are_rusts_exact_autodereferencing_rules/\" rel=\"nofollow noreferrer\">Rust subreddit</a> in the hopes of getting some good answers!"}, {"owner": {"reputation": 793, "user_id": 2665887, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/58236dce0b5672eb68e8a6ae0a92ef51?s=128&d=identicon&r=PG", "display_name": "user2665887", "link": "https://stackoverflow.com/users/2665887/user2665887"}, "edited": false, "score": 0, "creation_date": 1424097613, "post_id": 28519997, "comment_id": 45401003, "body": "For extra fun try to repeat the experiment in generics and compare the results."}], "answers": [{"comments": [{"owner": {"reputation": 9895, "user_id": 452775, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/88963e7cc58eabf150447e7b78a24793?s=128&d=identicon&r=PG", "display_name": "Lii", "link": "https://stackoverflow.com/users/452775/lii"}, "edited": false, "score": 30, "creation_date": 1503226896, "post_id": 28552082, "comment_id": 78519904, "body": "This answer seems exhaustive and detailed but I think it lacks a short and accessible summery of the rules. One such summery is given in this <a href=\"https://stackoverflow.com/questions/36426207/why-does-rust-not-deref-string-to-str?noredirect=1&amp;lq=1#comment60472747_36426207\">comment by Shepmaster</a>: &quot;It [the deref algorithm] will deref as many times as possible (<code>&amp;&amp;String</code> -&gt; <code>&amp;String</code> -&gt; <code>String</code> -&gt; <code>str</code>) and then reference at max once (<code>str</code> -&gt; <code>&amp;str</code>)&quot;."}, {"owner": {"reputation": 9895, "user_id": 452775, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/88963e7cc58eabf150447e7b78a24793?s=128&d=identicon&r=PG", "display_name": "Lii", "link": "https://stackoverflow.com/users/452775/lii"}, "edited": false, "score": 0, "creation_date": 1503227029, "post_id": 28552082, "comment_id": 78519946, "body": "(I don&#39;t know how accurate and complete that explanation is myself.)"}, {"owner": {"reputation": 9895, "user_id": 452775, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/88963e7cc58eabf150447e7b78a24793?s=128&d=identicon&r=PG", "display_name": "Lii", "link": "https://stackoverflow.com/users/452775/lii"}, "edited": false, "score": 2, "creation_date": 1527694746, "post_id": 28552082, "comment_id": 88227031, "body": "In what cases do auto dereferencing occur? Is it used only for the receiver expression for method call? For field accesses also? Assignment right-hand sides? Left-hand sides? Function parameters? Return value expressions?"}, {"owner": {"reputation": 8162, "user_id": 294313, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/165e55c78689e561c554c3dec671fb50?s=128&d=identicon&r=PG", "display_name": "SamB", "link": "https://stackoverflow.com/users/294313/samb"}, "edited": false, "score": 2, "creation_date": 1540674456, "post_id": 28552082, "comment_id": 92954324, "body": "Note: Currently, the nomicon has a TODO note to steal information from this answer and write it up in <a href=\"https://static.rust-lang.org/doc/master/nomicon/dot-operator.html\" rel=\"nofollow noreferrer\">static.rust-lang.org/doc/master/nomicon/dot-operator.html</a>"}, {"owner": {"reputation": 455, "user_id": 7350842, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/39bec2e0e7e07a1ca7622efc3c1d6256?s=128&d=identicon&r=PG&f=1", "display_name": "haslersn", "link": "https://stackoverflow.com/users/7350842/haslersn"}, "edited": false, "score": 1, "creation_date": 1545935701, "post_id": 28552082, "comment_id": 94737234, "body": "Is coercion (A) tried before this or (B) tried after this or (C) tried in every step of this algorithm or (D) something else?"}, {"owner": {"reputation": 462, "user_id": 5452170, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/16bfc7d23c7bad37f5832e8e01cf849d?s=128&d=identicon&r=PG&f=1", "display_name": "Xiao-Feng Li", "link": "https://stackoverflow.com/users/5452170/xiao-feng-li"}, "reply_to_user": {"reputation": 455, "user_id": 7350842, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/39bec2e0e7e07a1ca7622efc3c1d6256?s=128&d=identicon&r=PG&f=1", "display_name": "haslersn", "link": "https://stackoverflow.com/users/7350842/haslersn"}, "edited": false, "score": 0, "creation_date": 1569530292, "post_id": 28552082, "comment_id": 102637331, "body": "@haslersn  Auto deref  is part of coercion, which includes auto-deref, auto-unsize, auto-ref, etc. See the implementation code here: <a href=\"https://github.com/rust-lang/rust/blob/b6d91a2bdac45cd919497a24207fab843124d4ba/src/librustc_typeck/check/method/probe.rs#L92\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/blob/&hellip;</a>. Auto-unsize is applied after one or more auto-derefs, and auto-ref is after other adjustments. So per you specific question, (C) tried in every step is the answer."}, {"owner": {"reputation": 18645, "user_id": 50385, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/2faf0c72f6a7f65431e7df489878be24?s=128&d=identicon&r=PG", "display_name": "Joseph Garvin", "link": "https://stackoverflow.com/users/50385/joseph-garvin"}, "edited": false, "score": 0, "creation_date": 1597165985, "post_id": 28552082, "comment_id": 112043122, "body": "Notably this coercion does not appear to happen for comparison operators like <code>&gt;</code>, inconsistent with named function calls."}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 170, "last_activity_date": 1592647488, "last_edit_date": 1592647488, "creation_date": 1424128927, "answer_id": 28552082, "question_id": 28519997, "link": "https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082#28552082", "title": "What are Rust&#39;s exact auto-dereferencing rules?", "body": "<p>Your pseudo-code is pretty much correct. For this example, suppose we had a method call <code>foo.bar()</code> where <code>foo: T</code>. I'm going to use the <a href=\"https://doc.rust-lang.org/stable/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\" rel=\"noreferrer\">fully qualified syntax</a> (FQS) to be unambiguous about what type the method is being called with, e.g. <code>A::bar(foo)</code> or <code>A::bar(&amp;***foo)</code>. I'm just going to write a pile of random capital letters, each one is just some arbitrary type/trait, except <code>T</code> is always the type of the original variable <code>foo</code> that the method is called on.</p>\n<p>The core of the algorithm is:</p>\n<ul>\n<li>For each <a href=\"https://github.com/rust-lang/rust/blob/b6d91a2bdac45cd919497a24207fab843124d4ba/src/librustc_typeck/check/method/probe.rs#L166-L196\" rel=\"noreferrer\">&quot;dereference step&quot;</a> <code>U</code> (that is, set <code>U = T</code> and then <code>U = *T</code>, ...)\n<ol>\n<li>if there's a method <code>bar</code> where the receiver type (the type of <code>self</code> in the method) matches <code>U</code> exactly , use it (<a href=\"https://github.com/rust-lang/rust/blob/b6d91a2bdac45cd919497a24207fab843124d4ba/src/librustc_typeck/check/method/probe.rs#L793\" rel=\"noreferrer\">a &quot;by value method&quot;</a>)</li>\n<li>otherwise, add one auto-ref (take <code>&amp;</code> or <code>&amp;mut</code> of the receiver), and, if some method's receiver matches <code>&amp;U</code>, use it (<a href=\"https://github.com/rust-lang/rust/blob/b6d91a2bdac45cd919497a24207fab843124d4ba/src/librustc_typeck/check/method/probe.rs#L798\" rel=\"noreferrer\">an &quot;autorefd method&quot;</a>)</li>\n</ol>\n</li>\n</ul>\n<p>Notably, everything considers the &quot;receiver type&quot; of the method, <em>not</em> the <code>Self</code> type of the trait, i.e. <code>impl ... for Foo { fn method(&amp;self) {} }</code> thinks about <code>&amp;Foo</code> when matching the method, and <code>fn method2(&amp;mut self)</code> would think about <code>&amp;mut Foo</code> when matching.</p>\n<p>It is an error if there's ever multiple trait methods valid in the inner steps (that is, there can be only be zero or one trait methods valid in each of 1. or 2., but there can be one valid for each: the one from 1 will be taken first), and inherent methods take precedence over trait ones. It's also an error if we get to the end of the loop without finding anything that matches. It is also an error to have recursive <code>Deref</code> implementations, which make the loop infinite (they'll hit the &quot;recursion limit&quot;).</p>\n<p>These rules seem to do-what-I-mean in most circumstances, although having the ability to write the unambiguous FQS form is very useful in some edge cases, and for sensible error messages for macro-generated code.</p>\n<p>Only one auto-reference is added because</p>\n<ul>\n<li>if there was no bound, things get bad/slow, since every type can have an arbitrary number of references taken</li>\n<li>taking one reference <code>&amp;foo</code> retains a strong connection to <code>foo</code> (it is the address of <code>foo</code> itself), but taking more starts to lose it: <code>&amp;&amp;foo</code> is the address of some temporary variable on the stack that stores <code>&amp;foo</code>.</li>\n</ul>\n<h2>Examples</h2>\n<p>Suppose we have a call <code>foo.refm()</code>, if <code>foo</code> has type:</p>\n<ul>\n<li><code>X</code>, then we start with <code>U = X</code>, <code>refm</code> has receiver type <code>&amp;...</code>, so step 1 doesn't match, taking an auto-ref gives us <code>&amp;X</code>, and this does match (with <code>Self = X</code>), so the call is <code>RefM::refm(&amp;foo)</code></li>\n<li><code>&amp;X</code>, starts with <code>U = &amp;X</code>, which matches  <code>&amp;self</code> in the first step (with <code>Self = X</code>), and so the call is <code>RefM::refm(foo)</code></li>\n<li><code>&amp;&amp;&amp;&amp;&amp;X</code>, this doesn't match either step (the trait isn't implemented for <code>&amp;&amp;&amp;&amp;X</code> or <code>&amp;&amp;&amp;&amp;&amp;X</code>), so we dereference once to get <code>U = &amp;&amp;&amp;&amp;X</code>, which matches 1 (with <code>Self = &amp;&amp;&amp;X</code>) and the call is <code>RefM::refm(*foo)</code></li>\n<li><code>Z</code>, doesn't match either step so it is dereferenced once, to get <code>Y</code>, which also doesn't match, so it's dereferenced again, to get <code>X</code>, which doesn't match 1, but does match after autorefing, so the call is <code>RefM::refm(&amp;**foo)</code>.</li>\n<li><code>&amp;&amp;A</code>, the 1. doesn't match and neither does 2. since the trait is not implemented for <code>&amp;A</code> (for 1) or <code>&amp;&amp;A</code> (for 2), so it is dereferenced to <code>&amp;A</code>, which matches 1., with <code>Self = A</code></li>\n</ul>\n<p>Suppose we have <code>foo.m()</code>, and that <code>A</code> isn't <code>Copy</code>, if <code>foo</code> has type:</p>\n<ul>\n<li><code>A</code>, then <code>U = A</code> matches <code>self</code> directly so the call is <code>M::m(foo)</code> with <code>Self = A</code></li>\n<li><code>&amp;A</code>, then 1. doesn't match, and neither does 2. (neither <code>&amp;A</code> nor <code>&amp;&amp;A</code> implement the trait), so it is dereferenced to <code>A</code>, which does match, but <code>M::m(*foo)</code> requires taking <code>A</code> by value and hence moving out of <code>foo</code>, hence the error.</li>\n<li><code>&amp;&amp;A</code>, 1. doesn't match, but autorefing gives <code>&amp;&amp;&amp;A</code>, which does match, so the call is <code>M::m(&amp;foo)</code> with <code>Self = &amp;&amp;&amp;A</code>.</li>\n</ul>\n<p>(This answer is based on <a href=\"https://github.com/rust-lang/rust/blob/b6d91a2bdac45cd919497a24207fab843124d4ba/src/librustc_typeck/check/method/probe.rs\" rel=\"noreferrer\">the code</a>, and <a href=\"https://github.com/rust-lang/rust/tree/b6d91a2bdac45cd919497a24207fab843124d4ba/src/librustc_typeck/check/method#method-lookup\" rel=\"noreferrer\">is reasonably close to the (slightly outdated) README</a>. Niko Matsakis, the main author of this part of the compiler/language, also glanced over this answer.)</p>\n"}, {"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 16, "last_activity_date": 1573868676, "creation_date": 1573868676, "answer_id": 58886793, "question_id": 28519997, "link": "https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/58886793#58886793", "title": "What are Rust&#39;s exact auto-dereferencing rules?", "body": "<p>The Rust reference has <a href=\"https://doc.rust-lang.org/reference/expressions/method-call-expr.html\" rel=\"noreferrer\">a chapter about the method call expression</a>. I copied the most important part below. Reminder: we are talking about an expression <code>recv.m()</code>, where <code>recv</code> is called \"receiver expression\" below.</p>\n\n<blockquote>\n  <p>The first step is to build a list of candidate receiver types. Obtain these by repeatedly dereferencing the receiver expression's type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, and adding the result type if that is successful. Then, for each candidate <code>T</code>, add <code>&amp;T</code> and <code>&amp;mut T</code> to the list immediately after <code>T</code>.</p>\n  \n  <p>For instance, if the receiver has type <code>Box&lt;[i32;2]&gt;</code>, then the candidate types will be <code>Box&lt;[i32;2]&gt;</code>, <code>&amp;Box&lt;[i32;2]&gt;</code>, <code>&amp;mut Box&lt;[i32;2]&gt;</code>, <code>[i32; 2]</code> (by dereferencing), <code>&amp;[i32; 2]</code>, <code>&amp;mut [i32; 2]</code>, <code>[i32]</code> (by unsized coercion), <code>&amp;[i32]</code>, and finally <code>&amp;mut [i32]</code>.</p>\n  \n  <p>Then, for each candidate type <code>T</code>, search for a visible method with a receiver of that type in the following places:</p>\n  \n  <ol>\n  <li><code>T</code>'s inherent methods (methods implemented directly on <code>T</code> [\u00b9]).</li>\n  <li>Any of the methods provided by a visible trait implemented by <code>T</code>. [...]</li>\n  </ol>\n</blockquote>\n\n<p>(<em>Note about [\u00b9]</em>: I actually think this phrasing is wrong. <a href=\"https://github.com/rust-lang/reference/issues/718\" rel=\"noreferrer\">I've opened an issue</a>. Let's just ignore that sentence in the parenthesis.)</p>\n\n<hr>\n\n<p>Let's go through a few examples from your code in detail! For your examples, we can ignore the part about \"unsized coercion\" and \"inherent methods\".</p>\n\n<p><strong><code>(*X{val:42}).m()</code></strong>: the receiver expression's type is <code>i32</code>. We perform these steps:</p>\n\n<ul>\n<li>Creating list of candidate receiver types:\n\n<ul>\n<li><code>i32</code> cannot be dereferenced, so we are already done with step 1. List: <strong><code>[i32]</code></strong></li>\n<li>Next, we add <code>&amp;i32</code> and <code>&amp;mut i32</code>. List: <strong><code>[i32, &amp;i32, &amp;mut i32]</code></strong></li>\n</ul></li>\n<li>Searching for methods for each candidate receiver type:\n\n<ul>\n<li>We find <code>&lt;i32 as M&gt;::m</code> which has the receiver type <code>i32</code>. So we are already done.</li>\n</ul></li>\n</ul>\n\n<p><br></p>\n\n<p>So far so easy. Now let's pick a more difficult example: <strong><code>(&amp;&amp;A).m()</code></strong>. The receiver expression's type is <code>&amp;&amp;A</code>. We perform these steps:</p>\n\n<ul>\n<li>Creating list of candidate receiver types:\n\n<ul>\n<li><code>&amp;&amp;A</code> can be dereferenced to <code>&amp;A</code>, so we add that to the list. <code>&amp;A</code> can be dereferenced again, so we also add <code>A</code> to the list. <code>A</code> cannot be dereferenced, so we stop. List: <strong><code>[&amp;&amp;A, &amp;A, A]</code></strong></li>\n<li>Next, for each type <code>T</code> in the list, we add <code>&amp;T</code> and <code>&amp;mut T</code> immediately after <code>T</code>. List: <strong><code>[&amp;&amp;A, &amp;&amp;&amp;A, &amp;mut &amp;&amp;A, &amp;A, &amp;&amp;A, &amp;mut &amp;A, A, &amp;A, &amp;mut A]</code></strong></li>\n</ul></li>\n<li>Searching for methods for each candidate receiver type:\n\n<ul>\n<li>There is no method with receiver type <code>&amp;&amp;A</code>, so we go to the next type in the list.</li>\n<li>We find the method <code>&lt;&amp;&amp;&amp;A as M&gt;::m</code> which indeed has the receiver type <code>&amp;&amp;&amp;A</code>. So we are done.</li>\n</ul></li>\n</ul>\n\n<hr>\n\n<p>Here are the candidate receiver lists for all of your examples. The type that is enclosed in <code>\u27eax\u27eb</code> is the one that \"won\", i.e. the first type for which a fitting method could be found. Also remember that the first type in the list is always the receiver expression's type. Lastly, I formatted the list in lines of three, but that's just formatting: this list is a flat list.</p>\n\n<ul>\n<li><strong><code>(*X{val:42}).m()</code></strong> \u2192 <code>&lt;i32 as M&gt;::m</code>\n\n<pre><code>[\u27eai32\u27eb, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>X{val:42}.m()</code></strong> \u2192 <code>&lt;X as M&gt;::m</code>\n\n<pre><code>[\u27eaX\u27eb, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;X{val:42}).m()</code></strong> \u2192 <code>&lt;&amp;X as M&gt;::m</code>\n\n<pre><code>[\u27ea&amp;X\u27eb, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;X{val:42}).m()</code></strong> \u2192 <code>&lt;&amp;&amp;X as M&gt;::m</code>\n\n<pre><code>[\u27ea&amp;&amp;X\u27eb, &amp;&amp;&amp;X, &amp;mut &amp;&amp;X, \n &amp;X, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;&amp;X{val:42}).m()</code></strong> \u2192 <code>&lt;&amp;&amp;&amp;X as M&gt;::m</code>\n\n<pre><code>[\u27ea&amp;&amp;&amp;X\u27eb, &amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;X, \n &amp;&amp;X, &amp;&amp;&amp;X, &amp;mut &amp;&amp;X, \n &amp;X, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;&amp;&amp;X{val:42}).m()</code></strong> \u2192 <code>&lt;&amp;&amp;&amp;X as M&gt;::m</code>\n\n<pre><code>[&amp;&amp;&amp;&amp;X, &amp;&amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;&amp;X, \n \u27ea&amp;&amp;&amp;X\u27eb, &amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;X, \n &amp;&amp;X, &amp;&amp;&amp;X, &amp;mut &amp;&amp;X, \n &amp;X, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;&amp;&amp;&amp;X{val:42}).m()</code></strong> \u2192 <code>&lt;&amp;&amp;&amp;X as M&gt;::m</code>\n\n<pre><code>[&amp;&amp;&amp;&amp;&amp;X, &amp;&amp;&amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;&amp;&amp;X, \n &amp;&amp;&amp;&amp;X, &amp;&amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;&amp;X, \n \u27ea&amp;&amp;&amp;X\u27eb, &amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;X, \n &amp;&amp;X, &amp;&amp;&amp;X, &amp;mut &amp;&amp;X, \n &amp;X, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n</ul>\n\n<h2><br></h2>\n\n<ul>\n<li><strong><code>(*X{val:42}).refm()</code></strong> \u2192 <code>&lt;i32 as RefM&gt;::refm</code>\n\n<pre><code>[i32, \u27ea&amp;i32\u27eb, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>X{val:42}.refm()</code></strong> \u2192 <code>&lt;X as RefM&gt;::refm</code>\n\n<pre><code>[X, \u27ea&amp;X\u27eb, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;X{val:42}).refm()</code></strong> \u2192 <code>&lt;X as RefM&gt;::refm</code>\n\n<pre><code>[\u27ea&amp;X\u27eb, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;X{val:42}).refm()</code></strong> \u2192 <code>&lt;&amp;X as RefM&gt;::refm</code>\n\n<pre><code>[\u27ea&amp;&amp;X\u27eb, &amp;&amp;&amp;X, &amp;mut &amp;&amp;X, \n &amp;X, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;&amp;X{val:42}).refm()</code></strong> \u2192 <code>&lt;&amp;&amp;X as RefM&gt;::refm</code>\n\n<pre><code>[\u27ea&amp;&amp;&amp;X\u27eb, &amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;X, \n &amp;&amp;X, &amp;&amp;&amp;X, &amp;mut &amp;&amp;X, \n &amp;X, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;&amp;&amp;X{val:42}).refm()</code></strong> \u2192 <code>&lt;&amp;&amp;&amp;X as RefM&gt;::refm</code>\n\n<pre><code>[\u27ea&amp;&amp;&amp;&amp;X\u27eb, &amp;&amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;&amp;X, \n &amp;&amp;&amp;X, &amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;X, \n &amp;&amp;X, &amp;&amp;&amp;X, &amp;mut &amp;&amp;X, \n &amp;X, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;&amp;&amp;&amp;X{val:42}).refm()</code></strong> \u2192 <code>&lt;&amp;&amp;&amp;X as RefM&gt;::refm</code>\n\n<pre><code>[&amp;&amp;&amp;&amp;&amp;X, &amp;&amp;&amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;&amp;&amp;X, \n \u27ea&amp;&amp;&amp;&amp;X\u27eb, &amp;&amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;&amp;X, \n &amp;&amp;&amp;X, &amp;&amp;&amp;&amp;X, &amp;mut &amp;&amp;&amp;X, \n &amp;&amp;X, &amp;&amp;&amp;X, &amp;mut &amp;&amp;X, \n &amp;X, &amp;&amp;X, &amp;mut &amp;X, \n X, &amp;X, &amp;mut X, \n i32, &amp;i32, &amp;mut i32]\n</code></pre></li>\n</ul>\n\n<h2><br></h2>\n\n<ul>\n<li><strong><code>Y{val:42}.refm()</code></strong> \u2192 <code>&lt;i32 as RefM&gt;::refm</code>\n\n<pre><code>[Y, &amp;Y, &amp;mut Y,\n i32, \u27ea&amp;i32\u27eb, &amp;mut i32]\n</code></pre></li>\n<li><strong><code>Z{val:Y{val:42}}.refm()</code></strong> \u2192 <code>&lt;i32 as RefM&gt;::refm</code>\n\n<pre><code>[Z, &amp;Z, &amp;mut Z,\n Y, &amp;Y, &amp;mut Y,\n i32, \u27ea&amp;i32\u27eb, &amp;mut i32]\n</code></pre></li>\n</ul>\n\n<h2><br></h2>\n\n<ul>\n<li><strong><code>A.m()</code></strong> \u2192 <code>&lt;A as M&gt;::m</code>\n\n<pre><code>[\u27eaA\u27eb, &amp;A, &amp;mut A]\n</code></pre></li>\n<li><strong><code>(&amp;A).m()</code></strong> \u2192 <code>&lt;A as M&gt;::m</code>\n\n<pre><code>[&amp;A, &amp;&amp;A, &amp;mut &amp;A,\n \u27eaA\u27eb, &amp;A, &amp;mut A]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;A).m()</code></strong> \u2192 <code>&lt;&amp;&amp;&amp;A as M&gt;::m</code>\n\n<pre><code>[&amp;&amp;A, \u27ea&amp;&amp;&amp;A\u27eb, &amp;mut &amp;&amp;A,\n &amp;A, &amp;&amp;A, &amp;mut &amp;A,\n A, &amp;A, &amp;mut A]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;&amp;A).m()</code></strong> \u2192 <code>&lt;&amp;&amp;&amp;A as M&gt;::m</code>\n\n<pre><code>[\u27ea&amp;&amp;&amp;A\u27eb, &amp;&amp;&amp;&amp;A, &amp;mut &amp;&amp;&amp;A,\n &amp;&amp;A, &amp;&amp;&amp;A, &amp;mut &amp;&amp;A,\n &amp;A, &amp;&amp;A, &amp;mut &amp;A,\n A, &amp;A, &amp;mut A]\n</code></pre></li>\n<li><strong><code>A.refm()</code></strong> \u2192 <code>&lt;A as RefM&gt;::refm</code>\n\n<pre><code>[A, \u27ea&amp;A\u27eb, &amp;mut A]\n</code></pre></li>\n<li><strong><code>(&amp;A).refm()</code></strong> \u2192 <code>&lt;A as RefM&gt;::refm</code>\n\n<pre><code>[\u27ea&amp;A\u27eb, &amp;&amp;A, &amp;mut &amp;A,\n A, &amp;A, &amp;mut A]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;A).refm()</code></strong> \u2192 <code>&lt;A as RefM&gt;::refm</code>\n\n<pre><code>[&amp;&amp;A, &amp;&amp;&amp;A, &amp;mut &amp;&amp;A,\n \u27ea&amp;A\u27eb, &amp;&amp;A, &amp;mut &amp;A,\n A, &amp;A, &amp;mut A]\n</code></pre></li>\n<li><strong><code>(&amp;&amp;&amp;A).refm()</code></strong> \u2192 <code>&lt;&amp;&amp;&amp;A as RefM&gt;::refm</code>\n\n<pre><code>[&amp;&amp;&amp;A, \u27ea&amp;&amp;&amp;&amp;A\u27eb, &amp;mut &amp;&amp;&amp;A,\n &amp;&amp;A, &amp;&amp;&amp;A, &amp;mut &amp;&amp;A,\n &amp;A, &amp;&amp;A, &amp;mut &amp;A,\n A, &amp;A, &amp;mut A]\n</code></pre></li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 13, "user_id": 9158028, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/4a2c49f0cf9d5c8315d19e68b26a3e47?s=128&d=identicon&r=PG&f=1", "display_name": "Jiang", "link": "https://stackoverflow.com/users/9158028/jiang"}, "is_accepted": false, "score": 0, "last_activity_date": 1618216971, "last_edit_date": 1618216971, "creation_date": 1618214254, "answer_id": 67054588, "question_id": 28519997, "link": "https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/67054588#67054588", "title": "What are Rust&#39;s exact auto-dereferencing rules?", "body": "<p>I was troubled by this problem for a long time, especially for this part:</p>\n<pre><code>    (*X{val:42}).refm();     // i32::refm() , Self == @\n    X{val:42}.refm();        // X::refm()   , Self == @\n    (&amp;X{val:42}).refm();     // X::refm()   , Self == *@\n    (&amp;&amp;X{val:42}).refm();    // &amp;X::refm()  , Self == *@\n    (&amp;&amp;&amp;X{val:42}).refm();   // &amp;&amp;X::refm() , Self == *@\n    (&amp;&amp;&amp;&amp;X{val:42}).refm();  // &amp;&amp;&amp;X::refm(), Self == *@\n    (&amp;&amp;&amp;&amp;&amp;X{val:42}).refm(); // &amp;&amp;&amp;X::refm(), Self == **@\n</code></pre>\n<p>until I found a way to remember these weird rules. I'm not sure if this is correct, but most of the time this method is effective.</p>\n<p>The key is, when looking for which function to use, do <strong>NOT</strong> use the type which calling the &quot;dot operator&quot; to determine which &quot;impl&quot; to use, but find the function according to the <em>function signature</em>, and then determine the type of &quot;self&quot; with the <em>function signature</em>.</p>\n<p>I converte the function defination code as follows:</p>\n<pre><code>trait RefM { fn refm(&amp;self); }\n\nimpl RefM for i32  { fn refm(&amp;self) { println!(&quot;i32::refm()&quot;);  } }\n// converted to:     fn refm(&amp;i32 ) { println!(&quot;i32::refm()&quot;);  }\n// =&gt; type of  'self'  : i32\n// =&gt; type of parameter: &amp;i32\n\nimpl RefM for X    { fn refm(&amp;self) { println!(&quot;X::refm()&quot;);    } }\n// converted to:     fn refm(&amp;X   ) { println!(&quot;X::refm()&quot;);    }\n// =&gt; type of  'self'  : X\n// =&gt; type of parameter: &amp;X\n\nimpl RefM for &amp;X   { fn refm(&amp;self) { println!(&quot;&amp;X::refm()&quot;);   } }\n// converted to:     fn refm(&amp;&amp;X  ) { println!(&quot;&amp;X::refm()&quot;);   }\n// =&gt; type of  'self'  : &amp;X\n// =&gt; type of parameter: &amp;&amp;X\n\nimpl RefM for &amp;&amp;X  { fn refm(&amp;self) { println!(&quot;&amp;&amp;X::refm()&quot;);  } }\n// converted to:     fn refm(&amp;&amp;&amp;X ) { println!(&quot;&amp;&amp;X::refm()&quot;);  }\n// =&gt; type of  'self'  : &amp;&amp;X\n// =&gt; type of parameter: &amp;&amp;&amp;X\n\nimpl RefM for &amp;&amp;&amp;X { fn refm(&amp;self) { println!(&quot;&amp;&amp;&amp;X::refm()&quot;); } }\n// converted to:     fn refm(&amp;&amp;&amp;&amp;X) { println!(&quot;&amp;&amp;&amp;X::refm()&quot;); }\n// =&gt; type of  'self'  : &amp;&amp;&amp;X\n// =&gt; type of parameter: &amp;&amp;&amp;&amp;X\n</code></pre>\n<p>Therefore, when you write the code:</p>\n<p><code>(&amp;X{val:42}).refm();</code></p>\n<p>the function</p>\n<p><code>fn refm(&amp;X   ) { println!(&quot;X::refm()&quot;);</code></p>\n<p>will be called, because the parameter type is <code>&amp;X</code>.</p>\n<p>And if no matching function signature is found, an auto-ref or some auto-deref performed.</p>\n"}], "owner": {"reputation": 3943, "user_id": 403742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a75da0019ec1c94350b0c334d2269823?s=128&d=identicon&r=PG", "display_name": "kFYatek", "link": "https://stackoverflow.com/users/403742/kfyatek"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 29329, "favorite_count": 108, "accepted_answer_id": 28552082, "answer_count": 3, "score": 226, "last_activity_date": 1618216971, "creation_date": 1423945915, "last_edit_date": 1614023458, "question_id": 28519997, "link": "https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules", "title": "What are Rust&#39;s exact auto-dereferencing rules?", "body": "<p>I'm learning/experimenting with Rust, and in all the elegance that I find in this language, there is one peculiarity that baffles me and seems totally out of place.</p>\n\n<p>Rust automatically dereferences pointers when making method calls. I made some tests to determine the exact behaviour:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct X { val: i32 }\nimpl std::ops::Deref for X {\n    type Target = i32;\n    fn deref(&amp;self) -&gt; &amp;i32 { &amp;self.val }\n}\n\ntrait M { fn m(self); }\nimpl M for i32   { fn m(self) { println!(\"i32::m()\");  } }\nimpl M for X     { fn m(self) { println!(\"X::m()\");    } }\nimpl M for &amp;X    { fn m(self) { println!(\"&amp;X::m()\");   } }\nimpl M for &amp;&amp;X   { fn m(self) { println!(\"&amp;&amp;X::m()\");  } }\nimpl M for &amp;&amp;&amp;X  { fn m(self) { println!(\"&amp;&amp;&amp;X::m()\"); } }\n\ntrait RefM { fn refm(&amp;self); }\nimpl RefM for i32  { fn refm(&amp;self) { println!(\"i32::refm()\");  } }\nimpl RefM for X    { fn refm(&amp;self) { println!(\"X::refm()\");    } }\nimpl RefM for &amp;X   { fn refm(&amp;self) { println!(\"&amp;X::refm()\");   } }\nimpl RefM for &amp;&amp;X  { fn refm(&amp;self) { println!(\"&amp;&amp;X::refm()\");  } }\nimpl RefM for &amp;&amp;&amp;X { fn refm(&amp;self) { println!(\"&amp;&amp;&amp;X::refm()\"); } }\n\n\nstruct Y { val: i32 }\nimpl std::ops::Deref for Y {\n    type Target = i32;\n    fn deref(&amp;self) -&gt; &amp;i32 { &amp;self.val }\n}\n\nstruct Z { val: Y }\nimpl std::ops::Deref for Z {\n    type Target = Y;\n    fn deref(&amp;self) -&gt; &amp;Y { &amp;self.val }\n}\n\n\n#[derive(Clone, Copy)]\nstruct A;\n\nimpl M for    A { fn m(self) { println!(\"A::m()\");    } }\nimpl M for &amp;&amp;&amp;A { fn m(self) { println!(\"&amp;&amp;&amp;A::m()\"); } }\n\nimpl RefM for    A { fn refm(&amp;self) { println!(\"A::refm()\");    } }\nimpl RefM for &amp;&amp;&amp;A { fn refm(&amp;self) { println!(\"&amp;&amp;&amp;A::refm()\"); } }\n\n\nfn main() {\n    // I'll use @ to denote left side of the dot operator\n    (*X{val:42}).m();        // i32::m()    , Self == @\n    X{val:42}.m();           // X::m()      , Self == @\n    (&amp;X{val:42}).m();        // &amp;X::m()     , Self == @\n    (&amp;&amp;X{val:42}).m();       // &amp;&amp;X::m()    , Self == @\n    (&amp;&amp;&amp;X{val:42}).m();      // &amp;&amp;&amp;X:m()    , Self == @\n    (&amp;&amp;&amp;&amp;X{val:42}).m();     // &amp;&amp;&amp;X::m()   , Self == *@\n    (&amp;&amp;&amp;&amp;&amp;X{val:42}).m();    // &amp;&amp;&amp;X::m()   , Self == **@\n    println!(\"-------------------------\");\n\n    (*X{val:42}).refm();     // i32::refm() , Self == @\n    X{val:42}.refm();        // X::refm()   , Self == @\n    (&amp;X{val:42}).refm();     // X::refm()   , Self == *@\n    (&amp;&amp;X{val:42}).refm();    // &amp;X::refm()  , Self == *@\n    (&amp;&amp;&amp;X{val:42}).refm();   // &amp;&amp;X::refm() , Self == *@\n    (&amp;&amp;&amp;&amp;X{val:42}).refm();  // &amp;&amp;&amp;X::refm(), Self == *@\n    (&amp;&amp;&amp;&amp;&amp;X{val:42}).refm(); // &amp;&amp;&amp;X::refm(), Self == **@\n    println!(\"-------------------------\");\n\n    Y{val:42}.refm();        // i32::refm() , Self == *@\n    Z{val:Y{val:42}}.refm(); // i32::refm() , Self == **@\n    println!(\"-------------------------\");\n\n    A.m();                   // A::m()      , Self == @\n    // without the Copy trait, (&amp;A).m() would be a compilation error:\n    // cannot move out of borrowed content\n    (&amp;A).m();                // A::m()      , Self == *@\n    (&amp;&amp;A).m();               // &amp;&amp;&amp;A::m()   , Self == &amp;@\n    (&amp;&amp;&amp;A).m();              // &amp;&amp;&amp;A::m()   , Self == @\n    A.refm();                // A::refm()   , Self == @\n    (&amp;A).refm();             // A::refm()   , Self == *@\n    (&amp;&amp;A).refm();            // A::refm()   , Self == **@\n    (&amp;&amp;&amp;A).refm();           // &amp;&amp;&amp;A::refm(), Self == @\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d7a379b91c949c676c399b22fd97ddad\" rel=\"noreferrer\">Playground</a>)</p>\n\n<p>So, it seems that, more or less:</p>\n\n<ul>\n<li>The compiler will insert as many dereference operators as necessary to invoke a method.</li>\n<li>The compiler, when resolving methods declared using <code>&amp;self</code> (call-by-reference):\n\n<ul>\n<li>First tries calling for a single dereference of <code>self</code></li>\n<li>Then tries calling for the exact type of <code>self</code></li>\n<li>Then, tries inserting as many dereference operators as necessary for a match</li>\n</ul></li>\n<li>Methods declared using <code>self</code> (call-by-value) for type <code>T</code> behave as if they were declared using <code>&amp;self</code> (call-by-reference) for type <code>&amp;T</code> and called on the reference to whatever is on the left side of the dot operator.</li>\n<li>The above rules are first tried with raw built-in dereferencing, and if there's no match, the overload with <code>Deref</code> trait is used.</li>\n</ul>\n\n<p>What are the exact auto-dereferencing rules? Can anyone give any formal rationale for such a design decision?</p>\n"}, {"tags": ["iterator", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423946125, "post_id": 28519745, "comment_id": 45356849, "body": "Does &quot;carry on iterating&quot; mean that you would reset your position <code>0, 1, (2, 3), 2, 3</code> or that you would only touch each thing once <code>0, 1, (2, 3), 4, 5</code>?"}, {"owner": {"reputation": 183, "user_id": 4119156, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-lBGugoWscQI/AAAAAAAAAAI/AAAAAAAAAFQ/XbODxH0Kzw0/photo.jpg?sz=128", "display_name": "George Roger", "link": "https://stackoverflow.com/users/4119156/george-roger"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423946532, "post_id": 28519745, "comment_id": 45356952, "body": "Only touch each element once."}], "answers": [{"comments": [{"owner": {"reputation": 1276, "user_id": 1846442, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/d5f46711431a276412c20f1ed2f7b4ed?s=128&d=identicon&r=PG&f=1", "display_name": "darque", "link": "https://stackoverflow.com/users/1846442/darque"}, "reply_to_user": {"reputation": 183, "user_id": 4119156, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-lBGugoWscQI/AAAAAAAAAAI/AAAAAAAAAFQ/XbODxH0Kzw0/photo.jpg?sz=128", "display_name": "George Roger", "link": "https://stackoverflow.com/users/4119156/george-roger"}, "edited": false, "score": 0, "creation_date": 1423951661, "post_id": 28519978, "comment_id": 45358393, "body": "@GeorgeRoger <a href=\"https://github.com/rust-lang/rfcs/pull/214\" rel=\"nofollow noreferrer\">Here</a> is the relevant RFC. It&#39;s based on the <a href=\"https://github.com/rust-lang/rfcs/pull/160\" rel=\"nofollow noreferrer\">if let</a> syntax."}], "tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": true, "score": 7, "last_activity_date": 1423945775, "creation_date": 1423945775, "answer_id": 28519978, "question_id": 28519745, "link": "https://stackoverflow.com/questions/28519745/how-do-i-pass-an-iterator-i-am-iterating-on-to-a-function/28519978#28519978", "title": "How do I pass an iterator I am iterating on to a function?", "body": "<p>The <code>for</code> construct consumes the iterator, and doing what you want using it will be quite tricky (if not impossible, I'm really not sure about that).</p>\n\n<p>However, you can have it working pretty easily by switching to a <code>while let</code> construct, like this:</p>\n\n<pre><code>fn parse_tokens (tokens: &amp;Vec&lt;char&gt;) {\n    let mut iter = tokens.iter();\n    let mut things: Vec&lt;Thing&gt; = vec![];\n    while let Some(token) = iter.next() {\n        match token {\n            &amp;'a' =&gt; things.push(take_three(&amp;mut iter)),\n            &amp;'b' =&gt; things.push(take_four(&amp;mut iter)),\n            _ =&gt; {},\n        }\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 183, "user_id": 4119156, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-lBGugoWscQI/AAAAAAAAAAI/AAAAAAAAAFQ/XbODxH0Kzw0/photo.jpg?sz=128", "display_name": "George Roger", "link": "https://stackoverflow.com/users/4119156/george-roger"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1393, "favorite_count": 0, "accepted_answer_id": 28519978, "answer_count": 1, "score": 4, "last_activity_date": 1423946493, "creation_date": 1423944289, "last_edit_date": 1423946493, "question_id": 28519745, "link": "https://stackoverflow.com/questions/28519745/how-do-i-pass-an-iterator-i-am-iterating-on-to-a-function", "title": "How do I pass an iterator I am iterating on to a function?", "body": "<p>I'm iterating through an array, and depending on the current value, I'd like to pass the iterator to a sub function and have it deal with a number of values, and upon exiting the sub function, carry on iterating through the array. Below is the closest I've managed to get so far, but I keep getting <code>error: use of moved value: 'iter'</code>.</p>\n\n<p>I've tried looking into lifetimes, but that hasn't worked for me either. I've spent most of a day on this now, and can't seem to get anywhere with it. Any help would be greatly appreciated. Thanks.</p>\n\n<pre><code>enum Thing {\n    Three(char, char, char),\n    Four(char, char, char, char),\n}\n\nfn take_three &lt;'a&gt;(iter: &amp;mut std::slice::Iter&lt;'a, char&gt;) -&gt; Thing {\n    let a = iter.next().unwrap();\n    let b = iter.next().unwrap();\n    let c = iter.next().unwrap();\n    Thing::Three(*a,*b,*c)\n}\n\nfn take_four &lt;'a&gt;(iter: &amp;mut std::slice::Iter&lt;'a, char&gt;) -&gt; Thing {\n    let a = iter.next().unwrap();\n    let b = iter.next().unwrap();\n    let c = iter.next().unwrap();\n    let d = iter.next().unwrap();\n    Thing::Four(*a,*b,*c,*d)\n}\n\nfn parse_tokens (tokens: &amp;Vec&lt;char&gt;) {\n    let mut iter = tokens.iter();\n    let mut things: Vec&lt;Thing&gt; = vec![];\n    for token in iter {\n        match token {\n            &amp;'a' =&gt; things.push(take_three(&amp;mut iter)),\n            &amp;'b' =&gt; things.push(take_four(&amp;mut iter)),\n            _ =&gt; {},\n        }\n    }\n}\n\nfn main() {\n    let tokens = vec!['a', '1', '2', '3', 'b', '1', '2', '3', '4', 'a', '4', '5', '6'];\n    parse_tokens(&amp;tokens);\n}\n</code></pre>\n"}, {"tags": ["rust", "mmap"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 3, "creation_date": 1423927602, "post_id": 28516996, "comment_id": 45351391, "body": "What do you mean by &quot;fails when calling...&quot;? Is there a compiler error, a run-time crash, what&#39;s the error message, etc.?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423929526, "post_id": 28516996, "comment_id": 45351885, "body": "Do you want the modifications to be saved back to the file?"}, {"owner": {"reputation": 451, "user_id": 430927, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/f385607b86235391929f18ca887fccb7?s=128&d=identicon&r=PG&f=1", "display_name": "mkhq", "link": "https://stackoverflow.com/users/430927/mkhq"}, "edited": false, "score": 0, "creation_date": 1423932135, "post_id": 28516996, "comment_id": 45352649, "body": "@delnan, updated the question with the error message"}, {"owner": {"reputation": 451, "user_id": 430927, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/f385607b86235391929f18ca887fccb7?s=128&d=identicon&r=PG&f=1", "display_name": "mkhq", "link": "https://stackoverflow.com/users/430927/mkhq"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423932214, "post_id": 28516996, "comment_id": 45352680, "body": "@Shepmaster, yes, that would be ideal and I saw that you included it in your answer, thanks a lot!"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 19, "last_activity_date": 1584971044, "last_edit_date": 1584971044, "creation_date": 1423929463, "answer_id": 28517368, "question_id": 28516996, "link": "https://stackoverflow.com/questions/28516996/how-to-create-and-write-to-memory-mapped-files/28517368#28517368", "title": "How to create and write to memory mapped files?", "body": "<p>The real answer is to use a crate that provides this functionality, ideally in a cross-platform manner.</p>\n\n<pre><code>use memmap; // 0.7.0\nuse std::{\n    fs::OpenOptions,\n    io::{Seek, SeekFrom, Write},\n};\n\nconst SIZE: u64 = 1024 * 1024;\n\nfn main() {\n    let src = \"Hello!\";\n\n    let mut f = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .create(true)\n        .open(\"test.mmap\")\n        .expect(\"Unable to open file\");\n\n    // Allocate space in the file first\n    f.seek(SeekFrom::Start(SIZE)).unwrap();\n    f.write_all(&amp;[0]).unwrap();\n    f.seek(SeekFrom::Start(0)).unwrap();\n\n    let mut data = unsafe {\n        memmap::MmapOptions::new()\n            .map_mut(&amp;f)\n            .expect(\"Could not access data from memory mapped file\")\n    };\n\n    data[..src.len()].copy_from_slice(src.as_bytes());\n}\n</code></pre>\n\n<p>Note that this is still possible for this code to lead to <em>undefined behavior</em>. Since the slice is backed by a file, the contents of the file (and thus the slice) may change from <em>outside of the Rust program</em>, breaking the invariants that the <code>unsafe</code> block is supposed to hold. The programmer needs to ensure that the file doesn't change during the lifetime of the map. Unfortunately, the crate itself does not provide much assistance to prevent this from happening or even any documentation warning the user.</p>\n\n<hr>\n\n<p>If you wish to use lower-level system calls, you are missing two main parts: </p>\n\n<ol>\n<li><p><code>mmap</code> <a href=\"https://stackoverflow.com/a/16255596/155423\">doesn't allocate any space on its own</a>, so you need to set some space in the file. Without this, I get <code>Illegal instruction: 4</code> when running on macOS.</p></li>\n<li><p><code>MemoryMap</code> (was) <a href=\"https://doc.rust-lang.org/0.12.0/std/os/enum.MapOption.html\" rel=\"nofollow noreferrer\">private by default</a> so you need to mark the mapping as <em>public</em> so that changes are written back to the file (I'm assuming you want the writes to be saved). Without this, the code runs, but the file is never changed.</p></li>\n</ol>\n\n<p>Here's a version that works for me:</p>\n\n<pre><code>use libc; // 0.2.67\nuse std::{\n    fs::OpenOptions,\n    io::{Seek, SeekFrom, Write},\n    os::unix::prelude::AsRawFd,\n    ptr,\n};\n\nfn main() {\n    let src = \"Hello!\";\n\n    let size = 1024 * 1024;\n\n    let mut f = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .create(true)\n        .open(\"test.mmap\")\n        .expect(\"Unable to open file\");\n\n    // Allocate space in the file first\n    f.seek(SeekFrom::Start(size as u64)).unwrap();\n    f.write_all(&amp;[0]).unwrap();\n    f.seek(SeekFrom::Start(0)).unwrap();\n\n    // This refers to the `File` but doesn't use lifetimes to indicate\n    // that. This is very dangerous, and you need to be careful.\n    unsafe {\n        let data = libc::mmap(\n            /* addr: */ ptr::null_mut(),\n            /* len: */ size,\n            /* prot: */ libc::PROT_READ | libc::PROT_WRITE,\n            // Then make the mapping *public* so it is written back to the file\n            /* flags: */ libc::MAP_SHARED,\n            /* fd: */ f.as_raw_fd(),\n            /* offset: */ 0,\n        );\n\n        if data == libc::MAP_FAILED {\n            panic!(\"Could not access data from memory mapped file\")\n        }\n\n        ptr::copy_nonoverlapping(src.as_ptr(), data as *mut u8, src.len());\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1985, "user_id": 1136400, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/x6MCZ.png?s=128&g=1", "display_name": "Doncho Gunchev", "link": "https://stackoverflow.com/users/1136400/doncho-gunchev"}, "edited": false, "score": 1, "creation_date": 1516961387, "post_id": 30163552, "comment_id": 83911280, "body": "I get error[E0433]: failed to resolve. Could not find &#39;consts&#39; in &#39;libc&#39; trying to compile.  Fixed changing <code>libc::consts::os::posix88::MAP_SHARED</code> to <code>libc::MAP_SHARED</code>."}], "tags": [], "owner": {"reputation": 101, "user_id": 4886606, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0ba8ea97f51f613e3acad463e4fc8e8a?s=128&d=identicon&r=PG&f=1", "display_name": "lgvz", "link": "https://stackoverflow.com/users/4886606/lgvz"}, "is_accepted": false, "score": 10, "last_activity_date": 1431335113, "creation_date": 1431335113, "answer_id": 30163552, "question_id": 28516996, "link": "https://stackoverflow.com/questions/28516996/how-to-create-and-write-to-memory-mapped-files/30163552#30163552", "title": "How to create and write to memory mapped files?", "body": "<p>Up to date version:</p>\n\n<pre><code>use std::ptr;\nuse std::fs;\nuse std::io::{Write, SeekFrom, Seek};\nuse std::os::unix::prelude::AsRawFd;\nuse mmap::{MemoryMap, MapOption};\n\n// from crates.io\nextern crate mmap;\nextern crate libc;\n\nfn main() {\n    let size: usize = 1024*1024;\n\n    let mut f = fs::OpenOptions::new().read(true)\n                                      .write(true)\n                                      .create(true)\n                                      .open(\"test.mmap\")\n                                      .unwrap();\n\n    // Allocate space in the file first\n    f.seek(SeekFrom::Start(size as u64)).unwrap();\n    f.write_all(&amp;[0]).unwrap();\n    f.seek(SeekFrom::Start(0)).unwrap();\n\n    let mmap_opts = &amp;[\n        // Then make the mapping *public* so it is written back to the file\n        MapOption::MapNonStandardFlags(libc::consts::os::posix88::MAP_SHARED),\n        MapOption::MapReadable,\n        MapOption::MapWritable,\n        MapOption::MapFd(f.as_raw_fd()),\n    ];\n\n    let mmap = MemoryMap::new(size, mmap_opts).unwrap();\n\n    let data = mmap.data();\n\n    if data.is_null() {\n        panic!(\"Could not access data from memory mapped file\")\n    }\n\n    let src = \"Hello!\";\n    let src_data = src.as_bytes();\n\n    unsafe {\n        ptr::copy(src_data.as_ptr(), data, src_data.len());\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 451, "user_id": 430927, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/f385607b86235391929f18ca887fccb7?s=128&d=identicon&r=PG&f=1", "display_name": "mkhq", "link": "https://stackoverflow.com/users/430927/mkhq"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 8192, "favorite_count": 4, "accepted_answer_id": 28517368, "answer_count": 2, "score": 17, "last_activity_date": 1584971044, "creation_date": 1423926869, "last_edit_date": 1523659588, "question_id": 28516996, "link": "https://stackoverflow.com/questions/28516996/how-to-create-and-write-to-memory-mapped-files", "title": "How to create and write to memory mapped files?", "body": "<blockquote>\n  <p>Editor's note: This code example is from a version of Rust prior to 1.0 and the code it uses does not exist in Rust 1.0. Some answers have been updated to answer the core question for newer versions of Rust.</p>\n</blockquote>\n\n<p>I'm trying to create a memory mapped file using <code>std::os::MemoryMap</code>. The current approach looks as follows:</p>\n\n<pre><code>use std::os;\nuse std::ptr;\nuse std::old_io as io;\nuse std::os::unix::prelude::AsRawFd;\nuse std::os::MapOption;\n\nlet path = Path::new(\"test.mmap\");\n\nlet f = match io::File::open_mode(&amp;path, io::Open, io::ReadWrite) {\n    Ok(f) =&gt; f,\n    Err(err) =&gt; panic!(\"Could not open file: {}\", err),\n};\n\nlet mmap_opts = &amp;[\n    MapOption::MapReadable,\n    MapOption::MapWritable,\n    MapOption::MapFd(f.as_raw_fd())\n];\n\nlet mmap = match os::MemoryMap::new(1024*1024, mmap_opts) {\n    Ok(mmap) =&gt; {\n        println!(\"Successfully created the mmap: {}\", mmap.len());\n        mmap\n    }\n    Err(err) =&gt; panic!(\"Could not read the mmap: {}\", err),\n};\n\nunsafe {\n   let data = mmap.data();\n\n    if data.is_null() {\n        panic!(\"Could not access data from memory mapped file\")\n    }\n\n    let src = \"Hello!\";\n    ptr::copy_memory(data, src.as_ptr(), src.as_bytes().len());\n}\n</code></pre>\n\n<p>This program fails with</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Process didn't exit successfully: `target/mmap` (status=4)\n</code></pre>\n\n<p>when calling <code>ptr::copy_memory</code> or any other operations on data.</p>\n\n<ul>\n<li>What is the reason I cannot write (or read) the data from the <code>MemoryMap</code>?</li>\n<li>What is the correct way to use <code>MemoryMap</code> in Rust?</li>\n</ul>\n"}, {"tags": ["rust", "ffi"], "answers": [{"comments": [{"owner": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "edited": false, "score": 0, "creation_date": 1434410474, "post_id": 28516599, "comment_id": 49756295, "body": "Is that still true for 1.0? <code>&lt;OsStr as std::os::unix::ffi::OsStrExt&gt;::from_bytes(CStr::from_ptr(c_p&zwnj;&#8203;ath).to_bytes())</code> compiles, but it&#39;s uuugly."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "edited": false, "score": 1, "creation_date": 1434410784, "post_id": 28516599, "comment_id": 49756382, "body": "@porneL I&#39;ve updated the example for 1.0, but it seems like your case will still have some sharp edges :-)"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1434410714, "last_edit_date": 1434410714, "creation_date": 1423924190, "answer_id": 28516599, "question_id": 28515784, "link": "https://stackoverflow.com/questions/28515784/whats-the-right-way-to-create-osstring-from-a-ffi-returned-slice/28516599#28516599", "title": "What&#39;s the right way to create OsStr(ing) from a FFI-returned slice?", "body": "<p>You can use <a href=\"http://doc.rust-lang.org/std/slice/fn.from_raw_parts.html\" rel=\"nofollow\"><code>from_raw_parts</code></a> to go from the raw pointer to a slice, then <a href=\"http://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html\" rel=\"nofollow\"><code>OsStrExt::from_bytes</code></a>:</p>\n\n<pre><code>use std::slice;\nuse std::ffi::OsStr;\nuse std::os::unix::ffi::OsStrExt; // NOTE PLATFORM-SPECIFIC\n\nfn foo(data: *const u8, length: usize) {\n    let slice = unsafe { slice::from_raw_parts(data, length) };\n    let os_str = OsStr::from_bytes(slice);\n}\n\nfn main() {\n}\n</code></pre>\n\n<p>Note that <strong>this is *nix-specific</strong> - Windows and *nix do not represent paths is the same way (turns out this stuff is reasonably complicated!). If your API actually is returning a UTF-8 string, then you could use the normal string methods to convert the raw components to a <code>&amp;str</code> and then to an <code>OsStr(ring)</code>.</p>\n\n<p>For further information about <a href=\"https://simonsapin.github.io/wtf-8/\" rel=\"nofollow\"><code>WTF-8</code></a>, I highly recommend the excellent docs.</p>\n"}], "owner": {"reputation": 429, "user_id": 2267702, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/864df5197b734693575274c0205cd696?s=128&d=identicon&r=PG", "display_name": "Anonymous", "link": "https://stackoverflow.com/users/2267702/anonymous"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1393, "favorite_count": 0, "accepted_answer_id": 28516599, "answer_count": 1, "score": 4, "last_activity_date": 1434410714, "creation_date": 1423918050, "last_edit_date": 1423923197, "question_id": 28515784, "link": "https://stackoverflow.com/questions/28515784/whats-the-right-way-to-create-osstring-from-a-ffi-returned-slice", "title": "What&#39;s the right way to create OsStr(ing) from a FFI-returned slice?", "body": "<p>I have a function that accepts a callback with args <code>data: *const u8, length: usize</code>, that represents some path. What is the right way to create an OsStr(ing) from this?</p>\n\n<p>There's <code>from_byte_slice</code> in <code>OsStrExt</code>, but seems like it doesn't check if the data is correct WTF-8 or whatever, and it's not clear how to use it.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": true, "score": 9, "last_activity_date": 1423903266, "creation_date": 1423903266, "answer_id": 28513916, "question_id": 28513851, "link": "https://stackoverflow.com/questions/28513851/moving-to-and-from-a-mutably-borrowed-structure/28513916#28513916", "title": "Moving to and from a mutably borrowed structure", "body": "<p>The main difference is that when you move a value from a borrowed struct, you leave it into a \"partially moved state\", which forbids it to be used as a whole struct afterwards.</p>\n\n<p>And this state is forbidden for borrowed values, as they need to be still valid at the end of the function and the compiler doesn't (yet ?) understand that you are setting the value properly afterwards.</p>\n\n<p>However, if what you want to do is extract the old Vec and replace it by a new one, the standard library contains exactly the function you need: <a href=\"http://doc.rust-lang.org/std/mem/fn.replace.html\"><code>std::mem::replace</code></a></p>\n\n<pre><code>fn move_v_out(s: &amp;mut S) {\n    let old_vector = std::mem::replace(&amp;mut s.v, vec![]);\n    // do something with old_vector\n}\n</code></pre>\n"}], "owner": {"reputation": 647, "user_id": 4523058, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/a975dc9f5de333ddaf78b50c048548ec?s=128&d=identicon&r=PG", "display_name": "urubi", "link": "https://stackoverflow.com/users/4523058/urubi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 302, "favorite_count": 0, "accepted_answer_id": 28513916, "answer_count": 1, "score": 6, "last_activity_date": 1423903266, "creation_date": 1423902616, "question_id": 28513851, "link": "https://stackoverflow.com/questions/28513851/moving-to-and-from-a-mutably-borrowed-structure", "title": "Moving to and from a mutably borrowed structure", "body": "<p>Can someone explain why moving values into borrowed structs is valid while moving them out is not? For example:</p>\n\n<pre><code>struct S {\n    v: Vec&lt;u8&gt;\n}\n\nfn move_v_out(s: &amp;mut S) {\n    let old_vecotr = s.v; // If removed, program compiles fine\n    s.v = vec![];\n}\n\nfn main() {\n    let mut v = S {\n        v: vec![]\n    };\n    move_v_out(&amp;mut v);\n}\n</code></pre>\n\n<p>In either case, a member of a mutably-borrowed structure is modified. However one causes a compilation error.</p>\n"}, {"tags": ["hashmap", "rust", "lookup"], "answers": [{"comments": [{"owner": {"reputation": 1213, "user_id": 4416558, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9c9d0e7bc4fd06d5be32acbfaac3a334?s=128&d=identicon&r=PG&f=1", "display_name": "Yusuke Shinyama", "link": "https://stackoverflow.com/users/4416558/yusuke-shinyama"}, "edited": false, "score": 0, "creation_date": 1423891824, "post_id": 28512504, "comment_id": 45343858, "body": "Thanks for a swift anser! Now I&#39;ve learned I should look into a little deep down to the documents."}, {"owner": {"reputation": 10797, "user_id": 505248, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/a4c11bcd46268e709dd8638de9c4a2af?s=128&d=identicon&r=PG&f=1", "display_name": "Pascalius", "link": "https://stackoverflow.com/users/505248/pascalius"}, "edited": false, "score": 29, "creation_date": 1513454647, "post_id": 28512504, "comment_id": 82663390, "body": "the issue with entry() is, that you always have to clone the key, is there a way to avoid this?"}, {"owner": {"reputation": 1027, "user_id": 814422, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad082805d1ce2e3766886195c720fca6?s=128&d=identicon&r=PG", "display_name": "kbolino", "link": "https://stackoverflow.com/users/814422/kbolino"}, "reply_to_user": {"reputation": 10797, "user_id": 505248, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/a4c11bcd46268e709dd8638de9c4a2af?s=128&d=identicon&r=PG&f=1", "display_name": "Pascalius", "link": "https://stackoverflow.com/users/505248/pascalius"}, "edited": false, "score": 0, "creation_date": 1530646951, "post_id": 28512504, "comment_id": 89307054, "body": "@Pascalius you could make your key type <code>&amp;T</code> (if the keys outlive the map, e.g. static strings) or <code>Rc&lt;T&gt;</code> instead of <code>T</code> -- but it&#39;s not pretty in either case"}, {"owner": {"reputation": 13936, "user_id": 3598119, "user_type": "registered", "accept_rate": 66, "profile_image": "https://www.gravatar.com/avatar/6c9c7dfa28a57e8011d12208a7c86d20?s=128&d=identicon&r=PG", "display_name": "Chris Beck", "link": "https://stackoverflow.com/users/3598119/chris-beck"}, "reply_to_user": {"reputation": 10797, "user_id": 505248, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/a4c11bcd46268e709dd8638de9c4a2af?s=128&d=identicon&r=PG&f=1", "display_name": "Pascalius", "link": "https://stackoverflow.com/users/505248/pascalius"}, "edited": false, "score": 1, "creation_date": 1549582114, "post_id": 28512504, "comment_id": 95964779, "body": "@Pascalius: you can use <code>v.key()</code> in the expression for <code>default</code>, and then it will get a reference to the key as it exists in the hashmap, so you may avoid a clone this way"}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 147, "last_activity_date": 1495991086, "last_edit_date": 1495991086, "creation_date": 1423888881, "answer_id": 28512504, "question_id": 28512394, "link": "https://stackoverflow.com/questions/28512394/how-to-lookup-from-and-insert-into-a-hashmap-efficiently/28512504#28512504", "title": "How to lookup from and insert into a HashMap efficiently?", "body": "<p>The <a href=\"http://doc.rust-lang.org/nightly/std/collections/struct.HashMap.html#method.entry\" rel=\"noreferrer\"><code>entry</code> API</a> is designed for this. In manual form, it might look like</p>\n\n<pre><code>use std::collections::hash_map::Entry;\n\nlet values: &amp;Vec&lt;isize&gt; = match map.entry(key) {\n    Entry::Occupied(o) =&gt; o.into_mut(),\n    Entry::Vacant(v) =&gt; v.insert(default)\n};\n</code></pre>\n\n<p>Or one can use the briefer form:</p>\n\n<pre><code>map.entry(key).or_insert_with(|| default)\n</code></pre>\n\n<p>If <code>default</code> is OK/cheap to compute even when it isn't inserted, it can also just be:</p>\n\n<pre><code>map.entry(key).or_insert(default)\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 519, "user_id": 2434460, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/24e772445b4dbcac5e0875b092320b3e?s=128&d=identicon&r=PG", "display_name": "Daniel", "link": "https://stackoverflow.com/users/2434460/daniel"}, "is_accepted": false, "score": 0, "last_activity_date": 1614420863, "creation_date": 1614420863, "answer_id": 66397673, "question_id": 28512394, "link": "https://stackoverflow.com/questions/28512394/how-to-lookup-from-and-insert-into-a-hashmap-efficiently/66397673#66397673", "title": "How to lookup from and insert into a HashMap efficiently?", "body": "<p>I've used @huon and @Shepmaster's answer and just implemented it as a trait:</p>\n<pre><code>use std::collections::HashMap;\nuse std::hash::Hash;\n\npub trait InsertOrGet&lt;K: Eq + Hash, V: Default&gt; {\n    fn insert_or_get(&amp;mut self, item: K) -&gt; &amp;mut V;\n}\n\nimpl&lt;K: Eq + Hash, V: Default&gt; InsertOrGet&lt;K, V&gt; for HashMap&lt;K, V&gt; {\n    fn insert_or_get(&amp;mut self, item: K) -&gt; &amp;mut V {\n        return match self.entry(item) {\n            std::collections::hash_map::Entry::Occupied(o) =&gt; o.into_mut(),\n            std::collections::hash_map::Entry::Vacant(v) =&gt; v.insert(V::default()),\n        };\n    }\n}\n</code></pre>\n<p>Then somewhere else I can just do:</p>\n<pre><code>use crate::utils::hashmap::InsertOrGet;\n\nlet new_or_existing_value: &amp;mut ValueType = my_map.insert_or_get(my_key.clone());\n</code></pre>\n"}], "owner": {"reputation": 1213, "user_id": 4416558, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9c9d0e7bc4fd06d5be32acbfaac3a334?s=128&d=identicon&r=PG&f=1", "display_name": "Yusuke Shinyama", "link": "https://stackoverflow.com/users/4416558/yusuke-shinyama"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 21029, "favorite_count": 18, "accepted_answer_id": 28512504, "answer_count": 2, "score": 121, "last_activity_date": 1614420863, "creation_date": 1423887810, "last_edit_date": 1511296136, "question_id": 28512394, "link": "https://stackoverflow.com/questions/28512394/how-to-lookup-from-and-insert-into-a-hashmap-efficiently", "title": "How to lookup from and insert into a HashMap efficiently?", "body": "<p>I'd like to do the following:</p>\n\n<ul>\n<li>Lookup a <code>Vec</code> for a certain key, and store it for later use.</li>\n<li>If it doesn't exist, create an empty <code>Vec</code> for the key, but still keep it in the variable.</li>\n</ul>\n\n<p>How to do this efficiently? Naturally I thought I could use <code>match</code>:</p>\n\n<pre><code>use std::collections::HashMap;\n\n// This code doesn't compile.\nlet mut map = HashMap::new();\nlet key = \"foo\";\nlet values: &amp;Vec&lt;isize&gt; = match map.get(key) {\n    Some(v) =&gt; v,\n    None =&gt; {\n        let default: Vec&lt;isize&gt; = Vec::new();\n        map.insert(key, default);\n        &amp;default\n    }\n};\n</code></pre>\n\n<p>When I tried it, it gave me errors like:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `map` as mutable because it is also borrowed as immutable\n  --&gt; src/main.rs:11:13\n   |\n7  |     let values: &amp;Vec&lt;isize&gt; = match map.get(key) {\n   |                                     --- immutable borrow occurs here\n...\n11 |             map.insert(key, default);\n   |             ^^^ mutable borrow occurs here\n...\n15 | }\n   | - immutable borrow ends here\n</code></pre>\n\n<p>I ended up with doing something like this, but I don't like the fact that it performs the lookup twice (<code>map.contains_key</code> and <code>map.get</code>):</p>\n\n<pre><code>// This code does compile.\nlet mut map = HashMap::new();\nlet key = \"foo\";\nif !map.contains_key(key) {\n    let default: Vec&lt;isize&gt; = Vec::new();\n    map.insert(key, default);\n}\nlet values: &amp;Vec&lt;isize&gt; = match map.get(key) {\n    Some(v) =&gt; v,\n    None =&gt; {\n        panic!(\"impossiburu!\");\n    }\n};\n</code></pre>\n\n<p>Is there a safe way to do this with just one <code>match</code>?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "edited": false, "score": 1, "creation_date": 1423892750, "post_id": 28512314, "comment_id": 45344044, "body": "I think you&#39;ve run into a compiler bug. I wrote a simpler example with <code>HashMap</code>, and was able to make it compile by removing the <code>: &amp;String</code> annotation from the closure, which really shouldn&#39;t have made any difference."}, {"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "reply_to_user": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "edited": false, "score": 0, "creation_date": 1423908006, "post_id": 28512314, "comment_id": 45346560, "body": "I agree with @wingedsubmariner. This is probably worthy of an issue. I just tried it in playlen and removing the <code>: &amp;String</code> in the closure works."}, {"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 2, "creation_date": 1423908176, "post_id": 28512314, "comment_id": 45346588, "body": "I also would like to mention that you don&#39;t need to construct a String from a literal for lookup. Just write <code>.get(&quot;x&quot;)</code>. <code>get</code> takes a <code>&amp;Q</code> where <code>Q: BorrorFrom&lt;K&gt;</code>. And since <code>str: BorrowFrom&lt;String&gt;</code>, you can use a <code>&amp;str</code> for lookup as well."}, {"owner": {"reputation": 15886, "user_id": 471341, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/166bdbf4351669bc37a0407d38b8cb88?s=128&d=identicon&r=PG", "display_name": "yonran", "link": "https://stackoverflow.com/users/471341/yonran"}, "edited": false, "score": 0, "creation_date": 1423949595, "post_id": 28512314, "comment_id": 45357862, "body": "Thanks. I have filed bug <a href=\"https://github.com/rust-lang/rust/issues/22340\" rel=\"nofollow noreferrer\">Can\u2019t declare lifetime of closure that returns a reference #22340</a> in response."}], "answers": [{"tags": [], "owner": {"reputation": 129, "user_id": 1576468, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/822d1e5acfa208bfebe3078d6e8c292c?s=128&d=identicon&r=PG", "display_name": "user18700", "link": "https://stackoverflow.com/users/1576468/user18700"}, "is_accepted": false, "score": 1, "last_activity_date": 1423907279, "creation_date": 1423907279, "answer_id": 28514338, "question_id": 28512314, "link": "https://stackoverflow.com/questions/28512314/how-do-i-get-lifetime-of-reference-to-owned-object-cannot-infer-an-appropriate/28514338#28514338", "title": "How do I get lifetime of reference to owned object? (cannot infer an appropriate lifetime for lifetime parameter)", "body": "<p>I managed to get it working by avoiding using closures and using match instead. I think this works because in <code>.map(|s| &amp;s[])</code> the compiler gets confused and thinks the reference should live shorter than how long it actually lives for.</p>\n\n<pre><code>fn print_x_from_table(table: collections::BTreeMap&lt;String, String&gt;) {\n    let x = match table.get(\"x\") {\n        Some(v) =&gt; &amp;v[],\n        None =&gt; \"\"\n    };\n    println!(\"table contains x={}\", x);\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 0, "last_activity_date": 1423926657, "creation_date": 1423926657, "answer_id": 28516969, "question_id": 28512314, "link": "https://stackoverflow.com/questions/28512314/how-do-i-get-lifetime-of-reference-to-owned-object-cannot-infer-an-appropriate/28516969#28516969", "title": "How do I get lifetime of reference to owned object? (cannot infer an appropriate lifetime for lifetime parameter)", "body": "<p>I think this is a limitation of the closure syntax. Check out these alternatives:</p>\n\n<pre><code>use std::ops::Deref;\nuse std::collections::HashMap;\n\nfn inner&lt;'a&gt;(s: &amp;'a String) -&gt; &amp;'a str { //'\n    &amp;s[]\n}\n\nfn inner2(s: &amp;String) -&gt; &amp;str {\n    &amp;s[]\n}\n\nfn print_x_from_table(table: HashMap&lt;String, String&gt;) {\n    let x = table\n        .get(\"x\")\n        // .map(|s: &amp;String| &amp;s[])  // ERROR!\n        // .map(inner) // OK\n        // .map(inner2) // OK\n        // .map(Deref::deref)  // OK\n        .map(|s| &amp;s[])  // OK\n        .unwrap_or(\"\");\n    println!(\"table contains x={}\", x);\n}\n\nfn main() {\n}\n</code></pre>\n\n<p>In the second example, we use a function <code>inner</code> that has explicit named lifetimes that tie the input and the output together, letting the reference live beyond the closure. However, this is the exact case for lifetime elision, so <code>inner2</code> is the same concept, but shorter. We could also cut out the middleman and just use the <code>Deref::deref</code> method directly. </p>\n\n<p>The last example doesn't specify any types, so the compiler automatically inserts them and ties the references together (this last part is a guess based on observation, not intrinsic knowledge). This is probably what you'd see most of the time; it's not super common to specify types when you don't need to.</p>\n\n<p>One potential \"solution\" would be if we could specify lifetimes ourselves on the closure definition. A hypothetical syntax like</p>\n\n<pre><code>&lt;'a&gt;|foo: &amp;'a String| -&gt; &amp;'a str { foo.bar() }\n</code></pre>\n\n<p>could do the trick, but I don't know of any way to make that work.</p>\n"}], "owner": {"reputation": 15886, "user_id": 471341, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/166bdbf4351669bc37a0407d38b8cb88?s=128&d=identicon&r=PG", "display_name": "yonran", "link": "https://stackoverflow.com/users/471341/yonran"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 402, "favorite_count": 0, "answer_count": 2, "score": 2, "last_activity_date": 1423926657, "creation_date": 1423886828, "last_edit_date": 1423889177, "question_id": 28512314, "link": "https://stackoverflow.com/questions/28512314/how-do-i-get-lifetime-of-reference-to-owned-object-cannot-infer-an-appropriate", "title": "How do I get lifetime of reference to owned object? (cannot infer an appropriate lifetime for lifetime parameter)", "body": "<p>How do I get this to compile?</p>\n\n<pre><code>extern crate collections;\nfn print_x_from_table(table: collections::BTreeMap&lt;String, String&gt;) {\n    let x: &amp;str = table\n        .get(&amp;String::from_str(\"x\"))\n        .map(|s: &amp;String| &amp;s[])  // ERROR!\n        .unwrap_or(\"\");\n    println!(\"table contains x={}\", x);\n}\n</code></pre>\n\n<p>It gives this error:</p>\n\n<pre><code>src/rusttest.rs:5:22: 5:25 error: cannot infer an appropriate lifetime for lifetime parameter 'a in function call due to conflicting requirements\nsrc/rusttest.rs:5       .map(|s: &amp;String| &amp;s[])\n                                           ^~~\nsrc/rusttest.rs:7:34: 7:35 note: first, the lifetime cannot outlive the expression at 7:33...\nsrc/rusttest.rs:7   println!(\"table contains x={}\", x);\n                                                    ^\nnote: in expansion of format_args!\n&lt;std macros&gt;:2:43: 2:76 note: expansion site\n&lt;std macros&gt;:1:1: 2:78 note: in expansion of println!\nsrc/rusttest.rs:7:2: 7:37 note: expansion site\nsrc/rusttest.rs:7:34: 7:35 note: ...so type `&amp;str` of expression is valid during the expression\nsrc/rusttest.rs:7   println!(\"table contains x={}\", x);\n</code></pre>\n\n<p>If <code>table</code> were a reference parameter, I know that I could add a type parameter <code>'a</code> to indicate how long <code>s</code> should live. But how do I do that when I own <code>table</code>?</p>\n\n<pre><code>extern crate collections;\nfn print_x_from_ref_table&lt;'a&gt;(table: &amp;'a collections::BTreeMap&lt;String, String&gt;) {\n    let x: &amp;'a str = table\n        .get(&amp;String::from_str(\"x\"))\n        .map(|s: &amp;'a String| &amp;s[])\n        .unwrap_or(\"\");\n    println!(\"table contains x={}\", x);\n}\n</code></pre>\n"}, {"tags": ["rust", "traits"], "comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 2, "creation_date": 1423879061, "post_id": 28509874, "comment_id": 45341916, "body": "There&#39;s a method like .top already, called <code>.last()</code>, that you can use."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1425345993, "post_id": 28509874, "comment_id": 45916587, "body": "Please make sure to upvote useful answers and mark an answer as accepted if it solved your problem! If no answer is acceptable, consider leaving comments explaining why, or edit your question to phrase the problem differently."}], "answers": [{"comments": [{"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 1, "creation_date": 1423909657, "post_id": 28510042, "comment_id": 45346918, "body": "Please remove <code>&lt;T&gt;</code> after <code>top</code>. Also, the first implementation you show should not work because it requires <code>T: Copy</code>."}, {"owner": {"reputation": 14069, "user_id": 1769720, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5815db653a13a7122066f811caa020a7?s=128&d=identicon&r=PG", "display_name": "didierc", "link": "https://stackoverflow.com/users/1769720/didierc"}, "reply_to_user": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 0, "creation_date": 1423926042, "post_id": 28510042, "comment_id": 45350951, "body": "@sellibitze ah yes, I did remove it in my tests, but it escaped me when I copied it back somehow, thanks! As for <code>Copy</code>, I was not sure of the reason why it did not work, but using references fixed it. I was a bit sceptical about this being optimal in the case of types like floats and ints."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1423955367, "post_id": 28510042, "comment_id": 45359267, "body": "&quot;the compiler couldn&#39;t know that values of type <code>T</code> are copiable \u2014 ie. that <code>T</code> supports the <code>Clone</code> trait&quot; - note that types that are <a href=\"http://doc.rust-lang.org/std/marker/trait.Copy.html\" rel=\"nofollow noreferrer\"><code>Copy</code></a>able are distinct from types that are <a href=\"http://doc.rust-lang.org/std/clone/trait.Clone.html\" rel=\"nofollow noreferrer\"><code>Clone</code></a>able."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423971984, "post_id": 28510042, "comment_id": 45362320, "body": "More correct, yes. I chimed in with an answer that shows usage of the <code>Copy</code> or <code>Clone</code> bounds, if that&#39;s what OP wanted."}], "tags": [], "owner": {"reputation": 14069, "user_id": 1769720, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5815db653a13a7122066f811caa020a7?s=128&d=identicon&r=PG", "display_name": "didierc", "link": "https://stackoverflow.com/users/1769720/didierc"}, "is_accepted": false, "score": 2, "last_activity_date": 1423971448, "last_edit_date": 1423971448, "creation_date": 1423867597, "answer_id": 28510042, "question_id": 28509874, "link": "https://stackoverflow.com/questions/28509874/use-of-undeclared-type-name-error-with-a-parameterized-trait/28510042#28510042", "title": "Use of undeclared type name error with a parameterized trait", "body": "<p>This should work:</p>\n\n<pre><code>impl&lt;T&gt; Stack&lt;T&gt; for Vec&lt;T&gt; {\n    fn top(&amp;self) -&gt; Option&lt;T&gt; {\n        match self.len() {\n            0 =&gt; None,\n            n =&gt; Some(self[n-1])\n        }\n    }\n}\n</code></pre>\n\n<p>You need to inform the compiler about the type parameters of <code>Stack</code> relevant in the implementation. </p>\n\n<p>But that's not enough: fixing this error brings up an issue with the <code>main</code> function, specifically the parameter to <code>println!</code> is of the wrong type:</p>\n\n<pre><code>fn main() {\n    let mut stack: Vec&lt;f64&gt; = Vec::new();\n    stack.push(42.0);\n    match stack.pop() {\n        None    =&gt; println!(\"empty stack\"),\n        Some(n) =&gt; println!(\"top: {}\", n)\n    };\n}\n</code></pre>\n\n<p>But this fix, in turn, shows that the <code>top</code> method isn't well typed for that code. One way to fix the error:</p>\n\n<pre><code>trait Stack&lt;T&gt; {\n    fn top(&amp;self) -&gt; Option&lt;&amp;T&gt;;\n}\n\nimpl&lt;T&gt; Stack&lt;T&gt; for Vec&lt;T&gt; {\n    fn top(&amp;self) -&gt; Option&lt;&amp;T&gt; {\n        match self.len() {\n            0 =&gt; None,\n            n =&gt; Some(&amp;self[n-1])\n        }\n    }\n}\n</code></pre>\n\n<p>Edit: </p>\n\n<ul>\n<li><p>as explained by @sellibitze in the comments, the reason it doesn't work is that from the original definition of <code>Stack</code>, the compiler couldn't know that values of type <code>T</code> are copyable or at least clonable \u2014 ie. that <code>T</code> supports the <a href=\"http://doc.rust-lang.org/std/marker/trait.Copy.html\" rel=\"nofollow\"><code>Copy</code></a> or the <a href=\"http://doc.rust-lang.org/std/clone/trait.Clone.html\" rel=\"nofollow\"><code>Clone</code></a> trait, and hence values could not be duplicated (a return by value in C++ parlance). Using a reference solves the problem as a reference to <code>T</code> is copyable </p></li>\n<li><p>rather than matching on the return value from <code>top</code>, I could have used the fact that <code>Option&lt;T&gt;</code> supports the <code>Show</code> trait when <code>T</code> implements it, which happens to be true for <code>f64</code>. This means that I could simply replace <code>{}</code> by the <code>{:?}</code> formatter in the call to the <code>println!</code> macro, and leave the rest of the original <code>main</code> function untouched.</p></li>\n</ul>\n\n<p>For example:</p>\n\n<pre><code>fn main(){\n    let mut stack: Vec&lt;f64&gt; = Vec::new();\n    stack.push(42.0);\n    println!(\"top: {:?}\", stack.top())\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 14069, "user_id": 1769720, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5815db653a13a7122066f811caa020a7?s=128&d=identicon&r=PG", "display_name": "didierc", "link": "https://stackoverflow.com/users/1769720/didierc"}, "edited": false, "score": 0, "creation_date": 1423973535, "post_id": 28522797, "comment_id": 45362513, "body": "Thanks, I&#39;m sure OP will appreciate your input, as I do."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1423971896, "creation_date": 1423971896, "answer_id": 28522797, "question_id": 28509874, "link": "https://stackoverflow.com/questions/28509874/use-of-undeclared-type-name-error-with-a-parameterized-trait/28522797#28522797", "title": "Use of undeclared type name error with a parameterized trait", "body": "<p>Here are two possible implementations if you want to support returning a value, instead of a reference. Note that you <strong>can't have both of them</strong>. In most cases, you'll see the one with the <code>Clone</code> bound, as any type that is <code>Copy</code> should also implement <code>Clone</code>:</p>\n\n<pre><code>trait Stack&lt;T&gt; {\n    fn top(&amp;self) -&gt; Option&lt;T&gt;;\n}\n\n// We have values where we duplicate by copying bits na\u00efvely\nimpl&lt;T&gt; Stack&lt;T&gt; for Vec&lt;T&gt;\n    where T: Copy\n{\n    fn top(&amp;self) -&gt; Option&lt;T&gt; {\n        self.last().map(|v| *v)\n    }\n}\n\n// We have values where we can duplicate them,\n// but it might take a function call to do so\nimpl&lt;T&gt; Stack&lt;T&gt; for Vec&lt;T&gt;\n    where T: Clone\n{\n    fn top(&amp;self) -&gt; Option&lt;T&gt; {\n        self.last().map(|v| v.clone())\n    }\n}\n\nfn main() {\n    let stack = vec![1324.4f64];\n    println!(\"{:?}\", stack.top());\n}\n</code></pre>\n"}], "owner": {"reputation": 14360, "user_id": 35189, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/6010464aba06865d7a982c3a1456d377?s=128&d=identicon&r=PG", "display_name": "Dave Vogt", "link": "https://stackoverflow.com/users/35189/dave-vogt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1417, "favorite_count": 0, "answer_count": 2, "score": 1, "last_activity_date": 1423971896, "creation_date": 1423866762, "last_edit_date": 1423881762, "question_id": 28509874, "link": "https://stackoverflow.com/questions/28509874/use-of-undeclared-type-name-error-with-a-parameterized-trait", "title": "Use of undeclared type name error with a parameterized trait", "body": "<p>I'm trying to implement a few operations on a parameterized type (specifically, some common \"stack\" operations on top of <code>Vec&lt;T&gt;</code>. However I'm not sure how that works (yet), so here's a stripped-down version of what I'm currently struggling with:</p>\n\n<pre><code>trait Stack&lt;T&gt; {\n    fn top(&amp;self) -&gt; Option&lt;T&gt;;\n}\n\nimpl Stack for Vec&lt;T&gt; {\n    fn top&lt;T&gt;(&amp;self) -&gt; Option&lt;T&gt; {\n        match self.len() {\n            0 =&gt; None,\n            n =&gt; Some(self[n-1])\n        }\n    }\n}\n\nfn main() {\n    let mut stack: Vec&lt;f64&gt; = Vec::new();\n    stack.push(1324.4);\n    println!(\"{}\", stack.top());\n}\n</code></pre>\n\n<p>The above fails to compile (on rust nightly) with the following error:</p>\n\n<pre><code>test.rs:6:20: 6:21 error: use of undeclared type name `T`\ntest.rs:6 impl Stack for Vec&lt;T&gt; {\n                             ^\nerror: aborting due to previous error\n</code></pre>\n"}, {"tags": ["sockets", "tcp", "rust"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1423844329, "post_id": 28503514, "comment_id": 45326941, "body": "why don&#39;t you start a thread per socket?"}, {"owner": {"reputation": 2628, "user_id": 1366913, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/bcd760432e7ba71d5f0c71350886456f?s=128&d=identicon&r=PG", "display_name": "nathansizemore", "link": "https://stackoverflow.com/users/1366913/nathansizemore"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1423844561, "post_id": 28503514, "comment_id": 45327085, "body": "@ker This implementation is for an estimated connection time of 5-30min and should be capable of handling around 200k concurrent connections.  I am going under the assumption that amount of threads is a bad thing, but am currently trying to figure out a way to calculate this, as this would be plan B"}, {"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 0, "creation_date": 1423849946, "post_id": 28503514, "comment_id": 45330482, "body": "You might want to have a look to AsyncIO libraries, such as <a href=\"https://github.com/carllerche/mio\" rel=\"nofollow noreferrer\">github.com/carllerche/mio</a>"}, {"owner": {"reputation": 2628, "user_id": 1366913, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/bcd760432e7ba71d5f0c71350886456f?s=128&d=identicon&r=PG", "display_name": "nathansizemore", "link": "https://stackoverflow.com/users/1366913/nathansizemore"}, "edited": false, "score": 0, "creation_date": 1423869415, "post_id": 28503514, "comment_id": 45339747, "body": "Looks like a solid library, but I don&#39;t need all of the io on the stream to be async.  I think I&#39;ll just implement a separate trait for this specific purpose on this project."}], "answers": [{"tags": [], "owner": {"reputation": 2628, "user_id": 1366913, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/bcd760432e7ba71d5f0c71350886456f?s=128&d=identicon&r=PG", "display_name": "nathansizemore", "link": "https://stackoverflow.com/users/1366913/nathansizemore"}, "is_accepted": true, "score": 9, "last_activity_date": 1484832862, "last_edit_date": 1484832862, "creation_date": 1424201613, "answer_id": 28569655, "question_id": 28503514, "link": "https://stackoverflow.com/questions/28503514/force-non-blocking-read-with-tcpstream/28569655#28569655", "title": "Force non blocking read with TcpStream", "body": "<p><strong>Updated Answer</strong></p>\n\n<p>It should be noted, that as of Rust 1.9.0, <code>std::net::TcpStream</code> has added functionality:</p>\n\n<p><a href=\"https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.set_nonblocking\" rel=\"nofollow noreferrer\"><code>fn set_nonblocking(&amp;self, nonblocking: bool) -&gt; Result&lt;()&gt;</code></a></p>\n\n<p><strong>Original Answer</strong></p>\n\n<p>Couldn't exactly get it with TcpStream, and didn't want to pull in a separate lib for IO operations, so I decided to set the file descriptor as Non-blocking before using it, and executing a system call to read/write.  Definitely not the safest solution, but less work than implementing a new IO lib, even though <a href=\"https://github.com/carllerche/mio\" rel=\"nofollow noreferrer\">MIO</a> looks great.</p>\n\n<pre><code>extern \"system\" {\n    fn read(fd: c_int, buffer: *mut c_void, count: size_t) -&gt; ssize_t;\n}\n\npub fn new(user: User, stream: TcpStream) -&gt; Socket {\n\n    // First we need to setup the socket as Non-blocking on POSIX\n    let fd = stream.as_raw_fd();\n    unsafe {\n        let ret_value = libc::fcntl(fd,\n            libc::consts::os::posix01::F_SETFL,\n            libc::consts::os::extra::O_NONBLOCK);\n\n        // Ensure we didnt get an error code\n        if ret_value &lt; 0 {\n            panic!(\"Unable to set fd as non-blocking\")\n        }\n    }\n\n    Socket {\n        user: user,\n        stream: stream\n    }\n}\n\npub fn read(&amp;mut self) {\n    let count = 512 as size_t;\n    let mut buffer = [0u8; 512];\n    let fd = self.stream.as_raw_fd();\n\n    let mut num_read = 0 as ssize_t;\n    unsafe {\n        let buf_ptr = buffer.as_mut_ptr();\n        let void_buf_ptr: *mut c_void = mem::transmute(buf_ptr);\n        num_read = read(fd, void_buf_ptr, count);\n        if num_read &gt; 0 {\n            println!(\"Read: {}\", num_read);\n        }\n\n        println!(\"test\");\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 2628, "user_id": 1366913, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/bcd760432e7ba71d5f0c71350886456f?s=128&d=identicon&r=PG", "display_name": "nathansizemore", "link": "https://stackoverflow.com/users/1366913/nathansizemore"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2605, "favorite_count": 3, "accepted_answer_id": 28569655, "answer_count": 1, "score": 12, "last_activity_date": 1484832862, "creation_date": 1423842877, "question_id": 28503514, "link": "https://stackoverflow.com/questions/28503514/force-non-blocking-read-with-tcpstream", "title": "Force non blocking read with TcpStream", "body": "<p>I've got a thread, that maintains a list of sockets, and I'd like to traverse the list, see if there is anything to read, if so - act upon it, if not - move onto the next.  The problem is, as soon as I come across the first node, all execution is halted until something comes through on the read.</p>\n\n<p>I'm using <code>std::io::Read::read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;</code></p>\n\n<p>From the <a href=\"http://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read\">doc</a></p>\n\n<blockquote>\n  <p>This function does not provide any guarantees about whether it blocks waiting for data, but if an object needs to block for a read but cannot it will typically signal this via an Err return value.</p>\n</blockquote>\n\n<p>Digging into the source, the TcpStream Read implementation is</p>\n\n<pre><code>impl Read for TcpStream {\n    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; { self.0.read(buf) }\n}\n</code></pre>\n\n<p>Which invokes</p>\n\n<pre><code>pub fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; IoResult&lt;uint&gt; {\n    let fd = self.fd();\n    let dolock = || self.lock_nonblocking();\n    let doread = |nb| unsafe {\n        let flags = if nb {c::MSG_DONTWAIT} else {0};\n        libc::recv(fd,\n                   buf.as_mut_ptr() as *mut libc::c_void,\n                   buf.len() as wrlen,\n                   flags) as libc::c_int\n    };\n    read(fd, self.read_deadline, dolock, doread)\n}\n</code></pre>\n\n<p>And finally, calls <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/sys/common/net.rs#L387\"><code>read&lt;T, L, R&gt;(fd: sock_t, deadline: u64, mut lock: L, mut read: R)</code></a></p>\n\n<p>Where I can see loops over non blocking reads until data has been retrieved or an error has occurred.</p>\n\n<p>Is there a way to force a non-blocking read with <code>TcpStream</code>?</p>\n"}, {"tags": ["error-handling", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1423833705, "post_id": 28491759, "comment_id": 45320370, "body": "possible duplicate of <a href=\"http://stackoverflow.com/questions/28068807/detect-endoffile-ioresult-when-reading-a-file\">Detect EndOfFile IoResult when reading a file</a>"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1423834717, "post_id": 28491759, "comment_id": 45320996, "body": "also possible duplicate of <a href=\"http://stackoverflow.com/questions/27475113/how-to-check-for-eof-with-read-line\" title=\"how to check for eof with read line\">stackoverflow.com/questions/27475113/&hellip;</a>"}], "answers": [{"comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1423834604, "post_id": 28491919, "comment_id": 45320941, "body": "This is not a very readable solution. Have a look at Chris&#39; Answer and at <a href=\"http://stackoverflow.com/questions/28068807/detect-endoffile-ioresult-when-reading-a-file\" title=\"detect endoffile ioresult when reading a file\">stackoverflow.com/questions/28068807/&hellip;</a>"}], "tags": [], "owner": {"reputation": 341, "user_id": 4561902, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/15c71478a8008d934d7bc2d3bd0256d8?s=128&d=identicon&r=PG", "display_name": "user145632", "link": "https://stackoverflow.com/users/4561902/user145632"}, "is_accepted": false, "score": 0, "last_activity_date": 1423799947, "last_edit_date": 1423799947, "creation_date": 1423797615, "answer_id": 28491919, "question_id": 28491759, "link": "https://stackoverflow.com/questions/28491759/how-can-i-match-on-a-specific-ioerror-type/28491919#28491919", "title": "How can I match on a specific io::Error type?", "body": "<p>I figured it out.  I changed this line to check the error type!  Hope this helps others.</p>\n\n<pre><code>Err(e) =&gt; if e.kind == IoErrorKind::EndOfFile { break } else { panic!(\"Can't read from file: {}, err {}\", filename, e) },\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 96616, "user_id": 377270, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ce60a64d7650842955b526c3c4e85d0d?s=128&d=identicon&r=PG", "display_name": "sarnold", "link": "https://stackoverflow.com/users/377270/sarnold"}, "edited": false, "score": 1, "creation_date": 1494394354, "post_id": 28492277, "comment_id": 74803004, "body": "Does this still work? <code>IoError</code> appears different these days, and the closest I came still resulted in <i>error[E0026]: struct <code>std::io::Error</code> does not have a field named <code>kind</code></i>"}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 96616, "user_id": 377270, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ce60a64d7650842955b526c3c4e85d0d?s=128&d=identicon&r=PG", "display_name": "sarnold", "link": "https://stackoverflow.com/users/377270/sarnold"}, "edited": false, "score": 10, "creation_date": 1494458074, "post_id": 28492277, "comment_id": 74842123, "body": "@sarnold: <code>std::io::Error</code> now conceals its fields so that you can\u2019t edit the kind of an <code>Error</code> object; it does, however, have a <i>method</i> <a href=\"http://doc.rust-lang.org/std/io/struct.Error.html#method.kind\" rel=\"nofollow noreferrer\"><code>kind()</code></a> which returns the kind. Now I\u2019d recommend something more like <code>Err(ref e) if e.kind() == io::ErrorKind::EndOfFile =&gt; break,</code>."}, {"owner": {"reputation": 96616, "user_id": 377270, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ce60a64d7650842955b526c3c4e85d0d?s=128&d=identicon&r=PG", "display_name": "sarnold", "link": "https://stackoverflow.com/users/377270/sarnold"}, "edited": false, "score": 0, "creation_date": 1494466101, "post_id": 28492277, "comment_id": 74843838, "body": "Thanks, nice to know that I didn&#39;t miss something obvious."}, {"owner": {"reputation": 25867, "user_id": 17027, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/fb75fbfd9dd8d93d49ff88c152d82c92?s=128&d=identicon&r=PG", "display_name": "Mahmoud Al-Qudsi", "link": "https://stackoverflow.com/users/17027/mahmoud-al-qudsi"}, "edited": false, "score": 0, "creation_date": 1536345831, "post_id": 28492277, "comment_id": 91405628, "body": "Side note: these days the rust documentation is explicit that &quot;no more bytes to read&quot; should always be <code>Ok(0)</code> and not <code>ErrorKind::EndOfFile</code>"}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": false, "score": 8, "last_activity_date": 1599677521, "last_edit_date": 1599677521, "creation_date": 1423800082, "answer_id": 28492277, "question_id": 28491759, "link": "https://stackoverflow.com/questions/28491759/how-can-i-match-on-a-specific-ioerror-type/28492277#28492277", "title": "How can I match on a specific io::Error type?", "body": "<blockquote>\n<p>Editor's note: This code example is from a version of Rust prior to 1.0 and does not apply to stable Rust 1.0 <code>io::Error</code>. The <em>concept</em> of nested pattern matching still applies in other contexts.</p>\n</blockquote>\n<p>You can match the kind as part of the pattern, using some more advanced features of pattern matching:</p>\n<pre><code>Err(IoError { kind: IoErrorKind::EndOfFile, .. }) =&gt; break,\nErr(e) =&gt; panic!(&quot;Can't read from file: {}, err {}&quot;, filename, e),\n</code></pre>\n<p>The first variant means \u201can <code>Err</code> containing an <code>IoError</code> where <code>kind</code> is <code>IoErrorKind::EndOfFile</code> and all the other fields are whatever you like\u201d. The second then means \u201cany other <code>Err</code>, binding the contained value to the variable name <code>e</code>\u201d.</p>\n"}, {"tags": [], "owner": {"reputation": 96616, "user_id": 377270, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ce60a64d7650842955b526c3c4e85d0d?s=128&d=identicon&r=PG", "display_name": "sarnold", "link": "https://stackoverflow.com/users/377270/sarnold"}, "is_accepted": false, "score": 22, "last_activity_date": 1599678206, "last_edit_date": 1599678206, "creation_date": 1494396012, "answer_id": 43884600, "question_id": 28491759, "link": "https://stackoverflow.com/questions/28491759/how-can-i-match-on-a-specific-ioerror-type/43884600#43884600", "title": "How can I match on a specific io::Error type?", "body": "<p>This works in Rust version 1.17.0 (and probably back to Rust 1.0):</p>\n<pre><code>let binary = match file.read_u16::&lt;BigEndian&gt;() {\n    Err(ref e) if e.kind() == std::io::ErrorKind::UnexpectedEof =&gt; break,\n    Err(e) =&gt; panic!(&quot;Can't read from file: {}, err {}&quot;, filename, e),\n    Ok(binary) =&gt; binary,\n};\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 791, "user_id": 4747937, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/d9d99088c98489a7e0f718631b9e82fc?s=128&d=identicon&r=PG&f=1", "display_name": "kevlarr", "link": "https://stackoverflow.com/users/4747937/kevlarr"}, "is_accepted": false, "score": 5, "last_activity_date": 1599677790, "last_edit_date": 1599677790, "creation_date": 1523477892, "answer_id": 49783839, "question_id": 28491759, "link": "https://stackoverflow.com/questions/28491759/how-can-i-match-on-a-specific-ioerror-type/49783839#49783839", "title": "How can I match on a specific io::Error type?", "body": "<p>I find...</p>\n<pre><code>Err(e) =&gt; match e.kind() {\n    EndOfFile =&gt; break,\n    SomeOtherError =&gt; do_something(),\n    _ =&gt; panic!(&quot;Can't read from file: {}, err {}&quot;, filename, e),\n},\n</code></pre>\n<p>};</p>\n<p>... to be more readable than...</p>\n<pre><code>Ok(binary) =&gt; binary,\nErr(ref e) if e.kind() == EndOfFile =&gt; break,\nErr(ref e) if e.kind() == SomeOtherError =&gt; do_something(),\nErr(e) =&gt; panic!(&quot;Can't read from file: {}, err {}&quot;, filename, e),\n</code></pre>\n<p>(I'm not sure what other errors we could expect to get...)</p>\n<p>In other situations where the match guards might not be the same - the way that we're repeating <code>e.kind()</code> - we couldn't use the nested <code>match</code>.</p>\n<p>This works as of Rust 1.25.</p>\n"}, {"tags": [], "owner": {"reputation": 20521, "user_id": 1135424, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/rvwBS.jpg?s=128&g=1", "display_name": "nbari", "link": "https://stackoverflow.com/users/1135424/nbari"}, "is_accepted": false, "score": 0, "last_activity_date": 1559218405, "last_edit_date": 1559218405, "creation_date": 1559218079, "answer_id": 56378039, "question_id": 28491759, "link": "https://stackoverflow.com/questions/28491759/how-can-i-match-on-a-specific-ioerror-type/56378039#56378039", "title": "How can I match on a specific io::Error type?", "body": "<p>Here is an example of matching a <a href=\"https://docs.rs/mysql/16.0.2/mysql/enum.Error.html#variant.IoError\" rel=\"nofollow noreferrer\">MySQL <code>IoError</code></a>:</p>\n\n<pre><code>match pool.prep_exec(\"SELECT SLEEP(10)\", ()) {\n    Ok(_) =&gt; (),\n    Err(mysql::Error::IoError(e)) =&gt; {\n        eprintln!(\"IoError: {}\", e);\n        do_something();\n    }\n    Err(e) =&gt; {\n        eprintln!(\"{}\", e);\n        return;\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 341, "user_id": 4561902, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/15c71478a8008d934d7bc2d3bd0256d8?s=128&d=identicon&r=PG", "display_name": "user145632", "link": "https://stackoverflow.com/users/4561902/user145632"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6840, "favorite_count": 1, "answer_count": 5, "score": 23, "last_activity_date": 1599678206, "creation_date": 1423796088, "last_edit_date": 1599677394, "question_id": 28491759, "link": "https://stackoverflow.com/questions/28491759/how-can-i-match-on-a-specific-ioerror-type", "title": "How can I match on a specific io::Error type?", "body": "<p>I am trying to read in a file until the end 2 bytes at a time and I want to catch the EOF error:</p>\n<pre><code>use byteorder::{BigEndian, ReadBytesExt}; // 1.3.4\nuse std::fs::File;\n\nfn main() {\n    let filename = &quot;/etc/hosts&quot;;\n    let mut file = File::open(filename).expect(&quot;Cannot open file&quot;);\n    loop {\n        let binary = match file.read_u16::&lt;BigEndian&gt;() {\n            Ok(binary) =&gt; binary,\n            Err(e) =&gt; panic!(&quot;Can't read from file: {}, err {}&quot;, filename, e),\n            // Can I catch the EOF error here?\n        };\n        println!(&quot;{:?}&quot;, binary);\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423790598, "post_id": 28490170, "comment_id": 45303099, "body": "I was able to compile and run this just fine using <code>rustc 1.0.0-nightly (3ef8ff1f8 2015-02-12 00:38:24 +0000)</code> on a 32-bit Windows 7 VM. You should reduce your program, creating a <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a>. Once you have reduced the size of code, you should also include your <code>Cargo.toml</code>, how you are building, and exactly how you are launching your program."}, {"owner": {"reputation": 3008, "user_id": 3204951, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/8aca84582c72a22e9cb5245571103d92?s=128&d=identicon&r=PG", "display_name": "Nate Mara", "link": "https://stackoverflow.com/users/3204951/nate-mara"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423803457, "post_id": 28490170, "comment_id": 45306054, "body": "@Shepmaster Just edited to show those details. I&#39;m trying to build on win8 x64, with 32-bit rustc and 32-bit gcc."}, {"owner": {"reputation": 3008, "user_id": 3204951, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/8aca84582c72a22e9cb5245571103d92?s=128&d=identicon&r=PG", "display_name": "Nate Mara", "link": "https://stackoverflow.com/users/3204951/nate-mara"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423840338, "post_id": 28490170, "comment_id": 45324372, "body": "That fixed it! Thank you. What is the purpose of that?"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1423840619, "creation_date": 1423840619, "answer_id": 28502723, "question_id": 28490170, "link": "https://stackoverflow.com/questions/28490170/entry-point-could-not-be-located-when-running-program-on-windows/28502723#28502723", "title": "&quot;entry point could not be located&quot; when running program on Windows", "body": "<p>Add <code>#[no_link]</code> to your code:</p>\n\n<pre><code>#![plugin(regex_macros)]\n#[no_link]\nextern crate regex_macros;\n</code></pre>\n\n<p>Right now, plugins are crates, which means they get linked in. The <a href=\"https://github.com/rust-lang/regex/issues/16\" rel=\"nofollow\">regex_macros crate</a> should tell you to add <code>no_link</code>, but this is a temporary workaround for a <a href=\"https://github.com/rust-lang/rust/issues/20769\" rel=\"nofollow\">Rust issue</a>. However, it looks like this is in the <a href=\"https://github.com/rust-lang/rust/issues/21043\" rel=\"nofollow\">process</a> of being <a href=\"https://github.com/rust-lang/rust/pull/22026\" rel=\"nofollow\">fixed</a>.</p>\n"}], "owner": {"reputation": 3008, "user_id": 3204951, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/8aca84582c72a22e9cb5245571103d92?s=128&d=identicon&r=PG", "display_name": "Nate Mara", "link": "https://stackoverflow.com/users/3204951/nate-mara"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 275, "favorite_count": 0, "accepted_answer_id": 28502723, "answer_count": 1, "score": 1, "last_activity_date": 1423840699, "creation_date": 1423785423, "last_edit_date": 1423840699, "question_id": 28490170, "link": "https://stackoverflow.com/questions/28490170/entry-point-could-not-be-located-when-running-program-on-windows", "title": "&quot;entry point could not be located&quot; when running program on Windows", "body": "<p>I wrote a program to parse some filenames in Rust using the standard <a href=\"http://doc.rust-lang.org/regex/regex/index.html\" rel=\"nofollow noreferrer\">Regex</a> crate. The program runs fine on Linux, but when I tried to compile and run it on Windows, I get some kind of DLL error. I don't really understand what is going on with this, but it's all I have to go on.</p>\n\n<p><img src=\"https://i.imgur.com/3kHfwFW.png\" alt=\"error message\"></p>\n\n<p>This is the compiler version that I'm using:</p>\n\n<pre><code>F:\\Coding\\rust-shutterstock-deduper\\target (master)\n\u03bb rustc --version\nrustc 1.0.0-nightly (3ef8ff1f8 2015-02-12 00:38:24 +0000)\n</code></pre>\n\n<p>This is the program that I'm trying to run:</p>\n\n<pre><code>#![feature(plugin)]\n\n#![plugin(regex_macros)]\nextern crate regex_macros;\nextern crate regex;\n\nfn main() {\n        let x = regex!(\".*\");\n}\n</code></pre>\n\n<p>And my <code>Cargo.toml</code> file:</p>\n\n<pre><code>[package]\n\nname = \"my_package\"\nversion = \"0.0.1\"\nauthors = [\"Nate Mara &lt;natemara@gmail.com&gt;\"]\n\n[dependencies]\nregex = \"0.1.14\"\nregex_macros = \"0.1.8\"\n</code></pre>\n\n<p>Are there compiler flags that I should be passing in, or do I need to run this in a special way, or... what am I doing wrong here? I'm just running with <code>cargo run</code></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423759750, "post_id": 28482876, "comment_id": 45288226, "body": "How much do you care about errors? I think a lot of this code is dealing with error handling, and I feel that people are going to be surprised with how many errors are possible with code when they start programming in Rust..."}, {"owner": {"reputation": 786, "user_id": 108611, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/eb2d8324a32de112e4714635dc2f6058?s=128&d=identicon&r=PG", "display_name": "buster", "link": "https://stackoverflow.com/users/108611/buster"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1423760297, "post_id": 28482876, "comment_id": 45288614, "body": "The previous version was much smaller... <a href=\"https://github.com/buster/rrun/commit/d65bdffadb8391ac3f9adb648e617e2f20aea809#diff-93d0fcbc95e775bf2e023879c10a69e1R7\" rel=\"nofollow noreferrer\">github.com/buster/rrun/commit/&hellip;</a> So most of this is due to OsString and what not.. So, apparently the old version is not working anymore and the new one is even uglier"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1513980593, "last_edit_date": 1513980593, "creation_date": 1423771158, "answer_id": 28486699, "question_id": 28482876, "link": "https://stackoverflow.com/questions/28482876/how-to-cleanly-get-the-path-to-the-bash-history/28486699#28486699", "title": "How to cleanly get the path to the bash history?", "body": "<p>I think you are suffering because of the transition between <code>std::old_path</code> and <code>std::path</code>, namely on the return value of <code>home_dir()</code>. Once it returns a <code>std::path::PathBuf</code>, it will look like:</p>\n\n<pre><code>#![feature(os,env,path)]\n\nuse std::env;\nuse std::ffi::OsString;\nuse std::path::PathBuf;\n\nfn future_home_dir() -&gt; Option&lt;PathBuf&gt; {\n    Some(PathBuf::new(\"/home/user\"))\n}\n\nfn main() {\n    let filename = env::var_os(\"HISTFILE\").unwrap_or(OsString::from_str(\".bash_history\"));\n    let home_dir = future_home_dir().expect(\"could not determine a home directory\");\n    let path = home_dir.join(&amp;filename);\n\n    println!(\"{:?}\", path);\n}\n</code></pre>\n\n<p>The stable version of this is:</p>\n\n<pre><code>use std::env;\nuse std::ffi::OsString;\n\nfn main() {\n    let filename = env::var_os(\"HISTFILE\").unwrap_or_else(|| OsString::from(\".bash_history\"));\n    let home_dir = env::home_dir().expect(\"could not determine a home directory\");\n    let path = home_dir.join(&amp;filename);\n\n    println!(\"{:?}\", path);\n}\n</code></pre>\n"}], "owner": {"reputation": 786, "user_id": 108611, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/eb2d8324a32de112e4714635dc2f6058?s=128&d=identicon&r=PG", "display_name": "buster", "link": "https://stackoverflow.com/users/108611/buster"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 158, "favorite_count": 0, "accepted_answer_id": 28486699, "answer_count": 1, "score": 0, "last_activity_date": 1513980593, "creation_date": 1423759099, "last_edit_date": 1423771974, "question_id": 28482876, "link": "https://stackoverflow.com/questions/28482876/how-to-cleanly-get-the-path-to-the-bash-history", "title": "How to cleanly get the path to the bash history?", "body": "<p>So, now and then i am looking into Rust, and this time i have the simple task to get the path to my bash history file.\nSo, you come up with env::var() and env::home_dir() and like to join them.\nNow, it's like 1 or 2 lines in python and probably in C, i came up with this hideous 3 liner:</p>\n\n<blockquote>\n<pre><code>let h_file = env::var(\"HISTFILE\").unwrap_or(OsString::from_string(\".bash_history\".to_string())).into_string().unwrap_or_else(|_| { panic!(\"the end is near!!!\")});\nlet h_dir = env::home_dir().unwrap_or_else(|| { panic!(\"unable to get homedir!\") } );\nlet h_file_p = h_dir.join(h_file);\n</code></pre>\n</blockquote>\n\n<p>What would be the better way? To be honest, i am concerned that, as a beginner, just using the docs, i came up with is this hideous thing.</p>\n\n<p>Edit: Of course the point is that the first line is that long, and i am aware that i could put all those commands in several lines following each other or use a gazillion match statements, all of which would not really make this a nice solution for a basic task..</p>\n"}, {"tags": ["rust", "builder", "lifetime", "borrow-checker"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1423717673, "post_id": 28469667, "comment_id": 45264360, "body": "This code cannot be compiled on <a href=\"https://play.rust-lang.org/\" rel=\"nofollow noreferrer\">the playpen</a>, specifically because you reference many structures that aren&#39;t defined. Please review how to create an <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a>, and pay attention to the <i>minimal</i> part."}], "answers": [{"comments": [{"owner": {"reputation": 1935, "user_id": 165186, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/14c799413ec2b9d79c335465d55d57cb?s=128&d=identicon&r=PG", "display_name": "Attila Kun", "link": "https://stackoverflow.com/users/165186/attila-kun"}, "edited": false, "score": 0, "creation_date": 1611978064, "post_id": 28469846, "comment_id": 116630114, "body": "What you write all makes sense, but why doesn&#39;t Rust hit me with an error at the time I&#39;m declaring the <code>canvas</code> variable? Why allow the declaration of something that later can&#39;t be used under any circumstances? If you remove <code>println!(&quot;{:?}&quot;, canvas);</code> the program compiles fine which is a bit misleading because it led me to believe that binding to the <code>canvas</code> variable is fine. But it isn&#39;t and it can never be."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 17, "last_activity_date": 1546821748, "last_edit_date": 1546821748, "creation_date": 1423718166, "answer_id": 28469846, "question_id": 28469667, "link": "https://stackoverflow.com/questions/28469667/borrowed-value-does-not-live-long-enough-when-using-the-builder-pattern/28469846#28469846", "title": "&quot;borrowed value does not live long enough&quot; when using the builder pattern", "body": "<p>Here's a minimal reproduction:</p>\n\n<pre><code>#[derive(Debug)]\npub struct Canvas;\n\nimpl Canvas {\n    fn new() -&gt; Self {\n        Canvas\n    }\n\n    fn color(&amp;self) -&gt; &amp;Canvas {\n        self\n    }\n}\n\nfn main() {\n    let mut canvas = Canvas::new().color();\n    //             1 ^~~~~~~~~~~~~\n    //                           2 ^~~~~\n    println!(\"{:?}\", canvas);\n}\n</code></pre>\n\n<p><strong>Rust 2015</strong></p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0597]: borrowed value does not live long enough\n  --&gt; src/main.rs:15:22\n   |\n15 |     let mut canvas = Canvas::new().color();\n   |                      ^^^^^^^^^^^^^        - temporary value dropped here while still borrowed\n   |                      |\n   |                      temporary value does not live long enough\n...\n19 | }\n   | - temporary value needs to live until here\n   |\n   = note: consider using a `let` binding to increase its lifetime\n</code></pre>\n\n<p><strong>Rust 2018</strong></p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0716]: temporary value dropped while borrowed\n  --&gt; src/main.rs:15:22\n   |\n15 |     let mut canvas = Canvas::new().color();\n   |                      ^^^^^^^^^^^^^        - temporary value is freed at the end of this statement\n   |                      |\n   |                      creates a temporary which is freed while still in use\n...\n18 |     println!(\"{:?}\", canvas);\n   |                      ------ borrow later used here\n   |\n   = note: consider using a `let` binding to create a longer lived value\n</code></pre>\n\n<hr>\n\n<p>The problem arises because you create a temporary variable (1), then pass the reference to that variable to the method (2), which returns the reference. At the end of the method chain, you are trying to return the reference and store it in the variable, but the reference points to a temporary item that has <em>nowhere to live</em>! Rust doesn't let you have a reference to something that's invalid.</p>\n\n<p>Part of the problem is that this <em>is not the Builder pattern</em>, this is just a struct that modifies itself using <em>chained method invocation</em>. Some solutions:</p>\n\n<ol>\n<li>Store the \"temporary\" variable, in which case all the methods are just normal mutation methods that happen afterward.</li>\n<li>Take in <code>self</code> instead of a reference to self (<code>&amp;self</code>, <code>&amp;mut self</code>) and then ultimately return the full struct.</li>\n<li>Have a <code>build</code> method at the end of the chain that returns another standalone struct, not a reference. </li>\n</ol>\n"}], "owner": {"reputation": 325, "user_id": 170993, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/5b9b07a1e96b1b5acee26709f699c0d1?s=128&d=identicon&r=PG", "display_name": "nqe", "link": "https://stackoverflow.com/users/170993/nqe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2886, "favorite_count": 0, "accepted_answer_id": 28469846, "answer_count": 1, "score": 9, "last_activity_date": 1552590243, "creation_date": 1423717330, "last_edit_date": 1552590243, "question_id": 28469667, "link": "https://stackoverflow.com/questions/28469667/borrowed-value-does-not-live-long-enough-when-using-the-builder-pattern", "title": "&quot;borrowed value does not live long enough&quot; when using the builder pattern", "body": "<p>I have the following code:</p>\n\n<pre><code>pub struct Canvas&lt;'a&gt; {\n    width: isize,\n    height: isize,\n    color: Color,\n    surface: Surface,\n    texture: Texture,\n    renderer: &amp;'a Renderer,\n}\n\nimpl&lt;'a&gt; Canvas&lt;'a&gt; {\n    pub fn new(width: isize, height: isize, renderer: &amp;'a Renderer) -&gt; Canvas&lt;'a&gt; {\n        let color = Color::RGB(0, 30, 0);\n        let mut surface = core::create_surface(width, height);\n        let texture = Canvas::gen_texture(&amp;mut surface, width, height, color, renderer);\n        Canvas {\n            width: width,\n            height: height,\n            color: color,\n            surface: surface,\n            texture: texture,\n            renderer: renderer,\n        }\n    }\n\n    pub fn color(&amp;mut self, color: Color) -&gt; &amp;mut Canvas&lt;'a&gt; {\n        self.color = color;\n        self.texture = Canvas::gen_texture(\n            &amp;mut self.surface,\n            self.width,\n            self.height,\n            self.color,\n            self.renderer,\n        );\n        self\n    }\n}\n</code></pre>\n\n<p>I would like to be able to do this:</p>\n\n<pre><code>let mut canvas = Canvas::new(100, 100, &amp;renderer).color(Color::RGB(80, 230, 80));\n</code></pre>\n\n<p>I get this error:</p>\n\n<blockquote>\n  <p>error: borrowed value does not live long enough\n  let mut canvas = Canvas::new(100, 100, &amp;renderer)</p>\n</blockquote>\n\n<p>Why does the returned <code>Canvas</code> object not live long enough? If I store the result in an intermediate <code>let</code>, then it works; why?</p>\n"}, {"tags": ["openssl", "rust", "rust-cargo"], "comments": [{"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1423722908, "post_id": 28469061, "comment_id": 45266119, "body": "Could you post your full <code>Cargo.lock</code>?"}, {"owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "edited": false, "score": 0, "creation_date": 1423742873, "post_id": 28469061, "comment_id": 45277005, "body": "It seems that the culprit is the fact that <a href=\"https://github.com/nickel-org/rust-http\" rel=\"nofollow noreferrer\">nickel-org&#39;s rust-http</a> (which is a dependency of nickel) brings in <code>sfackler&#47;rust-openssl</code> instead of the &quot;official&quot; one on crates.io. Unfortunately the rust-http repo doesn&#39;t have issues enabled, but I opened one on nickel&#39;s main repo: <a href=\"https://github.com/nickel-org/nickel.rs/issues/149\" rel=\"nofollow noreferrer\">#139</a>"}, {"owner": {"reputation": 261, "user_id": 2407776, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1738d99b3c543b63e1c05bcee6b31689?s=128&d=identicon&r=PG", "display_name": "Erik", "link": "https://stackoverflow.com/users/2407776/erik"}, "edited": false, "score": 0, "creation_date": 1423747072, "post_id": 28469061, "comment_id": 45279465, "body": "Renato: That looks like the solution to me, if you put this up as an answer I&#39;ll accept it. For now, maybe I&#39;ll just make a local fork of http and see if I can swap the dependency out without a major overhaul."}, {"owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "edited": false, "score": 0, "creation_date": 1423759428, "post_id": 28469061, "comment_id": 45287994, "body": "@Erik I don&#39;t think you will have a problem swaping the dependency here. It&#39;s the same library, just from a different source (github instead of crates.io)"}], "answers": [{"tags": [], "owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "is_accepted": true, "score": 3, "last_activity_date": 1423753525, "creation_date": 1423753525, "answer_id": 28480858, "question_id": 28469061, "link": "https://stackoverflow.com/questions/28469061/how-can-i-prevent-linking-to-the-same-native-library-by-multiple-dependencies/28480858#28480858", "title": "How can I prevent linking to the same native library by multiple dependencies?", "body": "<p>It seems that the culprit is the fact that <a href=\"https://github.com/nickel-org/rust-http\" rel=\"nofollow\">nickel-org's rust-http</a> (which is a dependency of nickel) brings in sfackler/rust-openssl instead of the \"official\" openssl on crates.io. Unfortunately the rust-http repo doesn't have issues enabled, but I opened one on nickel's main repo: <a href=\"https://github.com/nickel-org/nickel.rs/issues/149\" rel=\"nofollow\">#139</a></p>\n"}], "owner": {"reputation": 261, "user_id": 2407776, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1738d99b3c543b63e1c05bcee6b31689?s=128&d=identicon&r=PG", "display_name": "Erik", "link": "https://stackoverflow.com/users/2407776/erik"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1063, "favorite_count": 0, "accepted_answer_id": 28480858, "answer_count": 1, "score": 5, "last_activity_date": 1424291955, "creation_date": 1423713638, "last_edit_date": 1424291955, "question_id": 28469061, "link": "https://stackoverflow.com/questions/28469061/how-can-i-prevent-linking-to-the-same-native-library-by-multiple-dependencies", "title": "How can I prevent linking to the same native library by multiple dependencies?", "body": "<p>Question: How can I work around (or fix) the situation where two dependencies of mine link to the same library, but that library can't be linked twice? This seems like something that would typically be solved with a shared library, but I'm not sure how to approach it with Rust.</p>\n\n<p>Details:</p>\n\n<p>I'm making a web app in Rust using the <a href=\"https://github.com/nickel-org/nickel.rs/\" rel=\"nofollow\">Nickel framework</a> and <a href=\"https://github.com/sfackler/rust-postgres\" rel=\"nofollow\">rust-postgres</a> for a database. I get the following error when building:</p>\n\n<pre><code>&gt; cargo build\nnative library `openssl` is being linked to by more than one package, and can only be linked to by one package\n\n  openssl-sys v0.3.3 (https://github.com/sfackler/rust-openssl.git#ee66da60)\n  openssl-sys v0.3.3\n</code></pre>\n\n<p>Looking through Cargo.lock, openssl is referenced by http (which is a dependency of nickel) and rust-postgres.</p>\n\n<p>My Cargo.toml looks like this:</p>\n\n<pre><code>[package]\n\nname = \"goodoldweb\"\nversion = \"0.0.1\"\nauthors = [\"...\"]\n\n[dependencies.nickel]\ngit=\"https://github.com/nickel-org/nickel.rs.git\"\n\n[dependencies.postgres]\ngit=\"https://github.com/sfackler/rust-postgres.git\"\n</code></pre>\n\n<p>Here's the full Cargo.lock:</p>\n\n<pre><code>[root]\nname = \"goodoldweb\"\nversion = \"0.0.1\"\ndependencies = [\n \"nickel 0.1.0 (git+https://github.com/nickel-org/nickel.rs.git)\",\n \"postgres 0.6.1 (git+https://github.com/sfackler/rust-postgres.git)\",\n]\n\n[[package]]\nname = \"byteorder\"\nversion = \"0.2.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"gcc\"\nversion = \"0.1.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"groupable\"\nversion = \"0.1.0\"\nsource = \"git+https://github.com/nickel-org/groupable-rs#efc8d769f611558f086322cd8d2d5ff53314e435\"\n\n[[package]]\nname = \"http\"\nversion = \"0.1.0-pre\"\nsource = \"git+https://github.com/nickel-org/rust-http.git#1997192b7662ee5bf3bf381bfd9e2aa70f85a545\"\ndependencies = [\n \"openssl 0.3.3 (git+https://github.com/sfackler/rust-openssl.git)\",\n \"time 0.1.17 (git+https://github.com/rust-lang/time)\",\n \"url 0.2.18 (git+https://github.com/nickel-org/rust-url.git)\",\n]\n\n[[package]]\nname = \"libc\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"libressl-pnacl-sys\"\nversion = \"2.1.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"pnacl-build-helper 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"log\"\nversion = \"0.2.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"matches\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"nickel\"\nversion = \"0.1.0\"\nsource = \"git+https://github.com/nickel-org/nickel.rs.git#8c2e6a9bdbce0a3ec53d559b86f5060ee1ea6c29\"\ndependencies = [\n \"groupable 0.1.0 (git+https://github.com/nickel-org/groupable-rs)\",\n \"http 0.1.0-pre (git+https://github.com/nickel-org/rust-http.git)\",\n \"log 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"nickel_macros 0.0.1 (git+https://github.com/nickel-org/nickel.rs.git)\",\n \"plugin 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"regex 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"regex_macros 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"rust-mustache 0.3.0 (git+https://github.com/nickel-org/rust-mustache.git)\",\n \"rustc-serialize 0.2.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"time 0.1.17 (git+https://github.com/rust-lang/time)\",\n \"typemap 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"url 0.2.18 (git+https://github.com/nickel-org/rust-url.git)\",\n]\n\n[[package]]\nname = \"nickel_macros\"\nversion = \"0.0.1\"\nsource = \"git+https://github.com/nickel-org/nickel.rs.git#8c2e6a9bdbce0a3ec53d559b86f5060ee1ea6c29\"\n\n[[package]]\nname = \"openssl\"\nversion = \"0.3.3\"\nsource = \"git+https://github.com/sfackler/rust-openssl.git#ee66da6060c57bc86906261ee3d684fac1fd05e4\"\ndependencies = [\n \"openssl-sys 0.3.3 (git+https://github.com/sfackler/rust-openssl.git)\",\n]\n\n[[package]]\nname = \"openssl\"\nversion = \"0.3.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"openssl-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"openssl-sys\"\nversion = \"0.3.3\"\nsource = \"git+https://github.com/sfackler/rust-openssl.git#ee66da6060c57bc86906261ee3d684fac1fd05e4\"\ndependencies = [\n \"gcc 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"libressl-pnacl-sys 2.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"pkg-config 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"openssl-sys\"\nversion = \"0.3.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"gcc 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"libressl-pnacl-sys 2.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"pkg-config 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"phantom\"\nversion = \"0.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"phf\"\nversion = \"0.6.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"phf_shared 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"phf_macros\"\nversion = \"0.6.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"phf_shared 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"rand 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"phf_shared\"\nversion = \"0.6.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"pkg-config\"\nversion = \"0.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"plugin\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"typemap 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"pnacl-build-helper\"\nversion = \"1.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"postgres\"\nversion = \"0.6.1\"\nsource = \"git+https://github.com/sfackler/rust-postgres.git#fe6ae0c63a6e5d66d2afb785605b7d89ec47062d\"\ndependencies = [\n \"byteorder 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"log 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"openssl 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"phf 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"phf_macros 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"rustc-serialize 0.2.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"time 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"rand\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"libc 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"log 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"regex\"\nversion = \"0.1.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"regex_macros\"\nversion = \"0.1.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"regex 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"rust-mustache\"\nversion = \"0.3.0\"\nsource = \"git+https://github.com/nickel-org/rust-mustache.git#58ed857c88f8e5230913c382034601f37141b4ee\"\ndependencies = [\n \"log 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"rustc-serialize 0.2.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"rustc-serialize\"\nversion = \"0.2.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"time\"\nversion = \"0.1.17\"\nsource = \"git+https://github.com/rust-lang/time#0960d5e21b332088b04f62117514b0a02fd31259\"\ndependencies = [\n \"gcc 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"libc 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"time\"\nversion = \"0.1.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"gcc 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"libc 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"typemap\"\nversion = \"0.0.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\ndependencies = [\n \"phantom 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"unsafe-any 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"unsafe-any\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\n\n[[package]]\nname = \"url\"\nversion = \"0.2.18\"\nsource = \"git+https://github.com/nickel-org/rust-url.git#5801582b307c16f759b5fe11dec71385af86180c\"\ndependencies = [\n \"matches 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"rustc-serialize 0.2.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n</code></pre>\n"}]