[{"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 18, "last_activity_date": 1582714657, "last_edit_date": 1582714657, "creation_date": 1429141714, "answer_id": 29662949, "question_id": 29662807, "link": "https://stackoverflow.com/questions/29662807/how-do-you-borrow-a-mutable-reference-during-a-match/29662949#29662949", "title": "How do you borrow a mutable reference during a match?", "body": "<p><strong>Before Rust 1.26</strong> (from mid-2018, so any readers now are probably using a newer version), write your match block like one of these two:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>match d.get_mut(&amp;0).unwrap() {\n    &amp;mut VT::A(ref mut v) =&gt; v.push(0),\n    &amp;mut VT::B(ref mut v) =&gt; v.push(0.1),\n}\n</code></pre>\n\n<pre class=\"lang-rust prettyprint-override\"><code>match *d.get_mut(&amp;0).unwrap() {\n    VT::A(ref mut v) =&gt; v.push(0),\n    VT::B(ref mut v) =&gt; v.push(0.1),\n}\n</code></pre>\n\n<p>In patterns <code>ref mut</code> takes a mutable reference, even as <code>&amp;mut</code> dereferences a mutable reference.</p>\n\n<p>(The generally preferred convention was <code>match *foo { X =&gt; \u2026 }</code> rather than <code>match foo { &amp;mut X =&gt; \u2026 }</code>, due to less noise on the more numerous match branch lines, but it flipped the other way after the Rust 1.26 changes, since now <em>that</em> has less noise associated with it.)</p>\n\n<hr>\n\n<p><strong>From <a href=\"https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1260-2018-05-10\" rel=\"noreferrer\">Rust 1.26</a> onwards</strong>, any <code>&amp;</code>/<code>ref</code> and <code>&amp;mut</code>/<code>ref mut</code> pairs can be omitted, with the compiler inferring them. (This is a slightly simplistic explanation, but it\u2019s the essence of it.)</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>match d.get_mut(&amp;0).unwrap() {\n    VT::A(v) =&gt; v.push(0),\n    VT::B(v) =&gt; v.push(0.1),\n}\n</code></pre>\n"}], "owner": {"reputation": 1470, "user_id": 2075745, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/6f9a084d236381e1882c4e28edb5151f?s=128&d=identicon&r=PG", "display_name": "user25064", "link": "https://stackoverflow.com/users/2075745/user25064"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 7924, "favorite_count": 2, "accepted_answer_id": 29662949, "answer_count": 1, "score": 14, "last_activity_date": 1582714657, "creation_date": 1429140728, "last_edit_date": 1495541900, "question_id": 29662807, "link": "https://stackoverflow.com/questions/29662807/how-do-you-borrow-a-mutable-reference-during-a-match", "title": "How do you borrow a mutable reference during a match?", "body": "<p>I found <a href=\"https://stackoverflow.com/questions/22282117/how-do-i-borrow-a-reference-to-what-is-inside-an-optiont-in-rust\">this</a> but could not get my code to work. I still have the sneaking suspicion that I need <code>ref</code> somehow.</p>\n\n<p>I am trying to make a reasonable Table class in Rust to learn more about the language and running into some trouble with understanding the borrow checker and mutability concepts as well as their corresponding syntax.</p>\n\n<p>I want the table class to be flexible and allow for different column types where the data types within the columns are homogeneous. So, a column of ints, floats, strings etc.</p>\n\n<hr>\n\n<p>I started without flexible data types and came up with <a href=\"http://is.gd/a5ezdS\" rel=\"noreferrer\">this</a> hashmap mapping ints (the column labels in this case) to vectors of ints (the data within the columns). </p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::collections::HashMap; \n\nfn main() {\n    let mut d: HashMap&lt;isize, Vec&lt;isize&gt;&gt; = HashMap::new();\n    d.insert(0, Vec::new());\n    d.get_mut(&amp;0).unwrap().push(0); \n\n    println!(\"{:?}\", d);\n    // nice {0: [0]}\n}\n</code></pre>\n\n<p>To implement flexible data types, <code>enum</code> seemed like a decent start so <a href=\"http://is.gd/rmRJQh\" rel=\"noreferrer\">that is where I started</a> but I am stuck on the implementation.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::collections::HashMap; \n\n#[derive(Debug)] \nenum VT {\n    A(Vec&lt;isize&gt;),\n    B(Vec&lt;f64&gt;),\n}\n\nfn main() {\n    let mut d: HashMap&lt;isize, VT&gt; = HashMap::new();\n    d.insert(0, VT::A(Vec::new()));\n\n    match d.get_mut(&amp;0).unwrap() {\n        &amp;mut VT::A(v) =&gt; v.push(0),\n        &amp;mut VT::B(v) =&gt; v.push(0.1), // would not be reached as-is \n    } \n\n    println!(\"{:?}\", d);\n}\n// cannot borrow immutable local variable `v` as mutable :(\n</code></pre>\n\n<p>Ultimately, having a library similar to <a href=\"http://pandas.pydata.org/\" rel=\"noreferrer\">pandas</a> would be the dream. For now, implementing a table is good Rust practice.</p>\n"}, {"tags": ["string", "static", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1429113297, "post_id": 29654927, "comment_id": 47449804, "body": "Why do you want to have a global mutable variable? That strongly pushes against <i>everything</i> Rust wants to encourage. The fact that you had to use <code>unsafe</code> for basically your entire program is a sign that you are really trying to do something awkward."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 4, "creation_date": 1429114190, "post_id": 29654927, "comment_id": 47450467, "body": "What (as distinct from how) are you actually trying to do? It&#39;s not at all clear to me from your code example."}, {"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1429115515, "post_id": 29654927, "comment_id": 47451278, "body": "Why do you have global <code>&amp;&#39;static str</code> with application lifetime? If won&#39;t ever get de-allocated and could lead to memory leaks IIUC."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 7, "last_activity_date": 1510150908, "last_edit_date": 1510150908, "creation_date": 1429114169, "answer_id": 29655370, "question_id": 29654927, "link": "https://stackoverflow.com/questions/29654927/how-do-i-assign-a-string-to-a-mutable-static-variable/29655370#29655370", "title": "How do I assign a String to a mutable static variable?", "body": "<p>I have <em>no idea</em> what you are trying to do, so I can't tell you how to do it.</p>\n\n<p><strong>Maybe you want <a href=\"https://stackoverflow.com/q/27791532/155423\">How do I create a global, mutable singleton?</a></strong></p>\n\n<p>That being said, I can help explain your errors:</p>\n\n<pre><code>static mut NameArr: [&amp;'static str; 20] = [\"\\0\"; 20];\n</code></pre>\n\n<p>This declares a mutable global variable. The variable is an array of a fixed-length of 20 items. Each item is a <code>&amp;'static str</code>, a string literal that <strong>must be guaranteed to live for the life of the entire program</strong>. That's what <code>'static</code> means.</p>\n\n<pre><code>static mut S1: String = \"\".to_string();\n</code></pre>\n\n<p>This attempts to create <em>another</em> mutable global variable, this time it is a <code>String</code>, an object that allocates and owns a piece of memory in the heap. When a <code>String</code> goes out of scope, the memory is freed via a <em>destructor</em>. This is the source of your first error - global variables aren't allowed to have destructors. Additionally, you aren't currently allowed to <em>call methods</em> when defining a global value - there's no context for these methods to run right now!</p>\n\n<p>Having <em>global mutable variables</em> is really not a good idea with Rust, or any program, really. There's technical reasons (such as data races) and programmer reasons (rationalizing about this kind of code is <strong>hard</strong>). You can check out <a href=\"https://stackoverflow.com/q/27791532/155423\">How do I create a global, mutable singleton?</a> for instructions on how to do it if you really need it.</p>\n\n<p>Rust forces you to use an <code>unsafe</code> block to deal with mutable global variables for these reasons. The compiler can no longer guarantee the safety of your program. For example, what happens to the value you've stored in the array if you were to call <code>S1.clear</code>?</p>\n\n<p>There are also stylistic concerns:</p>\n\n<ol>\n<li>Rust uses <code>snake_case</code> for variables</li>\n<li><code>SCREAMING_SNAKE_CASE</code> for constants / statics</li>\n<li><code>CamelCase</code> for structs/enums/traits</li>\n<li>4-space indention</li>\n<li>Variable definitions should be <code>name: type</code>, with the space after the <code>:</code></li>\n</ol>\n"}, {"tags": [], "owner": {"reputation": 10797, "user_id": 505248, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/a4c11bcd46268e709dd8638de9c4a2af?s=128&d=identicon&r=PG&f=1", "display_name": "Pascalius", "link": "https://stackoverflow.com/users/505248/pascalius"}, "is_accepted": false, "score": 1, "last_activity_date": 1510150763, "last_edit_date": 1510150763, "creation_date": 1510150030, "answer_id": 47181804, "question_id": 29654927, "link": "https://stackoverflow.com/questions/29654927/how-do-i-assign-a-string-to-a-mutable-static-variable/47181804#47181804", "title": "How do I assign a String to a mutable static variable?", "body": "<p>In Rust you would use <a href=\"https://crates.io/crates/lazy-static\" rel=\"nofollow noreferrer\">lazy_static</a> and a <code>RwLock</code> or <code>Mutex</code> to synchronize write access.</p>\n\n<p><strong>Cargo.toml</strong></p>\n\n<pre><code>[dependencies]\nlazy_static = \"0.2\"\n</code></pre>\n\n<p><strong>main.rs</strong></p>\n\n<pre><code>#[macro_use]\nextern crate lazy_static;\n\nuse std::sync::RwLock;\n\nlazy_static! {\n    static ref GLOBAL_STRING: RwLock&lt;String&gt; = RwLock::new(\"string\".to_string());\n}\n\nfn main() {\n    {\n        let nice = GLOBAL_STRING.read().unwrap();\n        println!(\"{}\", *nice);\n    }\n\n    {\n        let mut mystr = GLOBAL_STRING.write().unwrap();\n        *mystr = \"assign new\".to_string();\n    }\n\n    {\n        let nice = GLOBAL_STRING.read().unwrap();\n        println!(\"{}\", *nice);\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 51, "user_id": 4792706, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/70cfd2c2d56bfc58d03bc49c26d553e2?s=128&d=identicon&r=PG&f=1", "display_name": "TurtleBest", "link": "https://stackoverflow.com/users/4792706/turtlebest"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2764, "favorite_count": 0, "answer_count": 2, "score": 5, "last_activity_date": 1510150908, "creation_date": 1429112978, "last_edit_date": 1429113224, "question_id": 29654927, "link": "https://stackoverflow.com/questions/29654927/how-do-i-assign-a-string-to-a-mutable-static-variable", "title": "How do I assign a String to a mutable static variable?", "body": "<p>I want to assign a value to a global variable, but it keeps having a compiler error:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>static mut NameArr: [&amp;'static str; 20] = [\"\\0\"; 20];\n\nfn main() {\n\n  unsafe {\n    static mut S1 :String = \"\".to_string();\n\n    S1.push('\\0');\n\n    NameArr[0] = S1.as_slice();\n  }\n}\n</code></pre>\n\n<p>The error:</p>\n\n<pre><code>a.rs:7:29: 7:43 error: mutable statics are not allowed to have destructors\na.rs:7     static mut S1 :String = \"\".to_string();\n                                   ^~~~~~~~~~~~~~\na.rs:7:29: 7:43 error: static contains unimplemented expression type [E0019]\na.rs:7     static mut S1 :String = \"\".to_string();\n                                   ^~~~~~~~~~~~~~\nerror: aborting due to 2 previous errors\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 2388, "user_id": 144873, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/fa80de77b38844201e18c30f88bc88a7?s=128&d=identicon&r=PG", "display_name": "naasking", "link": "https://stackoverflow.com/users/144873/naasking"}, "edited": false, "score": 0, "creation_date": 1429196202, "post_id": 29657337, "comment_id": 47494337, "body": "Thanks for the links, but the Linaro cross binaries for Windows seem to be built for mingw32 on Windows, so they don&#39;t run on msys2 which the Rust build uses. I&#39;ll try in my Debian VM. Still, it seems like it should be possible to just build what I need from LLVM, which is already included in the Rust build. Seems unnecessarily convoluted to require the cross chain to be already installed."}, {"owner": {"reputation": 1479, "user_id": 4450817, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/566922fb80a38c57d6a0db0be0f42f3b?s=128&d=identicon&r=PG&f=1", "display_name": "Vaelden", "link": "https://stackoverflow.com/users/4450817/vaelden"}, "reply_to_user": {"reputation": 2388, "user_id": 144873, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/fa80de77b38844201e18c30f88bc88a7?s=128&d=identicon&r=PG", "display_name": "naasking", "link": "https://stackoverflow.com/users/144873/naasking"}, "edited": false, "score": 0, "creation_date": 1429206928, "post_id": 29657337, "comment_id": 47501904, "body": "LLVM still does not include binutils (ld, as and other fundamental programs) so you would will always need those. Besides, Rust uses jemalloc, written in C, that needs a cross-compiler. So maybe it could be possible to include clang in what is being downloaded and built as an option, but the simplest (and fastest) will still be to rely on a cross-compilation toolchain being already installed."}, {"owner": {"reputation": 2388, "user_id": 144873, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/fa80de77b38844201e18c30f88bc88a7?s=128&d=identicon&r=PG", "display_name": "naasking", "link": "https://stackoverflow.com/users/144873/naasking"}, "edited": false, "score": 0, "creation_date": 1429208493, "post_id": 29657337, "comment_id": 47502871, "body": "Ok, so I&#39;ve managed to build rust cross compiler on Debian Jessie after including the embebian sources and installing the arm gc cross compilers. Native rust progams build and run as before, but building for arm fails with a link error: <a href=\"http://higherlogics.com/personal/err-arm.txt\" rel=\"nofollow noreferrer\">higherlogics.com/personal/err-arm.txt</a>  I&#39;m not sure what it means by file in wrong format. Does ARM not use ELF, so I should somehow get rust to use arm-linux-gnueabihf-ld? I&#39;m not sure how to do that since it clearly used arm-linux-gnueabihf-gcc."}, {"owner": {"reputation": 1479, "user_id": 4450817, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/566922fb80a38c57d6a0db0be0f42f3b?s=128&d=identicon&r=PG&f=1", "display_name": "Vaelden", "link": "https://stackoverflow.com/users/4450817/vaelden"}, "reply_to_user": {"reputation": 2388, "user_id": 144873, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/fa80de77b38844201e18c30f88bc88a7?s=128&d=identicon&r=PG", "display_name": "naasking", "link": "https://stackoverflow.com/users/144873/naasking"}, "edited": false, "score": 0, "creation_date": 1429208929, "post_id": 29657337, "comment_id": 47503132, "body": "It looks like rustc still tries to use <code>cc</code> which is usually a symlink to <code>gcc</code>, which will in turn try to use <code>ld</code> and not the cross-compiling one <code>arm-linux-gnueabihf-ld</code>. Could you try with <code>rustc --target=arm-unknown-linux-gnueabihf hello.rs -C linker=arm-linux-gnueabihf-gcc</code>?"}, {"owner": {"reputation": 2388, "user_id": 144873, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/fa80de77b38844201e18c30f88bc88a7?s=128&d=identicon&r=PG", "display_name": "naasking", "link": "https://stackoverflow.com/users/144873/naasking"}, "edited": false, "score": 0, "creation_date": 1429210473, "post_id": 29657337, "comment_id": 47504009, "body": "That seemed to do it, although Raspbian is only on glibc 2.13 where this linked to glibc 2.18. I can just link everything statically for my purposes, so not a big deal. So is there some configure option for rust to use the proper linker given the --target specified?"}, {"owner": {"reputation": 1479, "user_id": 4450817, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/566922fb80a38c57d6a0db0be0f42f3b?s=128&d=identicon&r=PG&f=1", "display_name": "Vaelden", "link": "https://stackoverflow.com/users/4450817/vaelden"}, "reply_to_user": {"reputation": 2388, "user_id": 144873, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/fa80de77b38844201e18c30f88bc88a7?s=128&d=identicon&r=PG", "display_name": "naasking", "link": "https://stackoverflow.com/users/144873/naasking"}, "edited": false, "score": 0, "creation_date": 1429212204, "post_id": 29657337, "comment_id": 47505122, "body": "I edited my answer. It should now answer your latest comments."}, {"owner": {"reputation": 2388, "user_id": 144873, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/fa80de77b38844201e18c30f88bc88a7?s=128&d=identicon&r=PG", "display_name": "naasking", "link": "https://stackoverflow.com/users/144873/naasking"}, "edited": false, "score": 0, "creation_date": 1429225507, "post_id": 29657337, "comment_id": 47511930, "body": "Actually, not quite there yet. I updated the Raspi to Jessie as well, so I&#39;m on the same glibc now, but the hello world segfaults. Running it in gdb doesn&#39;t yield anything informative. It says it&#39;s using host libthread_db library, then it receives a SIGSEGV in &quot;0x2a052502 in ?? ()&quot;. Any thoughts on how to debug?"}], "tags": [], "owner": {"reputation": 1479, "user_id": 4450817, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/566922fb80a38c57d6a0db0be0f42f3b?s=128&d=identicon&r=PG&f=1", "display_name": "Vaelden", "link": "https://stackoverflow.com/users/4450817/vaelden"}, "is_accepted": true, "score": 7, "last_activity_date": 1429212103, "last_edit_date": 1429212103, "creation_date": 1429120363, "answer_id": 29657337, "question_id": 29652280, "link": "https://stackoverflow.com/questions/29652280/cant-build-cross-compiler/29657337#29657337", "title": "Can&#39;t build cross compiler", "body": "<p>The error message says that make did not find the <code>arm-linux-gnueabihf-gcc</code> binary, which is supposed to be a C compiler producing ARM code. That means that you probably don't have any ARM C cross-compilation toolchain installed.</p>\n\n<p>I know Ubuntu has packages for cross compilers (gcc-arm-linux-gnueabihf in 14.04) so Debian may have the same packages. You can also find fully packaged ARM C cross-compilers for Windows and Linux on the <a href=\"https://www.linaro.org/\" rel=\"nofollow\">Linaro</a> website. If you are building for the Rapsberry Pi, you can also find toolchains to build for Raspbian and Archlinux on <a href=\"https://github.com/raspberrypi/tools\" rel=\"nofollow\">https://github.com/raspberrypi/tools</a>.</p>\n\n<p>Here is an example under Linux with a Linaro toolchain (should be distribution-agnostic for the host)</p>\n\n<pre><code>$ wget http://releases.linaro.org/14.11/components/toolchain/binaries/arm-linux-gnueabihf/gcc-linaro-4.9-2014.11-x86_64_arm-linux-gnueabihf.tar.xz\n$ tar -xf gcc-linaro-4.9-2014.11-x86_64_arm-linux-gnueabihf.tar.xz\n$ export PATH=$PATH:$PWD/gcc-linaro-4.9-2014.11-x86_64_arm-linux-gnueabihf/bin\n$ cd &lt;your_configured_rustc_build_directory&gt;\n$ make\n</code></pre>\n\n<p>You can then use the cross compiler with the following line. You can provide the full path to the arm-linux-gnueabihf-gcc binary if you don't want to put it in your PATH.</p>\n\n<pre><code>rustc --target=arm-unknown-linux-gnueabihf -C linker=arm-linux-gnueabihf-gcc hello.rs\n</code></pre>\n\n<p>If you are using Cargo, you can specify the linker to use for each target in the <code>.cargo/config</code> with this option:</p>\n\n<pre><code>[target.arm-unknown-linux-gnueabihf]\nlinker = \"arm-linux-gnueabihf-gcc\"\n</code></pre>\n"}], "owner": {"reputation": 2388, "user_id": 144873, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/fa80de77b38844201e18c30f88bc88a7?s=128&d=identicon&r=PG", "display_name": "naasking", "link": "https://stackoverflow.com/users/144873/naasking"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2990, "favorite_count": 0, "accepted_answer_id": 29657337, "answer_count": 1, "score": 3, "last_activity_date": 1429212181, "creation_date": 1429106290, "last_edit_date": 1429212181, "question_id": 29652280, "link": "https://stackoverflow.com/questions/29652280/cant-build-cross-compiler", "title": "Can&#39;t build cross compiler", "body": "<p>I can't seem to build Rust as a cross-compiler, either on Windows with MSYS2 or on a fresh install of Debian Wheezy. The error is the same for both. I run this configure:</p>\n\n<pre><code>./configure --target=arm-unknown-linux-gnueabihf,x86_64-pc-windows-gnu\n</code></pre>\n\n<p>make works, but then make install fails with:</p>\n\n<pre><code>[...]\nprepare: tmp/dist/rustc-1.0.0-dev-x86_64-pc-windows-gnu-image/bin/rustlib/x86_64-pc-windows-gnu/lib/rustdoc-*.dll\nprepare: tmp/dist/rustc-1.0.0-dev-x86_64-pc-windows-gnu-image/bin/rustlib/x86_64-pc-windows-gnu/lib/fmt_macros-*.dll\nprepare: tmp/dist/rustc-1.0.0-dev-x86_64-pc-windows-gnu-image/bin/rustlib/x86_64-pc-windows-gnu/lib/libmorestack.a\nprepare: tmp/dist/rustc-1.0.0-dev-x86_64-pc-windows-gnu-image/bin/rustlib/x86_64-pc-windows-gnu/lib/libcompiler-rt.a\ncompile: arm-unknown-linux-gnueabihf/rt/arch/arm/morestack.o\nmake[1]: arm-linux-gnueabihf-gcc: Command not found\n/home/Sandro/rust/mk/rt.mk:94: recipe for target 'arm-unknown-linux-gnueabihf/rt/arch/arm/morestack.o' failed\nmake[1]: *** [arm-unknown-linux-gnueabihf/rt/arch/arm/morestack.o] Error 127\nmake[1]: Leaving directory '/home/Sandro/rust'\n/home/Sandro/rust/mk/install.mk:22: recipe for target 'install' failed\nmake: *** [install] Error 2\n</code></pre>\n\n<p>Everything builds fine if I don't specify a cross architecture. Am I missing some special configure flag to make this work?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1429082882, "post_id": 29643305, "comment_id": 47428954, "body": "By the way: this example is based on an old test of mine which was ported to the latest rustc. Back in the days, as_slice() was still needed. Nowadays, one would just rely on automatic conversions as described by the various answers."}], "answers": [{"comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1429081040, "post_id": 29643439, "comment_id": 47427927, "body": "Actually <code>&amp;s</code> (i.e., no slicing) is even simpler."}, {"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 0, "creation_date": 1429081289, "post_id": 29643439, "comment_id": 47428055, "body": "@delnan Yes indeed, didn&#39;t tink about it. But it doesn&#39;t always work (if you want to <code>match</code> a <code>String</code> against a set of <code>&amp;str</code> values for examples, like this <a href=\"http://is.gd/VDuUjn\" rel=\"nofollow noreferrer\">is.gd/VDuUjn</a> )"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1429081406, "post_id": 29643439, "comment_id": 47428124, "body": "Yeah, it has to be in a context where deref coercions apply. Though one can always do <code>let foo_str: &amp;str = &amp;foo;</code> and use that."}], "tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": true, "score": 8, "last_activity_date": 1429080762, "creation_date": 1429080762, "answer_id": 29643439, "question_id": 29643305, "link": "https://stackoverflow.com/questions/29643305/how-to-provide-a-type-annotation-for-asref/29643439#29643439", "title": "How to provide a type-annotation for `AsRef`?", "body": "<p>In your precise case of <code>String</code> and <code>&amp;str</code>, the simplest is to use the <a href=\"http://doc.rust-lang.org/std/ops/trait.Index.html\" rel=\"noreferrer\"><code>Index</code></a> syntax:</p>\n\n<pre><code>let s: String = \"foo\".to_string();\nlet slice: &amp;str = &amp;s[..]; // full range index\n</code></pre>\n\n<p>which in your case, would give:</p>\n\n<pre><code>let s = \"Hi\";\nassert!(&amp;s.replace(\"Hi\", \"Ho\")[..] == \"Ho\");\n</code></pre>\n\n<p>However, for traits methods like <code>as_ref()</code>, you can also call them using the syntax:</p>\n\n<pre><code>Trait::method(obj); // equivalent to obj.method();\n</code></pre>\n\n<p>Which allow you to set the types parameters like this:</p>\n\n<pre><code>Trait::&lt;T&gt;::method(obj);\n</code></pre>\n\n<p>In your case, an alternate syntax would thus be:</p>\n\n<pre><code>let s = \"Hi\";\nassert!(AsRef::&lt;str&gt;::as_ref(&amp;s.replace(\"Hi\", \"Ho\")) == \"Ho\");\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 2, "creation_date": 1429082285, "post_id": 29643514, "comment_id": 47428658, "body": "It isn&#39;t the <code>Deref</code> impl/dereferencing, it is <code>impl&lt;&#39;a&gt; PartialEq&lt;&amp;&#39;a str&gt; for String</code>: <a href=\"http://doc.rust-lang.org/std/string/struct.String.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/string/struct.String.html</a>"}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1429102771, "post_id": 29643514, "comment_id": 47441499, "body": "@huon-dbaupp: good point. I hadn\u2019t stopped to think about it properly but indeed things like <code>==</code> don\u2019t do any autoref/autoderef like that."}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": false, "score": 8, "last_activity_date": 1429102736, "last_edit_date": 1429102736, "creation_date": 1429081042, "answer_id": 29643514, "question_id": 29643305, "link": "https://stackoverflow.com/questions/29643305/how-to-provide-a-type-annotation-for-asref/29643514#29643514", "title": "How to provide a type-annotation for `AsRef`?", "body": "<p>In this particular case, you don\u2019t need any fanciness at all: <code>String</code> is comparable with <code>&amp;str</code> (there is a <code>PartialEq&lt;&amp;str&gt;</code> implementation on <code>String</code>), so you can just compare them directly:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let s = \"Hi\";\nassert!(s.replace(\"Hi\", \"Ho\") == \"Ho\");\n// Or, if you prefer:\nassert_eq!(s.replace(\"Hi\", \"Ho\"), \"Ho\");\n</code></pre>\n\n<p>In real life you will not often need to call <code>as_ref</code> for reasons like this.</p>\n"}], "owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1732, "favorite_count": 0, "accepted_answer_id": 29643439, "answer_count": 2, "score": 7, "last_activity_date": 1429102736, "creation_date": 1429080279, "question_id": 29643305, "link": "https://stackoverflow.com/questions/29643305/how-to-provide-a-type-annotation-for-asref", "title": "How to provide a type-annotation for `AsRef`?", "body": "<p>The following code shows were the question originates. Since <code>as_slice()</code> is deprecated, <code>as_ref()</code> is suggested as replacement.</p>\n\n<p>However, when using it in this context, a type annotation is required.</p>\n\n<pre><code>let s = \"Hi\";             // This is a string slice\n// warning: use of deprecated item: use std::convert::AsRef&lt;str&gt; instead, #[warn(deprecated)] on by default\nassert!(s.replace(\"Hi\", \"Ho\").as_slice() == \"Ho\");\n// tests/lang.rs:120:35: 120:43 error: type annotations required: cannot resolve `collections::string::String : core::convert::AsRef&lt;_&gt;` [E0283]\n// assert!(s.replace(\"Hi\", \"Ho\").as_ref() == \"Ho\");\n</code></pre>\n\n<p><strong>How can I provide such a type-annotation ?</strong>. The only syntax I would find somewhat applicable is <code>&lt;MyType as AsRef&gt;::as_ref()</code>, but I don't know how to do that with an instance.</p>\n\n<p>I am using <code>rustc 1.0.0-nightly (be9bd7c93 2015-04-05) (built 2015-04-05)</code>.</p>\n"}, {"tags": ["c", "rust", "static-linking"], "comments": [{"owner": {"reputation": 16233, "user_id": 4253229, "user_type": "registered", "accept_rate": 83, "profile_image": "https://lh4.googleusercontent.com/-e2FAQvlj5CQ/AAAAAAAAAAI/AAAAAAAAAqM/TlSnekirgNE/photo.jpg?sz=128", "display_name": "Eugene Sh.", "link": "https://stackoverflow.com/users/4253229/eugene-sh"}, "edited": false, "score": 0, "creation_date": 1429031823, "post_id": 29632715, "comment_id": 47409427, "body": "Try turning optimizations off"}, {"owner": {"reputation": 65, "user_id": 4787622, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2a03a13b347fe64ef19e79d29ab3da02?s=128&d=identicon&r=PG", "display_name": "kykcuk", "link": "https://stackoverflow.com/users/4787622/kykcuk"}, "reply_to_user": {"reputation": 16233, "user_id": 4253229, "user_type": "registered", "accept_rate": 83, "profile_image": "https://lh4.googleusercontent.com/-e2FAQvlj5CQ/AAAAAAAAAAI/AAAAAAAAAqM/TlSnekirgNE/photo.jpg?sz=128", "display_name": "Eugene Sh.", "link": "https://stackoverflow.com/users/4253229/eugene-sh"}, "edited": false, "score": 0, "creation_date": 1429049591, "post_id": 29632715, "comment_id": 47418811, "body": "<code>rustc -g -C opt_level=0 foo.rs</code> <code>gcc -O0 -g bar.c libfoo.a -ldl -lpthread -lrt -lgcc_s -lpthread -lc -lm -o bar</code> produces same result"}], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 4, "last_activity_date": 1429080049, "last_edit_date": 1429080049, "creation_date": 1429077160, "answer_id": 29642495, "question_id": 29632715, "link": "https://stackoverflow.com/questions/29632715/segmentation-fault-after-linking-rust-staticlib-with-c/29642495#29642495", "title": "Segmentation fault after linking Rust staticlib with C", "body": "<p>The problem here is that thread-locals with destructors can only be used in position-independent executables (due to <a href=\"https://github.com/rust-lang/rust/pull/24445\" rel=\"nofollow\">a bug</a>) . Fix: pass the <code>-pie</code> flag to gcc, or wait a day or two.</p>\n\n<p>This is caused by <a href=\"https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src/libstd/io/stdio.rs#L402-L414\" rel=\"nofollow\"><code>std::io::stdio::_print</code></a> and <a href=\"https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src/libstd/io/stdio.rs#L24-L28\" rel=\"nofollow\"><code>std::io::stdio::LOCAL_STDOUT</code></a> in the standard library:</p>\n\n<pre><code>/// Stdout used by print! and println! macros\nthread_local! {\n    static LOCAL_STDOUT: RefCell&lt;Option&lt;Box&lt;Write + Send&gt;&gt;&gt; = {\n        RefCell::new(None)\n    }\n}\n\n// ...\n\npub fn _print(args: fmt::Arguments) {\n    let result = LOCAL_STDOUT.with(|s| {\n        if s.borrow_state() == BorrowState::Unused {\n            if let Some(w) = s.borrow_mut().as_mut() {\n                return w.write_fmt(args);\n            }\n        }\n        stdout().write_fmt(args)\n    });\n    if let Err(e) = result {\n        panic!(\"failed printing to stdout: {}\", e);\n    }\n}\n</code></pre>\n\n<p>The <code>Box</code> in <code>LOCAL_STDOUT</code> has the destructor in that case, so the executable crashes when the thread-local variable is touched. I've filed <a href=\"https://github.com/rust-lang/rust/issues/24445\" rel=\"nofollow\">#24445</a>, and Alex Crichton has <a href=\"https://github.com/rust-lang/rust/issues/24445\" rel=\"nofollow\">diagnosed and fixed the underlying cause</a> already.</p>\n\n<p>Printing doesn't require initialising the threads or anything; there's fallback to <code>stdout()</code> in the case that <code>LOCAL_STDOUT</code> contains <code>None</code> (which is the default). Just passing <code>-pie</code> is enough to convince the executable to print <code>bork!</code> instead of crashing.</p>\n"}], "owner": {"reputation": 65, "user_id": 4787622, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2a03a13b347fe64ef19e79d29ab3da02?s=128&d=identicon&r=PG", "display_name": "kykcuk", "link": "https://stackoverflow.com/users/4787622/kykcuk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 514, "favorite_count": 0, "accepted_answer_id": 29642495, "answer_count": 1, "score": 3, "last_activity_date": 1429080049, "creation_date": 1429029186, "question_id": 29632715, "link": "https://stackoverflow.com/questions/29632715/segmentation-fault-after-linking-rust-staticlib-with-c", "title": "Segmentation fault after linking Rust staticlib with C", "body": "<p>I'm trying to link statically against library written in Rust:</p>\n\n<pre><code>#![crate_type = \"staticlib\"]\n\n#[no_mangle]\npub extern \"C\" fn foo() {\n    println!(\"bork!\");\n}\n</code></pre>\n\n<p>Using following code in C:</p>\n\n<pre><code>void foo();\nint main()\n{\n    foo();\n    return 0;\n}\n</code></pre>\n\n<p>Compile lib with rustc:</p>\n\n<pre><code>rustc foo.rs\n</code></pre>\n\n<p>Compile binary and link with library:</p>\n\n<pre><code>gcc -g bar.c libfoo.a -ldl -lpthread -lrt -lgcc_s -lpthread -lc -lm -o bar\n</code></pre>\n\n<p>Run inside debugger:</p>\n\n<pre><code>(gdb) run\nStarting program: /home/kykc/rusttest/bar \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00007ffff72117df in __cxa_thread_atexit_impl (func=&lt;optimized out&gt;, obj=&lt;optimized out&gt;, dso_symbol=0x0) at cxa_thread_atexit_impl.c:67\n67  cxa_thread_atexit_impl.c: No such file or directory.\n</code></pre>\n\n<p>gcc:</p>\n\n<pre><code>gcc-4.8.real (Ubuntu 4.8.2-19ubuntu1) 4.8.2\n</code></pre>\n\n<p>rustc:</p>\n\n<pre><code>rustc 1.0.0-beta (9854143cb 2015-04-02) (built 2015-04-02)\n</code></pre>\n\n<p>It works completely fine with dylib. What am I doing wrong?</p>\n"}, {"tags": ["rust", "immutability"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1429026910, "post_id": 29631590, "comment_id": 47406487, "body": "Do you ask whether it&#39;s important to track mutability, or are you already convinced that tracking mutability is important and only want to know whether immutability is the default?"}, {"owner": {"reputation": 1553, "user_id": 3839220, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/8062ce7db5476fc8d470bba1e7cc785d?s=128&d=identicon&r=PG&f=1", "display_name": "metro-man", "link": "https://stackoverflow.com/users/3839220/metro-man"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1429027000, "post_id": 29631590, "comment_id": 47406553, "body": "Uhhh, I&#39;ve updated the question a little bit. What do you mean by tracking mutability?"}, {"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1429088075, "post_id": 29631590, "comment_id": 47431986, "body": "Actually, Rust doesn&#39;t enforce interior mutability. What it does check is you can&#39;t call <code>&amp;mut</code> method on something that wasn&#39;t declared <code>mut</code>. You can still change <code>Cell</code> or <code>RefCell</code> using immutable borrow."}], "answers": [{"comments": [{"owner": {"reputation": 1553, "user_id": 3839220, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/8062ce7db5476fc8d470bba1e7cc785d?s=128&d=identicon&r=PG&f=1", "display_name": "metro-man", "link": "https://stackoverflow.com/users/3839220/metro-man"}, "edited": false, "score": 2, "creation_date": 1429027261, "post_id": 29632043, "comment_id": 47406731, "body": "Perfect, I probably should have checked their reference/specification/book before posting this :)"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1429028625, "post_id": 29632043, "comment_id": 47407586, "body": "Another point: Every time someone measured it, the majority of bindings were immutable. Assuming we&#39;re already sold on tracking mutable vs immutable bindings precisely, then marking the mutable ones and making immutable the default is the economic choice, as it uses less code than the other way around."}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 4, "creation_date": 1429031517, "post_id": 29632043, "comment_id": 47409251, "body": "Not just majority, but overwhelming majority. A non-scientific test: I just grabbed Cargo&#39;s source, and there are 356 instances of &#39;let mut&#39;, and 1937 instances of &#39;let&#39; (which of course counts let mut too, so 1581 pure lets)."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 3, "creation_date": 1429088565, "post_id": 29632043, "comment_id": 47432263, "body": "that doesn&#39;t even count function arguments. I&#39;d wager the ratio is even larger when function args are included"}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 20, "last_activity_date": 1429027118, "last_edit_date": 1592644375, "creation_date": 1429027118, "answer_id": 29632043, "question_id": 29631590, "link": "https://stackoverflow.com/questions/29631590/why-is-immutability-enforced-in-rust-unless-otherwise-specified-with-mut/29632043#29632043", "title": "Why is immutability enforced in Rust unless otherwise specified with `mut`?", "body": "<p>The <a href=\"http://doc.rust-lang.org/nightly/book/variable-bindings.html\" rel=\"noreferrer\">Rust-Book</a> actually addresses this topic.</p>\n<blockquote>\n<p>There is no single reason that bindings are immutable by default, but we can think about it through one of Rust\u2019s primary focuses: safety. If you forget to say <code>mut</code>, the compiler will catch it, and let you know that you have mutated something you may not have intended to mutate. If bindings were mutable by default, the compiler would not be able to tell you this. If you <em>did</em> intend mutation, then the solution is quite easy: add <code>mut</code>.</p>\n<p>There are other good reasons to avoid mutable state when possible, but they\u2019re out of the scope of this guide. In general, you can often avoid explicit mutation, and so it is preferable in Rust. That said, sometimes, mutation is what you need, so it\u2019s not verboten.</p>\n</blockquote>\n<p>Basically it is the C++-Mantra that everything that you don't want to modify should be const, just properly done by reversing the rules. <a href=\"https://stackoverflow.com/questions/19478034/why-arent-c-types-const-by-default\">Also see this Stackoverflow article about C++.</a></p>\n"}], "owner": {"reputation": 1553, "user_id": 3839220, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/8062ce7db5476fc8d470bba1e7cc785d?s=128&d=identicon&r=PG&f=1", "display_name": "metro-man", "link": "https://stackoverflow.com/users/3839220/metro-man"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2806, "favorite_count": 0, "accepted_answer_id": 29632043, "answer_count": 1, "score": 17, "last_activity_date": 1429027314, "creation_date": 1429025764, "last_edit_date": 1429026985, "question_id": 29631590, "link": "https://stackoverflow.com/questions/29631590/why-is-immutability-enforced-in-rust-unless-otherwise-specified-with-mut", "title": "Why is immutability enforced in Rust unless otherwise specified with `mut`?", "body": "<p>Why is immutability forced in Rust, unless you specify <code>mut</code>? Is this a design choice for safety, do you consider this how it should be naturally in other languages?</p>\n\n<p>I should probably clarify, I'm still a newbie at Rust. So is this a design choice related to another feature in the language?</p>\n"}, {"tags": ["c", "rust", "ffi"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1429023800, "post_id": 29629775, "comment_id": 47404342, "body": "You may be interested in <a href=\"https://github.com/RustAudio\" rel=\"nofollow noreferrer\">RustAudio</a>."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1429023807, "last_edit_date": 1429023807, "creation_date": 1429021837, "answer_id": 29630073, "question_id": 29629775, "link": "https://stackoverflow.com/questions/29629775/what-happens-under-the-hood-when-i-call-a-rust-dylib-from-native-c-code/29630073#29630073", "title": "What happens under the hood when I call a Rust dylib from native C code?", "body": "<p>Nothing special happens. Compiled Rust code that is exported with <code>extern C</code> looks just the same as any other native code.</p>\n\n<blockquote>\n  <p>Does additional threads gets spawned on the Rust function call?</p>\n</blockquote>\n\n<p>No threads are created, unless your code creates them.</p>\n\n<blockquote>\n  <p>How much blocking happen on such call - mutexes, locks, memory allocations on heap, anything like that.</p>\n</blockquote>\n\n<p>No, unless your code does such.</p>\n"}], "owner": {"reputation": 65, "user_id": 4787622, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2a03a13b347fe64ef19e79d29ab3da02?s=128&d=identicon&r=PG", "display_name": "kykcuk", "link": "https://stackoverflow.com/users/4787622/kykcuk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 138, "favorite_count": 0, "accepted_answer_id": 29630073, "answer_count": 1, "score": 3, "last_activity_date": 1429023807, "creation_date": 1429021018, "last_edit_date": 1429021779, "question_id": 29629775, "link": "https://stackoverflow.com/questions/29629775/what-happens-under-the-hood-when-i-call-a-rust-dylib-from-native-c-code", "title": "What happens under the hood when I call a Rust dylib from native C code?", "body": "<p>Say, I have some dummy library written in Rust:</p>\n\n<pre><code>#![crate_type = \"dylib\"]\n\n#[no_mangle]\npub extern \"C\" fn foo() {\n    println!(\"bork!\");\n}\n</code></pre>\n\n<p>And I'm using it from C native code like that:</p>\n\n<pre><code>void foo();\nint main()\n{\n    foo();\n    return 0;\n}\n</code></pre>\n\n<p>I'm particularly interested in two things:</p>\n\n<ul>\n<li><p>Does additional threads gets spawned on the Rust function call?</p></li>\n<li><p>How much blocking happen on such call - mutexes, locks, memory allocations on heap, anything like that.</p></li>\n</ul>\n\n<p>I'm thinking of using Rust for real-time DSP applications and therefore I must be aware of any blocking operations that take place here. But I'm not enough hardcore to dig in actual C-Rust interop implementation myself..</p>\n"}, {"tags": ["multithreading", "concurrency", "rust"], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 0, "last_activity_date": 1429023459, "creation_date": 1429023459, "answer_id": 29630708, "question_id": 29629367, "link": "https://stackoverflow.com/questions/29629367/how-to-share-non-send-objects-between-threads/29630708#29630708", "title": "How to share non-Send objects between threads?", "body": "<p>Since you are using <code>scoped</code> threads, which are guaranteed to die <em>before</em> <code>rustbox</code>, you can simply share a reference to rustbox <em>if it is <code>Sync</code></em>.</p>\n\n<pre><code>fn main() {\n    let rustbox = match rustbox::RustBox::init(Default::default())  {\n        Ok(r) =&gt; r,\n        _ =&gt; panic!(\"\"),\n    };\n    let rustbox = &amp;rustbox;\n\n    let count = Arc::new(Mutex::new(0usize));\n    let (tx, rx) = sync::mpsc::channel();\n    let count_clone = count.clone();\n    thread::scoped(move|| {\n        loop {\n            let _ = rx.recv().unwrap();\n            show(rustbox, count_clone.lock().unwrap().clone());\n        }\n    });\n    loop {\n        if let Ok(_) = rustbox.poll_event(false) {\n            let mut i = count.lock().unwrap();\n            *i += 1;\n            show(rustbox, i.clone());\n        } else {\n            tx.send(()).unwrap();\n        }\n    }\n}\n</code></pre>\n\n<p>If it is not <code>Sync</code>, you can simply wrap it in a <code>Mutex</code> and sharing a reference to that.</p>\n\n<p><em>Note: this is only possible because you are using <code>thread::scoped</code>, should you be using <code>thread::spawned</code> then <code>Send</code> would be mandatory.</em></p>\n"}], "owner": {"reputation": 385, "user_id": 4489993, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b7da5b64b0090361295ae727caa6a86a?s=128&d=identicon&r=PG&f=1", "display_name": "agatana", "link": "https://stackoverflow.com/users/4489993/agatana"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 697, "favorite_count": 2, "accepted_answer_id": 29630708, "answer_count": 1, "score": 2, "last_activity_date": 1429023459, "creation_date": 1429019980, "last_edit_date": 1429020084, "question_id": 29629367, "link": "https://stackoverflow.com/questions/29629367/how-to-share-non-send-objects-between-threads", "title": "How to share non-Send objects between threads?", "body": "<p>I want to use the <code>rustbox</code> library in my concurrent program.\nHowever, <code>rustbox::RustBox</code> does not implement <code>Send</code> trait, so I can't share the object between threads.</p>\n\n<pre><code>extern crate rustbox;\n\nuse std::thread;\nuse std::sync::{ self, Arc, Mutex };\nuse std::default::Default;\n\nfn main() {\n    let rustbox = match rustbox::RustBox::init(Default::default())  {\n        Ok(r) =&gt; r,\n        _ =&gt; panic!(\"\"),\n    };\n\n    let count = Arc::new(Mutex::new(0usize));\n    let (tx, rx) = sync::mpsc::channel();\n    let count_clone = count.clone();\n    thread::scoped(move|| {\n        loop {\n            let _ = rx.recv().unwrap();\n            show(&amp;rustbox, count_clone.lock().unwrap().clone());\n        }\n    });\n    loop {\n        if let Ok(_) = rustbox.poll_event(false) {\n            let mut i = count.lock().unwrap();\n            *i += 1;\n            show(&amp;rustbox, i.clone());\n        } else {\n            tx.send(()).unwrap();\n        }\n    }\n}\n\nfn show(rustbox: &amp;rustbox::RustBox, count: usize) {\n    use rustbox::Color;\n    rustbox.print(1, 1, rustbox::RB_BOLD, Color::Default, Color::Default, &amp;format!(\"{}\", count));\n}\n</code></pre>\n\n<p><code>tx.send(()).unwrap();</code> will occur in other threads.</p>\n\n<p>The compiler error message is:</p>\n\n<pre><code>src/main.rs:16:5: 16:19 error: the trait `core::marker::Send` is not implemented for the type `rustbox::RustBox` [E0277]\nsrc/main.rs:16     thread::scoped(move|| {\n               ^~~~~~~~~~~~~~\nsrc/main.rs:16:5: 16:19 note: `rustbox::RustBox` cannot be sent  between threads safely\nsrc/main.rs:16     thread::scoped(move|| {\n               ^~~~~~~~~~~~~~\nerror: aborting due to previous error\nCould not compile `sof`.\n</code></pre>\n"}, {"tags": ["pointers", "rust", "memory-safety"], "comments": [{"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 5, "creation_date": 1429021178, "post_id": 29628650, "comment_id": 47402361, "body": "\u201cthat in a language that features pointers, it is not possible for the compiler to decide fully at compile time whether all pointers are used correctly and/or are valid (refer to an alive object) for various reasons, since that would essentially constitute solving the halting problem.\u201d I contest the truth of this statement. C-style pointers, maybe, for they lack various good things and have various bad things like pointer arithmetic, but for what people actually <i>need</i> from pointers, Rust with its references is a perfect example of the invalidity of the statement."}, {"owner": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "reply_to_user": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1429042727, "post_id": 29628650, "comment_id": 47415479, "body": "@ChrisMorgan I see, thanks."}], "answers": [{"comments": [{"owner": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "edited": false, "score": 0, "creation_date": 1429019779, "post_id": 29629134, "comment_id": 47401356, "body": "&quot;all functions manipulating references must declare how the references from their input and output are linked&quot; \u2013 yes, those are exactly the lifetime annotations I&#39;m referring to. Does this mean that if I ever get the lifetime annotations wrong, I can dereference an invalid pointer and crash?"}, {"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "reply_to_user": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "edited": false, "score": 0, "creation_date": 1429019897, "post_id": 29629134, "comment_id": 47401443, "body": "No, because the compiler actually checks that your annotations are correct. This sometimes can force the programmer to do some unusual things in order for the compiler to see that the annotations are right."}, {"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "reply_to_user": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "edited": false, "score": 0, "creation_date": 1429019929, "post_id": 29629134, "comment_id": 47401469, "body": "But on the other hand, if you do something wrong in an <code>unsafe</code> block, anything can happen."}, {"owner": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "edited": false, "score": 0, "creation_date": 1429040170, "post_id": 29629134, "comment_id": 47414105, "body": "of course, anything might happen in <code>unsafe</code> blocks, hence I&#39;m not at all interested in them. So the answer is &quot;if the compiler cannot prove it&#39;s correct, it&#39;s illegal.&quot; Thank you!"}], "tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": false, "score": 2, "last_activity_date": 1429019285, "creation_date": 1429019285, "answer_id": 29629134, "question_id": 29628650, "link": "https://stackoverflow.com/questions/29628650/how-does-rust-achieve-compile-time-only-pointer-safety/29629134#29629134", "title": "How does Rust achieve compile-time-only pointer safety?", "body": "<p>Most of the safety of Rust references is guaranteed by strict rules:</p>\n\n<ul>\n<li>If you posses a const reference (<code>&amp;</code>), you can clone this reference and pass it around, but not create a mutable <code>&amp;mut</code> reference out of it.</li>\n<li>If a mutable (<code>&amp;mut</code>) reference to an object exists, no other reference to this object can exist.</li>\n<li>A reference is not allowed to outlive the object it refers to, and all functions manipulating references <em>must</em> declare how the references from their input and output are linked, using lifetime annotations (like <code>'a</code>).</li>\n</ul>\n\n<p>So in terms of expressiveness, we are effectively more limited than when using plain raw pointers (for example, building a graph structure is not possible using only safe references), but these rules can effectively be completely checked at compile-time.</p>\n\n<p>Yet, it is still possible to use raw pointers, but you have to enclose the code dealing with them in a <code>unsafe { /* ... */ }</code> block, telling to the compiler \"Trust me, I know what I am doing here\". That is what some special smart pointers do internally, such as <a href=\"http://doc.rust-lang.org/std/cell/struct.RefCell.html\" rel=\"nofollow\"><code>RefCell</code></a>, which allows you to have these rules checked at runtime rather than compile-time, to gain expressiveness.</p>\n"}, {"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 9, "last_activity_date": 1429019405, "creation_date": 1429019405, "answer_id": 29629177, "question_id": 29628650, "link": "https://stackoverflow.com/questions/29628650/how-does-rust-achieve-compile-time-only-pointer-safety/29629177#29629177", "title": "How does Rust achieve compile-time-only pointer safety?", "body": "<p><strong>Disclaimer</strong>: I'm in a bit of a hurry, so this is a bit meandering.  Feel free to clean it up.</p>\n\n<p>The One Sneaky Trick That Language Designers Hate&trade; is basically this: Rust can <em>only</em> reason about the <code>'static</code> lifetime (used for global variables and other whole-program lifetime things) and the lifetime of stack (<em>i.e.</em> local) variables: it cannot express or reason about the lifetime of <em>heap</em> allocations.</p>\n\n<p>This means a few things.  First of all, all of the library types that deal with heap allocations (<em>i.e.</em> <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>) all <em>own</em> the thing they point to.  As a result, they don't actually <em>need</em> lifetimes in order to exist.</p>\n\n<p>Where you <em>do</em> need lifetimes is when you're accessing the <em>contents</em> of a smart pointer.  For example:</p>\n\n<pre><code>let mut x: Box&lt;i32&gt; = box 0;\n*x = 42;\n</code></pre>\n\n<p>What is happening behind the scenes on that second line is this:</p>\n\n<pre><code>{\n    let box_ref: &amp;mut Box&lt;i32&gt; = &amp;mut x;\n    let heap_ref: &amp;mut i32 = box_ref.deref_mut();\n    *heap_ref = 42;\n}\n</code></pre>\n\n<p>In other words, because <code>Box</code> isn't magic, we have to tell the compiler how to turn it into a regular, run of the mill borrowed pointer.  This is what the <code>Deref</code> and <code>DerefMut</code> traits are for.  This raises the question: what, exactly, is the lifetime of <code>heap_ref</code>?</p>\n\n<p>The answer to this is in the definition of <code>DerefMut</code> (from memory because I'm in a hurry):</p>\n\n<pre><code>trait DerefMut {\n    type Target;\n    fn deref_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut Target;\n}\n</code></pre>\n\n<p>Like I said before, Rust <em>absolutely cannot</em> talk about \"heap lifetimes\".  Instead, it has to tie the lifetime of the heap-allocated <code>i32</code> to the only other lifetime it has on hand: the lifetime of the <code>Box</code>.</p>\n\n<p>What this means is that \"complicated\" things don't have an expressible lifetime, and thus have to <em>own</em> the thing they manage.  When you convert a complicated smart pointer/handle into a simple borrowed pointer, <em>that</em> is the moment that you have to introduce a lifetime, and you usually just use the lifetime of the handle itself.</p>\n\n<p>Actually, I should clarify: by \"lifetime of the handle\", I really mean \"the lifetime of the variable in which the handle is currently being stored\": lifetimes are really for <em>storage</em>, not for <em>values</em>.  This is typically why newcomers to Rust get tripped up when they can't work out why they can't do something like:</p>\n\n<pre><code>fn thingy&lt;'a&gt;() -&gt; (Box&lt;i32&gt;, &amp;'a i32) {\n    let x = box 1701;\n    (x, &amp;x)\n}\n</code></pre>\n\n<p><em>\"But... I know that the box will continue to live on, why does the compiler say it doesn't?!\"</em>  Because Rust can't reason about heap lifetimes and <em>must</em> resort to tying the lifetime of <code>&amp;x</code> to the <em>variable</em> <code>x</code>, <em>not</em> the heap allocation it happens to point to.</p>\n"}, {"comments": [{"owner": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "edited": false, "score": 0, "creation_date": 1429040875, "post_id": 29629526, "comment_id": 47414505, "body": "Excellent explanation. There&#39;s only one thing which is not entirely clear to me: what do you mean by &quot;Rust doesn&#39;t prove you all pointers are used correctly&quot;? Of course one can write &quot;bogus&quot; programs, i. e. ones that are supposed to do something but they actually do something different, and give us incorrect results. By &quot;using pointers correctly&quot;, I meant that &quot;you can&#39;t have memory errors resulting from invalid/null/dangling pointers&quot;."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "edited": false, "score": 0, "creation_date": 1429084917, "post_id": 29629526, "comment_id": 47430108, "body": "Yes. You can still write <code>42</code> over your integer that you just read and wonder afterwards why it doesn&#39;t matter what you type in, your integer is 42. That&#39;s a logic error, not a memory error."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 8, "last_activity_date": 1429022606, "last_edit_date": 1495542325, "creation_date": 1429020378, "answer_id": 29629526, "question_id": 29628650, "link": "https://stackoverflow.com/questions/29628650/how-does-rust-achieve-compile-time-only-pointer-safety/29629526#29629526", "title": "How does Rust achieve compile-time-only pointer safety?", "body": "<blockquote>\n  <p>Is it the case that pointer checking isn't done entirely at compile-time, and Rust's smart pointers still introduce some runtime overhead compared to, say, raw pointers in C?</p>\n</blockquote>\n\n<p>There are special runtime-checks for things that can't be checked at compile time. These are usually found in the <code>cell</code> crate. But in general, Rust checks everything at compile time and should produce the same code as you would in C (if your C-code isn't doing undefined stuff). </p>\n\n<blockquote>\n  <p>Or is it possible that the Rust compiler can't make fully correct decisions, and it sometimes needs to Just Trust The Programmer\u2122, probably using one of the lifetime annotations (the ones with the &lt;'lifetime_ident> syntax)? In this case, does this mean that the pointer/memory safety guarantee is not 100%, and still relies on the programmer writing correct code?</p>\n</blockquote>\n\n<p>If the compiler cannot make the correct decision you get a compile time error telling you that the compiler cannot verify what you are doing. This might also restrict you from stuff you know is correct, but the compiler doesn't. You can always go to <code>unsafe</code> code in that case. But as you correctly assumed, then the compiler relies partly on the programmer.</p>\n\n<p>The compiler checks the function's implementation, to see if it does exactly what the lifetimes say it does. Then, at the call-site of the function, it checks if the programmer uses the function correctly. This is similar to type-checking. A C++ compiler checks if you are returning an object of the correct type. Then it checks at the call-site if the returned object is stored in a variable of the correct type. At no time can the programmer of a function break the promise (except if <code>unsafe</code> is used, but you can always let the compiler enforce that no <code>unsafe</code> is used in your project)</p>\n\n<p>Rust is continuously improved. More things may get legal in Rust once the compiler becomes smarter.</p>\n\n<blockquote>\n  <p>Another possibility is that Rust pointers are non-\"universal\" or restricted in some sense, so that the compiler can infer their properties entirely during compile-time, but they are not as useful as e. g. raw pointers in C or smart pointers in C++.</p>\n</blockquote>\n\n<p>There's a few things that can go wrong in C:</p>\n\n<ol>\n<li>dangling pointers</li>\n<li>double free</li>\n<li>null pointers</li>\n<li>wild pointers</li>\n</ol>\n\n<p>These don't happen in safe Rust.</p>\n\n<ol>\n<li>You can never have a pointer that points to an object no longer on the stack or heap. That's proven at compile time through lifetimes.</li>\n<li>You do not have manual memory management in Rust. Use a <code>Box</code> to allocate your objects (similar but not equal to a <code>unique_ptr</code> in C++)</li>\n<li>Again, no manual memory management. <code>Box</code>es automatically free memory.</li>\n<li>In safe Rust you can create a pointer to any location, but you cannot dereference it. Any reference you create always is bound to an object.</li>\n</ol>\n\n<p>There's a few things that can go wrong in C++:</p>\n\n<ol>\n<li>everything that can go wrong in C</li>\n<li>SmartPointers only help you not forget calling <code>free</code>. You can still create dangling references: <code>auto x = make_unique&lt;int&gt;(42);</code>\n<code>auto&amp; y = *x;</code>\n<code>x.reset();</code>\n<code>y = 99;</code></li>\n</ol>\n\n<p>Rust fixes those:</p>\n\n<ol>\n<li>see above</li>\n<li>as long as <code>y</code> exists, you may not modify <code>x</code>. This is checked at compile time and cannot be circumvented by more levels of indirection or structs.</li>\n</ol>\n\n<blockquote>\n  <p>I have read somewhere that in a language that features pointers, it is not possible for the compiler to decide fully at compile time whether all pointers are used correctly and/or are valid (refer to an alive object) for various reasons, since that would essentially constitute solving the halting problem.</p>\n</blockquote>\n\n<p>Rust doesn't prove you all pointers are used correctly. You may still write bogus programs. Rust proves that you are not using invalid pointers. Rust proves that you never have null-pointers. Rust proves that you never have two pointers to the same object, execept if all these pointers are non-mutable (const). Rust does not allow you to write any program (since that would include programs that violate memory safety). Right now Rust still prevents you from writing some useful programs, but there are plans to allow more (legal) programs to be written in safe Rust.</p>\n\n<blockquote>\n  <p>That is not surprising, intuitively, because in this case, we would be able to infer the runtime behavior of a program during compile-time, similarly to what's stated in <a href=\"https://stackoverflow.com/questions/17410081/why-is-it-impossible-to-build-a-compiler-that-can-determine-if-a-c-function-wi\">this related question</a>.</p>\n</blockquote>\n\n<p>Revisiting the example in your referenced question about the halting problem:</p>\n\n<pre><code>void foo() {\n    if (bar() == 0) this-&gt;a = 1;\n}\n</code></pre>\n\n<p>The above C++ code would look one of two ways in Rust:</p>\n\n<pre><code>fn foo(&amp;mut self) {\n    if self.bar() == 0 {\n        self.a = 1;\n    }\n}\n\nfn foo(&amp;mut self) {\n    if bar() == 0 {\n        self.a = 1;\n    }\n}\n</code></pre>\n\n<p>For an arbitrary <code>bar</code> you cannot prove this, because it might access global state. Rust soon gets <code>const</code> functions, which can be used to compute stuff at compile-time (similar to <code>constexpr</code>). If <code>bar</code> is <code>const</code>, it becomes trivial to prove if <code>self.a</code> is set to <code>1</code> at compile-time. Other than that, without <code>pure</code> functions or other restrictions of the function content, you can never prove whether <code>self.a</code> is set to <code>1</code> or not.</p>\n\n<p>Rust currently doesn't care whether your code is called or not. It cares whether the memory of <code>self.a</code> still exists during the assignment. <code>self.bar()</code> can never destroy <code>self</code> (except in <code>unsafe</code> code). Therefor <code>self.a</code> will always be available inside the <code>if</code> branch.</p>\n"}], "owner": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2944, "favorite_count": 7, "accepted_answer_id": 29629177, "answer_count": 3, "score": 16, "last_activity_date": 1429022606, "creation_date": 1429018125, "last_edit_date": 1495540919, "question_id": 29628650, "link": "https://stackoverflow.com/questions/29628650/how-does-rust-achieve-compile-time-only-pointer-safety", "title": "How does Rust achieve compile-time-only pointer safety?", "body": "<p>I have read somewhere that in a language that features pointers, it is not possible for the compiler to decide fully at compile time whether all pointers are used correctly and/or are valid (refer to an alive object) for various reasons, since that would essentially constitute solving the halting problem. That is not surprising, intuitively, because in this case, we would be able to infer the runtime behavior of a program during compile-time, similarly to what's stated in <a href=\"https://stackoverflow.com/questions/17410081/why-is-it-impossible-to-build-a-compiler-that-can-determine-if-a-c-function-wi\">this related question</a>.</p>\n\n<p>However, from what I can tell, the Rust language requires that pointer checking be done entirely at compile time (there's no undefined behavior related to pointers, \"safe\" pointers  at least, and there's no \"invalid pointer\" or \"null pointer\" runtime exception either).</p>\n\n<p>Assuming that the Rust compiler doesn't solve the halting problem, where does the fallacy lie?</p>\n\n<ul>\n<li>Is it the case that <strong>pointer checking isn't done entirely at compile-time,</strong> and Rust's smart pointers still introduce some runtime overhead compared to, say, raw pointers in C?</li>\n<li>Or is it possible that the Rust compiler can't make fully correct decisions, and it sometimes needs to Just Trust The Programmer\u2122, probably using one of the lifetime annotations (the ones with the <code>&lt;'lifetime_ident&gt;</code> syntax)? In this case, does this mean that the pointer/memory safety guarantee is not 100%, and still relies on the programmer writing correct code?</li>\n<li>Another possibility is that Rust pointers are non-\"universal\" or restricted in some sense, so that the compiler can infer their properties entirely during compile-time, but they are not as useful as e. g. raw pointers in C or smart pointers in C++.</li>\n<li>Or maybe it is something completely different and I'm misinterpreting one or more of <br /> <code>{ \"pointer\", \"safety\", \"guaranteed\", \"compile-time\" }</code>.</li>\n</ul>\n"}, {"tags": ["c", "rust"], "answers": [{"tags": [], "owner": {"reputation": 813, "user_id": 1453453, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/24d7111ef96c9534289fa27d069594e2?s=128&d=identicon&r=PG", "display_name": "aepsil0n", "link": "https://stackoverflow.com/users/1453453/aepsil0n"}, "is_accepted": true, "score": 3, "last_activity_date": 1429016709, "last_edit_date": 1495541367, "creation_date": 1429016709, "answer_id": 29628129, "question_id": 29627893, "link": "https://stackoverflow.com/questions/29627893/comparison-between-rust-and-c-c-pointers-for-accessing-values-in-a-struct/29628129#29628129", "title": "Comparison between Rust and C/C++ pointers for accessing values in a struct", "body": "<p><code>p.x</code> is indeed sugar in a certain sense. Rust automatically dereferences any type that implements the trait <a href=\"http://doc.rust-lang.org/std/ops/trait.Deref.html\" rel=\"nofollow noreferrer\"><code>Deref</code></a> or <a href=\"http://doc.rust-lang.org/std/ops/trait.DerefMut.html\" rel=\"nofollow noreferrer\"><code>DerefMut</code></a>(depending on whether the context requires a mutable or immutable reference), when doing method/attribute look-up.</p>\n\n<p>In your example, the reference <code>&amp;Point</code> implements <code>Deref&lt;Target=Point&gt;</code>, so your <code>p.x</code> expression is expanded to <code>(*p).x</code>. Note that this only works, as long as the pointer type does not have an attribute/method named <code>x</code> of its own (which is not the case for a simple refererence).</p>\n\n<p>There is <a href=\"https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules\">another question on SO</a> that goes on about the detailed rules for auto-dereferencing.</p>\n"}], "owner": {"reputation": 1470, "user_id": 2075745, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/6f9a084d236381e1882c4e28edb5151f?s=128&d=identicon&r=PG", "display_name": "user25064", "link": "https://stackoverflow.com/users/2075745/user25064"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 546, "favorite_count": 0, "accepted_answer_id": 29628129, "answer_count": 1, "score": 0, "last_activity_date": 1489684142, "creation_date": 1429016119, "last_edit_date": 1489684142, "question_id": 29627893, "link": "https://stackoverflow.com/questions/29627893/comparison-between-rust-and-c-c-pointers-for-accessing-values-in-a-struct", "title": "Comparison between Rust and C/C++ pointers for accessing values in a struct", "body": "<p>Some simple <a href=\"https://play.rust-lang.org/?gist=ff6c20950e84b07ad8c4e532fbd4ddbe&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Rust code</a>:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct Point {\n    x: f64,\n    y: f64,\n}\n\nfn main() {\n    let p: &amp;Point = &amp;(Point { x: 0.3, y: 0.4 });\n    // println!(\"{:?}\" , p-&gt;x); // no sugar here for Rust\n    println!(\"{:?}\", (*p).x);\n    println!(\"{:?}\", p.x); // sugar?\n    // no leak right? thanks Rust\n}\n</code></pre>\n\n<p>And some similar <a href=\"http://codepad.org/crV2CARz\" rel=\"nofollow noreferrer\">C code</a></p>\n\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt; \n#include &lt;stdlib.h&gt; \n\ntypedef struct Point Point; \n\nstruct Point {\n    float x;\n    float y; \n};\n\nint main() {\n    Point __tmp = { 0.3, 0.4 };\n    Point* p = &amp;__tmp;\n\n    printf(\"%f\\n\", p-&gt;x); // C sugar for below\n    printf(\"%f\\n\", (*p).x);\n    // below doesn't work because p is a pointer to a point\n    //printf(\"%f\", p.x); // error: request for member 'x' in something not a structure or union\n    // memory leak at this point right?\n    return 0; \n}\n</code></pre>\n\n<p>It seems that <code>p</code> is a pointer to a <code>Point</code> in both pieces of code.</p>\n\n<p>I want to make sure that Rust implementing <code>p.x</code> is (or can be thought of as) syntactic sugar and that I don't have a fundamental misunderstanding of what is going on. </p>\n\n<p>Is this what they mean by <em>aliasing</em>? Is <code>p</code> in Rust more like an alias?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1429011428, "post_id": 29625502, "comment_id": 47395682, "body": "At a cursory glance, a good number of methods could be thought of as &quot;missing&quot;; the most probable reason is that nobody implemented them yet... if this is not what you were asking for, then could you please specify your question?"}, {"owner": {"reputation": 1187, "user_id": 1137004, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5ebaa8eb2711795cbf1c9cdda773328?s=128&d=identicon&r=PG", "display_name": "kiyomi", "link": "https://stackoverflow.com/users/1137004/kiyomi"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1429012704, "post_id": 29625502, "comment_id": 47396429, "body": "@MatthieuM. Yes, &quot;nobody implemented them yet&quot; or &quot;for some reason, nobody implemented them&quot;"}, {"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1429021529, "post_id": 29625502, "comment_id": 47402607, "body": "There is no O(1) delete on LinkedList. If you used it in iterator, it cost you to iterate to that point. Further more <a href=\"https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html#method.swap_remove\" rel=\"nofollow noreferrer\">Vec#swap_remove</a>, does O(1) delete without preserving ordering."}], "answers": [{"tags": [], "owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "is_accepted": true, "score": 3, "last_activity_date": 1495111813, "last_edit_date": 1495111813, "creation_date": 1429022179, "answer_id": 29630212, "question_id": 29625502, "link": "https://stackoverflow.com/questions/29625502/why-does-the-linkedlist-mutable-iterator-not-have-a-remove-next-method/29630212#29630212", "title": "Why does the LinkedList mutable iterator not have a `remove_next` method?", "body": "<p>The most likely reason as to why there isn't a <code>remove_next</code> method, is because Rust team is evaluating cursors as alternative approach:</p>\n\n<pre><code>#[inline]\n#[unstable(feature = \"collections\",\n           reason = \"this is probably better handled by a cursor type -- we'll see\")]\n</code></pre>\n\n<p>[<a href=\"https://doc.rust-lang.org/nightly/std/collections/linked_list/struct.IterMut.html#method.insert_next/linked_list.rs.html#786-789\" rel=\"nofollow noreferrer\">Source</a>]</p>\n"}], "owner": {"reputation": 1187, "user_id": 1137004, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5ebaa8eb2711795cbf1c9cdda773328?s=128&d=identicon&r=PG", "display_name": "kiyomi", "link": "https://stackoverflow.com/users/1137004/kiyomi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 159, "favorite_count": 0, "accepted_answer_id": 29630212, "answer_count": 1, "score": 2, "last_activity_date": 1495111813, "creation_date": 1429008754, "last_edit_date": 1429015022, "question_id": 29625502, "link": "https://stackoverflow.com/questions/29625502/why-does-the-linkedlist-mutable-iterator-not-have-a-remove-next-method", "title": "Why does the LinkedList mutable iterator not have a `remove_next` method?", "body": "<p>I want an <code>O(1)</code> delete of the node in the <a href=\"https://doc.rust-lang.org/nightly/std/collections/linked_list/struct.IterMut.html\" rel=\"nofollow\"><code>LinkedList::IterMut</code></a>.<code>Vec</code> or other can't.</p>\n"}, {"tags": ["metaprogramming", "rust"], "answers": [{"comments": [{"owner": {"reputation": 1734, "user_id": 1565238, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/cd5ac413e588dd1a030e00f1dea143ee?s=128&d=identicon&r=PG", "display_name": "Aleksander Alekseev", "link": "https://stackoverflow.com/users/1565238/aleksander-alekseev"}, "edited": false, "score": 0, "creation_date": 1429005167, "post_id": 29624089, "comment_id": 47392015, "body": "So, TypeId is just a constant generated during the compilation and used inside generic get/set functions. And according to the source code, types are casted to/from Any in unsafe block, which actually is quite safe, because we know exactly which type is used in every generic function. Right?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1734, "user_id": 1565238, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/cd5ac413e588dd1a030e00f1dea143ee?s=128&d=identicon&r=PG", "display_name": "Aleksander Alekseev", "link": "https://stackoverflow.com/users/1565238/aleksander-alekseev"}, "edited": false, "score": 0, "creation_date": 1429005429, "post_id": 29624089, "comment_id": 47392148, "body": "@afiskon: You can use Any without <code>unsafe</code>, from what I know, however it is itself implement with <code>unsafe</code> behind the scenes because it manipulates raw memory."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 1, "creation_date": 1429020605, "post_id": 29624089, "comment_id": 47401954, "body": "Just to be clear, the functionality of anymap can be implemented in completely safe code; it can just be made somewhat more efficient by the use of unsafe code there which is indeed infallible, for the TypeId is stored as the key also and is by generic constraints and so forth known statically."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 2, "last_activity_date": 1429004626, "creation_date": 1429004626, "answer_id": 29624089, "question_id": 29623946, "link": "https://stackoverflow.com/questions/29623946/implementation-of-anymap-and-runtime-overhead-of-struct-portu32/29624089#29624089", "title": "Implementation of AnyMap and runtime overhead of `struct Port(u32);`", "body": "<p>Actually, it is pretty common in C, C++ and other system languages to have different types with the same in-memory representation.</p>\n\n<p>In memory:</p>\n\n<ul>\n<li>a <code>u32</code> is 4 contiguous bytes of memory</li>\n<li>a <code>Port</code> is 4 contiguous bytes of memory</li>\n<li>a <code>ConnectionLimit</code> is 4 contiguous bytes of memory</li>\n</ul>\n\n<p>Notably, compared to many other languages, there is no \"virtual table\" or other extraneous information stored in memory for each instance of those types.</p>\n\n<p>As for <code>AnyMap</code>, at the point where you store your object in the map, the compiler knows the type of the object, and therefore can provide the correct <code>TypeId</code>. This then has to be carried along preciously with the object data, because if it is ever lost it cannot be recovered.</p>\n"}], "owner": {"reputation": 1734, "user_id": 1565238, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/cd5ac413e588dd1a030e00f1dea143ee?s=128&d=identicon&r=PG", "display_name": "Aleksander Alekseev", "link": "https://stackoverflow.com/users/1565238/aleksander-alekseev"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 149, "favorite_count": 0, "accepted_answer_id": 29624089, "answer_count": 1, "score": 4, "last_activity_date": 1429018811, "creation_date": 1429004221, "last_edit_date": 1429018811, "question_id": 29623946, "link": "https://stackoverflow.com/questions/29623946/implementation-of-anymap-and-runtime-overhead-of-struct-portu32", "title": "Implementation of AnyMap and runtime overhead of `struct Port(u32);`", "body": "<p>I was reading \"24 days of Rust\" and <a href=\"http://siciarz.net/24-days-of-rust-anymap/\" rel=\"nofollow\">the example of <code>AnyMap</code> usage</a> just blew my mind. Consider the following code:</p>\n\n<pre><code>#[deriving(Show)]\nstruct Port(u32);\n\n#[deriving(Show)]\nstruct ConnectionLimit(u32);\n</code></pre>\n\n<p>It says:</p>\n\n<blockquote>\n  <p>Here the <code>Port</code> and <code>ConnectionLimit</code> types are abstractions over the\n  underlying integer (<strong>with no overhead at runtime</strong>!).</p>\n</blockquote>\n\n<p>Very well, I can understand how this could be achieved. All types are checked during compilation and in runtime we have only u32's. But in this case how is it possible to create a map from some <code>TypeId</code> to <code>Box&lt;Any&gt;</code>? And how Any could be casted to any subtype, like u32? </p>\n\n<p>The <a href=\"https://github.com/chris-morgan/anymap/\" rel=\"nofollow\">source code on <code>AnyMap</code></a> is quite complicated and a lot of metaprogramming is involved. How does it work? Maybe there is just a mistake in \"24 days of Rust\" and <code>Port</code> and <code>ConnectionLimit</code> actually have runtime overhead?</p>\n"}, {"tags": ["rust", "hyper"], "answers": [{"comments": [{"owner": {"reputation": 355, "user_id": 287612, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/9080f2bdfecd351dbb0ab0409117bc52?s=128&d=identicon&r=PG", "display_name": "hoxnox", "link": "https://stackoverflow.com/users/287612/hoxnox"}, "edited": false, "score": 0, "creation_date": 1429010533, "post_id": 29623343, "comment_id": 47395186, "body": "Thanks. But There is another problem - res bocme borrowed, when I call status_mut(), so I can&#39;t use res after this call. I simply try to answer with Response(StatusCode::Forbidden, &quot;Auth failed&quot;) in the handler..."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 355, "user_id": 287612, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/9080f2bdfecd351dbb0ab0409117bc52?s=128&d=identicon&r=PG", "display_name": "hoxnox", "link": "https://stackoverflow.com/users/287612/hoxnox"}, "edited": false, "score": 1, "creation_date": 1429011469, "post_id": 29623343, "comment_id": 47395702, "body": "It is not really clear what you want to do, but there is a universal method when you want to limit borrow boundaries - take the code which creates and uses a borrow in curly braces: <code>{ let status = res.status_mut(); status.whatever(...); } &#47;* here res is available again *&#47;</code>."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 3, "last_activity_date": 1429002433, "creation_date": 1429002433, "answer_id": 29623343, "question_id": 29622808, "link": "https://stackoverflow.com/questions/29622808/how-can-i-set-http-status-code-in-hyper-http-server-handler/29623343#29623343", "title": "How can I set HTTP status code in hyper HTTP Server handler?", "body": "<p>Mutability in Rust is inherited, so you can just mark the parameter as mutable to get mutability:</p>\n\n<pre><code>pub fn handle_request(req: Request, mut res: Response&lt;Fresh&gt;){\n    let status: &amp;mut StatusCode = res.status_mut();\n}\n</code></pre>\n\n<p>This is possible because this function accepts <code>Response&lt;Fresh&gt;</code> by value - if it accepted it by reference: <code>&amp;Response&lt;Fresh&gt;</code>, it would be impossible to modify it at all.</p>\n"}], "owner": {"reputation": 355, "user_id": 287612, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/9080f2bdfecd351dbb0ab0409117bc52?s=128&d=identicon&r=PG", "display_name": "hoxnox", "link": "https://stackoverflow.com/users/287612/hoxnox"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 730, "favorite_count": 1, "accepted_answer_id": 29623343, "answer_count": 1, "score": 2, "last_activity_date": 1429011447, "creation_date": 1429000833, "last_edit_date": 1429011447, "question_id": 29622808, "link": "https://stackoverflow.com/questions/29622808/how-can-i-set-http-status-code-in-hyper-http-server-handler", "title": "How can I set HTTP status code in hyper HTTP Server handler?", "body": "<p>According to the <a href=\"https://hyperium.github.io/hyper/hyper/server/response/struct.Response.html\" rel=\"nofollow\">documentation</a> I could get mutable reference to the <code>status</code> by calling <code>status_mut()</code>. Unfortunately signature of the handler function, used to serve requests with hyper::Server contain immutable <code>Response</code>, so the following code gives me an error:</p>\n\n<pre><code>pub fn handle_request(req: Request, res: Response&lt;Fresh&gt;){\n    let status: &amp;mut StatusCode = res.status_mut();\n}\n\nerror: cannot borrow immutable local variable `res` as mutable\n</code></pre>\n\n<p>Is there any way to set response status code in the request handler, used by hyper::server::Server?</p>\n\n<p><strong>UPD</strong>: Finally I have found the example. Right in the <a href=\"https://github.com/hyperium/hyper/blob/master/examples/server.rs\" rel=\"nofollow\">source code</a>. =*)</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 3692, "user_id": 1467466, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/ec7b22599095a0d388d6e51818e7db9b?s=128&d=identicon&r=PG", "display_name": "user", "link": "https://stackoverflow.com/users/1467466/user"}, "edited": false, "score": 0, "creation_date": 1428996904, "post_id": 29621305, "comment_id": 47387178, "body": "Okay, I currently think that the reason is an extension of why you can&#39;t move out of mutable borrows in a context where you don&#39;t know where you&#39;re borrowing from: because it&#39;s expected that some later statement <i>may</i> mutably borrow one stack frame up. This then propagates to traits, but in a slightly more convoluted way that, if true, isn&#39;t particularly clear in the error messages."}], "answers": [{"tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": true, "score": 6, "last_activity_date": 1428997637, "creation_date": 1428997637, "answer_id": 29621832, "question_id": 29621305, "link": "https://stackoverflow.com/questions/29621305/moving-a-mutable-trait-object-reference-into-a-box/29621832#29621832", "title": "Moving a mutable trait object reference into a box", "body": "<blockquote>\n  <p>Shouldn't the mutability rules transitively ensure that the trait I get in <code>accept_b</code> is the sole owner of the underlying object and thereby support movement into a box?</p>\n</blockquote>\n\n<p>No, absolutely not. <code>accept_b</code> is borrowing the reference, not owning it.</p>\n\n<p>The mutability rule only makes you certain that you are the only one borrowing the object, but it does not give you ownership.</p>\n\n<p>It is actually never possible to move out of borrowed content and leaving the reference dandling. If you want to move out of a <code>&amp;mut</code> reference, you can use functions like <code>std::mem::replace(..)</code>, but they require you to put an other object in place of the one you are moving out, which in turns involve copying actual memory data, and thus the type must be <code>Sized</code>.</p>\n\n<p>So no, it is not possible to move out of a <code>&amp;mut T</code> if <code>T</code> is not <code>Sized</code>.</p>\n"}], "owner": {"reputation": 3692, "user_id": 1467466, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/ec7b22599095a0d388d6e51818e7db9b?s=128&d=identicon&r=PG", "display_name": "user", "link": "https://stackoverflow.com/users/1467466/user"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1610, "favorite_count": 0, "accepted_answer_id": 29621832, "answer_count": 1, "score": 2, "last_activity_date": 1428997637, "creation_date": 1428995726, "last_edit_date": 1428996766, "question_id": 29621305, "link": "https://stackoverflow.com/questions/29621305/moving-a-mutable-trait-object-reference-into-a-box", "title": "Moving a mutable trait object reference into a box", "body": "<p>How do I move a mutable trait object reference into a box? e.g. I'd perhaps expect</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct A {a:i32}\ntrait B {\n    fn dummy(&amp;self) {}\n}\nimpl B for A {}\n\nfn accept_b(x:&amp;mut B) -&gt; Box&lt;B&gt; {\n    Box::new(*x)\n}\n\nfn main() {\n    let mut a = A{a:0};\n    accept_b(&amp;a);\n}\n</code></pre>\n\n<p><sub><sup><a href=\"http://is.gd/VDnoUa\" rel=\"nofollow\">(playpen link)</a></sup></sub></p>\n\n<p>... to work, but instead it errors out as</p>\n\n<pre><code>&lt;anon&gt;:8:5: 8:13 error: the trait `core::marker::Sized` is not implemented for the type `B` [E0277]\n&lt;anon&gt;:8     Box::new(*x)\n             ^~~~~~~~\n&lt;anon&gt;:8:5: 8:13 note: `B` does not have a constant size known at compile-time\n&lt;anon&gt;:8     Box::new(*x)\n             ^~~~~~~~\n&lt;anon&gt;:8:14: 8:16 error: cannot infer an appropriate lifetime due to conflicting requirements\n&lt;anon&gt;:8     Box::new(*x)\n                      ^~\n&lt;anon&gt;:7:33: 9:2 note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the block at 7:32...\n&lt;anon&gt;:7 fn accept_b(x:&amp;mut B) -&gt; Box&lt;B&gt; {\n&lt;anon&gt;:8     Box::new(*x)\n&lt;anon&gt;:9 }\n&lt;anon&gt;:8:14: 8:16 note: ...so that expression is assignable (expected `B`, found `B`)\n&lt;anon&gt;:8     Box::new(*x)\n                      ^~\nnote: but, the lifetime must be valid for the static lifetime...\n&lt;anon&gt;:8:5: 8:17 note: ...so that it can be closed over into an object\n&lt;anon&gt;:8     Box::new(*x)\n             ^~~~~~~~~~~~\n&lt;anon&gt;:13:14: 13:16 error: mismatched types:\n expected `&amp;mut B`,\n    found `&amp;A`\n(values differ in mutability) [E0308]\n&lt;anon&gt;:13     accept_b(&amp;a);\n                       ^~\nerror: aborting due to 3 previous errors\n</code></pre>\n\n<p>... effectively whining that I can't move the trait object into the box. Do I <em>have</em> to put the value in a box <em>first</em>, and then cast that box into a box-of-a-trait later?</p>\n\n<p>Shouldn't the mutability rules transitively ensure that the trait I get in <code>accept_b</code> is the sole owner of the underlying object and thereby support movement into a box? Or does Rust not record the necessary information to provide that nicety? Am I misunderstanding move vs mutable borrow semantics? What's going on?</p>\n"}, {"tags": ["multithreading", "rust"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1429006656, "post_id": 29621088, "comment_id": 47392909, "body": "would you mind posting a smaller example? (something that runs in the [PlayPen](play.rust-lang.org) would of course be the most comfortable solution for answerers)"}, {"owner": {"reputation": 37, "user_id": 2150806, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/51d6210e6a5fe8e4ad4055d633109f43?s=128&d=identicon&r=PG", "display_name": "user2150806", "link": "https://stackoverflow.com/users/2150806/user2150806"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1429059933, "post_id": 29621088, "comment_id": 47421680, "body": "I have kinda given up on this to work  <a href=\"https://github.com/carllerche/eventual/issues/4\" rel=\"nofollow noreferrer\">github.com/carllerche/eventual/issues/4</a>"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1429460700, "creation_date": 1429460700, "answer_id": 29732523, "question_id": 29621088, "link": "https://stackoverflow.com/questions/29621088/what-do-i-wait-or-join-on-when-using-channels-and-threads/29732523#29732523", "title": "What do I wait or join on when using channels and threads?", "body": "<p>This is actually a very complicated question, one with a great potential for race conditions! As I understand it, you:</p>\n\n<ol>\n<li>Have an unbounded queue</li>\n<li>Have a set of workers that operate on the queue items</li>\n<li>The workers can put an <em>unknown</em> amount of items back into the queue</li>\n<li>Want to know when everything is \"done\"</li>\n</ol>\n\n<p>One obvious issue is that it may <strong>never be done</strong>. If every worker puts one item back into the queue, you've got an infinite loop.</p>\n\n<p>That being said, I feel like the solution is to track </p>\n\n<ol>\n<li>How many items are queued</li>\n<li>How many items are in progress</li>\n</ol>\n\n<p>When both of these values are zero, then you are done. Easier said than done...</p>\n\n<pre><code>use std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize,Ordering};\nuse std::sync::mpsc::{channel,TryRecvError};\nuse std::thread;\n\nfn main() {\n    let running_threads = Arc::new(AtomicUsize::new(0));\n    let (tx, rx) = channel();\n\n    // We prime the channel with the first bit of work\n    tx.send(10).unwrap();\n\n    loop {\n        // In an attempt to avoid a race condition, we fetch the\n        // active thread count before checking the channel. Otherwise,\n        // we might read nothing from the channel, and *then* a thread\n        // finishes and added something to the queue.\n        let n_active_threads = running_threads.compare_and_swap(0, 0, Ordering::SeqCst);\n\n        match rx.try_recv() {\n            Ok(id) =&gt; {\n                // I lie a bit and increment the counter to start\n                // with. If we let the thread increment this, we might\n                // read from the channel before the thread ever has a\n                // chance to run!\n                running_threads.fetch_add(1, Ordering::SeqCst);\n\n                let my_tx = tx.clone();\n                let my_running_threads = running_threads.clone();\n\n                // You could use a threadpool, but I'm spawning\n                // threads to only rely on stdlib.\n                thread::spawn(move || {\n                    println!(\"Working on {}\", id);\n\n                    // Simulate work\n                    thread::sleep_ms(100);\n\n                    if id != 0 {\n                        my_tx.send(id - 1).unwrap();\n                        // Send multiple sometimes\n                        if id % 3 == 0 &amp;&amp; id &gt; 2 {\n                            my_tx.send(id - 2).unwrap();\n                        }\n                    }\n\n                    my_running_threads.fetch_sub(1, Ordering::SeqCst);\n                });\n            },\n            Err(TryRecvError::Empty) if n_active_threads == 0 =&gt; break,\n            Err(TryRecvError::Empty) =&gt; {\n                println!(\"Channel is empty, but there are {} threads running\", n_active_threads);\n                // We sleep a bit here, to avoid quickly spinning\n                // through an empty channel while the worker threads\n                // work.\n                thread::sleep_ms(1);\n            },\n            Err(TryRecvError::Disconnected) =&gt; unreachable!(),\n        }\n    }\n}\n</code></pre>\n\n<p>I make no guarantees that this implementation is perfect (I probably <em>should</em> guarantee that it's broken, because threading is hard). One big caveat is that I don't intimately know the meanings of all the variants of <a href=\"http://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html\" rel=\"nofollow\"><code>Ordering</code></a>, so I chose the one that looked to give the strongest guarantees.</p>\n"}], "owner": {"reputation": 37, "user_id": 2150806, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/51d6210e6a5fe8e4ad4055d633109f43?s=128&d=identicon&r=PG", "display_name": "user2150806", "link": "https://stackoverflow.com/users/2150806/user2150806"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 528, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1429558494, "creation_date": 1428994859, "last_edit_date": 1429558494, "question_id": 29621088, "link": "https://stackoverflow.com/questions/29621088/what-do-i-wait-or-join-on-when-using-channels-and-threads", "title": "What do I wait or join on when using channels and threads?", "body": "<p>Here's an example but what should I wait on to decide when it is done. Do we have a better way to wait for the channel to be empty and all the threads to have completed? Full example is at <a href=\"http://github.com/posix4e/rust_webcrawl\" rel=\"nofollow\">http://github.com/posix4e/rust_webcrawl</a></p>\n\n<pre><code>loop {\n    let n_active_threads = running_threads.compare_and_swap(0, 0, Ordering::SeqCst);\n    match rx.try_recv() {\n        Ok(new_site) =&gt; {\n            let new_site_copy = new_site.clone();\n            let tx_copy = tx.clone();\n            counter += 1;\n\n            print!(\"{} \", counter);\n            if !found_urls.contains(&amp;new_site) {\n                found_urls.insert(new_site);\n                running_threads.fetch_add(1, Ordering::SeqCst);\n                let my_running_threads = running_threads.clone();\n                pool.execute(move || {\n                    for new_url in get_websites_helper(new_site_copy) {\n                        if new_url.starts_with(\"http\") {\n                            tx_copy.send(new_url).unwrap();\n                        }\n                    }\n                    my_running_threads.fetch_sub(1, Ordering::SeqCst);\n                });\n            }\n        }\n        Err(TryRecvError::Empty) if n_active_threads == 0 =&gt; break,\n        Err(TryRecvError::Empty) =&gt; {\n             writeln!(&amp;mut std::io::stderr(),\n                \"Channel is empty, but there are {} threads running\",\n                n_active_threads);\n              thread::sleep_ms(10);\n        },\n        Err(TryRecvError::Disconnected) =&gt; unreachable!(),\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 471, "user_id": 1204992, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/7ea79d59662f7180c29da5a1be5a9284?s=128&d=identicon&r=PG", "display_name": "Ferio", "link": "https://stackoverflow.com/users/1204992/ferio"}, "is_accepted": false, "score": 1, "last_activity_date": 1429545253, "creation_date": 1429545253, "answer_id": 29752643, "question_id": 29620969, "link": "https://stackoverflow.com/questions/29620969/how-to-multiplex-on-senders/29752643#29752643", "title": "How to multiplex on senders?", "body": "<p>There are many ways of doing it, I would probably just set up another (async) channel and make the worker threads send their sender back as soon as they are idle\u2026</p>\n\n<pre><code> while let Ok(sender) = sync_senders.recv() {\n    ...\n }\n</code></pre>\n\n<p>But why do you want to do that? Maybe a <a href=\"http://mahkoh.github.io/comm/doc/comm/index.html\" rel=\"nofollow\">multiple-consumer channel</a> fits better for your purpose?</p>\n"}], "owner": {"reputation": 2910, "user_id": 1329147, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/bb27892c2e4adec367d862a16db8389c?s=128&d=identicon&r=PG", "display_name": "Amos", "link": "https://stackoverflow.com/users/1329147/amos"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 191, "favorite_count": 0, "answer_count": 1, "score": 4, "last_activity_date": 1429545253, "creation_date": 1428994476, "question_id": 29620969, "link": "https://stackoverflow.com/questions/29620969/how-to-multiplex-on-senders", "title": "How to multiplex on senders?", "body": "<p>I have a bunch of SyncSenders. I want to get a \"ready to send\" set.</p>\n\n<p>Currently I'm doing this:</p>\n\n<pre><code>for c in data {\n  loop {\n    for tx in sync_senders {\n      if let Ok(_) = tx.try_send(c) {    \n        do something;\n        ...\n      }\n    }\n    until some sends are success, break\n  }\n}  \n</code></pre>\n\n<p>Is there a way to multiplex on SyncSenders, so I can get a ready set of them?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 4, "last_activity_date": 1428984149, "creation_date": 1428984149, "answer_id": 29618960, "question_id": 29618700, "link": "https://stackoverflow.com/questions/29618700/how-to-generate-tuples-from-strings/29618960#29618960", "title": "How to generate tuples from strings?", "body": "<p>A tuple is a heterogeneous collection; each element may be of a different type. And in your example, they <em>are</em> of different types, so each <code>parse</code> method is needing to produce a different type. Therefore pure runtime iteration is right out; you do need all the <code>ws[N].parse().unwrap()</code> statements expanded.</p>\n\n<p>Sadly there is not at present any way of writing out the current iteration of a <code>$(\u2026)*</code> (though it could be simulated with a compiler plugin). There is, however, a way that one can get around that: blending run- and compile-time iteration. We use iterators to pull out the strings, and the macro iteration expansion (ensuring that <code>$t</code> is mentioned inside the <code>$(\u2026)</code> so it knows what to repeat over) to produce the right number of the same lines. This also means we can avoid using an intermediate vector as we are using the iterator directly, so we win all round.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>macro_rules! read_tuple {\n    (\n        $lines:ident, ($($t:ty),*)\n    ) =&gt; {{\n        let l = $lines.next().unwrap();\n        let mut ws = l.trim().split(\" \");\n        (\n            $(ws.next().unwrap().parse::&lt;$t&gt;().unwrap(),)*\n        )\n    }}\n}\n</code></pre>\n\n<p>A minor thing to note is how I changed <code>),*</code> to <code>,)*</code>; this means that you will get <code>()</code>, <code>(1,)</code>, <code>(1, 2,)</code>, <code>(1, 2, 3,)</code>, &amp;c. instead of <code>()</code>, <code>(1)</code>, <code>(1, 2)</code>, <code>(1, 2, 3)</code>\u2014the key difference being that a single-element tuple will work (though you\u2019ll still sadly be writing <code>read_tuple!(lines, (T))</code>).</p>\n"}], "owner": {"reputation": 95, "user_id": 1510870, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3e95a16f622331110642ea65f3f3e848?s=128&d=identicon&r=PG", "display_name": "Mark M", "link": "https://stackoverflow.com/users/1510870/mark-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2362, "favorite_count": 0, "accepted_answer_id": 29618960, "answer_count": 1, "score": 4, "last_activity_date": 1429018536, "creation_date": 1428982410, "last_edit_date": 1429018536, "question_id": 29618700, "link": "https://stackoverflow.com/questions/29618700/how-to-generate-tuples-from-strings", "title": "How to generate tuples from strings?", "body": "<p>I am writing a macro to parse some structured text into tuples, line by line. Most parts work now, but I am stuck at forming a tuple by extracting/converting Strings from a vector. </p>\n\n<pre><code>// Reading Tuple from a line\n// Example : read_tuple( \"1 ab 3\".lines()\n//                      ,(i32, String, i32))\n//  Expected :  (1, \"ab\", 3)\n// Note:: you can note use str\nmacro_rules! read_tuple {\n      (\n        $lines :ident , ( $( $t :ty ),* )\n      )\n        =&gt; {{\n            let l = ($lines).next().unwrap();\n            let  ws = l.trim().split(\" \").collect::&lt;Vec&lt;_&gt;&gt;();\n            let  s : ( $($t),*  ) = (\n                // for w in ws {\n                //     let p =  w.parse().unwrap();\n                //   ( p) ,\n                // }\n                ws[0].parse().unwrap(),\n                ws[1].parse().unwrap(),\n                //...\n                ws[2].parse().unwrap(),\n                // Or any way to automatically generate these statments?\n                );\n            s\n        }}\n}\n\nfn main() {\n    let mut _x = \"1 ab 3\".lines();\n    let a  = read_tuple!( _x, (i32, String, i32));\n\n    print!(\"{:?}\",a);\n}\n</code></pre>\n\n<p>How can I iterate through <code>ws</code> and return the tuple within this macro? \nYou can <a href=\"http://is.gd/XAvqrS\" rel=\"nofollow\">try here</a></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 1, "creation_date": 1428973977, "post_id": 29617389, "comment_id": 47379979, "body": "<code>router!</code> is sugar that expands to a function (<a href=\"https://github.com/nickel-org/nickel.rs/blob/master/src/macros.rs\" rel=\"nofollow noreferrer\">github.com/nickel-org/nickel.rs/blob/master/src/macros.rs</a>). A function cannot close over variables, nor will this approach work. Bear in mind how it may be multi-threaded; at the very least you will need to use some form of mutex to get it to work."}, {"owner": {"reputation": 11942, "user_id": 680786, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/6a2e4d0cd85ad3232f525a333ea3c971?s=128&d=identicon&r=PG", "display_name": "OZ_", "link": "https://stackoverflow.com/users/680786/oz"}, "reply_to_user": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 1, "creation_date": 1428977151, "post_id": 29617389, "comment_id": 47380811, "body": "@ChrisMorgan as I said, this code, without task_id, works fine: <a href=\"https://gist.github.com/jamm/d067307206c8420c7388\" rel=\"nofollow noreferrer\">gist.github.com/jamm/d067307206c8420c7388</a>, &quot;nor will this approach work&quot; is a wrong statement. &quot;at the very least you will need to use some form of mutex to get it to work&quot; - I don&#39;t change task_id inside spawned functions, so I don&#39;t need mutex."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1429000510, "post_id": 29617389, "comment_id": 47389118, "body": "@OZ_: you misunderstood I think, the point of Chris is that the function created by <code>router!</code> changes <code>task_id</code>, and this function might be called from multiple threads (as far as the Rust compiler knows), so even if it could close over variables (which it cannot) you would need some form of synchronization."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 4, "last_activity_date": 1428978821, "creation_date": 1428978821, "answer_id": 29618235, "question_id": 29617389, "link": "https://stackoverflow.com/questions/29617389/cant-capture-dynamic-environment-in-a-fn-item/29618235#29618235", "title": "Can&#39;t capture dynamic environment in a fn item", "body": "<p>To expand on Chris Morgan's answer, this is a self-contained example with the same error:</p>\n\n<pre><code>fn main() {\n    let mut a = 0;\n    fn router() {\n        a += 1;\n    }\n    router();\n    println!(\"{}\", a)\n}\n</code></pre>\n\n<p>The problem is that <code>fn</code> items are <em>not allowed to capture their environment</em>, period. Capturing environment is non-trivial, and there are multiple ways to get variables into a closure. Closures are actually structs with the appropriate member variables for each captured variable. </p>\n\n<p>Review Chris Morgan's statement:</p>\n\n<blockquote>\n  <p>Bear in mind how it <strong>may</strong> be multi-threaded; at the very least you will need to use some form of mutex to get it to work. </p>\n</blockquote>\n\n<p>(Emphasis mine). You are creating a function, but you <em>don't get to control how or when it is called</em>. For all you know, Nickel may choose to call it from multiple threads - that's up to the library. As it is, <strong>you</strong> do not ever call the code <code>task_id += 1</code>!</p>\n\n<p>I'm no expert on Nickel, but it appears that having dynamic routing is not possible with the code you've posted. However, it should be possible for you to avoid using the macro and <a href=\"https://github.com/nickel-org/nickel.rs/blob/8c07dd712883029df4c2fb813bc2deea668daaa9/src/nickel.rs#L60-L62\" rel=\"nofollow\">construct a handler yourself</a>, you \"just\" need to implement <a href=\"http://docs.nickel.rs/nickel/trait.Middleware.html\" rel=\"nofollow\"><code>Middleware</code></a>. That handler may be able to contain state, like your <code>task_id</code>.</p>\n"}], "owner": {"reputation": 11942, "user_id": 680786, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/6a2e4d0cd85ad3232f525a333ea3c971?s=128&d=identicon&r=PG", "display_name": "OZ_", "link": "https://stackoverflow.com/users/680786/oz"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1968, "favorite_count": 0, "answer_count": 1, "score": 3, "last_activity_date": 1428978821, "creation_date": 1428972386, "question_id": 29617389, "link": "https://stackoverflow.com/questions/29617389/cant-capture-dynamic-environment-in-a-fn-item", "title": "Can&#39;t capture dynamic environment in a fn item", "body": "<p>In this code everything works except <code>task_id</code>. I want this script to count requests in <code>task_id</code>:</p>\n\n<pre><code>use std::thread;\nuse std::thread::sleep_ms;\nuse std::sync::mpsc;\n#[macro_use] extern crate nickel;\nuse nickel::Nickel;\n\nfn main() {\n    let mut server = Nickel::new();\n    let mut task_id: i64 = 0;\n\n    server.utilize(router! {\n        get \"**\" =&gt; |_req, _res| {\n            task_id += 1;\n            run_heavy_task(task_id);\n            \"Yo!\"\n        }\n    });\n\n    server.listen(\"127.0.0.1:6767\");\n}\n\nfn run_heavy_task(task_id: i64) {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        println!(\"heavy task {} started!\", task_id);\n        sleep_ms(3000);\n        println!(\"heavy task {} completed\", task_id);\n        let result = tx.send(());\n    });\n\n\n    //rx.recv();\n    //println!(\"Task {} completed\", task_id);\n}\n</code></pre>\n\n<p>error:</p>\n\n<blockquote>\n  <p>can't capture dynamic environment in a fn item; use the || { ... }\n  closure form instead main.rs:13             task_id += 1;</p>\n</blockquote>\n\n<p>Please help me solve this issue - how can I pass task_id into closure?</p>\n"}, {"tags": ["rust", "boxing"], "answers": [{"comments": [{"owner": {"reputation": 550, "user_id": 2683311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6d2d92cece6a6eea6769ea1df88fb786?s=128&d=identicon&r=PG&f=1", "display_name": "Sergii Bogomolov", "link": "https://stackoverflow.com/users/2683311/sergii-bogomolov"}, "edited": false, "score": 0, "creation_date": 1428998095, "post_id": 29616086, "comment_id": 47387778, "body": "That&#39;s exactly what I wanted to know. As always, its RTFM problem :)"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 550, "user_id": 2683311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6d2d92cece6a6eea6769ea1df88fb786?s=128&d=identicon&r=PG&f=1", "display_name": "Sergii Bogomolov", "link": "https://stackoverflow.com/users/2683311/sergii-bogomolov"}, "edited": false, "score": 1, "creation_date": 1428999941, "post_id": 29616086, "comment_id": 47388782, "body": "@SergiiBogomolov: Don&#39;t feel bad about it, it takes time to learn to navigate new documentation (especially when it keeps changing)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 550, "user_id": 2683311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6d2d92cece6a6eea6769ea1df88fb786?s=128&d=identicon&r=PG&f=1", "display_name": "Sergii Bogomolov", "link": "https://stackoverflow.com/users/2683311/sergii-bogomolov"}, "edited": false, "score": 3, "creation_date": 1429018995, "post_id": 29616086, "comment_id": 47400793, "body": "@SergiiBogomolov to clarify - the compiler <i>can</i> optimize this case (as described in my answer) <b>if</b> the &quot;stack-allocated&quot; value is immediately moved to the <code>Box</code>. It does not optimize if the value is used before being moved to the <code>Box</code>."}], "tags": [], "owner": {"reputation": 1105, "user_id": 575229, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d6d6d34880c5ad7ca699b4311517edf?s=128&d=identicon&r=PG", "display_name": "Miles Rout", "link": "https://stackoverflow.com/users/575229/miles-rout"}, "is_accepted": false, "score": 3, "last_activity_date": 1428963846, "creation_date": 1428963846, "answer_id": 29616086, "question_id": 29615904, "link": "https://stackoverflow.com/questions/29615904/what-happens-when-a-stack-allocated-value-is-boxed/29616086#29616086", "title": "What happens when a stack-allocated value is boxed?", "body": "<p>As explained in the official Rust documentation <a href=\"https://doc.rust-lang.org/std/boxed/struct.Box.html\" rel=\"nofollow\">here</a>, <code>Box&lt;T&gt;::new(x: T)</code> allocates memory on the heap and then <em>moves</em> the argument into that memory. Accessing <code>a</code> after <code>let b = Box::new(a)</code> is a compile-time error.</p>\n"}, {"comments": [{"owner": {"reputation": 550, "user_id": 2683311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6d2d92cece6a6eea6769ea1df88fb786?s=128&d=identicon&r=PG&f=1", "display_name": "Sergii Bogomolov", "link": "https://stackoverflow.com/users/2683311/sergii-bogomolov"}, "edited": false, "score": 0, "creation_date": 1428998195, "post_id": 29617168, "comment_id": 47387822, "body": "Thank you for the detailed answer and a link. I thought that there is no need to read that &quot;Unstable&quot; part of the Rust book. I was wrong."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1428970972, "creation_date": 1428970972, "answer_id": 29617168, "question_id": 29615904, "link": "https://stackoverflow.com/questions/29615904/what-happens-when-a-stack-allocated-value-is-boxed/29617168#29617168", "title": "What happens when a stack-allocated value is boxed?", "body": "<p>It would be pretty strange for this optimization to happen as you describe it. For example, in this code:</p>\n\n<pre><code>let a = Foo { x: 1 };\n// operation that observes a\nlet b = Box::new(a);\n// operation that observes b\n</code></pre>\n\n<p><code>&amp;a</code> and <code>&amp;b</code> would be <em>equal</em>, which would be surprising. However, if you do something similar, but don't observe <code>a</code>:</p>\n\n<pre><code>#[inline(never)]\nfn frobnotz() -&gt; Box&lt;Foo&gt; {\n    let a = Foo { x: 1 };\n    Box::new(a)\n}\n</code></pre>\n\n<p>You can <a href=\"http://is.gd/sFUdyW\" rel=\"nofollow\">see via the LLVM IR</a> that this case <em>was</em> optimized:</p>\n\n<pre><code>define internal fastcc noalias dereferenceable(4) %Foo* @_ZN8frobnotz20h3dca7bc0ee8400bciaaE() unnamed_addr #0 {\nentry-block:\n  %0 = tail call i8* @je_mallocx(i64 4, i32 0)\n  %1 = icmp eq i8* %0, null\n  br i1 %1, label %then-block-106-.i.i, label %\"_ZN5boxed12Box$LT$T$GT$3new20h2665038481379993400E.exit\"\n\nthen-block-106-.i.i:                              ; preds = %entry-block\n  tail call void @_ZN3oom20he7076b57c17ed7c6HYaE()\n  unreachable\n\n\"_ZN5boxed12Box$LT$T$GT$3new20h2665038481379993400E.exit\": ; preds = %entry-block\n  %2 = bitcast i8* %0 to %Foo*\n  %x.sroa.0.0..sroa_idx.i = bitcast i8* %0 to i32*\n  store i32 1, i32* %x.sroa.0.0..sroa_idx.i, align 4\n  ret %Foo* %2\n}\n</code></pre>\n\n<p>Similarly, you can return the struct on the stack and then box it up, and there will still <a href=\"http://doc.rust-lang.org/book/box-syntax-and-patterns.html#returning-pointers\" rel=\"nofollow\">just be the one allocation</a>:</p>\n\n<blockquote>\n  <p>You may think that this gives us terrible performance: return a value and then immediately box it up ?! Isn't this pattern the worst of both worlds? Rust is smarter than that. There is no copy in this code. main allocates enough room for the box, passes a pointer to that memory into foo as x, and then foo writes the value straight into the Box.</p>\n</blockquote>\n"}], "owner": {"reputation": 550, "user_id": 2683311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6d2d92cece6a6eea6769ea1df88fb786?s=128&d=identicon&r=PG&f=1", "display_name": "Sergii Bogomolov", "link": "https://stackoverflow.com/users/2683311/sergii-bogomolov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 619, "favorite_count": 0, "accepted_answer_id": 29617168, "answer_count": 2, "score": 7, "last_activity_date": 1428970972, "creation_date": 1428962853, "last_edit_date": 1428963259, "question_id": 29615904, "link": "https://stackoverflow.com/questions/29615904/what-happens-when-a-stack-allocated-value-is-boxed", "title": "What happens when a stack-allocated value is boxed?", "body": "<p>If we have a value that is already allocated on stack, will boxing copy it to heap and then transfer ownership (that's how it works in .NET, with the exception that both copies will stay alive)? Or will the compiler be \"smart\" enough to allocate it directly on heap from the beginning?</p>\n\n<pre><code>struct Foo {\n    x: i32,\n}\n\nfn main() {\n    // a is allocated on stack?\n    let a = Foo { x: 1 };\n\n    // if a is not used, it will be optimized out\n    println!(\"{}\", a.x);\n\n    // what happens here? will the stack allocated structure\n    // be moved to heap? or was it originally allocated on heap?\n    let b = Box::new(a);\n}\n</code></pre>\n\n<p>I'm not a specialist in assembler, but this looks like it is actually allocated on stack and then moved: <a href=\"http://pastebin.com/8PzsgTJ1\" rel=\"noreferrer\">http://pastebin.com/8PzsgTJ1</a>. But I need a confirmation from someone who actually knows what is happening.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 74, "last_activity_date": 1573571958, "last_edit_date": 1573571958, "creation_date": 1428947249, "answer_id": 29611728, "question_id": 29611387, "link": "https://stackoverflow.com/questions/29611387/why-does-the-println-function-use-an-exclamation-mark-in-rust/29611728#29611728", "title": "Why does the println! function use an exclamation mark in Rust?", "body": "<p><a href=\"https://doc.rust-lang.org/std/macro.println.html\" rel=\"noreferrer\"><code>println!</code></a> is not a function, it is a <em>macro</em>. Macros use <code>!</code> to distinguish them from normal method calls. <a href=\"https://doc.rust-lang.org/book/ch19-06-macros.html\" rel=\"noreferrer\">The documentation</a> contains more information.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/29871967/155423\">What is the difference between macros and functions in Rust?</a></li>\n</ul>\n\n<hr>\n\n<p>Rust uses the <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" rel=\"noreferrer\"><code>Option</code></a> type to denote optional data. It has an <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap\" rel=\"noreferrer\"><code>unwrap</code></a> method.</p>\n\n<p>Rust 1.13 added the question mark operator <code>?</code> as an analog of the <code>try!</code> macro (originally proposed via <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md\" rel=\"noreferrer\">RFC 243</a>).</p>\n\n<p>An excellent explanation of the question mark operator is in <a href=\"https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\" rel=\"noreferrer\"><em>The Rust Programming Language</em></a>. </p>\n\n<pre><code>fn foo() -&gt; Result&lt;i32, Error&gt; {\n    Ok(4)\n}\n\nfn bar() -&gt; Result&lt;i32, Error&gt; {\n    let a = foo()?;\n    Ok(a + 4)\n}\n</code></pre>\n\n<p>The question mark operator also <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md#generalize-over-result-option-and-other-result-carrying-types\" rel=\"noreferrer\">extends to <code>Option</code></a>, so you may see it used to unwrap a value or return <code>None</code> from the function. This is different from just unwrapping as the program will not panic:</p>\n\n<pre><code>fn foo() -&gt; Option&lt;i32&gt; {\n    None\n}\n\nfn bar() -&gt; Option&lt;i32&gt; {\n    let a = foo()?;\n    Some(a + 4)\n}\n</code></pre>\n"}], "owner": {"reputation": 7500, "user_id": 3705470, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/dc959e9364c4d87d9bb5ed57a558fc5d?s=128&d=identicon&r=PG&f=1", "display_name": "Ch&#233;yo", "link": "https://stackoverflow.com/users/3705470/ch%c3%a9yo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 16463, "favorite_count": 5, "accepted_answer_id": 29611728, "answer_count": 1, "score": 66, "last_activity_date": 1573571958, "creation_date": 1428946061, "last_edit_date": 1429108073, "question_id": 29611387, "link": "https://stackoverflow.com/questions/29611387/why-does-the-println-function-use-an-exclamation-mark-in-rust", "title": "Why does the println! function use an exclamation mark in Rust?", "body": "<p>In Swift, <code>!</code> means to unwrap an optional (possible value).</p>\n"}, {"tags": ["multithreading", "rust"], "comments": [{"owner": {"reputation": 14973, "user_id": 128186, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/46c330659979615fe50c46f5f553b39f?s=128&d=identicon&r=PG", "display_name": "Arjan", "link": "https://stackoverflow.com/users/128186/arjan"}, "edited": false, "score": 0, "creation_date": 1428938166, "post_id": 29608798, "comment_id": 47363391, "body": "rust threads are native threads for quite some time now. You don&#39;t have to do anything to use all the cores."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1428938556, "post_id": 29608798, "comment_id": 47363678, "body": "This is asking two <b>very</b> different questions. You should split them apart. Actually, it&#39;s 3 (&quot;use all cores&quot;, <code>RTRACEMAXPROCS</code> and &quot;800K threads&quot;)."}], "answers": [{"tags": [], "owner": {"reputation": 16564, "user_id": 1261399, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/679444399bbf92e3a5d3f16347809f3f?s=128&d=identicon&r=PG", "display_name": "Leo Correa", "link": "https://stackoverflow.com/users/1261399/leo-correa"}, "is_accepted": false, "score": 0, "last_activity_date": 1428938247, "creation_date": 1428938247, "answer_id": 29608977, "question_id": 29608798, "link": "https://stackoverflow.com/questions/29608798/how-do-i-use-all-processor-cores-during-execution/29608977#29608977", "title": "How do I use all processor cores during execution?", "body": "<p>From looking at the code of your source <code>RTRACEMAXPROCS</code> is not actually part of Rust but of the program being used in the example. </p>\n\n<p><a href=\"https://github.com/Byron/rust-tracer/blob/5f6008c6b3c97471d965ed3113be0b7d6800b289/src/rust/main.rs#L46-L53\" rel=\"nofollow\">https://github.com/Byron/rust-tracer/blob/5f6008c6b3c97471d965ed3113be0b7d6800b289/src/rust/main.rs#L46-L53</a></p>\n\n<p>The author is simply using that environment variable to create a thread pool of a specified size. </p>\n\n<p>So short answer is No, <code>RTRACEMAXPROCS</code> and <code>GOMAXPROCS</code> are not the same thing. </p>\n"}, {"comments": [{"owner": {"reputation": 16564, "user_id": 1261399, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/679444399bbf92e3a5d3f16347809f3f?s=128&d=identicon&r=PG", "display_name": "Leo Correa", "link": "https://stackoverflow.com/users/1261399/leo-correa"}, "edited": false, "score": 0, "creation_date": 1428938583, "post_id": 29609007, "comment_id": 47363697, "body": "I don&#39;t think the term <code>green threads</code> apply to Go since by definition, green threads are scheduled by a virtual machine. Go doesn&#39;t run on a VM."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 16564, "user_id": 1261399, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/679444399bbf92e3a5d3f16347809f3f?s=128&d=identicon&r=PG", "display_name": "Leo Correa", "link": "https://stackoverflow.com/users/1261399/leo-correa"}, "edited": false, "score": 0, "creation_date": 1428938853, "post_id": 29609007, "comment_id": 47363918, "body": "@LeoCorrea The Wikipedia definition contrasts &quot;scheduled by a VM&quot; with &quot;scheduled natively by the OS&quot;, so it can&#39;t mean VM in the traditional sense (and indeed the very same article lists Go as a language with green threads). I and most people I&#39;ve talked to refer to most thread-like abstractions that are not managed by the OS as green threads."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 16564, "user_id": 1261399, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/679444399bbf92e3a5d3f16347809f3f?s=128&d=identicon&r=PG", "display_name": "Leo Correa", "link": "https://stackoverflow.com/users/1261399/leo-correa"}, "edited": false, "score": 2, "creation_date": 1428941657, "post_id": 29609007, "comment_id": 47365735, "body": "@LeoCorrea, I think it is more correct to say that green threads are scheduled by runtime, not by a VM. &quot;VMs&quot; is a strict subset of &quot;runtimes&quot;, and Go <i>does</i> have a runtime, as did Rust not so long ago."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1428941945, "post_id": 29609007, "comment_id": 47365880, "body": "@VladimirMatveev Like many things &quot;has a runtime&quot; is a continuum and somewhat fuzzy. Current Rust still has infrastructure that could be called a runtime, just like C and C++ (assuming default configuration for all three). But yeah, it&#39;s much smaller and simpler and passive than Go&#39;s, or most languages&#39;."}], "tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "is_accepted": true, "score": 4, "last_activity_date": 1428938317, "creation_date": 1428938317, "answer_id": 29609007, "question_id": 29608798, "link": "https://stackoverflow.com/questions/29608798/how-do-i-use-all-processor-cores-during-execution/29609007#29609007", "title": "How do I use all processor cores during execution?", "body": "<p>Rust doesn't have green threads any more. Every \"task\" you spawn maps to exactly one real OS thread (which is why the task terminology has fallen out of favor completely). An equivalent of <code>GOMAXPROCS</code> doesn't make sense.</p>\n\n<p>As for the second part of your question: 800K threads is ludicrous. It might work, but don't expect it to work nearly as well as Go's or Erlang's green threads. In particular, each thread reserves a couple of megabytes of address space and <em>at least</em> 4 KiB physical memory, plus whatever resources the OS needs for the thread (not a lot, I've been told). The \"spawn concurrent workers for every little thing\" paradigm is not very well supported.</p>\n"}], "owner": {"reputation": 213, "user_id": 2422492, "user_type": "registered", "accept_rate": 57, "profile_image": "https://i.stack.imgur.com/IC81j.jpg?s=128&g=1", "display_name": "Tigran Bayburtsyan", "link": "https://stackoverflow.com/users/2422492/tigran-bayburtsyan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1048, "favorite_count": 1, "accepted_answer_id": 29609007, "answer_count": 2, "score": 3, "last_activity_date": 1428938533, "creation_date": 1428937766, "last_edit_date": 1428938533, "question_id": 29608798, "link": "https://stackoverflow.com/questions/29608798/how-do-i-use-all-processor-cores-during-execution", "title": "How do I use all processor cores during execution?", "body": "<p>I'm writing a threaded program in <a href=\"http://rust-lang.org\" rel=\"nofollow\">Rust</a>.</p>\n\n<p><a href=\"http://golang.org\" rel=\"nofollow\">Go</a> has an environment variable <code>GOMAXPROCS</code> which is used by the Go compiler to use the maximum amount of processor cores during execution. I found the <code>RTRACEMAXPROCS</code> parameter <a href=\"https://github.com/Byron/rust-tracer/blob/5d064030f9716dcb2dd24f1091d1de09d225d19b/README.md\" rel=\"nofollow\">here</a> after many searches, but I can't find any documentation for this.</p>\n\n<p>Is the <code>RTRACEMAXPROCS</code> parameter the same as <code>GOMAXPROCS</code> for Rust?</p>\n\n<p>Is it good practice to use over 800K threads in single process or should I use multiple processes?</p>\n"}, {"tags": ["rust", "nickel"], "comments": [{"owner": {"reputation": 21581, "user_id": 288703, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/1bb69b75c5e73a7c9f4ebbc4835d622f?s=128&d=identicon&r=PG", "display_name": "Christoph", "link": "https://stackoverflow.com/users/288703/christoph"}, "edited": false, "score": 1, "creation_date": 1428931557, "post_id": 29606202, "comment_id": 47358492, "body": "I work on the nickel team. I&#39;m sorry you had such a bad first experience. The examples are out of date and I&#39;m trying to get that fixed soon. However, the problem that you ran into seems to be a real bug in either hyper or rust itself I think. I created an issue to track it:  <a href=\"https://github.com/nickel-org/nickel.rs/issues/185\" rel=\"nofollow noreferrer\">github.com/nickel-org/nickel.rs/issues/185</a>"}, {"owner": {"reputation": 2100, "user_id": 977203, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/c8c527cc87ad1dd9a851ad19d62a80c8?s=128&d=identicon&r=PG", "display_name": "robabby", "link": "https://stackoverflow.com/users/977203/robabby"}, "reply_to_user": {"reputation": 21581, "user_id": 288703, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/1bb69b75c5e73a7c9f4ebbc4835d622f?s=128&d=identicon&r=PG", "display_name": "Christoph", "link": "https://stackoverflow.com/users/288703/christoph"}, "edited": false, "score": 0, "creation_date": 1428932415, "post_id": 29606202, "comment_id": 47359157, "body": "@Christoph Yay, I helped find a bug! :)  Thanks for following up with me, and for logging the issue.  I look forward to a resolution.  I just checked the Nickel GitHub page as well and it looks like the current build is failing, also."}], "answers": [{"comments": [{"owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "edited": false, "score": 0, "creation_date": 1429274509, "post_id": 29606975, "comment_id": 47534827, "body": "I think that <a href=\"https://github.com/rust-lang/rust/issues/24374\" rel=\"nofollow noreferrer\">PR #24374</a> may be related..."}], "tags": [], "owner": {"reputation": 21581, "user_id": 288703, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/1bb69b75c5e73a7c9f4ebbc4835d622f?s=128&d=identicon&r=PG", "display_name": "Christoph", "link": "https://stackoverflow.com/users/288703/christoph"}, "is_accepted": true, "score": 4, "last_activity_date": 1428940462, "last_edit_date": 1428940462, "creation_date": 1428932944, "answer_id": 29606975, "question_id": 29606202, "link": "https://stackoverflow.com/questions/29606202/rust-nickel-hello-world-tutorial-throwing-dependency-error-when-run/29606975#29606975", "title": "Rust Nickel Hello World tutorial throwing dependency error when run", "body": "<p>The <code>arithmetic operation overflowed</code> bug seems to be an upstream issue. It also affects hyper which nickel depends on. </p>\n\n<p>See <a href=\"https://github.com/seanmonstar/num_cpus/issues/2\" rel=\"nofollow\">https://github.com/seanmonstar/num_cpus/issues/2</a></p>\n\n<p>As a temporary workaround use <code>cargo build --release</code> to prevent the checks altogether. </p>\n"}], "owner": {"reputation": 2100, "user_id": 977203, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/c8c527cc87ad1dd9a851ad19d62a80c8?s=128&d=identicon&r=PG", "display_name": "robabby", "link": "https://stackoverflow.com/users/977203/robabby"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 437, "favorite_count": 0, "accepted_answer_id": 29606975, "answer_count": 1, "score": 1, "last_activity_date": 1475213725, "creation_date": 1428930737, "last_edit_date": 1475213725, "question_id": 29606202, "link": "https://stackoverflow.com/questions/29606202/rust-nickel-hello-world-tutorial-throwing-dependency-error-when-run", "title": "Rust Nickel Hello World tutorial throwing dependency error when run", "body": "<p>I am learning Rust, and saw a post on <a href=\"http://www.reddit.com/r/rust/comments/32dhwb/nickel_is_on_cratesio/\" rel=\"nofollow\">http://reddit.com/r/rust</a> yesterday for <a href=\"https://crates.io/crates/nickel\" rel=\"nofollow\">Nickel</a>.  As a Node.js developer in my free time, I was interested in checking this out.</p>\n\n<p>I downloaded the Rust 1.0.0-beta DMG from <a href=\"http://rust-lang.org\" rel=\"nofollow\">http://rust-lang.org</a>.</p>\n\n<p>I followed the <a href=\"http://nickel.rs/getting-started.html\" rel=\"nofollow\">Hello World</a> tutorial precisely, and when I execute <code>cargo run</code> in my Terminal, I am receiving the following error:</p>\n\n<pre><code>Robs-MacBook-Pro:nickel-demo rob$ cargo run\n   Compiling nickel-demo v0.0.1 (file:///Users/rob/Workbench/nickel-demo)\nsrc/main.rs:4:1: 4:21 error: an external crate named `nickel` has already been imported into this module [E0259]\nsrc/main.rs:4 extern crate nickel;\n              ^~~~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\nCould not compile `nickel-demo`.\n</code></pre>\n\n<p>The Hello World <code>main.rs</code> file for the Nickel Demo looks like this:</p>\n\n<pre><code>extern crate nickel;\n\n#[macro_use] extern crate nickel_macros;\nextern crate nickel;\n\nuse nickel::Nickel;\n\nfn main() {\n    let mut server = Nickel::new();\n\n    server.utilize(router! {\n        get \"**\" =&gt; |_req, _res| {\n            \"Hello world!\"\n        }\n    });\n\n    server.listen(\"127.0.0.1:6767\");\n}\n</code></pre>\n\n<p>As I was typing this code into my editor, I specifically thought it was weird that I was declaring <code>extern crate nickel;</code> twice in the file.  After receiving the error I refactored the code to this:</p>\n\n<pre><code>extern crate nickel;\n\n#[macro_use] extern crate nickel_macros;\n\nuse nickel::Nickel;\n\n...\n</code></pre>\n\n<p>And I get this error:</p>\n\n<pre><code>Robs-MacBook-Pro:nickel-demo rob$ cargo run\n   Compiling nickel-demo v0.0.1 (file:///Users/rob/Workbench/nickel-demo)\n     Running `target/debug/nickel-demo`\nListening on http://127.0.0.1:6767\nCtrl-C to shutdown server\nthread '&lt;main&gt;' panicked at 'arithmetic operation overflowed', /Users/rob/.cargo/registry/src/github.com-1ecc6299db9ec823/hyper-0.3.11/src/server/mod.rs:90\nAn unknown error occurred\n</code></pre>\n"}, {"tags": ["rust", "lifetime", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 39993, "user_id": 146622, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/5240a4744cdf2fffb8bd36c0649fcab4?s=128&d=identicon&r=PG", "display_name": "Daniel A.A. Pelsmaeker", "link": "https://stackoverflow.com/users/146622/daniel-a-a-pelsmaeker"}, "edited": false, "score": 0, "creation_date": 1428933157, "post_id": 29606725, "comment_id": 47359637, "body": "This is great, thank you! I didn&#39;t know about the trait lifetime and had tried <code>pub fn foo&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; &amp;&#39;a mut Box&lt;Foo&gt;</code> to no avail. How can I require a type implementing <code>Foo</code> to be <code>&#39;static</code>? I tried <code>trait Foo&lt;&#39;static&gt;</code> but that doesn&#39;t work."}, {"owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "edited": false, "score": 0, "creation_date": 1428933641, "post_id": 29606725, "comment_id": 47359962, "body": "Maybe a better alternative to forcing <code>&#39;static</code> would be to add a lifetime parameter to <code>Bar</code>: <code>pub struct Bar&lt;&#39;f&gt; { foo: Option&lt;Box&lt;Foo+&#39;f&gt;&gt; }</code>."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "edited": false, "score": 0, "creation_date": 1428937296, "post_id": 29606725, "comment_id": 47362762, "body": "@rodrigo: it all depends on what you want and need. Adding a lifetime parameter is strictly superior for what it allows you to do, but if you don&#39;t need that ability its slight increase in verbosity should be avoided. I imagine that most cases will be fine with <code>&#39;static</code>."}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 11, "last_activity_date": 1428932566, "last_edit_date": 1428932566, "creation_date": 1428932232, "answer_id": 29606725, "question_id": 29606017, "link": "https://stackoverflow.com/questions/29606017/as-mut-unwrap-cannot-infer-lifetime-due-to-conflicting-requirements/29606725#29606725", "title": "as_mut().unwrap(): Cannot infer lifetime due to conflicting requirements", "body": "<p>This is a case of lifetime elision and the default object bounds backfiring in a painfully invisible way.</p>\n\n<p>The errors are downright opaque as it is, which is not good. If you replace the <code>.as_mut().unwrap()</code> with the comparable <code>match</code> statement:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>match self.foo {\n    Some(ref mut foo) =&gt; foo,\n    None =&gt; panic!(),\n}\n</code></pre>\n\n<p>things become a little clearer:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>a.rs:13:34: 13:37 error: mismatched types:\n expected `&amp;mut Box&lt;Foo&gt;`,\n    found `&amp;mut Box&lt;Foo&gt;`\n(lifetime mismatch) [E0308]\na.rs:13             Some(ref mut foo) =&gt; foo,\n                                         ^~~\na.rs:11:44: 16:6 note: the anonymous lifetime #1 defined on the block at 11:43...\na.rs:11     pub fn foo(&amp;mut self) -&gt; &amp;mut Box&lt;Foo&gt; {\na.rs:12         match self.foo {\na.rs:13             Some(ref mut foo) =&gt; foo,\na.rs:14             None =&gt; panic!(),\na.rs:15         }\na.rs:16     }\nnote: ...does not necessarily outlive the static lifetime\nerror: aborting due to previous error\n</code></pre>\n\n<p>Now we know that what is happening is a lifetime mismatch in somewhere in the type <code>&amp;mut Box&lt;Foo&gt;</code>, that an anonymous lifetime does not necessarily outlive the static lifetime. There are two lifetimes in that type; with no type elision, that type is <code>&amp;'a mut Box&lt;Foo + 'b&gt;</code>. Remember that with a trait object, you still need to indicate how long the trait object can last for, hence <code>'b</code>. In the most common case, <code>Box&lt;Trait&gt;</code> is equivalent to <code>Box&lt;Trait + 'static&gt;</code>, which indicates that the trait object cannot contain any non-static references. (Without this guarantee, memory safety would be violated.) In your struct definition, the lifetime of the trait object is inferred as <code>'static</code> in this manner.</p>\n\n<p>However, the elided lifetime in <code>Box&lt;Trait&gt;</code> is not always interpreted as <code>'static</code>. If it is contained in a reference, then the required lifetime is shrunk to that, i.e. <code>&amp;'a Box&lt;Trait&gt;</code> is interpreted as <code>&amp;'a Box&lt;Trait + 'a&gt;</code>.</p>\n\n<p>Therefore, the full elision-free signature of your method is actually this:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub fn foo&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut Box&lt;Foo + 'a&gt;;\n</code></pre>\n\n<p>Now why this doesn\u2019t work I\u2019m not clear on; I would have thought that a <code>&amp;'a mut Box&lt;Foo + 'static&gt;</code> (which you have) could be coerced to a <code>&amp;'a mut Box&lt;Foo + 'a&gt;</code>, but apparently this is not the case; it <em>might</em> be a bug in variance handling (rejecting code that should be legal) or it might not be, I\u2019m not sure. I don\u2019t see why the anonymous lifetime #1 should be needing to outlive the static lifetime, that error feels like it\u2019s handling the lifetimes back to front.</p>\n\n<p>Anyway, what you actually wanted was to be returning a <code>&amp;'a mut Box&lt;Foo + 'static&gt;</code>. So just write the <code>'static</code> out explicitly and all is hunky\u2010dory:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub fn foo(&amp;mut self) -&gt; &amp;mut Box&lt;Foo + 'static&gt; {\n    self.foo.as_mut().unwrap()\n}\n</code></pre>\n\n<p>Another solution is to require in the definition that a type implementing <code>Foo</code> must always be <code>'static</code>. Then <code>Box&lt;Foo + 'a&gt;</code> would be obvious nonsense for an <code>'a</code> not necessarily as great as <code>'static</code>, and it gets sensible and knows that it\u2019s got to be <code>'static</code>. (Any lifetime constraint on the trait overrides the default object bounds.)</p>\n\n<p>You can read more about the default object bounds in <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md\">RFC 599</a>.</p>\n"}], "owner": {"reputation": 39993, "user_id": 146622, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/5240a4744cdf2fffb8bd36c0649fcab4?s=128&d=identicon&r=PG", "display_name": "Daniel A.A. Pelsmaeker", "link": "https://stackoverflow.com/users/146622/daniel-a-a-pelsmaeker"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1254, "favorite_count": 1, "accepted_answer_id": 29606725, "answer_count": 1, "score": 3, "last_activity_date": 1428933515, "creation_date": 1428930120, "last_edit_date": 1428932731, "question_id": 29606017, "link": "https://stackoverflow.com/questions/29606017/as-mut-unwrap-cannot-infer-lifetime-due-to-conflicting-requirements", "title": "as_mut().unwrap(): Cannot infer lifetime due to conflicting requirements", "body": "<p>Rust lifetimes confuse me again. I'm trying to return a mutable reference to a boxed object I own. Here is my problem simplified:</p>\n\n<pre><code>pub trait Foo {\n    fn foo(&amp;self);\n}\n\npub struct Bar {\n    foo: Option&lt;Box&lt;Foo&gt;&gt;,\n}\n\nimpl Bar {\n\n    pub fn foo(&amp;mut self) -&gt; &amp;mut Box&lt;Foo&gt; {\n        let foo_ref = self.foo.as_mut();\n        foo_ref.unwrap()\n    }\n\n    pub fn set_foo(&amp;mut self, value: Box&lt;Foo&gt;) {\n        self.foo = Some(value);\n    }\n}\n</code></pre>\n\n<p>I get these errors, which I don't really understand:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>   Compiling testproject v0.0.1 (file:///home/virtlink/projects/orion/testproject)\nsrc/lib.rs:15:17: 15:25 error: cannot infer an appropriate lifetime due to conflicting requirements\nsrc/lib.rs:15         foo_ref.unwrap()\n                              ^~~~~~~~\nsrc/lib.rs:15:9: 15:25 note: first, the lifetime cannot outlive the method call at 15:8...\nsrc/lib.rs:15         foo_ref.unwrap()\n                      ^~~~~~~~~~~~~~~~\nsrc/lib.rs:15:9: 15:16 note: ...so that method receiver is valid for the method call\nsrc/lib.rs:15         foo_ref.unwrap()\n                      ^~~~~~~\nsrc/lib.rs:13:44: 16:6 note: but, the lifetime must be valid for the anonymous lifetime #1 defined on the block at 13:43...\nsrc/lib.rs:13     pub fn foo(&amp;mut self) -&gt; &amp;mut Box&lt;Foo&gt; {\nsrc/lib.rs:14         let foo_ref = self.foo.as_mut();\nsrc/lib.rs:15         foo_ref.unwrap()\nsrc/lib.rs:16     }\nsrc/lib.rs:15:9: 15:25 note: ...so that expression is assignable (expected `&amp;mut Box&lt;Foo&gt;`, found `&amp;mut Box&lt;Foo&gt;`)\nsrc/lib.rs:15         foo_ref.unwrap()\n                      ^~~~~~~~~~~~~~~~\nerror: aborting due to previous error\nCould not compile `testproject`.\n</code></pre>\n\n<p>I'm not sure how to solve this.</p>\n"}, {"tags": ["sockets", "rust"], "answers": [{"comments": [{"owner": {"reputation": 1847, "user_id": 419206, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/d21b889a17df72df17b6efda7028f9b4?s=128&d=identicon&r=PG", "display_name": "Vayn", "link": "https://stackoverflow.com/users/419206/vayn"}, "edited": false, "score": 0, "creation_date": 1428931686, "post_id": 29605879, "comment_id": 47358596, "body": "Hope <code>std::net</code> to be stable soon. Could you explain how to use <code>AsRawFd</code>? Thank you."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 5, "last_activity_date": 1428934930, "last_edit_date": 1428934930, "creation_date": 1428929720, "answer_id": 29605879, "question_id": 29605439, "link": "https://stackoverflow.com/questions/29605439/how-to-set-timeout-for-stdnetudpsocket/29605879#29605879", "title": "How to set timeout for std::net::UdpSocket?", "body": "<p>There is no way to set timeout on any network operations in <code>std::net</code> right now. There is an <a href=\"https://github.com/rust-lang/rfcs/pull/1047\" rel=\"nofollow\">RFC</a> on that, so for Rust 1.0 it will definitely be fixed. Stay tuned!</p>\n\n<p>In the meantime you can use <a href=\"http://doc.rust-lang.org/std/os/unix/io/trait.AsRawFd.html\" rel=\"nofollow\"><code>AsRawFd</code></a> implementation which each socket has and call low-level socket functions on the file descriptor manually. <a href=\"http://doc.rust-lang.org/std/os/unix/io/trait.AsRawFd.html#method.as_raw_fd\" rel=\"nofollow\"><code>AsRawFd::as_raw_fd()</code></a> returns raw file descriptor which represents the underlying socket in the operating system. You can call various low-level socket functions on this file descriptor, like <code>setsockopt</code>. These functions are available through <code>libc</code> crate. You can find how it could be done in <code>libstd</code> sources, for example, <a href=\"https://github.com/rust-lang/rust/blob/3cac76bcf239c5db7d612eea52dd39be6e0281b4/src/libstd/sys/common/net.rs#L125\" rel=\"nofollow\">here</a>. You would also probably want to use <code>libc</code> from crates.io - the built-in one is behind a feature gate and hence not available in beta.</p>\n\n<p>In order to set send/read timeout you would need to call <code>setsockopt</code> with <code>SO_SNDTIMEO</code>/<code>SO_RCVTIMEO</code> option, providing a pointer to a <a href=\"http://doc.rust-lang.org/libc/libc/types/os/common/posix01/struct.timeval.html\" rel=\"nofollow\"><code>timeval</code></a> instance. This is essentially how it could be done in C. I could expand on this later (in a few hours, probably) if you want.</p>\n"}], "owner": {"reputation": 1847, "user_id": 419206, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/d21b889a17df72df17b6efda7028f9b4?s=128&d=identicon&r=PG", "display_name": "Vayn", "link": "https://stackoverflow.com/users/419206/vayn"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 390, "favorite_count": 1, "accepted_answer_id": 29605879, "answer_count": 1, "score": 2, "last_activity_date": 1428934930, "creation_date": 1428928371, "last_edit_date": 1428934277, "question_id": 29605439, "link": "https://stackoverflow.com/questions/29605439/how-to-set-timeout-for-stdnetudpsocket", "title": "How to set timeout for std::net::UdpSocket?", "body": "<p><a href=\"http://doc.rust-lang.org/std/old_io/net/udp/struct.UdpSocket.html\" rel=\"nofollow\">std::old_io::net::udp::UdpSocket</a> has been replaced with <a href=\"https://doc.rust-lang.org/std/net/struct.UdpSocket.html\" rel=\"nofollow\">std::net::UdpSocket</a>, and <code>fn set_timeout(&amp;mut self, timeout_ms: Option&lt;u64&gt;)</code> has no equivalent.</p>\n\n<p>Any ideas how to achieve that?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 17, "last_activity_date": 1434770497, "last_edit_date": 1434770497, "creation_date": 1428902586, "answer_id": 29598350, "question_id": 29598264, "link": "https://stackoverflow.com/questions/29598264/returning-a-struct-containing-mutable-values/29598350#29598350", "title": "Returning a struct containing mutable values", "body": "<p>There are two problems here.</p>\n\n<p>The first is that you don't need to use <code>&amp;mut</code> to make a structure field mutable.  Mutability is <em>inherited</em> in Rust.  That is, if you have a <code>Foo</code> stored in a mutable variable (<code>let mut f: Foo</code>), its fields are mutable; if it's in an immutable variable (<code>let f: Foo</code>), its fields are immutable.  The solution is to just use:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct Foo {\n    values: Vec&lt;i32&gt;,\n}\n</code></pre>\n\n<p>and return a <code>Foo</code> by value.</p>\n\n<p>The second problem (and the source of the actual compilation error) is that you're trying to return a borrow to something you created in the function.  This is <em>impossible</em>.  No, there is no way around it; you can't somehow extend the lifetime of <code>initial</code>, returning <code>initial</code> as well as the borrow won't work.  Really.  This is one of the things Rust was specifically designed to absolutely forbid.</p>\n\n<p>If you want to transfer something <em>out</em> of a function, one of two things must be true:</p>\n\n<ol>\n<li><p>It is being stored somewhere outside the function that will outlive the current call (as in, you were <em>given</em> a borrow as an argument; returning doesn't count), or</p></li>\n<li><p>You are returning <em>ownership</em>, not just a borrowed reference.</p></li>\n</ol>\n\n<p>The corrected <code>Foo</code> works because it <em>owns</em> the <code>Vec&lt;i32&gt;</code>.</p>\n"}], "owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2629, "favorite_count": 0, "accepted_answer_id": 29598350, "answer_count": 1, "score": 8, "last_activity_date": 1434770497, "creation_date": 1428902087, "last_edit_date": 1434770483, "question_id": 29598264, "link": "https://stackoverflow.com/questions/29598264/returning-a-struct-containing-mutable-values", "title": "Returning a struct containing mutable values", "body": "<p>I have the following code, where I'm trying to return the struct <code>Foo</code> with a set of default values for the field <code>values</code>. These values may be changed later. But the compiler complains:</p>\n\n<pre><code>error: `initial` does not live long enough\n</code></pre>\n\n<p>How this could be achieved? Any alternatives?</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct Foo &lt;'a&gt; {\n    values: &amp;'a mut Vec&lt;i32&gt;,\n}\n\nimpl &lt;'a&gt; Foo &lt;'a&gt; {\n    fn new() -&gt; Foo &lt;'a&gt; {\n        let initial = vec![1, 2];\n\n        Foo { values: &amp;mut initial }\n    }\n}\n\nlet my_foo = Foo::new();\n\nmy_foo.values.push(3);\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1847, "user_id": 419206, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/d21b889a17df72df17b6efda7028f9b4?s=128&d=identicon&r=PG", "display_name": "Vayn", "link": "https://stackoverflow.com/users/419206/vayn"}, "edited": false, "score": 4, "creation_date": 1428860998, "post_id": 29592369, "comment_id": 47331990, "body": "Should I always use <code>usize</code> type for safety?"}, {"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "reply_to_user": {"reputation": 1847, "user_id": 419206, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/d21b889a17df72df17b6efda7028f9b4?s=128&d=identicon&r=PG", "display_name": "Vayn", "link": "https://stackoverflow.com/users/419206/vayn"}, "edited": false, "score": 18, "creation_date": 1428861192, "post_id": 29592369, "comment_id": 47332057, "body": "Depends on what you want to do, if holding indexes in a memory structure, yes. For plain numbers, <code>u32</code> is often good. The standard library always use <code>usize</code> when appropriate, and rust won&#39;t silently convert a <code>u32</code> to a <code>usize</code>, so you&#39;ll see when they are needed."}, {"owner": {"reputation": 3469, "user_id": 2574612, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/4b008a3d7ce933943329e84c1dbe6db7?s=128&d=identicon&r=PG", "display_name": "Nicholas Pipitone", "link": "https://stackoverflow.com/users/2574612/nicholas-pipitone"}, "edited": false, "score": 3, "creation_date": 1541026940, "post_id": 29592369, "comment_id": 93082898, "body": "<code>u32</code> can also be too big if you&#39;re working on embedded systems, which Rust as a systems language is designed to work well with. If <code>u32</code> was <i>always</i> too small, the language probably would&#39;ve been designed to silently convert <code>u32</code> into <code>usize</code>."}, {"owner": {"reputation": 3791, "user_id": 3294902, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/PwpJj.jpg?s=128&g=1", "display_name": "Kostas Chalkias", "link": "https://stackoverflow.com/users/3294902/kostas-chalkias"}, "edited": false, "score": 2, "creation_date": 1557881133, "post_id": 29592369, "comment_id": 98911175, "body": "Note that <code>usize</code> might cause confusion in cases you are interested in deterministic behavior or serialisation."}], "tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": true, "score": 117, "last_activity_date": 1428864245, "last_edit_date": 1428864245, "creation_date": 1428859843, "answer_id": 29592369, "question_id": 29592256, "link": "https://stackoverflow.com/questions/29592256/whats-the-difference-between-usize-and-u32/29592369#29592369", "title": "What&#39;s the difference between `usize` and `u32`?", "body": "<p>As the documentation states <code>usize</code> is pointer-sized, thus its actual size depends on the architecture your are compiling your program for.</p>\n\n<p>As an example, on a 32 bit x86 computer, <code>usize = u32</code>, while on x86_64 computers, <code>usize = u64</code>.</p>\n\n<p><code>usize</code> gives you the guarantee to be always big enough to hold any pointer or any offset in a data structure, while <code>u32</code> can be too small on some architectures.</p>\n"}, {"tags": [], "owner": {"reputation": 18471, "user_id": 4597501, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/AYPrE.jpg?s=128&g=1", "display_name": "All \u0406\u0455 V\u0430\u0438\u0456\u0442y", "link": "https://stackoverflow.com/users/4597501/all-%d0%86%d1%95-v%d0%b0%d0%b8%d1%96%d1%82y"}, "is_accepted": false, "score": 3, "last_activity_date": 1592034319, "creation_date": 1592034319, "answer_id": 62356926, "question_id": 29592256, "link": "https://stackoverflow.com/questions/29592256/whats-the-difference-between-usize-and-u32/62356926#62356926", "title": "What&#39;s the difference between `usize` and `u32`?", "body": "<p>Adding to @Levans' answer,</p>\n\n<p>The size of <strong><code>usize</code></strong> is depended on how much size it takes to reference any location in memory.</p>\n\n<p>on a 32 bit target <code>usize</code> is 4 bytes and on a 64 bit target <code>usize</code> is 8 bytes</p>\n"}], "owner": {"reputation": 1847, "user_id": 419206, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/d21b889a17df72df17b6efda7028f9b4?s=128&d=identicon&r=PG", "display_name": "Vayn", "link": "https://stackoverflow.com/users/419206/vayn"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 22545, "favorite_count": 10, "accepted_answer_id": 29592369, "answer_count": 2, "score": 82, "last_activity_date": 1592034319, "creation_date": 1428859215, "question_id": 29592256, "link": "https://stackoverflow.com/questions/29592256/whats-the-difference-between-usize-and-u32", "title": "What&#39;s the difference between `usize` and `u32`?", "body": "<p>The documentation says <code>usize</code> is</p>\n\n<blockquote>\n  <p>Operations and constants for pointer-sized unsigned integers.</p>\n</blockquote>\n\n<p>In most cases, I can replace <code>usize</code> with <code>u32</code> and nothing happens. So I don't understand why we need two types which are so alike.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 2732, "user_id": 258065, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/a5e0ab01b552291118d6ddd8b5332abb?s=128&d=identicon&r=PG", "display_name": "Theo Belaire", "link": "https://stackoverflow.com/users/258065/theo-belaire"}, "edited": false, "score": 0, "creation_date": 1428851805, "post_id": 29590943, "comment_id": 47329022, "body": "For extra background, I&#39;m trying to wrap cairo idiomatically, though I&#39;m really just looking for a generic answer (hence why this is not part of the question)."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 1, "creation_date": 1428851851, "post_id": 29590943, "comment_id": 47329040, "body": "The problem on Windows is that interacting with Unicode paths requires going through a different API. <code>char *</code> is only for code pages . Maybe you can at least work with ASCII paths, but generally on Windows a <code>OsString</code> is not a <code>char *</code>. This is partially the problem of the maintainer of the C library you&#39;re using."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1428852341, "post_id": 29590943, "comment_id": 47329193, "body": "Specifically, on *nix-like platforms, <a href=\"https://github.com/rust-lang/rust/blob/a1e3c25a2688664e85052b6205187b62410c0df0/src/libstd/sys/unix/os_str.rs#L24-L26\" rel=\"nofollow noreferrer\">OsStr is Vec&lt;u8&gt;</a>, but on Windows it <a href=\"https://github.com/rust-lang/rust/blob/a1e3c25a2688664e85052b6205187b62410c0df0/src/libstd/sys/windows/os_str.rs#L23-L25\" rel=\"nofollow noreferrer\">is a Wtf8Buf</a>."}], "answers": [{"comments": [{"owner": {"reputation": 2732, "user_id": 258065, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/a5e0ab01b552291118d6ddd8b5332abb?s=128&d=identicon&r=PG", "display_name": "Theo Belaire", "link": "https://stackoverflow.com/users/258065/theo-belaire"}, "edited": false, "score": 0, "creation_date": 1428960128, "post_id": 29597774, "comment_id": 47375904, "body": "Ah, I see, so I could use something like this example: <a href=\"http://lists.cairographics.org/archives/cairo/2007-May/010677.html\" rel=\"nofollow noreferrer\">lists.cairographics.org/archives/cairo/2007-May/010677.html</a> but just performing the write call myself, to a file I open using the path."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 1, "last_activity_date": 1428898806, "creation_date": 1428898806, "answer_id": 29597774, "question_id": 29590943, "link": "https://stackoverflow.com/questions/29590943/how-to-convert-a-path-into-a-const-char-for-ffi/29597774#29597774", "title": "How to convert a Path into a const char* for FFI?", "body": "<p>Assuming you're trying to wrap something like <code>cairo_surface_write_to_png</code>, you're probably better off just re-implementing it yourself in terms of <code>cairo_surface_write_to_png_stream</code>, using Rust for the file IO.</p>\n\n<hr>\n\n<p>The problem is more or less that paths on Windows are UTF-16, and there is (as far as I know), no 8-bit encoding (<em>i.e.</em> representable as <code>const char *</code>) that Windows will accept which can correctly store all possible paths.  In effect, if you're using <code>const char *</code> for paths on Windows, you're Doing It Wrong&trade;.</p>\n\n<p>Rust works around this by using <em>neither</em> UTF-16 or UTF-8 on Windows; instead, it uses <a href=\"https://simonsapin.github.io/wtf-8/\" rel=\"nofollow\">WTF-8</a> which is a non-standard extension to UTF-8 to encode the full UTF-16 space.  But, this also means that the actual, internal representation of a Rust path on Windows is effectively useless outside of Rust itself.</p>\n"}], "owner": {"reputation": 2732, "user_id": 258065, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/a5e0ab01b552291118d6ddd8b5332abb?s=128&d=identicon&r=PG", "display_name": "Theo Belaire", "link": "https://stackoverflow.com/users/258065/theo-belaire"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 568, "favorite_count": 0, "accepted_answer_id": 29597774, "answer_count": 1, "score": 3, "last_activity_date": 1428898806, "creation_date": 1428851400, "last_edit_date": 1428852016, "question_id": 29590943, "link": "https://stackoverflow.com/questions/29590943/how-to-convert-a-path-into-a-const-char-for-ffi", "title": "How to convert a Path into a const char* for FFI?", "body": "<p>I'm trying to take a <a href=\"http://doc.rust-lang.org/std/path/struct.PathBuf.html\" rel=\"nofollow\"><code>PathBuf</code></a> which represents a file location,\nand pass it into a C library to save an image to that location.</p>\n\n<p>I can see that I can turn the <code>PathBuf</code> into an <a href=\"http://doc.rust-lang.org/std/ffi/struct.OsString.html\" rel=\"nofollow\"><code>OsString</code></a>, and using <a href=\"http://doc.rust-lang.org/std/os/unix/ffi/index.html\" rel=\"nofollow\"><code>std::os::unix::ffi</code></a>, I can turn it into <code>Vec&lt;u8&gt;</code>, and from there, a <a href=\"http://doc.rust-lang.org/std/ffi/struct.CString.html\" rel=\"nofollow\"><code>CString</code></a>, but this seems somewhat convoluted and platform specific.</p>\n\n<p>Is that really the best we can do at this point?  I'd rather not limit this to Unix only over an issue as small as this, since everything else works on Windows as far as I know.</p>\n"}, {"tags": ["serialization", "rust"], "answers": [{"comments": [{"owner": {"reputation": 1847, "user_id": 419206, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/d21b889a17df72df17b6efda7028f9b4?s=128&d=identicon&r=PG", "display_name": "Vayn", "link": "https://stackoverflow.com/users/419206/vayn"}, "edited": false, "score": 0, "creation_date": 1428850392, "post_id": 29590637, "comment_id": 47328523, "body": "Thank you! The tutorial is totally out of date."}], "tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": false, "score": 2, "last_activity_date": 1428849560, "creation_date": 1428849560, "answer_id": 29590637, "question_id": 29590253, "link": "https://stackoverflow.com/questions/29590253/how-to-use-emit-struct-and-emit-struct-field-to-serialize-a-custom-struct/29590637#29590637", "title": "How to use `emit_struct` and `emit_struct_field` to serialize a custom struct?", "body": "<p>You problem is with the <code>emit_struct(..)</code> call.</p>\n\n<p>The prototype of this function is:</p>\n\n\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn emit_struct&lt;F&gt;(&amp;mut self, name: &amp;str, len: usize, f: F)\n    -&gt; Result&lt;(), Self::Error&gt;\n    where F: FnOnce(&amp;mut Self) -&gt; Result&lt;(), Self::Error&gt;;\n</code></pre>\n\n<p>Here, <code>len</code> is the number of fields of your struct. Bu you are setting it to <code>0</code>, so the JSON dictionary generated has 0 fields.</p>\n\n<p>Changing it to 3 gives this output:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>{\"name\":\"John Doe\",\"age\":33,\"summary\":\"Nice person named John Doe, 33 years of age\"}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1847, "user_id": 419206, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/d21b889a17df72df17b6efda7028f9b4?s=128&d=identicon&r=PG", "display_name": "Vayn", "link": "https://stackoverflow.com/users/419206/vayn"}, "edited": false, "score": 0, "creation_date": 1428850524, "post_id": 29590667, "comment_id": 47328581, "body": "I&#39;m a newbie to Rust and rustc-serialize is really not well-documented. Thanks!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1428850581, "last_edit_date": 1428850581, "creation_date": 1428849718, "answer_id": 29590667, "question_id": 29590253, "link": "https://stackoverflow.com/questions/29590253/how-to-use-emit-struct-and-emit-struct-field-to-serialize-a-custom-struct/29590667#29590667", "title": "How to use `emit_struct` and `emit_struct_field` to serialize a custom struct?", "body": "<p>It looks like your tutorial is out-of-date. It says</p>\n\n<blockquote>\n  <p>We call emit_struct on our encoder and pass it 3 arguments: the name of the struct, current index and an anonymous function(aka lambda). The name of the struct is not used; <strong>current index is not used</strong> too.</p>\n</blockquote>\n\n<p>But <a href=\"https://github.com/rust-lang/rustc-serialize/blob/031333c08d4819aa36127f1a4070e3efcc2341d7/src/json.rs#L732-L737\" rel=\"nofollow\">the code says</a></p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn emit_struct&lt;F&gt;(&amp;mut self, _: &amp;str, len: usize, f: F) -&gt; EncodeResult&lt;()&gt; where\n    F: FnOnce(&amp;mut Encoder&lt;'a&gt;) -&gt; EncodeResult&lt;()&gt;,\n{\n    if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n    if len == 0 {\n        try!(write!(self.writer, \"{{}}\"));\n</code></pre>\n\n<p>So the argument has changed from an <em>index</em> to a <em>length</em>, and it's now meaningful. Here's your example working:</p>\n\n<pre><code>extern crate rustc_serialize;\nuse rustc_serialize::{json, Encodable, Encoder};\n\nstruct Person {\n    name: String,\n    age: usize,\n}\n\nimpl Encodable for Person {\n    fn encode&lt;S: Encoder&gt;(&amp;self, s: &amp;mut S) -&gt; Result&lt;(), S::Error&gt; {\n        s.emit_struct(\"Person\", 1, |s| {\n            try!(s.emit_struct_field(\"name\",    0, |s| self.name.encode(s)));\n            try!(s.emit_struct_field(\"age\",     1, |s| self.age.encode(s)));\n            try!(s.emit_struct_field(\"summary\", 2, |s| {\n                let summary = format!(\"Nice person named {}, {} years of age\", self.name, self.age);\n                summary.encode(s)\n            }));\n            Ok(())\n        })\n    }\n}\n\nfn main() {\n    let person = Person {\n        name: \"John Doe\".to_string(),\n        age: 33,\n    };\n    println!(\"{}\" , json::encode(&amp;person).unwrap());\n}\n</code></pre>\n\n<p>Note that I also removed the crazy gyrations to destructure <code>self</code> and just access the properties directly.</p>\n"}], "owner": {"reputation": 1847, "user_id": 419206, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/d21b889a17df72df17b6efda7028f9b4?s=128&d=identicon&r=PG", "display_name": "Vayn", "link": "https://stackoverflow.com/users/419206/vayn"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 279, "favorite_count": 0, "accepted_answer_id": 29590667, "answer_count": 2, "score": 1, "last_activity_date": 1428850581, "creation_date": 1428847290, "last_edit_date": 1428847682, "question_id": 29590253, "link": "https://stackoverflow.com/questions/29590253/how-to-use-emit-struct-and-emit-struct-field-to-serialize-a-custom-struct", "title": "How to use `emit_struct` and `emit_struct_field` to serialize a custom struct?", "body": "<p>I've read valve's <a href=\"http://valve.github.io/blog/2014/08/25/json-serialization-in-rust-part-1/\" rel=\"nofollow\">JSON Serialization in Rust, Part 1</a> and try to run the code in the blogpost. The most complicated part is do a custom serialization for a custom struct.</p>\n\n<p>I update the snippet so it can run on newest Rust nightly:</p>\n\n<pre><code>extern crate rustc_serialize;\nuse rustc_serialize::{json, Encodable, Encoder};\n\nstruct Person {\n    name: String,\n    age: usize,\n}\n\nimpl Encodable for Person {\n    fn encode&lt;S: Encoder&gt;(&amp;self, s: &amp;mut S) -&gt; Result&lt;(), S::Error&gt; {\n        match *self {\n            Person { name: ref p_name, age: ref p_age, } =&gt; {\n                s.emit_struct(\"Person\", 0, |s| {\n                    try!(s.emit_struct_field( \"name\", 0, |s| p_name.encode(s)));\n                    try!(s.emit_struct_field( \"age\", 1, |s| p_age.encode(s)));\n                    try!(s.emit_struct_field( \"summary\", 2, |s| {\n                        (format!(\"Nice person named {}, {} years of age\", p_name, p_age)).encode(s)\n                    }));\n                    Ok(())\n                })\n            },\n        }\n    }\n}\n\nfn main() {\n    let person = Person {\n        name: \"John Doe\".to_string(),\n        age: 33,\n    };\n    println!(\"{}\" , json::encode(&amp;person).unwrap());\n}\n</code></pre>\n\n<p>The output of above is <code>{}</code>, but the correct result should be:</p>\n\n<p><code>{\"age\":33,\"name\":\"John Doe\",\"summary\":\"Nice person named John Doe, 33 years of age\"}</code></p>\n\n<p>I want to know how to use <code>Encodable</code> trait to serialize a custom struct in right way.</p>\n\n<p>Thank you.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 273, "user_id": 286021, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8366e7b2d753db522f8ab5c0846807a4?s=128&d=identicon&r=PG", "display_name": "nelsonjchen", "link": "https://stackoverflow.com/users/286021/nelsonjchen"}, "edited": false, "score": 0, "creation_date": 1428829206, "post_id": 29584077, "comment_id": 47322937, "body": "I&#39;m doing that now. Is this the equivalent of the Ruby example? I&#39;m curious if the Ruby and friends version just tosses a packet out on the network without binding or if it binds like this behind the scenes."}, {"owner": {"reputation": 273, "user_id": 286021, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8366e7b2d753db522f8ab5c0846807a4?s=128&d=identicon&r=PG", "display_name": "nelsonjchen", "link": "https://stackoverflow.com/users/286021/nelsonjchen"}, "edited": false, "score": 0, "creation_date": 1428829330, "post_id": 29584077, "comment_id": 47322960, "body": "Oh, I just reflected on your comment on the question. I guess so. Thanks!"}, {"owner": {"reputation": 349, "user_id": 187539, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ac450184a905950c26fe2f124898d571?s=128&d=identicon&r=PG", "display_name": "Cody Schafer", "link": "https://stackoverflow.com/users/187539/cody-schafer"}, "edited": false, "score": 0, "creation_date": 1576009371, "post_id": 29584077, "comment_id": 104756649, "body": "This doesn&#39;t appear to work if I want to support either ipv4 or ipv6 sends. When unbound"}], "tags": [], "owner": {"reputation": 4091, "user_id": 26083, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/4c3b4f3460b142d0ba37de98d1b04655?s=128&d=identicon&r=PG", "display_name": "haavee", "link": "https://stackoverflow.com/users/26083/haavee"}, "is_accepted": true, "score": 12, "last_activity_date": 1618161354, "last_edit_date": 1618161354, "creation_date": 1428793557, "answer_id": 29584077, "question_id": 29583870, "link": "https://stackoverflow.com/questions/29583870/is-there-a-way-to-create-a-udpsocket-without-bind-for-just-send-to/29584077#29584077", "title": "Is there a way to create a UdpSocket without bind() for just send_to()?", "body": "<p>I would try <code>::bind(&quot;0.0.0.0:0&quot;)</code> - this should let the O/S choose an IP/port for you. This might be good enough for a transient socket to send a simple datagram with.</p>\n<p><em>Note: this is what happens too when using sendto() on an unbound UDP socket too, e.g. using the fd returned from the socket() system call without calling bind() - the O/S allocates an IP/port to send your datagram from.</em></p>\n"}], "owner": {"reputation": 273, "user_id": 286021, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8366e7b2d753db522f8ab5c0846807a4?s=128&d=identicon&r=PG", "display_name": "nelsonjchen", "link": "https://stackoverflow.com/users/286021/nelsonjchen"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2133, "favorite_count": 3, "accepted_answer_id": 29584077, "answer_count": 1, "score": 10, "last_activity_date": 1618161354, "creation_date": 1428791829, "last_edit_date": 1428792113, "question_id": 29583870, "link": "https://stackoverflow.com/questions/29583870/is-there-a-way-to-create-a-udpsocket-without-bind-for-just-send-to", "title": "Is there a way to create a UdpSocket without bind() for just send_to()?", "body": "<p>I'm trying to do the equivalent of <a href=\"https://github.com/davydovanton/AnyBar_rb/blob/0431c2bb3906bab4bb561b211a90b470098e1523/lib/any_bar.rb#L14-L20\" rel=\"noreferrer\">this piece of Ruby</a>:</p>\n\n<pre><code>def color=(color)\n  @color = color\n  any_bar = UDPSocket.new\n  any_bar.connect HOSTNAME, @port\n  any_bar.send @color, 0\n  any_bar.close\nend\n</code></pre>\n\n<p>I can't see any other way to <a href=\"https://doc.rust-lang.org/std/net/struct.UdpSocket.html\" rel=\"noreferrer\">initialize a <code>UdpSocket</code> from the Rust API documentation</a> without <code>bind()</code>. </p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428792732, "post_id": 29583769, "comment_id": 47316108, "body": "This is great. Isn&#39;t it possible to make a default implementation of the <code>value()</code> methods? Having to repeat them over and over again looks cumbersome."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 1, "creation_date": 1428793077, "post_id": 29583769, "comment_id": 47316194, "body": "@caio there&#39;s always macros! ^_^. However, if you actually find yourself repeating code over and over, perhaps you can extract the common code out into a new struct and then embed that struct where you extracted it from. Otherwise, you are going to <i>want</i> different implementations, so a default wouldn&#39;t be useful. You may be interested in <a href=\"http://stackoverflow.com/q/29256519/155423\">this question</a> that asked about the case in the middle of those two extremes."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1428791124, "creation_date": 1428791124, "answer_id": 29583769, "question_id": 29583709, "link": "https://stackoverflow.com/questions/29583709/access-a-field-from-a-struct-casted-with-boxtrait/29583769#29583769", "title": "Access a field from a struct casted with Box&lt;Trait&gt;", "body": "<p>Yes, traits do not have access to the fields of their implementors. You need to provide accessor methods. These are small and should be optimized away:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>trait View {\n    fn value(&amp;self) -&gt; &amp;'static str;\n}\n\nstruct View1 {\n    value: &amp;'static str,\n}\n\nimpl View for View1 {\n    fn value(&amp;self) -&gt; &amp;'static str { self.value }\n}\n\nstruct View2 {\n    value: &amp;'static str,\n    another_value: &amp;'static str,\n}\n\nimpl View for View2 {\n    fn value(&amp;self) -&gt; &amp;'static str { self.value }\n}\n\ntrait Renderable {\n    fn view(&amp;self) -&gt; &amp;View;\n\n    fn render(&amp;self) -&gt; &amp;'static str {\n        self.view().value()\n    }\n}\n\nstruct Pattern&lt;T&gt;\n    where T: View\n{\n    view: T,\n}\n\nimpl&lt;T&gt; Renderable for Pattern&lt;T&gt;\n    where T: View\n{\n    fn view(&amp;self) -&gt; &amp;View {\n        &amp;self.view\n    }\n}\n\nfn patterns() -&gt; Vec&lt;Box&lt;Renderable&gt;&gt; {\n    vec![\n        Box::new(Pattern { view: View1 { value: \"x\" } }),\n        Box::new(Pattern { view: View2 { value: \"y\", another_value: \"z\" } }),\n    ]\n}\n\nfn main() {\n    let p = patterns();\n\n    for x in p.iter() {\n        println!(\"{}\", x.render());\n    }\n}\n</code></pre>\n\n<p>Basically, traits are contracts that objects must adhere to, and the language of those contracts is the function names, the argument types, and the return types. If a trait needs to be able to get a <code>view</code> or a <code>value</code>, then that needs to be a part of the trait.</p>\n\n<p>Note that <em>implementations of traits</em> <strong>do</strong> have access to the fields of the struct they are implementing the trait on. Since the implementation is specialized for one type, that guarantees that you have access to the appropriate fields.</p>\n"}], "owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 842, "favorite_count": 0, "accepted_answer_id": 29583769, "answer_count": 1, "score": 0, "last_activity_date": 1428791124, "creation_date": 1428790620, "last_edit_date": 1428790742, "question_id": 29583709, "link": "https://stackoverflow.com/questions/29583709/access-a-field-from-a-struct-casted-with-boxtrait", "title": "Access a field from a struct casted with Box&lt;Trait&gt;", "body": "<p>I have the following code, that I think is pretty self-explanatory. The problem I'm facing is in the <code>render</code> function:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn render(&amp;self) -&gt; &amp;'static str {\n    self.view.value\n}\n</code></pre>\n\n<p>Where the compiler complains:</p>\n\n<pre><code>attempted access of field `view` on type `&amp;Self`, but no field with that name was found`\n</code></pre>\n\n<p>Full code:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct View1 {\n    value: &amp;'static str,\n}\n\nstruct View2 {\n    value: &amp;'static str,\n    another_value: &amp;'static str,\n}\n\nstruct Pattern&lt;T&gt; {\n    view: T,\n}\n\ntrait Renderable {\n    fn render(&amp;self) -&gt; &amp;'static str {\n        self.view.value\n    }\n}\n\nimpl &lt;T&gt; Renderable for Pattern &lt;T&gt; {}\n\nfn patterns() -&gt; Vec&lt;Box&lt;Renderable&gt;&gt; {\n    vec![\n        Box::new(Pattern { view: View1 { value: \"x\" } }),\n        Box::new(Pattern { view: View1 { value: \"y\" } }),\n    ]\n}\n\nfn main() {\n    let p = patterns();\n\n    for x in p.iter() {\n        println!(\"{}\", x.render());\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 3692, "user_id": 1467466, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/ec7b22599095a0d388d6e51818e7db9b?s=128&d=identicon&r=PG", "display_name": "user", "link": "https://stackoverflow.com/users/1467466/user"}, "edited": false, "score": 0, "creation_date": 1428821184, "post_id": 29584691, "comment_id": 47321279, "body": "Well, when an owner of the rust GitHub repo says it&#39;s a bug, it&#39;s probably a bug. Thanks for the workarounds and extra edifying notes!"}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 3, "last_activity_date": 1428849863, "last_edit_date": 1428849863, "creation_date": 1428799441, "answer_id": 29584691, "question_id": 29582740, "link": "https://stackoverflow.com/questions/29582740/bounds-on-associated-types-but-error-the-type-of-this-value-must-be-known-in-t/29584691#29584691", "title": "Bounds on associated types but &#39;error: the type of this value must be known in this context&#39;", "body": "<p>This seems like a bug: the <code>&lt;'a&gt;</code> in the trait declaration is seemingly causing the compiler to get confused, e.g.:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>trait DictLike&lt;'a&gt; {\n    type ItemsIterator: Iterator&lt;Item=u8&gt;;\n\n    fn items(&amp;self) -&gt; Self::ItemsIterator;\n\n    fn get(&amp;self)  {\n        for k in self.items() {}\n    }\n}\n</code></pre>\n\n\n\n<pre><code>&lt;anon&gt;:7:13: 7:14 error: unable to infer enough type information about `_`; type annotations required [E0282]\n&lt;anon&gt;:7         for k in self.items() {}\n                     ^\n</code></pre>\n\n<p>Removing the <code>'a</code> allows that code to compile. I've filed <a href=\"https://github.com/rust-lang/rust/issues/24338\" rel=\"nofollow\">#24338</a> about this.</p>\n\n<p>Fortunately, there is a work around: this seems to only happen when the code is inside the default method, and moving the actual implementation to an external function works fine:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::borrow::Borrow;\n\ntrait DictLike&lt;'a&gt; {\n    type Label: Eq + 'a;\n    type ItemsIterator: Iterator&lt;Item=(&amp;'a Self::Label, &amp;'a DictLike&lt;'a&gt;)&gt; + 'a;\n\n    fn items(&amp;self) -&gt; Self::ItemsIterator;\n\n    fn get&lt;Q: ?Sized + Eq&gt;(&amp;self, key: &amp;Q) -&gt; Option&lt;&amp;'a DictLike&lt;'a&gt;&gt;\n            where Self::Label: Borrow&lt;Q&gt; {\n        get(self, key)\n    }\n}\n\nfn get&lt;'a, X: ?Sized + DictLike&lt;'a&gt;, Q: ?Sized + Eq&gt;(x: &amp;X, key: &amp;Q) -&gt; Option&lt;&amp;'a DictLike&lt;'a&gt;&gt;\n        where X::Label: Borrow&lt;Q&gt; {\n    for (k,v) in x.items() {\n        if k.borrow() == key {\n            return Some(v);\n        }\n    }\n    None\n}\n</code></pre>\n\n<p>This is functionally no different to the original code, except for the fact that it compiles. (I took the liberty of switching the <code>.eq</code> call to the <code>==</code> operator, which is nicer sugar for the method call.)</p>\n\n<p>Also, if you're feeling like experimenting with iterators a little more, one could write <code>get</code> as </p>\n\n<pre><code>x.items()\n .find(|&amp;(k,_)| k.borrow() == key)\n .map(|(_, v)| v)\n</code></pre>\n\n<p>Using <a href=\"http://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find\" rel=\"nofollow\"><code>Iterator::find</code></a> and <a href=\"http://doc.rust-lang.org/nightly/std/option/enum.Option.html#method.map\" rel=\"nofollow\"><code>Option::map</code></a>.</p>\n"}], "owner": {"reputation": 3692, "user_id": 1467466, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/ec7b22599095a0d388d6e51818e7db9b?s=128&d=identicon&r=PG", "display_name": "user", "link": "https://stackoverflow.com/users/1467466/user"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 141, "favorite_count": 0, "accepted_answer_id": 29584691, "answer_count": 1, "score": 1, "last_activity_date": 1428849863, "creation_date": 1428784223, "last_edit_date": 1428785029, "question_id": 29582740, "link": "https://stackoverflow.com/questions/29582740/bounds-on-associated-types-but-error-the-type-of-this-value-must-be-known-in-t", "title": "Bounds on associated types but &#39;error: the type of this value must be known in this context&#39;", "body": "<p>The following </p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::borrow::Borrow;\n\ntrait DictLike&lt;'a&gt; {\n    type Label: Eq + 'a;\n    type ItemsIterator: Iterator&lt;Item=(&amp;'a Self::Label, &amp;'a DictLike&lt;'a&gt;)&gt; + 'a;\n\n    fn items(&amp;self) -&gt; Self::ItemsIterator;\n\n    fn get&lt;Q: ?Sized + Eq&gt;(&amp;self, key: &amp;Q) -&gt; Option&lt;&amp;'a DictLike&lt;'a&gt;&gt;\n        where Self::Label: Borrow&lt;Q&gt; {\n        for (k,v) in self.items() {\n            if k.borrow().eq(key) {\n                return Some(v);\n            }\n        }\n        None\n    }\n}\n</code></pre>\n\n<p>errors out as</p>\n\n<pre><code>lib.rs:12:16: 12:26 error: the type of this value must be known in this context\nlib.rs:12             if k.borrow().eq(key) {\n                         ^~~~~~~~~~\n</code></pre>\n\n<p>Why? Doesn't <code>ItemsIterator</code>'s type bound and the bound <code>Self::Label: Borrow&lt;Q&gt;</code> provide the necessary type information?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 1, "creation_date": 1428780142, "post_id": 29581928, "comment_id": 47312355, "body": "Isn&#39;t it possible to return <i>any</i> values without making them explicit? For example, any structs that implements a certain trait? Something like: &quot;fn foos&lt;T: Renderable&gt; -&gt; Vec&lt;Foo&lt;T&gt;&gt; {}&quot;"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 1, "creation_date": 1428780853, "post_id": 29581928, "comment_id": 47312602, "body": "@caio in your example, you have specified concrete type(s) in the body of the function - what benefit would there be to making it generic? The biggest I am aware of is to hide implementation details. What are you looking to do?"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 1, "creation_date": 1428780953, "post_id": 29581928, "comment_id": 47312642, "body": "@caio That signature, to be internally consistent and to support some (admittedly rarer) useful patterns, needs to allow the caller to ask for <i>any</i> concrete type, as long as it&#39;s <code>Renderable</code>. What you want would need a new feature, like the closed <a href=\"https://github.com/rust-lang/rfcs/pull/105\" rel=\"nofollow noreferrer\">RFC PR 105 (abstract unboxed return types)</a>. You can use <code>Box&lt;Trait&gt;</code> but that has a hefty cost."}, {"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428782724, "post_id": 29581928, "comment_id": 47313264, "body": "@Shepmaster What I&#39;m trying to do is: <code>patterns</code> is a list (vector) of <code>structs</code> that implements <code>Renderable</code> methods. I want to walk through the list of patterns, find the first who match the given pattern and call the <code>render</code> method in that struct. But structs will be created on demand and patterns can hold many of them. What I need is to make patterns return a list of these structs but defining all of them in an enum is painful."}, {"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428783375, "post_id": 29581928, "comment_id": 47313464, "body": "just adding some info: by &quot;given pattern&quot; I mean a regular expression. pseudo code: patterns = my_patterns(); for pattern in patterns { if (match(&quot;foo&quot;, pattern.regex)) { render(pattern) } }"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428784066, "post_id": 29581928, "comment_id": 47313665, "body": "@caio it sounds like you want what @delnan said - the (not available) RFC, or to have a <code>Vec&lt;Box&lt;Trait&gt;&gt;</code>."}, {"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428788355, "post_id": 29581928, "comment_id": 47314825, "body": "@Shepmaster @delnan do you mean something like this? <code>let x: Box&lt;Renderable&gt; = Box::new(Bar { value: &quot;x&quot; });</code> If so, how can I access <code>x.value</code>?"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 1, "creation_date": 1428788504, "post_id": 29581928, "comment_id": 47314865, "body": "@caio You can&#39;t, unless the trait has a method that gives access. But that has nothing to do with the <code>Box</code>, only with the fact that you want to use the trait instead of the concrete type (<code>Bar</code>)."}, {"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428788683, "post_id": 29581928, "comment_id": 47314910, "body": "@delnan I tried to create a method in the trait but it also didn&#39;t work. The method looks like this: <code>fn render(&amp;self) -&gt; &amp;&#39;static str { self.value }</code>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 1, "creation_date": 1428788994, "post_id": 29581928, "comment_id": 47315008, "body": "@caio this is fairly far from your original question - perhaps opening a new one? They are free to open ^_^"}, {"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428790652, "post_id": 29581928, "comment_id": 47315509, "body": "@Shepmaster Here we go: <a href=\"http://stackoverflow.com/questions/29583709/access-a-field-from-a-struct-casted-with-boxtrait\" title=\"access a field from a struct casted with boxtrait\">stackoverflow.com/questions/29583709/&hellip;</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1428779359, "creation_date": 1428779359, "answer_id": 29581928, "question_id": 29581855, "link": "https://stackoverflow.com/questions/29581855/how-to-return-a-vector-containing-generic-values/29581928#29581928", "title": "How to return a vector containing generic values", "body": "<p>The compiler is giving you a good error message here:</p>\n\n<pre><code>expected `Foo&lt;T&gt;`,\n   found `Foo&lt;&amp;str&gt;`\n</code></pre>\n\n<p>That is, you aren't returning some generic <code>T</code>, you are returning a concrete type. Actually, you aren't returning just one type, you are trying to return two <em>different</em> types!</p>\n\n<p>Each time a generic is resolved, it must resolve to a single type. That is, you can call <code>foo&lt;T&gt;(a: T, b: T)</code> with two <code>u32</code> or two <code>bool</code>, but <strong>not</strong> with one of each.</p>\n\n<p>To make your code work in the most straight-forward way, you can use an enum. This creates a single type that can have one of a set of values:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct Foo&lt;T&gt; {\n    bar: T,\n}\n\n#[derive(Debug)]\nenum Bar&lt;'a&gt; {\n    Num(i32),\n    Str(&amp;'a str),\n}\n\n// Note no generics here, we specify the concrete type that this `Foo` is\nfn foos() -&gt; Vec&lt;Foo&lt;Bar&lt;'static&gt;&gt;&gt; {\n    vec![\n        Foo { bar: Bar::Str(\"x\") },\n        Foo { bar: Bar::Num(1) },\n    ]\n}\n\nfn main() {\n    let my_foos: Vec&lt;_&gt; = foos();\n\n    println!(\"{:?}\", my_foos[0].bar);\n}\n</code></pre>\n"}], "owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2020, "favorite_count": 1, "accepted_answer_id": 29581928, "answer_count": 1, "score": 1, "last_activity_date": 1428779359, "creation_date": 1428778856, "question_id": 29581855, "link": "https://stackoverflow.com/questions/29581855/how-to-return-a-vector-containing-generic-values", "title": "How to return a vector containing generic values", "body": "<p>I'm trying to return a vector from a function but the compiler gives me the following error message:</p>\n\n<pre><code> expected `Foo&lt;T&gt;`,\n    found `Foo&lt;&amp;str&gt;`\n(expected type parameter,\n    found &amp;-ptr) [E0308]\n</code></pre>\n\n<p>What am I missing here? </p>\n\n<pre><code>struct Foo&lt;T&gt; {\n    bar: T,\n}\n\n\nfn foos&lt;T&gt;() -&gt; Vec&lt;Foo&lt;T&gt;&gt; {\n    vec![\n        Foo { bar: \"x\" },\n        Foo { bar: 1 },\n    ]\n}\n\n\n\nfn main() {\n    let my_foos: Vec&lt;_&gt; = foos();\n\n    println!(\"{}\", my_foos[0].bar);\n}\n</code></pre>\n"}, {"tags": ["file", "matrix", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1428774289, "post_id": 29580979, "comment_id": 47310400, "body": "Welcome to Stack Overflow! To get the most out of your questions, please read <a href=\"http://stackoverflow.com/help/how-to-ask\">How to ask a good question</a>. In this case, it would be <b>strongly encouraged</b> for you to include <a href=\"http://stackoverflow.com/help/mcve\">the MCVE</a> you have tried so we can understand the problem you are having. Additionally, I&#39;d recommend reading the <a href=\"http://doc.rust-lang.org/intro.html\" rel=\"nofollow noreferrer\">Rust 30-minute intro</a> and <a href=\"http://doc.rust-lang.org/nightly/book/\" rel=\"nofollow noreferrer\">The Rust Book</a> which cover <i>many</i> issues beginners run into!"}], "answers": [{"comments": [{"owner": {"reputation": 95, "user_id": 4777440, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6a90e9f5af1e931f26cf7ec7598d1a87?s=128&d=identicon&r=PG&f=1", "display_name": "vessd", "link": "https://stackoverflow.com/users/4777440/vessd"}, "edited": false, "score": 0, "creation_date": 1428840255, "post_id": 29582998, "comment_id": 47325615, "body": "<code>let mut s = String::new();</code> <code>f.read_line(&amp;mut s).unwrap();</code> These actions are necessary?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 95, "user_id": 4777440, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6a90e9f5af1e931f26cf7ec7598d1a87?s=128&d=identicon&r=PG&f=1", "display_name": "vessd", "link": "https://stackoverflow.com/users/4777440/vessd"}, "edited": false, "score": 1, "creation_date": 1428844475, "post_id": 29582998, "comment_id": 47326741, "body": "You mean the last example, right? Yes, these are necessary - you need to skip the first line which contains the number of elements. If you can change the format so it doesn&#39;t have the first line, you can omit these of course."}, {"owner": {"reputation": 1810, "user_id": 5500589, "user_type": "registered", "accept_rate": 35, "profile_image": "https://i.stack.imgur.com/IldVR.jpg?s=128&g=1", "display_name": "Galaxy", "link": "https://stackoverflow.com/users/5500589/galaxy"}, "edited": false, "score": 0, "creation_date": 1576882599, "post_id": 29582998, "comment_id": 105050062, "body": "spasibo for this post"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 8, "last_activity_date": 1428786143, "creation_date": 1428786143, "answer_id": 29582998, "question_id": 29580979, "link": "https://stackoverflow.com/questions/29580979/how-to-read-a-matrix-from-a-txt-file-in-rust/29582998#29582998", "title": "How to read a matrix from a txt file in Rust?", "body": "<p>This is a naive translation of your code to Rust:</p>\n\n<pre><code>use std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() {\n    // open the file\n    let mut f = BufReader::new(File::open(\"input.txt\").unwrap());\n\n    // read the first line and extract the number from it\n    let mut num_line = String::new();\n    f.read_line(&amp;mut num_line).unwrap();\n    let n: usize = num_line[1..].trim().parse().unwrap();\n\n    // preallocate the array and read the data into it\n    let mut arr = vec![vec![0f64; n]; n];\n    for (i, line) in f.lines().enumerate() {\n        for (j, number) in line.unwrap().split(char::is_whitespace).enumerate() {\n            arr[i][j] = number.trim().parse().unwrap();\n        }\n    }\n\n    println!(\"{:?}\", arr);\n}\n</code></pre>\n\n<p>There is more idiomatic way to perform the loop in Rust, though:</p>\n\n<pre><code>use std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() {\n    let mut f = BufReader::new(File::open(\"input.txt\").unwrap());\n\n    let mut num_line = String::new();\n    f.read_line(&amp;mut num_line).unwrap();\n    let n: usize = num_line[1..].trim().parse().unwrap();\n\n    let arr: Vec&lt;Vec&lt;f64&gt;&gt; = f.lines()\n        .take(n)\n        .map(|l| l.unwrap().split(char::is_whitespace)\n             .take(n)\n             .map(|number| number.parse().unwrap())\n             .collect())\n        .collect();\n\n    println!(\"{:?}\", arr);\n}\n</code></pre>\n\n<p>In fact, you don't even need the number of lines in advance to read the data if the format of your file is completely fixed:</p>\n\n<pre><code>use std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() {\n    let mut f = BufReader::new(File::open(\"input.txt\").unwrap());\n\n    let mut s = String::new();\n    f.read_line(&amp;mut s).unwrap();\n\n    let arr: Vec&lt;Vec&lt;f64&gt;&gt; = f.lines()\n        .map(|l| l.unwrap().split(char::is_whitespace)\n             .map(|number| number.parse().unwrap())\n             .collect())\n        .collect();\n\n    println!(\"{:?}\", arr);\n}\n</code></pre>\n"}], "owner": {"reputation": 95, "user_id": 4777440, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6a90e9f5af1e931f26cf7ec7598d1a87?s=128&d=identicon&r=PG&f=1", "display_name": "vessd", "link": "https://stackoverflow.com/users/4777440/vessd"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2365, "favorite_count": 0, "accepted_answer_id": 29582998, "answer_count": 1, "score": 4, "last_activity_date": 1462687368, "creation_date": 1428774014, "question_id": 29580979, "link": "https://stackoverflow.com/questions/29580979/how-to-read-a-matrix-from-a-txt-file-in-rust", "title": "How to read a matrix from a txt file in Rust?", "body": "<p>File example; square matrix; size of matrix after #</p>\n\n<pre><code>#3\n1.1 -0.2 0.1\n0.1 -1.2 -0.2\n0.2 -0.1 1.1\n</code></pre>\n\n<p>Approximately so i would write it in C</p>\n\n<pre><code>double **A;\nint i,j,size=0;\nFILE *f=NULL;\n\nf=fopen(\"input.txt\",\"w\");\nfscanf(f,\"#%d\\n\",&amp;size);\nA=(double**)malloc(size*sizeof(double*));\nfor(i=0;i&lt;size;i++)\n    A[i]=(double*)malloc(size*sizeof(double));\n\nfor(i=0;i&lt;size;i++)\n{\n    for(j=0;j&lt;size;j++)\n    {\n        fscanf(f,\"%lf\",&amp;A[i][j]);\n    }\n}\nfclose(f);\n</code></pre>\n\n<p>I tried to use the method \"read_to_string\" and parse String, but I'm confused by the conversion between String and str.</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428773451, "post_id": 29580628, "comment_id": 47310105, "body": "Is it possible to make the temporary value last longer without using a let statement? The vector will have many values, say 30. So I&#39;ll have to place 30 let statements? Any ideas?"}, {"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428777850, "post_id": 29580628, "comment_id": 47311625, "body": "Just another question: is it possible to return <code>foos</code> from a function? For example: let foos2: Vec&lt;_&gt; = foos(). I tried something like &quot;fn foos&lt;T&gt;() -&gt; Vec&lt;Foo&lt;T&gt;&gt; { }&quot; but it says there&#39;s a type mismatch."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428778057, "post_id": 29580628, "comment_id": 47311703, "body": "@caio It depends on which variant you have. The owned version should be fine, the second one (with the map) is not. That one has references to items that won&#39;t live beyond the function call. For more detail, I&#39;d recommend asking another top-level question!"}, {"owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "edited": false, "score": 0, "creation_date": 1428778867, "post_id": 29580628, "comment_id": 47311961, "body": "did it: <a href=\"http://stackoverflow.com/questions/29581855/how-to-return-a-vector-containing-generic-values\" title=\"how to return a vector containing generic values\">stackoverflow.com/questions/29581855/&hellip;</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1554256328, "last_edit_date": 1554256328, "creation_date": 1428771977, "answer_id": 29580628, "question_id": 29580295, "link": "https://stackoverflow.com/questions/29580295/lifetimes-when-adding-temporary-values-to-vectors/29580628#29580628", "title": "Lifetimes when adding temporary values to vectors", "body": "<h1>After Non-Lexical Lifetimes</h1>\n\n<p>Both versions of your code now work, thanks to <a href=\"https://stackoverflow.com/q/50251487/155423\">non-lexical lifetimes</a>.</p>\n\n<h1>Before Non-Lexical Lifetimes</h1>\n\n<p>Your problem can be simplified to this example:</p>\n\n<pre><code>fn main() {\n    let mut foos = Vec::new();\n    let y = &amp;42;\n    foos.push(y);\n}\n</code></pre>\n\n<p>The important thing to remember in this case is that variables are destroyed in the inverse order they are created. You could almost look at the code as</p>\n\n<pre><code>fn main() {\n    let mut foos = Vec::new();\n    {\n        let y = &amp;42;\n        {\n            foos.push(y);\n        }\n        // destroy y\n    }}\n    // destroy foos\n}\n</code></pre>\n\n<p>For simple values like I am showing, this doesn't really matter, but it's more important when you have complicated types that have custom <code>Drop</code> implementations.</p>\n\n<p>A simple fix is to reorder the statements:</p>\n\n<pre><code>fn main() {\n    let y = &amp;42;\n    let mut foos = Vec::new();\n    foos.push(y);\n}\n</code></pre>\n\n<p>Now, it's guaranteed that the thing being referred to <em>lives longer</em> than the reference stored in the vector. For your original reduced example, this works:</p>\n\n<pre><code>let y = Bar { value: \"Hello, world!\" };\nlet x = Foo { bar: &amp;y };\nlet mut foos = Vec::new();\nfoos.push(x);\n</code></pre>\n\n<p>Your original code has a bit trickier problem. Let's look at the expansion of the <code>vec!</code> macro:</p>\n\n<pre><code>let foos = &lt;[_]&gt;::into_vec(Box::new([Foo { bar: &amp;(Bar { value: \"a\" }) }]));\n</code></pre>\n\n<p>Which we can simplify down to</p>\n\n<pre><code>let foos = Box::new(&amp;42);\n</code></pre>\n\n<p>The problem is that the temporary variable is, well, <em>temporary</em>. It only exists for the duration of the function call. This means that the reference to the temporary variable can't last longer than that. That's why the error message suggests <em>\"consider using a <code>let</code> binding to increase its lifetime\"</em>. By doing so, the variable will live longer than the function call.</p>\n\n<blockquote>\n  <p>Is it possible to make the temporary value last longer without using a let statement? The vector will have many values, say 30. So I'll have to place 30 let statements?</p>\n</blockquote>\n\n<p>No, you have to be explicit about how long they <em>should</em> live, so you need to be explicit about where they are. I see two solutions:</p>\n\n<ol>\n<li><p>Change your structures so that they own items, instead of referring to them:</p>\n\n<pre><code>struct Foo&lt;T&gt; {\n    bar: T,\n}\n\nlet foos = vec![\n    Foo { bar: Bar { value: \"a\" } },\n    Foo { bar: Bar { value: \"b\" } },\n];\n</code></pre></li>\n<li><p>Create a vector that owns all the inner types, then map over it to get references:</p>\n\n<pre><code>let bars = vec![Bar { value: \"a\" }, Bar { value: \"b\" }];\nlet foos: Vec&lt;_&gt; = bars.iter().map(|bar| Foo { bar: bar }).collect();\n</code></pre></li>\n</ol>\n"}], "owner": {"reputation": 1741, "user_id": 639465, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/00f1bf67a52fc75fb6da011edcf3f42b?s=128&d=identicon&r=PG", "display_name": "caio", "link": "https://stackoverflow.com/users/639465/caio"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 592, "favorite_count": 0, "accepted_answer_id": 29580628, "answer_count": 1, "score": 4, "last_activity_date": 1554256328, "creation_date": 1428770096, "last_edit_date": 1554256239, "question_id": 29580295, "link": "https://stackoverflow.com/questions/29580295/lifetimes-when-adding-temporary-values-to-vectors", "title": "Lifetimes when adding temporary values to vectors", "body": "<p>I'm having some problems trying to understand how Rust lifetimes works in some situations, like below. I can't get it working but I'm not sure why.</p>\n\n<pre><code>struct Bar {\n    value: &amp;'static str,\n}\n\nstruct Foo&lt;'a, T: 'a&gt; {\n    bar: &amp;'a T,\n}\n\nfn main() {\n    let mut foos = Vec::new();\n\n    let y = Bar {\n        value: \"Hello, world!\",\n    };\n    let x = Foo { bar: &amp;y };\n\n    foos.push(x);\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0597]: `y` does not live long enough\n  --&gt; src/main.rs:15:25\n   |\n15 |     let x = Foo { bar: &amp;y };\n   |                         ^ borrowed value does not live long enough\n...\n18 | }\n   | - `y` dropped here while still borrowed\n   |\n   = note: values in a scope are dropped in the opposite order they are created\n</code></pre>\n\n<p>This is a simplified example of what I'm actually trying to achieve:</p>\n\n<pre><code>fn main() {\n    let foos = vec![\n        Foo { bar: &amp;(Bar { value: \"a\" }) },\n        Foo { bar: &amp;(Bar { value: \"b\" }) },\n    ];\n}\n</code></pre>\n\n<p>I'd appreciate any ideas, thoughts or explanations.</p>\n"}, {"tags": ["c", "rust", "language-design"], "comments": [{"owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "edited": false, "score": 2, "creation_date": 1428769753, "post_id": 29580191, "comment_id": 47308829, "body": "I think that syntax has more to do with the background of rust&#39;s creators. The <code>x: type</code> is used by ML, and ML has influenced the design of Rust (as far as I know, the original rust compiler was written in OCaml)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1428770799, "post_id": 29580191, "comment_id": 47309180, "body": "What&#39;s the benefit of the way C does it?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1428772926, "post_id": 29580191, "comment_id": 47309942, "body": "One downside of the C way is the <a href=\"http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html\" rel=\"nofollow noreferrer\">Right-Left rule</a>"}, {"owner": {"reputation": 34083, "user_id": 1287251, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/IQkBy.png?s=128&g=1", "display_name": "Cornstalks", "link": "https://stackoverflow.com/users/1287251/cornstalks"}, "edited": false, "score": 1, "creation_date": 1428774319, "post_id": 29580191, "comment_id": 47310408, "body": "My guess is that it&#39;s easier to parse like that. Given Rust&#39;s type inference, putting the variable type <i>after</i> the variable allows for it to be ommitted at times (yet still easily parsed). The parameter syntax is roughly consistent with normal variable declaration (it would be weird if Rust&#39;s function parameters were declared like they are in C, given that it would be totally inconsistent with how other Rust variables can be declared)."}, {"owner": {"reputation": 228853, "user_id": 827263, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/216c1db53d752f87dd8176a6ba0c2190?s=128&d=identicon&r=PG", "display_name": "Keith Thompson", "link": "https://stackoverflow.com/users/827263/keith-thompson"}, "edited": false, "score": 3, "creation_date": 1428776406, "post_id": 29580191, "comment_id": 47311119, "body": "The <code>var: type</code> syntax goes back <i>at least</i> to Pascal."}], "answers": [{"comments": [{"owner": {"reputation": 213217, "user_id": 41071, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/0ec0f5be7749c8cc8ccda4a809103f36?s=128&d=identicon&r=PG", "display_name": "svick", "link": "https://stackoverflow.com/users/41071/svick"}, "edited": false, "score": 0, "creation_date": 1428777722, "post_id": 29581386, "comment_id": 47311580, "body": "There are C-style languages with optional types for local variables: <code>auto</code> in C++ and <code>var</code> in C#. So it is possible."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1428789736, "post_id": 29581386, "comment_id": 47315220, "body": "It&#39;s not obvious to me why <code>let</code> clashes with omitting the type. Yes, you need <code>let</code>, but for other reasons, and if <code>let type var</code> should be easier to parse than <code>type var</code>, as the <code>let</code> already cues you in for a declaration. Mind you, I&#39;m not saying <code>type var</code> has no problems (I&#39;m fairly certain it has), I&#39;m just not sold on what is written in this answer."}], "tags": [], "owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "is_accepted": false, "score": 0, "last_activity_date": 1428776121, "creation_date": 1428776121, "answer_id": 29581386, "question_id": 29580191, "link": "https://stackoverflow.com/questions/29580191/what-is-the-purpose-of-rusts-function-parameter-syntax-over-cs/29581386#29581386", "title": "What is the purpose of Rust&#39;s function parameter syntax over C&#39;s?", "body": "<p>In normal Rust code a variable is declared this way:</p>\n\n<pre><code>let x : i32 = 0;\n</code></pre>\n\n<p>The C style is not possible because the type is optional, so the former is equivalent to this one:</p>\n\n<pre><code>let x = 0i32;\n</code></pre>\n\n<p>You need the <code>let</code> keyword to declare the intention of declaring a name.</p>\n\n<p>In a function declaration the type is mandatory, the initialization is not allowed and the <code>let</code> keyword makes no sense. Other than that the syntax is the same:</p>\n\n<pre><code>fn foo(x : i32)\n</code></pre>\n\n<p>It would be weird to have a different syntax for declaring local variables and function arguments, don't you think?</p>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 7, "last_activity_date": 1428843089, "creation_date": 1428843089, "answer_id": 29589665, "question_id": 29580191, "link": "https://stackoverflow.com/questions/29580191/what-is-the-purpose-of-rusts-function-parameter-syntax-over-cs/29589665#29589665", "title": "What is the purpose of Rust&#39;s function parameter syntax over C&#39;s?", "body": "<p>The declaration of a function argument is just a special case of variable declarations in Rust, therefore the answer to your question lies in variable declaration in general.</p>\n\n<p>Let us start with C:</p>\n\n<pre><code>a b = 1;\na = 2;\n</code></pre>\n\n<p>From a grammar point of view, C is not quite regular:</p>\n\n<ul>\n<li>in <code>a b = 1;</code>, <code>a</code> is the type and <code>b</code> is the name of a new variable being declared (and initialized)</li>\n<li>in <code>a = 1;</code>, <code>a</code> is the name of a variable that was declared previously and is now either initialized or assigned a new value (overwriting the previous one).</li>\n</ul>\n\n<p>Therefore, in C, knowing whether <code>a</code> is a type or a variable name requires looking ahead (ie, if followed by another variable then it's a type, otherwise it's a variable).</p>\n\n<p>Now, in Rust:</p>\n\n<pre><code>let a = 1;\na = 2;\n</code></pre>\n\n<p>The syntax for introducing a new variable requires using the <code>let</code> keyword, there is no ambiguity and no need to look ahead to disambiguate. This is all the more important because of shadowing in Rust (<code>let a = ...; let a = a.foo;</code>).</p>\n\n<p>The question was about types though, so let's extend the example:</p>\n\n<pre><code>let a: b = 1;\na = 2;\n</code></pre>\n\n<p>In this case, again, there is no need to look ahead. Immediately after <code>let</code> comes the variable name, and only after parsing a <code>:</code> comes the variable type.</p>\n\n<p>Therefore, the syntax of Rust is simply meant to avoid look ahead (Rust aims at having a LL(1) syntax) and the syntax of function arguments simply follows the regular syntax.</p>\n\n<p>Oh, and by the way, not all arguments have a type:</p>\n\n<pre><code>impl Foo {\n    fn doit(&amp;self);\n}\n</code></pre>\n"}], "owner": {"reputation": 1553, "user_id": 3839220, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/8062ce7db5476fc8d470bba1e7cc785d?s=128&d=identicon&r=PG&f=1", "display_name": "metro-man", "link": "https://stackoverflow.com/users/3839220/metro-man"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 568, "favorite_count": 0, "accepted_answer_id": 29589665, "answer_count": 2, "score": 4, "last_activity_date": 1428843089, "creation_date": 1428769512, "last_edit_date": 1428774058, "question_id": 29580191, "link": "https://stackoverflow.com/questions/29580191/what-is-the-purpose-of-rusts-function-parameter-syntax-over-cs", "title": "What is the purpose of Rust&#39;s function parameter syntax over C&#39;s?", "body": "<p>Weird title, anyway, in C function parameters are as follows:</p>\n\n<pre><code>void func_name(int a, int b) {\n\n}\n</code></pre>\n\n<p>However in Rust:</p>\n\n<pre><code>fn func_name(a: int, b: int) {\n\n}\n</code></pre>\n\n<p>Is this just a preference in syntax and was appealing to the creators of Rust, or is this for a specific purpose that I don't know about? For example, Go has \"optional semi-colons\", but they are actually to show when an expression ends. Please bare in mind that I'm a complete novice at Rust, so if you try to provide some fancy examples in Rust I probably wont understand :(</p>\n"}, {"tags": ["closures", "rust", "lifetime"], "comments": [{"owner": {"reputation": 41, "user_id": 4777396, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/164b99d6b198a2c17dd9b60276adcb00?s=128&d=identicon&r=PG&f=1", "display_name": "syakhmi", "link": "https://stackoverflow.com/users/4777396/syakhmi"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1428780087, "post_id": 29579944, "comment_id": 47312334, "body": "Done :) I don&#39;t think the question is fully answered though. In particular why the function and closure behave differently, and what exactly the conflicting lifetime requirements are referred to in the compiler error."}], "answers": [{"tags": [], "owner": {"reputation": 41, "user_id": 4777396, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/164b99d6b198a2c17dd9b60276adcb00?s=128&d=identicon&r=PG&f=1", "display_name": "syakhmi", "link": "https://stackoverflow.com/users/4777396/syakhmi"}, "is_accepted": true, "score": 1, "last_activity_date": 1490049528, "last_edit_date": 1490049528, "creation_date": 1428779870, "answer_id": 29582008, "question_id": 29579944, "link": "https://stackoverflow.com/questions/29579944/how-do-i-return-a-reference-to-a-closures-argument-from-the-closure/29582008#29582008", "title": "How do I return a reference to a closure&#39;s argument from the closure?", "body": "<p>I think I was confusing the lifetime of reference to the <code>Person</code> with the lifetime parameter of the struct (of the <code>&amp;str</code> reference). This compiles:</p>\n\n<pre><code>struct Person&lt;'a&gt; {\n    name: &amp;'a str,\n}\n\nimpl&lt;'a&gt; Person&lt;'a&gt; {\n    fn map&lt;F, T&gt;(&amp;self, closure: F) -&gt; T\n        where F: Fn(&amp;Person&lt;'a&gt;) -&gt; T\n    {\n        closure(self)\n    }\n}\n\nfn get_name&lt;'a&gt;(person: &amp;Person&lt;'a&gt;) -&gt; &amp;'a str {\n    person.name\n}\n\nfn main() {\n    let p = Person { name: \"hello\" };\n    println!(\"{:?}\", p.map(|person| person.name));\n    println!(\"{:?}\", p.map(get_name));\n}\n</code></pre>\n\n<p>I'm not sure if my understanding of the lifetime annotations is correct, and perhaps someone else can pick apart the compiler error above. The language is extremely confusing.</p>\n"}], "owner": {"reputation": 41, "user_id": 4777396, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/164b99d6b198a2c17dd9b60276adcb00?s=128&d=identicon&r=PG&f=1", "display_name": "syakhmi", "link": "https://stackoverflow.com/users/4777396/syakhmi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 387, "favorite_count": 1, "accepted_answer_id": 29582008, "answer_count": 1, "score": 3, "last_activity_date": 1490049528, "creation_date": 1428768173, "last_edit_date": 1490049496, "question_id": 29579944, "link": "https://stackoverflow.com/questions/29579944/how-do-i-return-a-reference-to-a-closures-argument-from-the-closure", "title": "How do I return a reference to a closure&#39;s argument from the closure?", "body": "<p>I am a Rust newbie, and don't understand all the rules for lifetime elision and inference. I can't seem to get returning a reference into an argument from a closure to work, and the errors don't help much for someone with my amount of knowledge.</p>\n\n<p>I can use a proper function with lifetime annotations in place of a closure, but can't figure out a way to annotate these lifetimes on the closure.</p>\n\n<pre><code>struct Person&lt;'a&gt; {\n    name: &amp;'a str,\n}\n\nimpl&lt;'a&gt; Person&lt;'a&gt; {\n    fn map&lt;F, T&gt;(&amp;'a self, closure: F) -&gt; T\n        where F: Fn(&amp;'a Person) -&gt; T\n    {\n        closure(self)\n    }\n}\n\nfn get_name&lt;'a&gt;(person: &amp;'a Person) -&gt; &amp;'a str {\n    person.name\n}\n\nfn main() {\n    let p = Person { name: \"hello\" };\n    let s: &amp;str = p.map(|person| person.name); // Does not work\n    // let s: &amp;str = p.map(get_name);  // Works\n    println!(\"{:?}\", s);\n}\n</code></pre>\n\n<p>And here is the compiler error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n  --&gt; src/main.rs:19:34\n   |\n19 |     let s: &amp;str = p.map(|person| person.name); // Does not work\n   |                                  ^^^^^^^^^^^\n   |\nnote: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the body at 19:33...\n  --&gt; src/main.rs:19:34\n   |\n19 |     let s: &amp;str = p.map(|person| person.name); // Does not work\n   |                                  ^^^^^^^^^^^\nnote: ...so that expression is assignable (expected &amp;str, found &amp;str)\n  --&gt; src/main.rs:19:34\n   |\n19 |     let s: &amp;str = p.map(|person| person.name); // Does not work\n   |                                  ^^^^^^^^^^^\nnote: but, the lifetime must be valid for the method call at 19:18...\n  --&gt; src/main.rs:19:19\n   |\n19 |     let s: &amp;str = p.map(|person| person.name); // Does not work\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...so that pointer is not dereferenced outside its lifetime\n  --&gt; src/main.rs:19:19\n   |\n19 |     let s: &amp;str = p.map(|person| person.name); // Does not work\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n</code></pre>\n\n<p>What is happening here, and how to change the closure for it to work?</p>\n"}, {"tags": ["hash", "rust"], "answers": [{"comments": [{"owner": {"reputation": 692, "user_id": 155990, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/888f8b558f794e3a569778641e4bd3ab?s=128&d=identicon&r=PG", "display_name": "DorkRawk", "link": "https://stackoverflow.com/users/155990/dorkrawk"}, "edited": false, "score": 0, "creation_date": 1428770980, "post_id": 29573951, "comment_id": 47309251, "body": "This totally worked. Thanks. Do you know if the core team plans to have std::hash::hash stable for 1.0? I was confused because the docs listed this feature as stable here: <a href=\"http://doc.rust-lang.org/std/hash/index.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/hash/index.html</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 692, "user_id": 155990, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/888f8b558f794e3a569778641e4bd3ab?s=128&d=identicon&r=PG", "display_name": "DorkRawk", "link": "https://stackoverflow.com/users/155990/dorkrawk"}, "edited": false, "score": 0, "creation_date": 1428771487, "post_id": 29573951, "comment_id": 47309457, "body": "@DorkRawk Stability is finer-grained than that \u2014 the <i>module</i> is stable, but <a href=\"http://doc.rust-lang.org/std/hash/fn.hash.html\" rel=\"nofollow noreferrer\">the <i>function</i> is not</a>. Unfortunately, I don&#39;t know if the method is slated to be stabilized. It&#39;s kind of a special use case - most people don&#39;t want to get the hash code directly, anyway. What&#39;s your use case?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 11, "last_activity_date": 1513107468, "last_edit_date": 1513107468, "creation_date": 1428724818, "answer_id": 29573951, "question_id": 29573605, "link": "https://stackoverflow.com/questions/29573605/how-do-i-use-stdhashhash/29573951#29573951", "title": "How do I use std::hash::hash?", "body": "<p>The original question was trying to use a feature that was <em>unstable</em> - which means it isn't allowed to be used in a stable release, like 1.0-beta or 1.0. Since them, the function has been removed from the language. </p>\n\n<p>The replacement is to write your own version, which allows you to specify the hash function. Additionally, using <code>SipHasher</code> directly is deprecated. If you need a specific hashing algorithm, you should pull it from crates.io. Otherwise, you can use an unspecified hashing algorithm from the standard library:</p>\n\n<pre><code>use std::hash::{Hash, Hasher};\nuse std::collections::hash_map::DefaultHasher;\n\n#[derive(Hash)]\nstruct Person {\n    id: u32,\n    name: String,\n    phone: u64,\n}\n\nfn my_hash&lt;T&gt;(obj: T) -&gt; u64\nwhere\n    T: Hash,\n{\n    let mut hasher = DefaultHasher::new();\n    obj.hash(&amp;mut hasher);\n    hasher.finish()\n}\n\nfn main() {\n    let person1 = Person {\n        id: 5,\n        name: \"Janet\".to_string(),\n        phone: 555_666_7777,\n    };\n    let person2 = Person {\n        id: 5,\n        name: \"Bob\".to_string(),\n        phone: 555_666_7777,\n    };\n\n    println!(\"{}\", my_hash(person1));\n    println!(\"{}\", my_hash(person2));\n}\n</code></pre>\n"}], "owner": {"reputation": 692, "user_id": 155990, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/888f8b558f794e3a569778641e4bd3ab?s=128&d=identicon&r=PG", "display_name": "DorkRawk", "link": "https://stackoverflow.com/users/155990/dorkrawk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5671, "favorite_count": 0, "accepted_answer_id": 29573951, "answer_count": 1, "score": 8, "last_activity_date": 1513107468, "creation_date": 1428721505, "last_edit_date": 1513107432, "question_id": 29573605, "link": "https://stackoverflow.com/questions/29573605/how-do-i-use-stdhashhash", "title": "How do I use std::hash::hash?", "body": "<p>I am trying to play with Rust's <code>std::hash</code> function:</p>\n\n<pre><code>use std::hash::{hash, Hash, SipHasher};\n\n#[test]\nfn hash_test() {\n    println!(\"{}\", hash::&lt;_, SipHasher&gt;(&amp;\"hello\"));\n}\n</code></pre>\n\n<p>I get this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: use of unstable library feature 'hash': module was recently redesigned\n</code></pre>\n\n<p>My Rust version is:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>rustc 1.0.0-beta (9854143cb 2015-04-02) (built 2015-04-02)\n</code></pre>\n\n<p>Is this syntax no longer valid?</p>\n"}, {"tags": ["arrays", "rust", "slice"], "answers": [{"comments": [{"owner": {"reputation": 4208, "user_id": 2343847, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/cf8c5e3c346c7734cb1ff728264f6cfb?s=128&d=identicon&r=PG", "display_name": "aij", "link": "https://stackoverflow.com/users/2343847/aij"}, "edited": false, "score": 0, "creation_date": 1428854791, "post_id": 29589604, "comment_id": 47329968, "body": "Could that be made safe using a macro instead?"}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "reply_to_user": {"reputation": 4208, "user_id": 2343847, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/cf8c5e3c346c7734cb1ff728264f6cfb?s=128&d=identicon&r=PG", "display_name": "aij", "link": "https://stackoverflow.com/users/2343847/aij"}, "edited": false, "score": 0, "creation_date": 1428873387, "post_id": 29589604, "comment_id": 47336347, "body": "I would prefer to just implement the necessary marker traits on all small array sizes and use that to remove the unsafe. I guess it can be made safe with a macro."}], "tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": false, "score": 2, "last_activity_date": 1440536771, "last_edit_date": 1440536771, "creation_date": 1428842696, "answer_id": 29589604, "question_id": 29573599, "link": "https://stackoverflow.com/questions/29573599/proper-way-to-build-an-array-from-a-slice/29589604#29589604", "title": "Proper way to build an array from a slice?", "body": "<p>You can use a loop to solve it the straightforward (but maybe disappointing) way:</p>\n\n<pre><code>let input = b\"abcdef\";\nlet mut array = [0u8; 32];\nfor (x, y) in input.iter().zip(array.iter_mut()) {\n    *y = *x;\n}\n</code></pre>\n\n<p>We can use a function to do a runtime size check and turn a slice into a reference to a fixed size array.</p>\n\n<p>Libstd doesn't provide enough traits to reliably check that the input and output types match here, but we could in theory develop that ourselves (for a finite number of array types). Either way, the cast looks like this, <strong>U</strong> is arbitrary array type you specify.</p>\n\n<pre><code>/// Return a reference to a fixed size array from a slice.\n///\n/// Return **Some(array)** if the dimensions match, **None** otherwise.\n///\n/// **Note:** Unsafe because we can't check if the **U** type is really an array.\npub unsafe fn as_array&lt;T, U&gt;(xs: &amp;[T]) -&gt; Option&lt;&amp;U&gt; where\n    U: AsRef&lt;[T]&gt;,\n{\n    let sz = std::mem::size_of::&lt;U&gt;();\n    let input_sz = xs.len() * std::mem::size_of::&lt;T&gt;();\n\n    // The size check could be relaxed to sz &lt;= input_sz\n    if sz == input_sz {\n        Some(&amp;*(xs.as_ptr() as *const U))\n    } else {\n        None\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 4208, "user_id": 2343847, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/cf8c5e3c346c7734cb1ff728264f6cfb?s=128&d=identicon&r=PG", "display_name": "aij", "link": "https://stackoverflow.com/users/2343847/aij"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2865, "favorite_count": 0, "closed_date": 1465302961, "answer_count": 1, "score": 3, "last_activity_date": 1440536771, "creation_date": 1428721443, "last_edit_date": 1495542159, "question_id": 29573599, "link": "https://stackoverflow.com/questions/29573599/proper-way-to-build-an-array-from-a-slice", "closed_reason": "Duplicate", "title": "Proper way to build an array from a slice?", "body": "<p>Ok, this seems a bit silly, but I'm having trouble finding a function to return a statically sized array from the contents of a slice.</p>\n\n<p>The Rust Book sections on arrays and slices says nothing about it. (It does show how to take a slice from an array, but I want to go the other way.) I also checked the documentation for <a href=\"https://doc.rust-lang.org/std/slice/\" rel=\"nofollow noreferrer\"><code>std::slice</code></a> and <a href=\"https://doc.rust-lang.org/std/primitive.array.html\" rel=\"nofollow noreferrer\"><code>std::array</code></a>, but if it's there, I'm not seeing it.</p>\n\n<p>There is of course the option of writing out each element one by one, but that seems ridiculous. For now, I ended up writing a python one-liner to do it for me.</p>\n\n<pre><code>\", \".join([\"k[{}]\".format(i) for i in range(32)])\n</code></pre>\n\n<p>So I ended up with this:</p>\n\n<pre><code>use db_key::Key;\n\n#[derive(Clone)]\npub struct Sha256{\n    bits : [u8;32]\n}\n\nimpl Key for Sha256 {\n    fn from_u8(k: &amp;[u8]) -&gt; Self {\n        Sha256{bits:\n               // FIXME: This is dumb.\n               [ k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8], k[9], k[10], k[11], k[12], k[13], k[14], k[15], k[16], k[17], k[18], k[19], k[20], k[21], k[22], k[23], k[24], k[25], k[26], k[27], k[28], k[29], k[30], k[31] ]\n        }\n    }\n    fn as_slice&lt;T, F: Fn(&amp;[u8]) -&gt; T&gt;(&amp;self, f: F) -&gt; T {\n        f(&amp;self.bits)\n    }\n}\n</code></pre>\n\n<p>I'd like to know if there's a proper way, like <code>k.to_array(32)</code> or something along those lines.</p>\n\n<p>And, yes, I realize the above code could fail with out-of-bounds access. I'm not sure what <code>db_key::Key</code> expects on invalid input.</p>\n\n<p>Edit:</p>\n\n<p><a href=\"https://stackoverflow.com/questions/29570607/is-there-a-good-way-to-convert-a-vect-to-an-array\">Is there a good way to convert a Vec to an array?</a> is similar but less general. A good answer to this will probably also be a good answer to that question with the addition of taking a slice from the <code>vec</code>, which can be done efficiently and concisely. I also don't consider \"write a separate conversion function for each size you care about\" to be a proper solution.</p>\n\n<p><a href=\"https://stackoverflow.com/questions/25428920/how-to-get-a-slice-as-a-static-array-in-rust\">How to get a slice as a static array in rust?</a> is also similar, but the accepted answer is the hack I had already come up with independently.</p>\n"}, {"tags": ["rust", "ownership", "borrow-checker"], "comments": [{"owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "edited": false, "score": 1, "creation_date": 1428702245, "post_id": 29570781, "comment_id": 47291658, "body": "If you add a <code>Copy</code> bound to <code>T</code>, your code actually works, although I obviously don&#39;t know if you&#39;re ok with that restriction."}], "answers": [{"comments": [{"owner": {"reputation": 454, "user_id": 2340672, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2f310ac7326625ce5f21de2937300b30?s=128&d=identicon&r=PG", "display_name": "azgult", "link": "https://stackoverflow.com/users/2340672/azgult"}, "edited": false, "score": 0, "creation_date": 1428704091, "post_id": 29571345, "comment_id": 47292382, "body": "It makes little sense for me to require the caller of the method to own <code>Foo</code>, when it is possible to implement it using only a <code>&amp;mut</code>. Ownership shouldn&#39;t be required in this case, as the integrity of <code>self</code> can be guaranteed."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 454, "user_id": 2340672, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2f310ac7326625ce5f21de2937300b30?s=128&d=identicon&r=PG", "display_name": "azgult", "link": "https://stackoverflow.com/users/2340672/azgult"}, "edited": false, "score": 0, "creation_date": 1428704385, "post_id": 29571345, "comment_id": 47292485, "body": "@azgult and that&#39;s exactly the reason why a lot of people request <code>&amp;own</code>-like pointer (see the links to RFC and issue I provided) - because such thing in fact <i>do</i> require ownership (<i>only</i> owner can move values around)."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 4, "last_activity_date": 1428703298, "creation_date": 1428703298, "answer_id": 29571345, "question_id": 29570781, "link": "https://stackoverflow.com/questions/29570781/temporarily-move-out-of-borrowed-content/29571345#29571345", "title": "Temporarily move out of borrowed content", "body": "<blockquote>\n  <p>The code above doesn't work, and understandibly so, moving the value\n  out of self breaks the integrity of it.</p>\n</blockquote>\n\n<p>This is not exactly what happens here. For example, same thing with <code>self</code> would work nicely:</p>\n\n<pre><code>impl&lt;T&gt; Foo&lt;T&gt; {\n    fn switch(self) {\n        self = match self {\n            Foo::Bar(val) =&gt; Foo::Baz(val),\n            Foo::Baz(val) =&gt; Foo::Bar(val),\n        }\n    }\n}\n</code></pre>\n\n<p>Rust is absolutely fine with partial and total moves. The problem here is that you do not own the value you're trying to move - you only have a mutable borrowed reference. You cannot move out of any reference, including mutable ones.</p>\n\n<p>This is in fact one of the frequently requested features - a special kind of reference which would allow moving out of it. It would allow several kinds of useful patterns. You can find more <a href=\"https://github.com/rust-lang/rfcs/issues/998\" rel=\"nofollow\">here</a> and <a href=\"https://github.com/rust-lang/rfcs/pull/965\" rel=\"nofollow\">here</a>.</p>\n\n<p>In the meantime for some cases you can use <a href=\"http://doc.rust-lang.org/std/mem/fn.replace.html\" rel=\"nofollow\"><code>std::mem::replace</code></a> and <a href=\"http://doc.rust-lang.org/std/mem/fn.swap.html\" rel=\"nofollow\"><code>std::mem::swap</code></a>. These functions allow you to \"take\" a value out of mutable reference, provided you give something in exchange.</p>\n"}, {"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 4, "creation_date": 1428704812, "post_id": 29571384, "comment_id": 47292627, "body": "This program will fail horribly if <code>T</code> has destructor. When you call <code>swap</code> you&#39;re replacing whatever is located at <code>self</code> with garbage. Then you reassign <code>*self</code>, and Rust will insert a call to destructor which would attempt to destroy the &quot;old&quot; value of <code>*self</code>, which is now garbage. For some reason <a href=\"http://is.gd/uaIhEe\" rel=\"nofollow noreferrer\">playpen</a> does not fail (but you can see double free there), but for me that program core dumps when I compile and run it locally."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1428705094, "post_id": 29571384, "comment_id": 47292712, "body": "<a href=\"http://is.gd/yT03vG\" rel=\"nofollow noreferrer\">This</a> program more clearly demonstrates when and how a destructor is called. If your program was safe, it would be called only once, but it is called twice - the first time being erroneous."}, {"owner": {"reputation": 454, "user_id": 2340672, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2f310ac7326625ce5f21de2937300b30?s=128&d=identicon&r=PG", "display_name": "azgult", "link": "https://stackoverflow.com/users/2340672/azgult"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1428705698, "post_id": 29571384, "comment_id": 47292918, "body": "Good catch. I believe that the modified version which uses <code>std::ptr::write</code> should be safe however."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1446801831, "post_id": 29571384, "comment_id": 54904857, "body": "no it&#39;s not safe, now you are actually dropping uninitialized memory. You need to <code>mem::forget</code> the <code>tmp</code> variable after the <code>write</code> call"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1505592338, "post_id": 29571384, "comment_id": 79479470, "body": "@oli_obk-ker I rewrote the answer based on these comments because it was being linked to; how does it look now?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1505592347, "post_id": 29571384, "comment_id": 79479477, "body": "@VladimirMatveev I rewrote the answer based on these comments because it was being linked to; how does it look now?"}, {"owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "edited": false, "score": 1, "creation_date": 1511623829, "post_id": 29571384, "comment_id": 81930056, "body": "<a href=\"https://docs.rs/take_mut/0.2.0/take_mut/fn.take.html\" rel=\"nofollow noreferrer\"><code>take</code></a> shows how to do this in a generic way, and also protects against unwinding (aborts instead)."}], "tags": [], "owner": {"reputation": 454, "user_id": 2340672, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2f310ac7326625ce5f21de2937300b30?s=128&d=identicon&r=PG", "display_name": "azgult", "link": "https://stackoverflow.com/users/2340672/azgult"}, "is_accepted": false, "score": 5, "last_activity_date": 1505592308, "last_edit_date": 1505592308, "creation_date": 1428703530, "answer_id": 29571384, "question_id": 29570781, "link": "https://stackoverflow.com/questions/29570781/temporarily-move-out-of-borrowed-content/29571384#29571384", "title": "Temporarily move out of borrowed content", "body": "<p>Okay, I figured out how to do it with a bit of <code>unsafe</code>ness and <code>std::mem</code>.</p>\n\n<p>I replace <code>self</code> with an uninitialized temporary value. Since I now \"own\" what used to be <code>self</code>, I can safely move the value out of it and replace it:</p>\n\n<pre><code>use std::mem;\n\nenum Foo&lt;T&gt; {\n    Bar(T),\n    Baz(T),\n}\n\nimpl&lt;T&gt; Foo&lt;T&gt; {\n    fn switch(&amp;mut self) {\n        // This is safe since we will overwrite it without ever reading it.\n        let tmp = mem::replace(self, unsafe { mem::uninitialized() });\n        // We absolutely must **never** panic while the uninitialized value is around!\n\n        let new = match tmp {\n            Foo::Bar(val) =&gt; Foo::Baz(val),\n            Foo::Baz(val) =&gt; Foo::Bar(val),\n        };\n\n        let uninitialized = mem::replace(self, new);\n        mem::forget(uninitialized);\n    }\n}\n\nfn main() {}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1604352078, "last_edit_date": 1604352078, "creation_date": 1582569749, "answer_id": 60382120, "question_id": 29570781, "link": "https://stackoverflow.com/questions/29570781/temporarily-move-out-of-borrowed-content/60382120#60382120", "title": "Temporarily move out of borrowed content", "body": "<p><a href=\"https://doc.rust-lang.org/std/mem/fn.uninitialized.html\" rel=\"nofollow noreferrer\"><code>mem:uninitialized</code></a> has been deprecated since Rust 1.39, replaced by <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\" rel=\"nofollow noreferrer\"><code>MaybeUninit</code></a>.</p>\n<p>However, uninitialized data is not required here. Instead, you can use <code>ptr::read</code> to get the data referred to by <code>self</code>.</p>\n<p>At this point, <code>tmp</code> has ownership of the data in the enum, but if we were to drop <code>self</code>, that data would attempt to be read by the destructor, causing memory unsafety.</p>\n<p>We then perform our transformation and put the value back, restoring the safety of the type.</p>\n<pre><code>use std::ptr;\n\nenum Foo&lt;T&gt; {\n    Bar(T),\n    Baz(T),\n}\n\nimpl&lt;T&gt; Foo&lt;T&gt; {\n    fn switch(&amp;mut self) {\n        // I copied this code from Stack Overflow without reading\n        // the surrounding text that explains why this is safe.\n        unsafe {\n            let tmp = ptr::read(self);\n    \n            // Must not panic before we get to `ptr::write`\n\n            let new = match tmp {\n                Foo::Bar(val) =&gt; Foo::Baz(val),\n                Foo::Baz(val) =&gt; Foo::Bar(val),\n            };\n    \n            ptr::write(self, new);\n        }\n    }\n}\n</code></pre>\n<p>More advanced versions of this code would <strong>prevent</strong> a panic from bubbling out of this code and instead cause the program to abort.</p>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://crates.io/crates/replace_with\" rel=\"nofollow noreferrer\">replace_with</a>, a crate that wraps this logic up.</li>\n<li><a href=\"https://crates.io/crates/take_mut\" rel=\"nofollow noreferrer\">take_mut</a>, a crate that wraps this logic up.</li>\n<li><a href=\"https://stackoverflow.com/q/36557412/155423\">Change enum variant while moving the field to the new variant</a></li>\n</ul>\n"}], "owner": {"reputation": 454, "user_id": 2340672, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2f310ac7326625ce5f21de2937300b30?s=128&d=identicon&r=PG", "display_name": "azgult", "link": "https://stackoverflow.com/users/2340672/azgult"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1592, "favorite_count": 0, "answer_count": 3, "score": 7, "last_activity_date": 1604352078, "creation_date": 1428700376, "last_edit_date": 1428700687, "question_id": 29570781, "link": "https://stackoverflow.com/questions/29570781/temporarily-move-out-of-borrowed-content", "title": "Temporarily move out of borrowed content", "body": "<p>I'm tring to replace a value in a mutable borrow; moving part of it into the new value:</p>\n\n<pre><code>enum Foo&lt;T&gt; {\n    Bar(T),\n    Baz(T),\n}\n\nimpl&lt;T&gt; Foo&lt;T&gt; {\n    fn switch(&amp;mut self) {\n        *self = match self {\n            &amp;mut Foo::Bar(val) =&gt; Foo::Baz(val),\n            &amp;mut Foo::Baz(val) =&gt; Foo::Bar(val),\n        }\n    }\n}\n</code></pre>\n\n<p>The code above doesn't work, and understandibly so, moving the value out of <code>self</code> breaks the integrity of it. But since that value is dropped immediately afterwards, I (if not the compiler) could guarantee it's safety.</p>\n\n<p>Is there some way to achieve this? I feel like this is a job for unsafe code, but I'm not sure how that would work.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 1003, "user_id": 1103760, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/OInfA.png?s=128&g=1", "display_name": "don bright", "link": "https://stackoverflow.com/users/1103760/don-bright"}, "edited": false, "score": 0, "creation_date": 1547268298, "post_id": 29570607, "comment_id": 95144181, "body": "it&#39;s one line. use itertools:Itertools; my_array.iter_mut().set_from(my_vector.iter().cloned());"}, {"owner": {"reputation": 2409, "user_id": 2284570, "user_type": "registered", "accept_rate": 44, "profile_image": "https://www.gravatar.com/avatar/9bd1d26aad2cfb7ece066d94c128d529?s=128&d=identicon&r=PG", "display_name": "user2284570", "link": "https://stackoverflow.com/users/2284570/user2284570"}, "reply_to_user": {"reputation": 1003, "user_id": 1103760, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/OInfA.png?s=128&g=1", "display_name": "don bright", "link": "https://stackoverflow.com/users/1103760/don-bright"}, "edited": false, "score": 0, "creation_date": 1609069181, "post_id": 29570607, "comment_id": 115739968, "body": "@donbright doesn t this result in a memory allocation?"}, {"owner": {"reputation": 1003, "user_id": 1103760, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/OInfA.png?s=128&g=1", "display_name": "don bright", "link": "https://stackoverflow.com/users/1103760/don-bright"}, "edited": false, "score": 0, "creation_date": 1609097789, "post_id": 29570607, "comment_id": 115747699, "body": "i am sorry im not 100% sure what you mean.... you can view the generated assembler here (click the ... by Run and hit ASM): <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=088605093493b42833e08b8698841f20\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}, {"owner": {"reputation": 1003, "user_id": 1103760, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/OInfA.png?s=128&g=1", "display_name": "don bright", "link": "https://stackoverflow.com/users/1103760/don-bright"}, "edited": false, "score": 0, "creation_date": 1609098732, "post_id": 29570607, "comment_id": 115747929, "body": "looking back at this now, the user, depending on intended platform, may be able to use a unsafe transmute, which would in theory eliminate copying (&quot;memory allocation&quot;?) .. and allow to use the bytes as-is"}], "answers": [{"comments": [{"owner": {"reputation": 336, "user_id": 2543937, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/uzQpz.jpg?s=128&g=1", "display_name": "Alien_AV", "link": "https://stackoverflow.com/users/2543937/alien-av"}, "edited": false, "score": 0, "creation_date": 1601310463, "post_id": 29570662, "comment_id": 113361321, "body": "For me, this fails with <code>the trait `std::convert::From&lt;std::boxed::Box&lt;[T]&gt;&gt;` is not implemented for `std::boxed::Box&lt;[T; 3]&gt;`</code>. Is this new? (The vector I supply is size 3, and I&#39;ve changed the &quot;demo&quot; function accordingly)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 336, "user_id": 2543937, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/uzQpz.jpg?s=128&g=1", "display_name": "Alien_AV", "link": "https://stackoverflow.com/users/2543937/alien-av"}, "edited": false, "score": 1, "creation_date": 1601310809, "post_id": 29570662, "comment_id": 113361453, "body": "@Alien_AV <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=779b1789e20d5fda0ac16f0db669fded\" rel=\"nofollow noreferrer\">works for me</a>."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 51, "last_activity_date": 1617029716, "last_edit_date": 1617029716, "creation_date": 1428699874, "answer_id": 29570662, "question_id": 29570607, "link": "https://stackoverflow.com/questions/29570607/is-there-a-good-way-to-convert-a-vect-to-an-array/29570662#29570662", "title": "Is there a good way to convert a Vec&lt;T&gt; to an array?", "body": "<p>Arrays must be completely initialized, so you quickly run into concerns about what to do when you convert a vector with too many or too few elements into an array. These examples simply panic.</p>\n<p>As of <a href=\"https://github.com/rust-lang/rust/blob/1.51.0/RELEASES.md#version-1510-2021-03-25\" rel=\"noreferrer\">Rust 1.51</a> you can parameterize over an array's length.</p>\n<pre><code>use std::convert::TryInto;\n\nfn demo&lt;T, const N: usize&gt;(v: Vec&lt;T&gt;) -&gt; [T; N] {\n    v.try_into()\n        .unwrap_or_else(|v: Vec&lt;T&gt;| panic!(&quot;Expected a Vec of length {} but it was {}&quot;, N, v.len()))\n}\n</code></pre>\n<p>As of <a href=\"https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1480-2020-11-19\" rel=\"noreferrer\">Rust 1.48</a>, each size needs to be a specialized implementation:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>use std::convert::TryInto;\n\nfn demo&lt;T&gt;(v: Vec&lt;T&gt;) -&gt; [T; 4] {\n    v.try_into()\n        .unwrap_or_else(|v: Vec&lt;T&gt;| panic!(&quot;Expected a Vec of length {} but it was {}&quot;, 4, v.len()))\n}\n</code></pre>\n<p>As of Rust 1.43:</p>\n<pre><code>use std::convert::TryInto;\n\nfn demo&lt;T&gt;(v: Vec&lt;T&gt;) -&gt; [T; 4] {\n    let boxed_slice = v.into_boxed_slice();\n    let boxed_array: Box&lt;[T; 4]&gt; = match boxed_slice.try_into() {\n        Ok(ba) =&gt; ba,\n        Err(o) =&gt; panic!(&quot;Expected a Vec of length {} but it was {}&quot;, 4, o.len()),\n    };\n    *boxed_array\n}\n</code></pre>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/25428920/155423\">How to get a slice as an array in Rust?</a></li>\n<li><a href=\"https://stackoverflow.com/q/42264041/155423\">How do I get an owned value out of a `Box`?</a></li>\n<li><a href=\"https://stackoverflow.com/q/28136739/155423\">Is it possible to control the size of an array using the type parameter of a generic?</a></li>\n</ul>\n"}], "owner": {"reputation": 593, "user_id": 1517980, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/722cea0b243b1e748a2d58137c58baff?s=128&d=identicon&r=PG", "display_name": "jgray", "link": "https://stackoverflow.com/users/1517980/jgray"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 40348, "favorite_count": 8, "accepted_answer_id": 29570662, "answer_count": 1, "score": 58, "last_activity_date": 1617029716, "creation_date": 1428699586, "last_edit_date": 1428699686, "question_id": 29570607, "link": "https://stackoverflow.com/questions/29570607/is-there-a-good-way-to-convert-a-vect-to-an-array", "title": "Is there a good way to convert a Vec&lt;T&gt; to an array?", "body": "<p>Is there a good way to convert a <code>Vec&lt;T&gt;</code> with size <code>S</code> to an array of type <code>[T; S]</code>? Specifically, I'm using a function that returns a 128-bit hash as a <code>Vec&lt;u8&gt;</code>, which will always have length 16, and I would like to deal with the hash as a <code>[u8, 16]</code>. </p>\n\n<p>Is there something built-in akin to the <code>as_slice</code> method which gives me what I want, or should I write my own function which allocates a fixed-size array, iterates through the vector copying each element, and returns the array?</p>\n"}, {"tags": ["iterator", "closures", "rust"], "answers": [{"comments": [{"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1428779092, "post_id": 29571020, "comment_id": 47312045, "body": "To me the Box makes no sense, am I missing something?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1428780383, "last_edit_date": 1495542806, "creation_date": 1428701545, "answer_id": 29571020, "question_id": 29570441, "link": "https://stackoverflow.com/questions/29570441/how-can-i-return-an-iterator-over-a-slice/29571020#29571020", "title": "How can I return an iterator over a slice?", "body": "<pre class=\"lang-rust prettyprint-override\"><code>fn get_iterator&lt;'a&gt;(s: &amp;'a [String]) -&gt; Box&lt;Iterator&lt;Item=&amp;'a String&gt; + 'a&gt; {\n    Box::new(s.iter())\n}\n</code></pre>\n\n<p>The trick here is that we start with a slice of items and that slice has the lifetime <code>'a</code>. <a href=\"http://doc.rust-lang.org/std/primitive.slice.html#method.iter\" rel=\"nofollow noreferrer\"><code>slice::iter</code></a> returns a <a href=\"http://doc.rust-lang.org/std/slice/struct.Iter.html\" rel=\"nofollow noreferrer\"><code>slice::Iter</code></a> with the same lifetime as the slice. The implementation of <code>Iterator</code> likewise returns references with that lifetime. We need to connect all of the lifetimes together.</p>\n\n<p>That explains the <code>'a</code> in the arguments and in the <code>Item=&amp;'a</code> part. So what's the <code>+ 'a</code> mean? There's a <a href=\"https://stackoverflow.com/a/26213294/155423\">complete answer</a> about that, and <a href=\"https://stackoverflow.com/a/25959806/155423\">another with more detail</a>. The short version is that an object with <em>references inside of it</em> may implement a trait, so we need to account for those lifetimes when talking about a trait. By default, that lifetime is <code>'static</code> as it was determined that was the usual case.</p>\n\n<p>The <code>Box</code> is not strictly required, but is a normal thing you'll see when you don't want to deal with the complicated types that might underlie the implementation (or just don't want to expose the implementation). In this case, the function <em>could</em> be</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn get_iterator&lt;'a&gt;(s: &amp;'a [String]) -&gt; std::slice::Iter&lt;'a, String&gt; {\n    s.iter()\n}\n</code></pre>\n\n<p>But if you add <code>.skip(1)</code>, the type would be:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>std::iter::Skip&lt;std::slice::Iter&lt;'a, String&gt;&gt;\n</code></pre>\n\n<p>And if you involve a closure, then it's currently impossible to specify the type, as closures are unique, anonymous, auto-generated types! A <code>Box</code> is required for those cases.</p>\n"}], "owner": {"user_type": "does_not_exist", "display_name": "user1949917"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 102, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1428780383, "creation_date": 1428698929, "last_edit_date": 1428701228, "question_id": 29570441, "link": "https://stackoverflow.com/questions/29570441/how-can-i-return-an-iterator-over-a-slice", "title": "How can I return an iterator over a slice?", "body": "<pre><code>fn main() {\n    let vec: Vec&lt;_&gt; = (0..5).map(|n| n.to_string()).collect();\n\n    for item in get_iterator(&amp;vec) {\n        println!(\"{}\", item);\n    }\n}\n\nfn get_iterator(s: &amp;[String]) -&gt; Box&lt;Iterator&lt;Item=String&gt;&gt; {\n    Box::new(s.iter())\n}\n</code></pre>\n"}, {"tags": ["string", "static", "rust", "ffi"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1428680815, "post_id": 29563785, "comment_id": 47280755, "body": "I would hope that <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\" rel=\"nofollow noreferrer\">RFC 911</a> would help with this - it would allow calling <code>as_ptr</code> in a static context."}], "answers": [{"tags": [], "owner": {"reputation": 1743, "user_id": 398021, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a5a39b5f9de50200406c7a209ff7a121?s=128&d=identicon&r=PG", "display_name": "goertzenator", "link": "https://stackoverflow.com/users/398021/goertzenator"}, "is_accepted": true, "score": 1, "last_activity_date": 1428685999, "creation_date": 1428685999, "answer_id": 29567098, "question_id": 29563785, "link": "https://stackoverflow.com/questions/29563785/how-do-i-create-static-c-strings/29567098#29567098", "title": "How do I create static C strings?", "body": "<p>The following seems to do the trick.  I don't really want the struct to be mutable, but I get core::marker::Sync errors if I don't mark it as mut.</p>\n\n<pre><code>extern crate libc;\n\nuse libc::funcs::c95::stdio::puts;\nuse std::mem;\n\npub struct Mystruct {\n    s1: *const u8,\n    s2: *const u8,\n}\n\nconst CONST_C_STR: *const u8 = b\"a constant c string\\0\" as *const u8;\n\n#[no_mangle]\npub static mut mystaticstruct: Mystruct = Mystruct {\n    s1: CONST_C_STR,\n    s2: b\"another constant c string\\0\" as *const u8\n};\n\nfn main() {\n    unsafe{\n        puts(mystaticstruct.s1 as *const i8); // puts likes i8\n        puts(mystaticstruct.s2 as *const i8);\n        println!(\"Mystruct size {}\", mem::size_of_val(&amp;mystaticstruct));\n    }\n}\n</code></pre>\n\n<p>The output (on 64 bit linux) is ...</p>\n\n<pre><code>a constant c string\nanother constant c string\nMystruct size 16\n</code></pre>\n"}], "owner": {"reputation": 1743, "user_id": 398021, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a5a39b5f9de50200406c7a209ff7a121?s=128&d=identicon&r=PG", "display_name": "goertzenator", "link": "https://stackoverflow.com/users/398021/goertzenator"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 254, "favorite_count": 0, "accepted_answer_id": 29567098, "answer_count": 1, "score": 1, "last_activity_date": 1428685999, "creation_date": 1428675428, "last_edit_date": 1495540244, "question_id": 29563785, "link": "https://stackoverflow.com/questions/29563785/how-do-i-create-static-c-strings", "title": "How do I create static C strings?", "body": "<p>I want to create a plugin module (shared lib) in Rust that exports a C compatible structure containing static C strings. In Sept 2014, <a href=\"https://stackoverflow.com/questions/25880043/creating-a-static-c-struct-containing-strings\">this Stack Overflow question</a> determined it wasn't possible. As of Jan 2015 this still was not possible as per <a href=\"http://www.reddit.com/r/rust/comments/2tzkro/compiletime_static_c_strings/\" rel=\"nofollow noreferrer\">this Reddit thread</a>. Has anything changed since?</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 135, "user_id": 484582, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/08f92cb5ad43d93785f49f1c732245f7?s=128&d=identicon&r=PG", "display_name": "JIoJIaJIu", "link": "https://stackoverflow.com/users/484582/jiojiajiu"}, "edited": false, "score": 0, "creation_date": 1428675573, "post_id": 29562217, "comment_id": 47277268, "body": "Excuse me, but I have more complicated structure, what do in such case  <a href=\"http://is.gd/KTNUGm\" rel=\"nofollow noreferrer\">Play.Rust</a> ?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 135, "user_id": 484582, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/08f92cb5ad43d93785f49f1c732245f7?s=128&d=identicon&r=PG", "display_name": "JIoJIaJIu", "link": "https://stackoverflow.com/users/484582/jiojiajiu"}, "edited": false, "score": 0, "creation_date": 1428676045, "post_id": 29562217, "comment_id": 47277567, "body": "I would make my structure copyable, by adding <code>#[derive(Copy)]</code> before the struct definition: <a href=\"http://is.gd/nrBnMk\" rel=\"nofollow noreferrer\">is.gd/nrBnMk</a>"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 135, "user_id": 484582, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/08f92cb5ad43d93785f49f1c732245f7?s=128&d=identicon&r=PG", "display_name": "JIoJIaJIu", "link": "https://stackoverflow.com/users/484582/jiojiajiu"}, "edited": false, "score": 0, "creation_date": 1428676137, "post_id": 29562217, "comment_id": 47277638, "body": "if you truly have a non-copyable structure, then you can use <a href=\"http://doc.rust-lang.org/std/collections/struct.HashMap.html#method.remove\" rel=\"nofollow noreferrer\"><code>remove</code></a> instead of <code>get</code>, which removes the value from the map and returns it"}, {"owner": {"reputation": 135, "user_id": 484582, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/08f92cb5ad43d93785f49f1c732245f7?s=128&d=identicon&r=PG", "display_name": "JIoJIaJIu", "link": "https://stackoverflow.com/users/484582/jiojiajiu"}, "edited": false, "score": 0, "creation_date": 1428676407, "post_id": 29562217, "comment_id": 47277846, "body": "I don&#39;t want to copy my structure(. But if I use <code>remove</code> I change a <code>HashMap </code>and I just want to get value and nothing more. And this value I cannot copy. Only such decisions exist?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 135, "user_id": 484582, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/08f92cb5ad43d93785f49f1c732245f7?s=128&d=identicon&r=PG", "display_name": "JIoJIaJIu", "link": "https://stackoverflow.com/users/484582/jiojiajiu"}, "edited": false, "score": 0, "creation_date": 1428678829, "post_id": 29562217, "comment_id": 47279528, "body": "if you get the value, you may not modify the hash-map. so you cannot call a function that wants <code>&amp;mut self</code>. Most likely you can work around your issue. but since <code>fire_petrol</code> doesn&#39;t use <code>gaz</code>, you could simply call <code>fire_petrol</code> after the match and have the <code>None=&gt;()</code> branch be <code>None=&gt;return</code> instead"}, {"owner": {"reputation": 135, "user_id": 484582, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/08f92cb5ad43d93785f49f1c732245f7?s=128&d=identicon&r=PG", "display_name": "JIoJIaJIu", "link": "https://stackoverflow.com/users/484582/jiojiajiu"}, "edited": false, "score": 0, "creation_date": 1428682723, "post_id": 29562217, "comment_id": 47281914, "body": "Ok, thanks, it&#39;s not what I want, but I&#39;ve understood the concept"}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 2, "last_activity_date": 1428671128, "creation_date": 1428671128, "answer_id": 29562217, "question_id": 29561696, "link": "https://stackoverflow.com/questions/29561696/why-does-the-borrow-from-hashmapget-not-end-when-the-function-returns/29562217#29562217", "title": "Why does the borrow from `HashMap::get` not end when the function returns?", "body": "<p>If you look at the <a href=\"http://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get\" rel=\"nofollow\">documentation of <code>HashMap::get</code></a> you can see, that it returns an <code>Option&lt;&amp;V&gt;</code>. The reference into the map allows you to do zero-copy accesses into a hash-map. The downside is, as long as you have a reference, you cannot modify the hash map as that might invalidate your reference. </p>\n\n<p>The branch <code>Some(gaz)</code> causes the binding <code>gaz</code> to have type <code>&amp;u64</code>, where the reference points into your hashmap. If you change that to <code>Some(&amp;gaz)</code> you get a copy of the value instead of a reference, and may modify the hash map even inside that branch.</p>\n\n<p><a href=\"http://is.gd/rNeCc9\" rel=\"nofollow\">Minimal Example in Playpen</a></p>\n"}], "owner": {"reputation": 135, "user_id": 484582, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/08f92cb5ad43d93785f49f1c732245f7?s=128&d=identicon&r=PG", "display_name": "JIoJIaJIu", "link": "https://stackoverflow.com/users/484582/jiojiajiu"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 582, "favorite_count": 0, "accepted_answer_id": 29562217, "answer_count": 1, "score": 0, "last_activity_date": 1428676169, "creation_date": 1428669565, "last_edit_date": 1428676169, "question_id": 29561696, "link": "https://stackoverflow.com/questions/29561696/why-does-the-borrow-from-hashmapget-not-end-when-the-function-returns", "title": "Why does the borrow from `HashMap::get` not end when the function returns?", "body": "<p>Here is emulation of my problem, when a borrow ends too late</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::collections::HashMap;\n\nstruct Item {\n    capacity: u64\n}\n\nstruct Petrol {\n    name: String,\n    fuel: HashMap&lt;&amp;'static str, Item&gt;\n}\n\nfn buy_gaz(p: &amp;mut Petrol) {\n   match p.fuel.get(\"gaz\") {\n      Some(gaz) =&gt; {\n        fire_petrol(p); \n      }\n      None =&gt; ()\n   }\n}\n\nfn fire_petrol(p: &amp;mut Petrol) {\n    println!(\"Boom!\");\n    p.fuel.remove(\"gaz\");\n    p.fuel.remove(\"benzin\");\n}\n\nfn main() {\n    let mut bt = Petrol {\n        name: \"Britii Petrovich\".to_string(),\n        fuel: HashMap::new()\n    };\n\n    bt.fuel.insert(\"gaz\", Item { capacity: 1000 });\n    bt.fuel.insert(\"benzin\", Item { capacity: 5000 });\n\n    buy_gaz(&amp;mut bt);\n}\n</code></pre>\n\n<p>When compiling I get:</p>\n\n<pre><code>note: previous borrow of `p.fuel` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `p.fuel` until the borrow ends\nmatch p.fuel.get(\"gaz\") {\n      ^~~~~~\n</code></pre>\n\n<p>Why does the borrow end so late and not on exit from <code>HashMap::get</code>? How do I fix my case?</p>\n\n<p>PS: I edited my first post for adding struct to <code>HashMap</code>, because decision below worked for simply types (with default Clone trait, I think), but doesn't work for custom structures</p>\n"}, {"tags": ["rust", "higher-order-functions"], "answers": [{"comments": [{"owner": {"reputation": 2376, "user_id": 2979958, "user_type": "registered", "accept_rate": 53, "profile_image": "https://www.gravatar.com/avatar/0837352343df3dd5f20807418f7321ef?s=128&d=identicon&r=PG&f=1", "display_name": "Kapichu", "link": "https://stackoverflow.com/users/2979958/kapichu"}, "edited": false, "score": 5, "creation_date": 1436116929, "post_id": 29554485, "comment_id": 50464618, "body": "Is it impossible to implement <code>Fn*</code> in stable?"}, {"owner": {"reputation": 12070, "user_id": 5044950, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/9yN0x.jpg?s=128&g=1", "display_name": "Sam Estep", "link": "https://stackoverflow.com/users/5044950/sam-estep"}, "reply_to_user": {"reputation": 2376, "user_id": 2979958, "user_type": "registered", "accept_rate": 53, "profile_image": "https://www.gravatar.com/avatar/0837352343df3dd5f20807418f7321ef?s=128&d=identicon&r=PG&f=1", "display_name": "Kapichu", "link": "https://stackoverflow.com/users/2979958/kapichu"}, "edited": false, "score": 0, "creation_date": 1484191503, "post_id": 29554485, "comment_id": 70411500, "body": "@Kapichu It appears so: the docs for the <a href=\"https://doc.rust-lang.org/std/ops/trait.FnOnce.html#tymethod.call_once\" rel=\"nofollow noreferrer\"><code>call_once</code></a> method link to issue <a href=\"https://github.com/rust-lang/rust/issues/29625\" rel=\"nofollow noreferrer\">#29625</a>, which is still open."}], "tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": true, "score": 7, "last_activity_date": 1428646079, "creation_date": 1428646079, "answer_id": 29554485, "question_id": 29553877, "link": "https://stackoverflow.com/questions/29553877/how-to-create-a-sized-closure-or-implement-fn-fnmut-fnonce-on-a-struct/29554485#29554485", "title": "How to create a sized closure or implement Fn/FnMut/FnOnce on a struct?", "body": "<p>The syntax for manually implementing a <code>Fn*</code> trait on a struct is this one:</p>\n\n\n\n<pre class=\"lang-rust prettyprint-override\"><code>impl FnOnce&lt;(Arg1,Arg2,Arg3,)&gt; for MyStruct {\n    type Output = MyOutput;\n    extern \"rust-call\" fn call_once(args: (Arg1, Arg2, Arg3,)) -&gt; MyOutput {\n       // implementation here\n    }\n}\n</code></pre>\n\n<p>Note that all the arguments are given as a single tuple.</p>\n\n<p>Also, this syntax is unstable and require <code>#![feature(core, unboxed_closures)]</code>, thus you cannot use it on the beta channel, only nightlies.</p>\n\n<p>In you case, it would translate like this:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>impl FnOnce&lt;(u32,)&gt; for MyErrorPartial {\n    type Output = MyError;\n\n    extern \"rust-call\" fn call_once(self, args: (u32,)) -&gt; MyError {\n        MyError {\n            code: args.0,\n            location: self.location,\n        }\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 15886, "user_id": 471341, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/166bdbf4351669bc37a0407d38b8cb88?s=128&d=identicon&r=PG", "display_name": "yonran", "link": "https://stackoverflow.com/users/471341/yonran"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1741, "favorite_count": 0, "accepted_answer_id": 29554485, "answer_count": 1, "score": 8, "last_activity_date": 1428679580, "creation_date": 1428642796, "last_edit_date": 1428679580, "question_id": 29553877, "link": "https://stackoverflow.com/questions/29553877/how-to-create-a-sized-closure-or-implement-fn-fnmut-fnonce-on-a-struct", "title": "How to create a sized closure or implement Fn/FnMut/FnOnce on a struct?", "body": "<p>Basically, I want to write a function that returns a closure. How can I do this without having to return <code>Box&lt;FnOnce(u32)&gt;</code>?</p>\n\n<p>From the <a href=\"https://doc.rust-lang.org/book/closures.html#closure-implementation\" rel=\"noreferrer\">closures chapter of the rust book</a>, I read that a closure is just syntactic sugar for a struct and an impl of <code>FnOnce</code>. Here is my attempt:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>#[derive(Debug)]\nstruct MyError {\n    code: u32,\n    location: &amp;'static str,\n}\n// Here is my closure:\nstruct MyErrorPartial {\n    location: &amp;'static str,\n}\nimpl FnOnce(u32) for MyErrorPartial {\n    type Output = MyError;\n\n    fn call_once(self, args: u32) -&gt; MyError {\n        MyError {\n            code: args,\n            location: self.location,\n        }\n    }\n}\nfn error_at(location: &amp;'static str) -&gt; MyErrorPartial {\n    MyErrorPartial {location: location}\n}\n\nfn function_returning_code() -&gt; Result&lt;(), u32&gt; {\n    Err(123)\n}\nfn function_with_error() -&gt; Result&lt;(), MyError&gt; {\n    try!(function_returning_code().map_err(error_at(\"line1\")));\n    try!(function_returning_code().map_err(error_at(\"line2\")));\n    Ok(())\n}\nfn main() {\n    function_with_error().unwrap();\n}\n</code></pre>\n\n<p>It currently gives an error:</p>\n\n<pre><code>&lt;anon&gt;:11:12: 11:17 error: associated type bindings are not allowed here [E0229]\n&lt;anon&gt;:11 impl FnOnce(u32) for MyErrorPartial {\n                     ^~~~~\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1428673436, "post_id": 29552451, "comment_id": 47275680, "body": "possible duplicate of <a href=\"http://stackoverflow.com/questions/24542115/how-to-index-a-string-in-rust\">How to index a String in Rust</a>"}], "answers": [{"comments": [{"owner": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "edited": false, "score": 0, "creation_date": 1428641045, "post_id": 29552976, "comment_id": 47258032, "body": "Thanks for the detailed response. Now the history of why the indexing syntax isn&#39;t available in Rust makes sense. I haven&#39;t gone through the last snippet you gave me but the <code>.char_at()</code> method offends the compiler. I get <code>lib.rs:10:1: 10:22 error: unstable feature lib.rs:10 #![feature(str_char)]</code>. Will get back to you when I get that fixed."}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "edited": false, "score": 0, "creation_date": 1428641191, "post_id": 29552976, "comment_id": 47258074, "body": "That error should have a <code>note</code> message that appears under it that tells you how to get around it, basically add <code>#![feature(str_char)]</code> to the top of your crate root (e.g. the top of your main.rs file if it&#39;s binary, or lib.rs if it&#39;s a library)."}, {"owner": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "edited": false, "score": 0, "creation_date": 1428641418, "post_id": 29552976, "comment_id": 47258140, "body": "Yes the original compilation gave me an error requiring me to add the <code>str_char</code> feature; I get the above error after I have added <code>#[feature(str_char)]</code> to my crate attributes. I guess the functionality is depreciated. I&#39;m looking into it now."}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "edited": false, "score": 1, "creation_date": 1428641583, "post_id": 29552976, "comment_id": 47258196, "body": "I don&#39;t think it&#39;s deprecated or it would&#39;ve told you that. Are you by any chance running on the rust beta? Unstable features are not usable within the beta and other &quot;stable&quot; releases; they&#39;re only usable in nightly releases. If you want to stick to the beta and not use a nightly, I believe an alternative to <code>char_at(index)</code> would be something like <code>chars().nth(index).unwrap()</code>."}, {"owner": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "edited": false, "score": 0, "creation_date": 1428641799, "post_id": 29552976, "comment_id": 47258246, "body": "Speaking of which I just found the issue report: <a href=\"https://github.com/rust-lang/rust/issues/23973\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/23973</a> - I&#39;ll try the alternative that you&#39;ve suggested!"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1428652493, "post_id": 29552976, "comment_id": 47262757, "body": "<code>chars().nth(index).unwrap()</code> is not a full replacement for <code>char_at(index)</code>. The former gives the <code>index</code>th <code>char</code> in the <code>String</code> in O(index) time, while the latter gives the <code>char</code> starting at the <code>index</code>th byte in O(1) time."}, {"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 0, "creation_date": 1428665354, "post_id": 29552976, "comment_id": 47270411, "body": "For completeness, a full replacement of <code>s.char_at(i)</code> is <code>s[i..].chars().next().unwrap()</code>. (Both yield the Unicode character starting at byte position <code>i</code> in <code>s</code> in <code>O(1)</code> time.)"}, {"owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "edited": false, "score": 0, "creation_date": 1428687648, "post_id": 29552976, "comment_id": 47284526, "body": "Question: would <code>s[i..(i+1)].chars().next().unwrap()</code> be any faster for long strings? I&#39;m guessing not since <code>chars</code> is an iterator."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "edited": false, "score": 1, "creation_date": 1428689270, "post_id": 29552976, "comment_id": 47285454, "body": "@anders It wouldn&#39;t be faster (slicing just does pointer arithmetic, and <code>chars</code> indeed is an iterator and thus lazy) and it would be wrong and crash for everything but ASCII."}], "tags": [], "owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "is_accepted": false, "score": 1, "last_activity_date": 1428641337, "last_edit_date": 1495540244, "creation_date": 1428637403, "answer_id": 29552976, "question_id": 29552451, "link": "https://stackoverflow.com/questions/29552451/accessing-a-character-in-a-borrowed-string-by-index/29552976#29552976", "title": "Accessing a character in a borrowed string by index", "body": "<p>You can use <a href=\"http://doc.rust-lang.org/core/str/trait.StrExt.html#tymethod.char_at\" rel=\"nofollow noreferrer\"><code>char_at(index)</code></a> to access a specific character. If you want to iterate over the characters in a string, you can use the <a href=\"http://doc.rust-lang.org/core/str/trait.StrExt.html#tymethod.chars\" rel=\"nofollow noreferrer\"><code>chars()</code></a> method which yields an iterator over the characters in the string.</p>\n\n<p>The reason it was <em>specifically</em> not made possible to use indexing syntax is, IIRC, because indexing syntax would give the impression that it was like accessing a character in your typical C-string-like string, where accessing a character at a given index is a constant time operation (i.e. just accessing a single byte in an array). Strings in Rust, on the other hand, are Unicode and a single character may not necessarily consist of just one byte, making a specific character access a linear time operation, so it was decided to make that performance difference explicit and clear.</p>\n\n<p>As far as I know, there is no method available for swapping characters in a string (see <a href=\"https://stackoverflow.com/questions/27895150/how-to-swap-two-characters-in-a-string\">this question</a>). Note that this wouldn't have been possible anyways via an immutably borrowed string, since such a string isn't yours to modify. You would have to most likely use a <code>String</code>, or perhaps a <code>&amp;mut str</code> if you're strictly swapping, but I'm not too familiar with Unicode's intricacies.</p>\n\n<p>I recommend instead you build up a <code>String</code> the way you want it, that way you don't have to worry about the mutability of the borrowed string. You'd refer/look into the borrowed string, and write into the output/build-up string accordingly based on your logic.</p>\n\n<p>So this:</p>\n\n<pre><code>for pos in 0..my_string_vec.len() {\n    while shift &lt;= pos &amp;&amp; my_string_vec[pos] != my_string_vec[pos-shift] {\n        shift += shifts[pos-shift];\n    }\n    shifts[pos+1] = shift;\n}\n</code></pre>\n\n<p>Might become something like this (not tested; not clear what your logic is for):</p>\n\n<pre><code>for ch in my_string.chars()\n    while shift &lt;= pos &amp;&amp; ch != my_string.char_at(pos - shift) {\n        // assuming shifts is a vec; not clear in question\n        shift += shifts[pos - shift];\n    }\n\n    shifts.push(shift);\n}\n</code></pre>\n\n<p>Your last for loop:</p>\n\n<pre><code>for ch in my_string_vec {\n    let pos = 0;    // simulate some runtime index\n    if my_other_string_vec[pos] != ch {\n        ...\n    }\n}\n</code></pre>\n\n<p>That kind of seems like you want to compare a given character in string A with the corresponding character (in the same position) of string B. For this I would recommend zipping the chars iterator of the first with the second, something like:</p>\n\n<pre><code>for (left, right) in my_string.chars().zip(my_other_string.chars()) {\n  if left != right {\n  }\n}\n</code></pre>\n\n<p>Note that <code>zip()</code> stops iterating as soon as either iterator stops, meaning that if the strings are not the same length, then it'll only go as far as the shortest string.</p>\n\n<p>If you need access to the \"character index\" information, you could add <code>.enumerate()</code> to that, so the above would change to:</p>\n\n<pre><code>for (index, (left, right)) in my_string.chars().zip(my_other_string.chars()).enumerate()\n</code></pre>\n"}], "owner": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1874, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1428641337, "creation_date": 1428633730, "last_edit_date": 1428633908, "question_id": 29552451, "link": "https://stackoverflow.com/questions/29552451/accessing-a-character-in-a-borrowed-string-by-index", "title": "Accessing a character in a borrowed string by index", "body": "<p>How would you access an element in a borrowed string by index?</p>\n\n<p>Straightforward in Python:</p>\n\n<pre><code>my_string_lst = list(my_string) \nprint my_string_list[0]\nprint my_string[0]                # same as above\n</code></pre>\n\n<p>Rust (attempt 1):</p>\n\n<pre><code>let my_string_vec = vec![my_string];    # doesn't work\nprintln!(\"{}\", my_string_vec[0]);       # returns entire of `my_string` \n</code></pre>\n\n<p>Rust (attempt 2):</p>\n\n<pre><code>let my_string_vec = my_string.as_bytes();  # returns a &amp;[u8]\nprintln!(\"{}\", my_string_vec[0]);          # prints nothing\n</code></pre>\n\n<p>My end goal is to stick it into a loop like this:</p>\n\n<pre><code>for pos in 0..my_string_vec.len() {\n    while shift &lt;= pos &amp;&amp; my_string_vec[pos] != my_string_vec[pos-shift] {\n        shift += shifts[pos-shift];\n    }\n    shifts[pos+1] = shift;\n}\n\nfor ch in my_string_vec {\n    let pos = 0;    // simulate some runtime index\n    if my_other_string_vec[pos] != ch {\n        ...\n    }\n}\n</code></pre>\n\n<p>I think it's possible to do use <code>my_string_vec.as_bytes()[pos]</code>and <code>my_string_vec.as_bytes()[pos-shift]</code>in my condition statement, but I feel that this has a bad code smell.</p>\n"}, {"tags": ["vector", "rust"], "comments": [{"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 12, "creation_date": 1428613178, "post_id": 29548819, "comment_id": 47249297, "body": "You introduced a big difference by replacing <code>sum + x</code> by <code>sum += x</code>."}, {"owner": {"reputation": 663, "user_id": 4766077, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/da5729347d738a5c974cb94c09a132f5?s=128&d=identicon&r=PG&f=1", "display_name": "mmatyas", "link": "https://stackoverflow.com/users/4766077/mmatyas"}, "reply_to_user": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 0, "creation_date": 1428613400, "post_id": 29548819, "comment_id": 47249420, "body": "I can&#39;t believe it, how could I miss that... Thanks!"}], "answers": [{"tags": [], "owner": {"reputation": 663, "user_id": 4766077, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/da5729347d738a5c974cb94c09a132f5?s=128&d=identicon&r=PG&f=1", "display_name": "mmatyas", "link": "https://stackoverflow.com/users/4766077/mmatyas"}, "is_accepted": false, "score": 12, "last_activity_date": 1610287487, "last_edit_date": 1610287487, "creation_date": 1428613852, "answer_id": 29549105, "question_id": 29548819, "link": "https://stackoverflow.com/questions/29548819/how-do-i-sum-a-vector-using-fold/29549105#29549105", "title": "How do I sum a vector using fold?", "body": "<p>So it turned out there was a huge difference in my code, as I wrote</p>\n<pre><code>sum += x\n</code></pre>\n<p>instead of</p>\n<pre><code>sum + x\n</code></pre>\n<p>Well, at least I hope this question helps, in case someone gets into similar situation.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 50, "last_activity_date": 1573653306, "last_edit_date": 1573653306, "creation_date": 1428626898, "answer_id": 29551508, "question_id": 29548819, "link": "https://stackoverflow.com/questions/29548819/how-do-i-sum-a-vector-using-fold/29551508#29551508", "title": "How do I sum a vector using fold?", "body": "<p>Since Rust 1.11, you can <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum\" rel=\"noreferrer\"><code>sum</code></a> the iterator directly, skipping <code>fold</code>:</p>\n\n<pre><code>let sum: u32 = vec![1, 2, 3, 4, 5, 6].iter().sum();\n</code></pre>\n\n<hr>\n\n<p>You've already figured out that <code>+=</code> is the problem, but I'd like to provide some more exposition.</p>\n\n<p>In your case, the arguments provided to the <code>fold</code> closure are <code>_</code> and <code>&amp;u32</code>. The first type is an not-yet-specified integer. If you change your fold call to <code>fold(0u32, |sum, val| sum += val)</code>, you'll get a slightly different message:</p>\n\n<pre><code>let sum: u32 = vec![1,2,3,4,5,6].iter().fold(0u32, |sum, val| sum += val);\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  |\n2 |     let sum: u32 = vec![1,2,3,4,5,6].iter().fold(0u32, |sum, val| sum += val);\n  |                                                                          ^^^ expected u32, found &amp;{integer}\n  |\n  = note: expected type `u32`\n  = note:    found type `&amp;{integer}`\n</code></pre>\n\n<p>The result value of the binary assignment operation <code>+=</code> is <code>()</code>, the unit type. This explains the error message when you changed to <code>fold(0, |sum, &amp;val| sum += val)</code>:</p>\n\n<pre><code>let mut a = 1;\nlet what_am_i = a += 1;\nprintln!(\"{:?}\", what_am_i); // =&gt; ()\n</code></pre>\n\n<p>If you change to <code>fold(0, |sum, &amp;val| {sum += val ; sum})</code>, you then get an understandable error about immutable variables:</p>\n\n<pre><code>let sum: u32 = vec![1,2,3,4,5,6].iter().fold(0, |sum, &amp;val| {sum += val; sum});\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0384]: re-assignment of immutable variable `sum`\n --&gt; src/main.rs:2:66\n  |\n2 |     let sum: u32 = vec![1,2,3,4,5,6].iter().fold(0, |sum, &amp;val| {sum += val; sum});\n  |                                                      ---         ^^^^^^^^^^ re-assignment of immutable variable\n  |                                                      |\n  |                                                      first assignment to `sum`\n</code></pre>\n\n<p>From here, you <em>could</em> mark <code>sum</code> as mutable, but the correct solution is to simply fold with <code>sum + val</code>, as you discovered.</p>\n"}], "owner": {"reputation": 663, "user_id": 4766077, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/da5729347d738a5c974cb94c09a132f5?s=128&d=identicon&r=PG&f=1", "display_name": "mmatyas", "link": "https://stackoverflow.com/users/4766077/mmatyas"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 36644, "favorite_count": 7, "accepted_answer_id": 29551508, "answer_count": 2, "score": 50, "last_activity_date": 1610287487, "creation_date": 1428612945, "last_edit_date": 1533051332, "question_id": 29548819, "link": "https://stackoverflow.com/questions/29548819/how-do-i-sum-a-vector-using-fold", "title": "How do I sum a vector using fold?", "body": "<p><a href=\"https://doc.rust-lang.org/book/iterators.html\" rel=\"noreferrer\">This</a> Rust tutorial explains the <code>fold()</code> mechanism well, and this example code:</p>\n\n<pre><code>let sum = (1..4).fold(0, |sum, x| sum + x);\n</code></pre>\n\n<p>works as expected.</p>\n\n<p>I'd like to run it on a vector, so based on that example, first I wrote this:</p>\n\n<pre><code>let sum: u32 = vec![1,2,3,4,5,6].iter().fold(0, |sum, val| sum += val);\n</code></pre>\n\n<p>which threw an error:</p>\n\n<pre><code>error: binary assignment operation `+=` cannot be applied to types `_` and `&amp;u32` [E0368]\nlet sum = ratings.values().fold(0, |sum, val| sum += val);\n                                              ^~~~~~~~~~\n</code></pre>\n\n<p>I guessed this might be a reference-related error for some reason, so I changed that to <code>fold(0, |sum, &amp;val| sum += val)</code>, which resulted in</p>\n\n<pre><code>error: mismatched types:\nexpected `u32`,\n   found `()`\n</code></pre>\n\n<p>Hm, maybe something's wrong with the closure? Using <code>{sum += x; sum }</code>, I got</p>\n\n<pre><code>binary assignment operation `+=` cannot be applied to types `_` and `&amp;u32`\n</code></pre>\n\n<p>again.</p>\n\n<p>After further trial and error, adding <code>mut</code> to <code>sum</code> worked:</p>\n\n<pre><code>let sum = vec![1,2,3,4,5,6].iter().fold(0, |mut sum, &amp;x| {sum += x; sum});\n</code></pre>\n\n<p>Could someone explain the reason why <code>fold()</code> for vectors differs so much from the tutorial? Or is there a better way to handle this?</p>\n\n<p>For reference, I'm using Rust beta, 2015-04-02.</p>\n"}, {"tags": ["multithreading", "api", "rust", "shutdown"], "answers": [{"comments": [{"owner": {"reputation": 3123, "user_id": 273348, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/35ugZ.jpg?s=128&g=1", "display_name": "Peter Jankuliak", "link": "https://stackoverflow.com/users/273348/peter-jankuliak"}, "edited": false, "score": 0, "creation_date": 1429014941, "post_id": 29544440, "comment_id": 47397877, "body": "Thanks, you&#39;re probably right that the functionality is missing in the API. I gave you +1, but I would like to wait a bit longer, maybe someone has a different explanation."}], "tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user4316209"}, "is_accepted": true, "score": 5, "last_activity_date": 1428600143, "last_edit_date": 1495541841, "creation_date": 1428598258, "answer_id": 29544440, "question_id": 29541821, "link": "https://stackoverflow.com/questions/29541821/how-to-break-from-the-blocking-tcplisteneraccept-call/29544440#29544440", "title": "How to break from the blocking TcpListener::accept call?", "body": "<p>The question is a fundamental one, as in the end the <code>accept()</code> call translates down to a <code>libc::accept()</code> (see <a href=\"https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src/libstd/sys/unix/net.rs#L54\" rel=\"nofollow noreferrer\">here</a> and <a href=\"https://github.com/rust-lang/rust/blob/89436536246250ee3cbc47a61c31037ce7558c06/src/libstd/sys/windows/net.rs#L89\" rel=\"nofollow noreferrer\">here</a>).</p>\n\n<p>The solution would be to use nonblocking-io, look at <a href=\"http://carllerche.github.io/mio/mio/\" rel=\"nofollow noreferrer\">mio</a> for example.</p>\n\n<hr>\n\n<p><strong>Edi:</strong> After some consideration I researched the possibility to interrupt the <code>accept()</code> using <code>close()</code>. It seems to be unreliable. But <a href=\"https://stackoverflow.com/a/2489066/4316209\">this</a> turned up: Using <code>shutdown()</code>. <code>TcpStream</code> exposes this function, but it seems to be the only case. Might be a shortcoming of the API?</p>\n"}], "owner": {"reputation": 3123, "user_id": 273348, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/35ugZ.jpg?s=128&g=1", "display_name": "Peter Jankuliak", "link": "https://stackoverflow.com/users/273348/peter-jankuliak"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 882, "favorite_count": 2, "accepted_answer_id": 29544440, "answer_count": 1, "score": 9, "last_activity_date": 1428600143, "creation_date": 1428590941, "question_id": 29541821, "link": "https://stackoverflow.com/questions/29541821/how-to-break-from-the-blocking-tcplisteneraccept-call", "title": "How to break from the blocking TcpListener::accept call?", "body": "<p>I'm running the <a href=\"http://doc.rust-lang.org/1.0.0-beta/std/net/struct.TcpListener.html#method.accept\" rel=\"noreferrer\"><code>accept</code> function of a TCP listener</a> in a loop in a separate thread. I would like to shutdown this thread gracefully, but I can't see any kind of <code>shutdown</code> mechanism which I could use to break from accepting.</p>\n\n<p>My current approach looks something like this:</p>\n\n<pre><code>use std::net::TcpListener;\nuse std::thread::spawn;\n\nfn main() {\n    let tcp_listener = TcpListener::bind(((\"0.0.0.0\"), 0)).unwrap();\n    let tcp_listener2 = tcp_listener.try_clone().unwrap();\n\n    let t = spawn(move || {\n        loop {\n            match tcp_listener2.accept() {\n                Ok(_) =&gt; { }\n                Err(_) =&gt; { break; }\n           }\n        }\n    });\n\n    drop(tcp_listener);\n    assert!(t.join().is_ok());\n}\n</code></pre>\n\n<p>But that doesn't do the trick (probably because I drop only the cloned copy?). Any thought on how to properly shutdown such thread?</p>\n\n<p>(for reference, <a href=\"http://users.rust-lang.org/t/how-to-break-from-the-blocking-tcplistener-accept-call/894/1\" rel=\"noreferrer\">I asked this question on rust user forum as well</a>)</p>\n"}, {"tags": ["multithreading", "rust"], "answers": [{"comments": [{"owner": {"reputation": 3029, "user_id": 1060004, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/ZOBMa.jpg?s=128&g=1", "display_name": "ustulation", "link": "https://stackoverflow.com/users/1060004/ustulation"}, "edited": false, "score": 0, "creation_date": 1428591230, "post_id": 29541551, "comment_id": 47235541, "body": "ya so i changed the signature to <code>Arc&lt;Mutex&lt;Facade&gt;&gt;</code> . But this now gives me an error that <code>the trait </code>&quot;core::marker::Sized&quot; is not implemented for the type &quot;Facade&quot;` and <code>&quot;Facade&quot; does not have a constant size known at compile-time</code> . This i understand as it is a trait. But now how do i implement a trait for a trait ?"}, {"owner": {"reputation": 3029, "user_id": 1060004, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/ZOBMa.jpg?s=128&g=1", "display_name": "ustulation", "link": "https://stackoverflow.com/users/1060004/ustulation"}, "edited": false, "score": 0, "creation_date": 1428592100, "post_id": 29541551, "comment_id": 47236199, "body": "ok so i use generics but now i get <code>the trait &quot;core::marker::Send&quot; is not implemented for the type &quot;F&quot; [E0277]</code>"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 3029, "user_id": 1060004, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/ZOBMa.jpg?s=128&g=1", "display_name": "ustulation", "link": "https://stackoverflow.com/users/1060004/ustulation"}, "edited": false, "score": 0, "creation_date": 1428592146, "post_id": 29541551, "comment_id": 47236244, "body": "@ustulation, sorry, I&#39;ve updated the code which fixes that error exactly at this moment :)"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 8, "last_activity_date": 1428592295, "last_edit_date": 1428592295, "creation_date": 1428590276, "answer_id": 29541551, "question_id": 29540407, "link": "https://stackoverflow.com/questions/29540407/how-can-i-share-references-across-threads/29541551#29541551", "title": "How can I share references across threads?", "body": "<p>I'm pretty sure you can't do this due to the mutable aliasing guarantees in Rust. In Rust you can't have two mutable references to the same thing at the same time, but this is exactly what happens in your code: you store <code>my_facade</code> to the field of <code>Client</code> and at the same time you are trying to pass it to <code>start()</code> method in another thread. This would require having two mutable references to the same <code>Facade</code> which is disallowed.</p>\n\n<p>The actual errors which compiler emits on your code are caused by that you're using a non-moving closure. If you change <code>thread::scoped()</code> instantiation to this:</p>\n\n<pre><code>join_grd: thread::scoped(move || Client::start(my_facade))\n</code></pre>\n\n<p>the error would be more sensible:</p>\n\n<pre><code>test.rs:16:60: 16:69 error: cannot move `my_facade` into closure because it is borrowed\ntest.rs:16             join_grd: thread::scoped(move || Client::start(my_facade))\n                                                                      ^~~~~~~~~\ntest.rs:15:21: 15:30 note: borrow of `*my_facade` occurs here\ntest.rs:15             facade: my_facade,\n                               ^~~~~~~~~\n</code></pre>\n\n<p>This essentially means that since <code>&amp;mut</code> references are unique and are moved instead of copied, you can't duplicate them. Similar code with the regular <code>&amp;</code> reference instead of <code>&amp;mut</code> (and an additional <code>Sync</code> parent trait on <code>Facade</code>) works fine.</p>\n\n<p>You have to rethink your architecture to fix this error. It is difficult to understand what you want from this piece of code alone, so I can't give any exact advices, but you may consider using <a href=\"http://doc.rust-lang.org/std/sync/struct.Arc.html\"><code>Arc</code></a> and <a href=\"http://doc.rust-lang.org/std/sync/struct.Mutex.html\"><code>Mutex</code></a> if you want to share mutable state between threads.</p>\n\n<hr>\n\n<p>Naive usage of <code>Arc/Mutex</code> like this:</p>\n\n<pre><code>fn start(my_facade: Arc&lt;Mutex&lt;Facade&gt;&gt;)\n</code></pre>\n\n<p>won't work because <code>Facade</code> is a trait, not a regular type. When you use traits as types, you're in fact opting into <a href=\"http://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html#dynamic-dispatch\">dynamic dispatch</a> in form of trait objects. In short, trait objects can't be used directly; they should always be behind a pointer. Your original program also used trait objects (<code>&amp;'a mut Facade</code> is a trait object). Ideally we should be able to form trait objects with any kind of smart pointer, and ideally <code>Arc&lt;Mutex&lt;Facade&gt;&gt;</code> should work, but unfortunately for now trait objects can only be created with <code>&amp;</code>, <code>&amp;mut</code> or <code>Box</code>:</p>\n\n<pre><code>fn start(my_facade: Arc&lt;Mutex&lt;Box&lt;Facade&gt;&gt;&gt;)\n</code></pre>\n\n<p>This is the reason of the error about <code>Sized</code> that you observe.</p>\n\n<p>However, you should also consider not using trait objects at all and just use generics:</p>\n\n<pre><code>trait Facade: Send { fn f(&amp;self); }\n\nstruct Client&lt;'a, F: Facade&gt; {  // '\n    facade: Arc&lt;Mutex&lt;F&gt;&gt;,\n    join_grd: thread::JoinGuard&lt;'a, ()&gt;,  // '\n}\n\nimpl&lt;'a, F: Facade+'a&gt; Client&lt;'a, F&gt; {  // '\n    pub fn new(my_facade: Arc&lt;Mutex&lt;F&gt;&gt;) -&gt; Client&lt;'a, F&gt; {  // '\n        let my_facade_2 = my_facade.clone();  // clone the Arc pointer\n        Client {\n            facade: my_facade,\n            join_grd: thread::scoped(move || Client::start(my_facade_2)),\n        }\n    }\n\n    fn start(my_facade: Arc&lt;Mutex&lt;F&gt;&gt;) { unimplemented!() }\n}\n</code></pre>\n\n<p>You also need to add <code>Send</code> bound either on the trait itself (as in the example above) or on <code>F</code> type variable (as in <code>F: Facade+Send+'a</code>) because only <code>Send</code> data may be transferred between threads safely, so you need to specify that <code>F</code> is <code>Send</code>, either directly or as a supertrait constraint on <code>Facade</code>.</p>\n"}], "owner": {"reputation": 3029, "user_id": 1060004, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/ZOBMa.jpg?s=128&g=1", "display_name": "ustulation", "link": "https://stackoverflow.com/users/1060004/ustulation"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 493, "favorite_count": 0, "accepted_answer_id": 29541551, "answer_count": 1, "score": 4, "last_activity_date": 1428592295, "creation_date": 1428587387, "last_edit_date": 1428587742, "question_id": 29540407, "link": "https://stackoverflow.com/questions/29540407/how-can-i-share-references-across-threads", "title": "How can I share references across threads?", "body": "<p>I am unable to share a reference between threads.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>trait Facade { /*some functions*/ }\n\nstruct Client&lt;'a&gt; {\n    facade: &amp;'a mut Facade,\n    join_grd: thread::JoinGuard&lt;'a()&gt;,\n}\n\nimpl&lt;'a&gt; Client&lt;'a&gt; {\n    pub fn new(my_facade: &amp;'a mut Facade) -&gt; Client&lt;'a&gt; {\n        Client {\n            facade: my_facade,\n        join_grd: thread::scoped(|| Client::start(my_facade)),\n        }\n    }\n\n    fn start(my_facade: &amp;'a mut Facade) { unimplemented!() }\n}\n</code></pre>\n\n<p>Given my newbie status in Rust, I'm getting confused with concepts and errors. How do I achieve the above ?</p>\n"}, {"tags": ["closures", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1468091774, "post_id": 29540167, "comment_id": 63989334, "body": "Also relevant: <a href=\"http://stackoverflow.com/questions/32044301/cannot-pass-self-as-callback-parameter-due-to-double-borrowing\" title=\"cannot pass self as callback parameter due to double borrowing\">stackoverflow.com/questions/32044301/&hellip;</a>"}], "answers": [{"comments": [{"owner": {"reputation": 91, "user_id": 3623669, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/15c2eb429faeb22de4c77eed2a6d8e16?s=128&d=identicon&r=PG&f=1", "display_name": "Marvel", "link": "https://stackoverflow.com/users/3623669/marvel"}, "edited": false, "score": 0, "creation_date": 1428661811, "post_id": 29551674, "comment_id": 47268262, "body": "Does this mean that I cannot write a button which changes his own title on click? See <a href=\"http://is.gd/xW4sGp\" rel=\"nofollow noreferrer\">the code</a>"}, {"owner": {"reputation": 91, "user_id": 3623669, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/15c2eb429faeb22de4c77eed2a6d8e16?s=128&d=identicon&r=PG&f=1", "display_name": "Marvel", "link": "https://stackoverflow.com/users/3623669/marvel"}, "edited": false, "score": 1, "creation_date": 1433079144, "post_id": 29551674, "comment_id": 49187591, "body": "Actually I can. Post click events to an queue and handle them in main loop as you want. <a href=\"http://is.gd/X39182\" rel=\"nofollow noreferrer\">The complete example</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1428628029, "creation_date": 1428628029, "answer_id": 29551674, "question_id": 29540167, "link": "https://stackoverflow.com/questions/29540167/creating-a-callback-system-using-closures/29551674#29551674", "title": "Creating a callback system using closures", "body": "<p>You are going to run into immediate problems with this line:</p>\n\n<pre><code>self.btn.set(|| self.hi());\n</code></pre>\n\n<p>Here, you need to borrow <code>self</code> as mutable in order to modify <code>btn</code>. You are <em>also</em> trying to borrow <code>self</code> as mutable in the closure. This is going to immediately run into problems because Rust does not allow you to have multiple mutable references to the same object (known as <em>aliasing</em>). This is a fundamental part of the the memory-safety guarantees of the language.</p>\n\n<p>Also, conceptually you are trying to set up a cycle of references - the <code>Window</code> knows about <code>Button</code> and <code>Button</code> knows about <code>Window</code>. While this is possible, it often isn't what you want. Once the references have a cycle, it's very hard to disentangle them. You can also search other questions that ask about creating <em>graphs</em> in Rust (as opposed to <em>trees</em>) to see similar issues other people have had.</p>\n\n<p>Ideally, you can structure your code as a tree. Here, I chose that <code>Button</code> can know about <code>Window</code>, but not vice versa:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct Button&lt;'a&gt; {\n    f: Option&lt;Box&lt;FnMut() + 'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Button&lt;'a&gt; {\n    fn new() -&gt; Button&lt;'a&gt; { Button { f: None } }\n    fn set&lt;T: FnMut() + 'a&gt;(&amp;mut self, f: T) { self.f = Some(Box::new(f)); }\n    fn unset(&amp;mut self) { self.f = None; }\n    fn call(&amp;mut self) { match self.f { Some(ref mut f) =&gt; f(), None =&gt; () } }\n}\n\nstruct Window;\n\nimpl Window {\n    fn hi(&amp;mut self) {\n        println!(\"callback\");\n    }\n}\n\nfn main() {\n    let mut wnd = Window;\n    let mut btn = Button::new();\n    btn.set(|| wnd.hi());\n    btn.call();\n    btn.unset();\n}\n</code></pre>\n"}], "owner": {"reputation": 91, "user_id": 3623669, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/15c2eb429faeb22de4c77eed2a6d8e16?s=128&d=identicon&r=PG&f=1", "display_name": "Marvel", "link": "https://stackoverflow.com/users/3623669/marvel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1761, "favorite_count": 3, "accepted_answer_id": 29551674, "answer_count": 1, "score": 8, "last_activity_date": 1428628135, "creation_date": 1428586827, "last_edit_date": 1428628135, "question_id": 29540167, "link": "https://stackoverflow.com/questions/29540167/creating-a-callback-system-using-closures", "title": "Creating a callback system using closures", "body": "<p>I'm trying to make something like a \"callback system\". For example, there is a window and a couple of buttons in it. The window sets callbacks for each button. Both callbacks should change the state of the window. The compiler doesn't allow capturing <code>&amp;self</code> in my closures / callbacks, and I don't know how to make it work. </p>\n\n<p>Are there any common patterns for callbacks I should be following?</p>\n\n<p>This is an easy example as all components have the same lifetime. What if the components have different lifetimes?</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>struct Button&lt;'a&gt; {\n    f: Option&lt;Box&lt;Fn() + 'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Button&lt;'a&gt; {\n    fn new() -&gt; Button&lt;'a&gt; { Button { f: None } }\n    fn set&lt;T: Fn() + 'a&gt;(&amp;mut self, f: T) { self.f = Some(Box::new(f)); }\n    fn unset(&amp;mut self) { self.f = None; }\n    fn call(&amp;self) { match self.f { Some(ref f) =&gt; f(), None =&gt; () } }\n}\n\nstruct Window&lt;'a&gt; {\n    btn: Button&lt;'a&gt;,\n    //btns: Vec&lt;Button&lt;'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Window&lt;'a&gt; {\n    fn new() -&gt; Window&lt;'a&gt; {\n        Window { btn: Button::new() }\n    }\n\n    fn hi(&amp;mut self) { // self is mutable\n        println!(\"callback\");\n    }\n\n    fn run(&amp;mut self) {\n        // Compile error: cannot infer an appropriate lifetime for\n        // capture of `self` by closure due to conflicting requirements\n        self.btn.set(|| self.hi()); // How to make it work?\n        self.btn.call();\n        self.btn.unset();\n    }\n}\n\nfn main() {\n    let mut wnd = Window::new();\n    wnd.run();\n}\n</code></pre>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 450, "user_id": 4301117, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/81eee027be0d8a17a2dbced4f0ccede2?s=128&d=identicon&r=PG&f=1", "display_name": "Leherenn", "link": "https://stackoverflow.com/users/4301117/leherenn"}, "edited": false, "score": 0, "creation_date": 1428586725, "post_id": 29539676, "comment_id": 47232105, "body": "Isn&#39;t the vector supposed to be immutable by default though? I thought the borrowing thing was passing the ownership to the caller and then giving it back after it has been used. I need to re-read this portion then, thanks for the help!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 450, "user_id": 4301117, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/81eee027be0d8a17a2dbced4f0ccede2?s=128&d=identicon&r=PG&f=1", "display_name": "Leherenn", "link": "https://stackoverflow.com/users/4301117/leherenn"}, "edited": false, "score": 0, "creation_date": 1428587052, "post_id": 29539676, "comment_id": 47232379, "body": "The vector is immutable, that&#39;s true. Even if the vector were mutable, you wouldn&#39;t be allowed to move the value out like this - the state of the vector would still be in an inconsistent state. That&#39;s why there are specific methods on a vector to remove items safely. And borrowing doesn&#39;t transfer ownership, just like borrowing your friends car doesn&#39;t give you the title. ^_^"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 9, "last_activity_date": 1487287050, "last_edit_date": 1487287050, "creation_date": 1428585631, "answer_id": 29539676, "question_id": 29539399, "link": "https://stackoverflow.com/questions/29539399/cannot-move-out-of-borrowed-content-while-summing-command-line-arguments/29539676#29539676", "title": "&quot;Cannot move out of borrowed content&quot; while summing command line arguments", "body": "<p><code>args</code> is a <code>Vec&lt;String&gt;</code>, and the <code>iter</code> iterator returns references to strings (<code>&amp;String</code>). One trick to see the types is to attempt to assign a value to the unit type <code>()</code>:</p>\n\n<pre><code>let () = args.iter().next();\n</code></pre>\n\n<p>Which has an error that shows the type:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; src/main.rs:5:13\n  |\n5 |         let () = args.iter().next();\n  |             ^^ expected enum `std::option::Option`, found ()\n  |\n  = note: expected type `std::option::Option&lt;&amp;std::string::String&gt;`\n  = note:    found type `()`\n</code></pre>\n\n<p>In your closure, you are attempting to automatically dereference (<code>|a, &amp;b|</code>) the second value. If you <em>were</em> able to dereference it, then the <code>String</code> would be <em>moved</em> out of the vector, which would leave the memory in the vector in an indeterminate state! If we tried to use the vector after this, we could cause a segfault, one of the things Rust is designed to help prevent.</p>\n\n<p>The easiest thing is to not dereference it at all (leaving <code>b</code> as a <code>&amp;String</code>):</p>\n\n<pre><code>use std::env;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    let sum_args: i32 =\n        args\n        .iter()\n        .skip(1)\n        .fold(0, |a, b| a + b.parse::&lt;i32&gt;().expect(\"Not an i32!\"));\n    println!(\"{:?}\", sum_args.to_string());\n}\n</code></pre>\n\n<p>Some additional minor points...</p>\n\n<p>You don't have to specify the vector elements type when you <code>collect</code>:</p>\n\n<pre><code>let args: Vec&lt;_&gt; = env::args().collect();\n</code></pre>\n\n<p>You don't need to create a string to print out a number:</p>\n\n<pre><code>println!(\"{}\", sum_args);\n</code></pre>\n\n<p>And I'd probably have written it as</p>\n\n<pre><code>use std::env;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    let sum_args: i32 =\n        args\n        .iter()\n        .skip(1)\n        .map(|n| n.parse::&lt;i32&gt;().expect(\"Not an i32!\"))\n        .sum();\n    println!(\"{}\", sum_args);\n}\n</code></pre>\n\n<hr>\n\n<p><strong>Overly clever solution warning</strong></p>\n\n<p>If you had to sum up a bunch of iterators of potentially-failed numbers, you could create a type that implements <code>FromIterator</code> and doesn't allocate any memory:</p>\n\n<pre><code>use std::env;\nuse std::iter::{FromIterator, Sum};\n\nstruct SumCollector&lt;T&gt;(T);\n\nimpl&lt;T&gt; FromIterator&lt;T&gt; for SumCollector&lt;T&gt;\n    where T: Sum\n{\n    fn from_iter&lt;I&gt;(iter: I) -&gt; Self\n        where I: IntoIterator&lt;Item = T&gt;\n    {\n        SumCollector(iter.into_iter().sum())\n    }\n}\n\nfn main() {\n    let sum: Result&lt;SumCollector&lt;i32&gt;, _&gt; = env::args().skip(1).map(|v| v.parse()).collect();\n    let sum = sum.expect(\"Something was not an i32!\");\n    println!(\"{}\", sum.0);\n}\n</code></pre>\n\n<hr>\n\n<p>Rust 1.16 should even support this out-of-the-box:</p>\n\n<pre><code>use std::env;\n\nfn main() {\n    let sum: Result&lt;_, _&gt; = env::args().skip(1).map(|v| v.parse::&lt;i32&gt;()).sum();\n    let sum: i32 = sum.expect(\"Something was not an i32!\");\n    println!(\"{}\", sum);\n}\n</code></pre>\n"}], "owner": {"reputation": 450, "user_id": 4301117, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/81eee027be0d8a17a2dbced4f0ccede2?s=128&d=identicon&r=PG&f=1", "display_name": "Leherenn", "link": "https://stackoverflow.com/users/4301117/leherenn"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2231, "favorite_count": 1, "accepted_answer_id": 29539676, "answer_count": 1, "score": 6, "last_activity_date": 1487287050, "creation_date": 1428584911, "last_edit_date": 1487285964, "question_id": 29539399, "link": "https://stackoverflow.com/questions/29539399/cannot-move-out-of-borrowed-content-while-summing-command-line-arguments", "title": "&quot;Cannot move out of borrowed content&quot; while summing command line arguments", "body": "<p>It's my first Rust program and it seems I've already encountered the dreaded borrow checker. :)  </p>\n\n<p>The program should read the arguments passed in the command line, sum them and return the result. I have troubles parsing the arguments into integers.</p>\n\n<pre><code>use std::env;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    let sum_args: i32 =\n        args\n        .iter()\n        .skip(1)\n        .fold(0, |a, &amp;b| a + b.parse::&lt;i32&gt;().ok().expect(\"Not an i32!\"));\n    println!(\"{:?}\", sum_args.to_string());\n}\n</code></pre>\n\n<p>Which fails with:  </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n --&gt; src/main.rs:9:22\n  |\n9 |         .fold(0, |a, &amp;b| a + b.parse::&lt;i32&gt;().ok().expect(\"Not an i32!\"));\n  |                      ^-\n  |                      ||\n  |                      |hint: to prevent move, use `ref b` or `ref mut b`\n  |                      cannot move out of borrowed content\n</code></pre>\n\n<p>How should I proceed?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "edited": false, "score": 4, "creation_date": 1428559962, "post_id": 29530932, "comment_id": 47215505, "body": "I updated Rust to 1.0 and <code>let mut shifts = vec![0; pattern.len()];</code> works directly now... Oops. Before this I had an <code>error: expected </code>:<code>, found </code>.` ../search.rs:17         zero_vec.push(0);` which made no sense."}, {"owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "reply_to_user": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "edited": false, "score": 3, "creation_date": 1428560166, "post_id": 29530932, "comment_id": 47215584, "body": "I&#39;ve been there myself. When I was very first starting out it was very hard to know whether I was using syntax incorrectly, or the syntax had just changed since the last time I updated or since the doc I was reading was updated. I&#39;m really glad we have the beta now and way excited for 1.0. Btw are you using <code>rustup.sh</code> to update Rust? If so you might want to get the latest version of the script, which will grab the beta now instead of nightlies."}, {"owner": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "edited": false, "score": 2, "creation_date": 1428560287, "post_id": 29530932, "comment_id": 47215641, "body": "But that&#39;s why I like most about the language - the community support is wonderful, no downvotes for my noob question. :) Yep I curl&#39;ed the latest <code>rustup.sh</code>. Thanks so much! Now I just have to figure out index access to string elements..."}, {"owner": {"reputation": 79299, "user_id": 589259, "user_type": "registered", "accept_rate": 82, "profile_image": "https://i.stack.imgur.com/vJbKg.jpg?s=128&g=1", "display_name": "Maarten Bodewes", "link": "https://stackoverflow.com/users/589259/maarten-bodewes"}, "edited": false, "score": 0, "creation_date": 1547729523, "post_id": 29530932, "comment_id": 95297256, "body": "Of course, you may ask yourself why you would have to lookup answers for so basic a question in the first place. This is more intuitive in most other languages, e.g. those that default to zero when an array / vector is initialized."}, {"owner": {"reputation": 2478, "user_id": 369495, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/24d44642fd1e7f0840cd0104a900b54c?s=128&d=identicon&r=PG", "display_name": "Tedford", "link": "https://stackoverflow.com/users/369495/tedford"}, "edited": false, "score": 0, "creation_date": 1593285153, "post_id": 29530932, "comment_id": 110728284, "body": "A very noob question but when I did this I ended up with a 2 element vector of 0 and 3 in which the size I was trying to initialize it to was 3.  Is there some criteria that would cause  the initialization to behavior differently?"}], "tags": [], "owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "is_accepted": true, "score": 107, "last_activity_date": 1520957105, "last_edit_date": 1520957105, "creation_date": 1428559441, "answer_id": 29530932, "question_id": 29530011, "link": "https://stackoverflow.com/questions/29530011/creating-a-vector-of-zeros-for-a-specific-size/29530932#29530932", "title": "Creating a vector of zeros for a specific size", "body": "<p>To initialize a vector of zeros (or any other constant value) of a given length, you can use the <code>vec!</code> macro:</p>\n\n<pre><code>let len = 10;\nlet zero_vec = vec![0; len];\n</code></pre>\n\n<p>That said, your function worked for me after just a couple syntax fixes:</p>\n\n<pre><code>fn zeros(size: u32) -&gt; Vec&lt;i32&gt; {\n    let mut zero_vec: Vec&lt;i32&gt; = Vec::with_capacity(size as usize);\n    for i in 0..size {\n        zero_vec.push(0);\n    }\n    return zero_vec;\n}\n</code></pre>\n\n<p><code>uint</code> no longer exists in Rust 1.0, <code>size</code> needed to be cast as <code>usize</code>, and the types for the vectors needed to match (changed <code>let mut zero_vec: Vec&lt;i64&gt;</code> to <code>let mut zero_vec: Vec&lt;i32&gt;</code>.</p>\n"}, {"comments": [{"owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "edited": false, "score": 0, "creation_date": 1428594552, "post_id": 29537747, "comment_id": 47238062, "body": "Is that considered more idiomatic than using vec! directly? Would that run faster?"}, {"owner": {"reputation": 51826, "user_id": 1223693, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/viu9Y.jpg?s=128&g=1", "display_name": "tckmn", "link": "https://stackoverflow.com/users/1223693/tckmn"}, "reply_to_user": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "edited": false, "score": 0, "creation_date": 1428598363, "post_id": 29537747, "comment_id": 47240478, "body": "@anders No idea; I agree that the <code>vec!</code> version looks nice as well. I suppose it couldn&#39;t hurt to try some benchmarks, which I might do when I get home."}, {"owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "edited": false, "score": 0, "creation_date": 1428598479, "post_id": 29537747, "comment_id": 47240529, "body": "Yeah you&#39;ve got me wondering now what the implementation of vec! is. I&#39;ll see if I can find some time to dig into this a little."}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 8, "creation_date": 1428673726, "post_id": 29537747, "comment_id": 47275888, "body": "Using the vec macro is considered more idiomatic, it was added specifically because people did not want to do this."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1428689606, "post_id": 29537747, "comment_id": 47285635, "body": "Note: <code>::&lt;Vec&lt;i32&gt;&gt;</code> is superfluous, type inference can figure it out automatically since it <i>has</i> to be the type of the expression, so you can just use <code>.collect()</code> here."}], "tags": [], "owner": {"reputation": 51826, "user_id": 1223693, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/viu9Y.jpg?s=128&g=1", "display_name": "tckmn", "link": "https://stackoverflow.com/users/1223693/tckmn"}, "is_accepted": false, "score": 10, "last_activity_date": 1515727078, "last_edit_date": 1515727078, "creation_date": 1428580268, "answer_id": 29537747, "question_id": 29530011, "link": "https://stackoverflow.com/questions/29530011/creating-a-vector-of-zeros-for-a-specific-size/29537747#29537747", "title": "Creating a vector of zeros for a specific size", "body": "<p>You can also use the <code>iter::repeat</code> function, which I suppose is \"more idiomatic\" (and just looks nicer to me):</p>\n\n<pre><code>use std::iter;\n\nfn zeros(size: usize) -&gt; Vec&lt;i32&gt; {\n    iter::repeat(0).take(size).collect()\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1428599847, "post_id": 29538829, "comment_id": 47241279, "body": "How does this differ from the last part of @anders answer?"}], "tags": [], "owner": {"reputation": 1252, "user_id": 4253667, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/foxzT.jpg?s=128&g=1", "display_name": "VRage", "link": "https://stackoverflow.com/users/4253667/vrage"}, "is_accepted": false, "score": 15, "last_activity_date": 1515727034, "last_edit_date": 1515727034, "creation_date": 1428583395, "answer_id": 29538829, "question_id": 29530011, "link": "https://stackoverflow.com/questions/29530011/creating-a-vector-of-zeros-for-a-specific-size/29538829#29538829", "title": "Creating a vector of zeros for a specific size", "body": "<p>Here is another way, much shorter. It works with Rust 1.0:</p>\n\n<pre><code>fn zeros(size: u32) -&gt; Vec&lt;i32&gt; {\n    vec![0; size as usize]\n}\n\nfn main() {\n    let vec = zeros(10);\n    for i in vec.iter() {\n        println!(\"{}\", i)\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1265, "user_id": 720302, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/hSURW.png?s=128&g=1", "display_name": "Jocelyn", "link": "https://stackoverflow.com/users/720302/jocelyn"}, "edited": false, "score": 7, "creation_date": 1522324533, "post_id": 48218307, "comment_id": 86118029, "body": "<code>vec!</code> is more efficient when allocating with 0 because it uses <code>RawVec::with_capacity_zeroed()</code>, while <code>.resize()</code> calls <code>.extend_with()</code> which uses a more complex value generator. For other values both use <code>.extend_with()</code> so the benefit is roughly the same."}], "tags": [], "owner": {"reputation": 912, "user_id": 1570826, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/568ad11ab0e853c0e4e8f8ade8bd5278?s=128&d=identicon&r=PG", "display_name": "lu_zero", "link": "https://stackoverflow.com/users/1570826/lu-zero"}, "is_accepted": false, "score": 4, "last_activity_date": 1515720576, "creation_date": 1515720576, "answer_id": 48218307, "question_id": 29530011, "link": "https://stackoverflow.com/questions/29530011/creating-a-vector-of-zeros-for-a-specific-size/48218307#48218307", "title": "Creating a vector of zeros for a specific size", "body": "<p>You may use <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.resize\" rel=\"nofollow noreferrer\">resize</a></p>\n\n<pre><code>let mut v = Vec::new();\nlet l = 42;\nv.resize(l, 0u32);\n</code></pre>\n"}], "owner": {"reputation": 1545, "user_id": 1744274, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/6287be0af95a5e6284e826fdfe14cad9?s=128&d=identicon&r=PG", "display_name": "elleciel", "link": "https://stackoverflow.com/users/1744274/elleciel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 49136, "favorite_count": 4, "accepted_answer_id": 29530932, "answer_count": 4, "score": 89, "last_activity_date": 1520957105, "creation_date": 1428555034, "last_edit_date": 1428632675, "question_id": 29530011, "link": "https://stackoverflow.com/questions/29530011/creating-a-vector-of-zeros-for-a-specific-size", "title": "Creating a vector of zeros for a specific size", "body": "<p>I'd like to initialize a vector of zeros with a specific size that is determined at runtime.</p>\n\n<p>In C, it would be like:</p>\n\n<pre class=\"lang-c prettyprint-override\"><code>int main(void)\n{\n    uint size = get_uchar();\n    int A[size][size];\n    memset(A, 0, size*size*sizeof(int));\n}\n</code></pre>\n\n<p>Here's the helper function that I tried writing in Rust, but I think the slicing syntax <code>0..size</code> is offending the compiler. Besides, it looks more verbose than the C version. Is there a more idiomatic way to do this?</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn zeros(size: u32) -&gt; Vec&lt;i32&gt; {\n    let mut zero_vec: Vec&lt;i32&gt; = Vec::with_capacity(size);\n    for i in 0..size {\n        zero_vec.push(0);\n    }\n    return zero_vec;\n}\n</code></pre>\n\n<p>I swear that the old docs used to explain a <code>from_elem()</code> method <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html\">here</a> and none of the permutations of the <code>[0 ; size]</code> <a href=\"https://github.com/rust-lang/rust/issues/15587\">notation</a> seem to work</p>\n\n<p>I'd like to stick this into a substring search algorithm ultimately:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub fn kmp(text: &amp;str, pattern: &amp;str) -&gt; i64 {\n    let mut shifts = zeros(pattern.len()+1);\n}\n</code></pre>\n"}]