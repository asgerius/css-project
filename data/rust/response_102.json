[{"tags": ["rust"], "comments": [{"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1482360495, "post_id": 41273041, "comment_id": 69747880, "body": "I think now you can do this <code>&amp;addr_string</code>"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 10, "last_activity_date": 1482361567, "last_edit_date": 1495540928, "creation_date": 1482361046, "answer_id": 41273331, "question_id": 41273041, "link": "https://stackoverflow.com/questions/41273041/what-does-combined-together-do-in-rust/41273331#41273331", "title": "What does &amp;* combined together do in Rust?", "body": "<p>In general, <code>&amp;*</code> means to first dereference (<code>*</code>) and then reference (<code>&amp;</code>) a value. In many cases, this would be silly, as we'd end up at the same thing. </p>\n\n<p>However, Rust has <a href=\"https://doc.rust-lang.org/book/deref-coercions.html\" rel=\"nofollow noreferrer\"><em>deref coercions</em></a>. Combined with the <a href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html\" rel=\"nofollow noreferrer\"><code>Deref</code></a> and <a href=\"https://doc.rust-lang.org/std/ops/trait.DerefMut.html\" rel=\"nofollow noreferrer\"><code>DerefMut</code></a> traits, a type can dereference to a <em>different</em> type!</p>\n\n<p>This is useful for <code>String</code>s as that means that they can get all the methods from <code>str</code>, it's useful for <code>Vec&lt;T&gt;</code> as it gains the methods from <code>[T]</code>, and it's super useful for all the smart pointers, like <code>Box&lt;T&gt;</code>, which will have <strong>all the methods</strong> of the contained <code>T</code>!</p>\n\n<p>Following the chain for <code>String</code>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>String --deref--&gt; str --ref--&gt; &amp;str\n</code></pre>\n\n<blockquote>\n  <p>Does not the <code>&amp;</code> mean we are taking its reference, then using the <code>*</code> to dereference it?</p>\n</blockquote>\n\n<p>No, your order of operations is backwards. <code>*</code> and <code>&amp;</code> associate to the right. In this example, dereferencing is first, then referencing.</p>\n\n<blockquote>\n  <p>I think now you can do this <code>&amp;addr_string</code> </p>\n</blockquote>\n\n<p>(from a comment)</p>\n\n<p><em>Sometimes</em>, this will do the same thing. See <a href=\"https://stackoverflow.com/q/28519997/155423\">What are Rust&#39;s exact auto-dereferencing rules?</a> for the full details, but yes, a <code>&amp;String</code> can be passed to a function that requires a <code>&amp;str</code>. There are still times where you need to do this little dance by hand. The most common I can think of is:</p>\n\n<pre><code>let name: Option&lt;String&gt; = Some(\"Hello\".to_string());\nlet name2: Option&lt;&amp;str&gt; = name.as_ref().map(|s| &amp;**s);\n</code></pre>\n\n<p>You'll note that we actually dereference <em>twice</em>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>&amp;String --&gt;deref--&gt; String --deref--&gt; str --ref--&gt; &amp;str\n</code></pre>\n\n<p>Although this case can now be done with <code>name.as_ref().map(String::as_str);</code></p>\n"}, {"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 15, "last_activity_date": 1482362404, "last_edit_date": 1482362404, "creation_date": 1482361452, "answer_id": 41273406, "question_id": 41273041, "link": "https://stackoverflow.com/questions/41273041/what-does-combined-together-do-in-rust/41273406#41273406", "title": "What does &amp;* combined together do in Rust?", "body": "<p><strong>In short</strong>: the <code>*</code> triggers an explicit deref, which can be overloaded via <a href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html\" rel=\"noreferrer\"><code>ops::Deref</code></a>.</p>\n\n<hr>\n\n<h3>More Detail</h3>\n\n<p>Look at this code:</p>\n\n<pre><code>let s = \"hi\".to_string();  // : String\nlet a = &amp;s;\n</code></pre>\n\n<p>What's the type of <code>a</code>? It's simply <code>&amp;String</code>! This shouldn't be very surprising, since we take the reference of a <code>String</code>. Ok, but what about this?</p>\n\n<pre><code>let s = \"hi\".to_string();  // : String\nlet b = &amp;*s;   // equivalent to `&amp;(*s)`\n</code></pre>\n\n<p>What's the type of <code>b</code>? It's <code>&amp;str</code>! Wow, what happened? </p>\n\n<p>Note that <code>*s</code> is executed first. As most operators, the dereference operator <code>*</code> is also overloadable and the usage of the operator can be considered syntax sugar for <code>*std::ops::Deref::deref(&amp;s)</code> (note that we recursively dereferencing here!). <code>String</code> <em>does</em> overload this operator:</p>\n\n<pre><code>impl Deref for String {\n    type Target = str;\n    fn deref(&amp;self) -&gt; &amp;str { ... }\n}\n</code></pre>\n\n<p>So, <code>*s</code> is actually <code>*std::ops::Deref::deref(&amp;s)</code>, in which the <code>deref()</code> function has the return type <code>&amp;str</code> which is then dereferenced again. Thus, <code>*s</code> has the type <code>str</code> (note the lack of <code>&amp;</code>).</p>\n\n<p>Since <code>str</code> is unsized and not very handy on its own, we'd like to have a reference to it instead, namely <code>&amp;str</code>. We can do this by adding a <code>&amp;</code> in front of the expression! Tada, now we reached the type <code>&amp;str</code>!</p>\n\n<hr>\n\n<p><code>&amp;*s</code> is rather the manual and explicit form. Often, the <code>Deref</code>-overload is used via automatic deref coercion. When the target type is fixed, the compiler will deref for you:</p>\n\n<pre><code>fn takes_string_slice(_: &amp;str) {}\n\nlet s = \"hi\".to_string();  // : String\ntakes_string_slice(&amp;s); // this works!\n</code></pre>\n"}], "owner": {"reputation": 1222, "user_id": 7152817, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/b2b6ef3fc885710cadba2ae10136b473?s=128&d=identicon&r=PG&f=1", "display_name": "D. Ataro", "link": "https://stackoverflow.com/users/7152817/d-ataro"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 513, "favorite_count": 0, "accepted_answer_id": 41273406, "answer_count": 2, "score": 7, "last_activity_date": 1482362404, "creation_date": 1482359606, "last_edit_date": 1482361119, "question_id": 41273041, "link": "https://stackoverflow.com/questions/41273041/what-does-combined-together-do-in-rust", "title": "What does &amp;* combined together do in Rust?", "body": "<p>I was reading through the book section about <code>String</code>s and found they were using <code>&amp;*</code> combined together to convert a piece of text. The following is what it says:</p>\n\n<pre><code>use std::net::TcpStream;\n\nTcpStream::connect(\"192.168.0.1:3000\"); // Parameter is of type &amp;str.\n\nlet addr_string = \"192.168.0.1:3000\".to_string();\nTcpStream::connect(&amp;*addr_string); // Convert `addr_string` to &amp;str.\n</code></pre>\n\n<p>In other words, they are saying they are converting a <code>String</code> to a <code>&amp;str</code>. But why is that conversion done using both of the aforementioned signs? Should this not be done using some other method? Does not the <code>&amp;</code> mean we are taking its reference, then using the <code>*</code> to dereference it?</p>\n"}, {"tags": ["rust", "inline-assembly"], "comments": [{"owner": {"reputation": 4398, "user_id": 1056174, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/GJiNL.jpg?s=128&g=1", "display_name": "Carl Patenaude Poulin", "link": "https://stackoverflow.com/users/1056174/carl-patenaude-poulin"}, "edited": false, "score": 2, "creation_date": 1482352086, "post_id": 41271353, "comment_id": 69743840, "body": "Associated reddit thread: <a href=\"https://www.reddit.com/r/rust/comments/5jm4ww/translating_inline_assembler_expression_from_gcc/\" rel=\"nofollow noreferrer\">reddit.com/r/rust/comments/5jm4ww/&hellip;</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1482353079, "post_id": 41271353, "comment_id": 69744407, "body": "You are likely going to need to work to provide a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>. While I don&#39;t have Xen, <a href=\"http://play.integer32.com/?gist=35a5ab7e6dc00be69301632b88ef8851&amp;version=nightly\" rel=\"nofollow noreferrer\">I can compile x86 assembly that is close to yours</a> just fine."}, {"owner": {"reputation": 4398, "user_id": 1056174, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/GJiNL.jpg?s=128&g=1", "display_name": "Carl Patenaude Poulin", "link": "https://stackoverflow.com/users/1056174/carl-patenaude-poulin"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1482358397, "post_id": 41271353, "comment_id": 69747027, "body": "I did as you said, and it made the issue obvious. Thanks for the help."}], "answers": [{"comments": [{"owner": {"reputation": 4398, "user_id": 1056174, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/GJiNL.jpg?s=128&g=1", "display_name": "Carl Patenaude Poulin", "link": "https://stackoverflow.com/users/1056174/carl-patenaude-poulin"}, "edited": false, "score": 1, "creation_date": 1482357913, "post_id": 41272593, "comment_id": 69746795, "body": "This is it. Turns out that <code>MyEnum::MyEnumCase as isize</code> was once considered a compile-time constant, but isn&#39;t anymore. Minimal repro: <a href=\"https://gist.github.com/lilred/3868c48004ce344d87002f540d5b21f3\" rel=\"nofollow noreferrer\">gist.github.com/lilred/3868c48004ce344d87002f540d5b21f3</a>"}, {"owner": {"reputation": 4398, "user_id": 1056174, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/GJiNL.jpg?s=128&g=1", "display_name": "Carl Patenaude Poulin", "link": "https://stackoverflow.com/users/1056174/carl-patenaude-poulin"}, "edited": false, "score": 0, "creation_date": 1482358354, "post_id": 41272593, "comment_id": 69747001, "body": "I&#39;ve edited my question to better reflect the actual issue."}], "tags": [], "owner": {"reputation": 2978, "user_id": 904148, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/4cf9d0b9f5d61826525247bd5b79cdc0?s=128&d=identicon&r=PG", "display_name": "Timothy Baldwin", "link": "https://stackoverflow.com/users/904148/timothy-baldwin"}, "is_accepted": true, "score": 4, "last_activity_date": 1482358620, "last_edit_date": 1482358620, "creation_date": 1482357472, "answer_id": 41272593, "question_id": 41271353, "link": "https://stackoverflow.com/questions/41271353/invalid-operand-for-inline-asm-constraint-i-when-writing-inline-x86-64-assembl/41272593#41272593", "title": "Invalid operand for inline asm constraint &#39;i&#39; when writing inline x86_64 assembly", "body": "<p>The value for the <code>\"i\"</code> constraint must be a compile-time constant and you are supplying it something that isn't. If you move the addition into Rust, you could use a register as well as a constant using the constraints <code>\"ri\"</code>.</p>\n\n<p>Whether something is a constant for the purpose of inline assembler can be affected by optimization options.</p>\n"}], "owner": {"reputation": 4398, "user_id": 1056174, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/GJiNL.jpg?s=128&g=1", "display_name": "Carl Patenaude Poulin", "link": "https://stackoverflow.com/users/1056174/carl-patenaude-poulin"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 981, "favorite_count": 0, "accepted_answer_id": 41272593, "answer_count": 1, "score": 4, "last_activity_date": 1482358620, "creation_date": 1482352009, "last_edit_date": 1482358340, "question_id": 41271353, "link": "https://stackoverflow.com/questions/41271353/invalid-operand-for-inline-asm-constraint-i-when-writing-inline-x86-64-assembl", "title": "Invalid operand for inline asm constraint &#39;i&#39; when writing inline x86_64 assembly", "body": "<p>The code below used to build just fine back in April (Rust version ~1.6), but it doesn't anymore. </p>\n\n<pre><code>#![feature(asm)]\n\nenum MyEnum { One = 1 }\n\nfn main() {\n    unsafe {\n        asm!(\"nop\" : : \"i\" (MyEnum::One as isize) : : ); // broken\n    }\n}\n</code></pre>\n\n<p>The error message does not point to any obvious changes that might be causing this.</p>\n"}, {"tags": ["rust", "mio"], "comments": [{"owner": {"reputation": 175, "user_id": 4776496, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c319ce7e959e835122dd719320005556?s=128&d=identicon&r=PG&f=1", "display_name": "kper", "link": "https://stackoverflow.com/users/4776496/kper"}, "reply_to_user": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1482352990, "post_id": 41271160, "comment_id": 69744363, "body": "What do you mean with lower?"}, {"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1482353135, "post_id": 41271160, "comment_id": 69744442, "body": "why not take the smaller?"}], "answers": [{"tags": [], "owner": {"reputation": 175, "user_id": 4776496, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c319ce7e959e835122dd719320005556?s=128&d=identicon&r=PG&f=1", "display_name": "kper", "link": "https://stackoverflow.com/users/4776496/kper"}, "is_accepted": true, "score": 0, "last_activity_date": 1482354989, "last_edit_date": 1482354989, "creation_date": 1482354763, "answer_id": 41271994, "question_id": 41271160, "link": "https://stackoverflow.com/questions/41271160/is-it-possible-to-register-multiple-timeouts-in-mio/41271994#41271994", "title": "Is it possible to register multiple timeouts in mio?", "body": "<p>I registered a tuple with an id</p>\n\n<pre><code>event_loop.timeout_ms((id, ServerTimeout::T1(timeout)), duration)\n</code></pre>\n\n<p>It didn't work, so I added <code>id</code> to <code>ServerTimeout::T1</code> and called the <code>timeout_ms</code> method again:</p>\n\n<pre><code>event_loop.timeout_ms(ServerTimeout::T1(id, timeout), duration)\n</code></pre>\n"}], "owner": {"reputation": 175, "user_id": 4776496, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c319ce7e959e835122dd719320005556?s=128&d=identicon&r=PG&f=1", "display_name": "kper", "link": "https://stackoverflow.com/users/4776496/kper"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 83, "favorite_count": 0, "accepted_answer_id": 41271994, "answer_count": 1, "score": 1, "last_activity_date": 1482354989, "creation_date": 1482351142, "last_edit_date": 1482352440, "question_id": 41271160, "link": "https://stackoverflow.com/questions/41271160/is-it-possible-to-register-multiple-timeouts-in-mio", "title": "Is it possible to register multiple timeouts in mio?", "body": "<p>I have written a TCP server in mio and registered multiple timeouts, but only the last registered timeout fires. Do I need a wrapper for my timeouts to combine them or are there any other ways to register multiple timeouts in mio v0.5?</p>\n"}, {"tags": ["rust", "sdl", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 2727, "user_id": 2512774, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/8323bc93db4001617eaf11df02f33a18?s=128&d=identicon&r=PG", "display_name": "Carl Levasseur", "link": "https://stackoverflow.com/users/2512774/carl-levasseur"}, "edited": false, "score": 3, "creation_date": 1506274379, "post_id": 41271422, "comment_id": 79742905, "body": "<b>FontLoader (and thus Font) does not live long enough</b>: Isn&#39;t the lifetime of <code>FontLoader</code> the same as the Phi that contains it ?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2727, "user_id": 2512774, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/8323bc93db4001617eaf11df02f33a18?s=128&d=identicon&r=PG", "display_name": "Carl Levasseur", "link": "https://stackoverflow.com/users/2512774/carl-levasseur"}, "edited": false, "score": 0, "creation_date": 1506277591, "post_id": 41271422, "comment_id": 79743935, "body": "@CarlLevasseur yes, the lifetime of <code>FontLoader</code> and its containing <code>Phi</code> are the same. Why do you ask?"}, {"owner": {"reputation": 2727, "user_id": 2512774, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/8323bc93db4001617eaf11df02f33a18?s=128&d=identicon&r=PG", "display_name": "Carl Levasseur", "link": "https://stackoverflow.com/users/2512774/carl-levasseur"}, "edited": false, "score": 3, "creation_date": 1506278262, "post_id": 41271422, "comment_id": 79744156, "body": "Doesn&#39;t that mean it has the <code>&#39;window</code> lifetime then ? i don&#39;t understand why it does not live long enough if its lifetime is the same as the <code>Phi</code> object and therefore, the same as <code>Phi.font</code> ? In what case would the font loader be free&#39;d before then end of the <code>&#39;window</code> lifetime ?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2727, "user_id": 2512774, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/8323bc93db4001617eaf11df02f33a18?s=128&d=identicon&r=PG", "display_name": "Carl Levasseur", "link": "https://stackoverflow.com/users/2512774/carl-levasseur"}, "edited": false, "score": 0, "creation_date": 1506278505, "post_id": 41271422, "comment_id": 79744237, "body": "@CarlLevasseur <i>In what case would the font loader be free&#39;d before then end of the <code>&#39;window</code> lifetime</i> \u2014 in <b>every</b> case, I believe. <i>Doesn&#39;t that mean it has the <code>&#39;window</code> lifetime</i> \u2014 no. It contains a reference that has the <code>window</code> lifetime, but itself has a different lifetime."}, {"owner": {"reputation": 2924, "user_id": 5319267, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8711578a7edbce62929678c9d6ea8201?s=128&d=identicon&r=PG&f=1", "display_name": "Mario Ishac", "link": "https://stackoverflow.com/users/5319267/mario-ishac"}, "edited": false, "score": 0, "creation_date": 1610827859, "post_id": 41271422, "comment_id": 116257038, "body": "I&#39;m trying to understand a <code>main</code> that would crash had the top example you provided been allowed to compile. Is this one? <a href=\"https://gist.github.com/rust-play/e5e9aa7374de695f896717f058d8c48c\" rel=\"nofollow noreferrer\">gist.github.com/rust-play/e5e9aa7374de695f896717f058d8c48c</a> In that <code>font_str</code> might have been freed before we print?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2924, "user_id": 5319267, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8711578a7edbce62929678c9d6ea8201?s=128&d=identicon&r=PG&f=1", "display_name": "Mario Ishac", "link": "https://stackoverflow.com/users/5319267/mario-ishac"}, "edited": false, "score": 2, "creation_date": 1610981052, "post_id": 41271422, "comment_id": 116297115, "body": "@MarioIshac since lifetimes prevent incorrect code from compiling, you need to use raw pointers to demonstrate the problem. <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2b5db621ea4921dcc1aa14b6733d2ab8\" rel=\"nofollow noreferrer\">Here&#39;s one such possibility</a>. Note that the pointer now points to an invalid location."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 28, "last_activity_date": 1610980624, "last_edit_date": 1610980624, "creation_date": 1482352271, "answer_id": 41271422, "question_id": 41270052, "link": "https://stackoverflow.com/questions/41270052/cannot-infer-an-appropriate-lifetime-for-autoref-due-to-conflicting-requirements/41271422#41271422", "title": "Cannot infer an appropriate lifetime for autoref due to conflicting requirements", "body": "<p>Here's a smaller example that reproduces the problem:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>struct FontLoader(String);\nstruct Font&lt;'a&gt;(&amp;'a str);\n\nimpl FontLoader {\n    fn load(&amp;self) -&gt; Font {\n        Font(&amp;self.0)\n    }\n}\n\nstruct Window;\n\nstruct Phi&lt;'window&gt; {\n    window: &amp;'window Window,\n    loader: FontLoader,\n    font: Option&lt;Font&lt;'window&gt;&gt;,\n}\n\nimpl&lt;'window&gt; Phi&lt;'window&gt; {\n    fn do_the_thing(&amp;mut self) {\n        let font = self.loader.load();\n        self.font = Some(font);\n    }\n}\n\nfn main() {}\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements\n  --&gt; src/main.rs:20:32\n   |\n20 |         let font = self.loader.load();\n   |                                ^^^^\n   |\nnote: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 19:5...\n  --&gt; src/main.rs:19:5\n   |\n19 |     fn do_the_thing(&amp;mut self) {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...so that reference does not outlive borrowed content\n  --&gt; src/main.rs:20:20\n   |\n20 |         let font = self.loader.load();\n   |                    ^^^^^^^^^^^\nnote: but, the lifetime must be valid for the lifetime `'window` as defined on the impl at 18:6...\n  --&gt; src/main.rs:18:6\n   |\n18 | impl&lt;'window&gt; Phi&lt;'window&gt; {\n   |      ^^^^^^^\nnote: ...so that the expression is assignable\n  --&gt; src/main.rs:21:21\n   |\n21 |         self.font = Some(font);\n   |                     ^^^^^^^^^^\n   = note: expected `Option&lt;Font&lt;'window&gt;&gt;`\n              found `Option&lt;Font&lt;'_&gt;&gt;`\n</code></pre>\n<p>The problem is indeed that you have constructed an impossible case. Specifically, the code states these points:</p>\n<ol>\n<li><p><code>Phi</code> is going to include a reference to a <code>Window</code>. That referred-to value lives for the lifetime <code>'window</code>.</p>\n</li>\n<li><p><code>Phi</code> is going to include a <code>Font</code>, which contains a reference. That referred-to value lives for the lifetime <code>'window</code>.</p>\n</li>\n<li><p><code>FontLoader</code> returns a <code>Font</code> which contains a reference to a value with the lifetime <strong>of the loader</strong>. This is due to lifetime inference, which when expanded looks like:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>impl FontLoader {\n    fn load&lt;'a&gt;(&amp;'a self) -&gt; Font&lt;'a&gt; {\n        Font(&amp;self.0)\n    }\n}\n</code></pre>\n<p>I highly encourage adding <code>#![deny(rust_2018_idioms)]</code> to your crate, which will disallow this specific type of lifetime inference.</p>\n</li>\n</ol>\n<p>Then the code attempts to load a <code>Font</code> from the <code>FontLoader</code> in <code>Phi</code>, which <strong>does not</strong> have the lifetime <code>'window</code> and store that <code>Font</code> into <code>Phi</code>. <code>FontLoader</code> (and thus <code>Font</code>) does not live long enough, so it cannot be stored in <code>Phi</code>.</p>\n<p>The compiler has correctly prevented incorrect code.</p>\n<hr />\n<p>Your next attempt would probably be to introduce a second lifetime:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>struct Phi&lt;'window, 'font&gt; {\n    window: &amp;'window Window,\n    loader: FontLoader,\n    font: Option&lt;Font&lt;'font&gt;&gt;,\n}\n\nimpl&lt;'window, 'font&gt; Phi&lt;'window, 'font&gt; {\n    fn do_the_thing(&amp;'font mut self) {\n        let font = self.loader.load();\n        self.font = Some(font);\n    }\n}\n</code></pre>\n<p>This will actually compile, but probably doesn't do what you want. See <a href=\"https://stackoverflow.com/q/32300132/155423\">Why can&#39;t I store a value and a reference to that value in the same struct?</a> for further information.</p>\n<p>More likely, you want to take a reference to the font loader:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>struct Phi&lt;'a&gt; {\n    window: &amp;'a Window,\n    loader: &amp;'a FontLoader,\n    font: Option&lt;Font&lt;'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Phi&lt;'a&gt; {\n    fn do_the_thing(&amp;mut self) {\n        let font = self.loader.load();\n        self.font = Some(font);\n    }\n}\n</code></pre>\n<p>Here, I've renamed the lifetime as it isn't strictly for the window anymore.</p>\n"}], "owner": {"reputation": 285, "user_id": 5224855, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f14c870e46b2038f68f63c9b2c30d5a2?s=128&d=identicon&r=PG&f=1", "display_name": "Brad Ziolko", "link": "https://stackoverflow.com/users/5224855/brad-ziolko"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 16486, "favorite_count": 4, "accepted_answer_id": 41271422, "answer_count": 1, "score": 28, "last_activity_date": 1610980624, "creation_date": 1482346754, "last_edit_date": 1482350978, "question_id": 41270052, "link": "https://stackoverflow.com/questions/41270052/cannot-infer-an-appropriate-lifetime-for-autoref-due-to-conflicting-requirements", "title": "Cannot infer an appropriate lifetime for autoref due to conflicting requirements", "body": "<p>I'm having lifetime issues with a particular function in my code.  I'm following a tutorial in an attempt to learn Rust and SDL.  The tutorial was slightly older and the SDL library has changed since its been written, so I'm following along while also adapting it towards the latest version of Rust-SDL.</p>\n\n<p>The lifetime problem is in this function:</p>\n\n<pre><code>pub fn ttf_str_sprite(&amp;mut self, text: &amp;str, font_path: &amp;'static str, size: i32, color: Color) -&gt; Option&lt;Sprite&gt; {\n    if let Some(font) = self.cached_fonts.get(&amp;(font_path, size)) {\n        return font.render(text).blended(color).ok()\n            .and_then(|surface| self.renderer.create_texture_from_surface(&amp;surface).ok())\n            .map(Sprite::new)\n    }\n    //::sdl2_ttf::Font::from_file(Path::new(font_path), size).ok()\n    self.ttf_context.load_font(Path::new(font_path), size as u16).ok()\n        .and_then(|font| {\n            self.cached_fonts.insert((font_path, size), font);\n            self.ttf_str_sprite(text, font_path, size, color)\n    })\n}\n</code></pre>\n\n<p>particularly with the line <code>self.ttf_context.load_font(Path::new(font_path), size as u16).ok()</code>.  The commented line above it is the old SDL version's font loading method.</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements\n  --&gt; src\\phi/mod.rs:57:26\n   |\n57 |         self.ttf_context.load_font(Path::new(font_path), size as u16).ok()\n   |                          ^^^^^^^^^\n   |\nhelp: consider using an explicit lifetime parameter as shown: fn ttf_str_sprite(&amp;'window mut self, text: &amp;str, font_path: &amp;'static str,\n              size: i32, color: Color) -&gt; Option&lt;Sprite&gt;\n</code></pre>\n\n<p>The struct object for that implementation looks like this:</p>\n\n<pre><code>pub struct Phi&lt;'window&gt; {\n    pub events: Events,\n    pub renderer: Renderer&lt;'window&gt;,\n    pub ttf_context: Sdl2TtfContext,\n\n    cached_fonts: HashMap&lt;(&amp;'static str, i32), ::sdl2_ttf::Font&lt;'window&gt;&gt;\n}\n</code></pre>\n\n<p>The method is trying to load a font from Phi's <code>ttf_context</code> and load it into the hashmap.  The Rust compiler suggested I add a lifetime to <code>self</code> in the function parameters, which, when I did that, caused a cascading effect to adding lifetimes to every method calling the original one, all the way down to <code>main()</code> and didn't help anything.</p>\n\n<p>Since I'm still new to Rust, I'm not sure where the lifetime conflict resides or why this is happening.  As a guess, I'm thinking that the <code>Font</code> object that is being generated is supposed to die with the end of that method but instead it's being loaded into a hashmap with a lifetime of <code>'window</code> and those two conflict.  I don't know enough about Rust to fix that, though, or if that's even correct.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1482344577, "last_edit_date": 1495541782, "creation_date": 1482343466, "answer_id": 41269143, "question_id": 41269043, "link": "https://stackoverflow.com/questions/41269043/how-would-one-return-a-function-from-a-function-in-rust/41269143#41269143", "title": "How would one return a function from a function in Rust?", "body": "<p>The parenthesis mean \"call the function with these arguments\". Don't do that:</p>\n\n<pre><code>fn func_exit() -&gt; bool {\n    println!(\"hi\");\n    true\n}\n\nfn locate_func() -&gt; fn() -&gt; bool {\n    func_exit\n}\n\nfn main() {\n    let f = locate_func();\n    f();\n}\n</code></pre>\n\n<p>Related but distinct: <a href=\"https://stackoverflow.com/q/25445761/155423\">Returning a closure from a function</a>.</p>\n"}], "owner": {"reputation": 1222, "user_id": 7152817, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/b2b6ef3fc885710cadba2ae10136b473?s=128&d=identicon&r=PG&f=1", "display_name": "D. Ataro", "link": "https://stackoverflow.com/users/7152817/d-ataro"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1406, "favorite_count": 2, "accepted_answer_id": 41269143, "answer_count": 1, "score": 2, "last_activity_date": 1482344577, "creation_date": 1482343116, "last_edit_date": 1482343485, "question_id": 41269043, "link": "https://stackoverflow.com/questions/41269043/how-would-one-return-a-function-from-a-function-in-rust", "title": "How would one return a function from a function in Rust?", "body": "<p>What I currently have and have tried:</p>\n\n<pre><code>fn locate_func() -&gt; fn() -&gt; bool {\n    func_exit()\n}\n</code></pre>\n\n<p>The above piece of code shows what I am trying to accomplish. I would like to return <code>func_exit</code> in the form of what I assume would be a pointer, to whatever variable binding might decide it needs that specific code, as well as once I have retrieved the function I would like to run it. But I am certain that I can figure out the running part on my own.</p>\n\n<pre><code>&amp;func_exit()\n</code></pre>\n\n<p>I have tried, but as you would most certainly know that simply evaluates the function and then returns a pointer pointing to the boolean on the stack.</p>\n\n<pre><code>*&amp;func_exit()\n&amp;*func_exit() // or\n</code></pre>\n\n<p>I believe I saw something similar in the Rust book at some point, but I have tried both of those combinations for this case, as well as tried doing the same thing with parenthesis in all the different ways, but that still evaluates the function first, then points to the evaluated boolean.</p>\n"}, {"tags": ["rust", "immutability", "borrow-checker"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1482334452, "post_id": 41266071, "comment_id": 69733641, "body": "please show the work you have done with <code>Cell</code> and <code>RefCell</code>. There is a lot of documentation on those types in the <a href=\"https://doc.rust-lang.org/std/cell/index.html\" rel=\"nofollow noreferrer\">std::cell</a> docs."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1482335097, "post_id": 41266071, "comment_id": 69734082, "body": "The direct answer to your stated question (<i>How do I tell Rust it is ok to borrow self as immutable when it is already borrowed mutably?</i>) is: <b>you don&#39;t</b>. It is inherently unsafe to do so."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1482335205, "post_id": 41266071, "comment_id": 69734165, "body": "@ker: I get the idea of <code>Cell</code> and <code>RefCell</code>, I&#39;m just not sure how best to apply them to this case. The documentation doesn&#39;t really help with that."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1482335937, "post_id": 41266071, "comment_id": 69734668, "body": "A (non-)compilable minimal example that I believe demonstrates the exact error the OP is getting: <a href=\"https://play.rust-lang.org/?gist=075e10f188f6d73c3be762df52dd8444&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">playground</a>. Despite the obvious shortcomings of the OP&#39;s code, I&#39;d also be curious how to structure things so that the <code>while</code> loop becomes possible."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1482336192, "post_id": 41266071, "comment_id": 69734885, "body": "@user4815162342: Thanks! I&#39;ll add it to the question."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482336197, "post_id": 41266071, "comment_id": 69734890, "body": "@Shepmaster: Ok badly worded, but how do make the example work in any case?"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 3, "creation_date": 1482337374, "post_id": 41266071, "comment_id": 69735655, "body": "Example code would be less confusing if it avoided gratuitous use of atomic types in an otherwise mutable data structure. Note that <code>x.store(x.load() + 1)</code> is an antipattern that defeats the purpose of atomic in <i>any</i> language."}, {"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1482339198, "post_id": 41266071, "comment_id": 69736743, "body": "Linked: <a href=\"http://stackoverflow.com/questions/41190333/mutable-borrow-of-self-doesnt-change-to-immutable\" title=\"mutable borrow of self doesnt change to immutable\">stackoverflow.com/questions/41190333/&hellip;</a>"}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1482342455, "post_id": 41266071, "comment_id": 69738504, "body": "@Stargateur: I&#39;m not sure that is the same issue. In this case <code>player</code> really is legitimately mutably borrowed since <code>manager.do_a_bit_more_work()</code> really does mutate it."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1482356917, "post_id": 41266071, "comment_id": 69746314, "body": "@Stargateur: Ha that is cheating! You can&#39;t create an entirely new <code>Manager</code> on each loop. It has some (omitted in the example) state."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1482399034, "post_id": 41266071, "comment_id": 69761215, "body": "@Stargateur: Well technically <code>fn main() {}</code> is equivalent since the code doesn&#39;t actually do anything! I think the example is clear enough without being overly complex."}, {"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1482419343, "post_id": 41266071, "comment_id": 69774131, "body": "@Timmmm I don&#39;t understand why you want a <code>Manager</code> of <code>Worker</code>, if after you use <code>Worker</code> yourself in the <code>while</code>. Why don&#39;t you put <code>Worker</code> in the <code>struct</code> Manager?"}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1482422557, "post_id": 41266071, "comment_id": 69776382, "body": "@Stargateur: This is a simplification of my actual code. I think it makes my question clear."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 0, "last_activity_date": 1482442153, "creation_date": 1482442153, "answer_id": 41291905, "question_id": 41266071, "link": "https://stackoverflow.com/questions/41266071/how-do-i-safely-use-an-object-while-it-is-mutably-borrowed/41291905#41291905", "title": "How do I safely use an object while it is mutably borrowed?", "body": "<p>Here's the simpler example I'm going to use:</p>\n\n<pre><code>struct Manager&lt;F&gt; {\n    cb: F,\n}\nimpl&lt;F&gt; Manager&lt;F&gt;\n    where F: FnMut()\n{\n    fn do_a_bit_more_work(&amp;mut self) { (self.cb)() }\n}\n\nstruct Worker;\nimpl Worker {\n    fn do_work(&amp;mut self) {}\n    fn get_progress(&amp;self) -&gt; u8 { 100 }\n}\n\nfn main() {\n    let mut worker = Worker;\n\n    let mut manager = Manager {\n        cb: || worker.do_work()\n    };\n\n    while worker.get_progress() &lt; 100 {\n        manager.do_a_bit_more_work();\n    }\n}\n</code></pre>\n\n<p>Adding <code>RefCell</code> allows it to compile:</p>\n\n<pre><code>use std::cell::RefCell;\n\nfn main() {\n    let worker = RefCell::new(Worker);\n\n    let mut manager = Manager {\n        cb: || worker.borrow_mut().do_work()\n    };\n\n    while worker.borrow().get_progress() &lt; 100 {\n        manager.do_a_bit_more_work();\n    }\n}\n</code></pre>\n\n<p>Now the closure borrows an immutable reference of the <code>RefCell&lt;Worker&gt;</code> and checking for an exclusive mutable borrow moves from compile time to runtime.</p>\n\n<p>Of course, <code>RefCell</code> isn't required to <em>solve the problem</em>, but avoiding <code>RefCell</code> does mean you have to look at the problem from a different direction. One solution is instead of keeping the <code>Worker</code>, give it to the <code>Manager</code>. Then borrow it back as needed:</p>\n\n<pre><code>trait DoWork {\n    fn do_work(&amp;mut self);\n}\n\nstruct Manager&lt;T&gt; {\n    work: T,\n}\n\nimpl&lt;T&gt; Manager&lt;T&gt;\n    where T: DoWork\n{\n    fn do_a_bit_more_work(&amp;mut self) {\n        self.work.do_work()\n    }\n\n    fn inspect&lt;F, U&gt;(&amp;self, mut f: F) -&gt; U\n        where F: FnMut(&amp;T) -&gt; U\n    {\n        f(&amp;self.work)\n    }\n\n    // Optionally\n    // fn inspect_mut&lt;F, U&gt;(&amp;mut self, mut f: F) -&gt; U\n    //    where F: FnMut(&amp;mut T) -&gt; U\n    // {\n    //     f(&amp;mut self.work)\n    // }\n\n    fn into_inner(self) -&gt; T {\n        self.work\n    }\n}\n\nstruct Worker;\nimpl Worker {\n    fn get_progress(&amp;self) -&gt; u8 {\n        100\n    }\n}\n\nimpl DoWork for Worker {\n    fn do_work(&amp;mut self) {}\n}\n\nfn main() {\n    let worker = Worker;\n\n    let mut manager = Manager { work: worker };\n\n    while manager.inspect(|w| w.get_progress()) &lt; 100 {\n        manager.do_a_bit_more_work();\n    }\n\n    let worker = manager.into_inner();\n}\n</code></pre>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 115, "favorite_count": 0, "answer_count": 1, "score": -2, "last_activity_date": 1482442153, "creation_date": 1482333363, "last_edit_date": 1482342510, "question_id": 41266071, "link": "https://stackoverflow.com/questions/41266071/how-do-i-safely-use-an-object-while-it-is-mutably-borrowed", "title": "How do I safely use an object while it is mutably borrowed?", "body": "<p>I have <a href=\"https://play.rust-lang.org/?gist=075e10f188f6d73c3be762df52dd8444&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">this code</a>:</p>\n\n<pre><code>use std::sync::atomic::{AtomicIsize, Ordering};\n\n#[derive(Default)]\npub struct Worker {\n    work: Vec&lt;u32&gt;,\n    progress: AtomicIsize,\n}\n\nimpl Worker {\n    fn do_work(&amp;mut self) {\n        self.work.push(0u32);\n        self.progress.store(self.progress.load(Ordering::SeqCst) + 1, Ordering::SeqCst);\n    }\n    fn get_progress(&amp;self) -&gt; isize {\n        self.progress.load(Ordering::SeqCst)\n    }\n}\n\npub struct Manager&lt;CB: FnMut()&gt; {\n    cb: CB\n}\n\nimpl&lt;CB: FnMut()&gt; Manager&lt;CB&gt; {\n    fn do_a_bit_more_work(&amp;mut self) {\n        (self.cb)();\n    }\n}\n\nfn main() {\n    let mut worker = Worker::default();\n\n    let mut manager = Manager {\n        cb: || worker.do_work()\n    };\n\n    while worker.get_progress() &lt; 100 {\n        manager.do_a_bit_more_work();\n    }\n}\n</code></pre>\n\n<p>That is, I have some manager that calls a callback to do some work. I want the callback to be <code>Worker::do_work()</code> and that function updates the members of <code>Worker</code> so it needs <code>&amp;mut self</code>. However once I pass <code>worker.do_work()</code> to the manager it means <code>worker</code> is mutably borrowed so I can never use it again.</p>\n\n<p>I want to use it again to check progress, and maybe change its behaviour. I can use atomic operations and mutexes and so on to try to make sure it is safe to do so, but how can I tell Rust to allow this without getting the <code>cannot borrow X as immutable because it is also borrowed as mutable</code> error?</p>\n\n<p>I'm guessing it is something to do with <code>Cell</code> or <code>RefCell</code> but I can't work it out.</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 2, "creation_date": 1482328096, "post_id": 41264166, "comment_id": 69729241, "body": "Your first two examples return a reference, so they are not really comparable with the last one that returns an owned object."}, {"owner": {"reputation": 3152, "user_id": 1525759, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/LHtNL.jpg?s=128&g=1", "display_name": "Addison", "link": "https://stackoverflow.com/users/1525759/addison"}, "edited": false, "score": 0, "creation_date": 1543547064, "post_id": 41264166, "comment_id": 93967420, "body": "Does anyone know if there&#39;s any solution or alternative to this now?"}], "answers": [{"comments": [{"owner": {"reputation": 321, "user_id": 6193633, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/f642d3c45da4db031e2d41798d1801a5?s=128&d=identicon&r=PG&f=1", "display_name": "kdy", "link": "https://stackoverflow.com/users/6193633/kdy"}, "edited": false, "score": 0, "creation_date": 1482330834, "post_id": 41264684, "comment_id": 69731141, "body": "Oh.. generated code shows whats&#39;s going on.. Thanks. I just decided to use FormatArg&lt;&#39;a&gt; instead."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1482329233, "last_edit_date": 1495535435, "creation_date": 1482329233, "answer_id": 41264684, "question_id": 41264166, "link": "https://stackoverflow.com/questions/41264166/why-i-cant-return-fmtargumentsa-from-a-t/41264684#41264684", "title": "Why I can&#39;t return fmt::Arguments&lt;&#39;a&gt; from &amp;&#39;a T?", "body": "<p>To understand what's happening, let's look at the <a href=\"https://stackoverflow.com/q/28580386/155423\">macro-expanded version</a>:</p>\n\n<pre><code>fn as_format_arg&lt;'a, T: 'a + ?Sized + Debug&gt;(t: &amp;'a T) -&gt; Arguments&lt;'a&gt; {\n    ::std::fmt::Arguments::new_v1({\n                                      static __STATIC_FMTSTR:\n                                             &amp;'static [&amp;'static str] =\n                                          &amp;[\"\"];\n                                      __STATIC_FMTSTR\n                                  },\n                                  &amp;match (&amp;t,) {\n                                       (__arg0,) =&gt;\n                                       [::std::fmt::ArgumentV1::new(__arg0,\n                                                                    ::std::fmt::Debug::fmt)],\n                                   })\n}\n</code></pre>\n\n<p>This helps explain the first error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: borrowed value does not live long enough\n  --&gt; src/main.rs:9:36\n   |\n9  |                                   &amp;match (&amp;t,) {\n   |                                    ^ temporary value created here\n...\n15 | }\n   | - temporary value only lives until here\n   |\nnote: borrowed value must be valid for the lifetime 'a as defined on the block at 4:72...\n  --&gt; src/main.rs:4:73\n   |\n4  | fn as_format_arg&lt;'a, T: 'a + ?Sized + Debug&gt;(t: &amp;'a T) -&gt; Arguments&lt;'a&gt; {\n   |                                                                         ^\n</code></pre>\n\n<p>Specifically, an <code>ArgumentV1</code> is being created on the stack and a reference is being taken of it. You cannot return that reference from the function.</p>\n\n<p>The second error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `t` does not live long enough\n  --&gt; src/main.rs:9:44\n   |\n9  |                                   &amp;match (&amp;t,) {\n   |                                            ^ does not live long enough\n...\n15 | }\n   | - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the lifetime 'a as defined on the block at 4:72...\n  --&gt; src/main.rs:4:73\n   |\n4  | fn as_format_arg&lt;'a, T: 'a + ?Sized + Debug&gt;(t: &amp;'a T) -&gt; Arguments&lt;'a&gt; {\n   |                                                                         ^\n</code></pre>\n\n<p>Note that the <a href=\"https://stackoverflow.com/q/30450399/155423\"><code>format!</code> family of macros <strong>doesn't</strong> take their arguments by value</a>; they automatically insert a reference. You wouldn't want <code>println!</code> to take ownership of your value!.</p>\n\n<p>This means that the printed value is actually a <code>&amp;&amp;'a T</code> - a <strong>reference</strong> to the stack-allocated <code>t</code> value! Again, you cannot return a reference to something allocated on the stack.</p>\n\n<blockquote>\n  <p>if the caller of a function specifies a lifetime on a parameter, I can return a type with that lifetime.</p>\n</blockquote>\n\n<p>This is halfway true. You can return only return a piece of that input parameter. You cannot create a completely new value and return it with that lifetime.</p>\n"}], "owner": {"reputation": 321, "user_id": 6193633, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/f642d3c45da4db031e2d41798d1801a5?s=128&d=identicon&r=PG&f=1", "display_name": "kdy", "link": "https://stackoverflow.com/users/6193633/kdy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 324, "favorite_count": 1, "accepted_answer_id": 41264684, "answer_count": 1, "score": 4, "last_activity_date": 1482329236, "creation_date": 1482327643, "last_edit_date": 1482329236, "question_id": 41264166, "link": "https://stackoverflow.com/questions/41264166/why-i-cant-return-fmtargumentsa-from-a-t", "title": "Why I can&#39;t return fmt::Arguments&lt;&#39;a&gt; from &amp;&#39;a T?", "body": "<p>Based on my understanding of lifetimes, if the caller of a function specifies a lifetime on a parameter, I can return a type with that lifetime. </p>\n\n<p>This works, even with elision:</p>\n\n<pre><code>pub fn substr(s: &amp;str) -&gt; &amp;str {\n    &amp;s[0..1]\n}\n\npub fn substr_ex&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {\n    &amp;s[0..1]\n}\n</code></pre>\n\n<p>But this doesn't:</p>\n\n<pre><code>use std::fmt::Arguments;\n\npub fn as_format_arg&lt;'a, T: 'a + ?Sized + Debug&gt;(t: &amp;'a T) -&gt; Arguments&lt;'a&gt; {\n    format_args!(\"{:?}\", t)\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: borrowed value does not live long enough\n  --&gt; &lt;anon&gt;:16:18\n   |\n16 |     format_args!(\"{:?}\", t)\n   |                  ^^^^^^ does not live long enough\n17 | }\n   | - temporary value only lives until here\n   |\n   = note: borrowed value must be valid for the lifetime 'a as defined on unknown free region bounded by scope CodeExtent(38/CallSiteScope { fn_id: NodeId(42), body_id: NodeId(92) })...\n\nerror: `t` does not live long enough\n  --&gt; &lt;anon&gt;:16:26\n   |\n16 |     format_args!(\"{:?}\", t)\n   |                          ^ does not live long enough\n17 | }\n   | - borrowed value only lives until here\n   |\n   = note: borrowed value must be valid for the lifetime 'a as defined on unknown free region bounded by scope CodeExtent(38/CallSiteScope { fn_id: NodeId(42), body_id: NodeId(92) })...\n</code></pre>\n\n<p>Is this a bug? Or am I misunderstanding lifetimes?</p>\n\n<p>Playpen: <a href=\"https://play.rust-lang.org/?gist=5a7cb4c917b38e012f20c771893f8b3b&amp;version=nightly\" rel=\"nofollow noreferrer\">https://play.rust-lang.org/?gist=5a7cb4c917b38e012f20c771893f8b3b&amp;version=nightly</a></p>\n"}, {"tags": ["enums", "rust", "lookup-tables"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1482293788, "post_id": 41254961, "comment_id": 69710493, "body": "You are gonna want a macro."}, {"owner": {"reputation": 109956, "user_id": 159145, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/r8ryC.png?s=128&g=1", "display_name": "Dai", "link": "https://stackoverflow.com/users/159145/dai"}, "edited": false, "score": 0, "creation_date": 1482294266, "post_id": 41254961, "comment_id": 69710607, "body": "I&#39;m not a Rust user, but I imagine idiomatic Rust prefers avoiding string values (not least for performance reasons). Is there no way you can parse the string values when first-encountered and then use their corresponding enum values for all subsequent processing?"}], "answers": [{"tags": [], "owner": {"reputation": 336, "user_id": 3748215, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/ed0e35e4fdc144d63a02e84d2e6e1168?s=128&d=identicon&r=PG&f=1", "display_name": "eddy", "link": "https://stackoverflow.com/users/3748215/eddy"}, "is_accepted": true, "score": 5, "last_activity_date": 1482331265, "last_edit_date": 1482331265, "creation_date": 1482315313, "answer_id": 41260314, "question_id": 41254961, "link": "https://stackoverflow.com/questions/41254961/using-rusts-enum-as-a-bi-directional-lookup-table/41260314#41260314", "title": "Using Rust&#39;s enum as a bi-directional lookup table", "body": "<ol>\n<li>To cast an enum to int you can use <code>as i32</code>. </li>\n<li>To cast an i32 to your enum you could use the <a href=\"https://crates.io/crates/enum_primitive\" rel=\"nofollow noreferrer\">enum_primitive</a> crate:</li>\n</ol>\n\n<p>cargo.toml:</p>\n\n<pre><code>[dependencies]\nenum_primitive = \"*\"\n</code></pre>\n\n<p>main.rs:\n</p>\n\n<pre><code>#[macro_use]\nextern crate enum_primitive;\nuse enum_primitive::FromPrimitive;\n\nenum_from_primitive! {\n#[derive(Debug, PartialEq)]\npub enum NetworkManagerState {\n    Unknown = 0,\n    Asleep = 10,\n    Disconnected = 20,\n    Disconnecting = 30,\n    Connecting = 40,\n    ConnectedLocal = 50,\n    ConnectedSite = 60,\n    ConnectedGlobal = 70,\n}\n}\n\nimpl From&lt;i32&gt; for NetworkManagerState {\n    fn from(val: i32) -&gt; NetworkManagerState {\n        NetworkManagerState::from_i32(val).expect(\"passed Value does not match an enum value!\")\n    }\n}\nimpl From&lt;NetworkManagerState&gt; for i32 {\n    fn from(val: NetworkManagerState) -&gt; i32 {\n        val as i32\n    }\n}\n\n\nfn main() {\n    let value_i32 = 40;\n    let value_enum = NetworkManagerState::Connecting;\n\n    // enum to i32\n    println!(\"{:?}\", value_enum as i32);\n\n    // i32 to enum\n    println!(\"{:?}\", NetworkManagerState::from_i32(value_i32).unwrap());\n\n    // using from trait\n    let y: i32 = NetworkManagerState::Connecting.into();\n    println!(\"{:?}\", y);\n\n    // using from trait\n    let x: NetworkManagerState = 40.into();\n    println!(\"{:?}\", x);\n}\n</code></pre>\n\n<p>using the from trait you could make your functions accepting everything that can be converted to your enum:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn fancy_function&lt;T: Into&lt;NetworkManagerState&gt;&gt;(value: T) {\n    let internal: NetworkManagerState = value.into();\n    println!(\"{:?}\", internal);\n}\n\n...\n\nfancy_function(60);\nfancy_function(NetworkManagerState::Asleep);\n</code></pre>\n"}], "owner": {"reputation": 33733, "user_id": 1031417, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/xlhE1.jpg?s=128&g=1", "display_name": "0x90", "link": "https://stackoverflow.com/users/1031417/0x90"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 892, "favorite_count": 0, "accepted_answer_id": 41260314, "answer_count": 1, "score": 4, "last_activity_date": 1482333229, "creation_date": 1482293472, "last_edit_date": 1482333229, "question_id": 41254961, "link": "https://stackoverflow.com/questions/41254961/using-rusts-enum-as-a-bi-directional-lookup-table", "title": "Using Rust&#39;s enum as a bi-directional lookup table", "body": "<p>I am writing code that interacts with the <a href=\"https://developer.gnome.org/NetworkManager/stable/gdbus-org.freedesktop.NetworkManager.html\" rel=\"nofollow noreferrer\">NetworkManager</a> over D-Bus and I want to use an <code>enum</code> using as key-value like scheme. </p>\n\n<p>For example, I want once to use the value <code>0</code> as the digit zero and in different context to use the string <code>Unknown</code> of this <code>enum</code>:</p>\n\n<pre><code>pub enum NetworkManagerState {\n    Unknown = 0,\n    Asleep = 10,\n    Disconnected = 20,\n    Disconnecting = 30,\n    Connecting = 40,\n    ConnectedLocal = 50,\n    ConnectedSite = 60,\n    ConnectedGlobal = 70,\n}\n</code></pre>\n\n<p>What is the cleanest, most idiomatic way of doing so? Is there a way to define a tuple based enum that each entry looks like that <code>(ConnectedSite, 60u32, \"Connected\")</code> and use each tuple attribute upon context. </p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482293574, "post_id": 41253667, "comment_id": 69710440, "body": "In addition to the linked duplicate, the compiler is specifically complaining because you are trying to take a reference to the stack-allocated <code>i32</code> that was passed as an argument. You are <b>not</b> taking a reference to the <code>i32</code> that was stored in the vector. <code>i32</code> is a <a href=\"https://doc.rust-lang.org/std/marker/trait.Copy.html\" rel=\"nofollow noreferrer\"><code>Copy</code></a> type. The linked duplicate is the answer you would run into next, once you took the reference to yourself ^_^."}, {"owner": {"reputation": 12341, "user_id": 3678068, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/QWjMd.png?s=128&g=1", "display_name": "Fabricator", "link": "https://stackoverflow.com/users/3678068/fabricator"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482346792, "post_id": 41253667, "comment_id": 69740970, "body": "@Shepmaster, got it. Thanks for taking your time to explain this."}], "owner": {"reputation": 12341, "user_id": 3678068, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/QWjMd.png?s=128&g=1", "display_name": "Fabricator", "link": "https://stackoverflow.com/users/3678068/fabricator"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 28, "favorite_count": 0, "closed_date": 1482282742, "answer_count": 0, "score": 0, "last_activity_date": 1482282542, "creation_date": 1482282542, "question_id": 41253667, "link": "https://stackoverflow.com/questions/41253667/preserve-lifetime-of-an-argument-in-another-object", "closed_reason": "Duplicate", "title": "Preserve lifetime of an argument in another object", "body": "<p>I have a struct <code>X</code> with 2 fields <code>owned</code> and <code>refed</code>, used to hold ownership and reference of numbers passed in by the <code>insert</code> function.</p>\n\n<pre><code>fn main() {\n    struct X&lt;'a&gt; {\n        owned: Vec&lt;i32&gt;,\n        refed: Vec&lt;&amp;'a i32&gt;\n    }\n\n    impl&lt;'a&gt; X&lt;'a&gt; {\n        fn insert(&amp;mut self, n: i32) {\n            self.owned.push(n);\n            self.refed.push(&amp;n);\n        }\n    }\n\n    let mut x = X { owned: vec![], refed: vec![] };\n    x.insert(1);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?code=%23!%5Bfeature(box_syntax%2C%20box_patterns)%5D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20b%20%3D%20Some(box%205)%3B%0A%20%20%20%20match%20b%20%7B%0A%20%20%20%20%20%20%20%20Some(box%20n)%20if%20n%20%3C%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22Box%20contains%20negative%20number%20%7B%7D%22%2C%20n)%3B%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20Some(box%20n)%20if%20n%20%3E%3D%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22Box%20contains%20non-negative%20number%20%7B%7D%22%2C%20n)%3B%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22No%20box%22)%3B%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20unreachable!()%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly\" rel=\"nofollow noreferrer\">fiddle</a></p>\n\n<p>When I run this, I get the following error:</p>\n\n<pre><code>error: `n` does not live long enough\n  --&gt; &lt;anon&gt;:10:30\n   |\n10 |             self.refed.push(&amp;n);\n   |                              ^ does not live long enough\n11 |         }\n   |         - borrowed value only lives until here\n   |\n   = note: borrowed value must be valid for the lifetime 'a as defined on unknown free region bounded by scope CodeExtent(36/CallSiteScope { fn_id: NodeId(24), body_id: NodeId(68) })...\n\nerror: aborting due to previous error\n</code></pre>\n\n<p>I'm surprised that the compiler thinks <code>n</code> will no longer be available after the function ends, even though its ownership was already transferred and extended. So how do we get around this?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 1816, "user_id": 84234, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/425b0c29f8405c495e2abcda0cfebf16?s=128&d=identicon&r=PG", "display_name": "runfalk", "link": "https://stackoverflow.com/users/84234/runfalk"}, "edited": false, "score": 0, "creation_date": 1482338220, "post_id": 41253004, "comment_id": 69736147, "body": "Thank you for the great answers. I chose to accept Shepmaster&#39;s answer since it described why my solution didn&#39;t work the best, as well as presenting multiple solutions to my problem."}], "answers": [{"tags": [], "owner": {"reputation": 420, "user_id": 4284367, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a3387cd64f46111d2b4be0af24b7ece7?s=128&d=identicon&r=PG&f=1", "display_name": "Emilgardis", "link": "https://stackoverflow.com/users/4284367/emilgardis"}, "is_accepted": false, "score": 5, "last_activity_date": 1482281523, "creation_date": 1482281523, "answer_id": 41253533, "question_id": 41253004, "link": "https://stackoverflow.com/questions/41253004/lifetime-of-format-in-match-expression-is-too-short/41253533#41253533", "title": "Lifetime of format!() in match expression is too short", "body": "<p>I'm no expert on lifetimes, but I believe the problem here is that you are trying to return a <code>&amp;String</code> from a <code>String</code> created by <code>format!</code> inside the match. Since the scope of the format is only inside the scope, the borrow checker complains.</p>\n\n<p>To fix this you can use an owned string.</p>\n\n<pre><code>fn main() {\n    let opt = Some(1);\n\n    let opt_display = match opt {\n        Some(ref x) =&gt; format!(\"{}\", x), // Allowed since opt_display now owns the string\n        None =&gt; \"\".into(),\n    };\n    // Another way to achieve the same thing.\n    //let opt_display = opt.map(|s| format!(\"{}\", s)).unwrap_or(\"\".into());\n\n    println!(\"opt: {}\", opt_display);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1816, "user_id": 84234, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/425b0c29f8405c495e2abcda0cfebf16?s=128&d=identicon&r=PG", "display_name": "runfalk", "link": "https://stackoverflow.com/users/84234/runfalk"}, "edited": false, "score": 0, "creation_date": 1482328909, "post_id": 41254955, "comment_id": 69729823, "body": "The <code>if let Some(ref x) =</code> solution is exactly what I am looking for. I now understand why my previous code didn&#39;t work. Working in Rust is certainly eye-opening. Thank you for the thourough run-down."}, {"owner": {"reputation": 1816, "user_id": 84234, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/425b0c29f8405c495e2abcda0cfebf16?s=128&d=identicon&r=PG", "display_name": "runfalk", "link": "https://stackoverflow.com/users/84234/runfalk"}, "edited": false, "score": 0, "creation_date": 1482335109, "post_id": 41254955, "comment_id": 69734095, "body": "When doing multiple <code>write!(</code> in sequence each seems to return a Result of some kind. The compiler displays <code>warning: unused result which must be used, ...</code>. I currently ignore that warning using <code>#[allow(unused_must_use)]</code>. Is there any way <code>write!</code> on a <code>fmt::Formatter</code> can fail? Is this bad practice?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1816, "user_id": 84234, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/425b0c29f8405c495e2abcda0cfebf16?s=128&d=identicon&r=PG", "display_name": "runfalk", "link": "https://stackoverflow.com/users/84234/runfalk"}, "edited": false, "score": 0, "creation_date": 1482335262, "post_id": 41254955, "comment_id": 69734197, "body": "@antennen yes, and? Use the <code>Result</code>, just like everywhere else in Rust, likely by &quot;returning on error&quot;, like I mention. Perhaps a refresher with the <a href=\"https://doc.rust-lang.org/stable/book/error-handling.html\" rel=\"nofollow noreferrer\">error handling chapter</a> of <i>The Rust Programming Language</i> would help? See also <a href=\"http://stackoverflow.com/a/41260867/155423\">Chris Emerson&#39;s answer who so kindly wrote out the entire implementation for you</a>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1816, "user_id": 84234, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/425b0c29f8405c495e2abcda0cfebf16?s=128&d=identicon&r=PG", "display_name": "runfalk", "link": "https://stackoverflow.com/users/84234/runfalk"}, "edited": false, "score": 0, "creation_date": 1482335337, "post_id": 41254955, "comment_id": 69734256, "body": "@antennen <i>Is there any way <code>write!</code> on a <code>fmt::Formatter</code> can fail?</i> \u2014 absolutely. The disk could be full, the file could have been closed, the network became unplugged... etc. <i>Is this bad practice?</i> Ignoring errors? Absolutely a bad idea, which is why the compiler tells you that you should use the <code>Result</code>."}, {"owner": {"reputation": 1816, "user_id": 84234, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/425b0c29f8405c495e2abcda0cfebf16?s=128&d=identicon&r=PG", "display_name": "runfalk", "link": "https://stackoverflow.com/users/84234/runfalk"}, "edited": false, "score": 0, "creation_date": 1482337257, "post_id": 41254955, "comment_id": 69735585, "body": "I have yet to read the error handling chapter. I started learning Rust yesterday by reading &quot;the book&quot;. Very interesting language. I will look into it!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1482326906, "last_edit_date": 1495535439, "creation_date": 1482293410, "answer_id": 41254955, "question_id": 41253004, "link": "https://stackoverflow.com/questions/41253004/lifetime-of-format-in-match-expression-is-too-short/41254955#41254955", "title": "Lifetime of format!() in match expression is too short", "body": "<p>As <a href=\"https://stackoverflow.com/a/41253533/155423\">Emilgardis has already explained</a>, you are trying to return a reference to a value that will be dropped while the reference is still around. Congratulations, you just tried to create memory unsafety that would have caused a crash (or worse) in C or C++, but Rust prevented it!</p>\n\n<p>One efficiency improvement you can make is to only allocate in one case:</p>\n\n<pre><code>fn main() {\n    let opt = Some(1);\n    let opt_display = opt.map(|s| format!(\"{}\", s));\n\n    // Type not needed, only used to assert the type is what we expect\n    let opt_display_str: &amp;str = opt_display.as_ref().map(String::as_str).unwrap_or(\"\");\n    println!(\"opt: {}\", opt_display_str);\n}\n</code></pre>\n\n<p>You could also use a <a href=\"https://doc.rust-lang.org/std/borrow/enum.Cow.html\" rel=\"nofollow noreferrer\"><code>Cow</code></a>, which allows either an owned or borrowed string. Note how similar it is to the other answer, but this doesn't allocate in the case of <code>None</code>:</p>\n\n<pre><code>use std::borrow::Cow;\n\nfn main() {\n    let opt = Some(1);\n\n    let opt_display: Cow&lt;str&gt; = match opt {\n        Some(ref x) =&gt; format!(\"{}\", x).into(),\n        None =&gt; \"\".into(),\n    };\n\n    println!(\"opt: {}\", opt_display);\n}\n</code></pre>\n\n<blockquote>\n  <p>I want to implement <code>Display::fmt</code></p>\n</blockquote>\n\n<p>The <em>best</em> thing to do is probably to avoid any allocation then. You will be handed a formatter that you <code>write!</code> to, just call <code>write!</code> in each match arm. This might introduce a bit of duplication, but is probably more efficient. Without the formatter, it would look something like:</p>\n\n<pre><code>fn main() {\n    let opt = Some(1);\n\n    print!(\"opt: \");\n\n    if let Some(ref x) = opt  {\n       print!(\"{}\", x);\n    }\n\n    println!(\"\");    \n}\n</code></pre>\n\n<p>Substitute <code>write!(f,</code> for <code>print!(</code> inside the formatter and return on error.</p>\n"}, {"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 3, "last_activity_date": 1482329122, "last_edit_date": 1482329122, "creation_date": 1482317069, "answer_id": 41260867, "question_id": 41253004, "link": "https://stackoverflow.com/questions/41253004/lifetime-of-format-in-match-expression-is-too-short/41260867#41260867", "title": "Lifetime of format!() in match expression is too short", "body": "<p>When implementing <code>Display</code>, there's no need to return strings; you can just <code>write!()</code> into the provided formatter.</p>\n\n<p>It would look like:</p>\n\n<pre><code>impl&lt;T: Display&gt; Display for Range&lt;T&gt; {\n    fn fmt(&amp;self, fmt: &amp;mut Formatter) -&gt; Result&lt;(), std::fmt::Error&gt; {\n        write!(fmt, \"&lt;\")?;\n        if let Some(v) = self.lower {\n            write!(fmt, \"{}\", v)?;\n        }\n        write!(fmt, \",\")?;\n        if let Some(v) = self.upper {\n            write!(fmt, \"{}\", v)?;\n        }\n        write!(fmt, \"&gt;\")\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=6d7a0ae8310d4f495ec5bb4807e8430c&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}], "owner": {"reputation": 1816, "user_id": 84234, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/425b0c29f8405c495e2abcda0cfebf16?s=128&d=identicon&r=PG", "display_name": "runfalk", "link": "https://stackoverflow.com/users/84234/runfalk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 383, "favorite_count": 0, "accepted_answer_id": 41254955, "answer_count": 3, "score": 2, "last_activity_date": 1482329122, "creation_date": 1482277495, "last_edit_date": 1482277986, "question_id": 41253004, "link": "https://stackoverflow.com/questions/41253004/lifetime-of-format-in-match-expression-is-too-short", "title": "Lifetime of format!() in match expression is too short", "body": "<p>I am implementing a custom <code>Display::fmt</code> for my own struct which represent an interval.</p>\n\n<pre><code>struct Range&lt;T&gt; {\n    lower: Option&lt;T&gt;,\n    upper: Option&lt;T&gt;,\n}\n</code></pre>\n\n<p>A range could be <code>Range { lower: Some(1), upper: None }</code>, which means it contains all integers from 1 up to infinity (or the limit of <code>i32</code> I suppose).</p>\n\n<p>I want to implement <code>Display::fmt</code> to use <code>T</code>'s <code>Display::fmt</code> if the bound is not <code>None</code> and to display an empty string otherwise:</p>\n\n<pre><code>let range = Range { lower: Some(1), upper: None }\nprintln!(\"{}\", range); // Prints &lt;1,&gt;\n\nlet range = Range { lower: Some(1), upper: Some(10) }\nprintln!(\"{}\", range); // Prints &lt;1,10&gt;\n\nlet range = Range { lower: None, upper: Some(10) }\nprintln!(\"{}\", range); // Prints &lt;,10&gt;\n</code></pre>\n\n<p>I have started my implementation but have trouble with the <code>match</code> expression and the lifetime of the string produced by <code>format!()</code>. The problem with my implementation is that the string returned by format doesn't live long enough to be used further down.</p>\n\n<pre><code>fn main() {\n    let opt = Some(1);\n\n    let opt_display = match opt {\n        Some(x) =&gt; &amp;format!(\"{}\", x), // error: borrowed value does not live long enough\n        None =&gt; \"\",\n    };\n\n    println!(\"opt: {}\", opt_display);\n}\n</code></pre>\n\n<p>Why doesn't my approach work and what is a good solution to my problem?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 103, "user_id": 4663577, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad45ec95c0369c3f849fd81f66e2984e?s=128&d=identicon&r=PG&f=1", "display_name": "Pireax", "link": "https://stackoverflow.com/users/4663577/pireax"}, "edited": false, "score": 0, "creation_date": 1482316031, "post_id": 41252287, "comment_id": 69721455, "body": "Using the nightly feature <code>specialization</code> we can be a bit more specific, would it be possible to implement it using that?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 103, "user_id": 4663577, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad45ec95c0369c3f849fd81f66e2984e?s=128&d=identicon&r=PG&f=1", "display_name": "Pireax", "link": "https://stackoverflow.com/users/4663577/pireax"}, "edited": false, "score": 0, "creation_date": 1482327250, "post_id": 41252287, "comment_id": 69728686, "body": "@Pireax no, I don&#39;t believe so. That&#39;s what I was obliquely referring to with the need to say &quot;<code>T</code> doesn&#39;t implement <code>HasLength</code>&quot;, which requires negative reasoning, which I don&#39;t think that specialization enables."}, {"owner": {"reputation": 103, "user_id": 4663577, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad45ec95c0369c3f849fd81f66e2984e?s=128&d=identicon&r=PG&f=1", "display_name": "Pireax", "link": "https://stackoverflow.com/users/4663577/pireax"}, "edited": false, "score": 0, "creation_date": 1482327913, "post_id": 41252287, "comment_id": 69729126, "body": "It seems to me that you would be able to differentiate between <code>&amp;&#39;a[T]</code> and <code>&amp;&#39;a[&amp;&#39;a[T]]</code> using this, or even <code>&amp;&#39;a[T]</code> vs <code>&amp;&#39;a[T] where T: HasLength</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 103, "user_id": 4663577, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad45ec95c0369c3f849fd81f66e2984e?s=128&d=identicon&r=PG&f=1", "display_name": "Pireax", "link": "https://stackoverflow.com/users/4663577/pireax"}, "edited": false, "score": 0, "creation_date": 1482328425, "post_id": 41252287, "comment_id": 69729487, "body": "@Pireax yep, that was my thought as well, but I ran into <a href=\"https://github.com/rust-lang/rust/issues/25041\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/25041</a>. I&#39;d encourage you to try and prove us all wrong though!"}, {"owner": {"reputation": 103, "user_id": 4663577, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad45ec95c0369c3f849fd81f66e2984e?s=128&d=identicon&r=PG&f=1", "display_name": "Pireax", "link": "https://stackoverflow.com/users/4663577/pireax"}, "edited": false, "score": 0, "creation_date": 1482339197, "post_id": 41252287, "comment_id": 69736742, "body": "I tried doing so but I ran into the issue that it never executes the more specific implementation, it does build though. <a href=\"https://play.rust-lang.org/?gist=4002445ebaa438b894c28d00eea8976d&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 103, "user_id": 4663577, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad45ec95c0369c3f849fd81f66e2984e?s=128&d=identicon&r=PG&f=1", "display_name": "Pireax", "link": "https://stackoverflow.com/users/4663577/pireax"}, "edited": false, "score": 0, "creation_date": 1482343890, "post_id": 41252287, "comment_id": 69739333, "body": "@Pireax that fails because <code>T</code> is an array, not a slice. I&#39;ve updated with the working version (and the caveats that entails)."}, {"owner": {"reputation": 103, "user_id": 4663577, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad45ec95c0369c3f849fd81f66e2984e?s=128&d=identicon&r=PG&f=1", "display_name": "Pireax", "link": "https://stackoverflow.com/users/4663577/pireax"}, "edited": false, "score": 0, "creation_date": 1482348119, "post_id": 41252287, "comment_id": 69741705, "body": "alright, makes sense. Too bad you can&#39;t generalize over array sizes :/. Thank you for your time, much appreciated."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 103, "user_id": 4663577, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad45ec95c0369c3f849fd81f66e2984e?s=128&d=identicon&r=PG&f=1", "display_name": "Pireax", "link": "https://stackoverflow.com/users/4663577/pireax"}, "edited": false, "score": 0, "creation_date": 1482348216, "post_id": 41252287, "comment_id": 69741769, "body": "@Pireax FYI generalizing over array sizes is another frequently requested feature, usually under the name of <a href=\"https://github.com/rust-lang/rfcs/issues/1038\" rel=\"nofollow noreferrer\">type level integers</a>."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1482343845, "last_edit_date": 1482343845, "creation_date": 1482273239, "answer_id": 41252287, "question_id": 41252103, "link": "https://stackoverflow.com/questions/41252103/how-do-i-get-the-dimensions-of-multi-dimensional-arrays/41252287#41252287", "title": "How do I get the dimensions of multi-dimensional arrays?", "body": "<p>It's not possible to do this in a generic fashion for every possible depth of nesting. Rust is a statically typed language, so you have to know your input and output types. What is an input type for <code>[1]</code> and what is the input type for <code>[[1]]</code>? Likewise, what are the corresponding output types?</p>\n\n<p>The closest I know of is a trait with an associated type. This allows implementing it for a specific type which then <em>associates</em> another output type:</p>\n\n<pre><code>trait Thing {\n    type Dimensions;\n    fn thing(self) -&gt; Self::Dimensions;\n}\n</code></pre>\n\n<p>However, as soon as you implement it, you run into problems:</p>\n\n<pre><code>impl&lt;'a, T&gt; Thing for &amp;'a[T] {\n    type Dimensions = usize;\n\n    fn thing(self) -&gt; usize { \n        self.len() \n    }\n}\n\nimpl&lt;'a, T&gt; Thing for &amp;'a[&amp;'a[T]] {\n    type Dimensions = [usize; 2];\n\n    fn thing(self) -&gt; Self::Dimensions {\n        [self.len(), self[0].len()]\n    }\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0119]: conflicting implementations of trait `Thing` for type `&amp;[&amp;[_]]`:\n  --&gt; src/main.rs:14:1\n   |\n6  | impl&lt;'a, T&gt; Thing for &amp;'a[T] {\n   | - first implementation here\n...\n14 | impl&lt;'a, T&gt; Thing for &amp;'a[&amp;'a[T]] {\n   | ^ conflicting implementation for `&amp;[&amp;[_]]`\n</code></pre>\n\n<p>That's because a <code>&amp;[[T]]</code> <strong>is</strong> a <code>&amp;[T]</code>.</p>\n\n<p>You may also think to try something recursive, but there's no way to say <code>&amp;[T]</code> and know if <code>T</code> can be further iterated or not. If you had an <code>HasLength</code> trait and a <code>DoesntHaveLength</code> trait, nothing stops you from implementing both traits for a single type. Thus, you are stopped again.</p>\n\n<hr>\n\n<p>Here's one partial attempt at using specialization:</p>\n\n<pre><code>#![feature(specialization)]\n\ntrait Dimensions: Sized {\n    fn dimensions(self) -&gt; Vec&lt;usize&gt; {\n        let mut answers = vec![];\n        self.dimensions_core(&amp;mut answers);\n        answers\n    }\n    fn dimensions_core(self, &amp;mut Vec&lt;usize&gt;);\n}\n\nimpl&lt;'a, T&gt; Dimensions for &amp;'a [T] {\n    default fn dimensions_core(self, answers: &amp;mut Vec&lt;usize&gt;) {\n        answers.push(self.len());\n    }\n}\n\nimpl&lt;'a, T&gt; Dimensions for &amp;'a [T]\n    where T: Dimensions + Copy\n{\n    fn dimensions_core(self, answers: &amp;mut Vec&lt;usize&gt;)  {\n        answers.push(self.len());\n        self[0].dimensions_core(answers);\n    }\n}\n\nimpl&lt;'a, T&gt; Dimensions for [T; 2] {\n    default fn dimensions_core(self, answers: &amp;mut Vec&lt;usize&gt;)  {\n        answers.push(2)\n    }\n}\n\nimpl&lt;'a, T&gt; Dimensions for [T; 2] \n    where T: Dimensions + Copy\n{\n    fn dimensions_core(self, answers: &amp;mut Vec&lt;usize&gt;)  {\n        answers.push(2);\n        self[0].dimensions_core(answers);\n    }\n}\n\nimpl&lt;'a, T&gt; Dimensions for [T; 3] {\n    default fn dimensions_core(self, answers: &amp;mut Vec&lt;usize&gt;)  {\n        answers.push(3)\n    }\n}\n\nimpl&lt;'a, T&gt; Dimensions for [T; 3] \n    where T: Dimensions + Copy\n{\n    fn dimensions_core(self, answers: &amp;mut Vec&lt;usize&gt;)  {\n        answers.push(3);\n        self[0].dimensions_core(answers);\n    }\n}\n\n// Also implement for all the other sizes of array as well as `Vec`\n\nfn main() {\n    let x = [[1, 2, 3], [4, 5, 6]];\n    println!(\"{:?}\", x.dimensions());\n\n    let x = [[1, 2], [3, 4], [5, 6]];\n    println!(\"{:?}\", x.dimensions());\n}\n</code></pre>\n\n<p>It has the obvious downside that you still have to implement the trait for each array size in order to get specialization to kick in.</p>\n\n<hr>\n\n<p>I'm guessing that you are coming from a language that is highly dynamic. Different languages have different strengths and weaknesses. In Rust, you know your input types, so there's no way the function wouldn't know the nesting of my type. If it's going to receive a <code>Vec&lt;T&gt;</code> or a <code>Vec&lt;&amp;[Vec&lt;T&gt;]&gt;</code>, I will know the <strong>depth</strong> of nesting ahead of time, so I can write a function that returns the lengths of each one:</p>\n\n<pre><code>fn depth3&lt;A, B, C, T&gt;(a: A) -&gt; [usize; 3]\n    where A: AsRef&lt;[B]&gt;,\n          B: AsRef&lt;[C]&gt;,\n          C: AsRef&lt;[T]&gt;\n{\n    let a = a.as_ref();\n    // All of these should check that the length is &gt; 1\n    // and possibly that all children have same length\n    let b = a[0].as_ref();\n    let c = b[0].as_ref();\n    [a.len(), b.len(), c.len()] \n}\n\nfn main() {\n    let x = [[[1], [2], [3]], [[4], [5], [6]]];\n    println!(\"{:?}\", depth3(&amp;x));\n}\n</code></pre>\n\n<p>This function is as generic as I think it can be - you pass in references to arrays, slices, vectors, or direct values for those types. In fact, I can't think of a way to even define a slice/vector/array with an unknown depth. I think to do something like that you'd have to introduce some new type (likely an enum) with some indirection so that you could have a non-infinite size.</p>\n"}, {"tags": [], "owner": {"reputation": 420, "user_id": 4284367, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a3387cd64f46111d2b4be0af24b7ece7?s=128&d=identicon&r=PG&f=1", "display_name": "Emilgardis", "link": "https://stackoverflow.com/users/4284367/emilgardis"}, "is_accepted": false, "score": 1, "last_activity_date": 1482283541, "creation_date": 1482283541, "answer_id": 41253783, "question_id": 41252103, "link": "https://stackoverflow.com/questions/41252103/how-do-i-get-the-dimensions-of-multi-dimensional-arrays/41253783#41253783", "title": "How do I get the dimensions of multi-dimensional arrays?", "body": "<p>An array is defined as <code>[T]</code>, <code>T</code> can't be both  <code>[U; 2]</code> and <code>[U; 3]</code>. This means that you wouldn't even be able to get past compilation with this.</p>\n\n<p>If you instead used a <code>Vec&lt;Vec&lt;T&gt;&gt;</code> as @Shepmaster hints, you could do something like this.</p>\n\n<pre><code>fn main() {\n    let x = vec![vec![1, 2, 3], vec![4, 5]];\n    println!(\"{:?}\", get_2d_dimension(&amp;x));\n}\n\nfn get_2d_dimension&lt;T&gt;(arr: &amp;[Vec&lt;T&gt;]) -&gt; Result&lt;(usize, usize), &amp;str&gt; {\n    let rows = arr.len();\n    if rows &lt;= 1 {\n        return Err(\"Not 2d\");\n    }\n    let cols = arr[0].len();\n    if arr.iter().skip(1).filter(|v| v.len() == cols).count() != rows - 1 {\n        Err(\"Not square.\")\n    } else {\n        Ok((rows, cols))\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 103, "user_id": 4663577, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad45ec95c0369c3f849fd81f66e2984e?s=128&d=identicon&r=PG&f=1", "display_name": "Pireax", "link": "https://stackoverflow.com/users/4663577/pireax"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 549, "favorite_count": 1, "accepted_answer_id": 41252287, "answer_count": 2, "score": 3, "last_activity_date": 1482348337, "creation_date": 1482272140, "last_edit_date": 1482348337, "question_id": 41252103, "link": "https://stackoverflow.com/questions/41252103/how-do-i-get-the-dimensions-of-multi-dimensional-arrays", "title": "How do I get the dimensions of multi-dimensional arrays?", "body": "<p>I want to get the size of all dimensions of an array in Rust but I'm not sure how to go about this. I'm able to get the length of the array using <code>x.len()</code> but I need to somehow do this recursively.\nI want to be able to do something like this:</p>\n\n<pre><code>let x = [[1, 2, 3], [4, 5, 6]];\nprintln!(\"{:?}\", x.dimensions());\n// [2, 3]\n</code></pre>\n\n<p>A slice with a shape like <code>[[1], [2, 3], [4, 5, 6]]</code> should give an error.</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 2, "creation_date": 1482271072, "post_id": 41251283, "comment_id": 69704375, "body": "Small note: the first elision rule existed. The extra two rules eliminated the need for 87% of the explicit lifetimes used in the standard library."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1581522744, "last_edit_date": 1581522744, "creation_date": 1482268091, "answer_id": 41251283, "question_id": 41250915, "link": "https://stackoverflow.com/questions/41250915/is-it-possible-to-disable-rusts-lifetime-elision/41251283#41251283", "title": "Is it possible to disable Rust&#39;s lifetime elision?", "body": "<blockquote>\n  <p>Is it possible to disable Rust's lifetime elision on a per-file basis</p>\n</blockquote>\n\n<p>No.</p>\n\n<p>The best alternative I can offer is to request a Clippy feature that is the <em>opposite</em> of <a href=\"https://rust-lang.github.io/rust-clippy/current/index.html#needless_lifetimes\" rel=\"nofollow noreferrer\"><code>needless_lifetimes</code></a> and then enable it. I don't know if such a request would be wanted by other people though.</p>\n\n<p>In the meantime, you could enable that lint and manually make sure that it fires for every function.</p>\n\n<hr>\n\n<p>For reference, <a href=\"https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\" rel=\"nofollow noreferrer\">there are only 3 rules</a>:</p>\n\n\n\n<blockquote>\n  <p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and lifetimes on return values are called <em>output lifetimes</em>.</p>\n  \n  <p>The compiler uses three rules to figure out what lifetimes references have when there aren\u2019t explicit annotations. The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. If the compiler gets to the end of the three rules and there are still references for which it can\u2019t figure out lifetimes, the compiler will stop with an error. These rules apply to <code>fn</code> definitions as well as <code>impl</code> blocks.</p>\n  \n  <p>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; a function with two parameters gets two separate lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; and so on.</p>\n  \n  <p>The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>\n  \n  <p>The third rule is if there are multiple input lifetime parameters, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of <code>self</code> is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</p>\n</blockquote>\n\n<hr>\n\n<p>For what it's worth, before Rust 1.0, these 3 lifetime elision rules didn't exist, there was only the first. However, something like 87% of all functions and methods in the standard library that used references were covered by the 3 elision rules, which is why they were adopted. Lifetime elision is the <strong>common</strong> case.</p>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 285, "favorite_count": 0, "accepted_answer_id": 41251283, "answer_count": 1, "score": 7, "last_activity_date": 1581522744, "creation_date": 1482266515, "last_edit_date": 1482268105, "question_id": 41250915, "link": "https://stackoverflow.com/questions/41250915/is-it-possible-to-disable-rusts-lifetime-elision", "title": "Is it possible to disable Rust&#39;s lifetime elision?", "body": "<p>Is it possible to disable Rust's lifetime elision on a per-file basis, maybe with an <code>#[attribute]</code>?</p>\n\n<p>I'm learning about lifetimes and I think this might help.</p>\n"}, {"tags": ["rust", "static-libraries", "rust-cargo"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 7, "creation_date": 1482253842, "post_id": 41241585, "comment_id": 69695464, "body": "I&#39;d suggest that this isn&#39;t really the right organization. An integration test is supposed to use your code as a real user would. However, your real user isn&#39;t going to be Rust code. I&#39;d advocate that you reorganize your code to have one crate that is pure Rust and contains the majority of your business logic. Integration tests of that would work like you are trying. Then, create a second crate that uses the first, exposes the FFI bindings that you want, and is built as <code>staticlib</code>. Integration tests for <i>that</i> should be written in C and basically ensure that the proper bindings exist."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1482253986, "post_id": 41241585, "comment_id": 69695547, "body": "<a href=\"https://doc.rust-lang.org/reference.html#linkage\" rel=\"nofollow noreferrer\">Potentially relevant</a>: <i>A static system library will be produced. This is different from other library outputs in that the Rust compiler will never attempt to link to staticlib outputs.</i>"}], "owner": {"reputation": 833, "user_id": 1441642, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0575947d5c36b6364924b2cb8a2e1c9a?s=128&d=identicon&r=PG", "display_name": "David Haynes", "link": "https://stackoverflow.com/users/1441642/david-haynes"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 842, "favorite_count": 1, "answer_count": 0, "score": 15, "last_activity_date": 1482246323, "creation_date": 1482234269, "last_edit_date": 1482246323, "question_id": 41241585, "link": "https://stackoverflow.com/questions/41241585/how-to-link-against-rust-crate-from-integration-tests-in-tests-folder-when-bui", "title": "How to link against Rust crate from integration tests in &#39;tests&#39; folder when building static library?", "body": "<p>I'm building a library in Rust that will be called from C/C++ code. <code>Cargo.toml</code> is configured to output the crate as a static library:</p>\n\n<pre><code>[lib]\ncrate-type = [\"staticlib\"]\n</code></pre>\n\n<p>I have a test in <code>tests/integration_test.rs</code>:</p>\n\n<pre><code>extern crate mylibrary;\n\n#[test]\nfn it_works() {\n    hello_world();   // Defined in 'mylibrary'.\n}\n</code></pre>\n\n<p>However, when running the tests with <code>cargo test</code>, the following error is output:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0463]: can't find crate for `mylibrary`\n --&gt; tests\\integration_test.rs:1:1\n  |\n1 | extern crate mylibrary;\n  | ^^^^^^^^^^^^^^^^^^^^^ can't find crate\n</code></pre>\n\n<p>If I remove the staticlib config line from <code>Cargo.toml</code> then the tests build and run fine.</p>\n\n<p>Two possibilities occur to me:</p>\n\n<ol>\n<li><p>Do I need to configure the building of the crate when running tests differently (i.e. so that it doesn't build a static library)?</p></li>\n<li><p>Do I need to link the static library crate differently in the test (i.e. as if it were a system C library)?</p></li>\n</ol>\n\n<p>It's not clear from the docs what the correct way to configure this setup is, or how to go about it.</p>\n"}, {"tags": ["rust", "closures", "mutability"], "comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 4, "creation_date": 1482229643, "post_id": 41239266, "comment_id": 69679656, "body": "Note that the whole point of the closure being declared <code>Fn</code> is to only allow those that don&#39;t modify the state they capture. (This in turn makes them acceptable in multi-threaded and other contexts.) Using <code>Fn</code> is the most liberal option regarding where  you <i>use</i> the closure, but the most conservative option regarding what kind of closures you <i>accept</i>."}], "answers": [{"comments": [{"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1482232457, "post_id": 41239686, "comment_id": 69681488, "body": "Well, I have just tried using <code>Rc&lt;RefCell&lt;bool&gt;&gt;</code> and it works too. Could you also include this into your answer with explanation why did it work ?"}, {"owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "reply_to_user": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1482233588, "post_id": 41239686, "comment_id": 69682152, "body": "@Victor your <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> works, because that way you&#39;re obtaining a shared mutable reference to <code>T</code>. Even though that works, it&#39;s far from the best solution. I edited my answer to show how/why the <code>FnMut</code> works."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1482253681, "post_id": 41239686, "comment_id": 69695374, "body": "@VictorPolevoy <code>Rc&lt;RefCell&lt;bool&gt;&gt;</code> is a hack because it hides mutability from Rust&#39;s static analyzer, and for no good reason. For example, using it in to allow <code>Fn</code> to mutate state will allow the closure to be invoked from multiple threads, but it will panic (abort the thread) at run-time if two threads try to execute the closure at the same time. Why do you need the function declared <code>Fn</code> as opposed to <code>FnMut</code>?"}], "tags": [], "owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "is_accepted": true, "score": 11, "last_activity_date": 1547739668, "last_edit_date": 1547739668, "creation_date": 1482228444, "answer_id": 41239686, "question_id": 41239266, "link": "https://stackoverflow.com/questions/41239266/how-to-change-the-variable-from-inside-fn-closure-in-rust/41239686#41239686", "title": "How to change the variable from inside Fn closure in Rust?", "body": "<p>Change your <code>perform_for_all</code> function to use <a href=\"https://doc.rust-lang.org/std/ops/trait.FnMut.html\" rel=\"nofollow noreferrer\"><code>FnMut</code></a> instead of <a href=\"https://doc.rust-lang.org/std/ops/trait.Fn.html\" rel=\"nofollow noreferrer\"><code>Fn</code></a>:</p>\n\n<pre><code>fn perform_for_all&lt;F&gt;(&amp;mut self, mut f: F)\nwhere\n    F: FnMut(&amp;mut u64),\n{\n    for mut i in &amp;mut self.vec {\n        f(&amp;mut i);\n    }\n}\n</code></pre>\n\n<p><a href=\"https://stackoverflow.com/a/41240890/2319934\">As Peter said</a>, there is some compiler magic going on.</p>\n\n<p>The signature for <a href=\"https://doc.rust-lang.org/std/ops/trait.Fn.html#tymethod.call\" rel=\"nofollow noreferrer\"><code>Fn::call</code></a> is:</p>\n\n<pre><code>extern \"rust-call\" fn call(&amp;self, args: Args) -&gt; Self::Output\n</code></pre>\n\n<p>This takes an immutable reference to <code>self</code>, which is why you can't modify any of the captured variables.   </p>\n\n<p>The signature for <a href=\"https://doc.rust-lang.org/std/ops/trait.FnMut.html#tymethod.call_mut\" rel=\"nofollow noreferrer\"><code>FnMut::call_mut</code></a> lets you mutate variables because it takes <code>&amp;mut self</code>:   </p>\n\n<pre><code>extern \"rust-call\" fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output\n</code></pre>\n\n<p>By changing your closure from <code>Fn</code> to <code>FnMut</code>, you allow it to modify its captured variables, given that the references you pass to it are mutable.</p>\n"}, {"comments": [{"owner": {"reputation": 3471, "user_id": 316723, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/752df5a606619b92b23612feda4420ad?s=128&d=identicon&r=PG", "display_name": "naktinis", "link": "https://stackoverflow.com/users/316723/naktinis"}, "edited": false, "score": 1, "creation_date": 1482234032, "post_id": 41240890, "comment_id": 69682408, "body": "Could you add a link to &quot;magic&quot; in the source code or expand on it some more? I think it is quite central for developing an intuition (and advancing understanding)."}, {"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "reply_to_user": {"reputation": 3471, "user_id": 316723, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/752df5a606619b92b23612feda4420ad?s=128&d=identicon&r=PG", "display_name": "naktinis", "link": "https://stackoverflow.com/users/316723/naktinis"}, "edited": false, "score": 1, "creation_date": 1482250890, "post_id": 41240890, "comment_id": 69693621, "body": "Added a link to the documentation. This explains it pretty well, though doesn&#39;t go into details of what the struct actually looks like."}, {"owner": {"reputation": 3471, "user_id": 316723, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/752df5a606619b92b23612feda4420ad?s=128&d=identicon&r=PG", "display_name": "naktinis", "link": "https://stackoverflow.com/users/316723/naktinis"}, "edited": false, "score": 0, "creation_date": 1482256026, "post_id": 41240890, "comment_id": 69696706, "body": "I was more referring to compiler code that does the said &quot;magic&quot;. I&#39;m curious how <code>done</code> becomes <code>self.done</code> in your analogy. I understand this is for illustration and not what actually happens, so I&#39;m looking for what actually happens."}, {"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "reply_to_user": {"reputation": 3471, "user_id": 316723, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/752df5a606619b92b23612feda4420ad?s=128&d=identicon&r=PG", "display_name": "naktinis", "link": "https://stackoverflow.com/users/316723/naktinis"}, "edited": false, "score": 1, "creation_date": 1482259043, "post_id": 41240890, "comment_id": 69698262, "body": "@naktinis There is some discussion of this in the some of the compiler source comments: <a href=\"https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src/librustc/ty/sty.rs#L183\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/blob/&hellip;</a>, though may not be exactly what you are after."}], "tags": [], "owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "is_accepted": false, "score": 7, "last_activity_date": 1482251944, "last_edit_date": 1482251944, "creation_date": 1482232054, "answer_id": 41240890, "question_id": 41239266, "link": "https://stackoverflow.com/questions/41239266/how-to-change-the-variable-from-inside-fn-closure-in-rust/41240890#41240890", "title": "How to change the variable from inside Fn closure in Rust?", "body": "<p>Just to expand a little on SplittyDev's answer.</p>\n\n<p>When you use a closure, the compiler does some magic to let the closure access variables in its environment. Effectively it will create a new struct, whose members are the variables that you tried to access.</p>\n\n<p>It's not exactly this (which won't actually compile), but it's a reasonable approximation conceptually:</p>\n\n<pre><code>struct Closure_1 {\n    done: bool\n}\n\nimpl FnMut&lt;&amp;mut u64&gt; for Closure_1 {\n    fn call_mut(&amp;mut self, v: &amp;mut u64) {\n        println!(\"value: {:?}\", v);                                                                 \n        self.done = true;         \n    }\n} \n</code></pre>\n\n<p>And when you call it, those variables will be borrowed or copied (or moved if you use <code>move</code> keyword).</p>\n\n<pre><code>let mut c1 = Closure_1 { done : done };\na.perform_for_all(|v| c1.call(&amp;v)); \ndone = c1.done;\n</code></pre>\n\n<p>When the closure modifies its environment, it cannot be a <code>Fn</code> because it must also mutate the variables on itself:</p>\n\n<pre><code>impl Fn&lt;&amp;mut u64&gt; for Closure_1 {\n    fn call(&amp;self, v: &amp;mut u64) {\n        println!(\"value: {:?}\", v);                                                                 \n        self.done = true; // Can't do this because self is not a mutable ref\n    }\n}\n</code></pre>\n\n<p>See <em>The Rust Programming Language</em> <a href=\"https://doc.rust-lang.org/book/closures.html#closures-and-their-environment\" rel=\"noreferrer\">section on closures and their environment</a> for more information.</p>\n"}], "owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3685, "favorite_count": 0, "accepted_answer_id": 41239686, "answer_count": 2, "score": 14, "last_activity_date": 1547739763, "creation_date": 1482227285, "last_edit_date": 1547739763, "question_id": 41239266, "link": "https://stackoverflow.com/questions/41239266/how-to-change-the-variable-from-inside-fn-closure-in-rust", "title": "How to change the variable from inside Fn closure in Rust?", "body": "<p>I have the following code (<a href=\"https://play.rust-lang.org/?gist=33ca64c1f7b3cd776dbf91cc7bdff6ff&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">playground</a>):</p>\n\n<pre><code>struct A {\n    pub vec: Vec&lt;u64&gt;,\n}\n\nimpl A {\n    fn perform_for_all&lt;F: Fn(&amp;mut u64)&gt;(&amp;mut self, f: F) {\n        for mut i in &amp;mut self.vec {\n            f(i);\n        }\n    }\n}\nfn main() {\n    let mut a = A {\n        vec: vec![1, 3, 44, 2, 4, 5, 6],\n    };\n\n    let mut done = false;\n\n    a.perform_for_all(|v| {\n        println!(\"value: {:?}\", v);\n        done = true;\n    });\n\n    if !done {\n        a.perform_for_all(|v| {\n            println!(\"value {:?}\", v);\n        });\n    }\n}\n</code></pre>\n\n<p>The following errors occur:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0594]: cannot assign to `done`, as it is a captured variable in a `Fn` closure\n  --&gt; src/main.rs:21:9\n   |\n21 |         done = true;\n   |         ^^^^^^^^^^^ cannot assign\n   |\nhelp: consider changing this to accept closures that implement `FnMut`\n  --&gt; src/main.rs:19:23\n   |\n19 |       a.perform_for_all(|v| {\n   |  _______________________^\n20 | |         println!(\"value: {:?}\", v);\n21 | |         done = true;\n22 | |     });\n   | |_____^\n</code></pre>\n\n<p>I have a list of loaded objects and a list of objects in a database. I need a function that takes a closure and executes it on the loaded objects and if we don't have the objects in the list, execute it on a list of objects from the database.</p>\n\n<p>That function looks like:</p>\n\n<pre><code>pub fn perform_for_match_with_mark&lt;F&gt;(&amp;mut self, mark: MatchMark, f: F)\nwhere\n    F: Fn(&amp;mut GameMatch),\n{\n    self.perform_for_all_matches(\n        |m| {\n            // runtime list\n            if let Game::Match(ref mut gm) = *m {\n                if gm.match_stamp().mark == mark {\n                    f(gm);\n                }\n            }\n        },\n        None,\n    );\n    // if we have called `f` above - don't execute lines below.\n    let tx = self.match_tx.clone();\n    GamesDatabase::perform_for_match_with_mark(mark, |ms| {\n        // database\n        self.perform_for_all_matches(\n            |m| {\n                if let Game::Match(ref gm) = *m {\n                    if gm.match_stamp().id == ms.id {\n                        f(&amp;mut GameMatch::new_with_match_stamp(\n                            tx.clone(),\n                            ms.clone(),\n                            gm.needs_server_set,\n                            gm.server_id,\n                        ))\n                    }\n                }\n            },\n            None,\n        );\n    });\n}\n</code></pre>\n\n<p>We have to operate on objects from the database only if we were unable to find them in runtime list. That is why I decided to make a variable which says \"we already found these objects in the list, leave the database alone\".</p>\n"}, {"tags": ["intellij-idea", "rust"], "owner": {"reputation": 2726, "user_id": 3612643, "user_type": "registered", "accept_rate": 47, "profile_image": "https://www.gravatar.com/avatar/3e18288eaaaef95535b2ba6deb069db5?s=128&d=identicon&r=PG&f=1", "display_name": "user3612643", "link": "https://stackoverflow.com/users/3612643/user3612643"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 81, "favorite_count": 0, "answer_count": 0, "score": 2, "last_activity_date": 1482246237, "creation_date": 1482224590, "last_edit_date": 1482246237, "question_id": 41238345, "link": "https://stackoverflow.com/questions/41238345/is-there-a-way-to-tie-cargo-into-intellijs-build-system", "title": "Is there a way to tie Cargo into IntelliJ&#39;s build system?", "body": "<p>I just started with the <a href=\"https://intellij-rust.github.io/\" rel=\"nofollow noreferrer\">Rust plugin for IntelliJ</a>. When I click \"Build/Build Project\" or \"Build/Recompile xxx.rs\", I only get the message</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Compilation completed successfully in 709ms\n</code></pre>\n\n<p>However, nothing was compiled since I don't get any error messages on \"broken\" Rust files. When I click \"Run/Run...\", IntelliJ starts Cargo and I see an error message.</p>\n\n<p>Is there a way to tie Cargo into IntelliJ's build system?</p>\n"}, {"tags": ["windows", "filesystems", "rust", "canonicalization"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 9, "last_activity_date": 1482201099, "creation_date": 1482201099, "answer_id": 41233992, "question_id": 41233684, "link": "https://stackoverflow.com/questions/41233684/why-does-my-canonicalized-path-get-prefixed-with/41233992#41233992", "title": "Why does my canonicalized path get prefixed with \\\\?\\", "body": "<p><a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#win32_file_namespaces\" rel=\"noreferrer\">The <code>\\\\?\\</code> prefix</a> tells Windows to treat the path as is, i.e. it disables the special meaning of <code>.</code> and <code>..</code>, special device names like <code>CON</code> are not interpreted and the path is assumed to be absolute. It also enables using paths <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath\" rel=\"noreferrer\">up to 32,767 characters (UTF-16 code units), whereas otherwise the limit is 260</a> (unless you're on Windows 10, version 1607 or later, and your application opts in to longer paths).</p>\n\n<p>Therefore, the <code>\\\\?\\</code> prefix ensures that you'll get a usable path; removing that prefix may yield a path that is unusable or that resolves to a different file! As such, I would recommend that you <em>keep that prefix in your paths</em>.</p>\n"}], "owner": {"reputation": 2816, "user_id": 5402030, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/pT1Sp.png?s=128&g=1", "display_name": "MutantOctopus", "link": "https://stackoverflow.com/users/5402030/mutantoctopus"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 244, "favorite_count": 0, "accepted_answer_id": 41233992, "answer_count": 1, "score": 2, "last_activity_date": 1482287623, "creation_date": 1482198085, "last_edit_date": 1482287623, "question_id": 41233684, "link": "https://stackoverflow.com/questions/41233684/why-does-my-canonicalized-path-get-prefixed-with", "title": "Why does my canonicalized path get prefixed with \\\\?\\", "body": "<p>I'm working on a personal project that I was trying to solve via canonicalizing a relative path in Rust. However, whenever I do so, the new path gets prefixed with a strange <code>\\\\?\\</code> sequence. For example, something as simple as:</p>\n\n<pre><code>let p = fs::canonicalize(\".\").unwrap();\nprintln!(\"{}\", p.display());\n</code></pre>\n\n<p>will result in something like the following output:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>\\\\?\\C:\\Users\\[...]\\rustprojects\\projectname\n</code></pre>\n\n<p>This isn't a particular problem because I can accomplish what I'm attempting in other ways. However, it seems like odd behavior, especially if you are going to use the string form of the path in some way that requires accuracy. Why is this sequence of characters prepending the result, and how can I avoid it?</p>\n"}, {"tags": ["linux", "windows", "macos", "rust", "native"], "comments": [{"owner": {"reputation": 11736, "user_id": 1987838, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/2tIuS.jpg?s=128&g=1", "display_name": "Hackerman", "link": "https://stackoverflow.com/users/1987838/hackerman"}, "edited": false, "score": 1, "creation_date": 1482175745, "post_id": 41229644, "comment_id": 69658445, "body": "On Linux: <code>cat &#47;sys&#47;block&#47;sda&#47;queue&#47;rotational</code> You should get 1 for hard disks and 0 for a SSD."}, {"owner": {"reputation": 74982, "user_id": 128967, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/e6ce48656d5e39227a10b37a51754134?s=128&d=identicon&r=PG", "display_name": "Naftuli Kay", "link": "https://stackoverflow.com/users/128967/naftuli-kay"}, "reply_to_user": {"reputation": 11736, "user_id": 1987838, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/2tIuS.jpg?s=128&g=1", "display_name": "Hackerman", "link": "https://stackoverflow.com/users/1987838/hackerman"}, "edited": false, "score": 0, "creation_date": 1482176142, "post_id": 41229644, "comment_id": 69658627, "body": "@Hackerman exactly what I was looking for, thanks. Now I just need to figure out how to trace dm-0 down to a given device. Down the rabbit hole..."}, {"owner": {"reputation": 11736, "user_id": 1987838, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/2tIuS.jpg?s=128&g=1", "display_name": "Hackerman", "link": "https://stackoverflow.com/users/1987838/hackerman"}, "edited": false, "score": 0, "creation_date": 1482176252, "post_id": 41229644, "comment_id": 69658682, "body": "I am glad to help Naftuli Kay :)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1482177170, "post_id": 41229644, "comment_id": 69659172, "body": "Why not just allow the user to decide if it&#39;s a SSD or not? What happens when the next generation of storage comes out? What about when a disk is actually a network-mounted device? What about when you have a symlink on a HDD to a SSD or vice versa?"}, {"owner": {"reputation": 74982, "user_id": 128967, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/e6ce48656d5e39227a10b37a51754134?s=128&d=identicon&r=PG", "display_name": "Naftuli Kay", "link": "https://stackoverflow.com/users/128967/naftuli-kay"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482177895, "post_id": 41229644, "comment_id": 69659555, "body": "@Shepmaster that is indeed a better solution, but it&#39;s still nice to know how to do it."}], "answers": [{"comments": [{"owner": {"reputation": 6764, "user_id": 42473, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/4sdGf.png?s=128&g=1", "display_name": "Mark Booth", "link": "https://stackoverflow.com/users/42473/mark-booth"}, "edited": false, "score": 0, "creation_date": 1578574747, "post_id": 41230209, "comment_id": 105487882, "body": "On RHEL7 LVM volumes appear to be handled correctly, the same as dm-crypt."}], "tags": [], "owner": {"reputation": 74982, "user_id": 128967, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/e6ce48656d5e39227a10b37a51754134?s=128&d=identicon&r=PG", "display_name": "Naftuli Kay", "link": "https://stackoverflow.com/users/128967/naftuli-kay"}, "is_accepted": false, "score": 2, "last_activity_date": 1482178083, "creation_date": 1482178083, "answer_id": 41230209, "question_id": 41229644, "link": "https://stackoverflow.com/questions/41229644/cross-platform-way-of-determining-if-on-ssd/41230209#41230209", "title": "Cross-platform way of determining if on SSD?", "body": "<p>Credit goes to <a href=\"https://stackoverflow.com/users/1987838/hackerman\">@Hackerman</a>:</p>\n\n<pre><code>$ cat /sys/block/sda/queue/rotational\n0\n</code></pre>\n\n<p>If it returns 1, the given filesystem is on rotational media.</p>\n\n<p>I have fleshed this concept out into a shell script which reliably determines whether a file is on rotational media or not:</p>\n\n<pre><code>#!/bin/bash\n\nset -e\n\n# emits the device path to the filesystem where the first argument lives\nfs_mount=\"$(df -h $1 | tail -n 1 | awk '{print $1;}')\"\n\n# if it's a symlink, resolve it\nif [ -L \"$fs_mount\" ]; then\n  fs_mount=\"$(readlink -f $fs_mount)\"\nfi\n\n# if it's a device-mapper like LVM or dm-crypt, then we need to be special\nif echo $fs_mount | grep -oP '/dev/dm-\\d+' &gt;/dev/null ; then\n  # get the first device slave\n  first_slave_dev=\"$(find /sys/block/$(basename $fs_mount)/slaves -mindepth 1 -maxdepth 1 -exec readlink -f {} \\; | head -1)\"\n  # actual device\n  dev=\"$(cd $first_slave_dev/../ &amp;&amp; basename $(pwd))\"\nelse\n  dev=\"$(basename $fs_mount | grep -ioP '[a-z]+(?=\\d+\\b)')\"\nfi\n\n# now that we have the actual device, we simply ask whether it's rotational or not\nif [[ $(cat /sys/block/$dev/queue/rotational) -eq 0 ]]; then\n  echo \"The filesystem hosting $1 is not on an rotational media.\"\nelse\n  echo \"The filesystem hosting $1 is on rotational media.\"\nfi\n</code></pre>\n\n<p>The above works for me both on plain partitions (ie <code>/dev/sda1</code> is mounted at a given path) and on <code>dm-crypt</code> partitions (ie <code>/dev/mapper/crypt</code> is mounted at a given path). I have not tested it with LVM because I don't have one nearby.</p>\n\n<p>Apologies for the Bash not being portable.</p>\n"}], "owner": {"reputation": 74982, "user_id": 128967, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/e6ce48656d5e39227a10b37a51754134?s=128&d=identicon&r=PG", "display_name": "Naftuli Kay", "link": "https://stackoverflow.com/users/128967/naftuli-kay"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 162, "favorite_count": 0, "answer_count": 1, "score": 2, "last_activity_date": 1482178083, "creation_date": 1482175613, "question_id": 41229644, "link": "https://stackoverflow.com/questions/41229644/cross-platform-way-of-determining-if-on-ssd", "title": "Cross-platform way of determining if on SSD?", "body": "<p>I'm writing a tool in Rust which needs to vary its functionality depending on whether the current filesystem is an SSD or a traditional hard drive.</p>\n\n<p>The difference at runtime will be that if the files exist on an SSD, more threads will be used to access files versus an HDD, which will only thrash the disk and reduce performance.</p>\n\n<p>I'm primarily interested in Linux, as that is my use case, but welcome any other additions. I also need to do this as a non-root user if possible. Is there a syscall or a filesystem device which will tell me what kind of device I'm on? </p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 2, "creation_date": 1482165673, "post_id": 41227212, "comment_id": 69653243, "body": "<code>or_exit()</code> doesn&#39;t seem to be a macro, as you say in the comment above, since the <code>!</code> is missing (typo?). Also: could you add the complete compiler error? :)"}, {"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1482165804, "post_id": 41227212, "comment_id": 69653306, "body": "@LukasKalbertodt That was something defined in the codebase, not standard library. I should probably change the code sample here simply to <code>unwrap()</code>. I now included the complete error."}], "answers": [{"comments": [{"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "edited": false, "score": 0, "creation_date": 1482167415, "post_id": 41227477, "comment_id": 69654206, "body": "I&#39;ve read the book but apparently those concepts still take some time to digest. With your method I am able to get a vector of <code>String</code>s, however there is some function that expects <code>Vec&lt;&amp;str&gt;</code>. Is there a convenient way to convert <code>Vec&lt;String&gt;</code> to <code>Vec&lt;&amp;str&gt;</code>, or would it be more idiomatic to avoid writing functions that require <code>Vec&lt;&amp;str&gt;</code> and change its input type to <code>Vec&lt;String&gt;</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "edited": false, "score": 0, "creation_date": 1482168134, "post_id": 41227477, "comment_id": 69654607, "body": "@JIXiang I&#39;d also suggest searching on SO for questions: <a href=\"http://stackoverflow.com/q/33216514/155423\">Convert Vec&lt;String&gt; to Vec&lt;&amp;str&gt;</a>. You can change your function type to accept either <code>&amp;str</code> or <code>String</code>, if useful."}, {"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "edited": false, "score": 0, "creation_date": 1482169216, "post_id": 41227477, "comment_id": 69655198, "body": "Right. I Googled it first but I seem to have made the mistake of writing &quot;Vector&quot; instead of &quot;Vec&quot; and encountered no relevant results from Google. Thanks for pointing this question out."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "edited": false, "score": 0, "creation_date": 1482172647, "post_id": 41227477, "comment_id": 69656897, "body": "@JIXiang also, if you wrote those methods, you may want to <a href=\"http://stackoverflow.com/q/40006219/155423\">consider making them take a slice</a>."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1482166623, "creation_date": 1482166623, "answer_id": 41227477, "question_id": 41227212, "link": "https://stackoverflow.com/questions/41227212/two-mutable-borrows-happen-on-the-same-line/41227477#41227477", "title": "Two mutable borrows happen on the same line?", "body": "<p>From the <a href=\"http://lise-henry.github.io/rust/stemmer/struct.Stemmer.html#method.stem_str\" rel=\"nofollow noreferrer\">documentation of <code>stem_str</code></a>:</p>\n\n<blockquote>\n  <p>The str reference it returns is only valid as long as you don't call stem or stem_str again; thus, Rust's borrowchecker won't let call one of them function if you have such a reference in scope.</p>\n</blockquote>\n\n<p>Presumably, this is because the stemmer implementation actually has some kind of internal buffer where the word is stored as it is stemmed.</p>\n\n<p>This is why you cannot call <code>stem_str</code> twice while keeping a reference to the string; doing so would <strong>invalidate the first string</strong>!.</p>\n\n<blockquote>\n  <p>I can't just call <code>as_str()</code> and expect to assign the obtained <code>&amp;str</code> back to <code>*t</code></p>\n</blockquote>\n\n<p>The compiler is <strong>absolutely correct</strong> again. You are attempting to create a value, take a reference to it, store the reference, then drop the value! That's a memory vulnerability and you can't do it.</p>\n\n<p>Instead, collect a vector of <code>String</code>s:</p>\n\n<pre><code>for line in input.lock().lines() {\n    let line = line.unwrap();\n    let mut query: Vec&lt;_&gt; = line.split_whitespace()\n        .map(|t| stemmer.stem(t))\n        .collect();\n}\n</code></pre>\n\n<p>I'd highly recommend reading <a href=\"https://doc.rust-lang.org/stable/book/\" rel=\"nofollow noreferrer\"><em>The Rust Programming Language</em></a> and understanding how references work and what they prevent. Do this <em>before</em> and <em>during</em> getting into anything complicated with ownership. These chapters specifically:</p>\n\n<ul>\n<li><a href=\"https://doc.rust-lang.org/stable/book/ownership.html\" rel=\"nofollow noreferrer\">Ownership</a></li>\n<li><a href=\"https://doc.rust-lang.org/stable/book/references-and-borrowing.html\" rel=\"nofollow noreferrer\">References and Borrowing</a></li>\n<li><a href=\"https://doc.rust-lang.org/stable/book/lifetimes.html\" rel=\"nofollow noreferrer\">Lifetimes</a></li>\n</ul>\n"}], "owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 383, "favorite_count": 0, "accepted_answer_id": 41227477, "answer_count": 1, "score": 3, "last_activity_date": 1482166623, "creation_date": 1482165581, "last_edit_date": 1482166255, "question_id": 41227212, "link": "https://stackoverflow.com/questions/41227212/two-mutable-borrows-happen-on-the-same-line", "title": "Two mutable borrows happen on the same line?", "body": "<p>I'm trying to use the <a href=\"https://github.com/lise-henry/stemmer-rs\" rel=\"nofollow noreferrer\">Snowball stemmer</a> crate in Rust to stem a vector of words. It should be simple, but the borrow checker keeps rejecting my code:</p>\n\n<pre><code>// Read user input\nlet input = stdin();\nlet mut stemmer = Stemmer::new(\"english\").unwrap();\nfor line in input.lock().lines() {\n    let line = line.unwrap();\n    let mut query: Vec&lt;_&gt; = line.split_whitespace().collect();\n    for t in &amp;mut query {\n        *t = stemmer.stem_str(t);\n    }\n    // \u2026\n}\n</code></pre>\n\n<p>The borrow checker says I have two mutable borrows of <code>stemmer</code> on the line <code>*t = stemmer.stem_str(t);</code> and rejects my code. (Line 80 is where the block of <code>for line in input.lock().lines()</code> end.)</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>57  18 error    E0499  cannot borrow `stemmer` as mutable more than once at a time (first mutable borrow occurs here) (rust-cargo)\n57  18 error    E0499  cannot borrow `stemmer` as mutable more than once at a time (second mutable borrow occurs here) (rust-cargo)\n80   5 info     E0499  first borrow ends here (rust-cargo)\n</code></pre>\n\n<p>If I call the <code>stem()</code> method directly, I get a <code>String</code>, but then I can't just call <code>as_str()</code> and expect to assign the obtained <code>&amp;str</code> back to <code>*t</code>, since the borrow checker complains that the \"borrowed value does not live long enough\".</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>57  18 error           borrowed value does not live long enough (temporary value created here) (rust-cargo)\n57  18 info            consider using a `let` binding to increase its lifetime (rust-cargo)\n57  42 info            temporary value only lives until here (rust-cargo)\n80   5 info            temporary value needs to live until here (rust-cargo)\n</code></pre>\n\n<p>I'm not sure if this has something to do with the implementation details of this library, but I really feel stuck here. I never expected stemming a vector of inputs would be so difficult.</p>\n"}, {"tags": ["unicode", "rust", "event-loop", "mio"], "owner": {"reputation": 2731, "user_id": 109414, "user_type": "registered", "accept_rate": 61, "profile_image": "https://www.gravatar.com/avatar/2b68fe77303968e573ca1e7004462ae7?s=128&d=identicon&r=PG", "display_name": "Edd Barrett", "link": "https://stackoverflow.com/users/109414/edd-barrett"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 265, "favorite_count": 0, "answer_count": 0, "score": 3, "last_activity_date": 1482160356, "creation_date": 1482158002, "last_edit_date": 1482160356, "question_id": 41224854, "link": "https://stackoverflow.com/questions/41224854/how-to-read-unicode-codepoints-from-an-unbuffered-file-in-a-mio-event-loop", "title": "How to read Unicode codepoints from an unbuffered file in a mio event loop?", "body": "<p>I'd like to use the mio crate to read keypresses as they arrive in an unbuffered fashion. I already have the code to unbuffer stdin, and I have scaffolded the event loop:</p>\n\n<pre><code>extern crate mio;\nextern crate termios;\n\nuse termios::{Termios, TCSANOW, ICANON, ECHO, tcsetattr};\nuse mio::*;\nuse mio::unix::EventedFd;\n\nfn unbuffer_stdin() {\n    let termios = Termios::from_fd(0).unwrap();\n    let mut new_termios = termios.clone();\n    new_termios.c_lflag &amp;= !(ICANON | ECHO);\n    tcsetattr(0, TCSANOW, &amp;mut new_termios).unwrap();\n}\n\nfn main() {\n    let stdin = 0;\n    unbuffer_stdin();\n\n    let poll = Poll::new().unwrap();\n\n    const STDIN: Token = Token(0);\n    let ev_fd = EventedFd(&amp;stdin);\n    poll.register(&amp;ev_fd, STDIN, Ready::readable(), PollOpt::edge()).unwrap();\n\n    let mut events = Events::with_capacity(1024);\n    loop {\n        poll.poll(&amp;mut events, None).unwrap();\n\n        for event in events.iter() {\n            match event.token() {\n                STDIN =&gt; {\n                    println!(\"keypress\");\n                    // XXX read in ready codepoints to a buffer\n                }\n                _ =&gt; unreachable!(),\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>How do I implement the part marked <code>XXX</code>? There are a couple of challenges:</p>\n\n<ul>\n<li>How do I know how many bytes to read? I'm not sure mio tells me this.</li>\n<li>How do I deal with partial codepoints, where the read spans a multi-byte character.</li>\n</ul>\n\n<p>One solution that might work is to use <code>oneshot</code> events instead of <code>edge</code> events, then read one byte per event into a temporary buffer. Each time the buffer makes sense as a complete codepoint, I could then convert it to a <code>char</code> and store it away, and clear the scratch buffer.</p>\n\n<p>This seems a little inefficient though. What is the best way?</p>\n"}, {"tags": ["sorting", "rust", "word-frequency"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 2, "creation_date": 1482145057, "post_id": 41220872, "comment_id": 69640665, "body": "If you need it to be indexed by word <i>and</i> sorted by value, that sounds like two data structures (possibly wrapped together).  I think I would probably accumulate the counts in a <code>BTreeMap</code> or <code>HashMap</code>, and then turn that into a <code>Vec</code> at the end."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 2, "creation_date": 1482145067, "post_id": 41220872, "comment_id": 69640672, "body": "Out of interest, what/where is the course?"}, {"owner": {"reputation": 63, "user_id": 7316014, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/9ZRRP.jpg?s=128&g=1", "display_name": "Jonathan", "link": "https://stackoverflow.com/users/7316014/jonathan"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1482146571, "post_id": 41220872, "comment_id": 69641484, "body": "@ChrisEmerson it&#39;s part of the 4TU Master Cyber Security programme in the Netherlands, a joint programme by the University of Twente and Delft University, where I&#39;m attending via the first university."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482152597, "post_id": 41220872, "comment_id": 69644910, "body": "Just to point out, a <code>BTreeMap</code> is sorted <b>by key</b>; that&#39;s how it works. See the requirement for <code>Ord</code> for <code>K</code>. If you could sort by value, the properties of the map would no longer hold, and it couldn&#39;t <i>be</i> a map."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482154480, "post_id": 41220872, "comment_id": 69646112, "body": "If you are interested in improving your code, you may want to ask a question <a href=\"http://meta.codereview.stackexchange.com/questions/5777/a-guide-to-code-review-for-stack-overflow-users\">over on Code Review</a>."}], "answers": [{"comments": [{"owner": {"reputation": 63, "user_id": 7316014, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/9ZRRP.jpg?s=128&g=1", "display_name": "Jonathan", "link": "https://stackoverflow.com/users/7316014/jonathan"}, "edited": false, "score": 0, "creation_date": 1482146699, "post_id": 41221181, "comment_id": 69641545, "body": "This seems to be the solution to my problem. I never realized I could use a vector in this way. I&#39;ll try it right away."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482154596, "post_id": 41221181, "comment_id": 69646184, "body": "You may want to use <a href=\"http://stackoverflow.com/q/40369255/155423\">the revord crate</a> instead of negating - <code>-MIN_INT</code> is not representable."}, {"owner": {"reputation": 63, "user_id": 7316014, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/9ZRRP.jpg?s=128&g=1", "display_name": "Jonathan", "link": "https://stackoverflow.com/users/7316014/jonathan"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482156167, "post_id": 41221181, "comment_id": 69647114, "body": "@Shepmaster I worked around that problem by explicitly declaring the count as a signed integer with <code>wordlenghts.insert(word.to_lowercase(), word.chars().count() as i64);</code>. Thanks for the tip though."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 63, "user_id": 7316014, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/9ZRRP.jpg?s=128&g=1", "display_name": "Jonathan", "link": "https://stackoverflow.com/users/7316014/jonathan"}, "edited": false, "score": 0, "creation_date": 1482156269, "post_id": 41221181, "comment_id": 69647178, "body": "@Jonathan that... makes it worse. By moving to a <b>signed</b> integer, you introduce the possibility of having <code>MIN_INT</code> to start with. An unsigned number, of course, cannot be negated, requiring the reverse ordering."}, {"owner": {"reputation": 63, "user_id": 7316014, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/9ZRRP.jpg?s=128&g=1", "display_name": "Jonathan", "link": "https://stackoverflow.com/users/7316014/jonathan"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482156375, "post_id": 41221181, "comment_id": 69647253, "body": "This suggestion resolved my problem completely, after ironing out the issue @Shepmaster also pointed out. The working code can be found <a href=\"http://pastebin.com/FMkkcJsm\" rel=\"nofollow noreferrer\">here</a>."}, {"owner": {"reputation": 63, "user_id": 7316014, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/9ZRRP.jpg?s=128&g=1", "display_name": "Jonathan", "link": "https://stackoverflow.com/users/7316014/jonathan"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482156460, "post_id": 41221181, "comment_id": 69647316, "body": "@Shepmaster I see. I&#39;ll update my program accordingly. Thanks for your insight."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482157216, "post_id": 41221181, "comment_id": 69647800, "body": "@Shepmaster I fixed the ordering stuff. Thanks for the comment!"}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 7, "last_activity_date": 1482157187, "last_edit_date": 1495542825, "creation_date": 1482145378, "answer_id": 41221181, "question_id": 41220872, "link": "https://stackoverflow.com/questions/41220872/how-if-possible-to-sort-a-btreemap-by-value-in-rust/41221181#41221181", "title": "How (if possible) to sort a BTreeMap by value in Rust?", "body": "<p>If you only need to analyze a static dataset, the easiest way is to just convert your <code>BTreeMap</code> into a <code>Vec&lt;T&gt;</code> in the end and sort the latter (<a href=\"https://play.rust-lang.org/?gist=5561b3fb979221008088ceee6cdcdce5&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Playground</a>):</p>\n\n<pre><code>use std::iter::FromIterator;\n\nlet mut v = Vec::from_iter(map);\nv.sort_by(|&amp;(_, a), &amp;(_, b)| b.cmp(&amp;a));\n</code></pre>\n\n<p>The vector contains the <code>(key, value)</code> pairs as tuple. To sort the vector, we have to use <code>sort_by()</code> or <code>sort_by_key()</code>. To sort the vector in decreasing order, I used <code>b.cmp(&amp;a)</code> (as opposed to <code>a.cmp(&amp;b)</code>, which would be the natural order). But there are <a href=\"https://stackoverflow.com/questions/40369255/reverse-specific-key-when-sorting-with-multiple-keys\">other possibilities to reverse the order of a sort</a>.</p>\n\n<hr>\n\n<p>However, if you really need some data structure such that you have a streaming calculation, it's getting more complicated. There are many possibilities in that case, but I guess using some kind of priority queue could work out. </p>\n"}], "owner": {"reputation": 63, "user_id": 7316014, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/9ZRRP.jpg?s=128&g=1", "display_name": "Jonathan", "link": "https://stackoverflow.com/users/7316014/jonathan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2639, "favorite_count": 1, "accepted_answer_id": 41221181, "answer_count": 1, "score": 4, "last_activity_date": 1482157187, "creation_date": 1482144444, "last_edit_date": 1482152673, "question_id": 41220872, "link": "https://stackoverflow.com/questions/41220872/how-if-possible-to-sort-a-btreemap-by-value-in-rust", "title": "How (if possible) to sort a BTreeMap by value in Rust?", "body": "<p>I am following a course on Software Security for which one of the assignments is to write some basic programs in Rust. For one of these assignments I need to analyze a text-file and generate several statistics. One of these is a generated list of the ten most used words in the text.</p>\n\n<p>I have written <a href=\"http://pastebin.com/ffdQ7Zsr\" rel=\"nofollow noreferrer\">this program</a> that performs all tasks in the assignment  except for the word frequency statistic mentioned above, the program compiles and executes the way I expect:</p>\n\n<pre><code>extern crate regex;\n\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::io::BufReader;\nuse std::collections::BTreeMap;\nuse regex::Regex;\n\nfn main() {\n    // Create a path to the desired file\n    let path = Path::new(\"text.txt\");\n    let display = path.display();\n\n    let file = match File::open(&amp;path) {\n        Err(why) =&gt; panic!(\"couldn't open {}: {}\", display,\n                           why.description()),\n        Ok(file) =&gt; file,\n    };\n\n    let mut wordcount = 0;\n    let mut averagesize = 0;\n    let mut wordsize = BTreeMap::new();\n    let mut words = BTreeMap::new();\n\n    for line in (BufReader::new(file)).lines() {\n        let re = Regex::new(r\"([A-Za-z]+[-_]*[A-Za-z]+)+\").unwrap();\n        for cap in re.captures_iter(&amp;line.unwrap()) {\n            let word = cap.at(1).unwrap_or(\"\");\n            let lower = word.to_lowercase();\n            let s = lower.len();\n\n            wordcount += 1;\n            averagesize += s;\n\n            *words.entry(lower).or_insert(0) += 1;\n            *wordsize.entry(s).or_insert(0) += 1;\n        }\n    }\n\n    averagesize = averagesize / wordcount;\n\n    println!(\"This file contains {} words with an average of {} letters per word.\", wordcount, averagesize);\n\n    println!(\"\\nThe number of times a word of a certain length was found.\");\n\n    for (size, count) in wordsize.iter() {\n        println!(\"There are {} words of size {}.\", count, size);\n    }\n\n    println!(\"\\nThe ten most used words.\");\n\n    let mut popwords = BTreeMap::new();\n    for (word, count) in words.iter() {\n        if !popwords.contains_key(count) {\n            popwords.insert(count, \"\");\n        }\n\n        let newstring = format!(\"{} {}\", popwords.get(count), word);\n        let mut e = popwords.get_mut(count);\n    }\n\n    let mut i = 0;\n    for (count, words) in popwords.iter() {\n        i += 1;\n        if i &gt; 10 {\n            break;\n        }\n        println!(\"{} times: {}\", count, words);\n    }\n}\n</code></pre>\n\n<p>I have a <code>BTreeMap</code> (that I chose with <a href=\"https://doc.rust-lang.org/std/collections/\" rel=\"nofollow noreferrer\">these</a> instructions), <code>words</code>, that stores each word as key and its associated frequency in the text as value. This functionality works as I expect, but there I am stuck. I have been trying to find ways to sort the <code>BTreemap</code> by value or find another data structure in Rust that is natively sorted by value.</p>\n\n<p>I am looking for the correct way to achieve this data structure (a list of words with their frequency, sorted by frequency) in Rust. Any pointers are greatly appreciated!</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 5, "last_activity_date": 1482117199, "last_edit_date": 1482117199, "creation_date": 1482116170, "answer_id": 41215173, "question_id": 41214948, "link": "https://stackoverflow.com/questions/41214948/how-to-declare-a-hashmap-with-type-str-string-in-rust/41215173#41215173", "title": "How to declare a hashmap with type &lt;&amp;str, String&gt; in Rust?", "body": "<p>You need to specify that the lifetime of the keys is <code>'static</code>:</p>\n\n<pre><code>pub struct SmpStruct {\n    word_dict: HashMap&lt;&amp;'static str, String&gt;,\n}\n</code></pre>\n\n<p>In struct fields or enum variants, <a href=\"https://doc.rust-lang.org/book/lifetimes.html#in-structs\" rel=\"nofollow noreferrer\">lifetime parameters</a> cannot be omitted; they must be specified explicitly, and if you want to accept lifetimes other than <code>'static</code>, then you must add a lifetime parameter on the struct or enum itself.</p>\n"}], "owner": {"reputation": 3, "user_id": 7313022, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/afec7e8fbbaad8444372751db7bcd057?s=128&d=identicon&r=PG&f=1", "display_name": "Nan Wang", "link": "https://stackoverflow.com/users/7313022/nan-wang"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2648, "favorite_count": 0, "closed_date": 1482117277, "accepted_answer_id": 41215173, "answer_count": 1, "score": 0, "last_activity_date": 1482117199, "creation_date": 1482113830, "last_edit_date": 1482117153, "question_id": 41214948, "link": "https://stackoverflow.com/questions/41214948/how-to-declare-a-hashmap-with-type-str-string-in-rust", "closed_reason": "Duplicate", "title": "How to declare a hashmap with type &lt;&amp;str, String&gt; in Rust?", "body": "<p>I'd like to declare a <code>HashMap</code> member in my structure, and as the keys will be always a static literals and the content shall be modified, so the type I expected is:</p>\n\n<pre><code>pub struct SmpStruct {\n    word_dict: HashMap&lt;&amp;str, String&gt;,\n}\n</code></pre>\n\n<p>Unfortunately, the compiler gives me the feedback:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0106]: missing lifetime specifier\n --&gt; src/main.rs:4:24\n  |\n4 |     word_dict: HashMap&lt;&amp;str, String&gt;,\n  |                        ^ expected lifetime parameter\n</code></pre>\n\n<p>As an alternative, I'm using <code>HashMap&lt;String, String&gt;</code>:</p>\n\n<pre><code>pub struct SmpStruct {\n    word_dict: HashMap&lt;String, String&gt;,\n}\n</code></pre>\n\n<p>This solution works, but is not perfect. Can anyone explain what I'm doing incorrectly here?</p>\n"}, {"tags": ["macros", "rust"], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1482096911, "post_id": 41213128, "comment_id": 69625019, "body": "Please let me know if I made any mistake! Since I&#39;ve never written a compiler plugin, it was pretty difficult to get all this information. It&#39;s not unlikely that I made a mistake! Please tell me (or just edit, if it can be edited)!"}, {"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "edited": false, "score": 1, "creation_date": 1482177255, "post_id": 41213128, "comment_id": 69659224, "body": "<code>rustc</code> has the <code>-Zextra-plugins=too,bar</code> command line option to add plugins without annotating the code."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "edited": false, "score": 0, "creation_date": 1482179642, "post_id": 41213128, "comment_id": 69660372, "body": "@llogiq Thanks! I added it to my answer."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 16, "last_activity_date": 1482179629, "last_edit_date": 1482179629, "creation_date": 1482096835, "answer_id": 41213128, "question_id": 41213127, "link": "https://stackoverflow.com/questions/41213127/what-types-of-macros-syntax-extensions-compiler-plugins-are-there/41213128#41213128", "title": "What types of Macros/Syntax Extensions/Compiler Plugins are there?", "body": "<p>You are right: it <em>is</em> confusing. Especially, because most of those features are unstable and change fairly often. But I'll try to summarize the current situation (<em>December 2016</em>).</p>\n\n<hr>\n\n<p><a href=\"https://i.stack.imgur.com/RnPNn.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/RnPNn.png\" alt=\"Venn-diagram showing compiler-plugins and syntax-extensions\"></a></p>\n\n<p>Let's start with the <strong>Syntax Extension</strong>: it's something that has to be \"called\" or annotated manually in order to have any effect. There are three kinds of syntax extensions, which differ in the way you annotate them:</p>\n\n<ul>\n<li><p><strong>function-like syntax extensions</strong>: these are probably the most common syntax extensions, also called \"macros\". The syntax for invoking them is <code>foo!(\u2026)</code> or (and this is pretty rare) <code>foo! some_ident (\u2026)</code>, where <code>foo</code> is the macro's name. Note that the <code>()</code> parenthesis can be replaced by <code>[]</code> or <code>{}</code>. <em>Function-like syntax extensions</em> can be defined either as a \"<em>macro by example</em>\" or as a \"<em>procedural macro</em>\".</p></li>\n<li><p><strong>attribute-like syntax extensions</strong>: these are invoked like <code>#[foo(\u2026)]</code> where the parenthesis are not necessary and, again, <code>foo</code> is the name of the syntax extension. The item the attribute is belonging to can then be modified or extended by additional items (decorator).</p></li>\n<li><p><strong>custom derives</strong>: most Rust-programmers have already used the <code>#[derive(\u2026)]</code> attribute. Of course, <code>derive</code> itself can be seen as <em>attribute-like syntax extension</em>. But it can also be extended, which is then invoked like <code>#[derive(Foo)]</code>, where <code>Foo</code> is the name of the <em>custom derive</em>.</p></li>\n</ul>\n\n<hr>\n\n<p>Most of these syntax extensions are also \"<strong>compiler plugins</strong>\". The only exception are <em>function-like syntax extensions</em> which are defined via \"<em>macro by example</em>\" (meaning <code>macro_rules!</code> syntax). <em>Macros by example</em> can be defined in your source code without writing a <em>compiler plugin</em> whatsoever.</p>\n\n<p>But there are also <strong>compiler plugins</strong> that aren't <em>syntax extensions</em>. Those types of <em>compiler plugins</em> are linters or other plugins which run some code at some stage of the compiling process. They don't need to be invoked manually: once loaded, the compiler will call them at certain points during compilation.</p>\n\n<p>All <em>compiler plugins</em> need to be loaded \u2013 either via <code>#![plugin(foo)]</code> at the crate-root or with the <code>-Zextra-plugins=too,bar</code> command line parameter \u2013 before they can have any effect!</p>\n\n<p><em>Compiler plugins</em> are currently unstable, therefore you need a nightly-compiler to use them. But the <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md\" rel=\"noreferrer\">\"Macro 1.1\"-RFC</a> will probably be stabilized soon, which means that a small subsets of <em>compiler plugins</em> can then be used with the stable compiler.</p>\n\n<hr>\n\n<p>Useful links:</p>\n\n<ul>\n<li><a href=\"http://manishearth.github.io/rust-internals-docs/rustc_plugin/registry/struct.Registry.html\" rel=\"noreferrer\">Documentation about registering <em>compiler plugins</em></a></li>\n<li><a href=\"https://doc.rust-lang.org/beta/book/compiler-plugins.html\" rel=\"noreferrer\">Book Chapter about <em>compiler plugins</em></a> </li>\n</ul>\n"}], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 546, "favorite_count": 1, "accepted_answer_id": 41213128, "answer_count": 1, "score": 10, "last_activity_date": 1482179629, "creation_date": 1482096835, "question_id": 41213127, "link": "https://stackoverflow.com/questions/41213127/what-types-of-macros-syntax-extensions-compiler-plugins-are-there", "title": "What types of Macros/Syntax Extensions/Compiler Plugins are there?", "body": "<p>I am very confused by the many terms used for several macro-like things in the Rust ecosystem. Could someone clarify what macros/syntax extensions/compiler plugins there are as well as explain the relationship between those terms?</p>\n"}, {"tags": ["unit-testing", "module", "rust"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1482093876, "post_id": 41212565, "comment_id": 69624118, "body": "The question &quot;Why doesn&#39;t this use statement work in Rust?&quot; is still answered in the thread marked as dupe. You probably want to ask &quot;What&#39;s the best way to do it in my situation?&quot;... Although I don&#39;t think there is a good answer to that. You have to list all private symbols manually in the <code>use</code>-statement... there is no way around it :/"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482093925, "post_id": 41212565, "comment_id": 69624133, "body": "For nom, you can add <code>pub</code> <a href=\"https://docs.rs/nom/2.0.1/nom/macro.named.html\" rel=\"nofollow noreferrer\">to the named macro</a>: <code>named!(pub Ch_D&lt;i16&gt;, ...</code>."}, {"owner": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482093994, "post_id": 41212565, "comment_id": 69624157, "body": "@Shepmaster yeah but now that can&#39;t be an answer, now can it."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1482094172, "post_id": 41212565, "comment_id": 69624197, "body": "@CamdenNarzt it&#39;s the same answer: make the function public or import it by name. Stack Overflow doesn&#39;t need thousands of variations on that question and answer for every unique combination of macro syntax that crate authors decide to dream up."}, {"owner": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "edited": false, "score": 0, "creation_date": 1482094264, "post_id": 41212565, "comment_id": 69624225, "body": "Well that&#39;s where I disagree, especially when the documentation situation for Rust crates is so terrible in general."}], "owner": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 39, "favorite_count": 0, "closed_date": 1482093437, "answer_count": 0, "score": 0, "last_activity_date": 1482093858, "creation_date": 1482093017, "last_edit_date": 1482093858, "question_id": 41212565, "link": "https://stackoverflow.com/questions/41212565/why-doesnt-this-use-statement-with-a-glob-import-work", "closed_reason": "Duplicate", "title": "Why doesn&#39;t this use statement with a glob import work?", "body": "<p>I have a module I'm trying to test. The module uses nom macros to generate functions. In the test module I <code>use super::*</code>, but the functions are not brought into scope.</p>\n\n<pre><code>pub mod v4 {\n    use nom::be_i16;\n    named!(Ch_D&lt;i16&gt;, preceded!(tag!([0x65;1]), be_i16));\n    //... lots more of these\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        #[test]\n        #[allow(overflowing_literals)]\n        fn Ch_D_test() {\n            let bytes = &amp;[0x65, 0xf0, 0xe7];\n            assert_eq!(Ch_D(bytes), IResult::Done(EMPTY_SLICE,0xf0e7));\n        }\n    }\n}\n</code></pre>\n\n<p>I get <code>error[E0425]: unresolved name 'Ch_D'</code> or if I <code>use super::Ch_D</code> it works, but I really don't want to write out every single function name.</p>\n\n<p>Since the nom macros don't create public functions I don't have much choice but to make this work without marking the functions as <code>pub</code>.</p>\n"}, {"tags": ["rust", "idioms"], "answers": [{"comments": [{"owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "edited": false, "score": 0, "creation_date": 1482092095, "post_id": 41212385, "comment_id": 69623627, "body": "Changed the question to more closely resemble the real problem"}, {"owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "edited": false, "score": 0, "creation_date": 1482093524, "post_id": 41212385, "comment_id": 69624033, "body": "I&#39;m changing the question back to the way it was so your answer remains relevant, just warning you ahead of time in case you&#39;re editing the answer"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "edited": false, "score": 0, "creation_date": 1482093598, "post_id": 41212385, "comment_id": 69624052, "body": "@ElectricCoffee sounds good. I believe the answer you are looking for is still in this answer - the last code block, specifically."}, {"owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "edited": false, "score": 0, "creation_date": 1482093964, "post_id": 41212385, "comment_id": 69624144, "body": "Done, I changed the <code>push_front</code> bit to <code>push</code> since it&#39;s a left-over from the copy-pasted <code>VecDeque</code> code that I missed when converting it to <code>Vec</code>. If you could be so kind as to remove the compiler errors, that would be splendid :)"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 3, "last_activity_date": 1482093748, "last_edit_date": 1482093748, "creation_date": 1482091788, "answer_id": 41212385, "question_id": 41212377, "link": "https://stackoverflow.com/questions/41212377/idiomatic-append-operation/41212385#41212385", "title": "Idiomatic append operation", "body": "<p>Neither. There's a built-in operation for this, <a href=\"https://doc.rust-lang.org/collections/vec/struct.Vec.html#method.append\" rel=\"nofollow noreferrer\"><code>Vec::append</code></a>:</p>\n\n<blockquote>\n  <p>Moves all the elements of other into <code>Self</code>, leaving other empty.</p>\n</blockquote>\n\n<pre><code>fn move_values&lt;T&gt;(buffer: &amp;mut Vec&lt;T&gt;, recipient: &amp;mut Vec&lt;T&gt;) {\n    recipient.append(buffer);\n}\n</code></pre>\n\n<hr>\n\n<p>Neither of your functions even compile:</p>\n\n<pre><code>fn move_values_1&lt;T&gt;(buffer: &amp;mut Vec&lt;T&gt;, recipient: &amp;mut Vec&lt;T&gt;) {\n    loop {\n        let value = buffer.pop();\n        if value.is_none() {\n            return;\n        }\n        recipient.push_front(card.unwrap());\n    }\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0425]: unresolved name `card`\n --&gt; src/main.rs:7:30\n  |\n7 |         recipient.push_front(card.unwrap());\n  |                              ^^^^ unresolved name\n</code></pre>\n\n\n\n<pre><code>fn move_values_2&lt;T&gt;(buffer: &amp;mut Vec&lt;T&gt;, recipient: &amp;mut Vec&lt;T&gt;) {\n    for value in buffer.iter() {\n        recipient.push_front(value.clone());\n    }\n\n    buffer.clear();\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: no method named `push_front` found for type `&amp;mut std::vec::Vec&lt;T&gt;` in the current scope\n --&gt; src/main.rs:7:19\n  |\n7 |         recipient.push_front(card.unwrap());\n  |                   ^^^^^^^^^^\n</code></pre>\n\n<hr>\n\n<blockquote>\n  <p>if I were to implement it myself</p>\n</blockquote>\n\n<p>Well, there's a reason that it's implemented for you, but sure... let's dig in.</p>\n\n<p>Checking if something <code>is_some</code> or <code>is_none</code> can usually be avoided by pattern matching. For example:</p>\n\n<pre><code>fn move_values_1&lt;T&gt;(buffer: &amp;mut Vec&lt;T&gt;, recipient: &amp;mut Vec&lt;T&gt;) {\n    while let Some(v) = buffer.pop() {\n        recipient.push(v);\n    }\n}\n</code></pre>\n\n<p>Of course, this moves everything in <strong>reverse order</strong> because pushing and popping to a Vec both occur at the end.</p>\n\n<p>Calling <code>clone</code> doesn't do what you want unless your trait bounds say that <code>T</code> implements <code>Clone</code>. Otherwise, you are just cloning the <em>reference</em> itself.</p>\n\n<p>You can avoid the need for cloning if you drain the values from one collection and insert them into the other:</p>\n\n<pre><code>for value in buffer.drain(..) {\n    recipient.push(value);\n}\n</code></pre>\n\n<p>But that <code>for</code> loop is silly, just <code>extend</code> the collection using the iterator:</p>\n\n<pre><code>recipient.extend(buffer.drain(..));\n</code></pre>\n\n<p>I'd <strong>still</strong> use the built in <code>append</code> method to do this when transferring between collections of the same type, as it is probably optimized for the precise data layout, and potentially specialized for certain types of data.</p>\n"}], "owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 300, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1482093748, "creation_date": 1482091653, "last_edit_date": 1482093735, "question_id": 41212377, "link": "https://stackoverflow.com/questions/41212377/idiomatic-append-operation", "title": "Idiomatic append operation", "body": "<p>I'm writing a function that will transfer the contents from one <code>Vec</code> to another.</p>\n\n<p>I managed to write two different versions of the same code. One is cleaner, but is potentially slower.</p>\n\n<p>Version 1:</p>\n\n<pre><code>fn move_values&lt;T&gt;(buffer: &amp;mut Vec&lt;T&gt;, recipient: &amp;mut Vec&lt;T&gt;) {\n    loop {\n        let value = buffer.pop();\n        if value.is_none() {\n            return;\n        }\n        recipient.push(value.unwrap());\n    }\n}\n</code></pre>\n\n<p>Version 2:</p>\n\n<pre><code>fn move_values&lt;T&gt;(buffer: &amp;mut Vec&lt;T&gt;, recipient: &amp;mut Vec&lt;T&gt;) {\n    for value in buffer.iter() {\n        recipient.push(value.clone());\n    }\n\n    buffer.clear();\n}\n</code></pre>\n\n<p>My initial gut feeling is that Version 1 is faster because it only requires a single run through the buffer; while Version 2 is more \"Rusty\" because it involves iterating over a collection rather than using <code>loop</code>.</p>\n\n<p>Which of these is more idiomatic or \"better practice\" in general?</p>\n\n<p>Note, I'm aware of <code>append</code>, I'm trying to do this by hand for educational purposes.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "edited": false, "score": 0, "creation_date": 1482080143, "post_id": 41210691, "comment_id": 69620046, "body": "I would also welcome any style improvements here, in the comments."}], "answers": [{"comments": [{"owner": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "edited": false, "score": 0, "creation_date": 1482081446, "post_id": 41210857, "comment_id": 69620437, "body": "so in this case it will be Ok(0)?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "edited": false, "score": 2, "creation_date": 1482085847, "post_id": 41210857, "comment_id": 69621911, "body": "@d33tah yes, I believe so. I can&#39;t imagine where any other number would come from, the wording is a bit ambiguous, isn&#39;t it?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1482139995, "post_id": 41210857, "comment_id": 69637453, "body": "The documentation isn&#39;t all that clear, but what happens if the remaining input is a partial line?  Is it returned as a line, or is it discarded?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1482081329, "creation_date": 1482081329, "answer_id": 41210857, "question_id": 41210691, "link": "https://stackoverflow.com/questions/41210691/how-to-check-for-eof-in-read-line-in-rust-1-12/41210857#41210857", "title": "How to check for EOF in read_line in Rust 1.12?", "body": "<p>From the <a href=\"https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_line\" rel=\"nofollow noreferrer\">documentation for <code>read_line</code></a>:</p>\n\n<blockquote>\n  <p>If this reader is currently at EOF then this function will not modify <code>buf</code> and will return <code>Ok(n)</code> where <code>n</code> is the number of bytes which were read.</p>\n</blockquote>\n"}], "owner": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 986, "favorite_count": 0, "accepted_answer_id": 41210857, "answer_count": 1, "score": 4, "last_activity_date": 1482081329, "creation_date": 1482080127, "last_edit_date": 1495540896, "question_id": 41210691, "link": "https://stackoverflow.com/questions/41210691/how-to-check-for-eof-in-read-line-in-rust-1-12", "title": "How to check for EOF in read_line in Rust 1.12?", "body": "<p>Consider the following program, how do I detect EOF in stdin and break the loop?</p>\n\n<pre><code>use std::io;\nuse std::process;\n\nfn main() {\n    let mut sum = 0;\n    loop {\n        let mut number_str = String::new();\n        match io::stdin().read_line(&amp;mut number_str) {\n            Ok(n) =&gt; {},\n            Err(e) =&gt; { println!(\"ERROR: got '{}' when reading a line\", e) }\n        }\n        match number_str.trim().parse::&lt;i32&gt;() {\n            Err(n) =&gt; {\n                println!(\"ERROR: Entered something that is not a number: '{}'\",\n                    number_str.trim_right());\n                process::exit(1)\n            },\n            Ok(n) =&gt; { sum += n }\n        }\n    }\n}\n</code></pre>\n\n<p><strong>Note</strong>: there is an <a href=\"https://stackoverflow.com/q/27475113/1091116\">identical question</a> but the answer seems to be out of date anymore, which is why I added a version number in the question title.</p>\n"}, {"tags": ["rust", "shuffle", "deque"], "answers": [{"comments": [{"owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "edited": false, "score": 0, "creation_date": 1482069930, "post_id": 41208996, "comment_id": 69616939, "body": "Thank you for this very long and detailed explanation!"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1482087844, "post_id": 41208996, "comment_id": 69622472, "body": "Indeed, the <code>shuffle</code> argument is quite unfortunate seeing as the contiguity is unused."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1482088237, "post_id": 41208996, "comment_id": 69622573, "body": "@MatthieuM. Maybe <code>shuffle</code> shouldn&#39;t be defined on slices, but on a <code>Shufflable</code> trait (defined for slice by default) defined the same way as <code>LenAndSwap</code> above? That would be backward-compatible with the current definition."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 6, "last_activity_date": 1482085364, "last_edit_date": 1482085364, "creation_date": 1482069190, "answer_id": 41208996, "question_id": 41208694, "link": "https://stackoverflow.com/questions/41208694/how-do-i-shuffle-a-vecdeque/41208996#41208996", "title": "How do I shuffle a VecDeque?", "body": "<p>Unfortunately, the <a href=\"https://doc.rust-lang.org/rand/rand/trait.Rng.html#method.shuffle\" rel=\"nofollow noreferrer\"><code>rand::Rng::shuffle</code> method</a> is defined to shuffle slices. Due to its own complexity constraints a <code>VecDeque</code> cannot store its elements in a slice, so <code>shuffle</code> can never be directly invoked on a <code>VecDeque</code>.</p>\n\n<p>The real requirement of the <code>values</code> argument to <code>shuffle</code> algorithm are finite sequence length, O(1) element access, and the ability to swap elements, all of which <code>VecDeque</code> fulfills. It would be nice if there were a trait that incorporates these, so that <code>values</code> could be generic on that, but there isn't one.</p>\n\n<p>With the current library, you have two options:</p>\n\n<ul>\n<li><p>Use <code>Vec::from(deque)</code> to copy the <code>VecDeque</code> into a temporary <code>Vec</code>, shuffle the vector, and return the contents back to <code>VecDeque</code>. This complexity of the operation will remain O(n), but it will require a potentially large and costly heap allocation of the temporary vector.</p></li>\n<li><p>Implement the shuffle on <code>VecDeque</code> yourself. The <a href=\"https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\" rel=\"nofollow noreferrer\">Fisher-Yates shuffle</a> used by <code>rand::Rng</code> is well understood and easy to implement, in its modern form it boils down to only about <a href=\"https://doc.rust-lang.org/rand/src/rand/src/lib.rs.html#546\" rel=\"nofollow noreferrer\">5 lines of code</a>. While in theory the standard library could switch to a different shuffle algorithm, that is not likely to happen in practice.</p></li>\n</ul>\n\n<p>A generic form of the second option, using a trait to express the len-and-swap requirement, and taking the code of <code>rand::Rng::shuffle</code>, could look like this:</p>\n\n<pre><code>extern crate rand;\n\nuse std::collections::VecDeque;\n\n// Real requirement for shuffle\ntrait LenAndSwap {\n    fn len(&amp;self) -&gt; usize;\n    fn swap(&amp;mut self, i: usize, j: usize);\n}\n\n// An exact copy of rand::Rng::shuffle, with the signature modified to\n// accept any type that implements LenAndSwap\nfn shuffle&lt;T, R&gt;(values: &amp;mut T, mut rng: R)\n    where T: LenAndSwap,\n          R: rand::Rng {\n    let mut i = values.len();\n    while i &gt;= 2 {\n        // invariant: elements with index &gt;= i have been locked in place.\n        i -= 1;\n        // lock element i in place.\n        values.swap(i, rng.gen_range(0, i + 1));\n    }\n}\n\n// VecDeque trivially fulfills the LenAndSwap requirement, but\n// we have to spell it out.\nimpl&lt;T&gt; LenAndSwap for VecDeque&lt;T&gt; {\n    fn len(&amp;self) -&gt; usize {\n        self.len()\n    }\n    fn swap(&amp;mut self, i: usize, j: usize) {\n        self.swap(i, j)\n    }\n}\n\nfn main() {\n    let mut v: VecDeque&lt;u64&gt; = [1, 2, 3, 4].iter().cloned().collect();\n    shuffle(&amp;mut v, rand::thread_rng());\n    println!(\"{:?}\", v);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 2, "creation_date": 1482072404, "post_id": 41209386, "comment_id": 69617614, "body": "As far as I understand this won&#39;t have the same effect, as elements are never swapped between both slices. So it&#39;s not a full shuffle and it&#39;s different from the &quot;to <code>Vec</code>, shuffle, to <code>VecDeque</code>&quot; solution..."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 1, "creation_date": 1482072494, "post_id": 41209386, "comment_id": 69617636, "body": "@LukasKalbertodt a good point! I guess it depends on the usecase how valid such a randomization would be."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": -1, "last_activity_date": 1558147373, "last_edit_date": 1558147373, "creation_date": 1482071847, "answer_id": 41209386, "question_id": 41208694, "link": "https://stackoverflow.com/questions/41208694/how-do-i-shuffle-a-vecdeque/41209386#41209386", "title": "How do I shuffle a VecDeque?", "body": "<p>Shuffle the components of the <code>VecDeque</code> separately, starting with <a href=\"https://doc.rust-lang.org/collections/vec_deque/struct.VecDeque.html#method.as_mut_slices\" rel=\"nofollow noreferrer\"><code>VecDeque.html::as_mut_slices</code></a>:</p>\n\n<pre><code>use rand::seq::SliceRandom; // 0.6.5;\nuse std::collections::VecDeque; \n\nfn shuffle(coll: &amp;mut VecDeque&lt;i32&gt;) {\n    let mut rng = rand::thread_rng();\n    let (a, b) = coll.as_mut_slices();\n    a.shuffle(&amp;mut rng);\n    b.shuffle(&amp;mut rng);\n}\n</code></pre>\n\n<p>As <a href=\"https://stackoverflow.com/questions/41208694/how-do-i-shuffle-a-vecdeque/41209386#comment69617614_41209386\">Lukas Kalbertodt points out</a>, this solution never swaps elements between the two slices so a certain amount of randomization will not happen. Depending on your needs of randomization, this may be unnoticeable or a deal breaker. </p>\n"}], "owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1384, "favorite_count": 0, "accepted_answer_id": 41208996, "answer_count": 2, "score": 4, "last_activity_date": 1558147373, "creation_date": 1482066931, "last_edit_date": 1482073380, "question_id": 41208694, "link": "https://stackoverflow.com/questions/41208694/how-do-i-shuffle-a-vecdeque", "title": "How do I shuffle a VecDeque?", "body": "<p>I can shuffle a regular vector quite simply like this:</p>\n\n<pre><code>extern crate rand;\nuse rand::Rng;\n\nfn shuffle(coll: &amp;mut Vec&lt;i32&gt;) {\n    rand::thread_rng().shuffle(coll);\n}\n</code></pre>\n\n<p>The problem is, my code now requires the use of a <code>std::collections::VecDeque</code> instead, which causes this code to not compile.</p>\n\n<p>What's the simplest way of getting around this?</p>\n"}, {"tags": ["rust", "type-conversion"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user743382"}, "edited": false, "score": 0, "creation_date": 1482061631, "post_id": 41207885, "comment_id": 69614762, "body": "Could you not avoid the problem by writing <code>println!(&quot;{}&quot;, i32::from(a));</code>, or am I missing some obvious reason why you need <code>into</code>?"}, {"owner": {"reputation": 20035, "user_id": 2971, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/f3f6251940b41a2251e7a9f4b745a7f2?s=128&d=identicon&r=PG", "display_name": "Magnus Hoff", "link": "https://stackoverflow.com/users/2971/magnus-hoff"}, "edited": false, "score": 0, "creation_date": 1482061789, "post_id": 41207885, "comment_id": 69614799, "body": "hvd: Uh, that&#39;s perfect! I should have said &quot;something like <code>into</code>&quot; or &quot;<code>into</code> or <code>from</code>&quot; or something along those lines. It is sometimes difficult to find the exact level of preciseness for a question ;) Thanks!"}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 1, "last_activity_date": 1482061219, "creation_date": 1482061219, "answer_id": 41207978, "question_id": 41207885, "link": "https://stackoverflow.com/questions/41207885/using-generic-trait-methods-like-into-when-type-inference-is-impossible/41207978#41207978", "title": "Using generic trait methods like .into() when type inference is impossible", "body": "<p>You can simply annotate the type of the result by assigning it to a variable.</p>\n\n<pre><code>let b: i32 = a.into();\nprintln!(\"{}\", b);\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 20035, "user_id": 2971, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/f3f6251940b41a2251e7a9f4b745a7f2?s=128&d=identicon&r=PG", "display_name": "Magnus Hoff", "link": "https://stackoverflow.com/users/2971/magnus-hoff"}, "is_accepted": false, "score": 8, "last_activity_date": 1548856454, "last_edit_date": 1548856454, "creation_date": 1482061460, "answer_id": 41208005, "question_id": 41207885, "link": "https://stackoverflow.com/questions/41207885/using-generic-trait-methods-like-into-when-type-inference-is-impossible/41208005#41208005", "title": "Using generic trait methods like .into() when type inference is impossible", "body": "<p>Apparently, this is possible on Rust nightly with <a href=\"https://github.com/rust-lang/rust/issues/23416\" rel=\"nofollow noreferrer\">type ascription</a>, which seems to be a feature designed for this use case (<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=35f6c2c0f733ccfe015d4d58e5cf4384\" rel=\"nofollow noreferrer\">playground</a>):</p>\n\n<pre><code>#![feature(type_ascription)]\n\nuse std::convert::*;\n\nstruct NewType(pub i32);\n\nimpl From&lt;NewType&gt; for i32 {\n    fn from(src: NewType) -&gt; i32 {\n        src.0\n    }\n}\n\nfn main() {\n    let a = NewType(5);\n    println!(\"{}\", a.into(): i32);\n}\n</code></pre>\n\n<p>Since this is available in an experimental feature, it might be reasonable to conclude that it is otherwise missing from the language proper.</p>\n"}, {"comments": [{"owner": {"reputation": 20035, "user_id": 2971, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/f3f6251940b41a2251e7a9f4b745a7f2?s=128&d=identicon&r=PG", "display_name": "Magnus Hoff", "link": "https://stackoverflow.com/users/2971/magnus-hoff"}, "edited": false, "score": 1, "creation_date": 1482062014, "post_id": 41208016, "comment_id": 69614854, "body": "I&#39;m not sure why I believed that I had to import <code>Into</code>. But you are absolutely right that I don&#39;t have to. Thanks :) Type ascription looks like exactly what I was imagining, but I will go for the stable <code>i32:from(a)</code> instead :)"}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 27, "last_activity_date": 1548856483, "last_edit_date": 1548856483, "creation_date": 1482061559, "answer_id": 41208016, "question_id": 41207885, "link": "https://stackoverflow.com/questions/41207885/using-generic-trait-methods-like-into-when-type-inference-is-impossible/41208016#41208016", "title": "Using generic trait methods like .into() when type inference is impossible", "body": "<p>I don't think there is a better way. Since the type parameter is on the trait, not the method <code>into()</code>, the turbofish operator <code>into::&lt;i32&gt;()</code> doesn't work. As you said, you can make it work by using the fully-qualified-syntax:</p>\n\n<pre><code>Into::&lt;i32&gt;::into(a)\n</code></pre>\n\n<p>Note, that <code>Into</code> is reexported in <code>std::prelude</code>, which means that you never have to specify the full path, as the trait is always in scope.</p>\n\n<p>Of course, there is also always the possibility to bind your temporary to a name and use the type annotation of the <code>let</code>-binding:</p>\n\n<pre><code>let tmp: i32 = a.into();\n</code></pre>\n\n<hr>\n\n<p>It might be better in the future, though! There is an <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md\" rel=\"noreferrer\"><em>Type Ascription for Expressions</em> RFC</a>, which was already accepted and implemented. The feature is still unstable, but if it's implemented you could write something like:</p>\n\n<pre><code>println!(\"{}\", (a.into(): i32));   // still unstable :/\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 38158, "user_id": 2707792, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/hjDjB.png?s=128&g=1", "display_name": "Andrey Tyukin", "link": "https://stackoverflow.com/users/2707792/andrey-tyukin"}, "edited": false, "score": 4, "creation_date": 1549686527, "post_id": 41208048, "comment_id": 96002225, "body": "Why one can expect that there is a <code>From</code>: <i>&quot;Library authors should not directly implement [the Into] trait, but should prefer implementing the From trait, which offers greater flexibility and provides an equivalent Into implementation for free, thanks to a blanket implementation in the standard library.&quot;</i> - from the documentation of <code>Into</code>."}], "tags": [], "owner": {"reputation": 5013, "user_id": 4181011, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/0C2A9.jpg?s=128&g=1", "display_name": "Simon Kraemer", "link": "https://stackoverflow.com/users/4181011/simon-kraemer"}, "is_accepted": true, "score": 29, "last_activity_date": 1548856377, "last_edit_date": 1548856377, "creation_date": 1482061788, "answer_id": 41208048, "question_id": 41207885, "link": "https://stackoverflow.com/questions/41207885/using-generic-trait-methods-like-into-when-type-inference-is-impossible/41208048#41208048", "title": "Using generic trait methods like .into() when type inference is impossible", "body": "<p>You could use <a href=\"https://doc.rust-lang.org/stable/std/convert/trait.From.html#tymethod.from\" rel=\"noreferrer\"><code>From::from</code></a>:</p>\n\n<pre><code>use std::convert::*;\n\nstruct NewType(pub i32);\n\nimpl From&lt;NewType&gt; for i32 {\n    fn from(src: NewType) -&gt; i32 {\n        src.0\n    }\n}\n\nfn main() {\n    let a = NewType(5);\n    println!(\"{}\", i32::from(a));\n}\n</code></pre>\n\n<p>You can read more about it in the <a href=\"https://doc.rust-lang.org/stable/std/convert/index.html\" rel=\"noreferrer\">docs for the <code>convert</code> module</a>. </p>\n"}], "owner": {"reputation": 20035, "user_id": 2971, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/f3f6251940b41a2251e7a9f4b745a7f2?s=128&d=identicon&r=PG", "display_name": "Magnus Hoff", "link": "https://stackoverflow.com/users/2971/magnus-hoff"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 9992, "favorite_count": 3, "accepted_answer_id": 41208048, "answer_count": 4, "score": 35, "last_activity_date": 1610237045, "creation_date": 1482060474, "last_edit_date": 1610237045, "question_id": 41207885, "link": "https://stackoverflow.com/questions/41207885/using-generic-trait-methods-like-into-when-type-inference-is-impossible", "title": "Using generic trait methods like .into() when type inference is impossible", "body": "<p>I'm hoping to be able to use <code>.into()</code> to convert a value in a context where type inference is impossible. This is typically when I want to convert a temporary value into some other type for passing it into a generic function. See the following code for an example (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9bf3ac22e1fbb5122ad30499d3e5070c\" rel=\"noreferrer\">playground</a>):</p>\n\n<pre><code>use std::convert::*;\n\nstruct NewType(pub i32);\n\nimpl From&lt;NewType&gt; for i32 {\n    fn from(src: NewType) -&gt; i32 {\n        src.0\n    }\n}\n\nfn main() {\n    let a = NewType(5);\n    println!(\"{}\", a.into()); // Understandably won't compile\n}\n</code></pre>\n\n<p>I get the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0282]: type annotations needed\n  --&gt; src/main.rs:13:20\n   |\n13 |     println!(\"{}\", a.into());\n   |                    ^^^^^^^^ cannot infer type for `T`\n</code></pre>\n\n<p>How do I properly tell the compiler that I want to convert <code>a</code> into <code>i32</code>?</p>\n\n<p>I can get it to work right by explicitly feeding <code>Into</code> with type arguments: <code>Into::&lt;i32&gt;::into(a)</code>. This is more verbose and explicit than I was hoping to be able to achieve, especially in a context where I have not imported <code>Into</code> (<code>std::convert::Into::&lt;i32&gt;::into(a)</code>). <code>a.into::&lt;i32&gt;()</code> would be acceptable, but that is not where the type arguments go.</p>\n\n<p><code>a.into() as i32</code> would look nice, but this exact syntax doesn't work.</p>\n\n<p>Is there a trick I am missing?</p>\n"}, {"tags": ["arrays", "rust"], "comments": [{"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 4, "creation_date": 1482060396, "post_id": 41207666, "comment_id": 69614421, "body": "note that <code>0..2</code> should be <code>0..3</code> in your code."}, {"owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "edited": false, "score": 1, "creation_date": 1482153395, "post_id": 41207666, "comment_id": 69645396, "body": "&quot;ugly&quot; is subjective, but I find the explicit  <code>for i in 0..3</code> much more readable than the proposed alternatives"}], "answers": [{"comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user1569030"}, "edited": false, "score": 0, "creation_date": 1482061553, "post_id": 41207820, "comment_id": 69614739, "body": "Minor follow-up: If I want to declare a function <code>fn cmap(a: Coord, b: Coord, f: F) -&gt; Coord { new_coord_from(a.iter().zip(&amp;b).map(f)); }</code> to abstract out the iter/zip part too so I can declare <code>fn add(a: Coord, b: Coord) -&gt; Coord { cmap(a,b, |(a,b)| a + b) }</code> - what type do I need to put for F?"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1482064841, "post_id": 41207820, "comment_id": 69615536, "body": "@Bristol Ass currently written, it would be <code>cmap&lt;F: Fn((&amp;i64, &amp;i64)) -&gt; i64&gt;(a: Coord, b: Coord, f: F) -&gt; Coord</code>. I would prefer, however, to get rid of the references and have <code>F</code> receive two numbers instead of a tuple: <code>fn cmap&lt;F: Fn(i64, i64) -&gt; i64&gt;(a: Coord, b: Coord, f: F) -&gt; Coord { new_coord_from(a.iter().zip(&amp;b).map(|(x, y)| f(*x, *y))) }</code>. The definition of <code>add</code> then boils down to the simplest form, <code>cmap(a, b, |x, y| x + y)</code> or even <code>cmap(a, b, i64::add)</code> (after bringing the <code>Add</code> trait into the scope with <code>use std::ops::Add</code>)."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 4, "last_activity_date": 1482060828, "last_edit_date": 1482060828, "creation_date": 1482060001, "answer_id": 41207820, "question_id": 41207666, "link": "https://stackoverflow.com/questions/41207666/how-do-i-add-two-rust-arrays-element-wise/41207820#41207820", "title": "How do I add two Rust arrays element-wise?", "body": "<p>One simple approach is to generate indices using the <code>enumerate</code> iterator method and fill <code>z</code> the \"obvious\" way, by assigning into the obtained indices:</p>\n\n<pre><code>type Coord = [i64; 3];\n\nfn add(a: Coord, b: Coord) -&gt; Coord {\n    let mut z: Coord = [0, 0, 0];\n    for (i, (aval, bval)) in a.iter().zip(&amp;b).enumerate() {\n        z[i] = aval + bval;\n    }\n    z\n}\n\nfn main() {\n    let x: Coord = [1, 2, 3];\n    let y: Coord = [1, 1, 1];\n    assert!(add(x, y) == [2, 3, 4]);\n}\n</code></pre>\n\n<p>In Rust, we can do better than that by noticing that <code>iter()</code> produces <em>references</em> into the array, and <code>iter_mut()</code> is available to produce mutable references. This results in code very similar to what you attempted to write:</p>\n\n<pre><code>fn add(a: Coord, b: Coord) -&gt; Coord {\n    let mut z: Coord = [0, 0, 0];\n    for ((zref, aval), bval) in z.iter_mut().zip(&amp;a).zip(&amp;b) {\n        *zval = aval + bval;\n    }\n    z\n}\n</code></pre>\n\n<p>If this pattern of writing into <code>z</code> recurs with different operations, you can abstract the creation of new <code>Coord</code> and filling it with data into a generic function:</p>\n\n<pre><code>fn new_coord_from&lt;F: Iterator&lt;Item=i64&gt;&gt;(src: F) -&gt; Coord {\n    let mut result = [0; 3];\n    for (rref, val) in result.iter_mut().zip(src) {\n        *rref = val;\n    }\n    result\n}\n</code></pre>\n\n<p><code>add</code> then looks just like we'd like it to:</p>\n\n<pre><code>fn add(a: Coord, b: Coord) -&gt; Coord {\n    new_coord_from(a.iter().zip(&amp;b).map(|(a, b)| a + b))\n}\n</code></pre>\n"}], "owner": {"user_type": "does_not_exist", "display_name": "user1569030"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4941, "favorite_count": 1, "accepted_answer_id": 41207820, "answer_count": 1, "score": 4, "last_activity_date": 1482072662, "creation_date": 1482058867, "last_edit_date": 1482072662, "question_id": 41207666, "link": "https://stackoverflow.com/questions/41207666/how-do-i-add-two-rust-arrays-element-wise", "title": "How do I add two Rust arrays element-wise?", "body": "<p>This is an absolute beginner question, but I can't find anything useful after searching for half an hour. I have Rust 1.7.0 and this code:</p>\n\n<pre><code>type coord = [i64; 3];\n\n// add two coordinates (\"vectors\") pointwise, that is\n// if z = add(a, b) then z[i] = a[i] + b[i] for i=0..2\nfn add(a: coord, b: coord) -&gt; coord {\n    //???\n}\n</code></pre>\n\n<p>The obvious thing I tried first is <code>a.zip(b).map(|(u,v)| u+v)</code> but this doesn't work (can't zip arrays), nor does <code>a.iter().zip(b.iter()).map(|(u,v)| u+v)</code> because it can't convert the iterator back to an array. I can see why this doesn't work in general but in this case we know both things are the same length.</p>\n\n<p>For now I'm doing</p>\n\n<pre><code>fn add(a: coord, b: coord) -&gt; coord {\n    let mut z: coord = [0, 0, 0];\n    for i in 0..2 {\n        z[i] = a[i] + b[i];\n    }\n    z\n}\n</code></pre>\n\n<p>but it looks ugly by comparison. What am I missing?</p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "edited": false, "score": 0, "creation_date": 1482057530, "post_id": 41207306, "comment_id": 69613874, "body": "You&#39;re passing an &amp;(Deck, Deck) to your draw_pair function, not the expected &amp;(&amp;mut Deck, &amp;mut Deck)."}, {"owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "reply_to_user": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "edited": false, "score": 0, "creation_date": 1482057868, "post_id": 41207306, "comment_id": 69613932, "body": "@SplittyDev I&#39;m aware of that."}, {"owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "reply_to_user": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "edited": false, "score": 0, "creation_date": 1482058023, "post_id": 41207306, "comment_id": 69613962, "body": "@SplittyDev the data I have at hand is immutable by default"}, {"owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "edited": false, "score": 0, "creation_date": 1482059266, "post_id": 41207306, "comment_id": 69614187, "body": "I just updated my answer to include a better version of the code without the ugly clones and tuple references."}], "answers": [{"comments": [{"owner": {"reputation": 5308, "user_id": 4038191, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/10ec10e81b5315fe2147c38bf3e15e9e?s=128&d=identicon&r=PG", "display_name": "EvilTak", "link": "https://stackoverflow.com/users/4038191/eviltak"}, "edited": false, "score": 0, "creation_date": 1482057597, "post_id": 41207460, "comment_id": 69613886, "body": "A <code>mut</code> reference is needed. It should be <code>let (ref mut p1, ref mut p2)</code>"}, {"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "reply_to_user": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "edited": false, "score": 0, "creation_date": 1482058479, "post_id": 41207460, "comment_id": 69614041, "body": "@ElectricCoffee it is better to ask a new question instead of adding more problems to it, but I have included a possible solution to my answer. As I don&#39;t know your exact requirements, I am not sure it will work for you. Please consider to include a <a href=\"http://stackoverflow.com/help/mcve\">Minimal, Complete, and Verifiable</a> example that reproduces your problem in the future."}, {"owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "edited": false, "score": 0, "creation_date": 1482058596, "post_id": 41207460, "comment_id": 69614058, "body": "I know, bad habit. But I figured I&#39;d tack it on since it was related to the previous question. Someone asked how I used it, so that&#39;s why. Is there really no shorter way of doing that without modifying the type?"}], "tags": [], "owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "is_accepted": false, "score": 0, "last_activity_date": 1482058234, "last_edit_date": 1495540801, "creation_date": 1482057078, "answer_id": 41207460, "question_id": 41207306, "link": "https://stackoverflow.com/questions/41207306/mutable-reference-to-a-tuple-as-input-parameter/41207460#41207460", "title": "Mutable reference to a tuple as input parameter", "body": "<p>This is the first error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>8 |     let (&amp;mut p1, &amp;mut p2) = decks;\n  |         ^^^^^^^^^^^^^^^^^^ expected reference, found tuple\n  |\n  = note: expected type `&amp;(&amp;mut Deck, &amp;mut Deck)`\n  = note:    found type `(_, _)`\n</code></pre>\n\n<p>The easiest way to fix that is dereferencing the right size (<code>*decks</code>), but then you get the other error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>8 |     let (&amp;mut p1, &amp;mut p2) = *decks;\n  |          ^^^^^--\n  |          |    |\n  |          |    hint: to prevent move, use `ref p1` or `ref mut p1`\n  |          cannot move out of borrowed content\n</code></pre>\n\n<p>As hinted using <code>ref</code> fixes this:</p>\n\n<pre><code>let (&amp;mut ref p1, &amp;mut ref p2) = *decks;\n</code></pre>\n\n<p>But there is no need to fully destructure the left side, you can also use</p>\n\n<pre><code>let (ref p1, ref p2) = *decks;\n</code></pre>\n\n<p>Here is a <a href=\"https://stackoverflow.com/help/mcve\">minimum implementation</a> to reproduce your problem, with the fix applied:</p>\n\n<pre><code>struct Card{}\nstruct Deck{}\nimpl Deck {\n    fn draw_card(&amp;self) -&gt; Card { Card {}}\n}\n\nfn draw_pair(decks: &amp;(&amp;mut Deck, &amp;mut Deck)) -&gt; (Card, Card) {\n    let (ref p1, ref p2) = *decks;\n\n    (p1.draw_card(), p2.draw_card())\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n</code></pre>\n\n<p>edit: here is a solution for your <code>play</code> function without modifying it's signature:</p>\n\n<pre><code>struct Card{}\n\n#[derive(Clone)]\nstruct Deck{}\nimpl Deck {\n    fn draw_card(&amp;self) -&gt; Card { Card {}}\n}\n\nfn play(decks: (Deck, Deck)) {\n    loop {\n        let (ref deck1, ref deck2) = decks;\n        let mut deck1 = deck1.clone();\n        let mut deck2 = deck2.clone();\n        let decks = (&amp;mut deck1, &amp;mut deck2);\n        let cards = draw_pair(&amp;decks);\n        // actual game not yet implemented\n    }\n}\n\nfn draw_pair(decks: &amp;(&amp;mut Deck, &amp;mut Deck)) -&gt; (Card, Card) {\n    let (ref p1, ref p2) = *decks;\n\n    (p1.draw_card(), p2.draw_card())\n}\n\nfn main() {\n    play((Deck{}, Deck{}));\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 5308, "user_id": 4038191, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/10ec10e81b5315fe2147c38bf3e15e9e?s=128&d=identicon&r=PG", "display_name": "EvilTak", "link": "https://stackoverflow.com/users/4038191/eviltak"}, "edited": false, "score": 0, "creation_date": 1482059934, "post_id": 41207641, "comment_id": 69614298, "body": "That&#39;s not an ideal solution though. The line which makes it all work <code>let mut decks = decks</code> is a bad hack, which should be avoided at all costs. It doesn&#39;t make a difference in such a small application, but it will in a multithreaded/concurrent scenario. Something which is immutable should not be mutated at any cost."}, {"owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "reply_to_user": {"reputation": 5308, "user_id": 4038191, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/10ec10e81b5315fe2147c38bf3e15e9e?s=128&d=identicon&r=PG", "display_name": "EvilTak", "link": "https://stackoverflow.com/users/4038191/eviltak"}, "edited": false, "score": 0, "creation_date": 1482060071, "post_id": 41207641, "comment_id": 69614332, "body": "How is this something that should be avoided at all costs? You own the Pair&lt;T&gt;, so you can obtain a mutable reference to it. This will never cause any problems. In a multi-threaded scenario you&#39;d be synchronizing it anyway, using a Cell&lt;T&gt; or Mutex&lt;T&gt;. Alternatively, you can change the Pair&lt;Deck&gt; to a &amp;mut Pair&lt;Deck&gt; and you&#39;ll be good."}], "tags": [], "owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "is_accepted": false, "score": 1, "last_activity_date": 1482072422, "last_edit_date": 1482072422, "creation_date": 1482058715, "answer_id": 41207641, "question_id": 41207306, "link": "https://stackoverflow.com/questions/41207306/mutable-reference-to-a-tuple-as-input-parameter/41207641#41207641", "title": "Mutable reference to a tuple as input parameter", "body": "<p>Since you can't move out of the borrowed mutable references, you'll have to clone the fields.</p>\n\n<pre><code>fn main() {\n    play((&amp;mut Deck(0), &amp;mut Deck(0)));\n}\n\n#[derive(Clone)]\nstruct Deck(i32);\n\nfn play(decks: (&amp;mut Deck, &amp;mut Deck)) {\n    let cards = draw_pair(&amp;decks);\n}\n\nfn draw_pair(decks: &amp;(&amp;mut Deck, &amp;mut Deck)) -&gt; (i32, i32) {\n    let mut p1 = decks.0.clone();\n    let mut p2 = decks.1.clone();\n    (0, 0)\n}\n</code></pre>\n\n<p>Here's a <a href=\"https://play.rust-lang.org/?gist=d2690093bfaaa0c02a26c17bab3b3311&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playpen</a> and <a href=\"https://play.rust-lang.org/?gist=663ca03dd42c6cb08293792d050c798a&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">here's a version</a> that preserves the <code>play</code> signature.</p>\n\n<p>Honestly though, I think in this case, adding a new type to represent the tuple would be a more clean and readable solution.</p>\n\n<p>Ideally, I'd do it like that:</p>\n\n<pre><code>struct Deck {}\nstruct Card {}\n\n#[derive(Debug)]\nstruct Pair&lt;T&gt; {\n    first: T,\n    second: T,\n}\n\nimpl&lt;T&gt; Pair&lt;T&gt; {\n    pub fn new(first: T, second: T) -&gt; Pair&lt;T&gt; {\n        Pair { first: first, second: second }\n    }\n}\n\nfn play(decks: Pair&lt;Deck&gt;) {\n    let mut decks = decks;\n    let cards = draw_pair(&amp;mut decks);\n}\n\nfn draw_pair(decks: &amp;mut Pair&lt;Deck&gt;) -&gt; Pair&lt;Card&gt; {\n    Pair::new(Card {}, Card {})\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 5308, "user_id": 4038191, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/10ec10e81b5315fe2147c38bf3e15e9e?s=128&d=identicon&r=PG", "display_name": "EvilTak", "link": "https://stackoverflow.com/users/4038191/eviltak"}, "is_accepted": true, "score": 1, "last_activity_date": 1482058787, "creation_date": 1482058787, "answer_id": 41207654, "question_id": 41207306, "link": "https://stackoverflow.com/questions/41207306/mutable-reference-to-a-tuple-as-input-parameter/41207654#41207654", "title": "Mutable reference to a tuple as input parameter", "body": "<p>Whenever you want to obtain references using pattern matching and destructuring, use <a href=\"http://rustbyexample.com/scope/borrow/ref.html\" rel=\"nofollow noreferrer\"><code>ref</code> instead of <code>&amp;</code></a>.  Use <code>let (ref mut p1, ref mut p2)</code> instead, and dereference <code>deck</code>.</p>\n\n<p>You have to note that you cannot mutate immutable data. You can either use your own mutable clones, or work without mutation. Making <code>decks</code> in <code>play</code> mutable is the only way to obtain mutable references to the inner data in <code>draw_pair</code>. The following code solves your problem:</p>\n\n<pre><code>fn draw_pair(decks: &amp;mut (Deck, Deck)) -&gt; (Card, Card) {\n    let (ref mut p1, ref mut p2) = *decks;\n\n    (p1.draw_card(), p2.draw_card())\n}\n\nfn play(mut decks: (Deck, Deck)) {\n    loop {\n        let cards = draw_pair(&amp;mut decks);\n        // actual game not yet implemented\n    }\n}\n</code></pre>\n\n<p>If the <code>decks</code> pair you receive in <code>play</code> is immutable, there's no other way around it but to maintain your own cloned and mutable <code>Deck</code>s like @wimh does in his answer. If you want to create your own mutable clone more concisely, the following one liner will help: <code>&amp;(&amp;mut decks.0.clone(), &amp;mut decks.1.clone())</code></p>\n"}], "owner": {"reputation": 10492, "user_id": 1351298, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/KJKqs.jpg?s=128&g=1", "display_name": "Electric Coffee", "link": "https://stackoverflow.com/users/1351298/electric-coffee"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1843, "favorite_count": 0, "accepted_answer_id": 41207654, "answer_count": 3, "score": 1, "last_activity_date": 1482072422, "creation_date": 1482055616, "last_edit_date": 1482072334, "question_id": 41207306, "link": "https://stackoverflow.com/questions/41207306/mutable-reference-to-a-tuple-as-input-parameter", "title": "Mutable reference to a tuple as input parameter", "body": "<p>I seem to have fallen into the hole known as \"fighting the borrow checker\" on this one. I have the following function:</p>\n\n<pre><code>fn draw_pair(decks: &amp;(&amp;mut Deck, &amp;mut Deck)) -&gt; (Card, Card) {\n    let (&amp;mut p1, &amp;mut p2) = decks;\n\n    (p1.draw_card(), p2.draw_card())\n}\n</code></pre>\n\n<p>I get the following error: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>expected type: &amp;(&amp;mut Deck, &amp;mut Deck)\nfound type: (_, _)\n</code></pre>\n\n<p>The idea is to take mutable references the contents of the tuple. I see no reason to mutate the tuple itself. This function will be running in a loop.</p>\n\n<p>I've tried writing <code>let &amp;(&amp;mut p1, &amp;mut p2) = decks;</code> instead, but it tells me it can't move out of borrowed contents.</p>\n\n<p>Here's the function that calls <code>draw_pair</code>:</p>\n\n<pre><code>fn play(decks: (Deck, Deck)) {\n    loop {\n        let cards = draw_pair(&amp;decks);\n        // actual game not yet implemented\n    }\n}\n</code></pre>\n\n<p>This too gives me an error, saying it expects <code>&amp;(&amp;mut Deck, &amp;mut Deck)</code> but is getting <code>&amp;(Deck, Deck)</code>.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 2, "creation_date": 1482046522, "post_id": 41206326, "comment_id": 69611799, "body": "The method is <code>clone</code>.  Rust is a case-sensitive language.  <b>Edit</b>: I just realised what your problem might be: <code>Clone</code> is not a method, it&#39;s a trait, and the name of a trait doesn&#39;t have to have anything to do with the name of the methods it defines."}, {"owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1482060253, "post_id": 41206326, "comment_id": 69614389, "body": "@DK. you&#39;re right, the misspelling of &#39;clone&#39; is the issue here. Could you write this as an answer so it can be accepted/upvoted?"}], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 2, "last_activity_date": 1482061218, "creation_date": 1482061218, "answer_id": 41207976, "question_id": 41206326, "link": "https://stackoverflow.com/questions/41206326/specified-generic-type-to-implement-clone-but-type-doesnt-have-clone-method/41207976#41207976", "title": "Specified generic type to implement Clone but type doesn&#39;t have Clone method", "body": "<p>Two possible answers:</p>\n\n<ol>\n<li><p>The method is called <code>clone</code> with a lower-case <code>c</code>.  Rust is a case-sensitive language.</p></li>\n<li><p><code>Clone</code> is not a method, it's a trait.  The name of a trait doesn't have anything to do with the name(s) of any methods it might define.  In <code>Clone</code>'s case, it defines a method <code>clone</code> for implementing types.</p></li>\n</ol>\n\n<p>The solution in both cases is simple: write <code>weight.clone()</code> instead.</p>\n"}], "owner": {"reputation": 1582, "user_id": 4604899, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/WyuD9.jpg?s=128&g=1", "display_name": "Julien Chien", "link": "https://stackoverflow.com/users/4604899/julien-chien"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 516, "favorite_count": 0, "accepted_answer_id": 41207976, "answer_count": 1, "score": 0, "last_activity_date": 1482061218, "creation_date": 1482046063, "question_id": 41206326, "link": "https://stackoverflow.com/questions/41206326/specified-generic-type-to-implement-clone-but-type-doesnt-have-clone-method", "title": "Specified generic type to implement Clone but type doesn&#39;t have Clone method", "body": "<p>I have code like this, where I need to insert something into two separate hashmaps. I only want generic types that implement Clone.</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::clone::Clone;\n\npub struct Something&lt;A, B&gt; {\n    hm1: HashMap&lt;usize, B&gt;,\n    hm2: HashMap&lt;usize, B&gt;,\n    other: A,\n}\n\nimpl&lt;A, B&gt; Something&lt;A, B&gt;\n    where B: Clone\n{\n    fn add_to_both_hm(&amp;mut self, x: usize, y: usize, weight: B) {\n        self.hm1.insert(x, weight.Clone());\n        self.hm2.insert(y, weight);\n    }\n}\n</code></pre>\n\n<p>But when compiling, the compiler complains that <code>error: no method named 'Clone' found for type 'B' in the current scope</code>. </p>\n\n<p>Why does it still error even though I specified <code>where B: Clone</code>? How can I fix that?</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=92e938f95d44c456abcc8c4d24e6168c&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">The rust playground is here</a>.</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 33471, "user_id": 1420279, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/c799e8b3d14c4f149ce71455109f17eb?s=128&d=identicon&r=PG", "display_name": "Antimony", "link": "https://stackoverflow.com/users/1420279/antimony"}, "edited": false, "score": 0, "creation_date": 1482045959, "post_id": 41204718, "comment_id": 69611707, "body": "@Antimony I&#39;m not certain, but I <i>think</i> it has to do with <code>Cell</code> having interior mutability which <i>probably</i> affects the lifetime variance of the containing type.  Throwing mutability into the mix tends to make the borrow checker stricter.  I&#39;d give a more thorough answer, but this is one aspect that I&#39;m not solid on, myself."}, {"owner": {"reputation": 33471, "user_id": 1420279, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/c799e8b3d14c4f149ce71455109f17eb?s=128&d=identicon&r=PG", "display_name": "Antimony", "link": "https://stackoverflow.com/users/1420279/antimony"}, "edited": false, "score": 0, "creation_date": 1482074578, "post_id": 41204718, "comment_id": 69618254, "body": "Good point. I forgot about variance inference. That&#39;s probably the answer."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 6, "last_activity_date": 1482024683, "creation_date": 1482024683, "answer_id": 41204718, "question_id": 41204134, "link": "https://stackoverflow.com/questions/41204134/rust-lifetime-error/41204718#41204718", "title": "Rust lifetime error", "body": "<p>First, the solution:</p>\n\n<pre><code>use std::cell::Cell;\n\nstruct Bar&lt;'a&gt; {\n    bar: &amp;'a str,\n}\nimpl&lt;'a&gt; Bar&lt;'a&gt; {\n    fn new(foo: &amp;Foo&lt;'a&gt;) -&gt; Bar&lt;'a&gt; { Bar{bar: foo.raw} }\n}\n\npub struct Foo&lt;'a&gt; {\n    raw: &amp;'a str,\n    cell: Cell&lt;&amp;'a str&gt;,\n}\nimpl&lt;'a&gt; Foo&lt;'a&gt; {\n    fn get_bar(&amp;self) -&gt; Bar&lt;'a&gt; { Bar::new(&amp;self) }\n}\n</code></pre>\n\n<p>There are two problems in your code.  The first is with <code>get_bar</code>, where you didn't specify the lifetime for the return type.  When you don't specify lifetimes in signatures, Rust doesn't infer the correct lifetimes, it just blindly fills them in based on simple rules.  In this specific case, what you get is effectively <code>fn get_bar&lt;'b&gt;(&amp;'b self) -&gt; Bar&lt;'b&gt;</code> which is <em>obviously</em> wrong, given the lifetime of <code>self.raw</code> (which was what you actually wanted) is <code>'a</code>.  See the Rust Book chapter on <a href=\"https://doc.rust-lang.org/book/lifetimes.html#lifetime-elision\" rel=\"noreferrer\">Lifetime Elision</a>.</p>\n\n<p>The second problem is that you're over-constraining the argument to <code>Bar::new</code>.  <code>&amp;'a Foo&lt;'a&gt;</code> means you require a borrow to a <code>Foo</code> for as long as the strings it's borrowing exist.  But borrows within a type have to outlive values of said type, so the <em>only</em> lifetime valid in this case is where <code>'a</code> matches the entire lifetime of the thing being borrowed... and <em>that</em> conflicts with the signature of <code>get_bar</code> (where you're saying <code>&amp;self</code> won't necessarily live as long as <code>'a</code> since it has its own lifetime).  Long story short: remove the unnecessary <code>'a</code> from the <code>Foo</code> borrow, leaving just <code>&amp;Foo&lt;'a&gt;</code>.</p>\n\n<p>To rephrase the above: the problem with <code>get_bar</code> was that you hadn't written enough constraints, the problem with <code>Bar::new</code> was that you'd written too many.</p>\n"}, {"tags": [], "owner": {"reputation": 33471, "user_id": 1420279, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/c799e8b3d14c4f149ce71455109f17eb?s=128&d=identicon&r=PG", "display_name": "Antimony", "link": "https://stackoverflow.com/users/1420279/antimony"}, "is_accepted": false, "score": 4, "last_activity_date": 1482085732, "last_edit_date": 1482085732, "creation_date": 1482082314, "answer_id": 41211020, "question_id": 41204134, "link": "https://stackoverflow.com/questions/41204134/rust-lifetime-error/41211020#41211020", "title": "Rust lifetime error", "body": "<p>DK explained which constraints were missing and why, but I figured I should explain why the code was working before I added <code>Cell</code>. It turns out to be due to <a href=\"https://doc.rust-lang.org/nomicon/subtyping.html\" rel=\"nofollow noreferrer\">variance inference</a>.</p>\n\n<p>If you add in the inferred lifetimes to the original code and rename the lifetime variables to be unique, you get</p>\n\n<pre><code>struct Bar&lt;'b&gt; {\n    bar: &amp;'b str,\n}\nimpl&lt;'b&gt; Bar&lt;'b&gt; {\n    fn new(foo: &amp;'b Foo&lt;'b&gt;) -&gt; Bar&lt;'b&gt; { Bar{bar: foo.raw} }\n}\n\npub struct Foo&lt;'a&gt; {\n    raw: &amp;'a str,\n    cell: Cell&lt;&amp;'a str&gt;,\n}\nimpl&lt;'a&gt; Foo&lt;'a&gt; {\n    fn get_bar&lt;'c&gt;(&amp;'c self) -&gt; Bar&lt;'c&gt; { Bar::new(&amp;self) }\n}\n</code></pre>\n\n<p>The problem comes when calling <code>Bar::new</code>, because you are passing <code>&amp;'c Foo&lt;'a&gt;</code>, to something expecting <code>&amp;'b Foo&lt;'b&gt;</code>. Normally, immutable types in Rust are covariant, meaning that <code>&amp;Foo&lt;'a&gt;</code> is implicitly convertable to <code>&amp;Foo&lt;'b&gt;</code> whenever 'b is a shorter lifetime than 'a. Without the Cell, <code>&amp;'c Foo&lt;'a&gt;</code> converts to <code>&amp;'c Foo&lt;'c&gt;</code>, and is passed to <code>Bar::new</code> wiht 'b = 'c, so there is no problem.</p>\n\n<p>However, <code>Cell</code> adds interior mutability to <code>Foo</code>, which means that it is no longer safe to be covariant. This is because <code>Bar</code> could potentially try to assign a shorter lived <code>'b</code> reference back into the original <code>Foo</code>, but <code>Foo</code> requires that all of the references it holds are valid for the longer lifetime <code>'a</code>. Therefore, interior mutability makes <code>&amp;Foo</code> invariant, meaning you can no longer shorten the lifetime parameter implicitly.  </p>\n"}], "owner": {"reputation": 33471, "user_id": 1420279, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/c799e8b3d14c4f149ce71455109f17eb?s=128&d=identicon&r=PG", "display_name": "Antimony", "link": "https://stackoverflow.com/users/1420279/antimony"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 453, "favorite_count": 1, "accepted_answer_id": 41204718, "answer_count": 2, "score": 2, "last_activity_date": 1482085732, "creation_date": 1482018064, "last_edit_date": 1482071951, "question_id": 41204134, "link": "https://stackoverflow.com/questions/41204134/rust-lifetime-error", "title": "Rust lifetime error", "body": "<p>Can anyone tell what the lifetime error is in the following code? (simplified from my actual code) I've looked it over myself, but I can't figure out what is wrong or how to fix it. The problem comes when I try to add the <code>Cell</code>, but I'm not sure why.</p>\n\n<pre><code>use std::cell::Cell;\n\nstruct Bar&lt;'a&gt; {\n    bar: &amp;'a str,\n}\nimpl&lt;'a&gt; Bar&lt;'a&gt; {\n    fn new(foo: &amp;'a Foo&lt;'a&gt;) -&gt; Bar&lt;'a&gt; { Bar{bar: foo.raw} }\n}\n\npub struct Foo&lt;'a&gt; {\n    raw: &amp;'a str,\n    cell: Cell&lt;&amp;'a str&gt;,\n}\nimpl&lt;'a&gt; Foo&lt;'a&gt; {\n    fn get_bar(&amp;self) -&gt; Bar { Bar::new(&amp;self) }\n}\n</code></pre>\n\n<p>The compiler error is</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n  --&gt; src/foo.rs:15:32\n   |\n15 |     fn get_bar(&amp;self) -&gt; Bar { Bar::new(&amp;self) }\n   |                                ^^^^^^^^\n</code></pre>\n"}, {"tags": ["rust", "optional"], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1481998471, "post_id": 41201520, "comment_id": 69602448, "body": "&quot;<i>all methods</i>&quot; is quite a lot... maybe start with: <code>map()</code>, <code>map_err()</code> and <code>and_then()</code> as they are <i>probably</i> the most important ones and apply to many other types (apart from <code>Iterator</code>, <code>Option</code> and <code>Result</code>) as well. But I agree: getting familiar with most of the methods is important."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1482012653, "post_id": 41201520, "comment_id": 69606254, "body": "I actually can&#39;t quite get this to work. See <a href=\"https://play.rust-lang.org/?gist=0c2b17c5bc7c0a8507d3f60cd2043357&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">this code</a>. I found <a href=\"https://stackoverflow.com/questions/29879372/expected-trait-coreopsfnmut-found-type-parameter\">this related question</a> but still can&#39;t quite work it out. /noob"}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1482012706, "post_id": 41201520, "comment_id": 69606268, "body": "(Btw that code I linked doesn&#39;t use <code>map</code>, but it shows the same problem I have when I replace <code>match</code> in my actual code with <code>map</code>.)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1482014610, "post_id": 41201520, "comment_id": 69606846, "body": "@Timmmm that code has multiple errors, I&#39;ve addressed one relevant here, the other (IMO more fundamental) issue is addressed by <a href=\"http://stackoverflow.com/q/32682876/155423\">Is there any way to return a reference to a variable created in a function?</a>."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1482014909, "post_id": 41201520, "comment_id": 69606930, "body": "Ah yeah I tried returning by value but it complained something wasn&#39;t <code>Sized</code>. Not returning references makes sense from a C++ point of view. I was imagining Rust had some kind of Go-like escape analysis thing for some reason. Thanks for the tons of help you&#39;re giving me by the way!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 10, "last_activity_date": 1482014832, "last_edit_date": 1482014832, "creation_date": 1481997904, "answer_id": 41201520, "question_id": 41201368, "link": "https://stackoverflow.com/questions/41201368/concise-way-to-box-an-option/41201520#41201520", "title": "Concise way to box an Option", "body": "<p>Yes:</p>\n\n<pre><code>thing.map(Box::new)\n</code></pre>\n\n<p>I would strongly recommend memorizing all the methods on <code>Iterator</code>, <code>Option</code> and <code>Result</code> as they are so pervasively used in Rust. <code>Option</code> and <code>Result</code> have fewer than 25 inherent methods each, many of which have substantial overlap between the two types. At least read all of them to know what is available and memorize that. You can always open up the documentation again to find the exact name.</p>\n\n<hr>\n\n<blockquote>\n  <p>I actually can't quite get this to work.</p>\n\n<pre><code>fn function_2&lt;F&gt;(foo: Option&lt;F&gt;)\n    where F: 'static + FnMut()\n{\n    let tmp: Option&lt;Box&lt;FnMut()&gt;&gt; = foo.map(Box::new);\n}\n</code></pre>\n  \n     <pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:14:37\n   |\n14 |     let tmp: Option&lt;Box&lt;FnMut()&gt;&gt; = foo.map(Box::new);\n   |                                     ^^^^^^^^^^^^^^^^^ expected trait std::ops::FnMut, found type parameter\n   |\n   = note: expected type `std::option::Option&lt;Box&lt;std::ops::FnMut()&gt;&gt;`\n   = note:    found type `std::option::Option&lt;Box&lt;F&gt;&gt;`\n</code></pre>\n</blockquote>\n\n<p>The original code here wan't just transforming one type to another, it was also creating a <em>trait object</em>. I can't say for sure why that form of creating a trait object allowed to be implicit and this isn't:</p>\n\n<pre><code>foo.map(|f| Box::new(f));\n</code></pre>\n\n<p>However, you can instead say:</p>\n\n<pre><code>foo.map(|f| Box::new(f) as Box&lt;FnMut()&gt;);\n</code></pre>\n\n<p>(and no need to specify the type on the variable, of course).</p>\n\n<hr>\n\n<p>Pedantically, \"boxing an <code>Option</code>\" would be <code>Box&lt;Option&lt;T&gt;&gt;</code>.</p>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 615, "favorite_count": 0, "accepted_answer_id": 41201520, "answer_count": 1, "score": 3, "last_activity_date": 1482014832, "creation_date": 1481996930, "question_id": 41201368, "link": "https://stackoverflow.com/questions/41201368/concise-way-to-box-an-option", "title": "Concise way to box an Option", "body": "<p>Is there a more concise way to achieve the following?</p>\n\n<pre><code>fn boxed_option&lt;T&gt;(thing: Option&lt;T&gt;) -&gt; Option&lt;Box&lt;T&gt;&gt; {\n    match thing {\n        Some(x) =&gt; Some(Box::new(x)),\n        None =&gt; None,\n    }\n}\n</code></pre>\n"}, {"tags": ["command-line", "rust", "rustdoc"], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 1, "creation_date": 1481982517, "post_id": 41199223, "comment_id": 69597832, "body": "Didn&#39;t know <code>rustup doc --std</code>. That&#39;s a nice little command, thanks!"}], "tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": false, "score": 8, "last_activity_date": 1481982275, "creation_date": 1481982275, "answer_id": 41199223, "question_id": 41199122, "link": "https://stackoverflow.com/questions/41199122/how-to-check-standard-library-documentation-offline/41199223#41199223", "title": "How to check standard library documentation offline?", "body": "<p><code>rustdoc</code> is used to build the documentation of a package. Not to access standard doc.</p>\n\n<p>If you use <code>rustup</code>, you can open the offline documentation using <code>rustup doc --std</code> and then use the search box on the page (works offline too).\nIf you don't use rustup, the documentation might still have been installed somewhere on your system but the path would depend on the system and installation procedure.</p>\n"}, {"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 2, "last_activity_date": 1481982366, "creation_date": 1481982366, "answer_id": 41199238, "question_id": 41199122, "link": "https://stackoverflow.com/questions/41199122/how-to-check-standard-library-documentation-offline/41199238#41199238", "title": "How to check standard library documentation offline?", "body": "<p>You can generate the offline documentation by cloning the Rust Compiler Repository and run rustdoc inside. This is rather complicated, though. Luckily, there are other ways!</p>\n\n<p><a href=\"https://rustup.rs/\" rel=\"nofollow noreferrer\"><strong>Rustup</strong></a>, the tool that just hit 1.0 and is now the preferred installation method for Rust, already downloads the docs for you! If you are using it, you can find the docs in <code>~/.multirust/toolchains/*/doc</code> where <code>*</code> is your toolchain-name. For example:</p>\n\n<pre><code>~/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/std/\n</code></pre>\n\n<p>Apart from that, there are many tools like <a href=\"https://zealdocs.org/\" rel=\"nofollow noreferrer\">\"Zeal\"</a> which provide offline documentation for multiple languages.</p>\n"}], "owner": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 456, "favorite_count": 1, "closed_date": 1481986806, "answer_count": 2, "score": 3, "last_activity_date": 1516329656, "creation_date": 1481981644, "last_edit_date": 1516329656, "question_id": 41199122, "link": "https://stackoverflow.com/questions/41199122/how-to-check-standard-library-documentation-offline", "closed_reason": "Duplicate", "title": "How to check standard library documentation offline?", "body": "<p>I found <code>rustdoc</code> command and I kind of expected it to work like <code>pydoc</code>. Unfortunately, <code>rustdoc std::io:stdin</code> doesn't do what I'd like it to. Is there a way to view standard library documentation in an offline form, either via command line or some kind of built in web server, like Python's <code>pydoc</code> allows?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 2, "creation_date": 1481990011, "post_id": 41198995, "comment_id": 69600018, "body": "It is also worth noticing that <code>trim</code> is not a <code>String</code> method, it is actually a <code>str</code> method inherited by <code>String</code> through the miracle of the <code>Deref</code> trait."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 6, "last_activity_date": 1481980860, "creation_date": 1481980860, "answer_id": 41198995, "question_id": 41198951, "link": "https://stackoverflow.com/questions/41198951/why-does-name-name-trim-give-me-expected-struct-stdstringstring/41198995#41198995", "title": "Why does `name = *name.trim();` give me `expected struct `std::string::String`, found str`?", "body": "<p>Let's look at the <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.trim\" rel=\"nofollow noreferrer\">method signature of <code>str::trim()</code></a>:</p>\n\n<pre><code>fn trim(&amp;self) -&gt; &amp;str\n</code></pre>\n\n<p>It returns a <code>&amp;str</code> and not a <code>String</code>! Why? Because it doesn't need to! Trimming is an operation that doesn't need to allocate a new buffer and thus doesn't result in an owned string. A <code>&amp;str</code> is just a pointer and a length... by incrementing the pointer and reducing the length, we can have another view into the string-slice. That's all what trimming does.</p>\n\n<p>So if you really want to transform the trimmed string into an owned string, say <code>name.trim().to_owned()</code>.</p>\n"}], "owner": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1180, "favorite_count": 0, "answer_count": 1, "score": 3, "last_activity_date": 1481986521, "creation_date": 1481980540, "last_edit_date": 1481986521, "question_id": 41198951, "link": "https://stackoverflow.com/questions/41198951/why-does-name-name-trim-give-me-expected-struct-stdstringstring", "title": "Why does `name = *name.trim();` give me `expected struct `std::string::String`, found str`?", "body": "<p>Consider the example (does not build):</p>\n\n<pre><code>use std::io::{self, Write};\n\nfn main() {\n    io::stdout().write(b\"Please enter your name: \");\n    io::stdout().flush();\n    let mut name = String::new();\n    io::stdin().read_line(&amp;mut name);\n    name = *name.trim();\n    println!(\"Hello, {}!\", name);\n}\n</code></pre>\n\n<p>Why do I get the following error?</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; src/main.rs:8:12\n  |\n8 |     name = *name.trim();\n  |            ^^^^^^^^^^^^ expected struct `std::string::String`, found str\n  |\n  = note: expected type `std::string::String`\n  = note:    found type `str`\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "edited": false, "score": 0, "creation_date": 1482003613, "post_id": 41198919, "comment_id": 69603898, "body": "Why do I need to pull in write but not flush though? Also, aren&#39;t those methods of stdout/stdin?"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "edited": false, "score": 1, "creation_date": 1482006129, "post_id": 41198919, "comment_id": 69604563, "body": "<code>write()</code> and <code>flush()</code> are methods of <a href=\"https://doc.rust-lang.org/std/io/trait.Write.html\" rel=\"nofollow noreferrer\">the <code>Write</code> trait</a>. Therefore you just have to use that trait. <code>Stdout</code> is a type which <i>implements</i> the <code>Write</code> trait. The method signature is given by the trait, the implementation by the type itself. Does this clarify the issue? :)"}, {"owner": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "edited": false, "score": 0, "creation_date": 1482008532, "post_id": 41198919, "comment_id": 69605222, "body": "So <code>use std::io;</code> pulls types, but not traits?"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "edited": false, "score": 0, "creation_date": 1482010279, "post_id": 41198919, "comment_id": 69605619, "body": "No, as I said <code>use std::io;</code> pulls the name <code>io</code> (which is a module). It doesn&#39;t import any items from that module, neither traits nor types."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 11, "last_activity_date": 1481980275, "creation_date": 1481980275, "answer_id": 41198919, "question_id": 41198871, "link": "https://stackoverflow.com/questions/41198871/why-isnt-use-stdio-enough-here/41198919#41198919", "title": "Why isn&#39;t `use std::io` enough here?", "body": "<blockquote>\n  <p>What does <code>use std::io;</code> actually do then?</p>\n</blockquote>\n\n<p>It does what every use-statement does: makes the last part of the used path directly available (pulling it into the current namespace). That means that you can write <code>io</code> and the compiler knows that you mean <code>std::io</code>. </p>\n\n<blockquote>\n  <p>How do I pull all names defined in <code>std::io</code>?</p>\n</blockquote>\n\n<p>With <code>use std::io::*;</code>. This is commonly referred to as <em>glob-import</em>.</p>\n\n<blockquote>\n  <p>Also, would it be a bad style?</p>\n</blockquote>\n\n<p>Yes, it would. Usually you should avoid glob-imports. They can be handy for certain situations, but cause a lot of trouble on most cases. For example, there is also the trait <code>std::fmt::Write</code>... so importing everything from <code>fmt</code> and <code>io</code> would possibly result in name-clashes. Rust values explicitness over implicitness, so rather avoid glob-imports.</p>\n\n<p>However, there is one type of module that is usually used with a glob-import: preludes. And in fact, there is even a <code>std::io::prelude</code> which reexports important symbols. See <a href=\"https://doc.rust-lang.org/std/io/prelude/index.html\" rel=\"noreferrer\">the documentation</a> for more information.</p>\n"}], "owner": {"reputation": 8608, "user_id": 1091116, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/15098b2b940cacd8b4d07026e01e3102?s=128&d=identicon&r=PG", "display_name": "d33tah", "link": "https://stackoverflow.com/users/1091116/d33tah"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 479, "favorite_count": 0, "answer_count": 1, "score": 4, "last_activity_date": 1481986461, "creation_date": 1481979897, "last_edit_date": 1481986461, "question_id": 41198871, "link": "https://stackoverflow.com/questions/41198871/why-isnt-use-stdio-enough-here", "title": "Why isn&#39;t `use std::io` enough here?", "body": "<p>I tried to compile the following program:</p>\n\n<pre><code>use std::io;\n\nfn main() {\n    io::stdout().write(b\"Please enter your name: \");\n    io::stdout().flush();\n}\n</code></pre>\n\n<p>Unfortunately, compiler resisted:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: no method named `write` found for type `std::io::Stdout` in the current scope\n --&gt; hello.rs:4:18\n  |\n4 |     io::stdout().write(b\"Please enter your name: \");\n  |                  ^^^^^\n  |\n  = help: items from traits can only be used if the trait is in scope; the following trait is implemented but not in scope, perhaps add a `use` for it:\n  = help: candidate #1: `use std::io::Write`\n</code></pre>\n\n<p>I found that I needed to do <code>use std::io::{self, Write};</code>. What does <code>use std::io;</code> actually do then and how do (if possible) I pull all names defined in <code>std::io</code>? Also, would it be a bad style?</p>\n"}, {"tags": ["rust", "mutex"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1481967568, "post_id": 41197088, "comment_id": 69593982, "body": "Could you provide an <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>, please? That would help a lot!"}, {"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1481968156, "post_id": 41197088, "comment_id": 69594144, "body": "@LukasKalbertodt I have already been doing it :)"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1481968677, "post_id": 41197088, "comment_id": 69594284, "body": "Thanks a lot! I edited your answer a bit still, I hope you don&#39;t mind. I think in this form it&#39;s easier to answer."}], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 6, "last_activity_date": 1481969584, "creation_date": 1481969584, "answer_id": 41197504, "question_id": 41197088, "link": "https://stackoverflow.com/questions/41197088/how-to-avoid-mutex-borrowing-problems-when-using-its-guard/41197504#41197504", "title": "How to avoid mutex borrowing problems when using it&#39;s guard", "body": "<p>The closure needs a mutable reference to the <code>self.map</code> in order to insert something into it. But closure capturing works with whole bindings only. This means, that if you say <code>self.map</code>, the closure attempts to capture <code>self</code>, not <code>self.map</code>. And <code>self</code> can't be mutably borrowed/captured, because parts of <code>self</code> are already immutably borrowed. </p>\n\n<p>We can solve this closure-capturing problem by introducing a new binding for the map alone such that the closure is able to capture it (<a href=\"https://play.rust-lang.org/?gist=9f93ba3b9404f845952028d5d37116a5&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Playground</a>):</p>\n\n<pre><code>let mm = &amp;mut self.map;\nlet mut lambda = |text: String| {\n    let _ = mm.insert(\"hello\".to_owned(), text);\n};\nlambda(\"dd\".to_owned());\n</code></pre>\n\n<hr>\n\n<p><strong>However</strong>, there is something you overlooked: since <code>synchronized_call()</code> accepts <code>&amp;mut self</code>, you don't need the mutex! Why? <em>Mutable references</em> are also called <em>exclusive references</em>, because the compiler can assure at compile time that there is only one such mutable reference at any given time. </p>\n\n<p>Therefore <strong>you statically know</strong>, that there is at most one instance of <code>synchronized_call()</code> running on one specific object at any given time, <em>if</em> the function is not recursive (calls itself). </p>\n\n<p>If you have mutable access to a mutex, you know that the mutex is unlocked. See <a href=\"https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.get_mut\" rel=\"noreferrer\">the <code>Mutex::get_mut()</code> method for more explanation</a>. Isn't that amazing?</p>\n"}, {"tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": false, "score": 4, "last_activity_date": 1482001802, "last_edit_date": 1482001802, "creation_date": 1481970072, "answer_id": 41197566, "question_id": 41197088, "link": "https://stackoverflow.com/questions/41197088/how-to-avoid-mutex-borrowing-problems-when-using-its-guard/41197566#41197566", "title": "How to avoid mutex borrowing problems when using it&#39;s guard", "body": "<p>Rust mutexes do not work the way you are trying to use them. In Rust, a mutex protects specific data relying on the borrow-checking mechanism used elsewhere in the language. As a consequence, declaring a field <code>Mutex&lt;()&gt;</code> doesn't make sense, because it is protecting read-write access to the <code>()</code> unit object that has no values to mutate.</p>\n\n<p>As Lukas explained, your <code>call_synchronized</code> as declared doesn't need to do synchronization because its signature already requests an exclusive (mutable) reference to <code>self</code>, which prevents it from being invoked from multiple threads on the same object. In other words, you need to change the <em>signature</em> of <code>call_synchronized</code> because the current one does not match the functionality it is intended to provide.</p>\n\n<p><code>call_synchronized</code> needs to accept a shared reference to <code>self</code>, which will signal to Rust that it can be called from multiple threads in the first place. Inside <code>call_synchronized</code> a call to <code>Mutex::lock</code> will simultaneously lock the mutex and provide a mutable reference to the underlying data, carefully scoped so that the lock is held for the duration of the reference:</p>\n\n<pre><code>use std::sync::Mutex;\nuse std::collections::BTreeMap;\n\npub struct A {\n    synced_map: Mutex&lt;BTreeMap&lt;String, String&gt;&gt;,\n}\n\nimpl A {\n    pub fn new() -&gt; A {\n        A {\n            synced_map: Mutex::new(BTreeMap::new()),\n        }\n    }\n}\n\nimpl A {\n    fn synchronized_call(&amp;self) {\n        let mut map = self.synced_map.lock().unwrap();\n        // omitting the lambda for brevity, but it would also work\n        // (as long as it refers to map rather than self.map)\n        map.insert(\"hello\".to_owned(), \"d\".to_owned());\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 911, "favorite_count": 1, "accepted_answer_id": 41197504, "answer_count": 2, "score": 1, "last_activity_date": 1482001802, "creation_date": 1481966141, "last_edit_date": 1481969674, "question_id": 41197088, "link": "https://stackoverflow.com/questions/41197088/how-to-avoid-mutex-borrowing-problems-when-using-its-guard", "title": "How to avoid mutex borrowing problems when using it&#39;s guard", "body": "<p>I want my method of struct to perform in a synchronized way. I wanted to do this by using <code>Mutex</code> (<a href=\"https://play.rust-lang.org/?gist=88d6bb960345670385979f25754b6412&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a>):</p>\n\n<pre><code>use std::sync::Mutex;\nuse std::collections::BTreeMap;\n\npub struct A {\n    map: BTreeMap&lt;String, String&gt;,\n    mutex: Mutex&lt;()&gt;,\n}\n\nimpl A {\n    pub fn new() -&gt; A {\n        A {\n            map: BTreeMap::new(),\n            mutex: Mutex::new(()),\n        }\n    }\n}\n\nimpl A {\n    fn synchronized_call(&amp;mut self) {\n        let mutex_guard_res = self.mutex.try_lock();\n        if mutex_guard_res.is_err() {\n            return\n        }\n        let mut _mutex_guard = mutex_guard_res.unwrap(); // safe because of check above\n        let mut lambda = |text: String| {\n            let _ = self.map.insert(\"hello\".to_owned(),\n                                    \"d\".to_owned());\n        };\n        lambda(\"dd\".to_owned());\n    }\n}    \n</code></pre>\n\n<p>Error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0500]: closure requires unique access to `self` but `self.mutex` is already borrowed\n  --&gt; &lt;anon&gt;:23:26\n   |\n18 |         let mutex_guard_res = self.mutex.try_lock();\n   |                               ---------- borrow occurs here\n...\n23 |         let mut lambda = |text: String| {\n   |                          ^^^^^^^^^^^^^^ closure construction occurs here\n24 |             if let Some(m) = self.map.get(&amp;text) {\n   |                              ---- borrow occurs due to use of `self` in closure\n...\n31 |     }\n   |     - borrow ends here\n</code></pre>\n\n<p>As I understand when we borrow anything from the struct we are unable to use other struct's fields till our borrow is finished. But how can I do method synchronization then?</p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "edited": false, "score": 7, "creation_date": 1481919891, "post_id": 41190333, "comment_id": 69583669, "body": "<a href=\"https://doc.rust-lang.org/nomicon/lifetime-mismatch.html\" rel=\"nofollow noreferrer\">Limits of Lifetimes</a>. This is exactly the same case."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1481920605, "post_id": 41190333, "comment_id": 69583972, "body": "@Stargateur: I don&#39;t think the &#39;desugared&#39; code is meant to compile; it is just for illustration."}, {"owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "reply_to_user": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1481920704, "post_id": 41190333, "comment_id": 69584012, "body": "@Stargateur: No it does not help. It is necessary to limit the lifetime of the <code>loan</code> <a href=\"https://play.rust-lang.org/?gist=fc564b89ff4fa44ae5463d7f407e88ca&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "edited": false, "score": 0, "creation_date": 1481920725, "post_id": 41190333, "comment_id": 69584020, "body": "@aSpex: Ah yes, that does seem to be the same. But the docs don&#39;t suggest a solution or workaround?"}, {"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "reply_to_user": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "edited": false, "score": 1, "creation_date": 1481920862, "post_id": 41190333, "comment_id": 69584077, "body": "Oh indeed &quot;This program is clearly correct according to the reference semantics we actually care about, but the lifetime system is too coarse-grained to handle that.&quot;. So the only solution is to use a independent scope. @aSpex You should post an answer."}, {"owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "edited": false, "score": 0, "creation_date": 1481922906, "post_id": 41190333, "comment_id": 69584807, "body": "I&#39;m not good at English. So if someone wants to post an answer please feel free"}], "answers": [{"comments": [{"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 1, "creation_date": 1481968265, "post_id": 41194414, "comment_id": 69594172, "body": "Thanks, so is there a solution or workaround? Will non-lexical lifetimes fix it?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 3, "creation_date": 1481969874, "post_id": 41194414, "comment_id": 69594591, "body": "I don&#39;t think there&#39;s a workaround other than splitting the mutation into a separate method call. It&#39;s not a lexical lifetime thing; the <code>&amp;i32</code> is borrowed <i>from</i> <code>&amp;mut self</code> so they&#39;re fundamentally tied together."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "reply_to_user": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 2, "creation_date": 1534198650, "post_id": 41194414, "comment_id": 90616748, "body": "@Timmmm the OP example works as-is with NLL enabled."}, {"owner": {"reputation": 28156, "user_id": 1026, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/ea331e778d54effc15b5fbc694bc8232?s=128&d=identicon&r=PG", "display_name": "Nickolay", "link": "https://stackoverflow.com/users/1026/nickolay"}, "edited": false, "score": 2, "creation_date": 1557532535, "post_id": 41194414, "comment_id": 98810090, "body": "<i>&quot;example works as-is with NLL enabled&quot;</i> only because the <code>aref</code> is unused. If you use it, like <code>println!(&quot;{} {}&quot;, aref, dat.get_b());</code> then NLL won&#39;t be of any help, as @ChrisEmerson explained."}, {"owner": {"reputation": 778, "user_id": 1391648, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0ba57886380485febe3117271f21b582?s=128&d=identicon&r=PG", "display_name": "hddh", "link": "https://stackoverflow.com/users/1391648/hddh"}, "edited": false, "score": 0, "creation_date": 1600950827, "post_id": 41194414, "comment_id": 113255180, "body": "Is there a reason why rust couldn&#39;t be extended to allow this, or even why it would be difficult to allow this. For example, why wouldn&#39;t rust be able to &quot;demote&quot; the mutable borrow of self to an immutable borrow of self when returned. That way, it would work (since you can have multiple immutable borrows of the same thing)."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 5, "last_activity_date": 1481936670, "creation_date": 1481936670, "answer_id": 41194414, "question_id": 41190333, "link": "https://stackoverflow.com/questions/41190333/why-doesnt-a-mutable-borrow-of-self-change-to-immutable/41194414#41194414", "title": "Why doesn&#39;t a mutable borrow of self change to immutable?", "body": "<p>Lifetimes are separate from whether a reference is mutable or not.  Working through the code:</p>\n\n<pre><code>fn reference_to_a(&amp;mut self) -&gt; &amp;i32\n</code></pre>\n\n<p>Although the lifetimes have been elided, this is equivalent to:</p>\n\n<pre><code>fn reference_to_a&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a i32\n</code></pre>\n\n<p>i.e. the input and output lifetimes are the same.  That's the only way to assign lifetimes to a function like this (unless it returned an <code>&amp;'static</code> reference to global data), since you can't make up the output lifetime from nothing.</p>\n\n<p>That means that if you keep the return value alive by saving it in a variable, you're keeping the <code>&amp;mut self</code> alive too.</p>\n\n<p>Another way of thinking about it is that the <code>&amp;i32</code> is a sub-borrow of <code>&amp;mut self</code>, so is only valid until that expires.</p>\n\n<p>As @aSpex points out, this is <a href=\"https://doc.rust-lang.org/nomicon/lifetime-mismatch.html\" rel=\"noreferrer\">covered in the nomicon</a>.</p>\n"}, {"tags": [], "owner": {"reputation": 28156, "user_id": 1026, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/ea331e778d54effc15b5fbc694bc8232?s=128&d=identicon&r=PG", "display_name": "Nickolay", "link": "https://stackoverflow.com/users/1026/nickolay"}, "is_accepted": false, "score": 1, "last_activity_date": 1557598141, "creation_date": 1557598141, "answer_id": 56093031, "question_id": 41190333, "link": "https://stackoverflow.com/questions/41190333/why-doesnt-a-mutable-borrow-of-self-change-to-immutable/56093031#56093031", "title": "Why doesn&#39;t a mutable borrow of self change to immutable?", "body": "<p><em><strong>Why is this an error:</strong></em> While a more precise explanation was already given by @Chris some 2.5 years ago, you can read <code>fn reference_to_a(&amp;mut self) -&gt; &amp;i32</code> as a declaration that:</p>\n\n<blockquote>\n  <p>\u201cI want to exclusively borrow <code>self</code>, then return a shared/immutable reference which lives as long as the original exclusive borrow\u201d <sub><em>(<a href=\"https://users.rust-lang.org/t/return-immutable-reference-taking-mutable-reference-to-self/16970/7\" rel=\"nofollow noreferrer\">source</a>)</em></sub></p>\n</blockquote>\n\n<p>Apparently <a href=\"https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886/33\" rel=\"nofollow noreferrer\">it can even prevent me from shooting myself in the foot</a>.</p>\n\n<p><em><strong>Is the borrow checker just not clever enough yet? Is this planned?</strong></em></p>\n\n<p>There's still no way to express \"I want to exclusively borrow self for the duration of the call, and return a shared reference with a <em>separate lifetime</em>\". It is <a href=\"https://doc.rust-lang.org/nomicon/lifetime-mismatch.html\" rel=\"nofollow noreferrer\">mentioned in the nomicon</a> as @aSpex pointed out, and is listed among the <a href=\"https://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5#3b78\" rel=\"nofollow noreferrer\">Things Rust doesn\u2019t let you do</a> as of late 2018.</p>\n\n<p>I couldn't find specific plans to tackle this, as previously <a href=\"https://internals.rust-lang.org/t/relaxing-the-borrow-checker-for-fn-mut-self-t/3256/21\" rel=\"nofollow noreferrer\">other borrow checker improvements were deemed higher priority</a>. The idea about allowing separate read/write \"lifetime roles\" (<code>Ref2&lt;'r, 'w&gt;</code>) was <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2094-nll.md#different-lifetime-roles\" rel=\"nofollow noreferrer\">mentioned in the NLL RFC</a>, but no-one has made it into an RFC of its own, as far as I can see.</p>\n\n<p><em><strong>Is there a way around it?</strong></em> Not really, but depending on the reason you needed this in the first place, other ways of structuring the code may be appropriate:</p>\n\n<ul>\n<li>You can return a copy/clone instead of the reference</li>\n<li>Sometimes you can split a <code>fn(&amp;mut self) -&gt; &amp;T</code> into two, one taking <code>&amp;mut self</code> and another returning <code>&amp;T</code>, <a href=\"https://stackoverflow.com/questions/41190333/mutable-borrow-of-self-doesnt-change-to-immutable#comment69594591_41194414\">as suggested by @Chris here</a></li>\n<li>As is often the case in Rust, rearranging your structs <a href=\"https://kyren.github.io/rustconf_2018_slides/index.html\" rel=\"nofollow noreferrer\">to be \"data-oriented\" rather than \"object-oriented\"</a> can help</li>\n<li>You can return a shared reference from the method: <code>fn(&amp;mut self) -&gt; (&amp;Self, &amp;T)</code> (<a href=\"https://stackoverflow.com/a/38080934/1026\">from this answer</a>)</li>\n<li>You can make the fn take a shared <code>&amp;self</code> reference and use <a href=\"https://doc.rust-lang.org/book/ch15-05-interior-mutability.html\" rel=\"nofollow noreferrer\">interior mutability</a> (i.e. define the parts of <code>Self</code> that need to be mutated as <code>Cell&lt;T&gt;</code> or <code>RefCell&lt;T&gt;</code>). This may feel like cheating, but it's actually appropriate, e.g. when the reason you need mutability as an <a href=\"https://doc.rust-lang.org/std/cell/#implementation-details-of-logically-immutable-methods\" rel=\"nofollow noreferrer\">implementation detail of a logically-immutable method</a>. After all we're making a method take a <code>&amp;mut self</code> <a href=\"https://users.rust-lang.org/t/return-immutable-reference-taking-mutable-reference-to-self/16970/10\" rel=\"nofollow noreferrer\">not because it mutates parts of <code>self</code>, but</a> to <a href=\"https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/\" rel=\"nofollow noreferrer\">make it known to the caller so that it's possible to reason about which values can change in a complex program</a>.</li>\n</ul>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 747, "favorite_count": 3, "answer_count": 2, "score": 12, "last_activity_date": 1589994996, "creation_date": 1481912774, "last_edit_date": 1589994996, "question_id": 41190333, "link": "https://stackoverflow.com/questions/41190333/why-doesnt-a-mutable-borrow-of-self-change-to-immutable", "title": "Why doesn&#39;t a mutable borrow of self change to immutable?", "body": "<p>This code fails the dreaded borrow checker (<a href=\"https://play.rust-lang.org/?gist=81b5445c6ddaa5b089ce27a751e5b0a3&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">playground</a>):</p>\n\n<pre><code>struct Data {\n    a: i32,\n    b: i32,\n    c: i32,\n}\n\nimpl Data {\n    fn reference_to_a(&amp;mut self) -&gt; &amp;i32 {\n        self.c = 1;\n        &amp;self.a\n    }\n    fn get_b(&amp;self) -&gt; i32 {\n        self.b\n    }\n}\n\nfn main() {\n    let mut dat = Data{ a: 1, b: 2, c: 3 };\n    let aref = dat.reference_to_a();\n    println!(\"{}\", dat.get_b());\n}\n</code></pre>\n\n<p>Since non-lexical lifetimes were implemented, this is required to trigger the error:</p>\n\n<pre><code>fn main() {\n    let mut dat = Data { a: 1, b: 2, c: 3 };\n    let aref = dat.reference_to_a();\n    let b = dat.get_b();\n    println!(\"{:?}, {}\", aref, b);\n}\n</code></pre>\n\n<p>Error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `dat` as immutable because it is also borrowed as mutable\n  --&gt; &lt;anon&gt;:19:20\n   |\n18 |     let aref = dat.reference_to_a();\n   |                --- mutable borrow occurs here\n19 |     println!(\"{}\", dat.get_b());\n   |                    ^^^ immutable borrow occurs here\n20 | }\n   | - mutable borrow ends here\n</code></pre>\n\n<p>Why is this? I would have thought that the mutable borrow of <code>dat</code> is converted into an immutable one when <code>reference_to_a()</code> returns, because that function only returns an immutable reference. Is the borrow checker just not clever enough yet? Is this planned? Is there a way around it?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1481922938, "post_id": 41191746, "comment_id": 69584819, "body": "I think glob imports are used far too often for this text to be correct."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 2, "creation_date": 1481923658, "post_id": 41191746, "comment_id": 69585110, "body": "@bluss they may be used often, but I feel they are used in specific narrow conditions - importing a module for unit tests (we only want the most recent ancestor), importing a prelude (we create a specific container that means &quot;all of these should be imported&quot;), or all the variations of an enum (which is usually constrained to a function&#39;s context). Personally, I&#39;m always a bit wary when encountering a glob import."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 5, "last_activity_date": 1482446494, "last_edit_date": 1495540423, "creation_date": 1481918834, "answer_id": 41191746, "question_id": 41190114, "link": "https://stackoverflow.com/questions/41190114/how-to-import-everything-from-the-crate-root/41191746#41191746", "title": "How to import everything from the crate root?", "body": "<p>As of Rust 1.14, <strong><code>use *;</code> and <code>use ::*;</code> now work as intended</strong> (importing everything from the crate root)<strong>!</strong></p>\n\n<hr>\n\n<p>Useful links:</p>\n\n<ul>\n<li><a href=\"https://github.com/rust-lang/rust/pull/37367\" rel=\"nofollow noreferrer\">PR that introduced the syntax</a></li>\n<li><a href=\"https://github.com/rust-lang/rust/issues/31484\" rel=\"nofollow noreferrer\">Old issue about the lack of said syntax</a></li>\n<li><a href=\"https://stackoverflow.com/revisions/41191746/1\">My old answer in the edit log</a></li>\n</ul>\n"}], "owner": {"reputation": 2734, "user_id": 973730, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/ed204943500512835fc90fb9ac790367?s=128&d=identicon&r=PG", "display_name": "Simon", "link": "https://stackoverflow.com/users/973730/simon"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1996, "favorite_count": 0, "accepted_answer_id": 41191746, "answer_count": 1, "score": 4, "last_activity_date": 1482446494, "creation_date": 1481911878, "last_edit_date": 1481912369, "question_id": 41190114, "link": "https://stackoverflow.com/questions/41190114/how-to-import-everything-from-the-crate-root", "title": "How to import everything from the crate root?", "body": "<p>To import symbols from a module you either need to enumerate them or use a wildcard to import everything. That is, I can use either <code>use module::{SomeSymbol, SomeOtherSymbol};</code> or <code>use module::*;</code></p>\n\n<p>However, when importing from the top-level module, the crate root, wildcards don't work. I can use either <code>use {SomeSymbol, SomeOtherSymbol};</code> or <code>use ::{SomeSymbol, SomeOtherSymbol}};</code> but neither <code>use *;</code> nor <code>use ::*;</code> work.</p>\n\n<p>Why doesn't it work and how to import everything from the crate root?</p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1481901657, "post_id": 41187296, "comment_id": 69574719, "body": "You can find the details of the borrow-checking process <a href=\"https://github.com/rust-lang/rust/tree/master/src/librustc_borrowck/borrowck\" rel=\"nofollow noreferrer\">here</a>."}, {"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 1, "creation_date": 1481902246, "post_id": 41187296, "comment_id": 69575059, "body": "There is an <a href=\"https://github.com/durka/unborrow\" rel=\"nofollow noreferrer\">unborrow macro</a> for a workaround, and a discussion on <a href=\"https://www.reddit.com/r/rust/comments/575tc7/why_does_rust_not_allow_disjoint_mutable_borrows/\" rel=\"nofollow noreferrer\">reddit</a>"}, {"owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "edited": false, "score": 1, "creation_date": 1481904980, "post_id": 41187296, "comment_id": 69576628, "body": "Take a look at this <a href=\"http://smallcultfollowing.com/babysteps/blog/2016/04/27/non-lexical-lifetimes-introduction/\" rel=\"nofollow noreferrer\">blog post</a>. It explains the issue in depth. There are follow-up posts with more information on the problem."}, {"owner": {"reputation": 1322, "user_id": 2693146, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/KTITg.jpg?s=128&g=1", "display_name": "Isiah Meadows", "link": "https://stackoverflow.com/users/2693146/isiah-meadows"}, "edited": false, "score": 1, "creation_date": 1514712983, "post_id": 41187296, "comment_id": 83053251, "body": "Related: <a href=\"https://github.com/rust-lang/rfcs/pull/2094\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/pull/2094</a>"}], "answers": [{"tags": [], "owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "is_accepted": true, "score": 30, "last_activity_date": 1606166287, "last_edit_date": 1606166287, "creation_date": 1481907409, "answer_id": 41189051, "question_id": 41187296, "link": "https://stackoverflow.com/questions/41187296/cannot-borrow-as-immutable-because-it-is-also-borrowed-as-mutable-in-function-ar/41189051#41189051", "title": "Cannot borrow as immutable because it is also borrowed as mutable in function arguments", "body": "<p>This line:</p>\n<pre><code>n.set(n.get() + 1);\n</code></pre>\n<p>is desugared into</p>\n<pre><code>Number::set(&amp;mut n, n.get() + 1);\n</code></pre>\n<p>The error message might be a bit more clear now:</p>\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `n` as immutable because it is also borrowed as mutable\n  --&gt; &lt;anon&gt;:18:25\n   |\n18 |     Number::set(&amp;mut n, n.get() + 1);\n   |                      -  ^          - mutable borrow ends here\n   |                      |  |\n   |                      |  immutable borrow occurs here\n   |                      mutable borrow occurs here\n</code></pre>\n<p>As Rust evaluates arguments left to right, that code is equivalent to this:</p>\n<pre><code>let arg1 = &amp;mut n;\nlet arg2 = n.get() + 1;\nNumber::set(arg1, arg2);\n</code></pre>\n<blockquote>\n<p>Editor's note: This code example gives an intuitive sense of the underlying problem, but isn't completely accurate. The <em>expanded</em> code still fails even with non-lexical lifetimes, but the <em>original</em> code compiles. For the full description of the problem, review <a href=\"https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src/librustc/middle/typeck/infer/region_inference/doc.rs#L154-L262\" rel=\"nofollow noreferrer\">the comments in the original implementation of the borrow checker</a></p>\n</blockquote>\n<p>It should now be obvious what is wrong. Swapping those first two lines fixes this, but Rust does not do that kind of control-flow analysis.</p>\n<p>This was first created as <a href=\"https://github.com/rust-lang/rust/issues/6268\" rel=\"nofollow noreferrer\">bug #6268</a>, now it is integrated into <a href=\"https://rust-lang.github.io/rfcs/2094-nll.html\" rel=\"nofollow noreferrer\">RFC 2094</a>, <a href=\"https://stackoverflow.com/q/50251487/155423\">non-lexical-lifetimes</a>. If you use Rust 1.36 or newer, NLL is enabled automatically and <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=67a639e672349bd870a9cd4e33b255fc\" rel=\"nofollow noreferrer\">your code will now compile without an error</a>.</p>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/60686259/155423\">Why is a mutable borrow in an argument disallowed for a mutable method call?</a></li>\n</ul>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4039, "favorite_count": 5, "accepted_answer_id": 41189051, "answer_count": 1, "score": 27, "last_activity_date": 1606166287, "creation_date": 1481901001, "last_edit_date": 1481902761, "question_id": 41187296, "link": "https://stackoverflow.com/questions/41187296/cannot-borrow-as-immutable-because-it-is-also-borrowed-as-mutable-in-function-ar", "title": "Cannot borrow as immutable because it is also borrowed as mutable in function arguments", "body": "<p>What is going on here (<a href=\"https://play.rust-lang.org/?code=%0Astruct%20Number%20%7B%0A%20%20%20%20num%3A%20i32%0A%7D%0A%0Aimpl%20Number%20%7B%0A%20%20%20%20fn%20set(%26mut%20self%2C%20new_num%3A%20i32)%20%7B%0A%20%20%20%20%20%20%20%20self.num%20%3D%20new_num%3B%0A%20%20%20%20%7D%0A%20%20%20%20fn%20get(%26self)%20-%3E%20i32%20%7B%0A%20%20%20%20%20%20%20%20self.num%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20n%20%3D%20Number%7B%20num%3A%200%20%7D%3B%0A%20%20%20%20n.set(n.get()%20%2B%201)%3B%0A%7D%0A&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">playground</a>)?</p>\n\n<pre><code>struct Number {\n    num: i32\n}\n\nimpl Number {\n    fn set(&amp;mut self, new_num: i32) {\n        self.num = new_num;\n    }\n    fn get(&amp;self) -&gt; i32 {\n        self.num\n    }\n}\n\nfn main() {\n    let mut n = Number{ num: 0 };\n    n.set(n.get() + 1);\n}\n</code></pre>\n\n<p>Gives this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `n` as immutable because it is also borrowed as mutable\n  --&gt; &lt;anon&gt;:17:11\n   |\n17 |     n.set(n.get() + 1);\n   |     -     ^          - mutable borrow ends here\n   |     |     |\n   |     |     immutable borrow occurs here\n   |     mutable borrow occurs here\n</code></pre>\n\n<p>However if you simply change the code to this it works:</p>\n\n<pre><code>fn main() {\n    let mut n = Number{ num: 0 };\n    let tmp = n.get() + 1;\n    n.set(tmp);\n}\n</code></pre>\n\n<p>To me those look exactly equivalent - I mean, I would expect the former to be transformed to the latter during compilation. Doesn't Rust evaluate all function parameters before evaluating the next-level-up function call?</p>\n"}, {"tags": ["rust", "rust-cargo", "semantic-versioning"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1481893813, "post_id": 41185023, "comment_id": 69569962, "body": "By &quot;changing the set of our dependencies&quot; do you mean adding/removing dependencies, changing the version of a dependency, or any of these? (personally I&#39;d rule that using a glob import is bad taste <i>except</i> for prelude modules, and therefore only prelude modules should worry about adding symbols)."}, {"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 1, "creation_date": 1481894600, "post_id": 41185023, "comment_id": 69570393, "body": "Only when your public API is not retro compatible."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1481894618, "post_id": 41185023, "comment_id": 69570405, "body": "I don&#39;t think you would consider bumping the version if the code fails to compile (like in your example); semver doesn&#39;t seem applicable here."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1481894859, "post_id": 41185023, "comment_id": 69570580, "body": "@MatthieuM. &quot;any of theses&quot; -&gt; yes."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1481896078, "post_id": 41185023, "comment_id": 69571299, "body": "@LukasKalbertodt: I am surprised changing the version of a dependency could break a downstream crate. I thought the very purpose of Rust&#39;s name mangling and static compilation was to be able have multiple instances of the same downstream crate in the final binary. Did I miss something?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1481898091, "post_id": 41185023, "comment_id": 69572470, "body": "@MatthieuM. Having multiple versions (at least if they are exposed) can cause issues: <a href=\"http://stackoverflow.com/questions/31130408/what-does-expected-struct-foo-found-a-different-struct-foo-mean/31130554\" title=\"what does expected struct foo found a different struct foo mean\">stackoverflow.com/questions/31130408/&hellip;</a>"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1481900032, "post_id": 41185023, "comment_id": 69573720, "body": "@ChrisEmerson: Yes, sure. However isn&#39;t that accounted for already? I mean, if you expose types from another crate, then the part of the crate&#39;s API you expose becomes your API. Which is why as much as possible you should of course avoid exposing external types :)"}, {"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 0, "creation_date": 1481901364, "post_id": 41185023, "comment_id": 69574532, "body": "Example: mixing two versions of <code>openssl-sys</code> <a href=\"http://stackoverflow.com/q/40824435/33499\">is not possible</a>. So if a crate upgrades using a newer version of <code>openssl-sys</code>, it is no longer possible to use other crates which still use the previous version of <code>openssl-sys</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 0, "creation_date": 1481902601, "post_id": 41185023, "comment_id": 69575281, "body": "@wimh: Ah! Any crate exporting non-mangled symbols can only be unique indeed, because to be able to import multiple crates Rust uses mangling to prevent symbol collisions. This may also transitively apply to any crate pulling in a C library (thus sys crates), since C&#39;s symbols are not mangled."}], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 11, "last_activity_date": 1598207593, "last_edit_date": 1598207593, "creation_date": 1481950254, "answer_id": 41195476, "question_id": 41185023, "link": "https://stackoverflow.com/questions/41185023/what-exactly-is-considered-a-breaking-change-to-a-library-crate/41195476#41195476", "title": "What exactly is considered a breaking change to a library crate?", "body": "<p>There is a Rust RFC on this subject: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md\" rel=\"nofollow noreferrer\">RFC 1105: API Evolution</a>. It's applicable to any Rust library project, and it covers all kinds of changes (not just breaking changes) and how they impact semantic versioning. I'll try to summarize the key points from the RFC in order to not make this answer a link-only answer. :)</p>\n<p>The RFC acknowledges that pretty much any change to a library can cause a client to suddenly stop compiling. As such, it defines a set of <em>major changes</em>, which require a bump of the major version number, and a set of <em>minor changes</em>, which require a bump of the minor version number; not all breaking changes are <em>major changes</em>.</p>\n<p>The key attribute of a minor change is that there must be a way that clients can avoid the breakage in advance by altering slightly their source code (e.g. change a glob import to a non-glob import, disambiguate an ambiguous call with UFCS, etc.) in such a way that the code is compatible with the version prior to the change and with the version that includes the change (assuming that it's a minor release). A minor change must also not force downstream crates to make major breaking changes in order to resolve the breakage.</p>\n<hr />\n<p>The major changes defined in the RFC (as of <a href=\"https://github.com/rust-lang/rfcs/blob/721f2d74cc4daf76f3e49d58fbc6ded55d545e45/text/1105-api-evolution.md\" rel=\"nofollow noreferrer\">commit <code>721f2d74</code></a>) are:</p>\n<ul>\n<li>Switching your project from being compatible with the stable compiler to only being compatible with the nightly compiler.</li>\n<li>Renaming, moving or removing any public <a href=\"https://doc.rust-lang.org/reference/items.html\" rel=\"nofollow noreferrer\">item</a> in a module.</li>\n<li>Adding a private field to a struct when all current fields are public.</li>\n<li>Adding a public field to a struct that has no private fields.</li>\n<li>Adding new variants to an enum.</li>\n<li>Adding new fields to an enum variant.</li>\n<li>Adding a non-defaulted item to a trait.</li>\n<li>Any non-trivial change to the signature of a trait item.</li>\n<li>Implementing a <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\" rel=\"nofollow noreferrer\">fundamental</a> trait on an existing type.</li>\n<li>Tightening bounds on an existing type parameter.</li>\n<li>Adding or removing arguments to a function.</li>\n<li>Any other breaking change that is not listed as a minor change in the RFC.</li>\n</ul>\n<p>The minor changes defined in the RFC (as of <a href=\"https://github.com/rust-lang/rfcs/blob/721f2d74cc4daf76f3e49d58fbc6ded55d545e45/text/1105-api-evolution.md\" rel=\"nofollow noreferrer\">commit <code>721f2d74</code></a>, breaking unless specified) are:</p>\n<ul>\n<li>Altering the use of Cargo features on a crate.</li>\n<li>Adding new public items in a module.</li>\n<li>Adding or removing private fields in a struct when at least one already exists (before and after the change) <em>[not breaking]</em>.</li>\n<li>Turning a tuple struct with all private fields (with at least one field) into a normal struct, or vice versa.</li>\n<li>Adding a defaulted item to a trait.</li>\n<li>Adding a defaulted type parameter to a trait <em>[not breaking]</em>.</li>\n<li>Implementing any non-fundamental trait on an existing type.</li>\n<li>Adding any item to an inherent <code>impl</code>.</li>\n<li>Changing an undocumented behavior of a function.</li>\n<li>Loosening bounds on an existing type parameter <em>[not breaking]</em>.</li>\n<li>Adding defaulted type parameters to a type or trait <em>[not breaking]</em>.</li>\n<li>Generalizing an existing struct or enum field by replacing its type by a new type parameter that defaults to the previous type <em>[breaking until <a href=\"https://github.com/rust-lang/rust/issues/27336\" rel=\"nofollow noreferrer\">issue 27336</a> is fixed]</em>.</li>\n<li>Introducing a new type parameter to an existing function.</li>\n<li>Generalizing a parameter or the return type of an existing function by replacing the type by a new type parameter that can be instantiated to the previous type.</li>\n<li>Introducing new lint warnings/errors.</li>\n</ul>\n<p>See <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md\" rel=\"nofollow noreferrer\">the RFC</a> for explanations and examples.</p>\n"}], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1781, "favorite_count": 4, "accepted_answer_id": 41195476, "answer_count": 1, "score": 12, "last_activity_date": 1598207593, "creation_date": 1481893308, "last_edit_date": 1481896003, "question_id": 41185023, "link": "https://stackoverflow.com/questions/41185023/what-exactly-is-considered-a-breaking-change-to-a-library-crate", "title": "What exactly is considered a breaking change to a library crate?", "body": "<p>Rust crates use <a href=\"http://semver.org/\" rel=\"noreferrer\">Semantic Versioning</a>. As a consequence, each release with a breaking change should result in a major version bump. A <em>breaking change</em> is commonly considered something that may break downstream crates (code the depends on the library in question).</p>\n\n<p>However, in Rust a whole lot has the potential of breaking downstream crates. For example, changing (including merely <em>adding to</em>) the set of public symbols is possibly a breaking change, because downstream crates can use glob-imports (<code>use foo::*;</code>) to pull symbols of our library into their namespace. Thus, adding symbols can break dependent crates as well; see <a href=\"https://play.rust-lang.org/?gist=991c179b87404188ff8cc18c75f66d4d&amp;version=nightly&amp;backtrace=0\" rel=\"noreferrer\">this example</a>. </p>\n\n<p>Similarly, changing (adding or changing the version) the set of <em>our</em> dependencies can break downstream builds. You can also imagine that the downstream crate relies on a specific size of one of our public types. This is rarely, if at all, useful; I just want to show: everything could be a breaking change, if only the downstream crate tries hard enough. </p>\n\n<p>Is there any guideline about this? <strong>What exactly is considered a breaking change and what not (because it's considered \"the user's fault\")?</strong></p>\n"}, {"tags": ["string", "vector", "reference", "rust", "ownership"], "answers": [{"comments": [{"owner": {"reputation": 623, "user_id": 1569573, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/38b8d6aa83833a196b04a61d0ccd6dcb?s=128&d=identicon&r=PG", "display_name": "Don Rowe", "link": "https://stackoverflow.com/users/1569573/don-rowe"}, "edited": false, "score": 0, "creation_date": 1481875838, "post_id": 41179800, "comment_id": 69559647, "body": "Thanks, Matthieu. For my case right now, I think I&#39;ll go with <code>&amp;[String]</code> since I imagine allocating a new <code>Vec&lt;&amp;str&gt;</code> incurs extra work."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 623, "user_id": 1569573, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/38b8d6aa83833a196b04a61d0ccd6dcb?s=128&d=identicon&r=PG", "display_name": "Don Rowe", "link": "https://stackoverflow.com/users/1569573/don-rowe"}, "edited": false, "score": 2, "creation_date": 1481876165, "post_id": 41179800, "comment_id": 69559780, "body": "@DonRowe: It incurs an extra allocation (O(1) but potentially expensive) + conversion (O(n))."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 13, "last_activity_date": 1586177699, "last_edit_date": 1586177699, "creation_date": 1481875438, "answer_id": 41179800, "question_id": 41179659, "link": "https://stackoverflow.com/questions/41179659/convert-vecstring-into-a-slice-of-str-in-rust/41179800#41179800", "title": "Convert Vec&lt;String&gt; into a slice of &amp;str in Rust?", "body": "<p>This is actually impossible without memory allocation<sup>1</sup>.</p>\n\n<p>Going from <code>String</code> to <code>&amp;str</code> is not just viewing the bits in a different light; <code>String</code> and <code>&amp;str</code> have a different memory layout, and thus going from one to the other requires creating a new object. The same applies to <code>Vec</code> and <code>&amp;[]</code></p>\n\n<p>Therefore, whilst you can go from <code>Vec&lt;T&gt;</code> to <code>&amp;[T]</code>, and thus from <code>Vec&lt;String&gt;</code> to <code>&amp;[String]</code>, you cannot directly go from <code>Vec&lt;String&gt;</code> to <code>&amp;[&amp;str]</code>. Your choices are:</p>\n\n<ul>\n<li>either accept <code>&amp;[String]</code></li>\n<li>allocate a new <code>Vec&lt;&amp;str&gt;</code> referencing the first <code>Vec</code>, and convert <em>that</em> into a <code>&amp;[&amp;str]</code></li>\n</ul>\n\n<p>As an example of the allocation:</p>\n\n<pre><code>fn usage(_: &amp;[&amp;str]) {}\n\nfn main() {\n    let owned = vec![String::new()];\n\n    let half_owned: Vec&lt;_&gt; = owned.iter().map(String::as_str).collect();\n\n    usage(&amp;half_owned);\n}\n</code></pre>\n\n<hr>\n\n<p><sup>1</sup> <em>The conversion required is impossible, however using generics and the <code>AsRef&lt;str&gt;</code> bound as shown in <a href=\"https://stackoverflow.com/users/5138648/aspex\">@aSpex</a>'s answer you get a slightly more verbose function declaration with the flexibility you were asking for.</em></p>\n"}, {"comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1481885970, "post_id": 41180422, "comment_id": 69565360, "body": "I think this is the answer the OP was looking for, as it allows using the slice without an unnecessary allocation. This approach is even more useful when accepting a slice of <code>AsRef&lt;Path&gt;</code> - you want the function to accept all of <code>&amp;[&amp;str]</code>, <code>&amp;[String]</code>, <code>&amp;[Path]</code>, and <code>&amp;[PathBuf]</code>, without allocating new memory."}, {"owner": {"reputation": 8074, "user_id": 553488, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/c243aff4eab563f6d2c1cf6c3407456b?s=128&d=identicon&r=PG", "display_name": "klefevre", "link": "https://stackoverflow.com/users/553488/klefevre"}, "edited": false, "score": 0, "creation_date": 1548865658, "post_id": 41180422, "comment_id": 95699476, "body": "One sad thing is if you&#39;re trying to take a <code>Option&lt;&amp;[T]&gt;</code> you can&#39;t just pass a <code>None</code> without specifying a concret type"}], "tags": [], "owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "is_accepted": true, "score": 41, "last_activity_date": 1481897449, "last_edit_date": 1481897449, "creation_date": 1481878165, "answer_id": 41180422, "question_id": 41179659, "link": "https://stackoverflow.com/questions/41179659/convert-vecstring-into-a-slice-of-str-in-rust/41180422#41180422", "title": "Convert Vec&lt;String&gt; into a slice of &amp;str in Rust?", "body": "<p>You can create a function that accepts both <code>&amp;[String]</code> and <code>&amp;[&amp;str]</code> using the <a href=\"https://doc.rust-lang.org/std/convert/trait.AsRef.html\" rel=\"noreferrer\"><code>AsRef</code> trait</a>:</p>\n\n<pre><code>fn test&lt;T: AsRef&lt;str&gt;&gt;(inp: &amp;[T]) {\n    for x in inp { print!(\"{} \", x.as_ref()) }\n    println!(\"\");\n}\n\nfn main() {\n    let vref = vec![\"Hello\", \"world!\"];\n    let vown = vec![\"May the Force\".to_owned(), \"be with you.\".to_owned()];\n    test(&amp;vref);\n    test(&amp;vown);\n}\n</code></pre>\n"}], "owner": {"reputation": 623, "user_id": 1569573, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/38b8d6aa83833a196b04a61d0ccd6dcb?s=128&d=identicon&r=PG", "display_name": "Don Rowe", "link": "https://stackoverflow.com/users/1569573/don-rowe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 7466, "favorite_count": 8, "accepted_answer_id": 41180422, "answer_count": 2, "score": 35, "last_activity_date": 1586177699, "creation_date": 1481874846, "last_edit_date": 1507730761, "question_id": 41179659, "link": "https://stackoverflow.com/questions/41179659/convert-vecstring-into-a-slice-of-str-in-rust", "title": "Convert Vec&lt;String&gt; into a slice of &amp;str in Rust?", "body": "<p>Per <a href=\"https://doc.rust-lang.org/0.12.0/guide-strings.html#string-vs.-&amp;str\" rel=\"noreferrer\">Steve Klabnik's writeup in the pre-Rust 1.0 documentation on the difference between <code>String</code> and <code>&amp;str</code></a>, in Rust you should use <code>&amp;str</code> unless you really need to have ownership over a <code>String</code>. Similarly, it's recommended to use references to slices (<code>&amp;[]</code>) instead of <code>Vec</code>s unless you really need ownership over the <code>Vec</code>.</p>\n\n<p>I have a <code>Vec&lt;String&gt;</code> and I want to write a function that uses this sequence of strings and it doesn't need ownership over the <code>Vec</code> or <code>String</code> instances, should that function take <code>&amp;[&amp;str]</code>? If so, what's the best way to reference the <code>Vec&lt;String&gt;</code> into <code>&amp;[&amp;str]</code>? Or, is this coercion overkill?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 819, "user_id": 2353008, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/pb5nr.jpg?s=128&g=1", "display_name": "Valarauca", "link": "https://stackoverflow.com/users/2353008/valarauca"}, "edited": false, "score": 0, "creation_date": 1481856330, "post_id": 41176430, "comment_id": 69553466, "body": "Okay cool so basically I need to wrap slice and add a drop trait thanks! (I&#39;m trying to work with TLS message packets which all together and be a couple KB once combined, I&#39;d prefer not to re-allocate them thus slices since you can easily slice those up, and borrow their contents easily)."}, {"owner": {"reputation": 819, "user_id": 2353008, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/pb5nr.jpg?s=128&g=1", "display_name": "Valarauca", "link": "https://stackoverflow.com/users/2353008/valarauca"}, "edited": false, "score": 0, "creation_date": 1481859672, "post_id": 41176430, "comment_id": 69554227, "body": "Can you at least provide a code example how to borrow a <code>Box&lt;[T]&gt;</code>? <code>as_ref()</code> or <code>borrow()</code> do not allow file time assignment"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 6, "last_activity_date": 1481864426, "last_edit_date": 1481864426, "creation_date": 1481855699, "answer_id": 41176430, "question_id": 41176297, "link": "https://stackoverflow.com/questions/41176297/what-is-the-safe-way-to-convert-a-vect-to-a-t/41176430#41176430", "title": "What is the safe way to convert a Vec&lt;T&gt; to a &amp;[T]", "body": "<p>A slice (<code>&amp;'a [T]</code>) is supposed to represent a view into some array that is owned by another object (e.g. a <code>Vec&lt;T&gt;</code> or a <code>Box&lt;[T]&gt;</code>). That's why references have a lifetime parameter and <code>Vec&lt;T&gt;</code> and <code>Box&lt;[T]&gt;</code> don't.</p>\n\n<p>When a slice is \"dropped\", no memory is freed, because the slice doesn't own the memory. Therefore, your function causes the vector's storage to be leaked. You can't just \"magically assign\" a lifetime to a slice and make the compiler insert code to free the heap allocation. Just think, what would happen when you copy the slice?</p>\n\n<p>Rust will automatically coerce a vector or a boxed slice to a slice in contexts where a slice is required (except when generics are involved), so really there's no reason to go against the rules and return a slice when you should be returning a vector or a boxed slice.</p>\n\n<p>Perhaps you're writing a library and you're concerned that returning a vector exposes some implementation detail? Well, think of it this way: if you were writing the library in C, you would use raw pointers, but then you would have to write in the API documentation whether the caller is supposed to call some function (and which one) to clean up the resource or not. In Rust, we encode these instructions by using the proper return type, so that the programmer doesn't have to worry about it.</p>\n\n<blockquote>\n  <p>Can you at least provide a code example how to borrow a <code>Box&lt;[T]&gt;</code>? <code>as_ref()</code> or <code>borrow()</code> do not allow life time assignment</p>\n</blockquote>\n\n<p>The shortest way to borrow from a <code>Box&lt;[T]&gt;</code> is to write <code>&amp;x</code> or <code>&amp;*x</code> (where <code>x</code> is a <code>Box&lt;[T]&gt;</code>). <code>&amp;x</code> produces a value of type <code>&amp;Box&lt;[T]&gt;</code>, which can be coerced to <code>&amp;[T]</code> because <code>Box</code> implements the <a href=\"https://doc.rust-lang.org/stable/std/ops/trait.Deref.html\" rel=\"nofollow noreferrer\"><code>Deref</code></a> trait.</p>\n\n<p>In order to return a slice with a valid lifetime parameter from a function, you must link it to the lifetime parameter of one of the function's input parameters. If you pass a <code>Box&lt;[T]&gt;</code> by value to the function, then there's no lifetime you can link to, as Rust expects the <code>Box</code> to be dropped by the end of the function (you can prevent that from happening by calling <code>mem::forget</code>, but the compiler cannot reason about that). You could always pass the <code>Box&lt;[T]&gt;</code> by reference (i.e. <code>&amp;Box&lt;[T]&gt;</code>), but that would just introduce an unnecessary layer of indirection, so your function should just accept <code>&amp;[T]</code> instead.</p>\n"}], "owner": {"reputation": 819, "user_id": 2353008, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/pb5nr.jpg?s=128&g=1", "display_name": "Valarauca", "link": "https://stackoverflow.com/users/2353008/valarauca"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 228, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1481897345, "creation_date": 1481854488, "last_edit_date": 1481897345, "question_id": 41176297, "link": "https://stackoverflow.com/questions/41176297/what-is-the-safe-way-to-convert-a-vect-to-a-t", "title": "What is the safe way to convert a Vec&lt;T&gt; to a &amp;[T]", "body": "<p>How can I assign to a lifetime to a vector's underlying heap allocation without moving it in memory?</p>\n\n<p>The easiest way I've found to do this is</p>\n\n<pre><code>pub fn heap_slice&lt;'a, T:'a&gt;(x: Vec&lt;T&gt;) -&gt; &amp;'a [T] {\n    use std::mem::forget;\n    use std::slice::from_raw_parts;\n    x.shrink_to_fit();\n    let ptr = x.ptr();\n    let len = x.len();\n    forget(x);\n    unsafe{ from_raw_parts(ptr,len) };\n}\n</code></pre>\n\n<p>But this does call <code>unsafe</code> outside of the stdlib, which is generally frowned upon. Is there a safe way?</p>\n\n<p>I see the <code>into_boxed_slice</code> is doing roughly exact same thing. But how do I recover the <code>&amp;[T]</code> and assign it a lifetime once it is a <code>Box&lt;[T]&gt;</code>?</p>\n"}, {"tags": ["rust", "lifetime", "borrow-checker"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1481832466, "post_id": 41172403, "comment_id": 69545301, "body": "Related: <a href=\"http://stackoverflow.com/q/36645452/155423\">stackoverflow.com/q/36645452/155423</a>, <a href=\"http://stackoverflow.com/q/30488928/155423\">stackoverflow.com/q/30488928/155423</a>, <a href=\"http://stackoverflow.com/q/38797960/155423\">stackoverflow.com/q/38797960/155423</a> \u2014 for whatever reason, everyone wants to return a CSV iterator."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1481832983, "post_id": 41172403, "comment_id": 69545583, "body": "Since the iterator elements aren&#39;t borrowed, it looks like the records iterator could be remade to take a <code>R: Read</code> by value. Since <code>&amp;mut R</code> implements <code>Read where R: Read</code>, it covers both the cases."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1481833066, "post_id": 41172403, "comment_id": 69545618, "body": "@bluss Yeah, I was surprised by that. I assumed they would be string slices. Such a change would still be a breaking API change though, but not one that&#39;s terrible to adapt to."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1481832995, "last_edit_date": 1495541327, "creation_date": 1481832545, "answer_id": 41172547, "question_id": 41172403, "link": "https://stackoverflow.com/questions/41172403/can-i-use-a-mutable-reference-method-like-a-value-passing-one/41172547#41172547", "title": "Can I use a mutable reference method like a value-passing one?", "body": "<p>No, you cannot. The reason that <code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code> methods exist is because they behave differently, have different restrictions, and allow different things. </p>\n\n<p>In this case, you'd probably ultimately end up trying <a href=\"https://stackoverflow.com/q/25702909/155423\">to create an iterator that yields references to itself</a>, which isn't allowed, or <a href=\"https://stackoverflow.com/q/32300132/155423\">store a value and a reference to that value in the same struct</a>, which is also disallowed.</p>\n"}], "owner": {"reputation": 182, "user_id": 865226, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df65dfe294994d2280a742d961eb0abc?s=128&d=identicon&r=PG", "display_name": "SeanTater", "link": "https://stackoverflow.com/users/865226/seantater"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 96, "favorite_count": 0, "accepted_answer_id": 41172547, "answer_count": 1, "score": 1, "last_activity_date": 1481832995, "creation_date": 1481831973, "last_edit_date": 1481832379, "question_id": 41172403, "link": "https://stackoverflow.com/questions/41172403/can-i-use-a-mutable-reference-method-like-a-value-passing-one", "title": "Can I use a mutable reference method like a value-passing one?", "body": "<p>Can I use a mutable reference method like a value-passing one? For example, can I use</p>\n\n<pre><code>o.mth(&amp;mut self, ...)\n</code></pre>\n\n<p>as</p>\n\n<pre><code>o.mth(self, ...)\n</code></pre>\n\n<p>This would allow me to return the result without worrying about the lifetime of <code>o</code>. It might involve a <code>move</code> closure, or some kind of wrapper?</p>\n\n<p>For context, I'm trying to return a boxed iterator over CSV records using the rust-csv package but the iterator can't outlive the reader, which <a href=\"http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.records\" rel=\"nofollow noreferrer\"><code>Reader::records(&amp;'t mut self)</code></a> borrows mutably. Contrast this with <a href=\"https://doc.rust-lang.org/nightly/std/io/trait.BufRead.html#method.lines\" rel=\"nofollow noreferrer\"><code>BufRead::lines(self)</code></a>, which consumes its reader and hence can be returned without lifetime problems.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 133611, "user_id": 152602, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7f370b4bd787fc68f9f62d9c6781cb79?s=128&d=identicon&r=PG", "display_name": "Lee", "link": "https://stackoverflow.com/users/152602/lee"}, "edited": false, "score": 3, "creation_date": 1481816943, "post_id": 41168061, "comment_id": 69536668, "body": "In <code>for (i, v)</code> the <code>v</code> is shadowing the previous definition of <code>v</code> which is the vector you&#39;re trying to index. Your entire loop could probably be optimised out though, since you aren&#39;t using the result of the indexing operation anywhere."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1481842714, "post_id": 41168061, "comment_id": 69550018, "body": "Please do not add <b>answers</b> to your <b>question</b>. I&#39;ve rolled back to your original version and then applied some normal cleanup. You are welcome and encouraged to add your own answer if you believe you have something substantial to add to any existing answers. You can also add a comment to existing answers if you just want to provide a small amount of additional detail to an existing answer."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 8, "last_activity_date": 1481817195, "creation_date": 1481817195, "answer_id": 41168223, "question_id": 41168061, "link": "https://stackoverflow.com/questions/41168061/how-solve-cannot-index-a-value-of-type-usize-error/41168223#41168223", "title": "How solve &quot;cannot index a value of type `usize`&quot; error?", "body": "<p>You, pal, are mightily confused here.</p>\n\n<pre><code>fn main() {\n    let v = vec![1; 1_000_000];\n</code></pre>\n\n<p>This <code>v</code> has type <code>Vec&lt;i32&gt;</code>.</p>\n\n<pre><code>for (i, v) in (0..v.len()).enumerate() {\n    v[i]\n}\n</code></pre>\n\n<p>You are iterating over a range of indexes, from <code>0</code> to <code>v.len()</code>, and using <code>enumerate</code> to generate indices as you go:</p>\n\n<ul>\n<li>This <code>v</code> has type <code>usize</code></li>\n<li>In the loop, <code>v == i</code>, always</li>\n</ul>\n\n<p>So... indeed, the compiler is correct, you cannot use <code>[]</code> on <code>usize</code>.</p>\n\n<hr>\n\n<p>The program \"fixed\":</p>\n\n<pre><code>extern crate time;\n\nfn main() {\n    let v = vec![1; 1_000_000];\n\n    let before_rec1 = time::precise_time_ns();\n\n    for i in 0..v.len() {\n        v[i]\n    }\n\n    let after_rec1 = time::precise_time_ns();\n    println!(\"Total time: {}\", after_rec1 - before_rec1);\n\n\n    let before_rec2 = time::precise_time_ns();\n\n    for i in 0..v.len() {\n        v.get(i)\n    }\n\n    let after_rec2 = time::precise_time_ns();\n    println!(\"Total time: {}\", after_rec2 - before_rec2);\n}\n</code></pre>\n\n<p>I would add a disclaimer, though, that if I were a compiler, this useless loop would be optimized into a noop. If, after compiling with <code>--release</code>, your programs reports <code>0</code>, this is what happened.</p>\n\n<p>Rust has built-in <a href=\"https://doc.rust-lang.org/book/benchmark-tests.html\" rel=\"noreferrer\">benchmarking support</a>, I advise that you use it rather than going the naive way. And... you will also need to inspect the assembly emitted, which is the only way to make sure that you are measuring what you think you are (optimizing compilers are tricky like that).</p>\n"}], "owner": {"reputation": 5534, "user_id": 1484555, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/9ede0b6ed1e9d2f7037ff60242dd7561?s=128&d=identicon&r=PG", "display_name": "almel", "link": "https://stackoverflow.com/users/1484555/almel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4786, "favorite_count": 0, "accepted_answer_id": 41168223, "answer_count": 1, "score": 1, "last_activity_date": 1481842614, "creation_date": 1481816666, "last_edit_date": 1481842614, "question_id": 41168061, "link": "https://stackoverflow.com/questions/41168061/how-solve-cannot-index-a-value-of-type-usize-error", "title": "How solve &quot;cannot index a value of type `usize`&quot; error?", "body": "<p>I am trying to measure the speed of <code>Vec</code>'s <code>[]</code> indexing vs. <code>.get(index)</code>  using the following code:</p>\n\n<pre><code>extern crate time;\n\nfn main() {\n    let v = vec![1; 1_000_000];\n    let before_rec1 = time::precise_time_ns();\n\n    for (i, v) in (0..v.len()).enumerate() {\n        v[i]\n    }\n    let after_rec1 = time::precise_time_ns();\n    println!(\"Total time: {}\", after_rec1 - before_rec1);\n\n\n    let before_rec2 = time::precise_time_ns();\n\n    for (i, v) in (0..v.len()).enumerate() {\n        v.get(i)\n    }\n    let after_rec2 = time::precise_time_ns();\n    println!(\"Total time: {}\", after_rec2 - before_rec2);\n}\n</code></pre>\n\n<p>but this returns the following errors:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: cannot index a value of type `usize`\n --&gt; src/main.rs:8:9\n  |\n8 |         v[i]\n  |         ^^^^\n\nerror: no method named `get` found for type `usize` in the current scope\n  --&gt; src/main.rs:17:11\n   |\n17 |         v.get(i)\n   |           ^^^\n</code></pre>\n\n<p>I'm confused why this doesn't work, since <code>enumerate</code> should give me an index which, by its very name, I should be able to use to index the vector.</p>\n\n<ol>\n<li>Why is this error being thrown?</li>\n<li>I know I can/should use iteration rather than C-style way of indexing, but for learning's sake what do I use to iterate over the index values like I'm trying to do here?</li>\n</ol>\n"}, {"tags": ["rust", "serde"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 6, "creation_date": 1481814083, "post_id": 41167080, "comment_id": 69534890, "body": "You need to use nightly, and a recent one at that, and you should not be using <code>&quot;*&quot;</code> dependencies but specify versions. If you want to use stable, you need to use the solution described here: <a href=\"https://serde.rs/codegen-stable.html\" rel=\"nofollow noreferrer\">serde.rs/codegen-stable.html</a>"}, {"owner": {"reputation": 992, "user_id": 1510611, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/29f2322d4cb7701902099116c656ab54?s=128&d=identicon&r=PG", "display_name": "Antonio Romero Oca", "link": "https://stackoverflow.com/users/1510611/antonio-romero-oca"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1481814202, "post_id": 41167080, "comment_id": 69534970, "body": "@ker do you mean rustc nightly? which version of serde and serde_derive could you recommend me?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 3, "creation_date": 1481814597, "post_id": 41167080, "comment_id": 69535247, "body": "Yes I mean rustc nightly. Unfortunately the feature will be unstable for another release cycle or two, so 1.5 to 3 months until you can use it in stable. The suggested versions are those that you can find on <a href=\"https://serde.rs\" rel=\"nofollow noreferrer\">serde.rs</a> or simply the most recent on on crates.io"}], "answers": [{"tags": [], "owner": {"reputation": 6357, "user_id": 6086311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cb99289473f6393b89474785f2d294d1?s=128&d=identicon&r=PG", "display_name": "dtolnay", "link": "https://stackoverflow.com/users/6086311/dtolnay"}, "is_accepted": false, "score": 0, "last_activity_date": 1519591805, "creation_date": 1519591805, "answer_id": 48978317, "question_id": 41167080, "link": "https://stackoverflow.com/questions/41167080/project-with-serde-cannot-compile/48978317#48978317", "title": "Project with serde cannot compile", "body": "<p>The <code>#![feature(...)]</code> attribute indicates code that uses Rust features which have not been stabilized yet. At the time the question was asked, the <code>proc_macro</code> feature was not yet stable. Serde needs this feature for its <code>#[derive(Serialize, Deserialize)]</code> macros.</p>\n\n<p>Custom derives have been stabilized as of <a href=\"https://blog.rust-lang.org/2017/02/02/Rust-1.15.html\" rel=\"nofollow noreferrer\">Rust 1.15</a> so the code in the question (with the feature attribute removed) should work on any Rust compiler since that version.</p>\n"}], "owner": {"reputation": 992, "user_id": 1510611, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/29f2322d4cb7701902099116c656ab54?s=128&d=identicon&r=PG", "display_name": "Antonio Romero Oca", "link": "https://stackoverflow.com/users/1510611/antonio-romero-oca"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 902, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1519591805, "creation_date": 1481813537, "last_edit_date": 1481842983, "question_id": 41167080, "link": "https://stackoverflow.com/questions/41167080/project-with-serde-cannot-compile", "title": "Project with serde cannot compile", "body": "<p>When I try to run the example <a href=\"https://github.com/serde-rs/serde\" rel=\"nofollow noreferrer\">from the serde repository</a>:</p>\n\n<pre><code>#![feature(proc_macro)]\n\n#[macro_use]\nextern crate serde_derive;\n\nextern crate serde_json;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let point = Point { x: 1, y: 2 };\n\n    // Convert the Point to a JSON string.\n    let serialized = serde_json::to_string(&amp;point).unwrap();\n\n    // Prints serialized = {\"x\":1,\"y\":2}\n    println!(\"serialized = {}\", serialized);\n\n    // Convert the JSON string back to a Point.\n    let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();\n\n    // Prints deserialized = Point { x: 1, y: 2 }\n    println!(\"deserialized = {:?}\", deserialized);\n}\n</code></pre>\n\n<p>I get an error:</p>\n\n<blockquote>\n  <p>error: failed to run <code>rustc</code> to learn about target-specific\n  information</p>\n  \n  <p>Caused by:   process didn't exit successfully: <code>rustc - --crate-name _\n  --print=file-names --crate-type bin --crate-type proc-macro --crate-type rlib --target x86_64-unknown-linux-gnu</code> (exit code: 101)\n  --- stderr error: unknown crate type: <code>proc-macro</code></p>\n</blockquote>\n\n<p>My Rust version is 1.13.0 and my Cargo.toml has these dependencies: </p>\n\n<pre><code>[dependencies]\nserde = \"*\"\nserde_derive = \"*\"\n</code></pre>\n\n<p>Should I use other dependencies or extra configuration?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "edited": false, "score": 0, "creation_date": 1481809488, "post_id": 41162696, "comment_id": 69531695, "body": "As a temporary workaround, you can use <code>&amp;[T]</code> instead, since it is length-independent."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 3, "creation_date": 1481802270, "post_id": 41162765, "comment_id": 69527227, "body": "I hope that 2017 will be the year were Rust gains integral generic parameters (I&#39;d really like if it got MORE than just integrals, but integrals would be so helpful already)."}, {"owner": {"reputation": 16572, "user_id": 83741, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/60adb60c59462ef0cb9db65853736cf4?s=128&d=identicon&r=PG", "display_name": "Alexander Torstling", "link": "https://stackoverflow.com/users/83741/alexander-torstling"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1560168767, "post_id": 41162765, "comment_id": 99635943, "body": "<a href=\"https://github.com/rust-lang/rust/issues/44580\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/44580</a> for the tracking issue. It&#39;s getting closer."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1560172292, "post_id": 41162765, "comment_id": 99637689, "body": "There&#39;s also talk of having generic array implementations sooner, see <a href=\"https://github.com/rust-lang/rust/pull/60466\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/pull/60466</a>"}, {"owner": {"reputation": 35470, "user_id": 6348498, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/0zu4m.jpg?s=128&g=1", "display_name": "Gurwinder Singh", "link": "https://stackoverflow.com/users/6348498/gurwinder-singh"}, "edited": false, "score": 0, "creation_date": 1591675822, "post_id": 41162765, "comment_id": 110138117, "body": "One more year has passed."}, {"owner": {"reputation": 231, "user_id": 4946427, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/40ab8bebe7076c9f2a634d55da49c010?s=128&d=identicon&r=PG&f=1", "display_name": "Sascha", "link": "https://stackoverflow.com/users/4946427/sascha"}, "edited": false, "score": 1, "creation_date": 1607873291, "post_id": 41162765, "comment_id": 115403251, "body": "With current rust version, the definition has changed  to &quot;Arrays of any size implement the following traits if the element type allows it:      Debug,     IntoIterator (implemented for &amp;[T; N] and &amp;mut [T; N]),     PartialEq, PartialOrd, Eq, Ord,     Hash,     AsRef, AsMut,     Borrow, BorrowMut&quot;,  Only the Default trait is still limited to 32 element arrays."}], "tags": [], "owner": {"reputation": 16572, "user_id": 83741, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/60adb60c59462ef0cb9db65853736cf4?s=128&d=identicon&r=PG", "display_name": "Alexander Torstling", "link": "https://stackoverflow.com/users/83741/alexander-torstling"}, "is_accepted": true, "score": 6, "last_activity_date": 1481800406, "creation_date": 1481800406, "answer_id": 41162765, "question_id": 41162696, "link": "https://stackoverflow.com/questions/41162696/why-do-large-arrays-not-implement-stdfmtdebug/41162765#41162765", "title": "Why do &quot;large&quot; arrays not implement std::fmt::Debug?", "body": "<p>From <a href=\"https://doc.rust-lang.org/std/primitive.array.html\" rel=\"noreferrer\">https://doc.rust-lang.org/std/primitive.array.html</a>:</p>\n\n<blockquote>\n  <p>Arrays of sizes from 0 to 32 (inclusive) implement the following\n  traits if the element type allows it: </p>\n  \n  <ul>\n  <li>Clone (only if T: Copy)</li>\n  <li>Debug</li>\n  <li>IntoIterator (implemented for &amp;[T; N] and &amp;mut [T; N])</li>\n  <li>PartialEq, PartialOrd, Eq, Ord</li>\n  <li>Hash</li>\n  <li>AsRef, AsMut</li>\n  <li>Borrow, BorrowMut</li>\n  <li>Default</li>\n  </ul>\n  \n  <p>This limitation on the size\n  N exists because Rust does not yet support code that is generic over\n  the size of an array type. [Foo; 3] and [Bar; 3] are instances of same\n  generic type [T; 3], but [Foo; 3] and [Foo; 5] are entirely different\n  types. As a stopgap, trait implementations are statically generated up\n  to size 32.</p>\n  \n  <p>Arrays of any size are Copy if the element type is Copy. This works\n  because the Copy trait is specially known to the compiler.</p>\n</blockquote>\n"}], "owner": {"reputation": 1721, "user_id": 4268862, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/daefd26c4e8c4ad64790330214dd26d1?s=128&d=identicon&r=PG", "display_name": "Lud", "link": "https://stackoverflow.com/users/4268862/lud"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1467, "favorite_count": 0, "closed_date": 1481833993, "accepted_answer_id": 41162765, "answer_count": 1, "score": 4, "last_activity_date": 1481834030, "creation_date": 1481800192, "last_edit_date": 1481834030, "question_id": 41162696, "link": "https://stackoverflow.com/questions/41162696/why-do-large-arrays-not-implement-stdfmtdebug", "closed_reason": "Duplicate", "title": "Why do &quot;large&quot; arrays not implement std::fmt::Debug?", "body": "<p>I can print in <code>Debug</code> the following array:</p>\n\n<pre><code>fn main() {\n    let array = [0; 5];\n    println!(\"{:?}\", array);\n}\n</code></pre>\n\n<p>However, if the size is bigger, let's say it's 50, the trait <code>std::fmt::Debug</code> will not be implemented by default:</p>\n\n<pre><code>fn main() {\n    let array = [0; 50];\n    println!(\"{:?}\", array);\n}\n</code></pre>\n\n<p>Compilation error:</p>\n\n<blockquote>\n  <p>error[E0277]: the trait bound <code>[{integer}; 50]: std::fmt::Debug</code> is not satisfied</p>\n</blockquote>\n\n<p>Why is the <code>std::fmt::Debug</code> trait not implemented for some sizes of arrays?</p>\n"}, {"tags": ["rust", "rust-chrono", "chrono-tz"], "answers": [{"tags": [], "owner": {"reputation": 33796, "user_id": 45525, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/TKzgD.png?s=128&g=1", "display_name": "Synesso", "link": "https://stackoverflow.com/users/45525/synesso"}, "is_accepted": true, "score": 6, "last_activity_date": 1481788910, "creation_date": 1481788910, "answer_id": 41159161, "question_id": 41158999, "link": "https://stackoverflow.com/questions/41158999/getting-the-current-time-in-specified-timezone/41159161#41159161", "title": "Getting the current time in specified timezone", "body": "<p>Construct the value based on UTC, not local times.</p>\n\n<pre><code>let utc = UTC::now().naive_utc();\nlet dt = Los_Angeles.from_utc_datetime(&amp;utc);\n</code></pre>\n"}], "owner": {"reputation": 33796, "user_id": 45525, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/TKzgD.png?s=128&g=1", "display_name": "Synesso", "link": "https://stackoverflow.com/users/45525/synesso"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1126, "favorite_count": 2, "accepted_answer_id": 41159161, "answer_count": 1, "score": 5, "last_activity_date": 1481833783, "creation_date": 1481788280, "last_edit_date": 1481833783, "question_id": 41158999, "link": "https://stackoverflow.com/questions/41158999/getting-the-current-time-in-specified-timezone", "title": "Getting the current time in specified timezone", "body": "<p>Using the <a href=\"https://github.com/djzin/chrono-tz\" rel=\"noreferrer\">Chrono-TZ library</a>, how can I get the current time in a specified time zone?</p>\n\n<p>I tried </p>\n\n<pre><code>let naive_dt = Local::now().naive_local();\nlet dt = Los_Angeles.from_local_datetime(&amp;naive_dt).unwrap();\nprintln!(\"{:#?}\", dt);\n</code></pre>\n\n<p>But this printed the datetime in my current timezone, and affixed the requested timezone identifier, thereby giving me a datetime that is off by the difference in timezones.</p>\n\n<p>For example, at 18:30 AEST (UTC+10), I ask for the current time in PST (UTC-8). It should be 00:30 PST. Instead I get 18:30 PST</p>\n"}, {"tags": ["rust", "any"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 5, "creation_date": 1481789843, "post_id": 41156227, "comment_id": 69519781, "body": "Is there any reason you don&#39;t just use closures? Closures are there to stop us from needing a function-pointer + data-pointer pair. Just like slices are there to stop us from needing a data-pointer + length pair."}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "edited": false, "score": 1, "creation_date": 1481790690, "post_id": 41156227, "comment_id": 69520232, "body": "How about creating accessor methods for <code>SomeTool</code>? <code>custom_data()</code> and <code>custom_data_mut()</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "edited": false, "score": 0, "creation_date": 1481805336, "post_id": 41156227, "comment_id": 69529014, "body": "@JorgeIsraelPe&#241;a: Same reaction here; I wonder if we&#39;re missing something because it seems obvious that one should create a function rather than copy/paste :("}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1481813032, "post_id": 41156227, "comment_id": 69534137, "body": "Having a function makes some sense of course, coming from C however, does this mean you would have to define some new function every time you wanted to have a type with this style of access? - or would you write this as a generic function which takes the <code>Option&lt;Box&lt;Any&gt;&gt;</code> as an argument? eg: <code>some_box_any_unwrap_as::&lt;StructOnlyForThisTool&gt;(&amp;tool.custom&zwnj;&#8203;_data)</code>. While I could write a macro or function which <i>works</i>, they feel a little awkward - especially if this is an API for others to use."}], "answers": [{"comments": [{"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1482025873, "post_id": 41161093, "comment_id": 69608934, "body": "Does this work when there are multiple methods like <code>execute</code> needed?"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1482051857, "post_id": 41161093, "comment_id": 69612747, "body": "@ideasman42 It does. In fact, that is kind of the whole point of bothering with defining a trait; otherwise a simple <code>FnMut</code> would suffice. Try it, the <a href=\"https://play.rust-lang.org/?gist=976b179960d0322f5811af1825648f3f&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">example is compilable</a>."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": false, "score": 1, "last_activity_date": 1482053746, "last_edit_date": 1495540373, "creation_date": 1481795481, "answer_id": 41161093, "question_id": 41156227, "link": "https://stackoverflow.com/questions/41156227/convenient-optionboxany-access-when-success-is-assured/41161093#41161093", "title": "Convenient &#39;Option&lt;Box&lt;Any&gt;&gt;&#39; access when success is assured?", "body": "<p>If the implementation really only has a single method with a name like <code>execute</code>, that is a strong indication to consider using a closure to capture the implementation data. <code>SomeTool</code> can incorporate an arbitrary callable in a type-erased manner using a boxed <code>FnMut</code>, as shown <a href=\"https://stackoverflow.com/a/41081702/1600898\">in this answer</a>. <code>execute()</code> then boils down to invoking the closure stored in the struct field implementation closure using <code>(self.impl_)()</code>. For a more general approach, that will also work when you have more methods on the implementation, read on.</p>\n\n<p>An idiomatic and type-safe equivalent of the type+dataptr C pattern is to store the implementation type and pointer to data together as a <a href=\"https://doc.rust-lang.org/beta/book/trait-objects.html\" rel=\"nofollow noreferrer\">trait object</a>. The <code>SomeTool</code> struct can contain a single field, a boxed <code>SomeToolImpl</code> trait object, where the trait specifies tool-specific methods such as <code>execute</code>. This has the following characteristics:</p>\n\n<ul>\n<li><p>You no longer need an explicit <code>type</code> field because the run-time type information is incorporated in the trait object.</p></li>\n<li><p>Each tool's implementation of the trait methods can access its own data in a type-safe manner without casts or unwraps. This is because the trait object's vtable automatically invokes the correct function for the correct trait implementation, and it is a compile-time error to try to invoke a different one.</p></li>\n<li><p>The \"fat pointer\" representation of the trait object has the same performance characteristics as the type+dataptr pair - for example, the size of <code>SomeTool</code> will be two pointers, and accessing the implementation data will still involve a single pointer dereference.</p></li>\n</ul>\n\n<p>Here is an example implementation:</p>\n\n<pre><code>struct SomeTool {\n    impl_: Box&lt;SomeToolImpl&gt;,\n}\n\nimpl SomeTool {\n    fn execute(&amp;mut self) {\n        self.impl_.execute();\n    }\n}\n\ntrait SomeToolImpl {\n    fn execute(&amp;mut self);\n}\n\nstruct SpecificTool1 {\n    foo_bar: bool\n}\n\nimpl SpecificTool1 {\n    pub fn new(foo_bar: bool) -&gt; SomeTool {\n        let my_data = SpecificTool1 { foo_bar: foo_bar };\n        SomeTool { impl_: Box::new(my_data) }\n    }\n}\n\nimpl SomeToolImpl for SpecificTool1 {\n    fn execute(&amp;mut self) {\n        println!(\"I am {}\", self.foo_bar);\n    }\n}\n\nstruct SpecificTool2 {\n    num: u64\n}\n\nimpl SpecificTool2 {\n    pub fn new(num: u64) -&gt; SomeTool {\n        let my_data = SpecificTool2 { num: num };\n        SomeTool { impl_: Box::new(my_data) }\n    }\n}\n\nimpl SomeToolImpl for SpecificTool2 {\n    fn execute(&amp;mut self) {\n        println!(\"I am {}\", self.num);\n    }\n}\n\npub fn main() {\n    let mut tool1: SomeTool = SpecificTool1::new(true);\n    let mut tool2: SomeTool = SpecificTool2::new(42);\n    tool1.execute();\n    tool2.execute();\n}\n</code></pre>\n\n<p>Note that, in this design, it doesn't make sense to make implementation an <code>Option</code> because we always associate the tool <em>type</em> with the implementation. While it is perfectly valid to have an implementation without data, it must always have a type associated with it.</p>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 141, "favorite_count": 0, "answer_count": 1, "score": 6, "last_activity_date": 1484292618, "creation_date": 1481774506, "last_edit_date": 1484292618, "question_id": 41156227, "link": "https://stackoverflow.com/questions/41156227/convenient-optionboxany-access-when-success-is-assured", "title": "Convenient &#39;Option&lt;Box&lt;Any&gt;&gt;&#39; access when success is assured?", "body": "<p>When writing callbacks for generic interfaces, it can be useful for them to define their own local data which they are responsible for creating and accessing.</p>\n\n<p>In C I would just use a void pointer, <em>C-like example</em>:</p>\n\n<pre><code>struct SomeTool {\n    int type;\n    void *custom_data;\n};\n\nvoid invoke(SomeTool *tool) {\n    StructOnlyForThisTool *data = malloc(sizeof(*data));\n    /* ... fill in the data ... */\n    tool.custom_data = custom_data;\n}\nvoid execute(SomeTool *tool) {\n    StructOnlyForThisTool *data = tool.custom_data;\n    if (data.foo_bar) { /* do something */ }\n}\n</code></pre>\n\n<p>When writing something similar in Rust, replacing <code>void *</code> with <code>Option&lt;Box&lt;Any&gt;&gt;</code>, however I'm finding that accessing the data is <strong>unreasonably verbose</strong>, eg:</p>\n\n<pre><code>struct SomeTool {\n    type: i32,\n    custom_data: Option&lt;Box&lt;Any&gt;&gt;,\n};\n\nfn invoke(tool: &amp;mut SomeTool) {\n    let data = StructOnlyForThisTool { /* my custom data */ }\n    /* ... fill in the data ... */\n    tool.custom_data = Some(Box::new(custom_data));\n}\nfn execute(tool: &amp;mut SomeTool) {\n    let data = tool.custom_data.as_ref().unwrap().downcast_ref::&lt;StructOnlyForThisTool&gt;().unwrap();\n    if data.foo_bar { /* do something */ }\n}\n</code></pre>\n\n<p>There is one line here which I'd like to be able to write in a more compact way:</p>\n\n<ul>\n<li><code>tool.custom_data.as_ref().unwrap().downcast_ref::&lt;StructOnlyForThisTool&gt;().unwrap()</code></li>\n<li><code>tool.custom_data.as_ref().unwrap().downcast_mut::&lt;StructOnlyForThisTool&gt;().unwrap()</code></li>\n</ul>\n\n<p>While each method makes sense on its own, in practice it's not something I'd want to write throughout a code-base, and not something I'm going to want to type out often or remember easily.</p>\n\n<p>By convention, the uses of unwrap here aren't dangerous because:</p>\n\n<ul>\n<li>While only some tools define custom data, the ones that do always define it.</li>\n<li>When the data is set, by convention the tool only ever sets its own data. So there is no chance of having the wrong data.</li>\n<li>Any time these conventions aren't followed, its a bug and should panic.</li>\n</ul>\n\n<p>Given these conventions, and assuming accessing custom-data from a tool is something that's done often - what would be a good way to simplify this expression?</p>\n\n<hr>\n\n<p>Some possible options:</p>\n\n<ul>\n<li>Remove the <code>Option</code>, just use <code>Box&lt;Any&gt;</code> with <code>Box::new(())</code> representing <code>None</code> so access can be simplified a little.</li>\n<li>Use a macro or function to hide verbosity - passing in the <code>Option&lt;Box&lt;Any&gt;&gt;</code>: <em>will work of course, but prefer not - would use as a last resort.</em></li>\n<li>Add a trait to <code>Option&lt;Box&lt;Any&gt;&gt;</code> which exposes a method such as <code>tool.custom_data.unwrap_box::&lt;StructOnlyForThisTool&gt;()</code> with matching <code>unwrap_box_mut</code>.</li>\n</ul>\n\n<hr>\n\n<p>Update 1): since asking this question a point I didn't include seems relevant.\nThere may be multiple callback functions like <code>execute</code> which must all be able to access the <code>custom_data</code>. At the time I didn't think this was important to point out.</p>\n\n<p>Update 2): Wrapping this in a function which takes <code>tool</code> isn't practical, since the borrow checker then prevents further access to members of <code>tool</code> until the cast variable goes out of scope, I found the only reliable way to do this was to write a macro.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 13, "last_activity_date": 1481774071, "last_edit_date": 1481774071, "creation_date": 1481773763, "answer_id": 41156126, "question_id": 41156082, "link": "https://stackoverflow.com/questions/41156082/in-rust-whats-the-difference-between-and-inside-a-println/41156126#41156126", "title": "In Rust, what&#39;s the difference between &quot;{}&quot; and &quot;{:?}&quot; inside a println!?", "body": "<p><code>{:?}</code>, or, specifically, <code>?</code>, is the placeholder used by the <code>Debug</code> trait. If the type does not implement <code>Debug</code>, then using <code>{:?}</code> in a format string breaks.</p>\n\n<p>For example:</p>\n\n<pre><code>struct MyType {\n    the_field: u32\n}\n\nfn main() {\n    let instance = MyType { the_field: 5000 };\n    println!(\"{:?}\", instance);\n}\n</code></pre>\n\n<p>..fails with:</p>\n\n<pre><code>error[E0277]: the trait bound `MyType: std::fmt::Debug` is not satisfied\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=1a0957c017ae7d0b8a11ec90ba1f9cd5&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Implementing <code>Debug</code> though, fixes that</a>:</p>\n\n<pre><code>#[derive(Debug)]\nstruct MyType {\n    the_field: u32\n}\n\nfn main() {\n    let instance = MyType { the_field: 5000 };\n    println!(\"{:?}\", instance);\n}\n</code></pre>\n\n<p>Which outputs: <code>MyType { the_field: 5000 }</code>.</p>\n\n<p>You can see a list of these placeholder/operators <a href=\"https://doc.rust-lang.org/std/fmt/\" rel=\"noreferrer\">in the documentation</a>.</p>\n"}], "owner": {"reputation": 99, "user_id": 7270418, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9ae0567fe1dc40a79ecb6c88e37a231a?s=128&d=identicon&r=PG&f=1", "display_name": "rusty_programmer", "link": "https://stackoverflow.com/users/7270418/rusty-programmer"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3476, "favorite_count": 2, "closed_date": 1481833710, "answer_count": 1, "score": 9, "last_activity_date": 1481774071, "creation_date": 1481773359, "question_id": 41156082, "link": "https://stackoverflow.com/questions/41156082/in-rust-whats-the-difference-between-and-inside-a-println", "closed_reason": "Duplicate", "title": "In Rust, what&#39;s the difference between &quot;{}&quot; and &quot;{:?}&quot; inside a println!?", "body": "<p>This code works:</p>\n\n<pre><code>let x = Some(2);\nprintln!(\"{:?}\", x);\n</code></pre>\n\n<p>But this does not:</p>\n\n<pre><code>let x = Some(2);\nprintln!(\"{}\", x);\n</code></pre>\n\n<pre>\n5 | println!(\"{}\", x);\n  |                ^ trait `std::option::Option: std::fmt::Display` not satisfied\n  |\n  = note: `std::option::Option` cannot be formatted with the default formatter; try using `:?` instead if you are using a format string\n  = note: required by `std::fmt::Display::fmt`\n</pre>\n\n<p>Why? What's <code>:?</code> in that context?</p>\n"}]