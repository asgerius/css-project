[{"tags": ["struct", "rust", "heap-memory"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1493233131, "post_id": 43641728, "comment_id": 74333154, "body": "Idiomatic Rust code uses <code>PascalCase</code> (no underscores) for type names (<code>GeomEntity</code>) and <code>snake_case</code> for variables and function names (<code>parse_geom</code>)."}], "answers": [{"comments": [{"owner": {"reputation": 148712, "user_id": 19750, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/13b41b2620da0b1e630715e0c91a0b03?s=128&d=identicon&r=PG", "display_name": "Josh Lee", "link": "https://stackoverflow.com/users/19750/josh-lee"}, "edited": false, "score": 4, "creation_date": 1493234350, "post_id": 43642518, "comment_id": 74333874, "body": "<code>Vec&lt;Box&lt;T&gt;&gt;</code> where <code>T</code> is a trait type is probably the most common case of the elements themselves being boxed."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 12, "last_activity_date": 1493233374, "last_edit_date": 1495542355, "creation_date": 1493233374, "answer_id": 43642518, "question_id": 43641728, "link": "https://stackoverflow.com/questions/43641728/if-i-make-a-struct-and-put-it-in-a-vector-does-it-reside-on-the-heap-or-the-sta/43642518#43642518", "title": "If I make a struct and put it in a vector, does it reside on the heap or the stack?", "body": "<p>The <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html\" rel=\"noreferrer\">documentation for <code>Vec</code></a> says (emphasis mine):</p>\n\n<blockquote>\n  <p>If a <code>Vec</code> has allocated memory, then <strong>the memory it points to is on the heap</strong></p>\n</blockquote>\n\n<p>So yes, the members of the vector are owned by the vector and are stored on the heap.</p>\n\n<hr>\n\n<p>In <em>general</em>, boxing an element before putting it in the <code>Vec</code> is wasteful - there's extra memory allocation and indirection. There are times when you need that extra allocation or indirection, so it's never say never.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/39679310/155423\">Does Rust box the individual items that are added to a vector?</a></li>\n</ul>\n"}], "owner": {"reputation": 1905, "user_id": 1819861, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/d6a4df7c88cd6b6049278e30a88d3596?s=128&d=identicon&r=PG", "display_name": "Jonathan Gallagher", "link": "https://stackoverflow.com/users/1819861/jonathan-gallagher"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1172, "favorite_count": 0, "accepted_answer_id": 43642518, "answer_count": 1, "score": 3, "last_activity_date": 1493233374, "creation_date": 1493230752, "last_edit_date": 1493233080, "question_id": 43641728, "link": "https://stackoverflow.com/questions/43641728/if-i-make-a-struct-and-put-it-in-a-vector-does-it-reside-on-the-heap-or-the-sta", "title": "If I make a struct and put it in a vector, does it reside on the heap or the stack?", "body": "<p>I'm writing some code that generates a vector of geometric elements:</p>\n\n<pre><code>struct Geom_Entity {\n    // a bunch of geometric information,\n    // like tangent planes, force vectors, etc\n}\n</code></pre>\n\n<p>The code is parsing many of these entities from a text file (for e.g.) so we have a function currently:</p>\n\n<pre><code>parse_Geom(x: String) -&gt; Vec&lt;Geom_Entity&gt; { \n    // a bunch of code\n}\n</code></pre>\n\n<p>These geometric entities are large structs with 17 <code>f64</code>s and a few other fields.  The file may contain well over 1000 of these, but not so many that they can't all fit into memory (at least for now).</p>\n\n<p>Also, should I be doing</p>\n\n<pre><code>Box::new(Geom_Entity { ...\n</code></pre>\n\n<p>and then putting the box in the vector?</p>\n"}, {"tags": ["multithreading", "rust", "mio"], "answers": [{"tags": [], "owner": {"reputation": 1540, "user_id": 2606171, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/F4ncy.png?s=128&g=1", "display_name": "belst", "link": "https://stackoverflow.com/users/2606171/belst"}, "is_accepted": false, "score": 2, "last_activity_date": 1493216636, "creation_date": 1493216636, "answer_id": 43636978, "question_id": 43633148, "link": "https://stackoverflow.com/questions/43633148/how-can-i-combine-discord-rs-events-with-other-events-from-twitter-or-timers/43636978#43636978", "title": "How can I combine discord-rs events with other events from Twitter or timers?", "body": "<p>In your case I would just start a thread for each service you need and then use a mpsc channel to send the events to the main loop.</p>\n\n<p>Example:</p>\n\n<pre><code>use std::thread;\nuse std::sync::mpsc::channel;\n\nenum Event {\n    Discord(()),\n    Twitter(()),\n    Timer(()),\n}\n\nfn main() {\n    let (tx, rx) = channel();\n    // discord\n    let txprime = tx.clone();\n    thread::spawn(move || {\n        loop {\n            // discord loop\n            txprime.send(Event::Discord(())).unwrap()\n        }\n    });\n\n    // twitter\n    let txprime = tx.clone();\n    thread::spawn(move || {\n        loop {\n            // twitter loop\n            txprime.send(Event::Twitter(())).unwrap()\n        }\n    });\n\n    // timer\n    let txprime = tx.clone();\n    thread::spawn(move || {\n        loop {\n            // timer loop\n            txprime.send(Event::Timer(())).unwrap()\n        }\n    });\n\n    // Main loop\n    loop {\n        match rx.recv().unwrap() {\n            Event::Discord(d) =&gt; unimplemented!(),\n            Event::Twitter(t) =&gt; unimplemented!(),\n            Event::Timer(t)   =&gt; unimplemented!(),\n        }\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": true, "score": 2, "last_activity_date": 1493280457, "last_edit_date": 1495542357, "creation_date": 1493236057, "answer_id": 43643283, "question_id": 43633148, "link": "https://stackoverflow.com/questions/43633148/how-can-i-combine-discord-rs-events-with-other-events-from-twitter-or-timers/43643283#43643283", "title": "How can I combine discord-rs events with other events from Twitter or timers?", "body": "<blockquote>\n  <p>This library gives me events when they arise in a single thread in a main loop</p>\n</blockquote>\n\n<p>The \"single thread\" thing is only true for small bots. As soon as you reach the <a href=\"https://github.com/hammerandchisel/discord-api-docs/issues/17#issuecomment-269231657\" rel=\"nofollow noreferrer\">2500 guilds limit</a>, Discord will refuse to connect your bot in a normal way. You'll have to use sharding. And I <em>guess</em> you're not going to provision new virtual servers for your bot shards. Chance is, you will spawn new <em>threads</em> instead, one event loop per shard.</p>\n\n<p>Here is how I do it, BTW:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn event_loop(shard_id: u8, total_shards: u8){\n    loop {\n        let bot = Discord::from_bot_token(\"...\").expect(\"!from_bot_token\");\n        let (mut dc, ready_ev) = bot.connect_sharded(shard_id, total_shards).expect(\"!connect\");\n        // ...\n    }\n}\n\nfn main() {\n    let total_shards = 10;\n    for shard_id in 0..total_shards {\n        sleep(Duration::from_secs(6)); // There must be a five-second pause between connections from one IP.\n        ThreadBuilder::new().name (fomat! (\"shard \" (shard_id)))\n          .spawn (move || {\n            loop {\n              if let Err (err) = catch_unwind (move || event_loop (shard_id, total_shards)) {\n                log! (\"shard \" (shard_id) \" panic: \" (gstuff::any_to_str (&amp;*err) .unwrap_or (\"\")));\n                sleep (Duration::from_secs (10));\n                continue}  // Panic restarts the shard.\n              break}\n          }) .expect (\"!spawn\");\n    }\n}\n</code></pre>\n\n<blockquote>\n  <p>I want to add some timers and other things which are calculated in their own threads and which must notify me to do something in the main loop's thread</p>\n</blockquote>\n\n<h3>Option 1. Don't.</h3>\n\n<p>Chance is, you don't really need to come <em>back</em> to the Discord event loop! Let's say you want to post a reply, to update an embed, etc. You do not need the Discord event loop to do that!</p>\n\n<p>Discord API goes in two parts:<br>\n1) Websocket API, represented by the <a href=\"https://docs.rs/discord/0.8.0/discord/struct.Connection.html\" rel=\"nofollow noreferrer\"><code>Connection</code></a>, is used to <em>get</em> events from Discord.<br>\n2) REST API, represented by the <a href=\"https://docs.rs/discord/0.8.0/discord/struct.Discord.html\" rel=\"nofollow noreferrer\"><code>Discord</code></a> interface, is used to <em>send</em> events out.</p>\n\n<p>You can send events from pretty much anywhere. From any thread. Maybe even from your timers.</p>\n\n<p><a href=\"https://docs.rs/discord/0.8.0/discord/struct.Discord.html\" rel=\"nofollow noreferrer\"><code>Discord</code></a> is <a href=\"https://doc.rust-lang.org/std/marker/trait.Sync.html\" rel=\"nofollow noreferrer\"><code>Sync</code></a>. Wrap it in the <a href=\"https://doc.rust-lang.org/nightly/std/sync/struct.Arc.html\" rel=\"nofollow noreferrer\"><code>Arc</code></a> and share it with your timers and threads.</p>\n\n<h3>Option 2. Seize the opportunity.</h3>\n\n<p>Even though <a href=\"https://docs.rs/discord/0.8.0/discord/struct.Connection.html#method.recv_event\" rel=\"nofollow noreferrer\"><code>recv_event</code></a> doesn't have a timeout, Discord will be constantly sending you new events. Users are signing in, signing out, typing, posting messages, starting videogames, editing stuff and what not. Indeed, if the stream of events stops then you have a problem with your Discord connection (for my bot I've implemented a High Availability failover based on that signal).</p>\n\n<p>You could share a <a href=\"https://docs.rs/deque/\" rel=\"nofollow noreferrer\">deque</a> with your threads and timers. Once the timer is finished it will post a little something to the deque, then the even loop will check the deque for new things to do once Discord wakes it with a new event.</p>\n\n<h3>Option 3. Bird's-eye view.</h3>\n\n<p>As <a href=\"https://stackoverflow.com/users/2606171/belst\">belst</a> have pointed out, you could start a generic event loop, a loop \"to rule them all\", then lift Discord events into that loop. This is particularly interesting because with sharding you're going to have multiple event loops.</p>\n\n<p>So, Discord event loop -> simple event filter -> channel -> main event loop.</p>\n\n<h3>Option 4. Sharded.</h3>\n\n<p>If you want your bot to stay online during code upgrades and restarts, then you should provision for a way to restart each shard separately (or otherwise implement a High Availability failover on the shard level, like I did). Because you can't immediately connect all your shards after a process restart, Discord won't let you.</p>\n\n<p>If all your shards share the same process, then after that process restarts you have to wait five seconds before attaching a new shard. With 10 shards it's almost a minute of bot downtime.</p>\n\n<p>One way to separate the shard restarts is to dedicate a process to every shard. Then when you need to upgrade the bot, you'd restart each process separately. That way <em>you</em> still have to wait five to six seconds per shard, but <em>your user's</em> don't.</p>\n\n<p>Even better is that you now need to restart the Discord event loop processes only for discord-rs upgrades and similar maintance-related tasks. Your main event loop, on the other hand, can be restarted immediately and as often as you like. This should speed up the compile-run-test loop considerably.</p>\n\n<p>So, Discord event loop, in a separate shard process -> simple event filter -> RPC or database -> main event loop, in a separate process.</p>\n"}], "owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 366, "favorite_count": 0, "accepted_answer_id": 43643283, "answer_count": 2, "score": 0, "last_activity_date": 1493280457, "creation_date": 1493206780, "last_edit_date": 1493209219, "question_id": 43633148, "link": "https://stackoverflow.com/questions/43633148/how-can-i-combine-discord-rs-events-with-other-events-from-twitter-or-timers", "title": "How can I combine discord-rs events with other events from Twitter or timers?", "body": "<p>I have written a bot for the Discord chat service using the <a href=\"https://github.com/SpaceManiac/discord-rs/blob/master/src/connection.rs#L189\" rel=\"nofollow noreferrer\">discord-rs</a> library. This library gives me events when they arise in a single thread in a main loop:</p>\n\n<pre><code>fn start() {\n    // ...\n    loop {\n        let event = match connection.recv_event() {\n            Ok(event) =&gt; event,\n            Err(err) =&gt; { ... },\n        }\n    }\n}\n</code></pre>\n\n<p>I want to add some timers and other things which are calculated in their own threads and which must notify me to do something in the main loop's thread. I also want to add Twitter support. So it may look as this:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>(Discord's network connection, Twitter network connection, some timer in another thread) -&gt; main loop\n</code></pre>\n\n<p>This will look something like this:</p>\n\n<pre><code>fn start() {\n    // ...\n    loop {\n        let event = match recv_events() {\n            // 1. if Discord - do something with discord\n            // 2. if timer - handle timer's notification\n            // 3. if Twitter network connection - handle twitter\n        }\n    }\n}\n</code></pre>\n\n<p>In raw C and C sockets, it could be done by (e)polling them but here I have no idea how to do that in Rust or if it is even possible. I think I want something like <code>poll</code> of few different sources which would provide me objects of different types.</p>\n\n<p>I guess this could be implemented if I provide a wrapper for mio's <code>Evented</code> trait and use mio's poll as described in the <a href=\"http://carllerche.github.io/mio/mio/event/trait.Evented.html#examples\" rel=\"nofollow noreferrer\"><code>Deadline</code></a> example.</p>\n\n<p>Is there any way to combine these events?</p>\n"}, {"tags": ["rust", "asn.1", "serde"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 3, "creation_date": 1493199610, "post_id": 43626142, "comment_id": 74309073, "body": "I think it&#39;s perfectly possible to implement an an ASN.1 codec with serde. But you need to choose a specific format (BER, DER, ...) and you probably can share only little code between the formats."}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 3, "creation_date": 1493200812, "post_id": 43626142, "comment_id": 74309921, "body": "The <a href=\"https://serde.rs/data-format.html\" rel=\"nofollow noreferrer\">official documentation</a> has a section on developing your own formats, in which you are advised to understand the <a href=\"https://serde.rs/data-model.html\" rel=\"nofollow noreferrer\">Serde data model</a>. Can you make your question more specific on the matter that is troubling you?"}, {"owner": {"reputation": 61, "user_id": 4303358, "user_type": "registered", "profile_image": "https://lh6.googleusercontent.com/-xe2hN32yExw/AAAAAAAAAAI/AAAAAAAAAuo/NBcl0wsGWzs/photo.jpg?sz=128", "display_name": "Anton K", "link": "https://stackoverflow.com/users/4303358/anton-k"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1493356106, "post_id": 43626142, "comment_id": 74390913, "body": "@E_net4, now there should be enough information on the issue. Thanks for your reply!"}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1493382394, "post_id": 43626142, "comment_id": 74406424, "body": "You seem to depend too much on a trait rather than the structs. Would there still be a problem if you focused on implementing <code>Serialize</code> to each complex type?"}, {"owner": {"reputation": 669, "user_id": 3108779, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dc38108f3e7579e0e09971f9a660c895?s=128&d=identicon&r=PG&f=1", "display_name": "Miloslav Raus", "link": "https://stackoverflow.com/users/3108779/miloslav-raus"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1552488821, "post_id": 43626142, "comment_id": 97030159, "body": "@oli_obk : You can share a fuckton of code, the main difference between DER (CER) and BER is that BER allows for streaming (unknown-length structures, which use end marker instead of size), while DER (CER) require the size be known in advance. It&#39;s like 2-4 pages in Dubuisson&#39;s book (free; <a href=\"http://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF\" rel=\"nofollow noreferrer\">oss.com/asn1/resources/books-whitepapers-pubs/&hellip;</a>). Now, PER and XER are certainly &quot;more fun&quot; ;-)"}, {"owner": {"reputation": 6143, "user_id": 2147218, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/JQVSl.jpg?s=128&g=1", "display_name": "bazza", "link": "https://stackoverflow.com/users/2147218/bazza"}, "reply_to_user": {"reputation": 669, "user_id": 3108779, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dc38108f3e7579e0e09971f9a660c895?s=128&d=identicon&r=PG&f=1", "display_name": "Miloslav Raus", "link": "https://stackoverflow.com/users/3108779/miloslav-raus"}, "edited": false, "score": 0, "creation_date": 1585126909, "post_id": 43626142, "comment_id": 107651285, "body": "@MiloslavRaus, there&#39;s uPER, cannonical PER, and JSON too for good measure! BTW, leveraging Serde will be code first, whereas a lot of ASN.1 usage is schema first, with a schema compiler producing source code in C, C++, or whatever. I&#39;m looking forward to the hallowed day we get that for Rust!"}], "owner": {"reputation": 61, "user_id": 4303358, "user_type": "registered", "profile_image": "https://lh6.googleusercontent.com/-xe2hN32yExw/AAAAAAAAAAI/AAAAAAAAAuo/NBcl0wsGWzs/photo.jpg?sz=128", "display_name": "Anton K", "link": "https://stackoverflow.com/users/4303358/anton-k"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 883, "favorite_count": 0, "answer_count": 0, "score": 1, "last_activity_date": 1493355968, "creation_date": 1493186272, "last_edit_date": 1493355968, "question_id": 43626142, "link": "https://stackoverflow.com/questions/43626142/is-it-possible-to-implement-asn-1-der-in-rust-using-serde", "title": "Is it possible to implement ASN.1 DER in Rust using Serde?", "body": "<p>AFAIK there's no (flexible and stable) ASN.1 {ser,deser}ialization library in Rust, so I'm looking into making one (while learning Rust at the same time). My goal is SNMP (v1-v3) client implementation in Rust.</p>\n\n<p>Before starting from scratch, I'd like to ask Serde team or experienced Serde users if it's possible to implement ASN.1 codec with Serde. Problem is every object in ASN.1 has it's own header (<code>TAG</code> + <code>LENGTH</code>), where <code>TAG</code> is user defined for each type, so iXX or uXX or bytes or whatever can be any <code>TAG</code>.</p>\n\n<p>An ASN.1 object is composed of <code>tag</code>, <code>length</code> and <code>payload</code>. ASN.1 has a set of universal (default) tags for integers, floats, bytestrings (as well as ASCII strings) etc. I could just stick to universal tags for primitive types, but for non-primitive types (tuples, newtypes, structs etc) the type should have an  implementation of the <code>Asn1Info</code> trait, providing tag and custom serialize / deserialize functionality.</p>\n\n<p>{ser,deser}ialization of primitive types is trivial, but how can I implement it for complex structures (or newtypes)? They <em>must</em> be <code>Asn1Info</code>.</p>\n\n<p>I've looked into the <a href=\"https://github.com/keeperofdakeys/asn1-rs\" rel=\"nofollow noreferrer\">asn1-cereal</a> library. It looks like a decent ASN.1 implementation, providing useful macros and stuff. I might as well work on it instead of writing everything from scratch.</p>\n\n<p>Let's assume <code>tag</code> is <code>u8</code> and Asn1Info trait looks like this:</p>\n\n<pre><code>pub trait Asn1Info {\n  fn asn1_tag() -&gt; u8;\n}\n</code></pre>\n\n<p>Then I have a newtype like <code>pub struct Counter(u32)</code> with it's own application-specific tag. I'd then make an impl for Counter like this:</p>\n\n<pre><code>impl Asn1Info for Counter {\n    fn asn1_tag() -&gt; u8 {\n        0x41\n    }\n}\n</code></pre>\n\n<p>Now how do I serialize it with tag <code>0x41</code> without manually implementing <code>Serialize</code> trait? There's no way to inject additional information to <code>Serializer</code>, so I'm unable to reuse all non-primitive serialization methods in it (like <code>serialize_newtype_variant</code>).\nIf I can't use <code>Serializer</code> methods in <code>Serialize</code> trait impl for custom ASN.1 objects (application-specific, context-specific etc.), then there's no way (or no point) to implement a useful ASN.1 codec with Serde, isn't it?</p>\n"}, {"tags": ["rust", "hammingweight"], "comments": [{"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 1, "creation_date": 1493166419, "post_id": 43612444, "comment_id": 74295069, "body": "&quot;I know Rust has count_ones() - the compiler told me when I was writing this code&quot; \u2192 When did it tell you?"}, {"owner": {"reputation": 618, "user_id": 174617, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/eb474a4ee0160ac2b307afad50b64b63?s=128&d=identicon&r=PG&f=1", "display_name": "Mark Wright", "link": "https://stackoverflow.com/users/174617/mark-wright"}, "reply_to_user": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 1, "creation_date": 1493295286, "post_id": 43612444, "comment_id": 74362199, "body": "Replace the declaration with <code>fn hamming_weight(val: u64) -&gt; u32</code>.    I get this error message: <code>help: here are some functions which might fulfill your needs: ... - .count_ones()</code>.  The rust compiler&#39;s error messages are amazing."}], "answers": [{"comments": [{"owner": {"reputation": 618, "user_id": 174617, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/eb474a4ee0160ac2b307afad50b64b63?s=128&d=identicon&r=PG&f=1", "display_name": "Mark Wright", "link": "https://stackoverflow.com/users/174617/mark-wright"}, "edited": false, "score": 0, "creation_date": 1493129165, "post_id": 43612638, "comment_id": 74274733, "body": "Thank you - that was baffling."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 12, "last_activity_date": 1493128357, "creation_date": 1493128357, "answer_id": 43612638, "question_id": 43612444, "link": "https://stackoverflow.com/questions/43612444/why-does-my-hamming-weight-function-work-in-c-but-not-in-rust/43612638#43612638", "title": "Why does my Hamming weight function work in C but not in Rust?", "body": "<blockquote>\n  <p>I had to use <code>u64</code> to prevent overflow panics on <code>0xffff</code></p>\n</blockquote>\n\n<p>That's your problem. The original C code <em>relies</em> on the operation overflowing. Increasing the size of the type doesn't fix it, but allowing the overflow to wrap does:</p>\n\n<pre><code>fn hamming_weight(val: u32) -&gt; u32 {\n    let v1 = val - ((val &gt;&gt; 1) &amp; 0x55555555);\n    let v2 = (v1 &amp; 0x33333333) + ((v1 &gt;&gt; 2) &amp; 0x33333333);\n    (((v2 + (v2 &gt;&gt; 4)) &amp; 0xF0F0F0F).wrapping_mul(0x1010101)) &gt;&gt; 24\n}\n</code></pre>\n"}], "owner": {"reputation": 618, "user_id": 174617, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/eb474a4ee0160ac2b307afad50b64b63?s=128&d=identicon&r=PG&f=1", "display_name": "Mark Wright", "link": "https://stackoverflow.com/users/174617/mark-wright"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 300, "favorite_count": 0, "accepted_answer_id": 43612638, "answer_count": 1, "score": 3, "last_activity_date": 1493128357, "creation_date": 1493127871, "last_edit_date": 1493128121, "question_id": 43612444, "link": "https://stackoverflow.com/questions/43612444/why-does-my-hamming-weight-function-work-in-c-but-not-in-rust", "title": "Why does my Hamming weight function work in C but not in Rust?", "body": "<p>I've got the following Hamming weight code in Rust, and it returns garbage for <code>0xffff</code> and <code>0xffffffff</code>, but the identical code in C works, so I must be misunderstanding something about how Rust does bit-level operations.  It's completely parenthesized, so I don't think it's an operator-precedence issue.</p>\n\n<p>In C:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n\nint hamming_weight(int val) {\n    int v1 = val - ((val &gt;&gt; 1) &amp; 0x55555555);\n    int v2 = (v1 &amp; 0x33333333) + ((v1 &gt;&gt; 2) &amp; 0x33333333);\n    return (((v2 + (v2 &gt;&gt; 4)) &amp; 0xF0F0F0F) * 0x1010101) &gt;&gt; 24;\n}\n\nint main() {\n    printf(\"%x -&gt; %d\\n\", 7, hamming_weight(7));\n    printf(\"%x -&gt; %d\\n\", 0xff, hamming_weight(0xff));\n    printf(\"%x -&gt; %d\\n\", 0xffff, hamming_weight(0xffff));\n    printf(\"%x -&gt; %d\\n\", 0xffffffff, hamming_weight(0xffffffff));\n    return 0;\n}\n</code></pre>\n\n<p>The results:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>7 -&gt; 3\nff -&gt; 8\nffff -&gt; 16\nffffffff -&gt; 32\n</code></pre>\n\n<p>In Rust (I had to use u64 to prevent overflow panics on <code>0xffff</code>):</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn hamming_weight(val: u64) -&gt; u64 {\n    let v1 = val - ((val &gt;&gt; 1) &amp; 0x55555555);\n    let v2 = (v1 &amp; 0x33333333) + ((v1 &gt;&gt; 2) &amp; 0x33333333);\n    (((v2 + (v2 &gt;&gt; 4)) &amp; 0xF0F0F0F) * 0x1010101) &gt;&gt; 24\n}\n\nfn main() {\n    println!(\"{:x} {}\", 7, hamming_weight(7));\n    println!(\"{:x} {}\", 0xff, hamming_weight(0xff));\n    println!(\"{:x} {}\", 0xffff, hamming_weight(0xffff));\n    println!(\"{:x} {}\", 0xffffffffu32, hamming_weight(0xffffffffu64));\n}\n</code></pre>\n\n<p>The results:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>7 3\nff 8\nffff 2064\nffffffff 135272480\n</code></pre>\n\n<p>I'm using Rust 1.16. I know Rust has <code>count_ones()</code> - the compiler told me when I was writing this code, which was pretty amazing, but I am choosing to not use it.</p>\n"}, {"tags": ["rust", "pattern-matching"], "comments": [{"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1493102044, "post_id": 43603102, "comment_id": 74255759, "body": "The first parameter must be named <code>self</code>, as stated in the note. <code>self</code> is a keyword."}, {"owner": {"reputation": 671, "user_id": 7551820, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh6.googleusercontent.com/-qFYkSwbZduE/AAAAAAAAAAI/AAAAAAAAAdQ/MmHqIWG-_xQ/photo.jpg?sz=128", "display_name": "Laurence", "link": "https://stackoverflow.com/users/7551820/laurence"}, "reply_to_user": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1493102287, "post_id": 43603102, "comment_id": 74255891, "body": "@kennytm He says that <code>self</code> is just a sugar, so does it mean that the first argument&#39;s name is not necessary to be  <code>self</code>?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1493104234, "post_id": 43603102, "comment_id": 74257005, "body": "@Laurence: The excerpt you are looking is dated February 2014, Rust 1.0 got out on May 15, 2015. Beware when looking too far in Rust history, as things changed a lot until 1.0; it may very well be that the comment you are basing your question on is simply obsolete."}, {"owner": {"reputation": 671, "user_id": 7551820, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh6.googleusercontent.com/-qFYkSwbZduE/AAAAAAAAAAI/AAAAAAAAAdQ/MmHqIWG-_xQ/photo.jpg?sz=128", "display_name": "Laurence", "link": "https://stackoverflow.com/users/7551820/laurence"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1493104490, "post_id": 43603102, "comment_id": 74257177, "body": "@MatthieuM. Yes, it is a relatively old post, but I didn&#39;t find other more recent posts about this issue, so I put it here.."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1493104580, "post_id": 43603102, "comment_id": 74257222, "body": "@Laurence: Oh don&#39;t worry; it&#39;s clearly an appropriate question for SO and hopefully you&#39;ll get a definite answer."}, {"owner": {"reputation": 1417, "user_id": 2977291, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/66afbccc6043392125ac0f0de57ccfa7?s=128&d=identicon&r=PG&f=1", "display_name": "paholg", "link": "https://stackoverflow.com/users/2977291/paholg"}, "edited": false, "score": 5, "creation_date": 1493105113, "post_id": 43603102, "comment_id": 74257567, "body": "@Laurence while the first argument must be <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> for it to be a method, you can destructure inside the function, like so: <code>let &amp;Vector{x, y, z} = self;</code>"}], "answers": [{"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 13, "last_activity_date": 1493132978, "last_edit_date": 1493132978, "creation_date": 1493117137, "answer_id": 43608513, "question_id": 43603102, "link": "https://stackoverflow.com/questions/43603102/is-it-possible-to-destructure-the-self-argument-of-a-method/43608513#43608513", "title": "Is it possible to destructure the `self` argument of a method?", "body": "<p>This was originally intended to be possible with the Universal Function Calls, but is backwards incompatible, because it would mean that <code>fn foo(bar: &amp;Self)</code> would suddenly be equivalent to <code>fn foo(self: &amp;Self)</code>, which can break method calls due to new methods appearing suddenly.</p>\n\n<p>Full rationale in <a href=\"https://github.com/rust-lang/rust/issues/16293#issuecomment-185906859\" rel=\"noreferrer\">this github issue comment</a></p>\n\n<p>You can destructure the explicit <code>self</code> parameter with a <code>let</code> binding in the function body:</p>\n\n<pre><code>let &amp;Vector { x, y, z } = self;\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 1057, "user_id": 146560, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fe6db7ea5f961fbaabca0c0d7a364217?s=128&d=identicon&r=PG", "display_name": "Ro.", "link": "https://stackoverflow.com/users/146560/ro"}, "is_accepted": false, "score": 0, "last_activity_date": 1616210726, "creation_date": 1616210726, "answer_id": 66717938, "question_id": 43603102, "link": "https://stackoverflow.com/questions/43603102/is-it-possible-to-destructure-the-self-argument-of-a-method/66717938#66717938", "title": "Is it possible to destructure the `self` argument of a method?", "body": "<pre><code>  impl Vector {        \n    fn print(&amp;self) {\n      // destructure self argument\n      let Vector { x, y, z } = &amp;self;\n      println!(&quot;{} {} {}&quot;, x, y, z);\n    }\n  }\n</code></pre>\n"}], "owner": {"reputation": 671, "user_id": 7551820, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh6.googleusercontent.com/-qFYkSwbZduE/AAAAAAAAAAI/AAAAAAAAAdQ/MmHqIWG-_xQ/photo.jpg?sz=128", "display_name": "Laurence", "link": "https://stackoverflow.com/users/7551820/laurence"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1466, "favorite_count": 0, "accepted_answer_id": 43608513, "answer_count": 2, "score": 10, "last_activity_date": 1616210726, "creation_date": 1493101421, "last_edit_date": 1493133029, "question_id": 43603102, "link": "https://stackoverflow.com/questions/43603102/is-it-possible-to-destructure-the-self-argument-of-a-method", "title": "Is it possible to destructure the `self` argument of a method?", "body": "<p>I am trying to find a way to destructure the <code>self</code> argument of a method.  According to a <a href=\"https://github.com/rust-lang/rust/pull/12566#issuecomment-37353339\" rel=\"noreferrer\">GitHub comment</a>:</p>\n\n<blockquote>\n  <p>Per today's meeting, we have a different plan to make self arguments destructurable. With universal function-call syntax (UFCS #11938) there will not be any distinction between static methods and instance methods - they will both be 'associated functions'. At that point any function who's first argument is the self type will be callable with method syntax, and <code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code> are just sugar for i.e. <code>self: &amp;Self</code>, and destructuring on the self argument can be done as normal by not using the self-sugar.</p>\n</blockquote>\n\n<p>I wrote the following code, but it does not work as I expected in that all three print functions can be used as a method.</p>\n\n<pre><code>struct Vector {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nimpl Vector {\n    fn print1(self: &amp;Self) {\n        println!(\"{} {} {}\", self.x, self.y, self.z);\n    }\n\n    // destructure self argument\n    fn print2(&amp;Vector{x, y, z}: &amp;Self) {\n        println!(\"{} {} {}\", x, y, z);\n    }\n\n    // use another name for the first argument\n    fn print3(this: &amp;Self) {\n        println!(\"{} {} {}\", this.x, this.y, this.z);\n    }\n}\n\nfn main() {\n    let v = Vector{x: 1, y: 2, z: 3};\n\n    Vector::print1(&amp;v); // work\n    v.print1();         // work\n    Vector::print2(&amp;v); // work\n    v.print2();         // not work\n    Vector::print3(&amp;v); // work\n    v.print3();         // not work\n}\n</code></pre>\n\n<p><code>print3()</code> was just used to test if it is possible to use a name other than <code>self</code> for the first argument of a method.</p>\n\n<p>It gives this compile error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: no method named `print2` found for type `Vector` in the current scope\n  --&gt; 1.rs:27:7\n   |\n27 |     v.print2();         // not work\n   |       ^^^^^^\n   |\n   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\nnote: candidate #1 is defined in an impl for the type `Vector`\n  --&gt; 1.rs:12:5\n   |\n12 |       fn print2(&amp;Vector{x, y, z}: &amp;Self) {\n   |  _____^ starting here...\n13 | |         println!(\"{} {} {}\", x, y, z);\n14 | |     }\n   | |_____^ ...ending here\n\nerror: no method named `print3` found for type `Vector` in the current scope\n  --&gt; 1.rs:29:7\n   |\n29 |     v.print3();         // not work\n   |       ^^^^^^\n   |\n   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\nnote: candidate #1 is defined in an impl for the type `Vector`\n  --&gt; 1.rs:16:5\n   |\n16 |       fn print3(this: &amp;Self) {\n   |  _____^ starting here...\n17 | |         println!(\"{} {} {}\", this.x, this.y, this.z);\n18 | |     }\n   | |_____^ ...ending here\n</code></pre>\n\n<p>It seems that <code>print2()</code> and <code>print3()</code> are not identified as methods of <code>Vector</code>.</p>\n\n<ol>\n<li>How to destructure the <code>self</code> argument of a method?</li>\n<li>According to the comment, the name <code>self</code> is just sugar. Does it mean that a name other than <code>self</code> can be used for the first argument of a method?</li>\n</ol>\n"}, {"tags": ["formatting", "gdb", "rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1493124445, "post_id": 43600870, "comment_id": 74270979, "body": "There&#39;s no guarantee that the <code>data_ptr</code> is NUL-terminated, so it seems like this is likely to fail at the worst time."}], "tags": [], "owner": {"reputation": 583, "user_id": 7102831, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/52cd25404ff80b8271b3ed72a718c269?s=128&d=identicon&r=PG&f=1", "display_name": "nate", "link": "https://stackoverflow.com/users/7102831/nate"}, "is_accepted": true, "score": 3, "last_activity_date": 1493124408, "last_edit_date": 1592644375, "creation_date": 1493089376, "answer_id": 43600870, "question_id": 43600685, "link": "https://stackoverflow.com/questions/43600685/how-can-i-print-with-formatting-when-debugging-a-rust-program-with-gdb/43600870#43600870", "title": "How can I print with formatting when debugging a Rust program with GDB?", "body": "<p>When using <code>printf</code>, it expects the expression to be either a number or a\npointer.  Pulled from <a href=\"https://sourceware.org/gdb/onlinedocs/gdb/Output.html\" rel=\"nofollow noreferrer\">Commands for Controlled Output</a></p>\n<blockquote>\n<p>printf template, expressions\u2026</p>\n<p>The expressions are separated by commas and may be either numbers or pointers</p>\n</blockquote>\n<p>If I had checked the type of <code>&quot;hello world&quot;</code> with gdb's <code>ptype</code> command, I would have noticed that it's an object and not a number or a pointer.</p>\n<pre class=\"lang-none prettyprint-override\"><code>(gdb) ptype &quot;hello world&quot;\ntype = struct &amp;str {\n  data_ptr: u8 *,\n  length: usize,\n}\n</code></pre>\n<p>To resolve this, change the argument to the string's property called <code>data_ptr</code>.</p>\n<pre class=\"lang-none prettyprint-override\"><code>(gdb) ptype &quot;hello world&quot;.data_ptr\ntype = u8 *\n\n(gdb) p &quot;hello world&quot;.data_ptr\n$14 = (u8 *) 0x101100080 &quot;hello world\\000&quot;\n</code></pre>\n<p>Returning <code>data_ptr</code> should work because it's a pointer (<code>u8 *</code>) and it points to an address that is the start of the string.</p>\n<pre class=\"lang-none prettyprint-override\"><code>(gdb) printf &quot;%s\\n&quot;, &quot;hello world&quot;.data_ptr\nhello world\n</code></pre>\n<hr />\n<p><strong>Be aware</strong> not to mix up with <code>print</code> as this <strong>wouldn't work</strong>.</p>\n<pre class=\"lang-none prettyprint-override\"><code>(gdb) print &quot;%s\\n&quot;, &quot;hello world&quot;.data_ptr\nCould not convert character to `UTF-8' character set\n</code></pre>\n"}], "owner": {"reputation": 583, "user_id": 7102831, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/52cd25404ff80b8271b3ed72a718c269?s=128&d=identicon&r=PG&f=1", "display_name": "nate", "link": "https://stackoverflow.com/users/7102831/nate"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 948, "favorite_count": 1, "accepted_answer_id": 43600870, "answer_count": 1, "score": 1, "last_activity_date": 1493124408, "creation_date": 1493088079, "last_edit_date": 1493124322, "question_id": 43600685, "link": "https://stackoverflow.com/questions/43600685/how-can-i-print-with-formatting-when-debugging-a-rust-program-with-gdb", "title": "How can I print with formatting when debugging a Rust program with GDB?", "body": "<p>When I try to print with string formatting, like I do when debugging in C, I get an error of conversion:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>(gdb) printf \"%s\\n\", \"hello world\"\nValue can't be converted to integer.\n</code></pre>\n\n<p>Expected:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>(gdb) printf \"%s\\n\", \"hello world\"\n$2 = \"hello world\"\n</code></pre>\n\n<p>Diagnostic info:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ rust-gdb -v\nGNU gdb (GDB) 7.12.1\n.....\n</code></pre>\n"}, {"tags": ["multithreading", "rust"], "answers": [{"comments": [{"owner": {"reputation": 863, "user_id": 5849285, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/UwK2I.jpg?s=128&g=1", "display_name": "Charles Shiller", "link": "https://stackoverflow.com/users/5849285/charles-shiller"}, "edited": false, "score": 0, "creation_date": 1493050336, "post_id": 43592692, "comment_id": 74235657, "body": "Thanks, although wouldn&#39;t it be more idiomatic to <code>drop()</code> variables rather than to hack scope?"}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "reply_to_user": {"reputation": 863, "user_id": 5849285, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/UwK2I.jpg?s=128&g=1", "display_name": "Charles Shiller", "link": "https://stackoverflow.com/users/5849285/charles-shiller"}, "edited": false, "score": 1, "creation_date": 1493050847, "post_id": 43592692, "comment_id": 74235980, "body": "@CharlesShiller See <a href=\"http://stackoverflow.com/q/35765440/1233251\">What are the options to end a mutable borrow in Rust?</a>. So no, blocks are as idiomatic as you can get."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1493054150, "post_id": 43592692, "comment_id": 74237892, "body": "@E_net4 in this case, <code>drop</code> should work because the lock doesn&#39;t look like a mutable borrow. I don&#39;t know that <i>either</i> is more idiomatic than the other here; <code>drop(vec)</code> just looks strange to me though."}, {"owner": {"reputation": 863, "user_id": 5849285, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/UwK2I.jpg?s=128&g=1", "display_name": "Charles Shiller", "link": "https://stackoverflow.com/users/5849285/charles-shiller"}, "edited": false, "score": 0, "creation_date": 1493058368, "post_id": 43592692, "comment_id": 74240307, "body": "Also, maybe it&#39;s the C in me, but is <code>&amp;**foo</code> different than <code>*foo</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 863, "user_id": 5849285, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/UwK2I.jpg?s=128&g=1", "display_name": "Charles Shiller", "link": "https://stackoverflow.com/users/5849285/charles-shiller"}, "edited": false, "score": 1, "creation_date": 1493061550, "post_id": 43592692, "comment_id": 74242212, "body": "@CharlesShiller see <a href=\"http://stackoverflow.com/a/28552082/155423\">stackoverflow.com/a/28552082/155423</a> for full details. TL;DR, Rust has the <code>Deref</code> trait, which means that <code>&amp;*</code> isn&#39;t always a no-op."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1493049693, "last_edit_date": 1495541869, "creation_date": 1493049336, "answer_id": 43592692, "question_id": 43592247, "link": "https://stackoverflow.com/questions/43592247/how-to-tell-rust-to-let-me-modify-a-shared-variable-hidden-behind-an-rwlock/43592692#43592692", "title": "How to tell Rust to let me modify a shared variable hidden behind an RwLock?", "body": "<p>Note that there's no structural difference between using a <code>RwLock</code> and a <code>Mutex</code>; they just have different access patterns. See \n<a href=\"https://stackoverflow.com/q/43428512/155423\">Concurrent access to vector from multiple threads using a mutex lock</a> for related discussion.</p>\n\n<p>The problem centers around the fact that you've transferred ownership of the vector (in the <code>RwLock</code>) to some thread; therefore your main thread doesn't <em>have it anymore</em>. You can't access it because it's gone.</p>\n\n<p>In fact, you'll have the same problem as you've tried to pass the vector to each of the threads. You only have one vector to give away, so only one thread could have it.</p>\n\n<p>You need <em>thread-safe shared ownership</em>, provided by <a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html\" rel=\"nofollow noreferrer\"><code>Arc</code></a>:</p>\n\n<pre><code>use std::sync::{Arc, RwLock};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    println!(\"Hello, world!\");\n    let v = vec![0, 1, 2, 3, 4, 5, 6];\n    let val = Arc::new(RwLock::new(v));\n\n    for _ in 0..10 {\n        let v = val.clone();\n        thread::spawn(move || thread_func(v));\n    }\n\n    for _ in 0..5 {\n        {\n            let mut val = val.write().unwrap();\n            val.push(1);\n        }\n        thread::sleep(Duration::from_millis(1000));\n    }\n}\n\nfn thread_func(val: Arc&lt;RwLock&lt;Vec&lt;i8&gt;&gt;&gt;) {\n    loop {\n        {\n            let val = val.read().unwrap();\n            println!(\"{}\", val.len());\n        }\n        thread::sleep(Duration::from_millis(100));\n    }\n}\n</code></pre>\n\n<p>Other things to note:</p>\n\n<ol>\n<li>I removed the infinite loop in <code>main</code> so that the code can actually finish.</li>\n<li>I fixed <strong>all of the compiler warnings</strong>. If you are going to use a compiled language, pay attention to the warnings.\n\n<ul>\n<li>unnecessary parentheses</li>\n<li><code>snake_case</code> identifiers. Definitely <strong>do not</strong> use <code>PascalCase</code> for local variables; that's used for types. <code>camelCase</code> does not get used in Rust.</li>\n</ul></li>\n<li>I added some blocks to shorten the lifetime that the read / write locks will be held. Otherwise there's a lot of contention and the child threads never have a chance to get a read lock.</li>\n<li><code>let ref v1 = *(*foo);</code> is non-idiomatic. Prefer <code>let v1 = &amp;**foo</code>. You don't even need to do that at all, thanks to <code>Deref</code>.</li>\n</ol>\n"}], "owner": {"reputation": 863, "user_id": 5849285, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/UwK2I.jpg?s=128&g=1", "display_name": "Charles Shiller", "link": "https://stackoverflow.com/users/5849285/charles-shiller"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1032, "favorite_count": 0, "accepted_answer_id": 43592692, "answer_count": 1, "score": 0, "last_activity_date": 1493049693, "creation_date": 1493048095, "last_edit_date": 1493048397, "question_id": 43592247, "link": "https://stackoverflow.com/questions/43592247/how-to-tell-rust-to-let-me-modify-a-shared-variable-hidden-behind-an-rwlock", "title": "How to tell Rust to let me modify a shared variable hidden behind an RwLock?", "body": "<p>Safe <a href=\"https://doc.rust-lang.org/book/references-and-borrowing.html\" rel=\"nofollow noreferrer\">Rust</a> demands the following from all references:</p>\n\n<ol>\n<li>One or more references (<code>&amp;T</code>) to a resource,</li>\n<li>Exactly one mutable reference (<code>&amp;mut T</code>).</li>\n</ol>\n\n<p>I want to have one <code>Vec</code> that can be read by multiple threads and written by one, but only one of those should be possible at a time (as the language demands). </p>\n\n<p>So I use an <code>RwLock</code>.</p>\n\n<p>I need a <code>Vec&lt;i8&gt;</code>. To let it outlive the main function, I <code>Box</code> it and then I <code>RwLock</code> around <em>that</em>, like thus:</p>\n\n<pre><code>fn main() {\n    println!(\"Hello, world!\");\n    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n    let val = RwLock::new(Box::new(v));\n    for i in 0..10 {\n        thread::spawn(move || threadFunc(&amp;val));\n    }\n    loop {\n        let mut VecBox = (val.write().unwrap());\n        let ref mut v1 = *(*VecBox);\n        v1.push(1);\n        //And be very busy.\n        thread::sleep(Duration::from_millis(10000));\n    }\n}\nfn threadFunc(val: &amp;RwLock&lt;Box&lt;Vec&lt;i8&gt;&gt;&gt;) {\n    loop {\n        //Use Vec\n        let VecBox = (val.read().unwrap());\n        let ref v1 = *(*VecBox);\n        println!(\"{}\", v1.len());\n        //And be very busy.\n        thread::sleep(Duration::from_millis(1000));\n    }\n}\n</code></pre>\n\n<p>Rust refuses to compile this:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code> capture of moved value: `val`\n   --&gt; src/main.rs:14:43\n      |\n   14 |         thread::spawn(move || threadFunc(&amp;val));\n      |                       -------             ^^^ value captured here after move\n      |                       |\n      |                       value moved (into closure) here\n</code></pre>\n\n<p>Without the thread:</p>\n\n<pre><code>for i in 0..10 {\n    threadFunc(&amp;val);\n}\n</code></pre>\n\n<p>It compiles. The problem is with the closure. I have to \"move\" it, or else Rust complains that it can outlive <code>main</code>, I also can't clone <code>val</code> (<code>RwLock</code> doesn't implement <code>clone()</code>).</p>\n\n<p>What should I do?</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1493063066, "post_id": 43590162, "comment_id": 74243032, "body": "Oh. Interesting!"}, {"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1493068558, "post_id": 43590162, "comment_id": 74245953, "body": "@MatthieuM. The cause seems to be some magic around <code>MutexGuard</code>. I made an oversimplified reproduction, based on on the types only. See <a href=\"https://gist.github.com/peterjoel/f6a1e1ec29da1ee73994820f742cdb7d#file-stdinlock_problem-rs\" rel=\"nofollow noreferrer\">here</a>. In the version that breaks, I&#39;m using <code>MutexGuard</code> from <code>std</code>. In the version that works, I copy-pasted the same code instead of using <code>std</code>."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 1, "creation_date": 1493083776, "post_id": 43590162, "comment_id": 74250224, "body": "Has anyone raised a bug report?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 1, "creation_date": 1493103956, "post_id": 43590162, "comment_id": 74256831, "body": "@Veedrac: Not that I know off, I was looking for an explanation as experience has proven time and time again that the borrow checker was more reliable than my intuition. Then again, in this case it looks more and more likely that something fishy is going on..."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 5, "creation_date": 1493119645, "post_id": 43590162, "comment_id": 74267416, "body": "There&#39;s a few open issues around this topic. The main one is <a href=\"https://github.com/rust-lang/rust/issues/37407\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/37407</a>"}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 2, "creation_date": 1493663178, "post_id": 43590162, "comment_id": 74492249, "body": "Discussion on this issue has proceeded in <a href=\"https://github.com/rust-lang/rust/issues/21114\" rel=\"nofollow noreferrer\">#21114</a>."}], "answers": [{"tags": [], "owner": {"reputation": 3583, "user_id": 1391026, "user_type": "registered", "accept_rate": 53, "profile_image": "https://www.gravatar.com/avatar/af98bdbeea8772f2d90d47d507098256?s=128&d=identicon&r=PG", "display_name": "musicmatze", "link": "https://stackoverflow.com/users/1391026/musicmatze"}, "is_accepted": false, "score": 3, "last_activity_date": 1515807390, "last_edit_date": 1515807390, "creation_date": 1513869474, "answer_id": 47927880, "question_id": 43590162, "link": "https://stackoverflow.com/questions/43590162/when-returning-the-outcome-of-consuming-a-stdinlock-why-was-the-borrow-to-stdin/47927880#47927880", "title": "When returning the outcome of consuming a StdinLock, why was the borrow to stdin retained?", "body": "<p>This seems to be a bug in the compiler. You can make the compiler happy by using an explicit <code>return</code> statement:</p>\n\n<pre><code>use std::io::{stdin, BufRead};\n\nfn foo() -&gt; usize {\n    let stdin = stdin();\n    let stdinlock = stdin.lock();\n    return stdinlock\n        .lines()\n        .count();\n}\n\nfn main() {}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=63b4c95351cecceb9b15047449e9aec4&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a></p>\n\n<p>As mentioned in the comments, there are multiple Rust issues related to this:</p>\n\n<ul>\n<li><a href=\"https://github.com/rust-lang/rust/issues/37407\" rel=\"nofollow noreferrer\">37407</a></li>\n<li><a href=\"https://github.com/rust-lang/rust/issues/21114\" rel=\"nofollow noreferrer\">21114</a></li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1515808315, "creation_date": 1515808315, "answer_id": 48236255, "question_id": 43590162, "link": "https://stackoverflow.com/questions/43590162/when-returning-the-outcome-of-consuming-a-stdinlock-why-was-the-borrow-to-stdin/48236255#48236255", "title": "When returning the outcome of consuming a StdinLock, why was the borrow to stdin retained?", "body": "<p>I cannot answer the <em>why</em> of your question, but I can state that the current<sup>1</sup> implementation of non-lexical lifetimes allows the original code to compile:</p>\n\n<pre><code>#![feature(nll)]\n\nuse std::io::{BufRead, stdin};\n\nfn foo() -&gt; usize {\n    let stdin = stdin();\n    let stdinlock = stdin.lock();\n    stdinlock\n        .lines()\n        .count()\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=9cd1aca50910f16ef8dd7feab6ecaf9c&amp;version=nightly\" rel=\"nofollow noreferrer\">Playground</a></p>\n\n<p><sup><strong>1</strong></sup> 1.25.0-nightly (2018-01-11 73ac5d6)</p>\n"}], "owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 624, "favorite_count": 0, "answer_count": 2, "score": 16, "last_activity_date": 1515808315, "creation_date": 1493042447, "last_edit_date": 1493054221, "question_id": 43590162, "link": "https://stackoverflow.com/questions/43590162/when-returning-the-outcome-of-consuming-a-stdinlock-why-was-the-borrow-to-stdin", "title": "When returning the outcome of consuming a StdinLock, why was the borrow to stdin retained?", "body": "<p>Given the following function:</p>\n\n<pre><code>use std::io::{BufRead, stdin};\n\nfn foo() -&gt; usize {\n    let stdin = stdin();\n    let stdinlock = stdin.lock();\n    stdinlock\n        .lines()\n        .count()\n}\n</code></pre>\n\n<p>This fails to compile with the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `stdin` does not live long enough\n  --&gt; src/main.rs:12:1\n   |\n7  |     let stdinlock = stdin.lock();\n   |                     ----- borrow occurs here\n...\n11 | }\n   | ^ `stdin` dropped here while still borrowed\n   |\n   = note: values in a scope are dropped in the opposite order they are created\n</code></pre>\n\n<p>I find this surprising because the outcome of consuming the lock (via <code>lines</code>) does not retain any references to the original source. In fact, assigning the same outcome to a binding before returning works just fine (<a href=\"https://play.integer32.com/?gist=924ab541d3b6436c1c7061f1da61eabc&amp;version=undefined\" rel=\"noreferrer\">Playground</a>).</p>\n\n<pre><code>fn bar() -&gt; usize {\n    let stdin = stdin();\n    let stdinlock = stdin.lock();\n    let r = stdinlock\n        .lines()\n        .count();\n    r\n}\n</code></pre>\n\n<p>This suggests that returning a \"consumed lock\" immediately has led to the lock attempting to live longer than the locked content, much in an unusual way. All references that I looked into usually point out that the order of declaration matters, but not how the returned objects can affect the order in which they are released.</p>\n\n<p>So why is the former function rejected by the compiler? Why is the lock being seemingly retained for longer than expected?</p>\n"}, {"tags": ["arm", "rust", "inline-assembly", "linker-scripts"], "comments": [{"owner": {"reputation": 2978, "user_id": 904148, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/4cf9d0b9f5d61826525247bd5b79cdc0?s=128&d=identicon&r=PG", "display_name": "Timothy Baldwin", "link": "https://stackoverflow.com/users/904148/timothy-baldwin"}, "edited": false, "score": 0, "creation_date": 1493054114, "post_id": 43587210, "comment_id": 74237864, "body": "It appears you are using GNU AS, you don&#39;t to do anything to import an external symbol, just use it (with the correct relocation type)."}], "owner": {"reputation": 7497, "user_id": 1213227, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/78179ef730f268752c0f6fdde3943b99?s=128&d=identicon&r=PG", "display_name": "Matthias", "link": "https://stackoverflow.com/users/1213227/matthias"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 425, "favorite_count": 1, "answer_count": 0, "score": 3, "last_activity_date": 1493034373, "creation_date": 1493034373, "last_edit_date": 1495540956, "question_id": 43587210, "link": "https://stackoverflow.com/questions/43587210/import-of-linker-symbols-for-inline-assembler-in-rust", "title": "Import of linker symbols for inline assembler in Rust", "body": "<p>I want to access a linker symbol defined in the linker file in inline assembler in Rust for an ARM target. However, </p>\n\n<pre><code>asm!(\".import mysymb\");\n</code></pre>\n\n<p>leads to</p>\n\n<blockquote>\n  <p>error: :1:2: error: unknown directive\n          .import mysymb</p>\n</blockquote>\n\n<p>Using <code>.extern</code> (as suggested <a href=\"https://stackoverflow.com/questions/20366004/arm-assembly-access-to-c-global-variable\">here</a>) results in:</p>\n\n<blockquote>\n  <p>LLVM ERROR: unsupported relocation on symbol</p>\n</blockquote>\n\n<p>What is the correct way to introduce this symbol?</p>\n"}, {"tags": ["rust", "rust-cargo"], "answers": [{"comments": [{"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1493026481, "post_id": 43578288, "comment_id": 74218041, "body": "This is, what I eventually did. I just wanted to verify there is a cleaner, less hacky way of achieving this."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1493035333, "post_id": 43578288, "comment_id": 74224210, "body": "@DanielFath if it&#39;s the kind of thing you find useful, perhaps others would too. You could submit a PR to Cargo to add it! ^_^"}, {"owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "edited": false, "score": 0, "creation_date": 1493039249, "post_id": 43578288, "comment_id": 74227234, "body": "Already made an issue, <a href=\"https://github.com/rust-lang/cargo/issues/3946\" rel=\"nofollow noreferrer\">2hrs ago</a> I&#39;ll think about that PR."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1493001052, "last_edit_date": 1493001052, "creation_date": 1492996184, "answer_id": 43578288, "question_id": 43577885, "link": "https://stackoverflow.com/questions/43577885/is-there-a-cargo-environment-variable-for-the-workspace-directory/43578288#43578288", "title": "Is there a Cargo environment variable for the workspace directory?", "body": "<p>No, not for the version of Cargo bundled with Rust 1.16.0. You can verify this yourself by printing out all of the environment variables in the build script:</p>\n\n<pre><code>use std::fs::File;\nuse std::io::Write;\n\nfn main() {\n    let mut dump = File::create(\"/tmp/dump\").expect(\"unable to open\");\n    for (k, v) in std::env::vars() {\n        writeln!(&amp;mut dump, \"{} -&gt; {}\", k, v).expect(\"unable to write\")\n    }\n}\n</code></pre>\n\n<p>On my machine, this produces:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ sort /tmp/dump | grep CARGO\nCARGO_CFG_DEBUG_ASSERTIONS -&gt;\nCARGO_CFG_TARGET_ARCH -&gt; x86_64\nCARGO_CFG_TARGET_ENDIAN -&gt; little\nCARGO_CFG_TARGET_ENV -&gt;\nCARGO_CFG_TARGET_FAMILY -&gt; unix\nCARGO_CFG_TARGET_OS -&gt; macos\nCARGO_CFG_TARGET_POINTER_WIDTH -&gt; 64\nCARGO_CFG_UNIX -&gt;\nCARGO_HOME -&gt; /Users/shep/.cargo\nCARGO_MANIFEST_DIR -&gt; /private/tmp/the-workspace/project-a\nCARGO_PKG_AUTHORS -&gt; An Devloper &lt;an.devloper@example.com&gt;\nCARGO_PKG_DESCRIPTION -&gt;\nCARGO_PKG_HOMEPAGE -&gt;\nCARGO_PKG_NAME -&gt; project-a\nCARGO_PKG_VERSION -&gt; 0.1.0\nCARGO_PKG_VERSION_MAJOR -&gt; 0\nCARGO_PKG_VERSION_MINOR -&gt; 1\nCARGO_PKG_VERSION_PATCH -&gt; 0\nCARGO_PKG_VERSION_PRE -&gt;\n</code></pre>\n\n<hr>\n\n<p>I'm not sure why you can't just do</p>\n\n<pre><code>Path::new(&amp;manifest_dir).join(\"..\").join(\"Dep\").join(\"test.json\")\n</code></pre>\n\n<p>I've split each directory into a separate call \u2014 avoiding the need to specify the directory separator at all to be platform agnostic.</p>\n"}], "owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1507, "favorite_count": 0, "accepted_answer_id": 43578288, "answer_count": 1, "score": 3, "last_activity_date": 1493001052, "creation_date": 1492992507, "last_edit_date": 1492995509, "question_id": 43577885, "link": "https://stackoverflow.com/questions/43577885/is-there-a-cargo-environment-variable-for-the-workspace-directory", "title": "Is there a Cargo environment variable for the workspace directory?", "body": "<p>I have the following projects in a workspace:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Workspacefolder\n |\n +-- Project A\n |    |\n |    +-- build.rs\n |\n +-- Dep\n |    |\n |    +-- test.json  \n |\n +-Cargo.toml\n</code></pre>\n\n<p>In <code>Project A</code>, there is <code>build.rs</code> that wants to open <code>test.json</code> in a way that doesn't rely on platform and that works well with CI.  </p>\n\n<p>I'm looking for a <code>CARGO_WORKSPACE</code> environment variable, because then I can say <code>Path::new(&amp;workspace_dir).join(\"/Dep/test.json\")</code>.</p>\n"}, {"tags": ["rust", "kcov"], "answers": [{"tags": [], "owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "is_accepted": true, "score": 4, "last_activity_date": 1492935191, "last_edit_date": 1495542354, "creation_date": 1492935191, "answer_id": 43568852, "question_id": 43567196, "link": "https://stackoverflow.com/questions/43567196/kcov-is-reporting-100-for-rust-lib-even-though-some-methods-are-not-covered/43568852#43568852", "title": "Kcov is reporting 100% for Rust lib even though some methods are not covered", "body": "<p>This is a known issue (<a href=\"https://github.com/rust-lang/rust/issues/39293\" rel=\"nofollow noreferrer\">https://github.com/rust-lang/rust/issues/39293</a>), with no solutions implemented yet. Generics in Rust are <a href=\"https://stackoverflow.com/questions/14189604/what-is-monomorphisation-with-context-to-c\">similar to templates in C++</a>, if you don't use the generic function, no code will be generated at all. Indeed those functions are not present:</p>\n\n<pre><code>$ nm target/debug/defaultmap-2fd0c3085042f647 | grep DefaultHashMap | cargo demangle\n000000000002c350 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt; as core::ops::Index&lt;KB&gt;&gt;::index::h14fb5e24128b7e47\n000000000002c390 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt; as core::ops::Index&lt;KB&gt;&gt;::index::h5c00e602e45f6925\n000000000002c3d0 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt; as core::ops::Index&lt;KB&gt;&gt;::index::hc5dfb7b3478d945a\n000000000002c420 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt; as core::ops::IndexMut&lt;K&gt;&gt;::index_mut::h8b298bf16464a070\n000000000002c470 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt; as core::ops::IndexMut&lt;K&gt;&gt;::index_mut::hcc509def35f89759\n000000000002bfc0 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt;&gt;::get::h6a0f4cb5c61c67e8\n000000000002c060 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt;&gt;::get::ha5fdb528b5dd94a5\n000000000002c110 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt;&gt;::get::hc1a5643986209ba6\n000000000002c1b0 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt;&gt;::get_mut::h14f0ded6ba3206f3\n000000000002c2a0 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt;&gt;::get_mut::h6ea36d917e778099\n000000000002eaf0 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt; as core::fmt::Debug&gt;::fmt::h2cefa624bd18fcfe\n000000000002e9e0 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt; as core::default::Default&gt;::default::h0b736edcd6ac228a\n000000000002ea60 t &lt;defaultmap::hashmap::DefaultHashMap&lt;K, V&gt; as core::default::Default&gt;::default::hd09b7abe1e63b94f\n</code></pre>\n\n<p>I think, for now, the only practical solution is to manually inspect the coverage report, and add back missing tests for the ignored functions.</p>\n"}], "owner": {"reputation": 2159, "user_id": 2570866, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/719063be2f6f7ca6be51df7833a26c25?s=128&d=identicon&r=PG", "display_name": "JelteF", "link": "https://stackoverflow.com/users/2570866/jeltef"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 218, "favorite_count": 0, "accepted_answer_id": 43568852, "answer_count": 1, "score": 4, "last_activity_date": 1492935191, "creation_date": 1492919659, "last_edit_date": 1495542354, "question_id": 43567196, "link": "https://stackoverflow.com/questions/43567196/kcov-is-reporting-100-for-rust-lib-even-though-some-methods-are-not-covered", "title": "Kcov is reporting 100% for Rust lib even though some methods are not covered", "body": "<p>I'm trying to add code coverage to my rust library. It's reporting that it is covered 100%, but when I look at the report a lot of lines are not counted: <a href=\"https://codecov.io/gh/JelteF/defaultmap/src/c878e108c61f270718c909e1500c4c2e865a33d1/src/lib.rs#L93...106\" rel=\"nofollow noreferrer\">https://codecov.io/gh/JelteF/defaultmap/src/c878e108c61f270718c909e1500c4c2e865a33d1/src/lib.rs#L93...106</a></p>\n\n<p>What is the reason for this and is it possible to fix this? I have already tried setting RUSTFLAGS to \"-C link-dead-code\" as suggested in this answer: <a href=\"https://stackoverflow.com/a/38371687/2570866\">https://stackoverflow.com/a/38371687/2570866</a>\nThat didn't help however.</p>\n"}, {"tags": ["input", "printing", "rust"], "answers": [{"comments": [{"owner": {"reputation": 399, "user_id": 2139291, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/8E5jB.jpg?s=128&g=1", "display_name": "creativcoder", "link": "https://stackoverflow.com/users/2139291/creativcoder"}, "edited": false, "score": 0, "creation_date": 1493272844, "post_id": 43567345, "comment_id": 74347246, "body": "io::stdin().read_line() does not preprocess the line read, so a &#39;\\n&#39; remains at the end. So it needs the extra trim() call, though ideally read_line() as it name suggests should do this by itself in order to provide better api to users."}], "tags": [], "owner": {"reputation": 388, "user_id": 7903988, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/7n42a.png?s=128&g=1", "display_name": "4e554c4c", "link": "https://stackoverflow.com/users/7903988/4e554c4c"}, "is_accepted": false, "score": 8, "last_activity_date": 1551190173, "last_edit_date": 1551190173, "creation_date": 1492921343, "answer_id": 43567345, "question_id": 43567092, "link": "https://stackoverflow.com/questions/43567092/how-to-ignore-the-line-break-while-printing-a-string-read-from-stdin/43567345#43567345", "title": "How to ignore the line break while printing a string read from stdin?", "body": "<p>Use <a href=\"https://doc.rust-lang.org/stable/std/primitive.str.html#method.trim\" rel=\"nofollow noreferrer\"><code>.trim()</code></a> to remove whitespace on a string. This example should work.</p>\n\n<pre><code>use std::io;\n\nfn main() {\n    println!(\"Enter your name:\");\n    let mut name = String::new();\n    io::stdin().read_line(&amp;mut name).expect(\"Failed To read Input\");\n    println!(\"Hello '{}'!\", name.trim());\n}\n</code></pre>\n\n<p>There also <a href=\"https://doc.rust-lang.org/stable/std/primitive.str.html#method.trim_start\" rel=\"nofollow noreferrer\"><code>trim_start()</code></a> and <a href=\"https://doc.rust-lang.org/stable/std/primitive.str.html#method.trim_end\" rel=\"nofollow noreferrer\"><code>.trim_end()</code></a> if you need to remove whitespace changes from only one side of the string.</p>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1551190212, "post_id": 54882912, "comment_id": 96543768, "body": "This does not handle the case when the newline is multiple characters, such as when it&#39;s <code>\\r\\n</code>."}], "tags": [], "owner": {"reputation": 938, "user_id": 3894179, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8c6b1c2c08d1075995cb780ee8a2e36e?s=128&d=identicon&r=PG", "display_name": "Andra", "link": "https://stackoverflow.com/users/3894179/andra"}, "is_accepted": false, "score": 0, "last_activity_date": 1551175380, "creation_date": 1551175380, "answer_id": 54882912, "question_id": 43567092, "link": "https://stackoverflow.com/questions/43567092/how-to-ignore-the-line-break-while-printing-a-string-read-from-stdin/54882912#54882912", "title": "How to ignore the line break while printing a string read from stdin?", "body": "<p>If you want to remove the last character only (in this case is newline character), you should use <a href=\"https://doc.rust-lang.org/stable/std/primitive.str.html#method.trim\" rel=\"nofollow noreferrer\"><code>.pop()</code></a> instead of <a href=\"https://doc.rust-lang.org/stable/std/primitive.str.html#method.trim\" rel=\"nofollow noreferrer\"><code>.trim()</code></a>.</p>\n\n<p>When you use <code>.trim()</code>, the leading and trailing whitespace(s) will be removed, so the space, tab, newline, and the other whitespace in the beginning and the end of the string will be removed.</p>\n\n<pre><code>use std::io;\n\nfn main() {\n    println!(\"Enter your name:\");\n    let mut name = String::new();\n    io::stdin().read_line(&amp;mut name).expect(\"Failed To read Input\");\n    name.pop();\n    println!(\"Hello '{}'!\", name);\n}\n</code></pre>\n"}], "owner": {"reputation": 113, "user_id": 6050592, "user_type": "registered", "accept_rate": 20, "profile_image": "https://www.gravatar.com/avatar/39ddd02374d1687804a2dbd1be5f1656?s=128&d=identicon&r=PG", "display_name": "Sriram", "link": "https://stackoverflow.com/users/6050592/sriram"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1191, "favorite_count": 2, "answer_count": 2, "score": 5, "last_activity_date": 1551190173, "creation_date": 1492918438, "last_edit_date": 1492952656, "question_id": 43567092, "link": "https://stackoverflow.com/questions/43567092/how-to-ignore-the-line-break-while-printing-a-string-read-from-stdin", "title": "How to ignore the line break while printing a string read from stdin?", "body": "<p>I tried to write a bit of code which reads a name from stdin and prints it. The problem is the line breaks immediately after printing the variable and the characters following the variable are printed in the next line:</p>\n\n<pre><code>use std::io;\n\nfn main() {\n    println!(\"Enter your name:\");\n    let mut name = String::new();\n    io::stdin().read_line(&amp;mut name).expect(\"Failed To read Input\");\n    println!(\"Hello '{}'!\", name);\n}\n</code></pre>\n\n<p>The '!' is printed in the next line, which is not the expected location.</p>\n\n<p><a href=\"https://i.stack.imgur.com/dr94U.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/dr94U.png\" alt=\"enter image description here\"></a></p>\n"}, {"tags": ["vector", "rust", "closures", "mutable"], "comments": [{"owner": {"reputation": 145, "user_id": 4983930, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/e2d50ab284fecc7f6b2ba41bb6a522ec?s=128&d=identicon&r=PG&f=1", "display_name": "rytone", "link": "https://stackoverflow.com/users/4983930/rytone"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1492903979, "post_id": 43565596, "comment_id": 74182253, "body": "@Shepmaster Oh, huh. I somehow managed to look at every single one of those questions that didn&#39;t quite apply to my situation, and not the ones that answered my question. Sorry about that. Looks like <code>RefCell</code> is the solution to my problem"}, {"owner": {"reputation": 145, "user_id": 4983930, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/e2d50ab284fecc7f6b2ba41bb6a522ec?s=128&d=identicon&r=PG&f=1", "display_name": "rytone", "link": "https://stackoverflow.com/users/4983930/rytone"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1492904225, "post_id": 43565596, "comment_id": 74182311, "body": "<a href=\"http://stackoverflow.com/questions/38027461/execute-callbacks-like-as-mutable-borrowing-from-cycle\" title=\"execute callbacks like as mutable borrowing from cycle\">stackoverflow.com/questions/38027461/&hellip;</a> and <a href=\"http://stackoverflow.com/questions/43552480/whats-the-correct-way-to-implement-the-equivalent-of-multiple-mutable-statical\" title=\"whats the correct way to implement the equivalent of multiple mutable statical\">stackoverflow.com/questions/43552480/&hellip;</a> helped."}], "owner": {"reputation": 145, "user_id": 4983930, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/e2d50ab284fecc7f6b2ba41bb6a522ec?s=128&d=identicon&r=PG&f=1", "display_name": "rytone", "link": "https://stackoverflow.com/users/4983930/rytone"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 193, "favorite_count": 0, "closed_date": 1492904377, "answer_count": 0, "score": 0, "last_activity_date": 1492904390, "creation_date": 1492902577, "last_edit_date": 1492903432, "question_id": 43565596, "link": "https://stackoverflow.com/questions/43565596/sharing-a-mutable-vector-between-multiple-closures", "closed_reason": "Duplicate", "title": "Sharing a mutable vector between multiple closures", "body": "<p>I am writing a program that uses <a href=\"https://github.com/tomaka/hlua\" rel=\"nofollow noreferrer\">hlua</a> to call Lua code that pushes to a <code>Vec</code>. The problem is, I have multiple Lua methods that push to the same <code>Vec</code>. Here is a very simplified version of what I am trying to do:</p>\n\n<pre><code>let mut vec = Vec::new();\n{\n    let mut lua = Lua::new();\n\n    // these functions do different things in my actual code\n    lua.set(\"pushA\", hlua::function1(|s: String| {\n        vec.push(s);\n    }));\n    lua.set(\"pushB\", hlua::function1(|s: String| {\n        vec.push(s);\n    }));\n\n    lua.execute::&lt;()&gt;(\"...\");\n}\n</code></pre>\n\n<p>The compiler errors with this: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0499]: cannot borrow `vec` as mutable more than once at a time\n  --&gt; src/main.rs:11:42\n   |\n10 |         lua.set(\"pushA\", hlua::function1(|s: String| { vec.push(s); }));\n   |                                          -----------   --- previous borrow occurs due to use of `vec` in closure\n   |                                          |\n   |                                          first mutable borrow occurs here\n11 |         lua.set(\"pushB\", hlua::function1(|s: String| { vec.push(s); }));\n   |                                          ^^^^^^^^^^^   --- borrow occurs due to use of `vec` in closure\n   |                                          |\n   |                                          second mutable borrow occurs here\n...\n14 |     }\n   |     - first borrow ends here\n</code></pre>\n\n<p>which I understand, but I can't come up with a solution to my problem where this would not occur in one way or another. I am very new with Rust, so this may be a dumb question.</p>\n"}, {"tags": ["rust", "polymorphism"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 5, "last_activity_date": 1492902581, "creation_date": 1492902581, "answer_id": 43565597, "question_id": 43565537, "link": "https://stackoverflow.com/questions/43565537/polymorphism-in-rust-and-trait-references-trait-objects/43565597#43565597", "title": "Polymorphism in Rust and trait references (trait objects?)", "body": "<p>Trait objects must be used behind a pointer. But references are not the only kind of pointers; <code>Box</code> is also a pointer!</p>\n\n<pre><code>let mut scanner: Option&lt;Box&lt;Scanner&gt;&gt; = None;\n\nscanner = match scanner_type {\n    ScannerType::Winapi =&gt; Some(Box::new(WinapiScanner::new()))\n}\n</code></pre>\n"}], "owner": {"reputation": 400, "user_id": 5840215, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-OjikolJf9jA/AAAAAAAAAAI/AAAAAAAAABc/hDIYGC4S52E/photo.jpg?sz=128", "display_name": "lem0nify", "link": "https://stackoverflow.com/users/5840215/lem0nify"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 351, "favorite_count": 0, "accepted_answer_id": 43565597, "answer_count": 1, "score": 1, "last_activity_date": 1492903371, "creation_date": 1492902008, "last_edit_date": 1492903371, "question_id": 43565537, "link": "https://stackoverflow.com/questions/43565537/polymorphism-in-rust-and-trait-references-trait-objects", "title": "Polymorphism in Rust and trait references (trait objects?)", "body": "<p>I'm writing a process memory scanner with a console prompt interface in Rust.</p>\n\n<p>I need scanner types such as a winapi scanner or a ring0 driver scanner so I'm trying to implement polymorphism.</p>\n\n<p>I have the following construction at this moment:</p>\n\n<pre><code>pub trait Scanner {\n    fn attach(&amp;mut self, pid: u32) -&gt; bool;\n    fn detach(&amp;mut self);\n}\n\npub struct WinapiScanner {\n    pid: u32,\n    hprocess: HANDLE,\n    addresses: Vec&lt;usize&gt;\n}\n\nimpl WinapiScanner {\n    pub fn new() -&gt; WinapiScanner {\n        WinapiScanner {\n            pid: 0,\n            hprocess: 0 as HANDLE,\n            addresses: Vec::&lt;usize&gt;::new()\n        }\n    }\n}\n\nimpl Scanner for WinapiScanner {\n    fn attach(&amp;mut self, pid: u32) -&gt; bool {\n        let handle = unsafe { OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid) };\n        if handle == 0 as HANDLE {\n            self.pid = pid;\n            self.hprocess = handle;\n            true\n        } else {\n            false\n        }\n    }\n\n    fn detach(&amp;mut self) {\n        unsafe { CloseHandle(self.hprocess) };\n        self.pid = 0;\n        self.hprocess = 0 as HANDLE;\n        self.addresses.clear();\n    }\n}\n</code></pre>\n\n<p>In future, I'll have some more scanner types besides <code>WinapiScanner</code>, so, if I understand correctly, I should use a trait reference (<code>&amp;Scanner</code>) to implement polymorphism.  I'm trying to create <code>Scanner</code> object like this (note the comments):</p>\n\n<pre><code>enum ScannerType {\n    Winapi\n}\n\npub fn start() {\n    let mut scanner: Option&lt;&amp;mut Scanner&gt; = None;\n    let mut scanner_type = ScannerType::Winapi;\n\n    loop {\n        let line = prompt();\n        let tokens: Vec&lt;&amp;str&gt; = line.split_whitespace().collect();\n        match tokens[0] {\n\n            // commands\n            \"scanner\" =&gt; {\n                if tokens.len() != 2 {\n                    println!(\"\\\"scanner\\\" command takes 1 argument\")\n                } else {\n                    match tokens[1] {\n                        \"list\" =&gt; {\n                            println!(\"Available scanners: winapi\");\n                        },\n                        \"winapi\" =&gt; {\n                            scanner_type = ScannerType::Winapi;\n                            println!(\"Scanner type set to: winapi\");\n                        },\n                        x =&gt; {\n                            println!(\"Unknown scanner type: {}\", x);\n                        }\n                    }\n                }\n            },\n            \"attach\" =&gt; {\n                if tokens.len() &gt; 1 {\n                    match tokens[1].parse::&lt;u32&gt;() {\n                        Ok(pid) =&gt; {\n                            scanner = match scanner_type {\n                                // ----------------------\n                                // Problem goes here.\n                                // Object, created by WinapiScanner::new() constructor\n                                // doesn't live long enough to borrow it here\n                                ScannerType::Winapi =&gt; Some(&amp;mut WinapiScanner::new())\n                                // ----------------------\n                            }\n                        }\n                        Err(_) =&gt; {\n                            println!(\"Wrong pid\");\n                        }\n                    }\n                }\n            },\n\n            x =&gt; println!(\"Unknown command: {}\", x)\n        }\n    }\n}\n\nfn prompt() -&gt; String {\n    use std::io::Write;\n    use std::io::BufRead;\n\n    let stdout = io::stdout();\n    let mut lock = stdout.lock();\n    let _ = lock.write(\"&gt;&gt; \".as_bytes());\n    let _ = lock.flush();\n    let stdin = io::stdin();\n    let mut lock = stdin.lock();\n    let mut buf = String::new();\n    let _ = lock.read_line(&amp;mut buf);\n    String::from(buf.trim())\n}\n</code></pre>\n\n<p>It's not a full program; I've pasted important parts only.</p>\n\n<p>What am I doing wrong and how do I implement what I want in Rust?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "edited": false, "score": 0, "creation_date": 1492859153, "post_id": 43558362, "comment_id": 74167996, "body": "Could you wrap a <code>RefCell&lt;HashMap&gt;</code> instead of just a <code>HashMap</code>?"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "edited": false, "score": 0, "creation_date": 1492859245, "post_id": 43558362, "comment_id": 74168019, "body": "@PeterHall Sadly, no. The <code>index()</code> method would need to return a <code>Ref&lt;V&gt;</code> instead of <code>&amp;V</code> in order for this to work. I&#39;d say the only sane way to do what JelteF wants is to write a standard method <code>get()</code> and either use <code>RefCell</code> or <code>&amp;mut self</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492952814, "post_id": 43558362, "comment_id": 74192624, "body": "See also <a href=\"http://stackoverflow.com/q/31141363/155423\">Default mutable value from HashMap</a>; <a href=\"http://stackoverflow.com/q/36141804/155423\">How to write a safe wrap for HashMap with default value</a>; <a href=\"http://stackoverflow.com/q/41417660/155423\">How does one create a HashMap with a default value in Rust?</a>; and <a href=\"http://stackoverflow.com/q/28512394/155423\">How to lookup from and insert into a HashMap efficiently?</a>."}], "answers": [{"comments": [{"owner": {"reputation": 2159, "user_id": 2570866, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/719063be2f6f7ca6be51df7833a26c25?s=128&d=identicon&r=PG", "display_name": "JelteF", "link": "https://stackoverflow.com/users/2570866/jeltef"}, "edited": false, "score": 1, "creation_date": 1492955194, "post_id": 43571171, "comment_id": 74193503, "body": "Thanks for the great and indepth answer! After trying to get RefCell working for a couple of hours I realised your part about reference invalidation. I then opted for your first solution to just not insert them into the map and document this. Because after thinking about the consequenses of this it normally does not indeed and if you really want to insert on access you could still use the <code>get_mut</code> method directly. The final crate can be found here in case you&#39;re interested: <a href=\"https://github.com/JelteF/defaultmap\" rel=\"nofollow noreferrer\">github.com/JelteF/defaultmap</a>"}], "tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": true, "score": 5, "last_activity_date": 1492954014, "last_edit_date": 1492954014, "creation_date": 1492950551, "answer_id": 43571171, "question_id": 43558362, "link": "https://stackoverflow.com/questions/43558362/implementing-only-indexmut-without-implementing-index/43571171#43571171", "title": "Implementing only IndexMut without implementing Index", "body": "<p>First, I suspect that your requirement \"<em>when getting a key that is not in the map the default value is put in that key</em>\" is not exactly required!</p>\n\n<p>Consider an immutable access <code>let foo = default_hash_map[bar] + 123;</code>. Unless you're going to use values with interior mutability with the map it might be inconsequential whether <code>default_hash_map[bar]</code> is actually creating a key or <strong>just returns a reference to a single default value</strong>.</p>\n\n<p>Now, if you really need to create new entries during access then there is a way to do this. The borrow checker restriction that only allows you to add new entries with a mutable access is here to stop you from creating the dangling pointers that would occur whenever you modify the map while holding the references in there. But if you were using a structure with stable references, where stable means that the references are not invalidated when you enter new entries into the structure, then the problem the borrow checker is trying to prevent will go away.</p>\n\n<p>In C++ I would've considered using a <a href=\"http://en.cppreference.com/w/cpp/container/deque\" rel=\"nofollow noreferrer\">deque</a> which is guaranteed by the standard not to invalidate its references when you add new entries to it. Unfortunately, Rust deques are different (though you can probably find <em>arena allocator</em> crates with properties similar to the C++ deque) and so for this example I'm using <code>Box</code>. The boxed values reside separately on the heap and aren't moved when you add new entries into <code>HashMap</code>.</p>\n\n<p>Now, your normal access pattern is probably going to be <em>modifying</em> the new entries and then accessing the <em>existing</em> entries of the map. Thus making new entries in <code>Index::index</code> is an exception and shouldn't slow down the rest of the map. It might make sense therefore to pay the boxing price only for the <code>Index::index</code> access. To do that we might use a second structure, that keeps just the boxed <code>Index::index</code> values.</p>\n\n<p>Knowing that <code>HashMap&lt;K, Box&lt;V&gt;&gt;</code> can be inserted into without invalidating the existing <code>V</code> refereces allows us to use it as a temporary buffer, holding the <code>Index::index</code>-created values until we get a chance to synchronize them with the primary <code>HashMap</code>.</p>\n\n\n\n<pre><code>use std::borrow::Borrow;\nuse std::cell::UnsafeCell;\nuse std::collections::HashMap;\nuse std::hash::Hash;\nuse std::ops::Index;\nuse std::ops::IndexMut;\n\nstruct DefaultHashMap&lt;K, V&gt;(HashMap&lt;K, V&gt;, UnsafeCell&lt;HashMap&lt;K, Box&lt;V&gt;&gt;&gt;, V);\n\nimpl&lt;K, V&gt; DefaultHashMap&lt;K, V&gt;\n    where K: Eq + Hash\n{\n    fn sync(&amp;mut self) {\n        let buf_map = unsafe { &amp;mut *self.1.get() };\n        for (k, v) in buf_map.drain() {\n            self.0.insert(k, *v);\n        }\n    }\n}\n\nimpl&lt;'a, K, V, Q: ?Sized&gt; Index&lt;&amp;'a Q&gt; for DefaultHashMap&lt;K, V&gt;\n    where K: Eq + Hash + Clone,\n          K: Borrow&lt;Q&gt;,\n          K: From&lt;&amp;'a Q&gt;,\n          Q: Eq + Hash,\n          V: Clone\n{\n    type Output = V;\n\n    fn index(&amp;self, key: &amp;'a Q) -&gt; &amp;V {\n        if let Some(v) = self.0.get(key) {\n            v\n        } else {\n            let buf_map: &amp;mut HashMap&lt;K, Box&lt;V&gt;&gt; = unsafe { &amp;mut *self.1.get() };\n            if !buf_map.contains_key(key) {\n                buf_map.insert(K::from(key), Box::new(self.2.clone()));\n            }\n            &amp;*buf_map.get(key).unwrap()\n        }\n    }\n}\n\nimpl&lt;'a, K, V, Q: ?Sized&gt; IndexMut&lt;&amp;'a Q&gt; for DefaultHashMap&lt;K, V&gt;\n    where K: Eq + Hash + Clone,\n          K: Borrow&lt;Q&gt;,\n          K: From&lt;&amp;'a Q&gt;,\n          Q: Eq + Hash,\n          V: Clone\n{\n    fn index_mut(&amp;mut self, key: &amp;'a Q) -&gt; &amp;mut V {\n        self.sync();\n        if self.0.contains_key(key) {\n            self.0.get_mut(key).unwrap()\n        } else {\n            self.0.insert(K::from(key), self.2.clone());\n            self.0.get_mut(key).unwrap()\n        }\n    }\n}\n\nfn main() {\n    {\n        let mut dhm = DefaultHashMap::&lt;String, String&gt;(HashMap::new(),\n                                                       UnsafeCell::new(HashMap::new()),\n                                                       \"bar\".into());\n        for i in 0..10000 {\n            dhm[&amp;format!(\"{}\", i % 1000)[..]].push('x')\n        }\n        println!(\"{:?}\", dhm.0);\n    }\n\n    {\n        let mut dhm = DefaultHashMap::&lt;String, String&gt;(HashMap::new(),\n                                                       UnsafeCell::new(HashMap::new()),\n                                                       \"bar\".into());\n        for i in 0..10000 {\n            let key = format!(\"{}\", i % 1000);\n            assert!(dhm[&amp;key].len() &gt;= 3);\n            dhm[&amp;key[..]].push('x');\n        }\n        println!(\"{:?}\", dhm.0);\n    }\n\n    {\n        #[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n        struct K(u32);\n        impl&lt;'a&gt; From&lt;&amp;'a u32&gt; for K {\n            fn from(v: &amp;u32) -&gt; K {\n                K(*v)\n            }\n        }\n        impl&lt;'a&gt; Borrow&lt;u32&gt; for K {\n            fn borrow(&amp;self) -&gt; &amp;u32 {\n                &amp;self.0\n            }\n        }\n        let mut dhm = DefaultHashMap::&lt;K, K&gt;(HashMap::new(),\n                                             UnsafeCell::new(HashMap::new()),\n                                             K::from(&amp;123));\n        for i in 0..10000 {\n            let key = i % 1000;\n            assert!(dhm[&amp;key].0 &gt;= 123);\n            dhm[&amp;key].0 += 1;\n        }\n        println!(\"{:?}\", dhm.0);\n    }\n}\n</code></pre>\n\n<p>(<a href=\"http://play.integer32.com/?gist=aba79959e59fdc75923d01173fe25fb8&amp;version=nightly\" rel=\"nofollow noreferrer\">playground</a>)</p>\n\n<p>Note that boxing only stabilizes the insertion of new entries. To <em>remove</em> the boxed entries you still need the mutable (<code>&amp;mut self</code>) access to <code>DefaultHashMap</code>.</p>\n"}], "owner": {"reputation": 2159, "user_id": 2570866, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/719063be2f6f7ca6be51df7833a26c25?s=128&d=identicon&r=PG", "display_name": "JelteF", "link": "https://stackoverflow.com/users/2570866/jeltef"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 340, "favorite_count": 0, "accepted_answer_id": 43571171, "answer_count": 1, "score": 5, "last_activity_date": 1492954014, "creation_date": 1492858477, "last_edit_date": 1492860509, "question_id": 43558362, "link": "https://stackoverflow.com/questions/43558362/implementing-only-indexmut-without-implementing-index", "title": "Implementing only IndexMut without implementing Index", "body": "<p>I'm trying to create a <code>DefaultHashMap</code> struct which is basically a wrapper around <code>HashMap</code>, with the difference that when getting a key that is not in the map the default value is put in that key and is returned.</p>\n\n<p>I made a <code>get</code> and a <code>get_mut</code> method and this works fine. Now I'm trying to implement <code>Index</code> and <code>IndexMut</code> as wrappers around those methods. Here I'm running into two problems. </p>\n\n<p>The first problem is caused by the fact that <code>get</code> has to mutate the struct when the key is not present it requires a mutable reference. However, the signature for the <code>index</code> method of <code>Index</code> has <code>&amp;self</code> instead of <code>&amp;mut self</code>, so I cannot implement it.</p>\n\n<p>This causes a second problem, <code>IndexMut</code> requires an <code>Index</code> implementation. So even though <code>IndexMut</code> would have no problems being implemented I cannot do this because <code>Index</code> cannot be implemented.</p>\n\n<p>The first problem is annoying but understandable. For the second one, I don't get why the requirement is even there. I would like to have a way to work around it. Right now I'm doing the following, but I hope someone has a better solution:</p>\n\n<pre><code>impl&lt;K: Eq + Hash, V: Clone&gt; Index&lt;K&gt; for DefaultHashMap&lt;K, V&gt; {\n    type Output = V;\n\n    fn index(&amp;self, _: K) -&gt; &amp;V {\n        panic!(\"DefautHashMap doesn't implement indexing without mutating\")\n    }\n}\n\nimpl&lt;K: Eq + Hash, V: Clone&gt; IndexMut&lt;K&gt; for DefaultHashMap&lt;K, V&gt; {\n    #[inline]\n    fn index_mut(&amp;mut self, index: K) -&gt; &amp;mut V {\n        self.get_mut(index)\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 9, "last_activity_date": 1492857237, "creation_date": 1492857237, "answer_id": 43558165, "question_id": 43557542, "link": "https://stackoverflow.com/questions/43557542/how-to-conditionally-skip-tests-based-on-runtime-information/43558165#43558165", "title": "How to conditionally skip tests based on runtime information?", "body": "<p>There is nothing built in for this; tests only succeed or fail.</p>\n\n<p>The built in test runner is very minimal.</p>\n"}], "owner": {"reputation": 6933, "user_id": 2580955, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/WZR9N.jpg?s=128&g=1", "display_name": "s3rvac", "link": "https://stackoverflow.com/users/2580955/s3rvac"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1032, "favorite_count": 0, "answer_count": 1, "score": 12, "last_activity_date": 1492857237, "creation_date": 1492853387, "question_id": 43557542, "link": "https://stackoverflow.com/questions/43557542/how-to-conditionally-skip-tests-based-on-runtime-information", "title": "How to conditionally skip tests based on runtime information?", "body": "<p>Is it possible to programmatically skip some tests based on runtime information? For example, I would like <code>cargo test</code> to emit something like</p>\n\n<pre><code>test my_test ... skipped\n</code></pre>\n\n<p>instead of</p>\n\n<pre><code>test my_test ... ok\n</code></pre>\n\n<p>when <code>cond()</code> is evaluated to <code>false</code> in the following test:</p>\n\n<pre><code>#[test]\nfn my_test() {\n    if !cond() {\n        // Mark the test as skipped. How?\n        return;\n    }\n\n    // The actual test that works only when cond() returns true.\n}\n</code></pre>\n\n<p>In other words, I am looking for a Rust alternative of <a href=\"https://docs.python.org/3/library/unittest.html#unittest.TestCase.skipTest\" rel=\"noreferrer\"><code>unittest.skipTest()</code></a> in Python (<a href=\"https://docs.python.org/3/library/unittest.html#unittest-skipping\" rel=\"noreferrer\">more information</a>).</p>\n"}, {"tags": ["rust", "lifetime", "serde", "serde-json"], "answers": [{"tags": [], "owner": {"reputation": 870, "user_id": 2818775, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/67257e8dbeaaf6af872f8c79524299d1?s=128&d=identicon&r=PG&f=1", "display_name": "realli", "link": "https://stackoverflow.com/users/2818775/realli"}, "is_accepted": false, "score": 16, "last_activity_date": 1492869232, "last_edit_date": 1492869232, "creation_date": 1492832171, "answer_id": 43554955, "question_id": 43554679, "link": "https://stackoverflow.com/questions/43554679/lifetime-error-when-creating-a-function-that-returns-a-value-implementing-serde/43554955#43554955", "title": "Lifetime error when creating a function that returns a value implementing serde::Deserialize", "body": "<p>I found an answer from <a href=\"https://github.com/serde-rs/serde/issues/891\" rel=\"noreferrer\">Serde issue 891</a>: I should use <code>DeserializeOwned</code> instead of <code>Deserialize</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 6357, "user_id": 6086311, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cb99289473f6393b89474785f2d294d1?s=128&d=identicon&r=PG", "display_name": "dtolnay", "link": "https://stackoverflow.com/users/6086311/dtolnay"}, "is_accepted": false, "score": 12, "last_activity_date": 1492893528, "creation_date": 1492893528, "answer_id": 43564347, "question_id": 43554679, "link": "https://stackoverflow.com/questions/43554679/lifetime-error-when-creating-a-function-that-returns-a-value-implementing-serde/43564347#43564347", "title": "Lifetime error when creating a function that returns a value implementing serde::Deserialize", "body": "<p><a href=\"https://serde.rs/lifetimes.html#trait-bounds\" rel=\"noreferrer\"><strong>This section of the Serde website covers <code>Deserialize</code> bounds in detail.</strong></a></p>\n\n<hr>\n\n<p>There are two main ways to write <code>Deserialize</code> trait bounds, whether on an impl block or a function or anywhere else.</p>\n\n<ul>\n<li><p><strong><code>&lt;'de, T&gt; where T: Deserialize&lt;'de&gt;</code></strong></p>\n\n<p>This means \"T can be deserialized from <strong>some</strong> lifetime.\" The caller gets to decide what lifetime that is. Typically this is used when the caller also provides the data that is being deserialized from, for example in a function like <a href=\"https://docs.serde.rs/serde_json/fn.from_str.html\" rel=\"noreferrer\"><code>serde_json::from_str</code></a>. In that case the input data must also have lifetime <code>'de</code>, for example it could be <code>&amp;'de str</code>.</p></li>\n<li><p><strong><code>&lt;T&gt; where T: DeserializeOwned</code></strong></p>\n\n<p>This means \"T can be deserialized from <strong>any</strong> lifetime.\" The callee gets to decide what lifetime. Usually this is because the data that is being deserialized from is going to be thrown away before the function returns, so T must not be allowed to borrow from it. For example a function that accepts base64-encoded data as input, decodes it from base64, deserializes a value of type T, then throws away the result of base64 decoding. Another common use of this bound is functions that deserialize from an IO stream, such as <a href=\"https://docs.serde.rs/serde_json/fn.from_reader.html\" rel=\"noreferrer\"><code>serde_json::from_reader</code></a>.</p>\n\n<p>To say it more technically, the <a href=\"https://docs.serde.rs/serde/de/trait.DeserializeOwned.html\" rel=\"noreferrer\"><code>DeserializeOwned</code></a> trait is equivalent to the <a href=\"https://doc.rust-lang.org/nomicon/hrtb.html\" rel=\"noreferrer\">higher-rank trait bound</a> <code>for&lt;'de&gt; Deserialize&lt;'de&gt;</code>. The only difference is <code>DeserializeOwned</code> is more intuitive to read. It means T owns all the data that gets deserialized.</p></li>\n</ul>\n"}], "owner": {"reputation": 870, "user_id": 2818775, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/67257e8dbeaaf6af872f8c79524299d1?s=128&d=identicon&r=PG&f=1", "display_name": "realli", "link": "https://stackoverflow.com/users/2818775/realli"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2287, "favorite_count": 1, "answer_count": 2, "score": 19, "last_activity_date": 1492893528, "creation_date": 1492829297, "last_edit_date": 1492869201, "question_id": 43554679, "link": "https://stackoverflow.com/questions/43554679/lifetime-error-when-creating-a-function-that-returns-a-value-implementing-serde", "title": "Lifetime error when creating a function that returns a value implementing serde::Deserialize", "body": "<p>I'm using serde and serde_json 1.0 to decode data from a base64 string:</p>\n\n<pre><code>fn from_base64_str&lt;T: Deserialize&gt;(string: &amp;str) -&gt; T {\n    let slice = decode_config(string, URL_SAFE).unwrap();     \n    serde_json::from_slice(&amp;slice).unwrap()\n}\n</code></pre>\n\n<p>When I compile, I got this:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0106]: missing lifetime specifier\n --&gt; src/main.rs:6:23\n  |\n6 | fn from_base64_str&lt;T: Deserialize&gt;(string: &amp;str) -&gt; T {\n  |                       ^^^^^^^^^^^ expected lifetime parameter\n</code></pre>\n\n<p>Checking the serde doc, <code>Deserialize</code> is defined as:</p>\n\n<pre><code>pub trait Deserialize&lt;'de&gt;: Sized {\n</code></pre>\n\n<p>So I added the lifetime:</p>\n\n<pre><code>fn from_base64_str&lt;'de, T: Deserialize&lt;'de&gt;&gt;(string: &amp;str) -&gt; T {\n    let slice = decode_config(string, URL_SAFE).unwrap();     \n    serde_json::from_slice(&amp;slice).unwrap()\n}\n</code></pre>\n\n<p>The compiler then told me:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: `slice` does not live long enough\n  --&gt; src/main.rs:11:29\n   |\n11 |     serde_json::from_slice(&amp;slice).unwrap()\n   |                             ^^^^^ does not live long enough\n12 | }\n   | - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the lifetime 'de as defined on the body at 9:64...\n  --&gt; src/main.rs:9:65\n   |\n9  |   fn from_base64_str&lt;'de, T: Deserialize&lt;'de&gt;&gt;(string: &amp;str) -&gt; T {\n   |  _________________________________________________________________^ starting here...\n10 | |     let slice = decode_config(string, URL_SAFE).unwrap();\n11 | |     serde_json::from_slice(&amp;slice).unwrap()\n12 | | }\n   | |_^ ...ending here\n</code></pre>\n\n<p>I only know the very basics of lifetimes in Rust, so I'm very confused by the <code>'de</code> in <code>trait Deserialize</code>.</p>\n\n<p>How can I fix the lifetime error in such function? I'm using Rust 1.18.0-nightly (452bf0852 2017-04-19)</p>\n"}, {"tags": ["callback", "rust", "borrow-checker", "event-driven"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492811614, "post_id": 43552480, "comment_id": 74157281, "body": "What makes you believe that the answers you&#39;ve seen elsewhere <b>aren&#39;t</b> a &quot;complete general solution&quot;? Perhaps you could <a href=\"https://stackoverflow.com/posts/43552480/edit\">edit</a> your question to explain?"}, {"owner": {"reputation": 6001, "user_id": 1797000, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/5974f50172fd161e3cccac40ecbe3934?s=128&d=identicon&r=PG", "display_name": "hdante", "link": "https://stackoverflow.com/users/1797000/hdante"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492811717, "post_id": 43552480, "comment_id": 74157317, "body": "Maybe I can link them directly"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492811766, "post_id": 43552480, "comment_id": 74157339, "body": "Said another way, why <i>shouldn&#39;t</i> this be viewed as a duplicate of <a href=\"http://stackoverflow.com/q/39089905/155423\">Passing mutable context into callbacks</a>; <a href=\"http://stackoverflow.com/q/29540167/155423\">Creating a callback system using closures</a>; <a href=\"http://stackoverflow.com/q/38027461/155423\">Execute callbacks like as mutable borrowing from cycle</a>; and <a href=\"http://stackoverflow.com/q/39137364/155423\">Callback to mutable self</a>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492811783, "post_id": 43552480, "comment_id": 74157349, "body": "Linking would be great; <b>and describing what&#39;s wrong with them</b>. In another vein, what makes you think there <i>is</i> a general solution?"}, {"owner": {"reputation": 6001, "user_id": 1797000, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/5974f50172fd161e3cccac40ecbe3934?s=128&d=identicon&r=PG", "display_name": "hdante", "link": "https://stackoverflow.com/users/1797000/hdante"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492812856, "post_id": 43552480, "comment_id": 74157774, "body": "I&#39;ll need to check these questions. I don&#39;t know if there&#39;s a general solution. Stating that there&#39;s none would be a valid answer. This answer doesn&#39;t appear in other questions, though."}], "answers": [{"comments": [{"owner": {"reputation": 6001, "user_id": 1797000, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/5974f50172fd161e3cccac40ecbe3934?s=128&d=identicon&r=PG", "display_name": "hdante", "link": "https://stackoverflow.com/users/1797000/hdante"}, "edited": false, "score": 0, "creation_date": 1492815422, "post_id": 43552922, "comment_id": 74158618, "body": "The first option looks ok to me, the second option I believe it wouldn&#39;t generally work with multiple widgets or require passing the complete widget tree or graph as the parameter. But since in your answer you have given up the static borrow checker I wonder if callbacks are intrinsically unsafe, or the borrow checker too limited ?"}, {"owner": {"reputation": 7872, "user_id": 440302, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e785baf6d4a2626b8649d5b538c51858?s=128&d=identicon&r=PG", "display_name": "Rufflewind", "link": "https://stackoverflow.com/users/440302/rufflewind"}, "reply_to_user": {"reputation": 6001, "user_id": 1797000, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/5974f50172fd161e3cccac40ecbe3934?s=128&d=identicon&r=PG", "display_name": "hdante", "link": "https://stackoverflow.com/users/1797000/hdante"}, "edited": false, "score": 2, "creation_date": 1492825228, "post_id": 43552922, "comment_id": 74160668, "body": "The second approach <i>is</i> more complicated, but that is exactly how one would express intent to the (static) borrow checker. The borrow checker does not analyze the whole program; it only looks at one function at a time, and each closure counts as its own function.  So if a closure uses a <code>&amp;mut Pen</code>, then that <code>&amp;mut Pen</code> is \u201clocked\u201d for exclusive use for as long as that closure exists. The borrow checker does not attempt to examine the call sites of the closure."}], "tags": [], "owner": {"reputation": 7872, "user_id": 440302, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e785baf6d4a2626b8649d5b538c51858?s=128&d=identicon&r=PG", "display_name": "Rufflewind", "link": "https://stackoverflow.com/users/440302/rufflewind"}, "is_accepted": false, "score": 3, "last_activity_date": 1492813716, "creation_date": 1492813716, "answer_id": 43552922, "question_id": 43552480, "link": "https://stackoverflow.com/questions/43552480/whats-the-correct-way-to-implement-the-equivalent-of-multiple-mutable-statical/43552922#43552922", "title": "What&#39;s the correct way to implement the equivalent of multiple mutable (statically allocated, statically dispatched, etc.) callbacks in Rust?", "body": "<p>One way is to use a <code>RefCell</code>, which allows you to mutate things with only <code>&amp;Pen</code> instead of <code>&amp;mut Pen</code>, at the cost of pushing the borrow-checking to runtime.  It\u2019s very cheap: there is no allocation, just a single flag test.\n The main downside is that violating the rules will result in a panic at runtime.  A useful rule of thumb is to never borrow for any longer than necessary (think of them as \u201csingle-threaded mutexes\u201d).</p>\n\n<pre><code>use std::cell::RefCell;\n\nfn main() {\n    println!(\"Hello, world !\");\n\n    let p1 = RefCell::new(Pen::new());\n    {\n        let mut rp1 = p1.borrow_mut();\n        rp1.write(\"Hello\");\n        println!(\"ink: {}, color: {}\", rp1.ink, rp1.color_cmyk);\n    }\n\n    let cb = |text| {\n        if p1.borrow_mut().write(text) {\n            println!(\"{}\", text);\n        }\n        else {\n            println!(\"Out of ink !\");\n        }\n    };\n\n    let cb2 = |text| {\n        let mut rp1 = p1.borrow_mut();\n        rp1.write(text);\n        rp1.ink\n    };\n\n    cb(\"Hello\");\n    cb(\"World\");\n    println!(\"{}\", cb2(\"Hello\"));\n}\n</code></pre>\n\n<p>Another way is to set up the callback system to pass in the object that you\u2019re modifying as an argument.  The trade-off is then your callback system needs to be aware of this state.</p>\n\n<pre><code>fn main() {\n    println!(\"Hello, world !\");\n\n    let mut p1 = Pen::new();\n    p1.write(\"Hello\");\n    println!(\"ink: {}, color: {}\", p1.ink, p1.color_cmyk);\n\n    let cb = |p1: &amp;mut Pen, text| if p1.write(text) {\n        println!(\"{}\", text);\n    } else {\n        println!(\"Out of ink !\");\n    };\n\n    let cb2 = |p1: &amp;mut Pen, text| {\n        p1.write(text);\n        p1.ink\n    };\n\n    cb(&amp;mut p1, \"Hello\");\n    cb(&amp;mut p1, \"World\");\n    println!(\"{}\", cb2(&amp;mut p1, \"Hello\"));\n}\n</code></pre>\n"}], "owner": {"reputation": 6001, "user_id": 1797000, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/5974f50172fd161e3cccac40ecbe3934?s=128&d=identicon&r=PG", "display_name": "hdante", "link": "https://stackoverflow.com/users/1797000/hdante"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 171, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1492813716, "creation_date": 1492811172, "last_edit_date": 1495541379, "question_id": 43552480, "link": "https://stackoverflow.com/questions/43552480/whats-the-correct-way-to-implement-the-equivalent-of-multiple-mutable-statical", "title": "What&#39;s the correct way to implement the equivalent of multiple mutable (statically allocated, statically dispatched, etc.) callbacks in Rust?", "body": "<p>I have the following example code, which is the standard basis of event-driven APIs in other programming languages, but in Rust the borrow checker blocks it with \"cannot borrow <code>p1</code> as mutable more than once at a time\":</p>\n\n<pre><code>struct Pen {\n    color_cmyk: u32,\n    ink: usize,\n}\n\nimpl Pen {\n    pub fn new() -&gt; Pen {\n        Pen {\n            color_cmyk: 0x80800000,\n            ink: 20000,\n        }\n    }\n\n    pub fn write(&amp;mut self, text: &amp;str) -&gt; bool {\n        if self.ink &lt; text.len() {\n            return false;\n        }\n\n        self.ink -= text.len();\n        true\n    }\n}\n\nfn main() {\n    println!(\"Hello, world !\");\n\n    let mut p1 = Pen::new();\n    p1.write(\"Hello\");\n    println!(\"ink: {}, color: {}\", p1.ink, p1.color_cmyk);\n\n    let mut cb = |text| if p1.write(text) {\n        println!(\"{}\", text);\n    } else {\n        println!(\"Out of ink !\");\n    };\n\n    let mut cb2 = |text| {\n        p1.write(text);\n        p1.ink\n    };\n\n    cb(\"Hello\");\n    cb(\"World\");\n    println!(\"{}\", cb2(\"Hello\"));\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0499]: cannot borrow `p1` as mutable more than once at a time\n  --&gt; src/main.rs:37:23\n   |\n31 |         let mut cb = |text| if p1.write(text) {\n   |                      ------    -- previous borrow occurs due to use of `p1` in closure\n   |                      |\n   |                      first mutable borrow occurs here\n...\n37 |         let mut cb2 = |text| {\n   |                       ^^^^^^ second mutable borrow occurs here\n38 |             p1.write(text);\n   |             -- borrow occurs due to use of `p1` in closure\n...\n45 |     }\n   |     - first borrow ends here\n</code></pre>\n\n<p>The code can be used, for example, to implement two callbacks to a window: one for handling keyboard events and another for handling mouse events, both of which update the window state (ex: changing color, closing the window, etc.).</p>\n\n<p>I know that this question appears elsewhere in Stack Overflow and other forums, but in general, the answers focus on describing the reason of the problem and rarely propose a complete general solution for it:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/31281155/cannot-borrow-x-as-mutable-more-than-once-at-a-time\">Cannot borrow `x` as mutable more than once at a time</a></li>\n<li><a href=\"https://users.rust-lang.org/t/how-to-bypass-cannot-borrow-as-mutable-more-than-once/2947\" rel=\"nofollow noreferrer\">How to bypass \u201ccannot borrow as mutable more than once\u201d?</a></li>\n<li><a href=\"https://users.rust-lang.org/t/cannot-borrow-as-mutable-more-than-once-at-a-time/8922\" rel=\"nofollow noreferrer\">Cannot borrow as mutable more than once at a time</a></li>\n<li><a href=\"https://stackoverflow.com/questions/39089905/passing-mutable-context-into-callbacks\">Passing mutable context into callbacks</a></li>\n<li><a href=\"https://stackoverflow.com/questions/29540167/creating-a-callback-system-using-closures\">Creating a callback system using closures</a></li>\n<li><a href=\"https://stackoverflow.com/questions/38027461/execute-callbacks-like-as-mutable-borrowing-from-cycle\">Execute callbacks like as mutable borrowing from cycle</a></li>\n<li><a href=\"https://stackoverflow.com/questions/39137364/callback-to-mutable-self\">Callback to mutable self</a></li>\n</ul>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 2369, "user_id": 4614680, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c9b36fb2c1d356a919916f77e74f1c3c?s=128&d=identicon&r=PG&f=1", "display_name": "Philipp Ludwig", "link": "https://stackoverflow.com/users/4614680/philipp-ludwig"}, "edited": false, "score": 0, "creation_date": 1492877745, "post_id": 43551600, "comment_id": 74174017, "body": "Thanks for the detailed explanation! Indeed coming from C++ I tried handling things similar to <code>const</code>, now I understand it better."}], "tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": true, "score": 13, "last_activity_date": 1492887206, "last_edit_date": 1492887206, "creation_date": 1492806912, "answer_id": 43551600, "question_id": 43550632, "link": "https://stackoverflow.com/questions/43550632/how-can-i-change-fields-of-elements-in-vectors-in-rust/43551600#43551600", "title": "How can I change fields of elements in vectors in Rust?", "body": "<p>To mutate the first element of the vector you'd usually get a reference to that element. In other words, a reference <em>into</em> the vector. And being a normal structure the vector needs to have a method that would provide you with the reference.</p>\n\n<p>Thing is, a reference into a vector means you can do something with the insides of the vector, read them or modify them in some way. Rust doesn't know the details, it just knows that while you're holding that reference, you can do stuff.</p>\n\n<p>And with just that limited information the borrow checker of Rust tries to stop you from shooting yourself in the foot. It says: if you're going to read the vector, fine, you can read it any way you want, you can even make some other function read it, or two functions, or five. But you can't modify the vector while you're reading it, it isn't safe, it leads to bugs. So, you can have as many read-only references into the vector as you want, but only if and when you're not holding any writeable references into it. If you do hold a writeable reference, then there can be only one such reference at a time.</p>\n\n<p>Thus the kind of reference matters. And that is why the vector has the two methods that give you the first element: <a href=\"https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.first\" rel=\"noreferrer\">first</a> and <a href=\"https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.first_mut\" rel=\"noreferrer\">first_mut</a>.</p>\n\n<p>So here</p>\n\n<pre><code>let mut vec = Vec::new();\n</code></pre>\n\n<p>your vector is already mutable. And coming from other languages you might work from intuition that if the vector is mutable once, it is mutable always. Kind of like <code>const</code> value in C++ or <code>immutable</code> in D. It's either mutable, or it's not.</p>\n\n<p>But in Rust you might want immutable references into mutable structure. For instance, you might want one thread to work on one element of a vector and another thread on another element, and if you'd rather keep the borrow checker's safety belt on, then the simplest way to have multiple references is to keep them immutable. That is why methods like <a href=\"https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.first\" rel=\"noreferrer\">first</a> return immutable references and to get a mutable reference you need to explicitly opt in by using a different method.</p>\n\n<p>P.S. So was that any help?</p>\n"}, {"comments": [{"owner": {"reputation": 2369, "user_id": 4614680, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c9b36fb2c1d356a919916f77e74f1c3c?s=128&d=identicon&r=PG&f=1", "display_name": "Philipp Ludwig", "link": "https://stackoverflow.com/users/4614680/philipp-ludwig"}, "edited": false, "score": 0, "creation_date": 1492877898, "post_id": 43551633, "comment_id": 74174057, "body": "Thanks for the examples, that&#39;s easier than expected. I hope you don&#39;t mind that I accepted ArtemGr&#39;s answer, since he provided a very detailled explanation."}], "tags": [], "owner": {"reputation": 4201, "user_id": 35054, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2489e1bbb7b21422d28f3cec3192257f?s=128&d=identicon&r=PG", "display_name": "dmitry_vk", "link": "https://stackoverflow.com/users/35054/dmitry-vk"}, "is_accepted": false, "score": 8, "last_activity_date": 1492807052, "creation_date": 1492807052, "answer_id": 43551633, "question_id": 43550632, "link": "https://stackoverflow.com/questions/43550632/how-can-i-change-fields-of-elements-in-vectors-in-rust/43551633#43551633", "title": "How can I change fields of elements in vectors in Rust?", "body": "<p>Here's equally working code samples:</p>\n\n<pre><code>vec[0].some_value += 1;\n\nvec.first_mut().unwrap().some_value += 1;\n</code></pre>\n\n<p>The issue with code that is shown in question is that <code>first()</code> returns an (immutable) reference to first element but mutable reference is required.</p>\n\n<p>Indexing (<code>[0]</code>) works like this:</p>\n\n<ol>\n<li><code>vec</code> derefs to slice</li>\n<li>indexing on slice calls <code>index_mut</code> method from <code>IndexMut</code> trait</li>\n<li><code>index_mut</code> method returns mutable reference (<code>&amp;mut someType</code>)</li>\n</ol>\n"}, {"tags": [], "owner": {"reputation": 420, "user_id": 236378, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/d73cb546da468a0b03888ff822dd42af?s=128&d=identicon&r=PG", "display_name": "Shchvova", "link": "https://stackoverflow.com/users/236378/shchvova"}, "is_accepted": false, "score": 4, "last_activity_date": 1519611019, "creation_date": 1519611019, "answer_id": 48980524, "question_id": 43550632, "link": "https://stackoverflow.com/questions/43550632/how-can-i-change-fields-of-elements-in-vectors-in-rust/48980524#48980524", "title": "How can I change fields of elements in vectors in Rust?", "body": "<p>I think you're looking for <code>&amp;mut</code> when taking reference.</p>\n\n<pre><code>#[derive(Debug)]\nstruct Character{\n    name: String,\n}\n\nfn main() {\n    let mut hobbits = vec![\n        Character{name:String::from(\"Sam\")},\n        Character{name:String::from(\"Merry\")},\n        Character{name:String::from(\"Pepper\")},\n    ];\n\n    {\n        let third = &amp;mut hobbits[2];\n        third.name = String::from(\"Pippin\");\n    }\n\n    println!(\"{:?}\", hobbits);\n}\n</code></pre>\n\n<p>Note <code>{}</code> around mutable element reference. It is required to limit mutable reference scope. Can't have mutable and immutable references at the same time: <code>println!</code> would fail while <code>third</code> is still in scope.</p>\n"}, {"tags": [], "owner": {"reputation": 543, "user_id": 1929013, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/11f5a7ee410a95d7fca8faf6dd7398f4?s=128&d=identicon&r=PG", "display_name": "cannot_mutably_borrow", "link": "https://stackoverflow.com/users/1929013/cannot-mutably-borrow"}, "is_accepted": false, "score": 2, "last_activity_date": 1576768032, "creation_date": 1576768032, "answer_id": 59412357, "question_id": 43550632, "link": "https://stackoverflow.com/questions/43550632/how-can-i-change-fields-of-elements-in-vectors-in-rust/59412357#59412357", "title": "How can I change fields of elements in vectors in Rust?", "body": "<p>This is an old question. I recently started with Rust and I'd like to try to answer.</p>\n\n<p>To update the first element, I'd do this:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let mut st = &amp;mut vec[0];\nst.some_value += 1;\n</code></pre>\n\n<p>or just:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>vec[0].some_value += 1;\n</code></pre>\n\n<p>To entirely replace the first element, I can do this:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>std::mem::replace(&amp;mut vec[0], SomeType { some_value: 111 });\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 1731, "user_id": 1901896, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/77b2651b08f4279ec5a29169d6c40c3d?s=128&d=identicon&r=PG", "display_name": "Akash5288", "link": "https://stackoverflow.com/users/1901896/akash5288"}, "is_accepted": false, "score": 1, "last_activity_date": 1592725934, "creation_date": 1592725934, "answer_id": 62495864, "question_id": 43550632, "link": "https://stackoverflow.com/questions/43550632/how-can-i-change-fields-of-elements-in-vectors-in-rust/62495864#62495864", "title": "How can I change fields of elements in vectors in Rust?", "body": "<p>You can do this by this way as well:</p>\n<pre><code>fn changeValues(mut list: Vec&lt;i32&gt;){\n        println!(&quot;Before value change: {:?}&quot;, list.get(0).unwrap());\n        list[0] = 3;\n        println!(&quot;After value change: {:?}&quot;, list.get(0).unwrap());\n    }\n</code></pre>\n"}], "owner": {"reputation": 2369, "user_id": 4614680, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c9b36fb2c1d356a919916f77e74f1c3c?s=128&d=identicon&r=PG&f=1", "display_name": "Philipp Ludwig", "link": "https://stackoverflow.com/users/4614680/philipp-ludwig"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 14204, "favorite_count": 0, "accepted_answer_id": 43551600, "answer_count": 5, "score": 13, "last_activity_date": 1592725934, "creation_date": 1492803154, "last_edit_date": 1492811220, "question_id": 43550632, "link": "https://stackoverflow.com/questions/43550632/how-can-i-change-fields-of-elements-in-vectors-in-rust", "title": "How can I change fields of elements in vectors in Rust?", "body": "<p>I have a <code>vec</code> of some struct type and I want to change some field of the first element in the vector. How can I do this?</p>\n\n<p>Example:</p>\n\n<pre><code>struct SomeType {\n    some_value: i32,\n}\n\nfn main() {\n    let mut vec = Vec::new();\n    let mut t = SomeType { some_value: 45 };\n    vec.push(t);\n\n    println!(\"Old value: {}\", vec.first().unwrap().some_value);\n    vec.first().unwrap().some_value += 1;\n    println!(\"New value: {}\", vec.first().unwrap().some_value);\n}\n</code></pre>\n\n<p>This fails to compile:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: cannot assign to immutable field\n  --&gt; vec.rs:15:2\n   |\n15 |    vec.first().unwrap().some_value += 1;\n   |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field\n</code></pre>\n\n<p>I can't get my head around the mutability stuff in Rust yet; what would be the correct approach here?</p>\n"}, {"tags": ["rust", "type-inference", "lifetime", "unification"], "answers": [{"comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user181351"}, "edited": false, "score": 0, "creation_date": 1492862108, "post_id": 43550405, "comment_id": 74168847, "body": "Can you describe how it does this please. Specifically, the differences from standard Hindley-Milner."}, {"owner": {"user_type": "does_not_exist", "display_name": "user181351"}, "edited": false, "score": 0, "creation_date": 1492863202, "post_id": 43550405, "comment_id": 74169208, "body": "(Algorithm W) ."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1493017306, "post_id": 43550405, "comment_id": 74212535, "body": "@tm1rbrt: I&#39;m woefully inadequate, it&#39;s also very much in flux. You may want to check out Niko Matsakis&#39; new blog serie though: Unification in Chalk <a href=\"http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/\" rel=\"nofollow noreferrer\">Part 1</a> and <a href=\"http://smallcultfollowing.com/babysteps/blog/2017/04/23/unification-in-chalk-part-2/\" rel=\"nofollow noreferrer\">Part 2</a>, where he is describing a new algorithm for unification he is working on and which he plans to transition the Rust compiler to (in part or in whole)."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 2, "last_activity_date": 1492802285, "creation_date": 1492802285, "answer_id": 43550405, "question_id": 43543407, "link": "https://stackoverflow.com/questions/43543407/what-algorithms-does-the-rust-compiler-use-to-infer-lifetime-variables/43550405#43550405", "title": "What algorithms does the Rust compiler use to infer lifetime variables?", "body": "<p>Rust uses a modified Hindley-Milner unification algorithm because it has sub-typing relationships.</p>\n\n<p>For example, <code>&amp;'static T</code> is a sub-type of <code>&amp;'a T</code> for any <code>'a</code>.</p>\n\n<p>Your case is relatively easy, when the compiler sees the call <code>foo(&amp;a, &amp;b)</code> it just unifies <code>'a</code> as the most restrictive of both lifetimes (which is the intersection, since lifetimes are lexical for now).</p>\n"}], "owner": {"user_type": "does_not_exist", "display_name": "user181351"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 838, "favorite_count": 0, "answer_count": 1, "score": 4, "last_activity_date": 1492802285, "creation_date": 1492779665, "last_edit_date": 1492780589, "question_id": 43543407, "link": "https://stackoverflow.com/questions/43543407/what-algorithms-does-the-rust-compiler-use-to-infer-lifetime-variables", "title": "What algorithms does the Rust compiler use to infer lifetime variables?", "body": "<pre><code>fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;'a i32) {}\n\nfn main() { \n    let a = 123;\n    {\n        let b = 234;\n        foo(&amp;a, &amp;b);\n    }\n}\n</code></pre>\n\n<p>In the code above <code>&amp;a</code> and <code>&amp;b</code> should hopefully be references with different lifetimes. </p>\n\n<p>How does the compiler infer the lifetime var <code>'a</code> for <code>foo</code>? As far as I can tell, it's not using a standard Hindley-Milner unification algorithm. The lifetime must be the inner scope or some intersection of the two lifetimes.</p>\n\n<p>Is lifetime inference a completely separate process to the standard type inference? </p>\n\n<p>Does the compiler use intersection types or use some sub-type relationship between lifetimes to choose the most restricted lifetime? </p>\n"}, {"tags": ["loops", "functional-programming", "iterator", "rust"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1492762037, "post_id": 43537034, "comment_id": 74126523, "body": "Right now, all the calculated <code>product</code>s are discarded and nothing really happens. Do you want to collect all those products into a vector or what do you want to do with them?"}, {"owner": {"reputation": 2897, "user_id": 3392714, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/302ac6bfbe982dcd53aa123f9bde72eb?s=128&d=identicon&r=PG&f=1", "display_name": "dani", "link": "https://stackoverflow.com/users/3392714/dani"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1492774296, "post_id": 43537034, "comment_id": 74135013, "body": "You are right. That got lost during cuting my original code to the above example. I made an edit."}], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 8, "last_activity_date": 1492780733, "last_edit_date": 1492780733, "creation_date": 1492762428, "answer_id": 43537381, "question_id": 43537034, "link": "https://stackoverflow.com/questions/43537034/how-to-avoid-loops-when-iterating-over-adjacent-elements-of-a-vector/43537381#43537381", "title": "How to avoid loops when iterating over adjacent elements of a vector", "body": "<p>The function you are searching for is <a href=\"https://doc.rust-lang.org/stable/std/primitive.slice.html#method.windows\" rel=\"nofollow noreferrer\"><code>[T]::windows()</code></a>. You can specify the size of the overlapping windows and it will return an iterator over sub-slices.</p>\n\n<p>You can obtain the product of all elements within a sub-slice by making an iterator out of it and using <a href=\"https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.product\" rel=\"nofollow noreferrer\"><code>Iterator::product()</code></a>.</p>\n\n<pre><code>let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet products: Vec&lt;u64&gt; = v.windows(3)\n    .map(|win| win.iter().product())\n    .collect();\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=9413ca51b34eab18addf2b6bb006846a&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a>)</p>\n\n<p>Here we collect all products into a new vector. </p>\n\n<hr>\n\n<p>A last note: instead of writing down all numbers in the vector manually you <em>could</em> write this instead:</p>\n\n<pre><code>let v: Vec&lt;_&gt; = (1..10).chain(1..10).collect();\n</code></pre>\n"}], "owner": {"reputation": 2897, "user_id": 3392714, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/302ac6bfbe982dcd53aa123f9bde72eb?s=128&d=identicon&r=PG&f=1", "display_name": "dani", "link": "https://stackoverflow.com/users/3392714/dani"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 264, "favorite_count": 0, "accepted_answer_id": 43537381, "answer_count": 1, "score": 6, "last_activity_date": 1492810173, "creation_date": 1492761340, "last_edit_date": 1492810173, "question_id": 43537034, "link": "https://stackoverflow.com/questions/43537034/how-to-avoid-loops-when-iterating-over-adjacent-elements-of-a-vector", "title": "How to avoid loops when iterating over adjacent elements of a vector", "body": "<p>In Rust, how do I avoid writing these loops? The code takes a vector and multiplies three adjacent elements to a product. Hence, the outer loop goes over all elements that can form a group of three and the inner loop does the multiplication.</p>\n\n<p>The difficulty lies, I think, in the incomplete iteration of the outer loop (from element <code>0</code> to <code>last - 3</code>). Further, the inner loop must use a sub-range.</p>\n\n<p>Is there a way to avoid writing the loops?</p>\n\n<pre><code>let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet mut products = Vec::new();\nfor seq in 0..v.len() - 3 {\n    let mut product = 1;\n    for offset in 0..3 {\n        product *= v[seq + offset];\n    }\n    products.push(product);\n}\n</code></pre>\n"}, {"tags": ["tcp", "websocket", "rust"], "comments": [{"owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492899428, "post_id": 43535480, "comment_id": 74181301, "body": "The first suggestion (Option&lt;&gt;) works! That&#39;s truly awesome! I haven&#39;t understood the nature of Option&lt;&gt; at all, I must read the docs more thoroughly. So far used it only for null pointers. How can I accept this as an answer? Regarding the suggestion of instantiation: Interesting point, I have not fully thought it through. My guess is that instantiation can be done only from the host. If it <i>is</i> technically possible, it is unusual in that I have not seen it elsewhere (granted, that doesn&#39;t mean much, I&#39;m a beginner). BTW, this is all about the LV2 audio plugin standard."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492904005, "post_id": 43535480, "comment_id": 74182259, "body": "You may be interested in <a href=\"https://www.reddit.com/r/rust/comments/61h21t/writing_an_audio_plugin_in_rust/\" rel=\"nofollow noreferrer\">reddit.com/r/rust/comments/61h21t/&hellip;</a>"}, {"owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492939627, "post_id": 43535480, "comment_id": 74188672, "body": "Thanks for the link, that looks interesting!"}], "answers": [{"comments": [{"owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "edited": false, "score": 0, "creation_date": 1492938805, "post_id": 43565760, "comment_id": 74188444, "body": "Option&lt;&gt;, yes! Good points about the downsides. In particular the third one, I haven&#39;t thought about that at all. Thanks for your help!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1492903978, "creation_date": 1492903978, "answer_id": 43565760, "question_id": 43535480, "link": "https://stackoverflow.com/questions/43535480/how-can-i-reuse-a-server-side-tcp-endpoint-for-multiple-consumers/43565760#43565760", "title": "How can I reuse a server-side TCP endpoint for multiple consumers?", "body": "<p>One workaround, if I understand all of your limitations correctly, is to use <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" rel=\"nofollow noreferrer\"><code>Option</code></a>. <code>Option</code> is used for precisely the case of \"something or not something\".</p>\n\n<p>Here, you could have an <code>Option&lt;TcpListener&gt;</code>. On a freshly-initialized plugin, this would be set to <code>Some(...)</code>, and once accepted, would transition to <code>None</code>.</p>\n\n<p>This does have a number of downsides:</p>\n\n<ul>\n<li>There's a time period where there are no listeners.</li>\n<li>You have to deal with the possibility of the listener being <code>None</code>.</li>\n<li>You can't start a second plugin before the first one accepts something.</li>\n</ul>\n\n<p>Some kind of parent-child relationship is probably better, or even limiting to a singleton plugin, if plausible.</p>\n"}], "owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 248, "favorite_count": 0, "accepted_answer_id": 43565760, "answer_count": 1, "score": 1, "last_activity_date": 1492903978, "creation_date": 1492756315, "last_edit_date": 1492869312, "question_id": 43535480, "link": "https://stackoverflow.com/questions/43535480/how-can-i-reuse-a-server-side-tcp-endpoint-for-multiple-consumers", "title": "How can I reuse a server-side TCP endpoint for multiple consumers?", "body": "<p>I'm a beginner trying to understand TCP, and I'm using Rust. If I create a new listener and bind it to an address </p>\n\n<pre><code>let tcplistener = TcpListener::bind(\"127.0.0.1:55555\").unwrap();\n</code></pre>\n\n<p>I can <code>tcplistener.accept()</code> new connections between <code>127.0.0.1:55555</code> and some other endpoint on the client. </p>\n\n<p>In my case, <code>tcplistener</code> lives within an instance of a struct representing a plugin. Each plugin should be controllable from its own browser tab. There is one connection (endpoint-pair) per plugin, with one endpoint always being <code>127.0.0.1:55555</code>. The plugins run in a single thread with non-blocking listeners and streams. I use websockets, but I'm not sure if this question is specific to websockets.</p>\n\n<p>What I'm doing now is</p>\n\n<ul>\n<li>instantiate plugin A</li>\n<li>accept the first connection from a browser tab to plugin A</li>\n<li>after that, assign the <code>tcplistener</code> field in plugin A to a newly created listener with arbitrary OS-assigned port</li>\n</ul>\n\n<p>This seems to work; if I instantiate a new plugin B afterwards, I can create a listener bound to <code>127.0.0.1:55555</code> and accepting a connection. If I don't create a new listener with different address/port, then I get the \"Address already in use\" error.</p>\n\n<p><strong>This is obviously not a good solution since it occupies all the other ports for no reason. Is there a better way?</strong> </p>\n\n<p>A comment said:</p>\n\n<blockquote>\n  <p>Why does each plugin have a <code>TcpListener</code>? Why not have one component with the listener, call <code>accept</code>, then hand off the returned <code>TcpStream</code> to each constructed plugin?</p>\n</blockquote>\n\n<p>That does sound good, but where would that <code>TcpListener</code> be stored, and how does it hand off the streams? Possibilities I see for storing:</p>\n\n<ul>\n<li>The host. I cannot modify the plugin host, I'm just a plugin author.</li>\n<li>One dedicated plugin. The problem I see is that plugins can't access any information stored in another plugin, so I wouldn't know how to do that.</li>\n<li>A separately running process. I could imagine running a server separately and let the plugins be clients. Users could connect their browser to the server, which somehow does the proxying to the plugin. Sounds reasonable, but the inconvenience here is that plugin users would have to install a server as a separate package. So I'd really like to avoid that. Although I suppose launching the server could be done automatically at plugin instantiation, maybe that's the way to go?</li>\n</ul>\n"}, {"tags": ["loops", "iterator", "rust", "lifetime", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 1784, "user_id": 996118, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/22e3d63a5c93121b865df18bd188cff5?s=128&d=identicon&r=PG", "display_name": "Miles", "link": "https://stackoverflow.com/users/996118/miles"}, "edited": false, "score": 0, "creation_date": 1492756400, "post_id": 43532403, "comment_id": 74123044, "body": "so if I had produced rxs, txs first and then built handles as a vector of references into rxs, Example 2 would become equivalent to Example 3."}, {"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "reply_to_user": {"reputation": 1784, "user_id": 996118, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/22e3d63a5c93121b865df18bd188cff5?s=128&d=identicon&r=PG", "display_name": "Miles", "link": "https://stackoverflow.com/users/996118/miles"}, "edited": false, "score": 1, "creation_date": 1492774344, "post_id": 43532403, "comment_id": 74135033, "body": "Yes. But when you borrow a value from a slice, you borrow the entire slice, which makes this difficult or impossible to write imperatively, without <code>unsafe</code> code to pull out new subslices and convince the compiler that this is ok. Iterators don&#39;t have this problem because their construction forces each mutable borrow to finish before the next occurs. There is some good info about this here: <a href=\"https://doc.rust-lang.org/nomicon/borrow-splitting.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/nomicon/borrow-splitting.html</a>"}], "tags": [], "owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "is_accepted": true, "score": 2, "last_activity_date": 1492739306, "last_edit_date": 1492739306, "creation_date": 1492737937, "answer_id": 43532403, "question_id": 43532275, "link": "https://stackoverflow.com/questions/43532275/reference-has-shorter-lifetime-than-its-value-from-same-scope/43532403#43532403", "title": "Reference has shorter lifetime than its value from same scope?", "body": "<p>In the first example you are moving <code>rx</code> into the <code>rxs</code> vec. That's fine because you move the ownership of <code>rx</code> too, and it won't get dropped.</p>\n\n<p>In the second example, you are passing a reference to <code>sel.handle()</code>, which is another way of saying it is being borrowed. <code>rx</code> is dropped at the end of each loop iteration, but <code>handles</code> outlives the entire loop. If the compiler didn't stop this from happening then <code>handles</code> would be full of dangling pointers.</p>\n\n<blockquote>\n  <p>But why would the reference have a different lifetime than the value</p>\n</blockquote>\n\n<p>A reference always has a shorter lifetime than the value that it references. This has to be the case: the reference must exist and be allocated to memory before you can find its address. After a value is dropped, any reference to it is pointing at freed memory, which could be being used for something else.</p>\n\n<blockquote>\n  <p>and if the value can be moved into a structure as in the first example, why not a reference like in the second?</p>\n</blockquote>\n\n<p>In the second example, the reference <em>is</em> being moved. But the original value isn't. The reference is now pointing at the free memory which was previously used by <code>rx</code>.</p>\n\n<p>In the third example, you have created vectors which own all of the <code>Sender</code>s and <code>Receiver</code>s. As long as <code>txs</code> and <code>rxs</code> stay in scope, these values will not be dropped.</p>\n"}, {"comments": [{"owner": {"reputation": 1784, "user_id": 996118, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/22e3d63a5c93121b865df18bd188cff5?s=128&d=identicon&r=PG", "display_name": "Miles", "link": "https://stackoverflow.com/users/996118/miles"}, "edited": false, "score": 1, "creation_date": 1492756262, "post_id": 43532715, "comment_id": 74122946, "body": "ah, so my &amp;x was excessive, and got Deref&#39;d by the compiler?"}], "tags": [], "owner": {"reputation": 600, "user_id": 3754495, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/65fff37f6d10b64ca1676adcc33f5ffb?s=128&d=identicon&r=PG", "display_name": "notriddle", "link": "https://stackoverflow.com/users/3754495/notriddle"}, "is_accepted": false, "score": 1, "last_activity_date": 1492740081, "creation_date": 1492740081, "answer_id": 43532715, "question_id": 43532275, "link": "https://stackoverflow.com/questions/43532275/reference-has-shorter-lifetime-than-its-value-from-same-scope/43532715#43532715", "title": "Reference has shorter lifetime than its value from same scope?", "body": "<p>In example 2, <code>rx</code> does not have the same lifetime as <code>handles</code>. In fact, it's dropped at the end of the loop, like this:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let sel = Select::new();\nlet mut handles: Vec&lt;Handle&lt;String&gt;&gt; = Vec::new();\nlet mut txs: Vec&lt;SyncSender&lt;String&gt;&gt; = Vec::new();\nfor _ in 0..N {\n    let (tx, rx) = sync_channel(0);\n    txs.push(tx);\n    handles.push(sel.handle(&amp;rx));\n    drop(tx);\n    drop(rx);\n}\ndrop(txs);\ndrop(handles);\ndrop(sel);\n</code></pre>\n\n<p>Exmaple 3 is not equivalent to example 2. This is equivalent to example 2, and it fails:</p>\n\n<pre><code>let (txs, rxs): (Vec&lt;SyncSender&lt;String&gt;&gt;, Vec&lt;Receiver&lt;String&gt;&gt;) =\n    (0..N).map(|_| sync_channel(0)).unzip();\nlet handles: Vec&lt;Handle&lt;String&gt;&gt; =\n    rxs.into_iter().map(|x| sel.handle(&amp;x)).collect(); // &lt;-- notice: into_iter()\n</code></pre>\n\n<p>The <code>iter()</code> function returns an iterator of references. That's why this works:</p>\n\n<pre><code>let (txs, rxs): (Vec&lt;SyncSender&lt;String&gt;&gt;, Vec&lt;Receiver&lt;String&gt;&gt;) =\n    (0..N).map(|_| sync_channel(0)).unzip();\nlet handles: Vec&lt;Handle&lt;String&gt;&gt; =\n    rxs.iter().map(|x| sel.handle(x)).collect(); // &lt;-- notice: no `&amp;`\n</code></pre>\n"}], "owner": {"reputation": 1784, "user_id": 996118, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/22e3d63a5c93121b865df18bd188cff5?s=128&d=identicon&r=PG", "display_name": "Miles", "link": "https://stackoverflow.com/users/996118/miles"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 72, "favorite_count": 0, "accepted_answer_id": 43532403, "answer_count": 2, "score": 1, "last_activity_date": 1492756602, "creation_date": 1492736997, "last_edit_date": 1492756602, "question_id": 43532275, "link": "https://stackoverflow.com/questions/43532275/reference-has-shorter-lifetime-than-its-value-from-same-scope", "title": "Reference has shorter lifetime than its value from same scope?", "body": "<p>It appears in my code that a value is living longer than a reference to it, even though both are created in the same scope. I'd like to know why, and how I can adjust the lifetime of my reference.</p>\n\n<p>Example 1 is accepted by the compiler...</p>\n\n<pre><code>let mut rxs: Vec&lt;Receiver&lt;String&gt;&gt; = Vec::new();\nlet mut txs: Vec&lt;SyncSender&lt;String&gt;&gt; = Vec::new();\nfor _ in 0..N {\n    let (tx, rx) = sync_channel(0);\n    txs.push(tx);\n    rxs.push(rx);\n}\n</code></pre>\n\n<p>But Example 2 isn't...</p>\n\n<pre><code>let sel = Select::new();\nlet mut handles: Vec&lt;Handle&lt;String&gt;&gt; = Vec::new();\nlet mut txs: Vec&lt;SyncSender&lt;String&gt;&gt; = Vec::new();\nfor _ in 0..N {\n    let (tx, rx) = sync_channel(0);\n    txs.push(tx);\n    handles.push(sel.handle(&amp;rx));\n}\n</code></pre>\n\n<p>The compiler tells me that the reference <code>&amp;rx</code> is <em>borrowed</em> in the last line of the <code>for</code> loop, but is <em>dropped</em> at the end of the <code>for</code> loop and needs to live longer, presumably because the reference is placed in a structure with longer lifetime. Why would the reference have a different lifetime than the value, and if the value can be <em>moved</em> into a structure as in the first example, why not a reference like in the second?</p>\n\n<p>Finally, I'd like to know why I <em>don't</em> encounter the same issue in Example 3, even though a reference is borrowed and passed into a structure that lasts longer than the scope of the borrow...</p>\n\n<pre><code>let (txs, rxs): (Vec&lt;SyncSender&lt;String&gt;&gt;, Vec&lt;Receiver&lt;String&gt;&gt;) =\n    (0..N).map(|_| sync_channel(0)).unzip();\nlet handles: Vec&lt;Handle&lt;String&gt;&gt; =\n    rxs.iter().map(|x| sel.handle(&amp;x)).collect();\n</code></pre>\n"}, {"tags": ["multidimensional-array", "rust"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 2, "creation_date": 1492724595, "post_id": 43528081, "comment_id": 74113445, "body": "Funny enough, your approach of Conway&#39;s game of life may not work properly, since you are progressively mutating the grid while counting neighbour cells. The game assumes that all neighbour checks are performed at once in each frame, before any cells die or reproduce. Therefore, replicating the game&#39;s state into a second object is devoid of the issue in your question, and would just work better in general."}, {"owner": {"reputation": 420, "user_id": 197488, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/LDfl3.png?s=128&g=1", "display_name": "QasimK", "link": "https://stackoverflow.com/users/197488/qasimk"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1492853049, "post_id": 43528081, "comment_id": 74166192, "body": "I do say that I don&#39;t implement the proper rules and that that is okay - the main reason was that I struggled to produce a version that worked with a copy because I wasn&#39;t able to do a alternative loop to &quot;windows&quot;!"}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1492870692, "post_id": 43528081, "comment_id": 74171509, "body": "That sounds like a good challenge for you to look into."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1492756641, "post_id": 43529759, "comment_id": 74123201, "body": "Correction: there is no runtime overhead using <code>Cell</code> (because it just copies the underlying value) however there is a slight runtime overhead using <code>RefCell</code> (it&#39;s reference counted like a read-write mutex)."}], "tags": [], "owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "is_accepted": true, "score": 1, "last_activity_date": 1492774562, "last_edit_date": 1492774562, "creation_date": 1492721787, "answer_id": 43529759, "question_id": 43528081, "link": "https://stackoverflow.com/questions/43528081/mutating-a-travelling-window-in-a-rust-ndarray/43529759#43529759", "title": "Mutating a travelling window in a Rust ndarray", "body": "<p>Your general approach using <code>ndarray</code> and <code>windows</code> is ok, but the problem is that the values that you get from the <code>windows</code> iterator will always be immutable. You can work around that by wrapping the values in <code>Cell</code> or <code>RefCell</code>, which gives you interior mutability. That is, they wrap a value as if it was immutable, but provide an API to let you mutate it anyway.</p>\n\n<p>Here is your code, fairly brutally adapted to use <code>RefCell</code>:</p>\n\n<pre><code>use ndarray::Array2;\nuse std::cell::RefCell;\n\nfn main() {\n    // creating variables for convenience, so they can be &amp;-referenced\n    let alive = String::from(\"#\");\n    let dead = String::from(\" \");\n\n    let world = Array2::&lt;String&gt;::from_elem((10, 10), \" \".to_string());\n    let world = world.map(RefCell::new);\n\n    for mut window in world.windows((3, 3)) {\n        let count_all  = window.fold(0, |count, cell| if *cell.borrow() == &amp;alive { count + 1 } else { count });\n        let count_neighbours = count_all - if *window[(1, 1)].borrow() == &amp;alive { 1 } else { 0 };\n        match count_neighbours {\n            0 | 1   =&gt; *window[(1, 1)].borrow_mut() = &amp;dead,  // Under-population\n            2       =&gt; {},                                    // Live if alive\n            3       =&gt; *window[(1, 1)].borrow_mut() = &amp;alive, // Re-produce\n            _       =&gt; *window[(1, 1)].borrow_mut() = &amp;alive, // Over-population\n        }\n    }\n}\n</code></pre>\n\n<p>What I've done above is really just to get your code working, pretty much as-is. But, as E_net4 pointed out, your solution has a major bug because it is mutating as it reads. Also, in terms of best-practices, your usage of <code>String</code> isn't ideal. An <code>enum</code> is much better because it's smaller, can be stack-allocated and better captures the invariants of your model. With an <code>enum</code> you would derive <code>Copy</code> as below, which would let you use a <code>Cell</code> instead of <code>RefCell</code>, which is likely to be better performance because it copies the data, instead of having to count references.</p>\n\n<pre><code>#[derive(Debug, PartialEq, Clone, Copy)]\nenum CellState {\n    Alive,\n    Dead\n}\n</code></pre>\n"}], "owner": {"reputation": 420, "user_id": 197488, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/LDfl3.png?s=128&g=1", "display_name": "QasimK", "link": "https://stackoverflow.com/users/197488/qasimk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 241, "favorite_count": 0, "accepted_answer_id": 43529759, "answer_count": 1, "score": 6, "last_activity_date": 1492774562, "creation_date": 1492715789, "question_id": 43528081, "link": "https://stackoverflow.com/questions/43528081/mutating-a-travelling-window-in-a-rust-ndarray", "title": "Mutating a travelling window in a Rust ndarray", "body": "<p>I am attempting to implement one iteration of <a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Rules\" rel=\"noreferrer\">Conway's Game of Life</a> in Rust using the <a href=\"https://github.com/bluss/rust-ndarray\" rel=\"noreferrer\">ndarray</a> library.</p>\n\n<p>I thought a 3x3 window looping over the array would be a simple way to count the living neighbours, however I am having trouble doing the actual update.</p>\n\n<p>The array signifies life with <code>#</code> and the absence of life with <code></code>:</p>\n\n<pre><code>let mut world = Array2::&lt;String&gt;::from_elem((10, 10), \" \".to_string());\nfor mut window in world.windows((3, 3)) {\n    let count_all  = window.fold(0, |count, cell| if cell == \"#\" { count + 1 } else { count });\n    let count_neighbours = count_all - if window[(1, 1)] == \"#\" { 1 } else { 0 };\n    match count_neighbours {\n        0 | 1   =&gt; window[(1, 1)] = \" \".to_string(), // Under-population\n        2       =&gt; {},                               // Live if alive\n        3       =&gt; window[(1, 1)] = \"#\".to_string(), // Re-produce\n        _       =&gt; window[(1, 1)] = \" \".to_string(), // Over-population\n    }\n}\n</code></pre>\n\n<p>This code does not compile! The error is within the <code>match</code> block with \"error: cannot borrow as mutable\" and \"error: cannot assign to immutable index\". I attempted <code>for &amp;mut window...</code> but the library does not implement this(?)</p>\n\n<p>I'm relatively new to Rust and I believe this <em>may</em> be an issue with the implementation of windows by the library. However, I'm not sure and I don't know if there perhaps some variation/fix that allows me to continue with this approach. Do I need to scrap this approach entirely? I'm not sure what the best approach would be here.</p>\n\n<p>Any other suggestions or improvements to the code would be greatly appreciated.</p>\n\n<p>(This code doesn't implement proper rules as I am mutating as I loop and I am ignoring the outer edge, however that is okay in this case. Also, any variations which do these things are also okay - the details are not important.)</p>\n"}, {"tags": ["rust", "driver", "linux-device-driver", "ethernet", "device-driver"], "comments": [{"owner": {"reputation": 17343, "user_id": 499609, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/c2a8564c05a7124ded58e86a6c86f6ca?s=128&d=identicon&r=PG", "display_name": "Asherah", "link": "https://stackoverflow.com/users/499609/asherah"}, "edited": false, "score": 0, "creation_date": 1493386220, "post_id": 43524447, "comment_id": 74409004, "body": "It would appear the Ethernet card causes the <code>in32()</code> to toggle the 16th bit when it&#39;s finished, based on that while loop. What exactly is the question?"}], "owner": {"reputation": 636, "user_id": 4091722, "user_type": "registered", "accept_rate": 25, "profile_image": "https://i.stack.imgur.com/kQuJG.jpg?s=128&g=1", "display_name": "rajiv_", "link": "https://stackoverflow.com/users/4091722/rajiv"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 133, "favorite_count": 0, "answer_count": 0, "score": 1, "last_activity_date": 1492703790, "creation_date": 1492703790, "question_id": 43524447, "link": "https://stackoverflow.com/questions/43524447/detecting-the-end-of-dma-transfer-in-the-ethernet-card", "title": "Detecting the end of DMA transfer in the Ethernet card.", "body": "<p>I am trying to write a toy kernel in Rust following some blogs online and am using qemu as a hardware emulator. I have configured qemu so that the network card is RTL8139. I am trying to achieve a simple packet transfer. </p>\n\n<p>The device driver structure looks like this </p>\n\n<pre><code>Rtl8139 {\n  config_1: port(0x52),\n  command_register: port(0x37),\n  transmit_address: [port(0x20), port(0x24), port(0x28), port(0x2c)],\n  transmit_status:  [port(0x10), port(0x14), port(0x18), port(0x1c)],\n  id: [port(0), port(1), port(2), port(3), port(4), port(5)],\n  descriptor: 0\n}\n</code></pre>\n\n<p>where port(X) represent the IO port at an offset of X from the io-base of the device. </p>\n\n<p>The code for packet transfer is as follows</p>\n\n<pre><code>fn put_frame(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, u32&gt; {\n    self.transmit_address[self.descriptor].out32(buf.as_ptr() as u32); \n    self.transmit_status[self.descriptor].out32(0xfff &amp; (buf.len() as u32));\n    while (self.transmit_status[self.descriptor].in32() &amp; 0x8000) == 0 { \n    }\n    self.descriptor = (self.descriptor + 1) % 4 ;\n    Ok(buf.len())\n}\n</code></pre>\n\n<p>The <code>self.descriptor</code> tells which port to use among the four ports for transfer. \nIn the above code.The first step shows, writing the base address of the data to be transferred into the <code>transmit_address</code> port and the range of this data in <code>transmit_status</code>. I suppose this will initiate the DMA from that address onto the CPU. And he(<a href=\"https://github.com/QuiltOS/QuiltOS\" rel=\"nofollow noreferrer\">here</a>) is using the while loop to somehow detect the end of DMA. </p>\n\n<p>My question is how does the ethernet card communicate the end of DMA to the device driver? </p>\n\n<p>The code is not mine. I referred <a href=\"https://github.com/QuiltOS/QuiltOS\" rel=\"nofollow noreferrer\">QuiltOS</a> for most of it. </p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1492702117, "post_id": 43523646, "comment_id": 74101027, "body": "You just need to start <a href=\"https://doc.rust-lang.org/stable/book/references-and-borrowing.html#thinking-in-scopes\" rel=\"nofollow noreferrer\">thinking in scopes</a>."}], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 5, "last_activity_date": 1604482032, "last_edit_date": 1604482032, "creation_date": 1492702171, "answer_id": 43523891, "question_id": 43523646, "link": "https://stackoverflow.com/questions/43523646/release-borrowing-in-rust/43523891#43523891", "title": "Release borrowing in Rust", "body": "<p>This is currently a limitation of the Rust borrow checker, often referred to as &quot;non lexical lifetimes&quot; (NLL). The problem here is that the when you assign a reference to a variable (<code>let mut y = &amp;mut x;</code>) the reference has to be valid for the entire scope of the variable. This means that &quot;x is borrowed&quot; lasts for the entire scope of <code>y</code>. So the compiler doesn't care about the line <code>y = &amp;mut a;</code>!</p>\n<p>You can read a lot more (technical) discussion about this <a href=\"https://github.com/aturon/rust-roadmap/issues/16\" rel=\"nofollow noreferrer\">here at the tracking issue</a>.</p>\n<p>EDIT: non-lexical lifetimes have landed some time ago, so your code should compile fine now.</p>\n"}], "owner": {"reputation": 1968, "user_id": 1035024, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/JiO6m.jpg?s=128&g=1", "display_name": "vZ10", "link": "https://stackoverflow.com/users/1035024/vz10"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 849, "favorite_count": 0, "closed_date": 1492702637, "accepted_answer_id": 43523891, "answer_count": 1, "score": 6, "last_activity_date": 1604482032, "creation_date": 1492701599, "last_edit_date": 1492701884, "question_id": 43523646, "link": "https://stackoverflow.com/questions/43523646/release-borrowing-in-rust", "closed_reason": "Duplicate", "title": "Release borrowing in Rust", "body": "<p>I'm trying Rust and have some issues with understanding \"borrowing\".</p>\n\n<pre><code>fn main() {\n    let mut x = 10;\n    let mut a = 6;\n    let mut y = &amp;mut x;\n\n    *y = 6;\n    y = &amp;mut a;\n\n    x = 15;\n    println!(\"{}\", x);\n}\n</code></pre>\n\n<p>And I've got an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0506]: cannot assign to `x` because it is borrowed\n --&gt; &lt;anon&gt;:9:5\n  |\n4 |     let mut y = &amp;mut x;\n  |                      - borrow of `x` occurs here\n...\n9 |     x = 15;\n  |     ^^^^^^ assignment to borrowed `x` occurs here\n\nerror[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n  --&gt; &lt;anon&gt;:10:20\n   |\n4  |     let mut y = &amp;mut x;\n   |                      - mutable borrow occurs here\n...\n10 |     println!(\"{}\", x);\n   |                    ^ immutable borrow occurs here\n11 | }\n   | - mutable borrow ends here\n</code></pre>\n\n<p>How can I release <code>x</code> from \"<code>y</code>-borrowing\"?</p>\n"}, {"tags": ["variables", "syntax", "compilation", "rust", "mutable"], "comments": [{"owner": {"reputation": 59630, "user_id": 636019, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/38ba39c7ba510ac2951c010c26afb6a6?s=128&d=identicon&r=PG", "display_name": "ildjarn", "link": "https://stackoverflow.com/users/636019/ildjarn"}, "edited": false, "score": 13, "creation_date": 1492691920, "post_id": 43519766, "comment_id": 74092630, "body": "That&#39;s deferred initialization, not mutation."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1492692899, "post_id": 43519766, "comment_id": 74093504, "body": "Rust 1.16 is the current version of Rust, and 1.17 should be released in a few weeks. It&#39;s worth it to stay current."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 7, "creation_date": 1492693774, "post_id": 43519886, "comment_id": 74094265, "body": "Idiomatic rust would more likely use expression-oriented syntax here: <code>let x = if condition { 1 } else if other_condition { 10 } else { 100 };</code>. There is no need for deferred initialization in these examples."}, {"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1492694021, "post_id": 43519886, "comment_id": 74094459, "body": "@MatthieuM. That&#39;s true. But if there were different side-effects inside some of the conditional branches, it would look odd. In that case, I think this form would be more idiomatic."}], "tags": [], "owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "is_accepted": true, "score": 15, "last_activity_date": 1492693147, "last_edit_date": 1492693147, "creation_date": 1492692158, "answer_id": 43519886, "question_id": 43519766, "link": "https://stackoverflow.com/questions/43519766/why-doesnt-the-compiler-report-an-error-when-a-variable-not-declared-as-mutable/43519886#43519886", "title": "Why doesn&#39;t the compiler report an error when a variable not declared as mutable is modified?", "body": "<p>What you have written is identical to:</p>\n\n<pre><code>let x: u32 = 10;\n</code></pre>\n\n<p>The compiler will not permit you to mutate it thereafter:</p>\n\n<pre><code>let x: u32;\nx = 10;\nx = 0; // Error: re-assignment of immutable variable `x`\n</code></pre>\n\n<p>Note that it is a compiler error if you try to use an uninitialized variable:</p>\n\n<pre><code>let x: u32;\nprintln!(\"{}\", x); // Error: use of possibly uninitialized variable: `x`\n</code></pre>\n\n<p>This feature can be pretty useful if you want to initialize the variable differently based on runtime conditions. A naive example:</p>\n\n<pre><code>let x: u32;\nif condition {\n    x = 1;   \n} else if other_condition {\n    x = 10;\n} else {\n    x = 100;\n}\n</code></pre>\n\n<p>But still it will still be an error if there is a <em>possibility</em> that it isn't initialized:</p>\n\n<pre><code>let x: u32;\nif condition {\n    x = 1;   \n} else if other_condition {\n    x = 10;\n} // no else\nprintln!(\"{:?}\", x); // Error: use of possibly uninitialized variable: `x`\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 12, "last_activity_date": 1492694914, "last_edit_date": 1492694914, "creation_date": 1492693699, "answer_id": 43520485, "question_id": 43519766, "link": "https://stackoverflow.com/questions/43519766/why-doesnt-the-compiler-report-an-error-when-a-variable-not-declared-as-mutable/43520485#43520485", "title": "Why doesn&#39;t the compiler report an error when a variable not declared as mutable is modified?", "body": "<p>As mentioned, this is not mutation, but deferred initialization:</p>\n\n<ul>\n<li>mutation is about changing the value of an existing variable,</li>\n<li>deferred initialization is about declaring a variable at one point, and initializing it later.</li>\n</ul>\n\n<p>The Rust compiler tracks whether a variable has a value at compile-time, so unlike C there is no risk of accidentally using an uninitialized variable (or unlike C++, a variable that was moved from).</p>\n\n<hr>\n\n<p>The most important reason for using deferred initialization is <strong>scope</strong>.</p>\n\n<pre><code>fn main() {\n    let x;\n    let mut v = vec!();\n\n    {\n        x = 2;\n        v.push(&amp;x);\n    }\n\n    println!(\"{:?}\", v);\n}\n</code></pre>\n\n<p>In Rust, the borrow-checker will validate that a reference cannot outlive the value it refers to, preventing dangling references.</p>\n\n<p>This means that <code>v.push(&amp;x)</code> requires that <code>x</code> lives longer than <code>v</code>, and therefore be declared <em>before</em> <code>v</code>.</p>\n\n<p>The need for it does not crop up often, but when it does other solutions would require run-time checks.</p>\n"}], "owner": {"reputation": 5623, "user_id": 6164172, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/cfe3f1dd56fc9c05a01393d3c618d727?s=128&d=identicon&r=PG&f=1", "display_name": "Troskyvs", "link": "https://stackoverflow.com/users/6164172/troskyvs"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 225, "favorite_count": 0, "accepted_answer_id": 43519886, "answer_count": 2, "score": 9, "last_activity_date": 1547487176, "creation_date": 1492691844, "last_edit_date": 1547487176, "question_id": 43519766, "link": "https://stackoverflow.com/questions/43519766/why-doesnt-the-compiler-report-an-error-when-a-variable-not-declared-as-mutable", "title": "Why doesn&#39;t the compiler report an error when a variable not declared as mutable is modified?", "body": "<p>I installed Rust 1.13 and tried:</p>\n\n<pre><code>fn main() {\n    let x: u32;\n    x = 10; // no error?\n}\n</code></pre>\n\n<p>When I compiled this file there's some warnings, but there's no error. As I'm not declaring <code>x</code> as <code>mut</code>, shouldn't <code>x = 10;</code> cause an error?</p>\n"}, {"tags": ["string", "char", "rust", "type-conversion"], "comments": [{"owner": {"reputation": 59630, "user_id": 636019, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/38ba39c7ba510ac2951c010c26afb6a6?s=128&d=identicon&r=PG", "display_name": "ildjarn", "link": "https://stackoverflow.com/users/636019/ildjarn"}, "edited": false, "score": 1, "creation_date": 1492683701, "post_id": 43516351, "comment_id": 74086586, "body": "<a href=\"https://play.rust-lang.org/?gist=76795197b5c0200b31bc86167f13cc94&amp;version=stable&amp;backtrace=1\" rel=\"nofollow noreferrer\">Food for thought</a>"}], "answers": [{"tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": true, "score": 7, "last_activity_date": 1492684522, "last_edit_date": 1495542851, "creation_date": 1492684522, "answer_id": 43517105, "question_id": 43516351, "link": "https://stackoverflow.com/questions/43516351/how-to-convert-a-string-of-digits-into-a-vector-of-digits/43517105#43517105", "title": "How to convert a string of digits into a vector of digits?", "body": "<p>You're close!</p>\n\n<p>First, the index loop <code>for i in 0..text.len()</code> is not necessary since you're going to use an iterator anyway. It's simpler to loop directly over the iterator: <code>for ch in text.chars()</code>. Not only that, but your index loop and the character iterator are likely to diverge, because <code>len()</code> returns you the number of bytes and <code>chars()</code> returns you the Unicode scalar values. Being UTF-8, the string is likely to have fewer Unicode scalar values than it has bytes.</p>\n\n<p>Next hurdle is that <code>to_digit(10)</code> returns an <code>Option</code>, telling you that there is a possibility the character won't be a digit. You can check whether <code>to_digit(10)</code> returned the <code>Some</code> variant of an <code>Option</code> with <code>if let Some(digit) = ch.to_digit(10)</code>.</p>\n\n<p>Pieced together, the code might now look like this:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn main() {\n    let text = \"731671\";\n    let mut v = Vec::new();\n    for ch in text.chars() {\n        if let Some(digit) = ch.to_digit(10) {\n            v.push(digit);\n        }\n    }\n    println!(\"{:?}\", v);\n}\n</code></pre>\n\n<p>Now, this is rather imperative: you're making a vector and filling it digit by digit, all by yourself. You can try a more <a href=\"https://stackoverflow.com/questions/10925689/functional-programming-vs-declarative-programming-vs-imperative-programming\">declarative or functional</a> approach by applying a transformation over the string:</p>\n\n<pre><code>fn main() {\n    let text = \"731671\";\n    let v: Vec&lt;u32&gt; = text.chars().flat_map(|ch| ch.to_digit(10)).collect();\n    println!(\"{:?}\", v);\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 600, "user_id": 3754495, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/65fff37f6d10b64ca1676adcc33f5ffb?s=128&d=identicon&r=PG", "display_name": "notriddle", "link": "https://stackoverflow.com/users/3754495/notriddle"}, "is_accepted": false, "score": 3, "last_activity_date": 1492713386, "creation_date": 1492713386, "answer_id": 43527347, "question_id": 43516351, "link": "https://stackoverflow.com/questions/43516351/how-to-convert-a-string-of-digits-into-a-vector-of-digits/43527347#43527347", "title": "How to convert a string of digits into a vector of digits?", "body": "<p>ArtemGr's answer is pretty good, but their version will skip any characters that aren't digits. If you'd rather have it fail on bad digits, you can use this version instead:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn to_digits(text: &amp;str) -&gt; Option&lt;Vec&lt;u32&gt;&gt; {\n    text.chars().map(|ch| ch.to_digit(10)).collect()\n}\nfn main() {\n    println!(\"{:?}\", to_digits(\"731671\"));\n    println!(\"{:?}\", to_digits(\"731six71\"));\n}\n</code></pre>\n\n<p>Output:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Some([7, 3, 1, 6, 7, 1])\nNone\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 1563, "user_id": 1619003, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/wKhdR.png?s=128&g=1", "display_name": "GraphicalDot", "link": "https://stackoverflow.com/users/1619003/graphicaldot"}, "is_accepted": false, "score": 0, "last_activity_date": 1589723224, "creation_date": 1589723224, "answer_id": 61852829, "question_id": 43516351, "link": "https://stackoverflow.com/questions/43516351/how-to-convert-a-string-of-digits-into-a-vector-of-digits/61852829#61852829", "title": "How to convert a string of digits into a vector of digits?", "body": "<p>New version of Rust</p>\n\n<p>Returns an Enum if conversion to digit fails.</p>\n\n<pre><code>#[derive(Debug, PartialEq)]\npub enum Error {\n    InvalidDigit(char),\n}\n\n\nfn to_digits(text: &amp;str) -&gt;  Result&lt;Vec&lt;u32&gt;, Error&gt; {\n\n    let mut numbers = Vec::new();\n    for s in string_digits.chars(){\n\n        match s.to_digit(10){\n            Some(number) =&gt; numbers.push(number),\n            None =&gt; {return Err(Error::InvalidDigit(s));}\n        }\n    Ok(numbers)\n    }\n</code></pre>\n"}], "owner": {"reputation": 2897, "user_id": 3392714, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/302ac6bfbe982dcd53aa123f9bde72eb?s=128&d=identicon&r=PG&f=1", "display_name": "dani", "link": "https://stackoverflow.com/users/3392714/dani"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 745, "favorite_count": 0, "accepted_answer_id": 43517105, "answer_count": 3, "score": 2, "last_activity_date": 1589723224, "creation_date": 1492682626, "question_id": 43516351, "link": "https://stackoverflow.com/questions/43516351/how-to-convert-a-string-of-digits-into-a-vector-of-digits", "title": "How to convert a string of digits into a vector of digits?", "body": "<p>I'm trying to store a <code>string</code> (or <code>str</code>) of digits, e.g. <code>12345</code> into a vector, such that the vector contains <code>{1,2,3,4,5}</code>.</p>\n\n<p>As I'm totally new to Rust, I'm having problems with the types (<code>String</code>, <code>str</code>, <code>char</code>, ...) but also the lack of any information about conversion.</p>\n\n<p>My current code looks like this:</p>\n\n<pre><code>fn main() {\n    let text = \"731671\";                \n    let mut v: Vec&lt;i32&gt;;\n    let mut d = text.chars();\n    for i in 0..text.len() {\n        v.push( d.next().to_digit(10) );\n    }\n}\n</code></pre>\n"}, {"tags": ["rust", "driver", "ethernet", "ioports"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492692852, "post_id": 43510285, "comment_id": 74093458, "body": "<i>and the driver needs to generate an interrupt on receiving a packet.</i> \u2014 I&#39;ve never written a kernel, but I&#39;m pretty sure you&#39;ve got this backwards. The network card will raise an interrupt when data is available to read. The kernel will do some bookkeeping in the interrupt and then later on (outside of the interrupt) read the data from the card."}, {"owner": {"reputation": 636, "user_id": 4091722, "user_type": "registered", "accept_rate": 25, "profile_image": "https://i.stack.imgur.com/kQuJG.jpg?s=128&g=1", "display_name": "rajiv_", "link": "https://stackoverflow.com/users/4091722/rajiv"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1492700813, "post_id": 43510285, "comment_id": 74100049, "body": "Yeah. that is correct. I am editing it."}], "owner": {"reputation": 636, "user_id": 4091722, "user_type": "registered", "accept_rate": 25, "profile_image": "https://i.stack.imgur.com/kQuJG.jpg?s=128&g=1", "display_name": "rajiv_", "link": "https://stackoverflow.com/users/4091722/rajiv"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 221, "favorite_count": 0, "answer_count": 0, "score": 2, "last_activity_date": 1492700900, "creation_date": 1492662979, "last_edit_date": 1492700900, "question_id": 43510285, "link": "https://stackoverflow.com/questions/43510285/how-to-communicate-between-network-card-and-the-ethernet-driver", "title": "How to communicate between Network card and the Ethernet driver?", "body": "<p>I am trying to build an unikernel in Rust,which will boot and start a web server. I am using <strong>Qemu</strong> for testing purposes.</p>\n\n<p>So far, I have managed to write an OS with segmentation, paging and interrupts enabled by following various blogs online and projects on github. The kernel is up and running and is able to detect software interrupts and also hardware interrupts if an interrupt of kind <code>int 32</code> is explicitly called. \nAfter this I enabled IO Ports and implemented all the Port I/O functions like <code>inb</code>,<code>outb</code>,<code>inl</code>,<code>outl</code>,<code>inw</code>,<code>outw</code> that helps me to read and write to the port. I read somewhere that this is how the driver and the device communicate with each other. Using these I used the probe method to detect the peripheral devices. In qemu, 3 devices were detected. </p>\n\n<p>One of those devices is <code>Intel 82540EM Ethernet Controller</code> with device id <code>0x100e</code> and vendor id <code>0x8086</code>. I am trying to communicate with this driver to implement the transmission and reception of the packets that will complete my project. I understood that all the communication that happens between the network card and the driver happens through the device's IO ports.  </p>\n\n<p>But, I couldn't clearly understand what happens in the background. So, can someone explain me-\n<strong>How do we detect that some new packet has arrived to the Network card?</strong> </p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 411, "user_id": 1541138, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/67b8f63b8132ce94dbdff783e71e8060?s=128&d=identicon&r=PG", "display_name": "Brett Jackson", "link": "https://stackoverflow.com/users/1541138/brett-jackson"}, "edited": false, "score": 0, "creation_date": 1492676052, "post_id": 43511622, "comment_id": 74081242, "body": "Excellent! This works! I was also able to just cast the enum to <code>u8</code>."}], "tags": [], "owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "is_accepted": true, "score": 16, "last_activity_date": 1492692302, "last_edit_date": 1492692302, "creation_date": 1492669050, "answer_id": 43511622, "question_id": 43509560, "link": "https://stackoverflow.com/questions/43509560/how-to-implement-bitwise-operations-on-a-bitflags-enum/43511622#43511622", "title": "How to implement bitwise operations on a bitflags enum?", "body": "<p>An <code>enum</code> in Rust is not intended to be used as bit flags. <code>PublicFlags</code> can <em>only</em> take the values given in the enum (and not a combination). So for instance, the following match statement is exhaustive:</p>\n\n<pre><code>let flags: PublicFlags;\n...\nmatch flags {\n    PublicFlagVersion =&gt; {...}\n    PublicFlagReset =&gt; {...}\n    NoncePresent =&gt; {...}\n    IdPresent =&gt; {...}\n    PktNumLen4 =&gt; {...}\n    PktNumLen2 =&gt; {...}\n    PktNumLen1 =&gt; {...}\n    Multipath =&gt; {...}\n}\n</code></pre>\n\n<p>There is no way to have a <code>PublicFlags</code> variable with a combination of the flags.</p>\n\n<p>The solution is to actually store the value as a <code>u8</code>, then use constants to store the value of each flag. This can be cumbersome, but thankfully the <a href=\"https://docs.rs/bitflags/0.8.2/bitflags/\" rel=\"noreferrer\">bitflags</a> crate wraps all the boilerplate up in a macro for you. Here is an example how you would create your struct using bitflags:</p>\n\n<pre><code>#[macro_use]\nextern crate bitflags;\n\nbitflags! {\n    flags PublicFlags: u8 {\n        const PUBLIC_FLAG_VERSION = 0x01,\n        const PUBLIC_FLAG_RESET = 0x02,\n        const NONCE_PRESENT = 0x04,\n        const ID_PRESENT = 0x08,\n        const PKT_NUM_LEN_4 = 0x30,\n        const PKT_NUM_LEN_2 = 0x20,\n        const PKT_NUM_LEN_1 = 0x10,\n        const MULTIPATH = 0x40,\n    }\n}\n\nfn main() {\n    let flag = PUBLIC_FLAG_VERSION | ID_PRESENT;\n    assert!((flag &amp; MULTIPATH).is_empty()); \n    assert!(flag.contains(ID_PRESENT));\n} \n</code></pre>\n"}], "owner": {"reputation": 411, "user_id": 1541138, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/67b8f63b8132ce94dbdff783e71e8060?s=128&d=identicon&r=PG", "display_name": "Brett Jackson", "link": "https://stackoverflow.com/users/1541138/brett-jackson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5425, "favorite_count": 0, "accepted_answer_id": 43511622, "answer_count": 1, "score": 10, "last_activity_date": 1492740683, "creation_date": 1492657982, "last_edit_date": 1492740683, "question_id": 43509560, "link": "https://stackoverflow.com/questions/43509560/how-to-implement-bitwise-operations-on-a-bitflags-enum", "title": "How to implement bitwise operations on a bitflags enum?", "body": "<p>I have an enum that looks like this:</p>\n\n<pre><code>#[repr(u8)]\npub enum PublicFlags {\n    PublicFlagVersion = 0x01,\n    PublicFlagReset = 0x02,\n    NoncePresent = 0x04,\n    IdPresent = 0x08,\n    PktNumLen4 = 0x30,\n    PktNumLen2 = 0x20,\n    PktNumLen1 = 0x10,\n    Multipath = 0x40,\n}\n</code></pre>\n\n<p>I want to do a bitwise operation on several of the enum values. However, the Rust compiler complains:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>an implementation of `std::ops::BitAnd` might be missing for `PublicFlags`.\n</code></pre>\n"}]