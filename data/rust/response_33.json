[{"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 2, "creation_date": 1440632643, "post_id": 32238059, "comment_id": 52359073, "body": "A reduction of the problem to its essence: <a href=\"http://is.gd/RIrNxZ\" rel=\"nofollow noreferrer\">something with <code>let f = |s| s; h(f);</code> does not work</a>, <a href=\"http://is.gd/GJHrXc\" rel=\"nofollow noreferrer\"><i>but something with <code>h(|s| s);</code> does</i></a>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1440658034, "post_id": 32238059, "comment_id": 52366140, "body": "This is a bit vague, could you post the not working code?"}, {"owner": {"reputation": 520, "user_id": 884498, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/88109a4658cfee0b9d680f48f073d9d4?s=128&d=identicon&r=PG", "display_name": "Nathan Fox", "link": "https://stackoverflow.com/users/884498/nathan-fox"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1440675837, "post_id": 32238059, "comment_id": 52377279, "body": "@MatthieuM. The not working code was in a link to a Rust Playground, but I edited the question to make this more obvious"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1440678089, "post_id": 32238059, "comment_id": 52378805, "body": "@NathanFuchs: Thanks, in general SO favors content to be <i>on SO</i>, because links go stale (especially minified URLs, they have a short expiry date)."}, {"owner": {"reputation": 650, "user_id": 1092644, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a446220154cd626be17c000557b791aa?s=128&d=identicon&r=PG", "display_name": "Rym", "link": "https://stackoverflow.com/users/1092644/rym"}, "edited": false, "score": 0, "creation_date": 1440684963, "post_id": 32238059, "comment_id": 52384115, "body": "Amusingly, removing some type annotations from your second example gets it working: <a href=\"http://is.gd/jswjjB\" rel=\"nofollow noreferrer\">is.gd/jswjjB</a>"}, {"owner": {"reputation": 520, "user_id": 884498, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/88109a4658cfee0b9d680f48f073d9d4?s=128&d=identicon&r=PG", "display_name": "Nathan Fox", "link": "https://stackoverflow.com/users/884498/nathan-fox"}, "reply_to_user": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1440714360, "post_id": 32238059, "comment_id": 52400640, "body": "@ChrisMorgan your simplified example seems like a compiler bug. Is there a tracking issue for this in Github?"}, {"owner": {"reputation": 3711, "user_id": 55965, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/83dd2a385c44fc42d52f14fccd9d992a?s=128&d=identicon&r=PG", "display_name": "Adrian Heine", "link": "https://stackoverflow.com/users/55965/adrian-heine"}, "reply_to_user": {"reputation": 650, "user_id": 1092644, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a446220154cd626be17c000557b791aa?s=128&d=identicon&r=PG", "display_name": "Rym", "link": "https://stackoverflow.com/users/1092644/rym"}, "edited": false, "score": 0, "creation_date": 1451418000, "post_id": 32238059, "comment_id": 56776902, "body": "@Rym Your code doesn&#39;t compile anymore."}, {"owner": {"reputation": 650, "user_id": 1092644, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a446220154cd626be17c000557b791aa?s=128&d=identicon&r=PG", "display_name": "Rym", "link": "https://stackoverflow.com/users/1092644/rym"}, "edited": false, "score": 0, "creation_date": 1451776469, "post_id": 32238059, "comment_id": 56888188, "body": "My guess is it&#39;s related to this change: <a href=\"https://github.com/rust-lang/rfcs/pull/1214\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/pull/1214</a>"}], "owner": {"reputation": 520, "user_id": 884498, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/88109a4658cfee0b9d680f48f073d9d4?s=128&d=identicon&r=PG", "display_name": "Nathan Fox", "link": "https://stackoverflow.com/users/884498/nathan-fox"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 309, "favorite_count": 0, "answer_count": 0, "score": 0, "last_activity_date": 1440675783, "creation_date": 1440629973, "last_edit_date": 1495541748, "question_id": 32238059, "link": "https://stackoverflow.com/questions/32238059/cannot-infer-appropriate-lifetime", "title": "Cannot infer appropriate lifetime", "body": "<p>I am still having problems with lifetimes in Rust. I want to use a closure that implements a trait that returns a reference, but I can't figure out how to make the compiler happy.</p>\n\n<p>This is kind of an extension of <a href=\"https://stackoverflow.com/questions/32194367/expected-bound-lifetime-parameter-found-concrete-lifetime\">this question I asked recently</a>\nwhich I got working, but now when I add a closure to the program it won't compile.</p>\n\n<p>I think part of my problem is I don't really understand the difference between declaring a lifetime in an <code>impl</code> block, and using <code>for</code> in a <code>where</code> clause.</p>\n\n<p>If I can get it to work using <a href=\"http://is.gd/GFE1Mv\" rel=\"nofollow noreferrer\">lifetimes in an impl block</a> or <a href=\"http://is.gd/cy3PX9\" rel=\"nofollow noreferrer\">lifetimes in a <code>for</code> block</a>, I would be happy, but I would also like to know the difference between them.</p>\n\n<p>Edit: The last 2 links are links to a Rust playground with code I can't get to compile. The first link is also shown below:</p>\n\n<pre><code>pub struct Response&lt;'a&gt;{\n    data: &amp;'a str\n}\n\npub enum Action&lt;'a&gt;{\n    Next(Response&lt;'a&gt;),\n    Done\n}\n\npub trait Handler&lt;'a&gt;: Send + Sync{\n    fn handle(&amp;self, res: Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;;\n}\n\nimpl&lt;'a, T&gt; Handler&lt;'a&gt; for T\nwhere T: Send + Sync + Fn(Response&lt;'a&gt;) -&gt; Action&lt;'a&gt; {\n    fn handle(&amp;self, res: Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;{\n        (*self)(res)\n    }\n}\n\nfn main(){\n    println!(\"running\");\n    do_something_with_handler(|res: Response| -&gt; Action{\n        //this closure should implement Handler\n\n        //Action::Done //This compiles if Done is returned instead of Next\n        Action::Next(res)\n    });\n}\n\npub fn do_something_with_handler&lt;'a, T&gt;(handler: T) where T: Handler&lt;'a&gt; + 'static{\n    //do something here\n}\n\n// This isn't used in this example, but I want to make sure the trait\n// can still be implemented for arbitrary types\nstruct SomethingElse;\n\nimpl&lt;'a&gt; Handler&lt;'a&gt; for SomethingElse{\n    fn handle(&amp;self, res: Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;{\n        Action::Next(res)\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1440656749, "post_id": 32238327, "comment_id": 52365479, "body": "<i>pocket flamethrower</i> =&gt; Where can I find one?"}, {"owner": {"reputation": 17720, "user_id": 498594, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/EYtd3.png?s=128&g=1", "display_name": "Kelvin", "link": "https://stackoverflow.com/users/498594/kelvin"}, "edited": false, "score": 0, "creation_date": 1440694145, "post_id": 32238327, "comment_id": 52390387, "body": "Should I think of &quot;moves&quot; as the <i>contents</i> being moved, and not as the &quot;variable (label) no longer being accessible&quot;? Is it as though the move makes <code>v0</code> undefined - i.e. the compiler is protecting me from accessing an undefined variable? The compiler error messages are somewhat confusing. E.g. <code>use of moved value: v0</code> should say &quot;use of value moved out of v0&quot;. And <code>v0 moved here because...</code> should be &quot;<i>contents</i> of v0 moved here...&quot; (emphasis added). <code>v0</code> is not the thing being moved. Am I understanding correctly?"}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 7, "last_activity_date": 1440631832, "creation_date": 1440631832, "answer_id": 32238327, "question_id": 32237882, "link": "https://stackoverflow.com/questions/32237882/assigning-to-a-moved-variable-seems-to-negate-the-move/32238327#32238327", "title": "Assigning to a moved variable seems to &quot;negate&quot; the move", "body": "<p>Think of <code>v0</code> and <code>v1</code> as cardboard boxes which can contain one widget.</p>\n\n<p>With <code>let mut v0 = vec![0, 1, 2];</code> you create a cardboard box with the label \u201cv0\u201d written on its side in black marker a label saying \u201cContents: one <code>Vec&lt;i64&gt;</code>\u201d on its side, and put a widget labelled \u201c[0, 1, 2]\u201d in it. (The \u201cmut\u201d becomes a tacky sticker on the box saying that you\u2019re allowed to fiddle with what\u2019s stored in it, e.g. pushing a new element onto the vector, or throwing away the vector and putting a new one in its place.)</p>\n\n<p>With <code>let v1 = v0;</code>, you create another cardboard box, this one with the label \u201cv1\u201d (and another \u201cContents: one <code>Vec&lt;i64&gt;</code>\u201d label), and take the widget out of the \u201cv0\u201d box and put it in the \u201cv1\u201d box. (The v1 cardboard box, not having been declared with <code>mut</code>, becomes a tacky sticker on the side of the box saying that you\u2019re only allowed to take the widget out of the box, not to put anything else in it. \u201cNot for reuse,\u201d it reads. Maybe clamshell packaging would be a better analogy for such a thing. Just take care not to injure yourself with the scissors.)</p>\n\n<p>The v0 cardboard box does not now contain any widget, so the \u201cContents: one <code>Vec&lt;i64&gt;</code>\u201d isn\u2019t true\u2014until it is true again, you can\u2019t take anything out of the box or use the contents of the box, can you? If you ask for its contents, e.g. with specifying <code>v0</code> as the return value for the function, the compiler will yell at you because it knows that there won\u2019t be a widget in the cardboard box.</p>\n\n<p>If you declared the v1 cardboard box inside a nested block, when you get to the end of that block you burninate the v1 cardboard box and anything inside it with your pocket flamethrower.</p>\n\n<p>If you write <code>v0 = vec![1, 2, 3]</code>, you are creating a new widget with the label \u201c[1, 2, 3]\u201d on it and dropping it in the cardboard box labelled v0. The compiler, following the instruction sheet, can see that by the end of the function, the v0 cardboard box will always contain a widget, so it lets you return it as the value.</p>\n\n<hr>\n\n<p>Applying the analogy:</p>\n\n<pre><code>fn testvec() -&gt; Vec&lt;i64&gt; {\n    let mut v0 = vec![0,1,2];\n    let v1 = v0;\n    v0 = vec![1,2,3];\n    v0\n}\n</code></pre>\n\n<p>This is an instruction sheet that reads roughly like this:</p>\n\n<ol>\n<li><p>This instruction sheet is called \u201ctestvec\u201d and makes a <code>Vec&lt;i64&gt;</code> widget.</p></li>\n<li><p>Take a cardboard box and write \u201cv0\u201d on its side.</p>\n\n<p>Make a <code>[0, 1, 2]</code> widget and drop it in the v0 box.</p></li>\n<li><p>Take a cardboard box and write \u201cv1\u201d on its side.</p>\n\n<p>Take the <code>[0, 1, 2]</code> widget out of the v0 box and put it in the v1 box.</p></li>\n<li><p>Make a <code>[1, 2, 3]</code> widget and drop it in the (now empty) v0 box.</p></li>\n<li><p>Take the widget out of the v0 box: it\u2019s the final product of this instruction sheet.</p>\n\n<p>Oh, and we don\u2019t need that v1 box any more, so burninate it and the widget that it contains.</p></li>\n</ol>\n"}], "owner": {"reputation": 17720, "user_id": 498594, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/EYtd3.png?s=128&g=1", "display_name": "Kelvin", "link": "https://stackoverflow.com/users/498594/kelvin"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 165, "favorite_count": 0, "accepted_answer_id": 32238327, "answer_count": 1, "score": 1, "last_activity_date": 1441124092, "creation_date": 1440628958, "last_edit_date": 1441124092, "question_id": 32237882, "link": "https://stackoverflow.com/questions/32237882/assigning-to-a-moved-variable-seems-to-negate-the-move", "title": "Assigning to a moved variable seems to &quot;negate&quot; the move", "body": "<p>This function doesn't compile because it tries to return <code>v0</code> which has been moved where it's assigned to <code>v1</code>. I understand that.</p>\n\n<pre><code>fn testvec() -&gt; Vec&lt;i64&gt; {\n    let mut v0 = vec![0,1,2];\n    let v1 = v0;\n    //v0 = vec![1,2,3];\n    v0\n}\n</code></pre>\n\n<p>But if I uncomment the <code>v0</code> assignment, it compiles. What's the principle behind this? Is it documented?</p>\n\n<p>When I first discovered this behavior, the function looked like this. It acts the same as above, but I also wonder if the nested block makes a difference.</p>\n\n<pre><code>fn testvec() -&gt; Vec&lt;i64&gt; {\n    let mut v0 = vec![0,1,2];\n    {\n      let v1 = v0;\n      //v0 = vec![1,2,3];\n    }\n    v0\n}\n</code></pre>\n\n<p>UPDATE</p>\n\n<p>To summarize my confusion: I thought a \"move\" actually made the variable name inaccessible. But in reality only the contents of the variable become inaccessible. E.g. this compiler error is misleading: <code>v0 moved here because</code> - it sounds like the variable <em>name</em> was moved instead of merely its value.</p>\n"}, {"tags": ["initialization", "rust"], "answers": [{"comments": [{"owner": {"reputation": 95188, "user_id": 440119, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/5ec9ca2a92a94a5470396073129d79e7?s=128&d=identicon&r=PG", "display_name": "Benjamin Lindley", "link": "https://stackoverflow.com/users/440119/benjamin-lindley"}, "edited": false, "score": 0, "creation_date": 1440627029, "post_id": 32237502, "comment_id": 52357333, "body": "You presume correctly. It was just the first simple example that popped into my head. Perhaps a better example would be a <code>Point</code> struct, where you want named members (x, y and z). It doesn&#39;t have to be a simple structure though. Even something like <code>Vec</code>, from the standard library, where <code>new</code> creates an empty container, would be a candidate."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 95188, "user_id": 440119, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/5ec9ca2a92a94a5470396073129d79e7?s=128&d=identicon&r=PG", "display_name": "Benjamin Lindley", "link": "https://stackoverflow.com/users/440119/benjamin-lindley"}, "edited": false, "score": 0, "creation_date": 1440633465, "post_id": 32237502, "comment_id": 52359270, "body": "@BenjaminLindley: I\u2019ve added some more explanation explaining the whys and wherefores."}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 3, "last_activity_date": 1440633442, "last_edit_date": 1440633442, "creation_date": 1440626840, "answer_id": 32237502, "question_id": 32237280, "link": "https://stackoverflow.com/questions/32237280/function-with-same-name-as-struct/32237502#32237502", "title": "Function with same name as struct", "body": "<p>If you want to use <code>Pair(T, U)</code> then you should consider using a tuple struct instead:</p>\n\n<pre><code>#[derive(Debug, Clone, Copy)]\nstruct Pair&lt;T, U&gt;(T, U);\n\nfn main(){\n    let x = Pair(1, 2);\n    println!(\"{:?}\", x);\n    println!(\"{:?}, {:?}\", (x.0, x.1));\n}\n</code></pre>\n\n<p>Or, y\u2019know, just a tuple (<code>(T, U)</code>). But I presume that <code>Pair</code> is not your actual use case.</p>\n\n<hr>\n\n<p>There was a time when having identically named functions was the convention for default constructors; this convention fell out of favour as time went by. It is considered bad form nowadays, probably mostly for consistency. If you have a tuple struct (or variant) <code>Pair(T, U)</code>, then you can use <code>Pair(first, last)</code> in a pattern, but if you have <code>Pair { first: T, last: U }</code> then you would need to use something more like <code>Pair { first, last }</code> in a pattern, and so your <code>Pair(first, last)</code> function would be inconsistent with the pattern. It is generally felt, thus, that these type of camel-case functions should be reserved solely for tuple structs and tuple variants, where it can be known that it is genuinely reflecting what is contained in the data structure with no further processing or magic.</p>\n"}], "owner": {"reputation": 95188, "user_id": 440119, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/5ec9ca2a92a94a5470396073129d79e7?s=128&d=identicon&r=PG", "display_name": "Benjamin Lindley", "link": "https://stackoverflow.com/users/440119/benjamin-lindley"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 161, "favorite_count": 0, "accepted_answer_id": 32237502, "answer_count": 1, "score": 0, "last_activity_date": 1440633442, "creation_date": 1440625769, "question_id": 32237280, "link": "https://stackoverflow.com/questions/32237280/function-with-same-name-as-struct", "title": "Function with same name as struct", "body": "<p>In general, I prefer to write initializer functions with descriptive names. However, for some structs, there is an obvious default initializer function. The standard Rust name for such a function is <code>new</code>, placed in the <code>impl</code> block for the struct. However, today I realized that I can give a function the same name as a struct, and thought this would be a good way to implement the obvious initializer function. For example:</p>\n\n<pre><code>#[derive(Debug, Clone, Copy)]\nstruct Pair&lt;T, U&gt; {\n    first: T,\n    second: U,\n}\n\n#[allow(non_snake_case)]\nfn Pair&lt;T, U&gt;(first: T, second: U) -&gt; Pair&lt;T, U&gt; {\n    Pair::&lt;T, U&gt; {\n        first: first,\n        second: second,\n    }\n}\n\nfn main(){\n    let x = Pair(1, 2);\n    println!(\"{:?}\", x);\n}\n</code></pre>\n\n<p>This is, in my opinion, much more appealing than this:</p>\n\n<pre><code>let x = Pair::new(1, 2);\n</code></pre>\n\n<p>However, I've never seen anyone else do this, and my question is simply if there are any problems with this approach. Are there, for example, ambiguities which it can cause which will not be there with the <code>new</code> implementation?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 2715, "user_id": 612512, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/bb7101e3af8cd635dbbb891055675534?s=128&d=identicon&r=PG", "display_name": "Christopher Stevenson", "link": "https://stackoverflow.com/users/612512/christopher-stevenson"}, "edited": false, "score": 0, "creation_date": 1440630052, "post_id": 32236571, "comment_id": 52358364, "body": "Documentation reference: <a href=\"http://doc.rust-lang.org/std/mem/fn.replace.html\" rel=\"nofollow noreferrer\">std::mem::replace</a>"}, {"owner": {"reputation": 1343, "user_id": 4365239, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/88acc4986ddaf51e21c254fb8c0f11b8?s=128&d=identicon&r=PG&f=1", "display_name": "tafia", "link": "https://stackoverflow.com/users/4365239/tafia"}, "edited": false, "score": 0, "creation_date": 1440672263, "post_id": 32236571, "comment_id": 52374930, "body": "Can you explain more why it didn&#39;t work in the first place ? Why does <code>f</code> need to be moved out?"}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 1343, "user_id": 4365239, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/88acc4986ddaf51e21c254fb8c0f11b8?s=128&d=identicon&r=PG&f=1", "display_name": "tafia", "link": "https://stackoverflow.com/users/4365239/tafia"}, "edited": false, "score": 0, "creation_date": 1440682935, "post_id": 32236571, "comment_id": 52382575, "body": "@tafia: <code>FnBox</code> is based on <code>FnOnce</code>, which consumes the closure environment; that is, <code>f.call_box</code> takes <code>self</code> by value, thus <code>f</code> must be <code>Box&lt;FnBox(&amp;T) + Send&gt;</code>. A mutable reference to that will not suffice, and a mutable reference is all you had in your initial example (hence \u201ccannot move out of borrowed context\u201d, it\u2019s trying to move the <code>Box&lt;FnBox(&amp;T) + Send&gt;</code> out of a mutable reference)."}, {"owner": {"reputation": 1343, "user_id": 4365239, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/88acc4986ddaf51e21c254fb8c0f11b8?s=128&d=identicon&r=PG&f=1", "display_name": "tafia", "link": "https://stackoverflow.com/users/4365239/tafia"}, "reply_to_user": {"reputation": 2715, "user_id": 612512, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/bb7101e3af8cd635dbbb891055675534?s=128&d=identicon&r=PG", "display_name": "Christopher Stevenson", "link": "https://stackoverflow.com/users/612512/christopher-stevenson"}, "edited": false, "score": 0, "creation_date": 1440725262, "post_id": 32236571, "comment_id": 52403530, "body": "@Chris Morgan: Thanks!! It&#39;s worth being in your answer for next readers"}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": false, "score": 7, "last_activity_date": 1440622668, "creation_date": 1440622668, "answer_id": 32236571, "question_id": 32236430, "link": "https://stackoverflow.com/questions/32236430/fnonce-inside-enum-cannot-move-out-of-borrowed-content/32236571#32236571", "title": "FnOnce inside Enum: cannot move out of borrowed content", "body": "<p><code>std::mem::replace</code> is what you should use there, like this:</p>\n\n<pre><code>use std::mem;\n\n\u2026\n\n    fn do_it(&amp;self, t: T) {\n        match mem::replace(self.foo.lock().unwrap(), Foo::DoNothing) {\n            Foo::CallFunction(f) =&gt; {\n                f.call_box((&amp;t,));\n            }\n            _ =&gt; panic!(\"...\")\n        }\n    }\n</code></pre>\n"}], "owner": {"reputation": 311, "user_id": 374202, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1e6f81a6fa4ff1526b10399579c89baa?s=128&d=identicon&r=PG", "display_name": "Florianx", "link": "https://stackoverflow.com/users/374202/florianx"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 420, "favorite_count": 0, "answer_count": 1, "score": 5, "last_activity_date": 1440622668, "creation_date": 1440622051, "question_id": 32236430, "link": "https://stackoverflow.com/questions/32236430/fnonce-inside-enum-cannot-move-out-of-borrowed-content", "title": "FnOnce inside Enum: cannot move out of borrowed content", "body": "<p>I'm new to rust and still have some problems with ownership/borrowing. In this case, I want to store a FnOnce in an enum and then call it later on from another thread. I tried a lot of different variants but always get stuck somewhere. Here is a reduced variant of what I currently have:</p>\n\n<pre><code>#![feature(fnbox)]\n\nuse std::sync::{Arc, Mutex};\nuse std::boxed::{Box, FnBox};\n\nenum Foo&lt;T&gt; {\n    DoNothing,\n    CallFunction(Box&lt;FnBox(&amp;T) + Send&gt;)\n}\n\nstruct FooInMutex&lt;T&gt; {\n    foo: Arc&lt;Mutex&lt;Foo&lt;T&gt;&gt;&gt;\n}\n\nimpl&lt;T&gt; FooInMutex&lt;T&gt; {\n    fn put_fn(&amp;self, f: Box&lt;FnBox(&amp;T)+Send&gt;) {\n        let mut foo = self.foo.lock().unwrap();\n        let mut new_foo : Foo&lt;T&gt;;\n        match *foo {\n            Foo::DoNothing =&gt;\n                new_foo = Foo::CallFunction(f),\n            _ =&gt;\n                new_foo = Foo::DoNothing\n        }\n        *foo = new_foo;\n    }\n\n    fn do_it(&amp;self, t: T) {\n        let mut foo = self.foo.lock().unwrap();\n        let mut new_foo : Foo&lt;T&gt;;\n        match *foo {\n            Foo::CallFunction(ref mut f) =&gt; {\n                //f(&amp;t)\n                f.call_box((&amp;t,));\n                new_foo = Foo::DoNothing;\n            }\n            _ =&gt;\n                panic!(\"...\")\n        }\n        *foo = new_foo;\n    }\n}\n\n#[test]\nfn it_works() {\n    let x = FooInMutex { foo: Arch::new(Mutex::new(Foo::DoNothing)) };\n\n    x.put_fn(Box::new(|| panic!(\"foo\"))); \n    x.do_it();\n}\n</code></pre>\n\n<p>I use \"rustc 1.4.0-nightly (e35fd7481 2015-08-17)\".\nThe error message:</p>\n\n<pre><code>src/lib.rs:35:17: 35:18 error: cannot move out of borrowed content\nsrc/lib.rs:35                 f.call_box((&amp;t,));\n                              ^\n</code></pre>\n\n<p>As I understand it, <em>f</em> is owned by the enum in the mutex and I only borrow it via *foo. But for calling <em>f</em>, I need move it out. But how to do this? Or what else do I have to change to make this example work?</p>\n"}, {"tags": ["gcc", "rust", "cross-compiling", "mingw-w64"], "answers": [{"tags": [], "owner": {"reputation": 3233, "user_id": 2487227, "user_type": "registered", "accept_rate": 77, "profile_image": "https://i.stack.imgur.com/yLbAE.jpg?s=128&g=1", "display_name": "Frederick Zhang", "link": "https://stackoverflow.com/users/2487227/frederick-zhang"}, "is_accepted": true, "score": 1, "last_activity_date": 1441146633, "last_edit_date": 1441146633, "creation_date": 1441134251, "answer_id": 32339104, "question_id": 32235620, "link": "https://stackoverflow.com/questions/32235620/failed-to-cross-compile-curl-rust-example/32339104#32339104", "title": "Failed to cross-compile curl-rust example", "body": "<p>The major cause of the problem was that the build script didn't pass <code>host</code> to the configuration command of <code>curl</code>. I've sent a <a href=\"https://github.com/carllerche/curl-rust/pull/83\" rel=\"nofollow\">PR</a> to the author after a <a href=\"https://github.com/carllerche/curl-rust/issues/82\" rel=\"nofollow\">discussion</a>. So wait for the update or just apply the patch locally.</p>\n\n<p>But there's actually another problem which may fail the compilation during the final linking stage. The <code>ssl</code> should have been linked before <code>crypto</code> however the <code>rust-openssl</code> did it in a reversed sequence. The author of <code>curl-rust</code> has sent a PR to the <code>rust-openssl</code> project.</p>\n"}], "owner": {"reputation": 3233, "user_id": 2487227, "user_type": "registered", "accept_rate": 77, "profile_image": "https://i.stack.imgur.com/yLbAE.jpg?s=128&g=1", "display_name": "Frederick Zhang", "link": "https://stackoverflow.com/users/2487227/frederick-zhang"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 482, "favorite_count": 0, "accepted_answer_id": 32339104, "answer_count": 1, "score": 3, "last_activity_date": 1441146633, "creation_date": 1440619154, "last_edit_date": 1440661464, "question_id": 32235620, "link": "https://stackoverflow.com/questions/32235620/failed-to-cross-compile-curl-rust-example", "title": "Failed to cross-compile curl-rust example", "body": "<p>I built a Rust 1.2.0 cross compiler under Fedora (x86_64) which supported multiple targets including <code>x86_64-pc-windows-gnu</code> and <code>arm-unknown-linux-gnueabihf</code> and successfully compiled some simple programs.</p>\n\n<p>However, I failed to cross compile the example program from <a href=\"https://github.com/carllerche/curl-rust\" rel=\"nofollow\">curl-rust</a>.</p>\n\n<p>When building for <code>x86_64-pc-windows-gnu</code>, I got:</p>\n\n<pre><code>     Compiling curl_example v0.1.0 (file:///home/frederick/rust/curl_example)\n     Running `rustc src/main.rs --crate-name curl_example --crate-type bin -C opt-level=3 --out-dir /home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release --emit=dep-info,link --target x86_64-pc-windows-gnu -C ar=x86_64-w64-mingw32-ar -C linker=x86_64-w64-mingw32-gcc -L dependency=/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release -L dependency=/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps --extern curl=/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/libcurl-8828a61714ae0eb4.rlib -L /home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/build/curl-sys-b582fd2220a1331e/out/lib`\nerror: linking with `x86_64-w64-mingw32-gcc` failed: exit code: 1\nnote: \"x86_64-w64-mingw32-gcc\" \"-Wl,--enable-long-section-names\" \"-fno-use-linker-plugin\" \"-Wl,--nxcompat\" \"-static-libgcc\" \"-m64\" \"-L\" \"/usr/local/lib/rustlib/x86_64-pc-windows-gnu/lib\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/curl_example.o\" \"-o\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/curl_example.exe\" \"-Wl,--gc-sections\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/libcurl-8828a61714ae0eb4.rlib\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/libcurl_sys-b582fd2220a1331e.rlib\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/liburl-5247f81b4a7b5841.rlib\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/libmatches-68291f81832fc22d.rlib\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/liblog-8a6aba167994951e.rlib\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/liblibz_sys-e8e1552876cd3abe.rlib\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/liblibc-144c435538abd757.rlib\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/librustc_serialize-7ff5bfc027146194.rlib\" \"/usr/local/lib/rustlib/x86_64-pc-windows-gnu/lib/libstd-d8ace771.rlib\" \"/usr/local/lib/rustlib/x86_64-pc-windows-gnu/lib/libcollections-d8ace771.rlib\" \"/usr/local/lib/rustlib/x86_64-pc-windows-gnu/lib/librustc_unicode-d8ace771.rlib\" \"/usr/local/lib/rustlib/x86_64-pc-windows-gnu/lib/librand-d8ace771.rlib\" \"/usr/local/lib/rustlib/x86_64-pc-windows-gnu/lib/liballoc-d8ace771.rlib\" \"/usr/local/lib/rustlib/x86_64-pc-windows-gnu/lib/liblibc-d8ace771.rlib\" \"/usr/local/lib/rustlib/x86_64-pc-windows-gnu/lib/libcore-d8ace771.rlib\" \"-L\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release\" \"-L\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps\" \"-L\" \"/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/build/curl-sys-b582fd2220a1331e/out/lib\" \"-L\" \"/usr/local/lib/rustlib/x86_64-pc-windows-gnu/lib\" \"-L\" \"/home/frederick/rust/curl_example/.rust/lib/x86_64-pc-windows-gnu\" \"-L\" \"/home/frederick/rust/curl_example/lib/x86_64-pc-windows-gnu\" \"-Wl,-Bstatic\" \"-Wl,-Bdynamic\" \"-l\" \"ws2_32\" \"-l\" \"z\" \"-l\" \"ws2_32\" \"-l\" \"userenv\" \"-l\" \"advapi32\" \"-l\" \"compiler-rt\"\nnote: /home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/libcurl_sys-b582fd2220a1331e.rlib(r-curl-libcurl_la-version.o): could not read symbols: Invalid operation\ncollect2: error: ld returned 1 exit status\n\nerror: aborting due to previous error\nCould not compile `curl_example`.\n\nCaused by:\n  Process didn't exit successfully: `rustc src/main.rs --crate-name curl_example --crate-type bin -C opt-level=3 --out-dir /home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release --emit=dep-info,link --target x86_64-pc-windows-gnu -C ar=x86_64-w64-mingw32-ar -C linker=x86_64-w64-mingw32-gcc -L dependency=/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release -L dependency=/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps --extern curl=/home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/deps/libcurl-8828a61714ae0eb4.rlib -L /home/frederick/rust/curl_example/target/x86_64-pc-windows-gnu/release/build/curl-sys-b582fd2220a1331e/out/lib` (exit code: 101)\n</code></pre>\n\n<p>When building for <code>arm-unknown-linux-gnueabihf</code>, I got:</p>\n\n<pre><code>   Compiling curl_example v0.1.0 (file:///home/frederick/rust/curl_example)\n     Running `rustc src/main.rs --crate-name curl_example --crate-type bin -C opt-level=3 --out-dir /home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release --emit=dep-info,link --target arm-unknown-linux-gnueabihf -C ar=arm-linux-gnueabihf-ar -C linker=arm-linux-gnueabihf-gcc -L dependency=/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release -L dependency=/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps --extern curl=/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib -L /home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/build/curl-sys-b582fd2220a1331e/out/lib -L native=/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/build/openssl-sys-765ddf9de3c5179c/out`\nerror: linking with `arm-linux-gnueabihf-gcc` failed: exit code: 1\nnote: \"arm-linux-gnueabihf-gcc\" \"-Wl,--as-needed\" \"-L\" \"/usr/local/lib/rustlib/arm-unknown-linux-gnueabihf/lib\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/curl_example.o\" \"-o\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/curl_example\" \"-Wl,--whole-archive\" \"-l\" \"morestack\" \"-Wl,--no-whole-archive\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-O1\" \"-nodefaultlibs\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl_sys-b582fd2220a1331e.rlib\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/liburl-5247f81b4a7b5841.rlib\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libmatches-68291f81832fc22d.rlib\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/liblog-8a6aba167994951e.rlib\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/liblibz_sys-e8e1552876cd3abe.rlib\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/librustc_serialize-7ff5bfc027146194.rlib\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libopenssl_sys-765ddf9de3c5179c.rlib\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/liblibc-144c435538abd757.rlib\" \"/usr/local/lib/rustlib/arm-unknown-linux-gnueabihf/lib/libstd-d8ace771.rlib\" \"/usr/local/lib/rustlib/arm-unknown-linux-gnueabihf/lib/libcollections-d8ace771.rlib\" \"/usr/local/lib/rustlib/arm-unknown-linux-gnueabihf/lib/librustc_unicode-d8ace771.rlib\" \"/usr/local/lib/rustlib/arm-unknown-linux-gnueabihf/lib/librand-d8ace771.rlib\" \"/usr/local/lib/rustlib/arm-unknown-linux-gnueabihf/lib/liballoc-d8ace771.rlib\" \"/usr/local/lib/rustlib/arm-unknown-linux-gnueabihf/lib/liblibc-d8ace771.rlib\" \"/usr/local/lib/rustlib/arm-unknown-linux-gnueabihf/lib/libcore-d8ace771.rlib\" \"-L\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release\" \"-L\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps\" \"-L\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/build/curl-sys-b582fd2220a1331e/out/lib\" \"-L\" \"/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/build/openssl-sys-765ddf9de3c5179c/out\" \"-L\" \"/usr/local/lib/rustlib/arm-unknown-linux-gnueabihf/lib\" \"-L\" \"/home/frederick/rust/curl_example/.rust/lib/arm-unknown-linux-gnueabihf\" \"-L\" \"/home/frederick/rust/curl_example/lib/arm-unknown-linux-gnueabihf\" \"-Wl,-Bstatic\" \"-Wl,-Bdynamic\" \"-l\" \"z\" \"-l\" \"crypto\" \"-l\" \"ssl\" \"-l\" \"c\" \"-l\" \"m\" \"-l\" \"dl\" \"-l\" \"pthread\" \"-l\" \"rt\" \"-l\" \"gcc_s\" \"-l\" \"pthread\" \"-l\" \"c\" \"-l\" \"m\" \"-l\" \"compiler-rt\"\nnote: /home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/curl_example.o: In function `main::h3f0c65dd085aa280gaa':\ncurl_example.0.rs:(.text._ZN4main20h3f0c65dd085aa280gaaE+0x188): undefined reference to `curl_easy_setopt'\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o): In function `ffi::easy::global_init::cleanup::hfb9c781cea2b575dzia':\ncurl.0.rs:(.text._ZN3ffi4easy11global_init7cleanup20hfb9c781cea2b575dziaE+0x0): undefined reference to `curl_global_cleanup'\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o): In function `ffi::easy::Easy.Drop::drop::h0c646593d425c9d3Hia':\ncurl.0.rs:(.text._ZN3ffi4easy9Easy.Drop4drop20h0c646593d425c9d3HiaE+0x4): undefined reference to `curl_easy_cleanup'\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o): In function `ffi::err::ErrCode.fmt..Display::fmt::h032b81c4990a5e2fOra':\ncurl.0.rs:(.text._ZN3ffi3err20ErrCode.fmt..Display3fmt20h032b81c4990a5e2fOraE+0x48): undefined reference to `curl_easy_strerror'\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o): In function `http::handle::Handle::new::hcbd4647fea69f7fe3Va':\ncurl.0.rs:(.text._ZN4http6handle6Handle3new20hcbd4647fea69f7fe3VaE+0x220): undefined reference to `curl_easy_init'\ncurl.0.rs:(.text._ZN4http6handle6Handle3new20hcbd4647fea69f7fe3VaE+0x230): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle6Handle3new20hcbd4647fea69f7fe3VaE+0x244): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle6Handle3new20hcbd4647fea69f7fe3VaE+0x260): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle6Handle3new20hcbd4647fea69f7fe3VaE+0x49c): undefined reference to `curl_easy_cleanup'\ncurl.0.rs:(.text._ZN4http6handle6Handle3new20hcbd4647fea69f7fe3VaE+0x534): undefined reference to `curl_easy_cleanup'\ncurl.0.rs:(.text._ZN4http6handle6Handle3new20hcbd4647fea69f7fe3VaE+0x558): undefined reference to `curl_easy_cleanup'\ncurl.0.rs:(.text._ZN4http6handle6Handle3new20hcbd4647fea69f7fe3VaE+0x5dc): undefined reference to `curl_easy_cleanup'\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o): In function `ffi::easy::Easy::setopt::h17415893674049649907':\ncurl.0.rs:(.text._ZN3ffi4easy4Easy6setopt21h17415893674049649907E+0x1bc): undefined reference to `curl_easy_setopt'\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o): In function `http::handle::Request$LT$$u27$a$C$$u20$$u27$b$GT$::exec::hd3fad3894ea8584cgab':\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0x108): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0x14c): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0x1a0): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0x1b8): undefined reference to `curl_easy_setopt'\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o):curl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0x1d0): more undefined references to `curl_easy_setopt' follow\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o): In function `http::handle::Request$LT$$u27$a$C$$u20$$u27$b$GT$::exec::hd3fad3894ea8584cgab':\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0x8e4): undefined reference to `curl_slist_append'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0x94c): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0x998): undefined reference to `curl_slist_free_all'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xa30): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xa50): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xa70): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xa84): undefined reference to `curl_easy_setopt'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xaa4): undefined reference to `curl_easy_setopt'\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o):curl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xabc): more undefined references to `curl_easy_setopt' follow\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o): In function `http::handle::Request$LT$$u27$a$C$$u20$$u27$b$GT$::exec::hd3fad3894ea8584cgab':\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xaf8): undefined reference to `curl_easy_perform'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xb30): undefined reference to `curl_easy_getinfo'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xc0c): undefined reference to `curl_slist_free_all'\ncurl.0.rs:(.text._ZN4http6handle35Request$LT$$u27$a$C$$u20$$u27$b$GT$4exec20hd3fad3894ea8584cgabE+0xe24): undefined reference to `curl_slist_free_all'\n/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib(curl-8828a61714ae0eb4.o): In function `ffi::easy::Easy::setopt::h1335928551378549339':\ncurl.0.rs:(.text._ZN3ffi4easy4Easy6setopt20h1335928551378549339E+0x160): undefined reference to `curl_easy_setopt'\ncollect2: error: ld returned 1 exit status\n\nerror: aborting due to previous error\nCould not compile `curl_example`.\n\nCaused by:\n  Process didn't exit successfully: `rustc src/main.rs --crate-name curl_example --crate-type bin -C opt-level=3 --out-dir /home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release --emit=dep-info,link --target arm-unknown-linux-gnueabihf -C ar=arm-linux-gnueabihf-ar -C linker=arm-linux-gnueabihf-gcc -L dependency=/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release -L dependency=/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps --extern curl=/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/deps/libcurl-8828a61714ae0eb4.rlib -L /home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/build/curl-sys-b582fd2220a1331e/out/lib -L native=/home/frederick/rust/curl_example/target/arm-unknown-linux-gnueabihf/release/build/openssl-sys-765ddf9de3c5179c/out` (exit code: 101)\n</code></pre>\n\n<p>But I did successfully cross compile <code>curl-rust</code> itself for both <code>x86_64-pc-windows-gnu</code> and <code>arm-unknown-linux-gnueabihf</code> which made it weirder.</p>\n\n<p>How to fix these problems? Did I miss any configurations?</p>\n"}, {"tags": ["iterator", "rust", "shared"], "answers": [{"comments": [{"owner": {"reputation": 528, "user_id": 1889530, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/6e5b9b8f6c6aa617e3b50dadc355f171?s=128&d=identicon&r=PG", "display_name": "mSSM", "link": "https://stackoverflow.com/users/1889530/mssm"}, "edited": false, "score": 4, "creation_date": 1440617755, "post_id": 32235050, "comment_id": 52352828, "body": "Right, this is great, thanks a lot! I was also confused about <code>into_iter()</code> can work on both <code>&amp;Vec</code> and <code>Vec</code>, but the source you reference explains it: there is an implementor for <code>Vec&lt;T&gt;</code> as well as for <code>&amp;&#39;a Vec&lt;T&gt;</code> and <code>&amp;&#39;a mut Vec&lt;T&gt;</code>. Very cool stuff! :)"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 11, "last_activity_date": 1440617015, "creation_date": 1440617015, "answer_id": 32235050, "question_id": 32234954, "link": "https://stackoverflow.com/questions/32234954/difference-between-iter-and-into-iter-on-a-shared-borrowed-vec/32235050#32235050", "title": "Difference between iter() and into_iter() on a shared, borrowed Vec?", "body": "<blockquote>\n  <p>But it cannot really take ownership of the v in that function, since it has only borrowed it to begin with</p>\n</blockquote>\n\n<p>It absolutely <em>can</em> take ownership of <code>v</code>, because that's a <code>&amp;Vec</code>. Note the precise semantics here - you are taking ownership <em>of the reference</em>, not of the referred-to item.</p>\n\n<p>If you check out the <a href=\"http://doc.rust-lang.org/std/iter/trait.IntoIterator.html\" rel=\"noreferrer\">implementors of <code>IntoIterator</code></a>, you can find:</p>\n\n<pre><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a Vec&lt;T&gt;\n</code></pre>\n\n<p>And the <a href=\"https://github.com/rust-lang/rust/blob/9165a4e2dcaaa878a33379c6ff097c68f0ca0485/src/libcollections/vec.rs#L1219-L1227\" rel=\"noreferrer\">source for that</a>:</p>\n\n<pre><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a Vec&lt;T&gt; {\n    fn into_iter(self) -&gt; slice::Iter&lt;'a, T&gt; {\n        self.iter()\n    }\n}\n</code></pre>\n\n<p>Surprise \u2014 it calls <code>iter</code>! So the answer to your question is: there isn't a difference.</p>\n"}], "owner": {"reputation": 528, "user_id": 1889530, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/6e5b9b8f6c6aa617e3b50dadc355f171?s=128&d=identicon&r=PG", "display_name": "mSSM", "link": "https://stackoverflow.com/users/1889530/mssm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2486, "favorite_count": 0, "accepted_answer_id": 32235050, "answer_count": 1, "score": 7, "last_activity_date": 1462574026, "creation_date": 1440616667, "last_edit_date": 1440617091, "question_id": 32234954, "link": "https://stackoverflow.com/questions/32234954/difference-between-iter-and-into-iter-on-a-shared-borrowed-vec", "title": "Difference between iter() and into_iter() on a shared, borrowed Vec?", "body": "<p>I am reading the <a href=\"https://www.ralfj.de/projects/rust-101/part04.html#section-5\">Rust 101 tutorial</a>, where the author talks about shared borrowing with the example of a <code>Vec</code> object passed to a function. Below is a slightly adapted MWE of what the the tutorial is teaching. The interesting part is <code>v.iter()</code> in <code>vec_min</code>. The author writes:</p>\n\n<blockquote>\n  <p>This time, we explicitly request an iterator for the vector <code>v</code>. The method <code>iter</code> borrows the vector it works on, and provides shared borrows of the elements.</p>\n</blockquote>\n\n<p>But what happens if I use a <code>for ... in ...</code> construction on an object which is shared? According to <a href=\"http://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html\">this blog post</a>, this implicit for loop uses <code>into_iter()</code>, taking ownership of <code>v</code>. But it cannot really take ownership of the <code>v</code> in that function, since it has only borrowed it to begin with, right?</p>\n\n<p>Can somebody explain the difference between <code>into_iter()</code> and <code>iter()</code> applied to a borrowed object to me?</p>\n\n<pre><code>enum NumberOrNothing {\n    Number(i32),\n    Nothing,\n}\nuse self::NumberOrNothing::{Number,Nothing};\n\nimpl NumberOrNothing {\n    fn print(self) {\n        match self {\n            Nothing =&gt; println!(\"The number is: &lt;nothing&gt;\"),\n            Number(n) =&gt; println!(\"The number is: {}\", n),\n        };\n    }\n}\n\nfn vec_min(v: &amp;Vec&lt;i32&gt;) -&gt; NumberOrNothing {\n    fn min_i32(a: i32, b: i32) -&gt; i32 {\n        if a &lt; b {a} else {b}\n    }\n\n    let mut min = Nothing;\n    for e in v.iter() {\n    //Alternatively implicitly and with *e replaced by e:\n    //for e in v {\n        min = Number(match min {\n            Nothing =&gt; *e,\n            Number(n) =&gt; min_i32(n, *e),\n        });\n    }\n    min\n}\n\npub fn main() {\n    let vec = vec![18,5,7,2,9,27];\n    let foo = Nothing;\n    let min = vec_min(&amp;vec);\n    let min = vec_min(&amp;vec);\n    min.print();\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 555, "user_id": 4637817, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/849a2d4951995c9fcb2b9aec36faaf2c?s=128&d=identicon&r=PG&f=1", "display_name": "Remagpie", "link": "https://stackoverflow.com/users/4637817/remagpie"}, "edited": false, "score": 0, "creation_date": 1440611108, "post_id": 32232804, "comment_id": 52348971, "body": "Thank you for explanation! But I still have some problems. I added <code>Vec</code> to <code>MyStruct</code>, and tried to save <code>Foo</code> to that vector. But when I try to save reference of vector element to hashmap, I get same error. Why can&#39;t I use` Vec` for this problem, and which type should I use?(<code>Arena</code> type was suggested, but I&#39;m unfamilliar with this library, and I prefer standard libraries) Playground link is here : <a href=\"https://play.rust-lang.org/?gist=683bcdaca275e1d0c47c&amp;version=stable\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 555, "user_id": 4637817, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/849a2d4951995c9fcb2b9aec36faaf2c?s=128&d=identicon&r=PG&f=1", "display_name": "Remagpie", "link": "https://stackoverflow.com/users/4637817/remagpie"}, "edited": false, "score": 0, "creation_date": 1440611561, "post_id": 32232804, "comment_id": 52349214, "body": "@Yang, please read the answer carefully again. Creating another <code>Vec</code> or <code>HashMap</code> or whatever inside <i>the same structure</i> won&#39;t work. You need to store <code>Foo</code>s elsewhere, outside of <code>MyStruct</code>."}, {"owner": {"reputation": 555, "user_id": 4637817, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/849a2d4951995c9fcb2b9aec36faaf2c?s=128&d=identicon&r=PG&f=1", "display_name": "Remagpie", "link": "https://stackoverflow.com/users/4637817/remagpie"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440612158, "post_id": 32232804, "comment_id": 52349560, "body": "@Vladimir Matveev Oh. Sorry for my misunderstanding. I think my problem is solved. Thank you again for your help."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 555, "user_id": 4637817, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/849a2d4951995c9fcb2b9aec36faaf2c?s=128&d=identicon&r=PG&f=1", "display_name": "Remagpie", "link": "https://stackoverflow.com/users/4637817/remagpie"}, "edited": false, "score": 0, "creation_date": 1440614995, "post_id": 32232804, "comment_id": 52351248, "body": "@Yang: The <code>Arena</code> type was suggested instead of <code>Vec</code> specifically because <code>Arena</code> guarantees that you can objects to the <code>Arena</code> while keeping references into the <code>Arena</code>; <code>Vec</code> does not offer such guarantees. And yes, the <code>Arena</code> need be outside <code>MyStruct</code> because sibling borrows are not possible in safe Rust."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 4, "last_activity_date": 1440609436, "creation_date": 1440609436, "answer_id": 32232804, "question_id": 32232486, "link": "https://stackoverflow.com/questions/32232486/how-to-create-hashmap-containing-reference-to-another-hashmaps-element/32232804#32232804", "title": "How to create hashmap containing reference to another hashmap&#39;s element?", "body": "<p>The problem is indeed related to ownership/borrowing/lifetimes.</p>\n\n<p>In general, in Rust, it is not possibly to (safely) take a reference in a sibling attribute; therefore having <code>.second</code> point into <code>.first</code> is impossible.</p>\n\n<p>However, even if you separated this in two structures, you will still run into problems because taking a reference into a <code>HashMap</code> borrows it (which means that as long as the reference lives, modifying the <code>HashMap</code> is forbidden), which is probably not what you wish for.</p>\n\n<p>This last hurdle can be avoided, in this case, by simply sharing the memory; for example, having both <code>HashMap</code> using a <code>Rc&lt;X&gt;</code> value instead of <code>X</code> and <code>&amp;'a X</code> respectively...</p>\n\n<p>... however this will not help with your particular question given the <code>Foo</code> and <code>Bar&lt;'a&gt;</code> types.</p>\n\n<p>You could change your structure into:</p>\n\n<pre><code>struct MyStruct&lt;'a, 'b&gt; {\n    first: HashMap&lt;&amp;'a str, &amp;'b Foo&gt;,\n    second: HashMap&lt;&amp;'a str, Bar&lt;'b&gt;&gt;,\n}\n</code></pre>\n\n<p>and then maintain the actual <code>Foo</code> instances elsewhere. A possibility if you need to allocate those <code>Foo</code> while maintaining the <code>HashMap</code> is to use arena allocation such as <a href=\"https://libraries.io/cargo/typed-arena\" rel=\"nofollow\"><code>Arena&lt;Foo&gt;</code></a>.</p>\n"}], "owner": {"reputation": 555, "user_id": 4637817, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/849a2d4951995c9fcb2b9aec36faaf2c?s=128&d=identicon&r=PG&f=1", "display_name": "Remagpie", "link": "https://stackoverflow.com/users/4637817/remagpie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2361, "favorite_count": 0, "accepted_answer_id": 32232804, "answer_count": 1, "score": 5, "last_activity_date": 1440609436, "creation_date": 1440608483, "question_id": 32232486, "link": "https://stackoverflow.com/questions/32232486/how-to-create-hashmap-containing-reference-to-another-hashmaps-element", "title": "How to create hashmap containing reference to another hashmap&#39;s element?", "body": "<p>I'm trying to make a struct containing two hashmaps - one with some value, and one with reference to another hashmap's element. Here is my code.</p>\n\n<pre><code>use std::collections::HashMap;\n\nstruct Foo;\nstruct Bar&lt;'s&gt;(&amp;'s Foo);\n\nstruct MyStruct&lt;'a&gt; {\n    first : HashMap&lt;&amp;'a str, Foo&gt;,\n    second : HashMap&lt;&amp;'a str, Bar&lt;'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; MyStruct&lt;'a&gt; {\n    fn new() -&gt; MyStruct&lt;'a&gt; {\n        let mut result = MyStruct {\n            first : HashMap::new(),\n            second : HashMap::new(),\n        };\n        match result.first.get(\"\") {\n            Some(t) =&gt; { result.second.insert(\"\", Bar(t)); },\n            None =&gt; {},\n        }\n        result\n    }\n}\n\nfn main() {\n}\n</code></pre>\n\n<p>and this code fails to compile with following error :</p>\n\n<blockquote>\n  <p>error: <code>result.first</code> does not live long enough</p>\n</blockquote>\n\n<p>I think this problem is related to lifetime, but I can't clearly explain what is wrong.</p>\n\n<p>Could anybody explain what is happening and how to solve this error?</p>\n\n<p>P.S. struct <code>Foo</code> and <code>Bar</code> are from library, so I can't modify these structs.</p>\n"}, {"tags": ["closures", "rust", "traits", "type-alias"], "answers": [{"comments": [{"owner": {"reputation": 564, "user_id": 2969020, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5dfbfc8e1b24766f12cb2e0b0873a9c4?s=128&d=identicon&r=PG&f=1", "display_name": "Otobo", "link": "https://stackoverflow.com/users/2969020/otobo"}, "edited": false, "score": 0, "creation_date": 1440594587, "post_id": 32226941, "comment_id": 52337607, "body": "Thanks for the answer, indeed by casting a or c as <code>Box&lt;Fn(i32) -&gt; i32&gt;</code> works. Also a typo correction on your answer, under the first block of code is <code>b</code> and <code>d</code> and not <code>b</code> and <code>c</code>."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 4, "last_activity_date": 1440594793, "last_edit_date": 1440594793, "creation_date": 1440592785, "answer_id": 32226941, "question_id": 32226503, "link": "https://stackoverflow.com/questions/32226503/implement-trait-for-closure-type-alias/32226941#32226941", "title": "Implement trait for closure type alias", "body": "<p>I believe this happens due to automatic coercion (that is, its absence) from a concrete type to a trait object type.</p>\n\n<p>When you call <code>with_one()</code>, the compiler is able to understand from the function argument type that you want a trait object and so it inserts automatic coercions:</p>\n\n<pre><code>with_one(a as Box&lt;Fn(i32) -&gt; i32&gt;);\nwith_one(c as Box&lt;Fn(i32) -&gt; i32&gt;);\n</code></pre>\n\n<p>For <code>b</code> and <code>d</code> these coercions have already happened at their assignment place in <code>let</code>s.</p>\n\n<p>For trait methods, however, the compiler does not perform coercions. This is a common behavior around generics (and traits are implemented over generics - their <code>Self</code> type is essentially an implicit type parameter for all trait methods). For example, Rust also does not perform deref coercions when using generics:</p>\n\n<pre><code>trait MyStringLike {}\n\nimpl&lt;'a&gt; MyStringLike for &amp;'a str {}\n\nfn function&lt;T: MyStringLike&gt;(t: T) {}\n\nlet s: String = \"abcde\".into();\nfunction(&amp;s);  // the trait `main::MyStringLike` is not implemented for the type `&amp;collections::string::String`\n</code></pre>\n"}], "owner": {"reputation": 564, "user_id": 2969020, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5dfbfc8e1b24766f12cb2e0b0873a9c4?s=128&d=identicon&r=PG&f=1", "display_name": "Otobo", "link": "https://stackoverflow.com/users/2969020/otobo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 863, "favorite_count": 1, "accepted_answer_id": 32226941, "answer_count": 1, "score": 5, "last_activity_date": 1440904630, "creation_date": 1440591596, "last_edit_date": 1440904630, "question_id": 32226503, "link": "https://stackoverflow.com/questions/32226503/implement-trait-for-closure-type-alias", "title": "Implement trait for closure type alias", "body": "<p>I have this closure type alias:</p>\n\n<pre><code>type ClosureType = Box&lt;Fn(i32) -&gt; i32&gt;;\n</code></pre>\n\n<p>this trait:</p>\n\n<pre><code>trait Trait {\n    fn change(&amp;self, y: i32) -&gt; i32;\n}\n</code></pre>\n\n<p>and these functions:</p>\n\n<pre><code>fn with_one(x: Box&lt;Fn(i32) -&gt; i32&gt;) -&gt; i32 {\n    x(1)\n}\n\nfn plus_one(x: i32) -&gt; i32 {\n    x+1\n}\n\nfn main() {\n    let a = Box::new(|x: i32|{x+1});\n    let b: ClosureType = Box::new(|x: i32|{x+1});\n    let c = Box::new(plus_one);\n    let d: ClosureType = Box::new(plus_one);\n    println!(\"{}\", a.change(1));\n    println!(\"{}\", b.change(1));\n    println!(\"{}\", c.change(1));\n    println!(\"{}\", d.change(1));\n    println!(\"{}\", with_one(a));\n    println!(\"{}\", with_one(b));\n    println!(\"{}\", with_one(c));\n    println!(\"{}\", with_one(d));\n}\n</code></pre>\n\n<p>When I implement the trait <code>Trait</code> for <code>ClosureType</code> or for <code>Box&lt;Fn(i32) -&gt; i32&gt;</code> which is the same if I understand correctly type aliases:</p>\n\n<pre><code>impl Trait for ClosureType {\n    fn change(&amp;self, y: i32) -&gt; i32{\n        self(y)\n    }\n}\n</code></pre>\n\n<p>or</p>\n\n<pre><code>impl Trait for Box&lt;Fn(i32) -&gt; i32&gt; {\n    fn change(&amp;self, y: i32) -&gt; i32{\n        self(y)\n    }\n}\n</code></pre>\n\n<p>for variable <code>a</code> I get:</p>\n\n<pre><code>&lt;anon&gt;:32:22: 32:31 error: no method named `change` found for type\n`Box&lt;[closure &lt;anon&gt;:28:22: 28:35]&gt;` in the current scope \n&lt;anon&gt;:32     println!(\"{}\", a.change(1));\n</code></pre>\n\n<p>and for variable <code>c</code>  I get:</p>\n\n<pre><code>&lt;anon&gt;:34:22: 34:31 error: no method named `change` found for type\n`Box&lt;fn(i32) -&gt; i32 {plus_one}&gt;` in the current scope\n&lt;anon&gt;:34     println!(\"{}\", c.change(1));\n</code></pre>\n\n<p>However variables <code>a</code> and <code>c</code> are accepted from function <code>with_one(x: Box&lt;Fn(i32) -&gt; i32&gt;) -&gt; i32</code>, in other words it seems that they have the same type(<code>Box&lt;Fn(i32) -&gt; i32&gt;</code>) for function <code>with_one</code> but different(<code>Box&lt;[closure &lt;anon&gt;:24:22: 24:35]&gt;</code> and <code>Box&lt;fn(i32) -&gt; i32 {plus_one}</code>) for <code>Trait</code> implementation.</p>\n\n<p>I feel I missing something here but not sure what it is, could you enlighten me?</p>\n\n<p>you can find all the code in <a href=\"https://play.rust-lang.org/?gist=9bfcd27580cf078e0551\" rel=\"nofollow\">this rust playground</a>.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1440593370, "post_id": 32226413, "comment_id": 52336631, "body": "Note: this is <a href=\"https://doc.rust-lang.org/error-index.html#E0186\" rel=\"nofollow noreferrer\">E0186</a>, and a quick search through the issues does not find it, so there might not already be an issue to improve this error. In general, Rust diagnostics are quite amazing in terms of quality given the (lack of) maturity of the compiler, but they do need some more love."}], "answers": [{"comments": [{"owner": {"reputation": 9933, "user_id": 678410, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/57083a995514ca4e66842dec135edd6f?s=128&d=identicon&r=PG", "display_name": "Anders Forsgren", "link": "https://stackoverflow.com/users/678410/anders-forsgren"}, "edited": false, "score": 0, "creation_date": 1440594235, "post_id": 32227002, "comment_id": 52337352, "body": "Thanks. Issue is submitted (not sure I did that right, but I&#39;m sure I won&#39;t be flogged I didn&#39;t. The Rust community is fantastic). <a href=\"https://github.com/rust-lang/rust/issues/28011\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/28011</a>"}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 0, "creation_date": 1440606766, "post_id": 32227002, "comment_id": 52346442, "body": "Please send general feature requests to the RFC repo instead. This case is borderline: it&#39;s more of an improvement, so I think it&#39;s fine on the main repo"}, {"owner": {"reputation": 9933, "user_id": 678410, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/57083a995514ca4e66842dec135edd6f?s=128&d=identicon&r=PG", "display_name": "Anders Forsgren", "link": "https://stackoverflow.com/users/678410/anders-forsgren"}, "edited": false, "score": 0, "creation_date": 1440614609, "post_id": 32227002, "comment_id": 52351032, "body": "Thanks Steve, the contributing.md doc wasnt very clear - from what I could make of existing tickets the rfc repo looked like mostly language spec changes and more issues looked like mine in /rust."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 3, "last_activity_date": 1440592968, "creation_date": 1440592968, "answer_id": 32227002, "question_id": 32226413, "link": "https://stackoverflow.com/questions/32226413/expected-method-signatures-in-trait-error-messages/32227002#32227002", "title": "Expected method signatures in trait error messages", "body": "<p>No, it is not possible. If you think this is an important feature, you can always submit a feature request to <a href=\"https://github.com/rust-lang/rust/issues\" rel=\"nofollow\">Rust issue tracker</a>.</p>\n\n<p>Meanwhile, you can use docs generated by rustdoc, e.g. <a href=\"http://doc.rust-lang.org/std/\" rel=\"nofollow\">these</a> for the standard library. They are usually pretty awesome, especially given that there is search function.</p>\n"}], "owner": {"reputation": 9933, "user_id": 678410, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/57083a995514ca4e66842dec135edd6f?s=128&d=identicon&r=PG", "display_name": "Anders Forsgren", "link": "https://stackoverflow.com/users/678410/anders-forsgren"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 89, "favorite_count": 0, "accepted_answer_id": 32227002, "answer_count": 1, "score": 2, "last_activity_date": 1440592968, "creation_date": 1440591392, "question_id": 32226413, "link": "https://stackoverflow.com/questions/32226413/expected-method-signatures-in-trait-error-messages", "title": "Expected method signatures in trait error messages", "body": "<p>I'm trying Rust and finding it hard to interpret what to do when my function signatures don't correspond to those expected by a trait. Example</p>\n\n<pre class=\"lang-rs prettyprint-override\"><code> impl std::fmt::Display for MyType {\n    // Not sure what to put here so I stub it and hope to get help from error\n    fn fmt() -&gt; () { } \n }\n</code></pre>\n\n<p>The compiler error message is</p>\n\n<pre><code>method `fmt` has a `&amp;self` declaration in the trait, but not in the impl\n</code></pre>\n\n<p>What I was hoping to see was something helping me implement the method for example:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Incorrect method signature for `fmt`\nActual signature    fn fmt() -&gt; ()\nExpected signature  fn fmt(&amp;self, &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;\n</code></pre>\n\n<p>Is it possible to get signature help from the compiler like this? I'm usually very impressed by the very friendly and detailed compiler errors, so this one really surprised me. I'm using the rust playground (<a href=\"https://play.rust-lang.org/\" rel=\"nofollow\">https://play.rust-lang.org/</a>) but I don't think that makes any difference to compiler output.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 4, "creation_date": 1440587896, "post_id": 32224002, "comment_id": 52332902, "body": "<a href=\"http://cglab.ca/~abeinges/blah/hash-rs/\" rel=\"nofollow noreferrer\">See benchmarks</a>. At this time, farmhash needs further adaptation to fit rust&#39;s streaming hashing API efficiently. This survey is very small, but there are two extreme ends. Short keys, FNV hash wins, long keys, xxhash dominates."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1440593075, "post_id": 32224002, "comment_id": 52336398, "body": "@bluss: One of the most impressive point of those benchmarks, as far as I am concerned, is the performance of <code>BTreeMap</code>; coming from C++ where <code>std::map</code> and <code>std::unordered_map</code> performance is crippled by the memory stability requirement, this is a welcome change."}], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 5, "last_activity_date": 1440585543, "creation_date": 1440585543, "answer_id": 32224381, "question_id": 32224002, "link": "https://stackoverflow.com/questions/32224002/how-to-use-farmhash-algorithm-in-place-of-default/32224381#32224381", "title": "How to use farmhash algorithm in place of default", "body": "<p>Here's how you do it:</p>\n\n<pre><code>#![feature(hashmap_hasher)]\nextern crate farmhash;\n\nuse std::collections::HashMap;\nuse std::collections::hash_state::DefaultState;\n\nuse farmhash::FarmHasher;\n\nfn main() {\n    let hm: HashMap&lt;u32, u32, DefaultState&lt;FarmHasher&gt;&gt; = \n        HashMap::with_hash_state(DefaultState::default());\n}\n</code></pre>\n\n<p>You need to create the map with non-default hash state using <code>FarmHasher</code> from the library. <code>FarmHasher</code> implements <code>Hasher</code> and <code>Default</code> traits, and so it can be used with <code>DefaultState</code>.</p>\n\n<p>Note that hasher configuration functionality is unstable, so you can only do this on nightlies with the corresponding feature enabled.</p>\n"}], "owner": {"reputation": 2403, "user_id": 3190054, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/b7de233f9b761d1d0d75d64b608aca88?s=128&d=identicon&r=PG&f=1", "display_name": "kezzos", "link": "https://stackoverflow.com/users/3190054/kezzos"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 348, "favorite_count": 0, "accepted_answer_id": 32224381, "answer_count": 1, "score": 4, "last_activity_date": 1440585543, "creation_date": 1440584548, "question_id": 32224002, "link": "https://stackoverflow.com/questions/32224002/how-to-use-farmhash-algorithm-in-place-of-default", "title": "How to use farmhash algorithm in place of default", "body": "<p>Im trying to have a go at using <a href=\"https://crates.io/crates/farmhash\" rel=\"nofollow\">farmhash (1.1.2)</a> as a replacement for rusts default hashmap hashing algorithm (Siphash?) to see if I can get any speed improvements. I have had a go with using <a href=\"https://crates.io/crates/twox-hash\" rel=\"nofollow\">twox-hash</a> and this gave a nice speed increase, although I would also like to test alongside farmhash, just for a comparison. The farmhash documentation only provides a short example similar to this:</p>\n\n<pre><code>let value: &amp;str = \"somestringkeyorsomthing\";\nlet res64 = farmhash::hash64(&amp;value.as_bytes());\nprintln!(\"{:?}\", res64)\n&gt;&gt;&gt; 12095987461079705245\n</code></pre>\n\n<p>How can I use this method to generate keys in a hashmap? If this is a complicated process, could anyone point me to a good example to follow?  </p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1440577897, "post_id": 32219798, "comment_id": 52326148, "body": "I will be happy if someone contradicts me, however I am afraid that this is something that would require HKT (Higher Ranked Types)."}], "answers": [{"comments": [{"owner": {"reputation": 1845, "user_id": 716390, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/03291df3e8db07ec188e120f66624272?s=128&d=identicon&r=PG", "display_name": "kriomant", "link": "https://stackoverflow.com/users/716390/kriomant"}, "edited": false, "score": 0, "creation_date": 1440582900, "post_id": 32221860, "comment_id": 52329494, "body": "Shouldn&#39;t it be true that every usage of unboxed closure may be desugared into struct implementing <code>Fn(Once|Mut|)</code>?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 1845, "user_id": 716390, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/03291df3e8db07ec188e120f66624272?s=128&d=identicon&r=PG", "display_name": "kriomant", "link": "https://stackoverflow.com/users/716390/kriomant"}, "edited": false, "score": 0, "creation_date": 1440583917, "post_id": 32221860, "comment_id": 52330241, "body": "It is true, but how it is related to your question?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 1845, "user_id": 716390, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/03291df3e8db07ec188e120f66624272?s=128&d=identicon&r=PG", "display_name": "kriomant", "link": "https://stackoverflow.com/users/716390/kriomant"}, "edited": false, "score": 0, "creation_date": 1440584554, "post_id": 32221860, "comment_id": 52330649, "body": "Oh, I now see what you mean. I don&#39;t know the reason why by-move closures work in this case. Unboxed closures have deep support in the compiler, so maybe this is a part of the compiler magic. Anyway, manual implementation of <code>Fn</code> traits is feature-gated, so such problems are not entirely unexpected."}, {"owner": {"reputation": 1845, "user_id": 716390, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/03291df3e8db07ec188e120f66624272?s=128&d=identicon&r=PG", "display_name": "kriomant", "link": "https://stackoverflow.com/users/716390/kriomant"}, "edited": false, "score": 0, "creation_date": 1440584827, "post_id": 32221860, "comment_id": 52330818, "body": "Because following code works as I expect: <a href=\"http://pastebin.com/gXZLYN84\" rel=\"nofollow noreferrer\">pastebin.com/gXZLYN84</a>, so if I can get desugared version (and thus name of struct generated for closure), I can return <code>Foo&lt;ClosureStruct&gt;</code>."}, {"owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "reply_to_user": {"reputation": 1845, "user_id": 716390, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/03291df3e8db07ec188e120f66624272?s=128&d=identicon&r=PG", "display_name": "kriomant", "link": "https://stackoverflow.com/users/716390/kriomant"}, "edited": false, "score": 0, "creation_date": 1462536612, "post_id": 32221860, "comment_id": 61688820, "body": "@kriomant the code in the pastebin does not work on nightly (2016-05-06) <a href=\"https://play.rust-lang.org/?gist=c5a82b073a5944b9c3040c8206144b5f&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 1, "last_activity_date": 1440578572, "creation_date": 1440578572, "answer_id": 32221860, "question_id": 32219798, "link": "https://stackoverflow.com/questions/32219798/how-to-implement-fnmut-which-returns-reference-with-lifetime-parameter/32221860#32221860", "title": "How to implement FnMut which returns reference with lifetime parameter?", "body": "<p>@MatthieuM. is correct. This can't be done without higher-kinded types, and even if they were available, I'm not entirely sure that <code>Fn*</code> traits could be changed to support it.</p>\n\n<p>The problem is, you want your function to return a slice of a vector inside this function. However, this would require <code>call_mut()</code> to have the following signature:</p>\n\n<pre><code>fn call_mut&lt;'a&gt;(&amp;'a mut self, _: ()) -&gt; Self::Output&lt;'a&gt;\n</code></pre>\n\n<p>The lifetime parameter is mandatory, because it is the only way to specify that the result of the function call will live exactly as long as the function itself. This would in turn require <code>Output</code> associated type to have a lifetime argument:</p>\n\n<pre><code>trait FnOnce&lt;A&gt; {\n    type Output&lt;'a&gt;;\n    ...\n}\n</code></pre>\n\n<p>This is exactly what HKT would allow. However, I'm not sure that it would be possible to use HKT for functions. Remember, each <code>FnMut</code> is also <code>FnOnce</code>: if you have a function which can be called multiple times, then it could also be called one time. Naturally, results of <code>FnMut</code> and <code>FnOnce</code> should be equivalent. However, there is just no way to return borrowed data from <code>FnOnce</code> because it takes the function <em>by value</em>. In your case the vector would be moved to the function and, since the function returns a slice, not a vector, it will have nowhere to go and so it will be destroyed. Therefore, such change would require allowing some functions to be <code>FnMut</code>/<code>Fn</code> but not <code>FnOnce</code>; I'm not sure if this is desirable or even possible.</p>\n"}, {"tags": [], "owner": {"reputation": 51, "user_id": 1685274, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/51GPL.jpg?s=128&g=1", "display_name": "Wesley Wolfe", "link": "https://stackoverflow.com/users/1685274/wesley-wolfe"}, "is_accepted": false, "score": 0, "last_activity_date": 1567325184, "creation_date": 1567325184, "answer_id": 57744252, "question_id": 32219798, "link": "https://stackoverflow.com/questions/32219798/how-to-implement-fnmut-which-returns-reference-with-lifetime-parameter/57744252#57744252", "title": "How to implement FnMut which returns reference with lifetime parameter?", "body": "<p>This problem can be solved by using a <code>trait</code> itself to express the would-be function.</p>\n\n<pre><code>trait CallbackTrait {\n    fn call(&amp;mut self) -&gt; &amp;[u8];\n}\n\nfn make_callback() -&gt; impl CallbackTrait {\n    struct MyData(Vec&lt;u8&gt;);\n    impl CallbackTrait for MyData {\n        fn call(&amp;mut self) -&gt; &amp;[u8] { &amp;self.0 }\n    }\n    MyData(vec![0; 100])\n}\n</code></pre>\n\n<p>And, when you want it to be a bit more generically passed around, it can be boxed.</p>\n\n<pre><code>fn make_another_callback() -&gt; Box&lt;dyn MyCallback&gt; {\n    Box::new&lt;make_callback()&gt;\n}\n</code></pre>\n\n<p>Seeing as <strong>no API</strong> expects any <code>Fn(Once|Mut|)</code> that returns something with the lifetime of a function itself, the problem itself is an issue of framing. A situation where you might expect to use this functionality can instead use a <code>trait</code> with a small change to the approach, with the added benefit of much more flexibility like requiring other <code>trait</code>s, or having multiple functions. As for why the language itself doesn't support this concept, @Vladimir Matveev has that explanation.</p>\n"}], "owner": {"reputation": 1845, "user_id": 716390, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/03291df3e8db07ec188e120f66624272?s=128&d=identicon&r=PG", "display_name": "kriomant", "link": "https://stackoverflow.com/users/716390/kriomant"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1414, "favorite_count": 0, "answer_count": 2, "score": 3, "last_activity_date": 1567325184, "creation_date": 1440571958, "question_id": 32219798, "link": "https://stackoverflow.com/questions/32219798/how-to-implement-fnmut-which-returns-reference-with-lifetime-parameter", "title": "How to implement FnMut which returns reference with lifetime parameter?", "body": "<p>I have third-party library with code like this:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub struct Foo&lt;T&gt; { t: T }\n\nimpl&lt;'a, T&gt; Foo&lt;T&gt; where T: 'a + FnMut() -&gt; &amp;'a [u8] {\n    pub fn from_callback(closure: T) -&gt; Self {\n        Foo { t: closure }\n    }\n}\n</code></pre>\n\n<p>It works fine with closure:</p>\n\n<pre><code>let buffer = vec![0; 100];\nFoo::from_callback(move || &amp;buffer)\n</code></pre>\n\n<p>however I want to return <code>Foo</code> from my function. Because of that I cannot use closure, so I have decided to use own struct which implements <code>FnMut</code>.</p>\n\n<p>I have defined struct:</p>\n\n<pre><code>pub struct Func {\n  buffer: Vec&lt;u8&gt;,\n}\n</code></pre>\n\n<p>then implemented <code>FnMut</code> for it:</p>\n\n<pre><code>#![feature(unboxed_closures)]\n\nimpl FnMut&lt;()&gt; for Func {\n  extern \"rust-call\" fn call_mut(&amp;mut self, _: ()) -&gt; Self::Output {\n    &amp;self.buffer\n  }\n}\n</code></pre>\n\n<p>implementing <code>FnOnce</code> is then required:</p>\n\n<pre><code>impl FnOnce&lt;()&gt; for Func {\n  type Output = &amp;[u8];\n                ^~~~  error: missing lifetime specifier [E0106]\n  extern \"rust-call\" fn call_once(self, _: ()) -&gt; Self::Output {\n    unimplemented!();\n  }\n}\n</code></pre>\n\n<p>But I don't know what to use as lifetime for reference in <code>Output</code>.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440522749, "post_id": 32209391, "comment_id": 52304033, "body": "This is the same problem as <a href=\"http://stackoverflow.com/q/20698384/155423\">stackoverflow.com/q/20698384/155423</a> or <a href=\"http://stackoverflow.com/q/30538387/155423\">stackoverflow.com/q/30538387/155423</a> or really any of the numerous questions that ask the question &quot;how do I have a reference to &#39;foo&#39; and then move &#39;foo&#39;?&quot;. There was <a href=\"http://stackoverflow.com/q/32194269/155423\">this question from yesterday</a> as well. The short version is that once you have a reference into an item, you can&#39;t move that item because it would invalidate the reference."}, {"owner": {"reputation": 2489, "user_id": 117710, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/83c42a65c08e2bfa14664f6976b6ab87?s=128&d=identicon&r=PG", "display_name": "anelson", "link": "https://stackoverflow.com/users/117710/anelson"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440523083, "post_id": 32209391, "comment_id": 52304202, "body": "Thanks for the comment.  Maybe I&#39;m misunderstanding the nomenclature, but in my example I don&#39;t think I&#39;m using references.  I intend to transfer ownership of the <code>SqliteConnection</code> from the scope of the <code>new</code> function to the <code>Foo</code> struct, which itself is to be owned by the caller of the <code>new</code> function."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440523712, "post_id": 32209391, "comment_id": 52304554, "body": "I&#39;d recommend changing your title to something more specific, like &quot;How do I have a <code>SqliteStatement</code> and <code>SqliteConnection</code> in the same struct&quot;. As it is now, your title isn&#39;t focused enough as transferring ownership to a struct is easy, but isn&#39;t what your problem is."}, {"owner": {"reputation": 2489, "user_id": 117710, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/83c42a65c08e2bfa14664f6976b6ab87?s=128&d=identicon&r=PG", "display_name": "anelson", "link": "https://stackoverflow.com/users/117710/anelson"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441052019, "post_id": 32209391, "comment_id": 52513387, "body": "If we define the best answer as the one that clarified for me exactly why what I was trying to do is not possible by design, then your answer to this question is definitely the best.  I had seen that other question but I did not grasp the way in which what I was attempting was in effect the same thing."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441052810, "post_id": 32209391, "comment_id": 52513743, "body": "<i>I had seen that other question</i> \u2014 I doubt that, as that question was created 5 days after this one was. ^_^"}], "answers": [{"comments": [{"owner": {"reputation": 2489, "user_id": 117710, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/83c42a65c08e2bfa14664f6976b6ab87?s=128&d=identicon&r=PG", "display_name": "anelson", "link": "https://stackoverflow.com/users/117710/anelson"}, "edited": false, "score": 0, "creation_date": 1440523734, "post_id": 32210369, "comment_id": 52304571, "body": "Aha!  That&#39;s what I was missing.  Thank you."}, {"owner": {"reputation": 2434, "user_id": 508716, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/77d190c42f3d57f3ee3ea864ab216016?s=128&d=identicon&r=PG", "display_name": "Tommi Komulainen", "link": "https://stackoverflow.com/users/508716/tommi-komulainen"}, "edited": false, "score": 4, "creation_date": 1475086957, "post_id": 32210369, "comment_id": 66806055, "body": "What would a sql connection + 2 prepared statements look like in actual code exactly?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 9, "last_activity_date": 1539529999, "last_edit_date": 1539529999, "creation_date": 1440523563, "answer_id": 32210369, "question_id": 32209391, "link": "https://stackoverflow.com/questions/32209391/how-to-store-rusqlite-connection-and-statement-objects-in-the-same-struct-in-rus/32210369#32210369", "title": "How to store rusqlite Connection and Statement objects in the same struct in Rust?", "body": "<p>Let's look at <a href=\"https://docs.rs/rusqlite/0.14.0/rusqlite/struct.Connection.html#method.prepare\" rel=\"nofollow noreferrer\"><code>Connection::prepare</code></a>:</p>\n\n<pre><code>pub fn prepare&lt;'a&gt;(&amp;'a self, sql: &amp;str) -&gt; Result&lt;Statement&lt;'a&gt;&gt;\n</code></pre>\n\n<p>If we ignore the <code>Result</code> (which just means that this function can fail), this means \"return a <code>Statement</code> that can live no longer than the <code>Connection</code> that <code>prepare</code> was called on\". This is likely due to the <code>Statement</code> containing a reference to the <code>Connection</code>.</p>\n\n<p>However, if you have a reference to an item, then you can no longer move the item because the reference would be invalidated. Using that invalid reference would lead to memory unsafety, so it's prevented.</p>\n\n<p>Basically, you need to mirror the lifetimes and ownership of these objects in your code, and so you cannot bundle the <code>Connection</code> and <code>Statement</code> in the same structure. Instead, one can reference the other.</p>\n"}], "owner": {"reputation": 2489, "user_id": 117710, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/83c42a65c08e2bfa14664f6976b6ab87?s=128&d=identicon&r=PG", "display_name": "anelson", "link": "https://stackoverflow.com/users/117710/anelson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1477, "favorite_count": 0, "closed_date": 1486688328, "accepted_answer_id": 32210369, "answer_count": 1, "score": 9, "last_activity_date": 1539529999, "creation_date": 1440520430, "last_edit_date": 1539529889, "question_id": 32209391, "link": "https://stackoverflow.com/questions/32209391/how-to-store-rusqlite-connection-and-statement-objects-in-the-same-struct-in-rus", "closed_reason": "Duplicate", "title": "How to store rusqlite Connection and Statement objects in the same struct in Rust?", "body": "<p>I'm working on my first Rust program and have run afoul of Rust ownership semantics.  I have declared a <code>struct</code> which will encapsulate a SQLite database connection so it maintains a <code>Connection</code> member.  For performance reasons, I also want to keep a prepared statement, represented by the <code>Statement</code> type.  Here is a simplified version of my code:</p>\n\n<pre><code>extern crate rusqlite; // 0.14.0\n\nuse rusqlite::{Connection, Statement};\n\npub struct Foo&lt;'a&gt; {\n    conn: Connection,\n    statement: Statement&lt;'a&gt;,\n}\n\nimpl&lt;'a&gt; Foo&lt;'a&gt; {\n    pub fn new() -&gt; Foo&lt;'a&gt; {\n        let conn = Connection::open(&amp;\":memory:\").unwrap();\n        let statement = conn\n            .prepare(\"INSERT INTO Foo(name, hash) VALUES($1, $2)\")\n            .unwrap();\n        Foo { conn, statement }\n    }\n}\n</code></pre>\n\n<p>I'm trying to transfer ownership of the <code>conn</code> variable to the callee by storing it in a member of <code>Foo</code>, but when I attempt to compile this code it fails:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0597]: `conn` does not live long enough\n  --&gt; src/main.rs:13:25\n   |\n13 |         let statement = conn\n   |                         ^^^^ borrowed value does not live long enough\n...\n17 |     }\n   |     - borrowed value only lives until here\n   |\nnote: borrowed value must be valid for the lifetime 'a as defined on the impl at 10:6...\n  --&gt; src/main.rs:10:6\n   |\n10 | impl&lt;'a&gt; Foo&lt;'a&gt; {\n   |      ^^\n</code></pre>\n\n<p>For some reason, the <code>rusqlite::Connection</code> type doesn't take a lifetime parameter, so I'm unable to explicitly tie its lifetime to that of the <code>Statement</code> instance.</p>\n\n<p>What am I missing?  This kind of encapsulation is a very common pattern, I'm sure I'm missing something.</p>\n"}, {"tags": ["vector", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 3, "creation_date": 1440501374, "post_id": 32202432, "comment_id": 52289184, "body": "Alright, that&#39;s a fun one..."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 17, "last_activity_date": 1440505168, "last_edit_date": 1440505168, "creation_date": 1440502064, "answer_id": 32202805, "question_id": 32202432, "link": "https://stackoverflow.com/questions/32202432/vector-of-vectors-created-with-the-vec-macro-contain-different-capacities/32202805#32202805", "title": "Vector of Vectors created with the vec! macro contain different capacities", "body": "<p>According to the <a href=\"https://doc.rust-lang.org/std/macro.vec!.html\">documentation</a>, <code>vec!</code> is defined as:</p>\n\n<pre><code>macro_rules! vec {\n    ( $ elem : expr ; $ n : expr ) =&gt; (\n        $ crate:: vec:: from_elem ( $ elem , $ n )\n    );\n    ( $ ( $ x : expr ) , * ) =&gt; (\n        &lt; [ _ ] &gt; :: into_vec (\n            $ crate:: boxed:: Box:: new ( [ $ ( $ x ) , * ] )\n        )\n    );\n    ( $ ( $ x : expr , ) * ) =&gt; ( vec ! [ $ ( $ x ) , * ] )\n}\n</code></pre>\n\n<p>In your case, it means that:</p>\n\n<pre><code>vec![Vec::with_capacity(dim); dim]\n</code></pre>\n\n<p>is expanded into:</p>\n\n<pre><code>std::vec::from_elem(Vec::with_capacity(dim), dim)\n</code></pre>\n\n<p>The definition of <code>Vec::from_elem</code> is hidden in the documentation, but can be <a href=\"https://doc.rust-lang.org/src/collections/vec.rs.html#1287\">found in the source</a>:</p>\n\n<pre><code>pub fn from_elem&lt;T: Clone&gt;(elem: T, n: usize) -&gt; Vec&lt;T&gt; {\n    unsafe {\n        let mut v = Vec::with_capacity(n);\n        let mut ptr = v.as_mut_ptr();\n\n        // Write all elements except the last one\n        for i in 1..n {\n            ptr::write(ptr, Clone::clone(&amp;elem));\n            ptr = ptr.offset(1);\n            v.set_len(i); // Increment the length in every step in case Clone::clone() panics\n        }\n\n        if n &gt; 0 {\n            // We can write the last element directly without cloning needlessly\n            ptr::write(ptr, elem);\n            v.set_len(n);\n        }\n\n        v\n    }\n}\n</code></pre>\n\n<p>And this where the heart of the mystery is solved:</p>\n\n<ul>\n<li>the element is cloned <code>n - 1</code> times, for the <code>n - 1</code> first elements of the vector, and then moved into the <code>n</code>-th slot.</li>\n<li>cloning a vector does not clone its capacity, only its elements.</li>\n</ul>\n\n<p>Thus the result you get is exactly as intended, if not as expected.</p>\n"}, {"tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": false, "score": 11, "last_activity_date": 1440595845, "last_edit_date": 1440595845, "creation_date": 1440518697, "answer_id": 32208848, "question_id": 32202432, "link": "https://stackoverflow.com/questions/32202432/vector-of-vectors-created-with-the-vec-macro-contain-different-capacities/32208848#32208848", "title": "Vector of Vectors created with the vec! macro contain different capacities", "body": "<p>As stated, this is because <code>vec![x; y]</code> clones the value. To avoid this, you can instead <code>collect</code> your vector:</p>\n\n<pre><code>let matrix_a: Vec&lt;Vec&lt;i32&gt;&gt; = (0..dim).map(|_| Vec::with_capacity(dim)).collect();\n</code></pre>\n\n<p>This seperately initializes each element, giving you complete allocations.</p>\n"}], "owner": {"reputation": 215, "user_id": 5073273, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/eda1bba6ef197687f10bfacf37a7fa6e?s=128&d=identicon&r=PG&f=1", "display_name": "Dominique M.", "link": "https://stackoverflow.com/users/5073273/dominique-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4370, "favorite_count": 0, "accepted_answer_id": 32202805, "answer_count": 2, "score": 15, "last_activity_date": 1440595845, "creation_date": 1440500927, "last_edit_date": 1440505412, "question_id": 32202432, "link": "https://stackoverflow.com/questions/32202432/vector-of-vectors-created-with-the-vec-macro-contain-different-capacities", "title": "Vector of Vectors created with the vec! macro contain different capacities", "body": "<p>I have a vector<code>matrix_a</code>, which contains 3 vectors, and it is initialized with the <code>vec!</code> macro.</p>\n\n<p>Every vector should have a capacity of 3, due to <code>Vec::with_capacity(dim)</code>, but only the last vector has a capacity of 3. The other vectors have a capacity of 0.</p>\n\n<p>Can someone explain why that is?</p>\n\n<pre><code>fn main() {\n    let dim = 3;\n    let matrix_a: Vec&lt;Vec&lt;i32&gt;&gt; = vec![Vec::with_capacity(dim); dim];\n\n    for vector in matrix_a{\n        println!(\"Capacity of vector: {}\", vector.capacity());\n    }\n}\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>Capacity of vector: 0\nCapacity of vector: 0\nCapacity of vector: 3\n</code></pre>\n"}, {"tags": ["types", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1440506954, "post_id": 32197330, "comment_id": 52292878, "body": "A general rule of thumb for lifetimes: it is rare that multiple inputs have the same lifetime."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1440532116, "post_id": 32197330, "comment_id": 52309429, "body": "@MatthieuM. I&#39;m not sure I agree. Collapsing several references to the same lifetime can certainly limit the range of things that you can do, but it also makes it easier to reason about. I think my process is the opposite of your suggestion - I assume that everything is the same lifetime until I hit a case where there&#39;s a need for multiple distinct lifetimes."}], "answers": [{"comments": [{"owner": {"reputation": 539, "user_id": 4313261, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh4.googleusercontent.com/-Vrtl0r4nCmI/AAAAAAAAAAI/AAAAAAAAAHM/fVptHJkPAsY/photo.jpg?sz=128", "display_name": "crhino", "link": "https://stackoverflow.com/users/4313261/crhino"}, "edited": false, "score": 0, "creation_date": 1440559856, "post_id": 32198939, "comment_id": 52318537, "body": "Thanks, that helps a lot. I was not clear on what it mean to have a for&lt;&#39;a&gt; bound on my type."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 6, "last_activity_date": 1440513649, "last_edit_date": 1440513649, "creation_date": 1440490794, "answer_id": 32198939, "question_id": 32197330, "link": "https://stackoverflow.com/questions/32197330/trouble-implementing-higher-ranked-lifetime-type-bound-for-a-byte-slice/32198939#32198939", "title": "Trouble implementing higher ranked lifetime type bound for a byte slice", "body": "<p>This is not a correct way, and the compiler is right.</p>\n\n<p>One way you can see why it is so is to look at the type (the slice) and the trait you think it implements side by side:</p>\n\n<pre><code>for&lt;'a&gt; IntoTest&lt;'a, &amp;'a [u8]&gt;\n&amp;'a [u8]\n</code></pre>\n\n<p>Here I've added a lifetime parameter on the slice for clarity. You can see that in the trait bound the lifetime parameter <code>'a</code> is <a href=\"https://en.wikipedia.org/wiki/Free_variables_and_bound_variables\" rel=\"nofollow\"><em>bound</em></a> by the <code>for</code> qualifier, in other words, this declaration is self-contained, it does not depend on anything in the external scope.</p>\n\n<p>In the slice, however, lifetime parameter <code>'a</code> is <em>free</em> - it is defined in some external scope, for example, through lifetime elision. Therefore, there is simply no way the slice can satisfy your trait implementation. For it to work your trait should be implemented like this:</p>\n\n<pre><code>impl&lt;'a, 'b&gt; IntoTest&lt;'a, &amp;'a [u8]&gt; for &amp;'b [u8] {\n    fn into_test(&amp;'a self) -&gt; &amp;'a [u8] {\n        unimplemented!()\n    }\n}\n</code></pre>\n\n<p>which <a href=\"http://is.gd/3a6lL6\" rel=\"nofollow\">compiles</a>, although it doesn't and couldn't do what you want. You can see that in this declaration lifetimes of the slice and in the trait signature are disjoint, therefore slices now do satisfy the <code>for&lt;'a&gt;</code>-based bound.</p>\n\n<p>There is another way to look at this problem. <code>T: for&lt;'a&gt; IntoTest&lt;'a, &amp;'a [u8]&gt;</code> bound means that type <code>T</code> implements the trait for every possible lifetime parameter of that trait, so the function itself can decide which lifetime it wants. For example, it could request <code>'static</code>. But naturally in your code <code>&amp;[u8]</code> is tied to the vector in the main method and cannot be <code>'static</code>. Therefore the soundness is violated - this <code>&amp;[u8]</code> can't provide any lifetime the user wants, and so it does not implement <code>for&lt;'a&gt; IntoTest&lt;'a, &amp;'a [u8]&gt;</code>.</p>\n\n<p>Note that just adding a lifetime parameter to the generic function won't work either:</p>\n\n<pre><code>fn higher_ranked_lifetime&lt;'a, T&gt;(test: T) where T: IntoTest&lt;'a, &amp;'a [u8]&gt; {\n    let _t = test.into_test();\n}\n</code></pre>\n\n<p>There will be this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>&lt;anon&gt;:12:14: 12:18 error: `test` does not live long enough\n&lt;anon&gt;:12     let _t = test.into_test();\n                       ^~~~\n&lt;anon&gt;:11:79: 13:2 note: reference must be valid for the lifetime 'a as defined on the block at 11:78...\n&lt;anon&gt;:11 fn higher_ranked_lifetime&lt;'a, T&gt;(test: T) where T: IntoTest&lt;'a, &amp;'a [u8]&gt; {\n&lt;anon&gt;:12     let _t = test.into_test();\n&lt;anon&gt;:13 }\n&lt;anon&gt;:11:79: 13:2 note: ...but borrowed value is only valid for the scope of parameters for function at 11:78\n&lt;anon&gt;:11 fn higher_ranked_lifetime&lt;'a, T&gt;(test: T) where T: IntoTest&lt;'a, &amp;'a [u8]&gt; {\n&lt;anon&gt;:12     let _t = test.into_test();\n&lt;anon&gt;:13 }\n</code></pre>\n\n<p>And this is again correct. Remember that your trait is defined like this:</p>\n\n<pre><code>pub trait IntoTest&lt;'a, T&gt; {\n    fn into_test(&amp;'a self) -&gt; T where Self: Sized;\n}\n</code></pre>\n\n<p>Here you require that <code>self</code> is passed by reference with the same lifetime as the lifetime parameter of the trait. However, the above declaration of the generic function makes this method not callable in principle:</p>\n\n<pre><code>fn higher_ranked_lifetime&lt;'a, T&gt;(test: T) where T: IntoTest&lt;'a, &amp;'a [u8]&gt;\n</code></pre>\n\n<p>Here the trait is specified to have lifetime parameter equal to the lifetime parameter of the function. However, <code>test</code> parameter itself lives only through the body of the function. Therefore, any reference taken to <code>test</code>, including the implicit one when calling <code>into_test()</code>:</p>\n\n<pre><code>let _t = (&amp;test).into_test();\n</code></pre>\n\n<p>will have lifetime strictly less than the lifetime parameter, and so it can't be used as a parameter for <code>into_test()</code> method. This is exactly what the error is about.</p>\n\n<p>Because you didn't explain what you really need, it's hard to say what you should do. I guess one of the most general ways would be to just drop your lifetime parameter on a trait and make the trait method accept <code>self</code> by value, and fix the generic function accordingly:</p>\n\n<pre><code>pub trait IntoTest&lt;T&gt; {\n    fn into_test(self) -&gt; T;\n}\n\nimpl&lt;'a&gt; IntoTest&lt;&amp;'a [u8]&gt; for &amp;'a [u8] {\n    fn into_test(self) -&gt; &amp;'a [u8] {\n        self\n    }\n}\n\nfn higher_ranked_lifetime&lt;'a, T&gt;(test: T) where T: IntoTest&lt;&amp;'a [u8]&gt; {\n    let _t = test.into_test();\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n    let vec = vec![1u8];\n    let slice = &amp;vec[..];\n    higher_ranked_lifetime(slice);\n}\n</code></pre>\n\n<p>This <a href=\"http://is.gd/ZtRVb0\" rel=\"nofollow\">does work</a> because now the trait itself does not have any lifetime parameters and does not add any requirements on how to call it. Lifetime parameters are now moved to types which implement it.</p>\n"}], "owner": {"reputation": 539, "user_id": 4313261, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh4.googleusercontent.com/-Vrtl0r4nCmI/AAAAAAAAAAI/AAAAAAAAAHM/fVptHJkPAsY/photo.jpg?sz=128", "display_name": "crhino", "link": "https://stackoverflow.com/users/4313261/crhino"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 206, "favorite_count": 2, "accepted_answer_id": 32198939, "answer_count": 1, "score": 6, "last_activity_date": 1440513649, "creation_date": 1440485585, "question_id": 32197330, "link": "https://stackoverflow.com/questions/32197330/trouble-implementing-higher-ranked-lifetime-type-bound-for-a-byte-slice", "title": "Trouble implementing higher ranked lifetime type bound for a byte slice", "body": "<p>I am trying to implement a trait on a <code>&amp;'a [u8]</code> and use it in an implementation that uses higher ranked lifetimes, e.g.:</p>\n\n<pre><code>pub trait IntoTest&lt;'a, T&gt; {\n    fn into_test(&amp;'a self) -&gt; T where Self: Sized;\n}\n\nimpl&lt;'a&gt; IntoTest&lt;'a, &amp;'a [u8]&gt; for &amp;'a [u8] {\n    fn into_test(&amp;'a self) -&gt; &amp;'a [u8] {\n        self\n    }\n}\n\nfn higher_ranked_lifetime&lt;T&gt;(test: T) where T: for&lt;'a&gt; IntoTest&lt;'a, &amp;'a [u8]&gt; {\n    let _t = test.into_test();\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n    let vec = vec![1u8];\n    let slice = &amp;vec[..];\n    higher_ranked_lifetime(slice);\n}\n</code></pre>\n\n<p>Short URL: <a href=\"http://is.gd/1QKhYk\">http://is.gd/1QKhYk</a></p>\n\n<p>The error I am getting is:</p>\n\n<pre><code>&lt;anon&gt;:19:5: 19:27 error: the trait `for&lt;'a&gt; IntoTest&lt;'a, &amp;'a [u8]&gt;` is not implemented for the type `&amp;[u8]` [E0277]\n&lt;anon&gt;:19     higher_ranked_lifetime(slice);\n</code></pre>\n\n<p>How should I be doing this? Is this even the right thing to do? I do not want to scope my <code>higher_ranked_lifetime</code> to a specific lifetime, but have it be applicable to any byte slice passed to it.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 9, "creation_date": 1440512438, "post_id": 32194553, "comment_id": 52297078, "body": "&quot;<code>for&lt;</code>&quot; appears 0 times in The Rust Book, and is used (excluding tests) a grand total of 33 times in the compiler. No wonder I haven&#39;t seen it before. If anyone&#39;s wondering about them, the only documentation I could find is <a href=\"https://github.com/nikomatsakis/rfcs/blob/hrtb/active/0000-higher-ranked-trait-bounds.md\" rel=\"nofollow noreferrer\">the RFC</a>."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 0, "creation_date": 1440512730, "post_id": 32194553, "comment_id": 52297316, "body": "Oh, the RFC points out that parenthesis notation will elide it all anyway: <a href=\"http://is.gd/fdy0M7\" rel=\"nofollow noreferrer\">is.gd/fdy0M7</a>."}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 3, "creation_date": 1440512842, "post_id": 32194553, "comment_id": 52297411, "body": "Yup, for&lt;&gt; is pretty much the last thing I haven&#39;t documented."}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 15, "last_activity_date": 1502666003, "last_edit_date": 1502666003, "creation_date": 1440469172, "answer_id": 32194553, "question_id": 32194367, "link": "https://stackoverflow.com/questions/32194367/expected-bound-lifetime-parameter-found-concrete-lifetime/32194553#32194553", "title": "Expected bound lifetime parameter, found concrete lifetime", "body": "<p>Your trait function definition is this:</p>\n\n<pre><code>fn handle&lt;'a&gt;(&amp;self, req: Request, res: Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;;\n</code></pre>\n\n<p>Note that <code>'a</code> is specified by the caller and can be anything and is not necessarily tied to <code>self</code> in any way.</p>\n\n<p>Your trait implementation definition is this:</p>\n\n<pre><code>fn handle(&amp;self, req: Request, res: Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;;\n</code></pre>\n\n<p><code>'a</code> is not here specified by the caller, but is instead tied to the type you are implementing the trait for. Thus the trait implementation does not match the trait definition.</p>\n\n<p>Here is what you need:</p>\n\n<pre><code>trait Handler: Send + Sync {\n    fn handle&lt;'a&gt;(&amp;self, req: Request, res: Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;;\n}\n\nimpl&lt;T&gt; Handler for T\nwhere\n    T: Send + Sync + for&lt;'a&gt; Fn(Request, Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;,\n{\n    fn handle&lt;'a&gt;(&amp;self, req: Request, res: Response&lt;'a&gt;) -&gt; Action&lt;'a&gt; {\n        (*self)(req, res)\n    }\n}\n</code></pre>\n\n<p>The key point is the change in the <code>T</code> bound: <code>for&lt;'a&gt; Fn(Request, Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;</code>. This means: \u201cgiven an arbitrary lifetime parameter <code>'a</code>, <code>T</code> must satisfy <code>Fn(Request, Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;</code>; or, \u201c<code>T</code> must, for all <code>'a</code>, satisfy <code>Fn(Request, Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;</code>.</p>\n"}], "owner": {"reputation": 520, "user_id": 884498, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/88109a4658cfee0b9d680f48f073d9d4?s=128&d=identicon&r=PG", "display_name": "Nathan Fox", "link": "https://stackoverflow.com/users/884498/nathan-fox"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6850, "favorite_count": 1, "accepted_answer_id": 32194553, "answer_count": 1, "score": 16, "last_activity_date": 1502666003, "creation_date": 1440467501, "last_edit_date": 1502665941, "question_id": 32194367, "link": "https://stackoverflow.com/questions/32194367/expected-bound-lifetime-parameter-found-concrete-lifetime", "title": "Expected bound lifetime parameter, found concrete lifetime", "body": "<p>I can't figure out the lifetime parameters for this code. Everything I try usually results in a compiler error: \"Expected bound lifetime parameter <code>'a</code>, found concrete lifetime\" or something like \"consider using an explicit lifetime parameter as shown\" (and the example shown doesn't help) or \"method not compatible with trait\".</p>\n\n<p><code>Request</code>, <code>Response</code>, and <code>Action</code> are simplified versions to keep this example minimal.</p>\n\n<pre><code>struct Request {\n    data: String,\n}\nstruct Response&lt;'a&gt; {\n    data: &amp;'a str,\n}\n\npub enum Action&lt;'a&gt; {\n    Next(Response&lt;'a&gt;),\n    Done,\n}\n\npub trait Handler: Send + Sync {\n    fn handle&lt;'a&gt;(&amp;self, req: Request, res: Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;;\n}\n\nimpl&lt;'a, T&gt; Handler for T\nwhere\n    T: Send + Sync + Fn(Request, Response&lt;'a&gt;) -&gt; Action&lt;'a&gt;,\n{\n    fn handle(&amp;self, req: Request, res: Response&lt;'a&gt;) -&gt; Action&lt;'a&gt; {\n        (*self)(req, res)\n    }\n}\n\nfn main() {\n    println!(\"running\");\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=f076024b4903afa81213d920e5056a65&amp;version=stable\" rel=\"noreferrer\">Rust Playground</a></p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 0, "creation_date": 1440467812, "post_id": 32194269, "comment_id": 52273919, "body": "Consider what happens to an internal pointer when a struct is moved."}], "answers": [{"comments": [{"owner": {"reputation": 521, "user_id": 963252, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/cf53173bc0968c9cfba3f1911d77fa56?s=128&d=identicon&r=PG", "display_name": "Ant Manelope", "link": "https://stackoverflow.com/users/963252/ant-manelope"}, "edited": false, "score": 0, "creation_date": 1440472274, "post_id": 32194679, "comment_id": 52274962, "body": "Thanks, that clear up the mystery.  :-)  Unfortunately in my actual use case, I&#39;m still stuck with repeating a lot of code.  See <a href=\"http://pastebin.com/2Vy5RYmG\" rel=\"nofollow noreferrer\">pastebin.com/2Vy5RYmG</a> and the block of code in run_thread() for my motivation here.  I&#39;m trying to not repeat myself so much every time I need to access the current thread&#39;s session."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 521, "user_id": 963252, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/cf53173bc0968c9cfba3f1911d77fa56?s=128&d=identicon&r=PG", "display_name": "Ant Manelope", "link": "https://stackoverflow.com/users/963252/ant-manelope"}, "edited": false, "score": 1, "creation_date": 1440472973, "post_id": 32194679, "comment_id": 52275105, "body": "@AntManelope I guess I&#39;m missing the problem. After <a href=\"http://is.gd/kWTb2s\" rel=\"nofollow noreferrer\">a little refactoring</a>, there&#39;s not all that much duplication, in my opinion."}, {"owner": {"reputation": 521, "user_id": 963252, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/cf53173bc0968c9cfba3f1911d77fa56?s=128&d=identicon&r=PG", "display_name": "Ant Manelope", "link": "https://stackoverflow.com/users/963252/ant-manelope"}, "edited": false, "score": 0, "creation_date": 1440473837, "post_id": 32194679, "comment_id": 52275319, "body": "Fair enough.  I&#39;m off and running now."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1440470264, "last_edit_date": 1495542386, "creation_date": 1440470264, "answer_id": 32194679, "question_id": 32194269, "link": "https://stackoverflow.com/questions/32194269/borrowing-reference-and-guard-together-from-a-mutex/32194679#32194679", "title": "Borrowing reference and guard together from a Mutex", "body": "<p>Let's look at the <a href=\"http://doc.rust-lang.org/std/ops/trait.DerefMut.html#tymethod.deref_mut\" rel=\"nofollow noreferrer\"><code>DerefMut</code> trait</a>:</p>\n\n<pre><code>pub trait DerefMut: Deref {\n    fn deref_mut(&amp;'a mut self) -&gt; &amp;'a mut Self::Target;\n}\n</code></pre>\n\n<p>This means that when <code>deref_mut</code> is called, a reference is returned that <em>lives as long as the value being dereferenced</em>. However, you are moving <code>guard</code> when you move it to <code>BorrowedInnerData</code>. This means that the value stops living at one memory location and starts at a new one. As <a href=\"https://stackoverflow.com/questions/32194269/borrowing-reference-and-guard-together-from-a-mutex#comment52273919_32194269\">Veedrac hints at</a>, it's entirely possible that by moving the guard, you would invalidate the reference. This would be bad and lead to crashes (in the best case).</p>\n\n<p>However, there's no real reason to keep <code>guard</code> and <code>inner_data</code>. Because of <code>Deref</code> and <code>DerefMut</code>, a <code>MutexGuard&lt;InnerData&gt;</code> can be used just like a <code>&amp;InnerData</code> or <code>&amp;mut InnerData</code>. Simply remove <code>inner_data</code> from your struct and keep <code>guard</code>.</p>\n"}], "owner": {"reputation": 521, "user_id": 963252, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/cf53173bc0968c9cfba3f1911d77fa56?s=128&d=identicon&r=PG", "display_name": "Ant Manelope", "link": "https://stackoverflow.com/users/963252/ant-manelope"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1790, "favorite_count": 0, "accepted_answer_id": 32194679, "answer_count": 1, "score": 4, "last_activity_date": 1440470264, "creation_date": 1440466727, "question_id": 32194269, "link": "https://stackoverflow.com/questions/32194269/borrowing-reference-and-guard-together-from-a-mutex", "title": "Borrowing reference and guard together from a Mutex", "body": "<p>I'm trying to encapsulate some code to avoid repeating it, relating to borrowing data out of a Mutex and further operations thereupon (which I leave off of this question as out of scope, but are the motivating factors).</p>\n\n<p>The following sample code complains that <code>guard</code> does not live long enough.  But that is precisely why I'm returning <code>guard</code> in the structure designed expressly for that purpose.</p>\n\n<p>Is this a limitation of the borrow checker?  Any suggestions on working around this?</p>\n\n<pre><code>use std::sync::{Mutex,MutexGuard};\nuse std::ops::DerefMut;\n\npub struct InnerData {\n    count: i32  // sample only\n}\n\npub struct Data {\n    pub inner_data: Mutex&lt;InnerData&gt;\n}\n\npub struct BorrowedInnerData&lt;'a&gt; {\n    pub inner_data: &amp;'a mut InnerData,\n    guard: MutexGuard&lt;'a,InnerData&gt;,\n}\n\nimpl Data {\n    pub fn borrow_inner_data&lt;'a&gt;(&amp;'a mut self) -&gt; BorrowedInnerData&lt;'a&gt; {\n        let guard = self.inner_data.lock().unwrap();\n        BorrowedInnerData {\n            inner_data: guard.deref_mut(),\n            guard: guard,\n        }\n    }\n}\n\nfn main() {\n    let mut data = Data {\n        inner_data: Mutex::new( InnerData {\n            count: 5\n        }),\n    };\n\n    let borrowed_inner_data = data.borrow_inner_data();\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440451197, "post_id": 32191649, "comment_id": 52268964, "body": "Please <a href=\"https://stackoverflow.com/posts/32191649/edit\">edit</a> your post to fix the missing curly brace and possibly indentation."}], "answers": [{"comments": [{"owner": {"reputation": 542, "user_id": 584839, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/0458b30ca5c58099f9d06a57497b2900?s=128&d=identicon&r=PG", "display_name": "Tetigi", "link": "https://stackoverflow.com/users/584839/tetigi"}, "edited": false, "score": 0, "creation_date": 1440453249, "post_id": 32191828, "comment_id": 52269824, "body": "Thanks for the great explanation! I do wish the compiler was a little bit smarter about these kind of things - it sucks having to pull out of a nice match loop just to appease it :P"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1440453547, "post_id": 32191828, "comment_id": 52269925, "body": "Couldn&#39;t this be rewritten with entries API? I think it solves exactly this problem (and given <code>Copy</code> keys it is rather easy to use). (BTW, you didn&#39;t reuse the <code>key</code> in <code>insert</code>)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440453841, "post_id": 32191828, "comment_id": 52270045, "body": "@VladimirMatveev good point, I forgot about the entry API here, as I was focused on the borrow issue. However, since <code>routes</code> is passed down to the recursive call, it doesn&#39;t like it. <a href=\"http://is.gd/dHpmeQ\" rel=\"nofollow noreferrer\">Did I miss something</a>?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440483490, "post_id": 32191828, "comment_id": 52278342, "body": "Oh, indeed, I somehow missed the recursion bit. In this case you&#39;re right, I don&#39;t think it&#39;s possible to use entries, unfortunately."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1440453760, "last_edit_date": 1440453760, "creation_date": 1440450863, "answer_id": 32191828, "question_id": 32191649, "link": "https://stackoverflow.com/questions/32191649/mutably-passing-an-immutably-borrowed-variable/32191828#32191828", "title": "Mutably passing an immutably borrowed variable", "body": "<p>I know that this has been answered before, but searching for it is not proving fruitful. If anyone finds a dupe, feel free to mark this as such.</p>\n\n<p>The problem is that in Rust, borrow scopes are currently <em>lexical</em> \u2014 they correspond to regions of code, ending at a closing curly brace.</p>\n\n<p>In your example, the borrow of <code>routes</code> lasts for the entire <code>match</code> block, which includes the <code>None</code> case. A smarter compiler would be able to see that the <code>None</code> case has no references to the <code>routes</code> and allow you to change it. For now, you have to make your code a bit uglier:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::cmp;\n\nfn dive(seen: u32, d: u32, r: u32, routes: &amp;mut HashMap&lt;(u32, u32), u32&gt;) -&gt; u32 {\n    let key = (cmp::max(d, r), cmp::min(d, r));\n\n    if let Some(v) = routes.get(&amp;key) {\n        return seen + *v;\n    }\n\n    let result = dive(0, d-1, r, routes) + dive(0, d, r-1, routes);\n    routes.insert(key, result);\n    seen + result\n}\n\nfn main() {}\n</code></pre>\n\n<p>This splits up the code into two distinct scopes, clarifying that the borrow only is needed in the first one.</p>\n\n<p>There is hope for this to change. The original issue was <a href=\"https://github.com/rust-lang/rust/issues/6393\" rel=\"nofollow\">borrow scopes should not always be lexical</a>, which was closed in favor of <a href=\"https://github.com/rust-lang/rfcs/issues/811\" rel=\"nofollow\">an RFC</a>. At the current point in time, the RFC is postponed. Unfortunately, changing from lexical to non-lexical scopes for borrows has the potential to make certain types of things harder to reason about.</p>\n"}], "owner": {"reputation": 542, "user_id": 584839, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/0458b30ca5c58099f9d06a57497b2900?s=128&d=identicon&r=PG", "display_name": "Tetigi", "link": "https://stackoverflow.com/users/584839/tetigi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 74, "favorite_count": 0, "accepted_answer_id": 32191828, "answer_count": 1, "score": 0, "last_activity_date": 1440453760, "creation_date": 1440450000, "last_edit_date": 1440450214, "question_id": 32191649, "link": "https://stackoverflow.com/questions/32191649/mutably-passing-an-immutably-borrowed-variable", "title": "Mutably passing an immutably borrowed variable", "body": "<p>I'm trying to create a simple memoisation-style call loop. It looks something like this:</p>\n\n<pre><code>fn dive(seen: u32, d: u32, r: u32, routes: &amp;mut HashMap&lt;(u32, u32), u32&gt;) -&gt; u32 {\n    match routes.get(&amp;(cmp::max(d, r), cmp::min(d, r))) {\n    Some(v) =&gt; seen + *v,\n    None =&gt; {\n        let result = dive(0, d-1, r, routes) + dive(0, d, r-1, routes);\n        routes.insert((cmp::max(d, r), cmp::min(d, r)), result);\n        seen + result\n    }\n}\n</code></pre>\n\n<p>However, I am having issues because routes is borrowed immutably for the match, and then passed mutably for the following <code>dives</code> whilst still in a valid lifetime. </p>\n\n<p>How can I get this to work? Can it be fixed by simply 'copying' the immutable value somehow? Or do I need to fix the control flow?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1440445750, "post_id": 32190430, "comment_id": 52266269, "body": "Ideally, you should create an <a href=\"/help/mcve\">MCVE</a> that doesn&#39;t require us to know the postgres crate in and out. Something that runs on <a href=\"https://play.rust-lang.org/\" rel=\"nofollow noreferrer\">the playground</a> is the best."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440446042, "post_id": 32190430, "comment_id": 52266437, "body": "My <a href=\"http://is.gd/WNlcSW\" rel=\"nofollow noreferrer\">attempt at an MCVE</a> doesn&#39;t seem to have the same problem you relate."}, {"owner": {"reputation": 79, "user_id": 3791276, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c090675513444a844805eecc77231f42?s=128&d=identicon&r=PG&f=1", "display_name": "user3791276", "link": "https://stackoverflow.com/users/3791276/user3791276"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440451210, "post_id": 32190430, "comment_id": 52268971, "body": "I went ahead and built up a simple demonstration on the Rust Playground, but you&#39;re right--it doesn&#39;t show the error I&#39;m seeing. I guess I don&#39;t even know what the underlying issue is, which makes this question unanswerable."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440451316, "post_id": 32190430, "comment_id": 52269021, "body": "Keep on trying! Sometimes the act of building the MCVE helps you solve the problem yourself \u2014 then you can come back and help us understand ^_^."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1440453138, "post_id": 32190430, "comment_id": 52269780, "body": "Incidentally, this question has already been asked (and answered) a week ago. See <a href=\"http://stackoverflow.com/questions/32081065/trait-x-is-not-implemented-for-the-type-x/\">here</a>. If it is indeed about your problem, we&#39;ll close this one as a duplicate. If not, try to explain the difference of your question from that question."}, {"owner": {"reputation": 79, "user_id": 3791276, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c090675513444a844805eecc77231f42?s=128&d=identicon&r=PG&f=1", "display_name": "user3791276", "link": "https://stackoverflow.com/users/3791276/user3791276"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440454340, "post_id": 32190430, "comment_id": 52270252, "body": "@VladimirMatveev Good find, that was exactly it. Looks like I can&#39;t have generics in a trait that I&#39;m using inside a Box."}], "owner": {"reputation": 79, "user_id": 3791276, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c090675513444a844805eecc77231f42?s=128&d=identicon&r=PG&f=1", "display_name": "user3791276", "link": "https://stackoverflow.com/users/3791276/user3791276"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 36, "favorite_count": 0, "closed_date": 1440470386, "answer_count": 0, "score": 0, "last_activity_date": 1440445629, "creation_date": 1440445303, "last_edit_date": 1440445629, "question_id": 32190430, "link": "https://stackoverflow.com/questions/32190430/trait-with-methods-that-take-generic-parameters", "closed_reason": "Duplicate", "title": "Trait with methods that take generic parameters", "body": "<p>I'm building a webapp in Rust and trying to implement basic Rails-style database migrations for managing my database. In my code, Migration is a trait with up and down methods to apply and roll back the migration. Each individual database migration is a struct that implements the Migration trait.</p>\n\n<p>I started out with this version of the Migration trait, and it compiles fine:</p>\n\n<pre><code>pub trait Migration : Display {\n    fn up(&amp;self, connection: &amp;postgres::Connection) -&gt; postgres::Result&lt;()&gt;;\n    fn down(&amp;self, connection: &amp;postgres::Connection) -&gt; postgres::Result&lt;()&gt;;\n}\n</code></pre>\n\n<p>But ideally I'd like to allow the caller to pass in either a transaction object or a raw connection object to run the migration. The Postgres crate supports this by providing the <code>GenericConnection</code> trait which both connections and transactions implement. So I refactored my Migration trait to this:</p>\n\n<pre><code>pub trait Migration : Display {\n    fn up&lt;T: postgres::GenericConnection&gt;(&amp;self, connection: &amp;T) -&gt; postgres::Result&lt;()&gt;;\n    fn down&lt;T: postgres::GenericConnection&gt;(&amp;self, connection: &amp;T) -&gt; postgres::Result&lt;()&gt;;\n}\n</code></pre>\n\n<p>But now when I compile, any code that tries to make use of a Migration generates the error <code>the trait db::migrations::migration::Migration is not implemented for the type db::migrations::migration::Migration</code>. For example, I have a struct that keeps track of all my migrations:</p>\n\n<pre><code>pub struct MigrationIndex {\n    /// all database migrations, in order from first to last\n    migrations: Vec&lt;Box&lt;Migration&gt;&gt;\n}\n</code></pre>\n\n<p>And it compiles fine with the first version of the <code>Migration</code> trait, and fails with the error above when using the version of <code>Migration</code> with generics. Am I using generics in traits wrong?</p>\n"}, {"tags": ["stream", "rust"], "answers": [{"comments": [{"owner": {"reputation": 694, "user_id": 5179678, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/HDDwl.jpg?s=128&g=1", "display_name": "mgul", "link": "https://stackoverflow.com/users/5179678/mgul"}, "edited": false, "score": 0, "creation_date": 1440521143, "post_id": 32194802, "comment_id": 52303099, "body": "Thank you, I&#39;ll test this as soon as I can."}, {"owner": {"reputation": 694, "user_id": 5179678, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/HDDwl.jpg?s=128&g=1", "display_name": "mgul", "link": "https://stackoverflow.com/users/5179678/mgul"}, "edited": false, "score": 0, "creation_date": 1440521987, "post_id": 32194802, "comment_id": 52303597, "body": "What I want, to be exact, is write body&#39;s data as soo nas they come in a file. I don&#39;t want to download all the body and then write, I want to write it byte per byte, as soon as they come."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 694, "user_id": 5179678, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/HDDwl.jpg?s=128&g=1", "display_name": "mgul", "link": "https://stackoverflow.com/users/5179678/mgul"}, "edited": false, "score": 0, "creation_date": 1440522450, "post_id": 32194802, "comment_id": 52303869, "body": "@Jhun that&#39;s fine. <code>req.origin</code> implements <code>Read</code> which will let you stream things. I honestly don&#39;t know exactly when the handler is called, like if Nickel waits for the whole thing to be buffered or not."}, {"owner": {"reputation": 694, "user_id": 5179678, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/HDDwl.jpg?s=128&g=1", "display_name": "mgul", "link": "https://stackoverflow.com/users/5179678/mgul"}, "edited": false, "score": 0, "creation_date": 1440523067, "post_id": 32194802, "comment_id": 52304192, "body": "<code>curl --request PUT -d &quot;test&quot; http:&#47;&#47;127.0.0.1:6767&#47;test</code> returns me <code>You posted 4 bytes.</code> ... So it works ! Now I need to know if nickels waits about all the data, or if I can put some code between the moment when nickels reads the first byte, and the last."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1440471132, "creation_date": 1440471132, "answer_id": 32194802, "question_id": 32189161, "link": "https://stackoverflow.com/questions/32189161/reading-the-request-body-with-nickel-rs/32194802#32194802", "title": "Reading the request body with nickel.rs", "body": "<p>Nickel is built on top of <a href=\"https://github.com/hyperium/hyper\" rel=\"nofollow\">hyper</a>, and the <a href=\"http://docs.nickel.rs/nickel/struct.Request.html\" rel=\"nofollow\">Nickel <code>Request</code></a>  exposes the original hyper request:</p>\n\n<pre><code>pub struct Request&lt;'a, 'b, 'k&gt; {\n    pub origin: HyperRequest&lt;'a, 'k&gt;,\n    pub route_result: Option&lt;RouteResult&lt;'b&gt;&gt;,\n    // some fields omitted\n}\n</code></pre>\n\n<p>That, in turn, implements the <code>Read</code> trait:</p>\n\n<pre><code>#[macro_use] extern crate nickel;\n\nuse nickel::Nickel;\nuse std::io::Read;\n\nfn main() {\n    let mut server = Nickel::new();\n\n    server.utilize(router! {\n        post \"**\" =&gt; |req, _res| {\n            let mut body = vec![];\n            req.origin.read_to_end(&amp;mut body).unwrap();\n            format!(\"You posted {} bytes\", body.len())\n        }\n    });\n\n    server.listen(\"127.0.0.1:6767\");\n}\n</code></pre>\n"}], "owner": {"reputation": 694, "user_id": 5179678, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/HDDwl.jpg?s=128&g=1", "display_name": "mgul", "link": "https://stackoverflow.com/users/5179678/mgul"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 351, "favorite_count": 0, "accepted_answer_id": 32194802, "answer_count": 1, "score": 3, "last_activity_date": 1440471132, "creation_date": 1440440696, "last_edit_date": 1440441183, "question_id": 32189161, "link": "https://stackoverflow.com/questions/32189161/reading-the-request-body-with-nickel-rs", "title": "Reading the request body with nickel.rs", "body": "<p>I would like to send a request to my API and put some binary data in the body of the request, but nickel.rs doesn't seem to have a way to handle streams.</p>\n\n<p>I can get the POST parameters and parse them into JSON, but how can I read the body?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440442233, "post_id": 32189104, "comment_id": 52264263, "body": "<code>box RustStruct::new()</code> without feature flag? Has <code>box</code> syntax been made stable?"}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440454611, "post_id": 32189104, "comment_id": 52270347, "body": "@VladimirMatveev not yet, they must be missing a flag"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 10, "last_activity_date": 1440485016, "last_edit_date": 1440485016, "creation_date": 1440440510, "answer_id": 32189104, "question_id": 32188582, "link": "https://stackoverflow.com/questions/32188582/wrapping-a-rust-struct-in-a-c-class/32189104#32189104", "title": "Wrapping a Rust struct in a C++ class", "body": "<p>There is a mix of multiple FFIs concepts in your answer, so first let me recommend that your read the <a href=\"https://doc.rust-lang.org/book/ffi.html\" rel=\"nofollow noreferrer\">Reference</a>.</p>\n\n<p>There are two ways to achieve what you wish, you can either:</p>\n\n<ul>\n<li>use a POD <code>struct</code> (Plain Old Data), aka C-compatible struct</li>\n<li>use an opaque pointer (<code>void*</code> in C)</li>\n</ul>\n\n<p>Mixing them, as you did, does not make sense.</p>\n\n<hr>\n\n<blockquote>\n  <p>Which to pick?</p>\n</blockquote>\n\n<p>Both solutions have advantages and disadvantages, it's basically an expressiveness versus performance trade-off.</p>\n\n<p>On the one hand, opaque pointers are more expressive: they can point to any Rust type. However:</p>\n\n<ul>\n<li>they require dynamic memory allocation</li>\n<li>they require being manipulated by Rust functions (so always indirectly from C or C++)</li>\n</ul>\n\n<p>On the other hand, POD struct do not require either of those, but they are limited to only a subset of types expressible in Rust.</p>\n\n<hr>\n\n<blockquote>\n  <p>How to use a POD?</p>\n</blockquote>\n\n<p>This is the easiest, actually, so let's start with it!</p>\n\n<p>In Rust:</p>\n\n<pre><code>#[repr(C)]\npub struct RustStruct {\n    num: i32,\n    // other members, also PODs!\n}\n</code></pre>\n\n<p>In C++</p>\n\n<pre><code>struct RustStruct {\n    int32_t num;\n    // other members, also with Standard Layout\n    // http://en.cppreference.com/w/cpp/types/is_standard_layout\n};\n\nclass Wrapper {\npublic:\nprivate:\n    RustStruct rustStruct;\n};\n</code></pre>\n\n<p>Note that I just got along with your question stricto censu here, you could actually merge the two in a single C++ class:</p>\n\n<pre><code>class RustStruct {\npublic:\nprivate:\n    int32_t num;\n    // other members, also with Standard Layout\n    // http://en.cppreference.com/w/cpp/types/is_standard_layout\n};\n</code></pre>\n\n<p>Just avoid <code>virtual</code> methods.</p>\n\n<hr>\n\n<blockquote>\n  <p>How to use an opaque pointer?</p>\n</blockquote>\n\n<p>This gets trickier:</p>\n\n<ul>\n<li>Only the Rust code may correctly create/copy/destruct the type</li>\n<li>Beware of leaking...</li>\n</ul>\n\n<p>So, we need to implement a lot of functions in Rust:</p>\n\n<pre><code>#![feature(box_raw, box_syntax)]\nuse std::boxed;\n\npub struct RustStruct {\n    num: i32,\n    // other members, anything goes\n}\n\npub extern \"C\" fn createRustStruct() -&gt; *mut RustStruct {\n    boxed::into_raw(box RustStruct::new())\n}\n\npub extern \"C\" fn destroyRustStruct(o: *mut RustStruct) {\n    boxed::from_raw(o);\n}\n</code></pre>\n\n<p>Alright... now on to C++:</p>\n\n<pre><code>struct RustStruct;\n\nRustStruct* createRustStruct();\nvoid destroyRustStruct(RustStruct*);\n\nclass Wrapper {\npublic:\n    Wrapper(): rustStruct(RustStructPtr(createRustStruct())) {}\n\nprivate:\n    struct Deleter {\n        void operator()(RustStruct* rs) const {\n            destroyRustStruct(rs);\n        }\n    };\n\n    typedef std::unique_ptr&lt;RustStruct, Deleter&gt; RustStructPtr;\n\n    RustStructPtr rustStruct;\n}; // class Wrapper\n</code></pre>\n\n<p>So, yes, a bit more involved, and <code>Wrapper</code> is not copyable either (copy has to be delegated to Rust too). Anyway, this should get you started!</p>\n\n<p><em>Note: if you have a lot of opaque pointers to wrap, a templated C++ class taking the copy/destroy functions as template parameters could alleviate a lot of boiler plate.</em></p>\n"}], "owner": {"reputation": 2060, "user_id": 2561805, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/ad2d8c097cfaa8fdc3ac87bfa9b8d277?s=128&d=identicon&r=PG", "display_name": "goo", "link": "https://stackoverflow.com/users/2561805/goo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1613, "favorite_count": 2, "accepted_answer_id": 32189104, "answer_count": 1, "score": 6, "last_activity_date": 1440485016, "creation_date": 1440438759, "last_edit_date": 1440453060, "question_id": 32188582, "link": "https://stackoverflow.com/questions/32188582/wrapping-a-rust-struct-in-a-c-class", "title": "Wrapping a Rust struct in a C++ class", "body": "<p>I would like to wrap a Rust struct in a C++ class.</p>\n\n<p>Rust:</p>\n\n<pre><code>#[repr(C)]\npub struct RustStruct {\n  num: i32,\n  // other members..\n}\n\npub extern \"C\" fn update(rust_struct: *mut RustStruct) {\n  (*rust_struct).num = 1i32;\n}\n\nextern \"C\" {\n  void update(void*);\n}\n</code></pre>\n\n<p>C++:</p>\n\n<pre><code>class Wrapper {\n  public:\n    Wrapper();\n    // ..\n\n  private:\n    void* rustStruct;\n    // ..\n};\n\nWrapper::Wrapper() {\n  update(rustStruct); // crash\n}\n\nint main() {\n  std::cout &lt;&lt; \"Testing..\";\n}\n</code></pre>\n\n<p>I understand why this wouldn't work. My question is: how can I achieve what I'm basically trying to do (wrap a rust struct in a c++ class)?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1440419227, "post_id": 32180684, "comment_id": 52249922, "body": "I don&#39;t get your point of your edit. In a function signature, the context tells us that we&#39;re declaring parameters and not assigning anything. And how you get the impression that anything happens by-reference, without any <code>&amp;</code> or other indicator, is beyond me."}, {"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440419266, "post_id": 32180684, "comment_id": 52249945, "body": "@delnan Read it carefully - I said that it isn&#39;t by reference, but it looks like it might be."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1440419328, "post_id": 32180684, "comment_id": 52249984, "body": "I understand that. I just don&#39;t get how it might look like it. There is nothing indicating that. As you note, the only difference is the absence of <code>let</code>, what does that have to do with by-value/by-reference?"}, {"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440420379, "post_id": 32180684, "comment_id": 52250736, "body": "The fact that <code>let</code> it missing makes it look (to me personally) like it&#39;s not the creation of a new variable. Therefore perhaps it is something else. Perhaps that something else is a reference? What else could it be?"}, {"owner": {"reputation": 12462, "user_id": 2298137, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/JN0cS.png?s=128&g=1", "display_name": "code_fodder", "link": "https://stackoverflow.com/users/2298137/code-fodder"}, "edited": false, "score": 1, "creation_date": 1598775988, "post_id": 32180684, "comment_id": 112563618, "body": "I don&#39;t really think this question is opinion based, its a legit question &quot;why does rust have the keyword let?&quot; - as a c++ guy, I was thinking the same as I was trying to understand rust&#39;s syntax. The answer given by Chris explains it nicely, and I think this question is a useful aid to anyone from a c++ background to start to understand rust. I vote to reopen it just for that reason..."}], "answers": [{"comments": [{"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 1, "creation_date": 1440416019, "post_id": 32181194, "comment_id": 52247841, "body": "Interesting points raised here - can you give an example of such an ambiguity? And to respond to paragraph 3, No, many years ago when I stopped using Basic and went to start programming in C, I liked that the &quot;dim&quot; keyword had disappeared because I didn&#39;t see any reason for it being there. I don&#39;t understand your point about philosophical grounds - I think it&#39;s perhaps personal preference whether you prefer type or identifier first? What&#39;s your philosophical argument for having the type after?"}, {"owner": {"reputation": 3986, "user_id": 1112707, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/c1I4K.jpg?s=128&g=1", "display_name": "seb", "link": "https://stackoverflow.com/users/1112707/seb"}, "edited": false, "score": 0, "creation_date": 1492025951, "post_id": 32181194, "comment_id": 73818485, "body": "So, from a visual perspective, assigning a value to a type is less silly than i32 x = 5; ?"}, {"owner": {"reputation": 158, "user_id": 4151878, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3998471c565e79df679511f44212aa1a?s=128&d=identicon&r=PG&f=1", "display_name": "Wtrmute", "link": "https://stackoverflow.com/users/4151878/wtrmute"}, "edited": false, "score": 0, "creation_date": 1501705447, "post_id": 32181194, "comment_id": 77901647, "body": "<i>&quot;Who came up with that idea?&quot;</i> <a href=\"https://www.bell-labs.com/usr/dmr/www/chist.html\" rel=\"nofollow noreferrer\">Dennis Ritchie did</a>. <i>&quot;Analogical reasoning led to a declaration syntax for names mirroring that of the expression syntax in which the names typically appear.&quot;</i> In retrospect, it was an unfortunate move (because it removed all hope of context insensitivity from the language), but it probably seemed like a great idea at the time exactly on philosophical grounds (&quot;how do you generalise type composition syntax?&quot;)"}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 158, "user_id": 4151878, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3998471c565e79df679511f44212aa1a?s=128&d=identicon&r=PG&f=1", "display_name": "Wtrmute", "link": "https://stackoverflow.com/users/4151878/wtrmute"}, "edited": false, "score": 0, "creation_date": 1501750136, "post_id": 32181194, "comment_id": 77918870, "body": "@Wtrmute: I\u2019m finding that a bit hard to follow. Is the expression syntax it refers to \u201c(int) foo\u201d? If so that doesn\u2019t seem like a very good mirror, so I\u2019m wondering if it\u2019s something else."}, {"owner": {"reputation": 158, "user_id": 4151878, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3998471c565e79df679511f44212aa1a?s=128&d=identicon&r=PG&f=1", "display_name": "Wtrmute", "link": "https://stackoverflow.com/users/4151878/wtrmute"}, "edited": false, "score": 0, "creation_date": 1501755912, "post_id": 32181194, "comment_id": 77923341, "body": "@ChrisMorgan: Ritchie&#39;s article (which I linked) explains this much better than a SO comment ever could, but it refers to the expressions with which one gets the primitive type out of the type of the variable. Ritchie gives examples, among which <code>int *api[10], (*pai)[10];</code> \u2014 in each case, the expressions <code>*api[0]</code> and <code>(*pai)[0]</code> yield exactly the primitve type <code>int</code>."}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": false, "score": 36, "last_activity_date": 1440415666, "creation_date": 1440415666, "answer_id": 32181194, "question_id": 32180684, "link": "https://stackoverflow.com/questions/32180684/why-does-rust-bother-with-let/32181194#32181194", "title": "Why does Rust bother with &quot;let&quot;?", "body": "<p>Rust has local type inference, so the type normally doesn\u2019t need to be written; <code>let x = 5;</code> will suffice. <code>x = 5;</code> would be quite different, as it would not <em>declare</em> a variable <code>x</code>, and Rust very deliberately separates declaration and assignment.</p>\n\n<p>It\u2019s also actually <code>let PATTERN = EXPR;</code>, not just <code>let IDENT = EXPR;</code>, so removing the <code>let</code> keyword would cause grammatical ambiguity. A pattern could be <code>mut x</code> (making the variable binding mutable), it could be <code>(a, b)</code> signifying tuple unpacking, <em>&amp;c.</em></p>\n\n<p>You only think <code>i32 x = 5;</code> makes sense because you\u2019re used to languages like C++. Seriously, who came up with that idea? It makes more sense on purely philosophical grounds to have the type after the name than before, and having just the type to declare variables is silly too. All sorts of grammatical ambiguity there. Type inference, allowing you to omit the type altogether, is a much nicer approach all round.</p>\n"}, {"tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 9, "last_activity_date": 1440415677, "creation_date": 1440415677, "answer_id": 32181200, "question_id": 32180684, "link": "https://stackoverflow.com/questions/32180684/why-does-rust-bother-with-let/32181200#32181200", "title": "Why does Rust bother with &quot;let&quot;?", "body": "<p>It significantly simplifies the grammar. Remember, there's a full pattern on the left hand side, it's not actually <code>let var</code> it's <code>let pattern</code>.</p>\n\n<blockquote>\n  <p>how can one declare a several variables of the same type in Rust?</p>\n</blockquote>\n\n<p>This is a completely different question, but there's no direct way to do this, no, at least not in the way you're thinking of. You can</p>\n\n<pre><code>let (a, b, c) = (1, 2, 3);\n</code></pre>\n\n<p>But they don't <em>have</em> to be of the same type, this is a destructuring pattern in action.</p>\n"}, {"comments": [{"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440416515, "post_id": 32181229, "comment_id": 52248194, "body": "I don&#39;t fully understand what you are trying to say in the final paragraph. When I write programs, I know whether my data is an integer, a pointer, a floating point value, a char, a std::vector, etc, etc... I would probably say it&#39;s not possible to write code unless you know about what format your data is to be stored in. That&#39;s the whole point about programming - to manipulate data, so if you &quot;don&#39;t know&quot; what your data looks like then you&#39;d better figure it out before you start typing!"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 3, "creation_date": 1440419113, "post_id": 32181229, "comment_id": 52249848, "body": "@user3728501 I know what my data looks like. Fortunately, in that I am not fully constrained by the machine and can think more abstractly: I can know that something is an integer without already making up my mind whether it&#39;s <code>u32</code> or <code>u64</code>. I can know that I want to look up the users for all the user IDs without caring that the result type of <code>items.iter().map(User::lookup)</code> is <code>iter::Map&lt;slice::Iter&lt;u32&gt;, fn(u32) -&gt; User&gt;</code>. And even if I need to know these things at some point, I don&#39;t need to know <i>at all times</i> and push it into the face of every reader."}, {"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440419215, "post_id": 32181229, "comment_id": 52249909, "body": "I would suggest that is poor practice - you will make mistakes if you&#39;re not aware at all times what your data is stored as and how it will behave."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 1, "creation_date": 1440419356, "post_id": 32181229, "comment_id": 52250002, "body": "@user3728501 So you are opposed to type inference as well?"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440419587, "post_id": 32181229, "comment_id": 52250148, "body": "@user3728501 Regardless, we are now arguing about the thought process of the author when writing code. A more important point, to me, is whether it makes sense to the <i>reader</i>. Is &quot;Here&#39;s the amount of space to allocate, as <code>usize</code>&quot; really more sensibe, semantically, then &quot;Here&#39;s some <code>usize</code> that stores the amount of space to allocate&quot;?"}, {"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440420481, "post_id": 32181229, "comment_id": 52250802, "body": "Type inference could be useful if there is no ambiguity. But generally I think programming languages are better without it. Without inference you have to be specific, and know exactly what you are doing - so I would probably say yes, although I don&#39;t really have a strong opinion about it, I think no type inference is slightly better than having type inference."}, {"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440420541, "post_id": 32181229, "comment_id": 52250845, "body": "Why are you only interested in the reader? Of what use is code which can be read easily and not written easily? A person isn&#39;t useful as a translator if they can read French but not speak or write it."}, {"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440420627, "post_id": 32181229, "comment_id": 52250895, "body": "Surely <code>int a = 32</code> is easier to read and write than <code>a int = 32</code>. The second makes <i>no sense what so ever</i> because it looks like you are assigning the value <code>32</code> to <code>int</code> - why? Because <code>int</code> is the other side of the <code>=</code> sign, of course... The second only makes some sense if you add a colon: (Or other symbol) eg: <code>a: int = 32</code>, because the colon makes it look like you are adding some extra information there."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 1, "creation_date": 1440430549, "post_id": 32181229, "comment_id": 52257856, "body": "@user3728501 Of course writing needs to be possible. But we&#39;re talking about (what you perceive to be) a slight loss in write-ability, for a slight win in readability. The fact that it will be read more often than written makes this a good trade off. RE: Last comment: But we <i>do</i> add the colon, and it even has many additional benefits (as explained in this answer). So what&#39;s your point here? And again, consider that the by far most common variable declaration in Rust is <code>let name = value;</code> with no type mentioned."}, {"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440511750, "post_id": 32181229, "comment_id": 52296587, "body": "Why would any code be read more often than it is written or modified? I would suggest the opposite is true - I modify my code all the time - I hardly ever &quot;read it&quot;, and few others read it in my line of work. Even as a software developer, I would suggest unless you are in a specific roll writing generic code, you code will be written many more times than being read."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440520782, "post_id": 32181229, "comment_id": 52302897, "body": "@user3728501 This is turning into a discussion that exceeds the scope of a comment chain (and Stack Overflow in general), so I&#39;ll refer you to Google to find some of the many essays arguing that &quot;code is read more often than it is written&quot;. I have neither the time nor the space to reproduce all the arguments here."}, {"owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440524860, "post_id": 32181229, "comment_id": 52305217, "body": "There are essays on such a topic? Please show me"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "edited": false, "score": 0, "creation_date": 1440528402, "post_id": 32181229, "comment_id": 52307294, "body": "More like blog posts, I suppose. Google finds plenty of support for the position in any case. It appears your line of work is simply very unusual."}], "tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "is_accepted": false, "score": 13, "last_activity_date": 1446748366, "last_edit_date": 1446748366, "creation_date": 1440415783, "answer_id": 32181229, "question_id": 32180684, "link": "https://stackoverflow.com/questions/32180684/why-does-rust-bother-with-let/32181229#32181229", "title": "Why does Rust bother with &quot;let&quot;?", "body": "<p>First, parsing ambiguity. While it <em>may</em> be possible to parse such code (but only because <code>a &lt; b &gt; c</code> is already illegal as expression for a different reason), it would complicate all tooling and make parser performance (and error recovery) worse.</p>\n\n<p>Second, type inference. Regardless of where the type is written, it can be omitted, so you need <code>let</code> or another marker to distinguish assignment from declaration. (You could technically use <code>let x = ...;</code> and <code>Type x = ...;</code> but why? It's not a type, it's the <em>absence</em> of a type.)</p>\n\n<p>Third, generality. <code>let</code> works with any (irrefutable) pattern, including those that double as perfectly legal expressions: <code>StructLiteral { field: x, other_field: y }</code> and <code>Some(thing)</code>. This is a source of even more ambiguity, if not for the parser (it rejects <code>Some(a) = b</code> currently), then for humans.</p>\n\n<p>Fourth, while <em>you</em> may be used to <code>type name</code>, there is a long tradition of <code>name: type</code>, and it's gaining mainstream traction without Rust's doing (e.g. in Scala).</p>\n\n<p>Fifth, I dispute this:</p>\n\n<blockquote>\n  <p>When programming you usually know what \"type\" of data you want before you think of a name for it.</p>\n</blockquote>\n\n<p>Perhaps I know the general shape of the data (an integer, a string, an iterator, a set, etc.) but the exact type is often an implementation detail that comes second. This argument also falls apart in the face of type inference: How can leaving the type out be useful if that's what you are mostly thinking in? If on the other hand you're only talking about what you think of first while <em>writing</em> code, then the case is dismissed: Code is read far more often than it is written, and the order in which concepts are introduced need not (and often shouldn't) reflect the order in which they are conceived.</p>\n"}], "owner": {"reputation": 9704, "user_id": 893254, "user_type": "registered", "accept_rate": 30, "profile_image": "https://www.gravatar.com/avatar/e4417c43fd253cd5b52e2dd709e34b44?s=128&d=identicon&r=PG&f=1", "display_name": "FreelanceConsultant", "link": "https://stackoverflow.com/users/893254/freelanceconsultant"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3815, "favorite_count": 2, "closed_date": 1440421714, "answer_count": 3, "score": 9, "last_activity_date": 1446748366, "creation_date": 1440414063, "last_edit_date": 1446747266, "question_id": 32180684, "link": "https://stackoverflow.com/questions/32180684/why-does-rust-bother-with-let", "closed_reason": "Opinion-based", "title": "Why does Rust bother with &quot;let&quot;?", "body": "<p>I was interested in Rust, and so I started reading the Rust programming guide on the Rust website, and discovered that variables are declared in the following manner:</p>\n\n<pre><code>let x: i32 = 5;\n</code></pre>\n\n<p>Which means assign the value integer 5 to the variable type integer 32 bit which shall be referred to by the notation <code>x</code> from this point onwards.</p>\n\n<p>My main question is why is the <code>let</code> keyword is there at all? It seems redundant, as if it doesn't actually \"do\" anything.</p>\n\n<p>I assume the compiler would be able to tell that the following is a variable (or const variable) declaration:</p>\n\n<pre><code>x: i32 = 5;\n</code></pre>\n\n<p>There doesn't appear to be a reason for a <code>let</code> keyword, but presumably there <em>is</em> a smart reason because Rust is focused on safety. So what is that reason?</p>\n\n<hr>\n\n<p>Edit: Addition: As function arguments, the let keyword is not required. Here is an example:</p>\n\n<pre><code>fn add1(x: i32) -&gt; i32\n{\n    x = x + 1\n}\n</code></pre>\n\n<p>This seems a bit strange - this \"looks like\" a pass by reference because of the missing <code>let</code>. But it's not. It's a pass by value. (Or at least I think it is.) Is this a syntactic inconsistency?</p>\n\n<hr>\n\n<p>As an aside, I would find it a lot more logical to change this statement around and write:</p>\n\n<pre><code>i32 x = 5;\n</code></pre>\n\n<p>Put a colon in there if you will:</p>\n\n<pre><code>i32: x = 5;\n</code></pre>\n\n<p>I guess I would find that more logical because:</p>\n\n<ul>\n<li>When programming you usually know what \"type\" of data you want before you think of a name for it.</li>\n</ul>\n\n<p>Perhaps some think the other way around? But this brings me to another point; how can one declare a several variables of the same type in Rust? Such as:</p>\n\n<pre><code>let x, y, z: i32 = {4, 5, 5} // A guess of what this might look like?\n</code></pre>\n\n<p>Or is this just not allowed in Rust?</p>\n"}, {"tags": ["vector", "iterator", "rust", "clone", "ownership"], "answers": [{"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440403819, "post_id": 32176037, "comment_id": 52240349, "body": "I&#39;d say that the first option is <i>the</i> idiomatic solution. The second option will result to extra 10000 allocations because the range will be run through twice."}, {"owner": {"reputation": 26037, "user_id": 542190, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c3bb1f122c476561bb9a98a1523e8b5e?s=128&d=identicon&r=PG", "display_name": "filmor", "link": "https://stackoverflow.com/users/542190/filmor"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 2, "creation_date": 1440405633, "post_id": 32176037, "comment_id": 52241354, "body": "But the first one will allocate all memory at once, depending on the amount of files that might not be so nice either."}, {"owner": {"reputation": 871, "user_id": 4992066, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/145b27b5b5512cff0cabf303fdcb4920?s=128&d=identicon&r=PG", "display_name": "swiesend", "link": "https://stackoverflow.com/users/4992066/swiesend"}, "edited": false, "score": 0, "creation_date": 1440431414, "post_id": 32176037, "comment_id": 52258444, "body": "Thank you for your solutions and comments! Would it be a valuable approach to create a macro to avoid the double allocation from option 2 like this? <code>macro_rules! files_vec {     ( $range:expr ) =&gt; {         $range.map(|x| x.to_string() + file_ext).collect()     } }</code> which is quite inflexible, but pre compiled"}], "tags": [], "owner": {"reputation": 26037, "user_id": 542190, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c3bb1f122c476561bb9a98a1523e8b5e?s=128&d=identicon&r=PG", "display_name": "filmor", "link": "https://stackoverflow.com/users/542190/filmor"}, "is_accepted": true, "score": 5, "last_activity_date": 1440399074, "creation_date": 1440399074, "answer_id": 32176037, "question_id": 32175475, "link": "https://stackoverflow.com/questions/32175475/use-of-moved-value-which-is-non-copyable-e0382-e0277/32176037#32176037", "title": "use of moved value, which is non-copyable [E0382] [E0277]", "body": "<p>Rust iterators are only forward iterators, as far as I understand, so they can only be iterated once. You can either <code>collect</code> them into a vector or use a function to generate your iterator:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>// 1st option\nlet files: Vec&lt;_&gt; = (0..10000).map(|x| x.to_string() + file_ext).collect();\n\nfor f in &amp;files { ... } // Borrow `files`\n\n// 2nd option\nlet files = || (0..10000).map(|x| x.to_string() + file_ext);\n\nfor f in files() { ... } // Call the closure to get an iterator\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 871, "user_id": 4992066, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/145b27b5b5512cff0cabf303fdcb4920?s=128&d=identicon&r=PG", "display_name": "swiesend", "link": "https://stackoverflow.com/users/4992066/swiesend"}, "edited": false, "score": 0, "creation_date": 1440428605, "post_id": 32182765, "comment_id": 52256536, "body": "Thank you for your explanation! As you point out my code makes more sense not to have an iterator and thus I accepted the answer from @filmor."}], "tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": false, "score": 0, "last_activity_date": 1440420533, "creation_date": 1440420533, "answer_id": 32182765, "question_id": 32175475, "link": "https://stackoverflow.com/questions/32175475/use-of-moved-value-which-is-non-copyable-e0382-e0277/32182765#32182765", "title": "use of moved value, which is non-copyable [E0382] [E0277]", "body": "<p>There are several problems here.</p>\n\n<p>The first is that calling</p>\n\n<pre><code>for f in files { ... }\n</code></pre>\n\n<p>will take <code>files</code> by value. This is avoidable by taking a reference instead:</p>\n\n<pre><code>for f in &amp;files { ... }\n</code></pre>\n\n<p>because <code>(&amp;foo).into_iter()</code> effectively resolves to <code>foo.iter()</code>.</p>\n\n<hr>\n\n<p>The second is that <code>files</code> must be <code>mut</code>, and the reference <code>&amp;mut</code> if you are iterating an iterator. If you had some vector, it would make sense to iterate <code>&amp;my_vector</code> - you can iterate it without modifying it. However, if you have an iterator itself, the state is kept and updated in the iterator itself.</p>\n\n<pre><code>let mut files = (0..10000).map(|x| x.to_string() + file_ext);\n\nfor file in &amp;mut files {\n    create_hardlink(&amp;file);\n}\n\nfor file in files {\n    fs::remove_file(&amp;file);\n}\n</code></pre>\n\n<hr>\n\n<p>The third is that even if you did these things, since you are using a single iterator, you can only iterate each element once! The second loop will be empty. This is the problem @filmor offers solutions for.</p>\n"}], "owner": {"reputation": 871, "user_id": 4992066, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/145b27b5b5512cff0cabf303fdcb4920?s=128&d=identicon&r=PG", "display_name": "swiesend", "link": "https://stackoverflow.com/users/4992066/swiesend"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 627, "favorite_count": 0, "accepted_answer_id": 32176037, "answer_count": 2, "score": 2, "last_activity_date": 1440427275, "creation_date": 1440396638, "last_edit_date": 1440427275, "question_id": 32175475, "link": "https://stackoverflow.com/questions/32175475/use-of-moved-value-which-is-non-copyable-e0382-e0277", "title": "use of moved value, which is non-copyable [E0382] [E0277]", "body": "<p>I have an ownership problem which I don't understand well. Basically I try to create some hardlinks on my file system and to remove them after being created. Therefore I created a range of integers which I map to the actual file names I like to create and destroy. My naive solution looks like this:</p>\n\n<pre><code>use std::fs;\n\nconst src_file: &amp;'static str = \"a.txt\";\nconst file_ext: &amp;'static str = \".txt\";\n\nfn create_hardlink(dest_file: &amp;str) {\n    fs::hard_link(&amp;src_file, &amp;dest_file);\n}\n\nfn main() {\n\n    let create = (0..10000).map(|x| x.to_string() + file_ext);\n    let remove = (0..10000).map(|x| x.to_string() + file_ext);\n\n    for file in create {\n        create_hardlink(&amp;file);\n    }\n\n    for file in remove {\n        fs::remove_file(&amp;file);\n    }\n}\n</code></pre>\n\n<p>But what I actually like to accomplish is a solution, where I don't have to repeat my self for creating the static collection with the file-names and can reuse <code>files</code> for a second for-loop:</p>\n\n<pre><code>...\n\nfn main() {\n\n    let files = (0..10000).map(|x| x.to_string() + file_ext);\n\n    for file in files {\n        create_hardlink(&amp;file);\n    }\n\n    for file in files {\n        fs::remove_file(&amp;file);\n    }\n}\n</code></pre>\n\n<p>So when I try this the compiler complains, that the second usage of <code>files</code> is not possible,</p>\n\n<pre><code>src/main.rs:20:17: 20:22 error: use of moved value: `files` [E0382]\nsrc/main.rs:20     for file in files {\n</code></pre>\n\n<p>because <code>files</code> already moved into the first for-loop: </p>\n\n<pre><code>src/main.rs:16:17: 16:22 note: `files` moved here because it has type `core::iter::Map&lt;core::ops::Range&lt;i32&gt;, [closure@src/main.rs:14:36: 14:64]&gt;`, which is non-copyable\n</code></pre>\n\n<p>after reading the explanation for <code>rustc --explain E0382</code> I decided to change the code as follows:</p>\n\n<pre><code>...\n\nfn main() {\n\n    let files = Rc::new(RefCell::new((0..10000).map(|x| x.to_string() + file_ext)));\n\n    for file in files.clone() {\n        create_hardlink(&amp;file);\n    }\n\n    for file in files.clone() {\n        fs::remove_file(&amp;file);\n    }\n}\n</code></pre>\n\n<p>But this does not work as expected to me:</p>\n\n<pre><code>src/main.rs:16:5: 18:6 error: the trait `core::iter::Iterator` is not implemented for the type `alloc::rc::Rc&lt;core::cell::RefCell&lt;core::iter::Map&lt;core::ops::Range&lt;_&gt;, [closure@src/main.rs:14:53: 14:81]&gt;&gt;&gt;` [E0277]\nsrc/main.rs:16     for file in files.clone() {\nsrc/main.rs:17         create_hardlink(&amp;file);\nsrc/main.rs:18     }\nnote: in expansion of for loop expansion\nsrc/main.rs:16:5: 18:6 note: expansion site\nsrc/main.rs:16:5: 18:6 help: run `rustc --explain E0277` to see a detailed explanation\nsrc/main.rs:16:5: 18:6 note: `alloc::rc::Rc&lt;core::cell::RefCell&lt;core::iter::Map&lt;core::ops::Range&lt;_&gt;, [closure@src/main.rs:14:53: 14:81]&gt;&gt;&gt;` is not an iterator; maybe try calling `.iter()` or a similar method\nsrc/main.rs:16     for file in files.clone() {\nsrc/main.rs:17         create_hardlink(&amp;file);\nsrc/main.rs:18     }\nnote: in expansion of for loop expansion\nsrc/main.rs:16:5: 18:6 note: expansion site\nsrc/main.rs:16:5: 18:6 note: required by `core::iter::IntoIterator::into_iter`\nsrc/main.rs:16     for file in files.clone() {\nsrc/main.rs:17         create_hardlink(&amp;file);\nsrc/main.rs:18     }\n</code></pre>\n\n<p>What can I do? Do I really have to implement the <code>core::iter::Iterator</code> for the type <code>alloc::rc::Rc&lt;core::cell::RefCell&lt;core::iter::Map&lt;core::ops::Range&lt;_&gt;</code> like <code>rustc --explain E0277</code> is telling me? I hope not...</p>\n\n<p>Is there a simple solution like defining <code>files</code> statically as <code>static</code>or as <code>const</code>? Or is my approach with mapping a <code>Range</code> non rusty?</p>\n\n<p>Why do I have a type like <code>&lt;core::iter::Map&lt;core::ops::Range&lt;_&gt;</code> and not something like <code>&lt;core::iter::String&gt;</code>?</p>\n\n<p>I hope you can help me out with that and enlighten a bit the Rust ownership principle to a novice like me.</p>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 2106, "user_id": 916384, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/38055799f271a72b7d50d91c322ce561?s=128&d=identicon&r=PG", "display_name": "franza", "link": "https://stackoverflow.com/users/916384/franza"}, "edited": false, "score": 0, "creation_date": 1440375095, "post_id": 32172819, "comment_id": 52231943, "body": "Thanks, that works. But can you please explain why <code>map</code> outlives <code>s</code>? I thought that variables are destructed at the end of scope, so is there any specific order of destruction?"}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 2106, "user_id": 916384, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/38055799f271a72b7d50d91c322ce561?s=128&d=identicon&r=PG", "display_name": "franza", "link": "https://stackoverflow.com/users/916384/franza"}, "edited": false, "score": 4, "creation_date": 1440375418, "post_id": 32172819, "comment_id": 52232003, "body": "&quot;is there any specific order of destruction&quot; \u2192 The opposite to the order of construction, because if you have <code>let x = 1; let y = T(&amp;x);</code>, the destructor of <code>y</code> might need to access <code>x</code>."}, {"owner": {"reputation": 2106, "user_id": 916384, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/38055799f271a72b7d50d91c322ce561?s=128&d=identicon&r=PG", "display_name": "franza", "link": "https://stackoverflow.com/users/916384/franza"}, "edited": false, "score": 0, "creation_date": 1440404598, "post_id": 32172819, "comment_id": 52240767, "body": "Oh, I see. I think this is because those vars are allocated in stack."}], "tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 9, "last_activity_date": 1554601518, "last_edit_date": 1554601518, "creation_date": 1440374816, "answer_id": 32172819, "question_id": 32172780, "link": "https://stackoverflow.com/questions/32172780/hashmap-key-does-not-live-long-enough/32172819#32172819", "title": "HashMap key does not live long enough", "body": "<p>This issue was solved with <a href=\"https://stackoverflow.com/q/50251487/155423\">non-lexical lifetimes</a>, and should not be a concern from Rust 2018 onwards. The answer below is relevant for people using older versions of Rust.</p>\n\n<hr>\n\n<p><code>map</code> outlives <code>s</code>, so at some point in <code>map</code>'s life (just before destruction), <code>s</code> will be invalid. This is solvable by switching their order of construction, and thus of destruction:</p>\n\n<pre><code>let s = Struct;\nlet mut map: HashMap&lt;String, &amp;Trait&gt; = HashMap::new();\nmap.insert(\"key\".to_string(), &amp;s);\n</code></pre>\n\n<p>If you instead want the <code>HashMap</code> to own the references, use owned pointers:</p>\n\n<pre><code>let mut map: HashMap&lt;String, Box&lt;Trait&gt;&gt; = HashMap::new();\nlet s = Struct;\nmap.insert(\"key\".to_string(), Box::new(s));\n</code></pre>\n"}], "owner": {"reputation": 2106, "user_id": 916384, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/38055799f271a72b7d50d91c322ce561?s=128&d=identicon&r=PG", "display_name": "franza", "link": "https://stackoverflow.com/users/916384/franza"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 732, "favorite_count": 0, "accepted_answer_id": 32172819, "answer_count": 1, "score": 5, "last_activity_date": 1554601518, "creation_date": 1440374409, "last_edit_date": 1554585875, "question_id": 32172780, "link": "https://stackoverflow.com/questions/32172780/hashmap-key-does-not-live-long-enough", "title": "HashMap key does not live long enough", "body": "<p>I'm trying to use a <code>HashMap&lt;String, &amp;Trait&gt;</code> but I have an error message I don't understand. Here's the code (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=e32245dbee9b3c209fe473bc1741316a\" rel=\"nofollow noreferrer\">playground</a>):</p>\n\n<pre><code>use std::collections::HashMap;\n\ntrait Trait {}\n\nstruct Struct;\n\nimpl Trait for Struct {}\n\nfn main() {\n    let mut map: HashMap&lt;String, &amp;Trait&gt; = HashMap::new();\n    let s = Struct;\n    map.insert(\"key\".to_string(), &amp;s);\n}\n</code></pre>\n\n<p>Here's the error I'm getting:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0597]: `s` does not live long enough\n  --&gt; src/main.rs:12:36\n   |\n12 |     map.insert(\"key\".to_string(), &amp;s);\n   |                                    ^ borrowed value does not live long enough\n13 | }\n   | - `s` dropped here while still borrowed\n   |\n   = note: values in a scope are dropped in the opposite order they are created\n</code></pre>\n\n<p>What's happening here? Is there a workaround?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1794, "user_id": 165780, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/3bc15548fe06e6ee25a25a6bdcc040d5?s=128&d=identicon&r=PG", "display_name": "Augusto Hack", "link": "https://stackoverflow.com/users/165780/augusto-hack"}, "edited": false, "score": 0, "creation_date": 1440375046, "post_id": 32172692, "comment_id": 52231933, "body": "thanks for the answer. Since growing the vec also uses unsafe code, what approach do you recomend?"}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 1794, "user_id": 165780, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/3bc15548fe06e6ee25a25a6bdcc040d5?s=128&d=identicon&r=PG", "display_name": "Augusto Hack", "link": "https://stackoverflow.com/users/165780/augusto-hack"}, "edited": false, "score": 2, "creation_date": 1440375522, "post_id": 32172692, "comment_id": 52232025, "body": "I recommend <code>Vec.resize(capacity, 0)</code>, since it&#39;s safe and easy. Only move to the unsafe variants if you really need the absolute maximum speed."}], "tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 5, "last_activity_date": 1440373715, "creation_date": 1440373715, "answer_id": 32172692, "question_id": 32172187, "link": "https://stackoverflow.com/questions/32172187/take-a-mutable-slice-from-a-vector-with-a-different-length/32172692#32172692", "title": "Take a mutable slice from a vector with a different length?", "body": "<p>If one was to just take a slice of the capacity, you would have a slice of uninitialized data. This is unsafe.</p>\n\n<p>You <em>can</em> do this with <code>Vec</code>'s <code>set_len</code>. However</p>\n\n<ul>\n<li><p>This is unsafe. Reading the data is memory safe, but a vector of another type, or misuse of <code>set_len</code>, may not be. Overflow checking and proper cleanup is important.</p></li>\n<li><p>This could well be a significant security flaw.</p></li>\n<li><p>If you are using non-primitive types, you need to consider panic safety.</p></li>\n<li><p><a href=\"https://github.com/rust-lang/rust/pull/23668\" rel=\"noreferrer\">The standard library has a policy against allowing reads to uninitialized memory, even if memory-safe.</a></p></li>\n</ul>\n\n<p>The basic way of doing this is</p>\n\n<pre><code>unsafe {\n    buffer.set_len(buffer.capacity());\n    let new_len = try!(r.read(slice));\n    buffer.set_len(cmp::min(buffer.len(), new_len));\n}\n</code></pre>\n\n<p>The <code>cmp::min</code> is needed if you don't totally trust <code>read</code>'s implementation, since incorrect output can result in too-large set length.</p>\n"}, {"tags": [], "owner": {"reputation": 1794, "user_id": 165780, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/3bc15548fe06e6ee25a25a6bdcc040d5?s=128&d=identicon&r=PG", "display_name": "Augusto Hack", "link": "https://stackoverflow.com/users/165780/augusto-hack"}, "is_accepted": false, "score": 0, "last_activity_date": 1440838022, "last_edit_date": 1440838022, "creation_date": 1440392433, "answer_id": 32174729, "question_id": 32172187, "link": "https://stackoverflow.com/questions/32172187/take-a-mutable-slice-from-a-vector-with-a-different-length/32174729#32174729", "title": "Take a mutable slice from a vector with a different length?", "body": "<p>I want to add three details to @Veedrac answer.</p>\n\n<p>1 - This is the relevant code that creates the slices from <code>Vec&lt;T&gt;</code>, and in both cases the slice goes from the start of the vector up to <code>self.len</code>:</p>\n\n<p><a href=\"https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src/libcollections/vec.rs#L1131-L1142\" rel=\"nofollow\">fn deref(&amp;self) -> &amp;[T]</a></p>\n\n<p><a href=\"https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src/libcollections/vec.rs#L1144-L1153\" rel=\"nofollow\">fn deref_mut(&amp;mut self) -> &amp;mut [T]</a></p>\n\n<p>2 - There is an <a href=\"https://github.com/rust-lang/rust/blob/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src/libstd/sys/common/io.rs#L16-L52\" rel=\"nofollow\">optimization in the TcpStream</a> to avoid zeroing the memory, much like @Veedrac's alternative, but it is only used for <code>read_to_end</code> and not in <code>read</code>. And the <code>BufReader</code> that does zeroing starts with small allocations for <a href=\"http://github.com/rust-lang/rust/issues/23815\" rel=\"nofollow\">performance reasons</a></p>\n\n<p>3 - The slice has no information about the vector size, so the vector the length must be updated anyways, otherwise the buffer will be larger than the data and the zeros will be used.</p>\n"}], "owner": {"reputation": 1794, "user_id": 165780, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/3bc15548fe06e6ee25a25a6bdcc040d5?s=128&d=identicon&r=PG", "display_name": "Augusto Hack", "link": "https://stackoverflow.com/users/165780/augusto-hack"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1070, "favorite_count": 0, "accepted_answer_id": 32172692, "answer_count": 2, "score": 4, "last_activity_date": 1440838022, "creation_date": 1440368996, "question_id": 32172187, "link": "https://stackoverflow.com/questions/32172187/take-a-mutable-slice-from-a-vector-with-a-different-length", "title": "Take a mutable slice from a vector with a different length?", "body": "<p>I'm trying to use a vector as a buffer <a href=\"https://github.com/hyperium/hyper/blob/master/src/buffer.rs#L53-L66\" rel=\"nofollow\">like this</a>, I'm wondering if there is a way to take a slice from the vector without <a href=\"https://github.com/hyperium/hyper/blob/master/src/buffer.rs#L23-L25\" rel=\"nofollow\">growing it</a>, so that code like this work:</p>\n\n<pre><code>fn example(r: Read) {\n    let buffer: Vec&lt;u8&gt; = Vec::with_capacity(1024);\n    let slice: &amp;mut[u8] = &amp;mut buffer;\n    r.read(slice); // doesnt work since the slice has length zero\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1440359746, "post_id": 32170625, "comment_id": 52228240, "body": "A vector of bits is an awfully inefficient representation. Consider writing accessor methods that operate on your <code>Vec&lt;u32&gt;</code> (or whatever), accessing and setting individual bits of the digits. That assumes your digits are bundles of bits rather than decimal digits, but honestly there is rarely a good reason to <i>not</i> do that."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440361280, "post_id": 32170625, "comment_id": 52228664, "body": "@delnan I assumed that OP wasn&#39;t worried about maximum efficiency here, but was mostly using this as a learning exercise. Otherwise, I&#39;d assume that there&#39;s a arbitrary precision library available that could be used (but I haven&#39;t looked). However, the description of the question could be clarified."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1440363369, "post_id": 32170625, "comment_id": 52229248, "body": "@Shepmaster The change I propose is not a very complicated one, though, and it easily saves a factor of eight in memory (and for many algorithms, the associated increase in cache hits will be pretty big as well)."}], "answers": [{"tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": false, "score": 2, "last_activity_date": 1440374511, "creation_date": 1440374511, "answer_id": 32172792, "question_id": 32170625, "link": "https://stackoverflow.com/questions/32170625/convert-vector-of-single-integers-into-vector-of-single-binary-values/32172792#32172792", "title": "Convert vector of single integers into vector of single binary values", "body": "<p>The most obvious way is to generate some abstract operations.</p>\n\n<pre><code>fn add_binary_fixed(left: &amp;mut Vec&lt;u8&gt;, right: u8);\nfn multiply_binary_fixed(binary_value: &amp;mut Vec&lt;u8&gt;, by: u8);\n</code></pre>\n\n<p>Then one can do</p>\n\n<pre><code>let mut binary_value = vec![0];\nfor decimal_digit in decimal_value {\n    multiply(binary_value, 10);\n    add(binary_value, decimal_digit);\n}\nbinary_value\n</code></pre>\n\n<p>If one uses traits and proper types, this can generalize to any (bounded, natural numbered) base conversion:</p>\n\n<pre><code>fn convert(value: &amp;LargeInteger, base: u8) -&gt; LargeInteger {\n    let mut output = LargeInteger::new(base);\n    for digit in value {\n        output.multiply(base);\n        output.add(digit);\n    }\n    output\n}\n</code></pre>\n"}], "owner": {"reputation": 15257, "user_id": 1409312, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/4TCzB.jpg?s=128&g=1", "display_name": "Syntactic Fructose", "link": "https://stackoverflow.com/users/1409312/syntactic-fructose"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 366, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1440374511, "creation_date": 1440357988, "last_edit_date": 1440373868, "question_id": 32170625, "link": "https://stackoverflow.com/questions/32170625/convert-vector-of-single-integers-into-vector-of-single-binary-values", "title": "Convert vector of single integers into vector of single binary values", "body": "<p>If I have a vector that represents some arbitrarily big numbers, <code>big_v</code>, I want to be able to convert this vector into a vector that holds the binary representation of <code>big_v</code> as well in order to implement a division algorithm. So say </p>\n\n<pre><code>let big_v = vec![1,3,9];        // 139\nlet big_binary_v = func(big_v); // 10001011\n</code></pre>\n\n<p><code>big_binary_v</code>'s value would be the equivalent of <code>[1,0,0,0,1,0,1,1]</code>. </p>\n\n<hr>\n\n<p>This trick is that I could implement this easy if it weren't for the fact that the vector can represent an arbitrarily large integer , if not I could simply do <code>binary(100) + binary(30) + binary(9)</code>. In the case that you have a number like <code>100000000000000001</code> however, you can't compute <code>binary(100000000000000000) + binary(1)</code>. Is there any trick to convert this vector to binary without using size dependent operations?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1440335080, "post_id": 32166202, "comment_id": 52220633, "body": "This is described pretty well in <a href=\"http://doc.rust-lang.org/stable/book\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i></a>, specifically the chapter titled &quot;<a href=\"http://doc.rust-lang.org/stable/book/casting-between-types.html\" rel=\"nofollow noreferrer\">Casting Between Types</a>&quot;."}], "answers": [{"tags": [], "owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "is_accepted": false, "score": 6, "last_activity_date": 1440329788, "creation_date": 1440329788, "answer_id": 32166228, "question_id": 32166202, "link": "https://stackoverflow.com/questions/32166202/how-to-cast-primitive-types/32166228#32166228", "title": "How to cast primitive types?", "body": "<p>You're looking for the <a href=\"https://doc.rust-lang.org/book/casting-between-types.html#as\"><code>as</code> keyword</a>:</p>\n\n<pre><code>let x: i32 = 5;\nlet y: u32 = x as u32;\n</code></pre>\n"}], "owner": {"reputation": 341, "user_id": 4407799, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/c741afb406509f1b64422fd5fa3879b3?s=128&d=identicon&r=PG&f=1", "display_name": "\u4e60\u660e\u660a", "link": "https://stackoverflow.com/users/4407799/%e4%b9%a0%e6%98%8e%e6%98%8a"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 227, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1440334138, "creation_date": 1440329646, "last_edit_date": 1440334138, "question_id": 32166202, "link": "https://stackoverflow.com/questions/32166202/how-to-cast-primitive-types", "title": "How to cast primitive types?", "body": "<p>How should I  cast primitive types in Rust?</p>\n\n<p>In C-derived languages, one normally does</p>\n\n<pre><code>    int i = 0;\n    long j = (long)i;\n</code></pre>\n\n<p>This does not work in Rust. What should I use instead?</p>\n"}, {"tags": ["rust", "reference", "covariance", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 2922, "user_id": 929981, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/66Mz4.png?s=128&g=1", "display_name": "jtepe", "link": "https://stackoverflow.com/users/929981/jtepe"}, "edited": false, "score": 0, "creation_date": 1440341197, "post_id": 32167082, "comment_id": 52222488, "body": "I get it. Inside the body of the create function the picked lifetime will be the scope of 2-3, since from the set of supplied concrete lifetimes, it will be the only one that matches the constraint. As a result it will be the lifetime &#39;a of the created VecRefRef&lt;&#39;a&gt;."}, {"owner": {"reputation": 3480, "user_id": 2686821, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/5dd46afe4f5a75f2667569582b20ac9b?s=128&d=identicon&r=PG&f=1", "display_name": "soupybionics", "link": "https://stackoverflow.com/users/2686821/soupybionics"}, "edited": false, "score": 0, "creation_date": 1529034369, "post_id": 32167082, "comment_id": 88739449, "body": "<i>Note that you have to use the syntax <code>&#39;b : &#39;a</code> to denote that the lifetime <code>&#39;a</code> will outlive <code>&#39;b.</code></i> \u2014 Shouldn&#39;t it be   &quot;... denote that the lifetime <code>&#39;b</code> will outlive <code>&#39;a</code>.&quot; ?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 6, "last_activity_date": 1529067712, "last_edit_date": 1529067712, "creation_date": 1440335979, "answer_id": 32167082, "question_id": 32165917, "link": "https://stackoverflow.com/questions/32165917/why-does-linking-lifetimes-matter-only-with-mutable-references/32167082#32167082", "title": "Why does linking lifetimes matter only with mutable references?", "body": "<blockquote>\n  <p>The mutable reference <code>r</code> inside <code>create()</code> has the lifetime of <code>VecRef&lt;'a&gt;</code> not <code>'a</code></p>\n</blockquote>\n\n<p>This is a common source of confusion. Check this function definition:</p>\n\n<pre><code>fn identity&lt;'a, T&gt;(val: &amp;'a T) -&gt; &amp;'a T { val }\n</code></pre>\n\n<p>In a function definition, <code>'a</code> is a <em>generic</em> lifetime parameter, which parallels a generic type parameter (<code>T</code>). When the function is called, the caller decides what the concrete values of <code>'a</code> and <code>T</code> will be. Let's look back at your <code>main</code>:</p>\n\n<pre><code>fn main() {\n    let v = vec![8u8, 9, 10];   // 1 |-lifetime of `v`\n    let mut ref_v = VecRef(&amp;v); // 2 |  |-lifetime of `ref_v` \n    create(&amp;mut ref_v);         // 3 |  |\n}\n</code></pre>\n\n<p><code>v</code> will live for the entire run of <code>main</code> (1-3), but <code>ref_v</code> only lives for the two final statements (2-3). Note that <code>ref_v</code> <em>refers to</em> a value that outlives it. If you then take a reference to <code>ref_v</code>, you have a reference to something that lives from (2-3) that itself has a reference to something that lives from (1-3).</p>\n\n<p>Check out your fixed method:</p>\n\n<pre><code>fn create&lt;'a&gt;(r: &amp;'a mut VecRef&lt;'a&gt;)\n</code></pre>\n\n<p>This says that <em>for this function call</em>, the reference to the <code>VecRef</code> and the reference it contains must be the same. There is a lifetime that can be picked that satisfies this \u2014 (2-3).</p>\n\n<p>Note that your structure definition currently requires that the two lifetimes be the same. You could allow them to differ:</p>\n\n<pre><code>struct VecRefRef&lt;'a, 'b: 'a&gt;(&amp;'a mut VecRef&lt;'b&gt;);\nfn create&lt;'a, 'b&gt;(r: &amp;'a mut VecRef&lt;'b&gt;)\n</code></pre>\n\n<p>Note that you have to use the syntax <code>'b: 'a</code> to denote that the lifetime <code>'b</code> will outlive <code>'a</code>.</p>\n\n<blockquote>\n  <p>If I use an immutable reference [...], it somehow does not matter any more</p>\n</blockquote>\n\n<p>This I'm less sure about. I believe that what is happening is that because you have an immutable borrow, it's OK for the compiler to reborrow at a smaller scope for you automatically. This allows the lifetimes to match. As you pointed out, a mutable reference cannot have any aliases, even ones with a smaller scope, so the compiler can't help in that case.</p>\n"}, {"comments": [{"owner": {"reputation": 3480, "user_id": 2686821, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/5dd46afe4f5a75f2667569582b20ac9b?s=128&d=identicon&r=PG&f=1", "display_name": "soupybionics", "link": "https://stackoverflow.com/users/2686821/soupybionics"}, "edited": false, "score": 0, "creation_date": 1529231795, "post_id": 32172407, "comment_id": 88791593, "body": "<i>Read prevents <code>&#39;b</code> from growing, since if one was to extract the inner pointer from the outer pointer you would be able to read it after <code>&#39;a</code> has expired.</i> -- Could you please elaborate on this?"}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 3480, "user_id": 2686821, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/5dd46afe4f5a75f2667569582b20ac9b?s=128&d=identicon&r=PG&f=1", "display_name": "soupybionics", "link": "https://stackoverflow.com/users/2686821/soupybionics"}, "edited": false, "score": 0, "creation_date": 1529236483, "post_id": 32172407, "comment_id": 88792608, "body": "@soupybionics I suspect I was wrong about this. Let me get back to you."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 3480, "user_id": 2686821, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/5dd46afe4f5a75f2667569582b20ac9b?s=128&d=identicon&r=PG&f=1", "display_name": "soupybionics", "link": "https://stackoverflow.com/users/2686821/soupybionics"}, "edited": false, "score": 0, "creation_date": 1549554014, "post_id": 32172407, "comment_id": 95951473, "body": "@soupybionics Sorry, I seem to have lost track of your question. I remember looking into it and thinking I was wrong, but I can&#39;t remember the details. I will note that <code>&amp;&#39;static &amp;&#39;b</code> <i>can</i> be cast to <code>&amp;&#39;static &amp;&#39;static</code> which suggests you are right, but I don&#39;t think this is correct. Rather, there is probably an implicit assumption that <code>&#39;b: &#39;a</code>; casting <code>&amp;&#39;a &amp;&#39;b</code> to <code>&amp;&#39;a &amp;&#39;static</code> fails."}], "tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 21, "last_activity_date": 1590772640, "last_edit_date": 1590772640, "creation_date": 1440371166, "answer_id": 32172407, "question_id": 32165917, "link": "https://stackoverflow.com/questions/32165917/why-does-linking-lifetimes-matter-only-with-mutable-references/32172407#32172407", "title": "Why does linking lifetimes matter only with mutable references?", "body": "<blockquote>\n  <p><strong>Warning:</strong> I'm speaking from a level of expertise that I don't really have. Given the length of this post, I'm probably wrong a large number of times.</p>\n</blockquote>\n\n\n\n<blockquote>\n  <p><strong>TL;DR:</strong> Lifetimes of top-level values are covariant. Lifetimes of referenced values are invariant.</p>\n</blockquote>\n\n<h3>Introducing the problem</h3>\n\n<p>You can simplify your example significantly, by replacing <code>VecRef&lt;'a&gt;</code> with <code>&amp;'a mut T</code>.</p>\n\n<p>Further, one should remove <code>main</code>, since it's more complete to talk about the <em>general</em> behaviour of a function than some particular lifetime instantiation.</p>\n\n<p>Instead of <code>VecRefRef</code>'s constructor, let's use this function:</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n</code></pre>\n\n<p>Before we go further, it's important to understand how lifetimes get implicitly cast in Rust. When one assigns a pointer to another explicitly annotated name, lifetime coercion happens. The most obvious thing this allows is shrinking the lifetime of the top-level pointer. As such, this is not a typical move.</p>\n\n<blockquote>\n  <p><strong>Aside:</strong> I say \"explicitly annotated\" because <a href=\"https://stackoverflow.com/questions/32154387/why-is-the-mutable-reference-not-moved-here/32158223#32158223\">in implicit cases like <code>let x = y</code> or <code>fn f&lt;T&gt;(_: T) {}</code>, reborrowing doesn't seem to happen</a>. It is not clear whether this is intended.</p>\n</blockquote>\n\n<p>The full example is then</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a, 'b&gt;(reference: &amp;'a mut &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>which gives the same error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0623]: lifetime mismatch\n --&gt; src/main.rs:5:26\n  |\n4 |     fn use_ref_ref&lt;'a, 'b&gt;(reference: &amp;'a mut &amp;'b mut ()) {\n  |                                       ------------------\n  |                                       |\n  |                                       these two types are declared with different lifetimes...\n5 |         use_same_ref_ref(reference);\n  |                          ^^^^^^^^^ ...but data from `reference` flows into `reference` here\n</code></pre>\n\n<h3>A trivial fix</h3>\n\n<p>One can fix it by doing</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a&gt;(reference: &amp;'a mut &amp;'a mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>since the signatures are now logically the same. However, what is not obvious is why</p>\n\n<pre><code>let mut val = ();\nlet mut reference = &amp;mut val;\nlet ref_ref = &amp;mut reference;\n\nuse_ref_ref(ref_ref);\n</code></pre>\n\n<p>is able to produce an <code>&amp;'a mut &amp;'a mut ()</code>.</p>\n\n<h3>A less trivial fix</h3>\n\n<p>One can instead enforce <code>'a: 'b</code></p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a: 'b, 'b&gt;(reference: &amp;'a mut &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>This means that the lifetime of the outer reference is <em>at least</em> as large as the lifetime of the inner one.</p>\n\n<p>It's not obvious</p>\n\n<ul>\n<li><p>why <code>&amp;'a mut &amp;'b mut ()</code> is not castable to <code>&amp;'c mut &amp;'c mut ()</code>, or</p></li>\n<li><p>whether this is better than <code>&amp;'a mut &amp;'a mut ()</code>.</p></li>\n</ul>\n\n<p>I hope to answer these questions.</p>\n\n<h3>A non-fix</h3>\n\n<p>Asserting <code>'b: 'a</code> does not fix the problem.</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a, 'b: 'a&gt;(reference: &amp;'a mut &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<h3>Another, more surprising fix</h3>\n\n<p>Making the outer reference immutable fixes the problem</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a, 'b&gt;(reference: &amp;'a &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<h3>And an even more surprising non-fix!</h3>\n\n<p>Making the <em>inner</em> reference immutable doesn't help at all!</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c ()) {}\n\nfn use_ref_ref&lt;'a, 'b&gt;(reference: &amp;'a mut &amp;'b ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<h1>BUT WHY??!</h1>\n\n<p>And the reason is...</p>\n\n<h3>Hold on, first we cover variance</h3>\n\n<p>Two very important concepts in computer science are <strong>covariance</strong> and <strong>contravariance</strong>. I'm not going to use these names (I'll be very explicit about which way I'm casting things) but those names are still very useful for <a href=\"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\" rel=\"noreferrer\">searching the internet</a>.</p>\n\n<p>It's very important to understand the concept of variance before you can understand the behaviour here. If you've taken a university course that covers this, or you can remember it from some other context, you're in a good position. You might still appreciate the help linking the idea to lifetimes, though.</p>\n\n<h3>The simple case - a normal pointer</h3>\n\n<p>Consider some stack positions with a pointer:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>    \u2551 Name      \u2502 Type                \u2502 Value\n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  1 \u2551 val       \u2502 i32                 \u2502 -1\n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  2 \u2551 reference \u2502 &amp;'x mut i32         \u2502 0x1\n</code></pre>\n\n<p>The stack grows downwards, so the <code>reference</code> stack position was created after <code>val</code>, and will be removed before <code>val</code> is.</p>\n\n<p>Consider that you do</p>\n\n<pre><code>let new_ref = reference;\n</code></pre>\n\n<p>to get</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>    \u2551 Name      \u2502 Type        \u2502 Value  \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  1 \u2551 val       \u2502 i32         \u2502 -1     \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  2 \u2551 reference \u2502 &amp;'x mut i32 \u2502 0x1    \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  3 \u2551 new_ref   \u2502 &amp;'y mut i32 \u2502 0x1    \n</code></pre>\n\n<p>What lifetimes are valid for <code>'y</code>?</p>\n\n<p>Consider the two mutable pointer operations:</p>\n\n<ul>\n<li><strong>Read</strong></li>\n<li><strong>Write</strong></li>\n</ul>\n\n<p><strong>Read</strong> prevents <code>'y</code> from growing, because a <code>'x</code> reference only guarantees the object stays alive during the scope of <code>'x</code>. However, <strong>read</strong> does not prevent <code>'y</code> from shrinking since any read when the pointed-to value is alive will result in a value independent of the lifetime <code>'y</code>.</p>\n\n<p><strong>Write</strong> prevents <code>'y</code> from growing also, since one cannot write to an invalidated pointer. However, <strong>write</strong> does not prevent <code>'y</code> from shrinking since any write to the pointer copies the value in, which leaves it independent of the lifetime <code>'y</code>.</p>\n\n<h3>The hard case - a pointer pointer</h3>\n\n<p>Consider some stack positions with a pointer pointer:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>    \u2551 Name      \u2502 Type                \u2502 Value  \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  1 \u2551 val       \u2502 i32                 \u2502 -1     \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  2 \u2551 reference \u2502 &amp;'a mut i32         \u2502 0x1    \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  3 \u2551 ref_ref   \u2502 &amp;'x mut &amp;'a mut i32 \u2502 0x2    \n</code></pre>\n\n<p>Consider that you do</p>\n\n<pre><code>let new_ref_ref = ref_ref;\n</code></pre>\n\n<p>to get</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>    \u2551 Name        \u2502 Type                \u2502 Value  \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  1 \u2551 val         \u2502 i32                 \u2502 -1     \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  2 \u2551 reference   \u2502 &amp;'a mut i32         \u2502 0x1    \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  3 \u2551 ref_ref     \u2502 &amp;'x mut &amp;'a mut i32 \u2502 0x2    \n \u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n  4 \u2551 new_ref_ref \u2502 &amp;'y mut &amp;'b mut i32 \u2502 0x2    \n</code></pre>\n\n<p>Now there are two questions:</p>\n\n<ol>\n<li><p>What lifetimes are valid for <code>'y</code>?</p></li>\n<li><p>What lifetimes are valid for <code>'b</code>?</p></li>\n</ol>\n\n<p>Let's first consider <code>'y</code> with the two mutable pointer operations:</p>\n\n<ul>\n<li><strong>Read</strong></li>\n<li><strong>Write</strong></li>\n</ul>\n\n<p><strong>Read</strong> prevents <code>'y</code> from growing, because a <code>'x</code> reference only guarantees the object stays alive during the scope of <code>'x</code>. However, <strong>read</strong> does not prevent <code>'y</code> from shrinking since any read when the pointed-to value is alive will result in a value independent of the lifetime <code>'y</code>.</p>\n\n<p><strong>Write</strong> prevents <code>'y</code> from growing also, since one cannot write to an invalidated pointer. However, <strong>write</strong> does not prevent <code>'y</code> from shrinking since any write to the pointer copies the value in, which leaves it independent of the lifetime <code>'y</code>.</p>\n\n<p>This is the same as before.</p>\n\n<h3>Now, consider <code>'b</code> with the two mutable pointer operations</h3>\n\n<p><strong>Read</strong> prevents <code>'b</code> from growing, since if one was to extract the inner pointer from the outer pointer you would be able to read it after <code>'a</code> has expired.</p>\n\n<p><strong>Write</strong> prevents <code>'b</code> from growing also, since if one was to extract the inner pointer from the outer pointer you would be able to write to it after <code>'a</code> has expired.</p>\n\n<p><strong>Read</strong> and <strong>write</strong> together also prevent <code>'b</code> from shrinking, because of this scenario:</p>\n\n<pre><code>let ref_ref: &amp;'x mut &amp;'a mut i32 = ...;\n\n{\n    // Has lifetime 'b, which is smaller than 'a\n    let new_val: i32 = 123;\n\n    // Shrink 'a to 'b\n    let new_ref_ref: &amp;'x mut &amp;'b mut i32 = ref_ref;\n\n    *new_ref_ref = &amp;mut new_val;\n}\n\n// new_ref_ref is out of scope, so ref_ref is usable again\nlet ref_ref: &amp;'a mut i32 = *ref_ref;\n// Oops, we have an &amp;'a mut i32 pointer to a dropped value!\n</code></pre>\n\n<p><strong>Ergo, <code>'b</code> cannot shrink and it cannot grow from <code>'a</code>, so <code>'a == 'b</code> exactly.</strong> This means <code>&amp;'y mut &amp;'b mut i32</code> is invariant in the lifetime 'b.</p>\n\n<h3>OK, does this solve our questions?</h3>\n\n<p>Remember the code?</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a, 'b&gt;(reference: &amp;'a mut &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>When you call <code>use_same_ref_ref</code>, a cast is attempted</p>\n\n<pre><code>&amp;'a mut &amp;'b mut ()  \u2192  &amp;'c mut &amp;'c mut ()\n</code></pre>\n\n<p>Now note that <code>'b == 'c</code> because of our discussion about variance. Thus we are actually casting</p>\n\n<pre><code>&amp;'a mut &amp;'b mut ()  \u2192  &amp;'b mut &amp;'b mut ()\n</code></pre>\n\n<p>The outer <code>&amp;'a</code> can only be shrunk. In order to do this, the compiler needs to know</p>\n\n<pre><code>'a: 'b\n</code></pre>\n\n<p>The compiler does not know this, and so fails compilation.</p>\n\n<h3>What about our other examples?</h3>\n\n<p>The first was</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a&gt;(reference: &amp;'a mut &amp;'a mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>Instead of <code>'a: 'b</code>, the compiler now needs <code>'a: 'a</code>, which is trivially true.</p>\n\n<p>The second directly asserted <code>'a: 'b</code></p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a: 'b, 'b&gt;(reference: &amp;'a mut &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>The third asserted <code>'b: 'a</code></p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a, 'b: 'a&gt;(reference: &amp;'a mut &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>This does not work, because this is not the needed assertion.</p>\n\n<h3>What about immutability?</h3>\n\n<p>We had two cases here. The first was to make the outer reference immutable.</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a, 'b&gt;(reference: &amp;'a &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>This one worked. Why?</p>\n\n<p>Well, consider our problem with shrinking <code>&amp;'b</code> from before:</p>\n\n<blockquote>\n  <p><strong>Read</strong> and <strong>write</strong> together also prevent <code>'b</code> from shrinking, because of this scenario:</p>\n\n<pre><code>let ref_ref: &amp;'x mut &amp;'a mut i32 = ...;\n\n{\n    // Has lifetime 'b, which is smaller than 'a\n    let new_val: i32 = 123;\n\n    // Shrink 'a to 'b\n    let new_ref_ref: &amp;'x mut &amp;'b mut i32 = ref_ref;\n\n    *new_ref_ref = &amp;mut new_val;\n}\n\n// new_ref_ref is out of scope, so ref_ref is usable again\nlet ref_ref: &amp;'a mut i32 = *ref_ref;\n// Oops, we have an &amp;'a mut i32 pointer to a dropped value!\n</code></pre>\n  \n  <p><strong>Ergo, <code>'b</code> cannot shrink and it cannot grow from <code>'a</code>, so <code>'a == 'b</code> exactly.</strong></p>\n</blockquote>\n\n<p>This can only happen because we can swap the inner reference for some new, insufficiently long lived reference. If we are not able to swap the reference, this is not a problem. Thus shrinking the lifetime of the inner reference is possible.</p>\n\n<h3>And the failing one?</h3>\n\n<p>Making the inner reference immutable does not help:</p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c ()) {}\n\nfn use_ref_ref&lt;'a, 'b&gt;(reference: &amp;'a mut &amp;'b ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>This makes sense when you consider that the problem mentioned before never involves any reads from the inner reference. In fact, here's the problematic code modified to demonstrate that:</p>\n\n<pre><code>let ref_ref: &amp;'x mut &amp;'a i32 = ...;\n\n{\n    // Has lifetime 'b, which is smaller than 'a\n    let new_val: i32 = 123;\n\n    // Shrink 'a to 'b\n    let new_ref_ref: &amp;'x mut &amp;'b i32 = ref_ref;\n\n    *new_ref_ref = &amp;new_val;\n}\n\n// new_ref_ref is out of scope, so ref_ref is usable again\nlet ref_ref: &amp;'a i32 = *ref_ref;\n// Oops, we have an &amp;'a i32 pointer to a dropped value!\n</code></pre>\n\n<h3>There was another question</h3>\n\n<p>It's been quite long, but think back to:</p>\n\n<blockquote>\n  <p>One can instead enforce <code>'a: 'b</code></p>\n\n<pre><code>fn use_same_ref_ref&lt;'c&gt;(reference: &amp;'c mut &amp;'c mut ()) {}\n\nfn use_ref_ref&lt;'a: 'b, 'b&gt;(reference: &amp;'a mut &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n  \n  <p>This means that the lifetime of the outer reference is <em>at least</em> as large as the lifetime of the inner one.</p>\n  \n  <p>It's not obvious</p>\n  \n  <ul>\n  <li><p>why <code>&amp;'a mut &amp;'b mut ()</code> is not castable to <code>&amp;'c mut &amp;'c mut ()</code>, or</p></li>\n  <li><p>whether this is better than <code>&amp;'a mut &amp;'a mut ()</code>.</p></li>\n  </ul>\n  \n  <p>I hope to answer these questions.</p>\n</blockquote>\n\n<p>We've answered the first bullet-pointed question, but what about the second? Does <code>'a: 'b</code> permit more than <code>'a == 'b</code>?</p>\n\n<p>Consider some caller with type <code>&amp;'x mut &amp;'y mut ()</code>. If <code>'x : 'y</code>, then it will be automatically cast to <code>&amp;'y mut &amp;'y mut ()</code>. Instead, if <code>'x == 'y</code>, then <code>'x : 'y</code> holds already! The difference is thus only important if you wish to return a type containing <code>'x</code> to the caller, who is the only one able to distinguish the two. Since this is not the case here, the two are equivalent.</p>\n\n<h3>One more thing</h3>\n\n<p>If you write</p>\n\n<pre><code>let mut val = ();\nlet mut reference = &amp;mut val;\nlet ref_ref = &amp;mut reference;\n\nuse_ref_ref(ref_ref);\n</code></pre>\n\n<p>where <code>use_ref_ref</code> is defined</p>\n\n<pre><code>fn use_ref_ref&lt;'a: 'b, 'b&gt;(reference: &amp;'a mut &amp;'b mut ()) {\n    use_same_ref_ref(reference);\n}\n</code></pre>\n\n<p>how is the code able to enforce <code>'a: 'b</code>? It looks on inspection like the opposite is true!</p>\n\n<p>Well, remember that</p>\n\n<pre><code>let reference = &amp;mut val;\n</code></pre>\n\n<p>is able to shrink its lifetime, since it's the outer lifetime at this point. Thus, it can refer to a lifetime <em>smaller</em> than the real lifetime of <code>val</code>, even when the pointer is outside of that lifetime!</p>\n"}], "owner": {"reputation": 2922, "user_id": 929981, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/66Mz4.png?s=128&g=1", "display_name": "jtepe", "link": "https://stackoverflow.com/users/929981/jtepe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1182, "favorite_count": 9, "accepted_answer_id": 32172407, "answer_count": 2, "score": 20, "last_activity_date": 1615038070, "creation_date": 1440327749, "last_edit_date": 1615038070, "question_id": 32165917, "link": "https://stackoverflow.com/questions/32165917/why-does-linking-lifetimes-matter-only-with-mutable-references", "title": "Why does linking lifetimes matter only with mutable references?", "body": "<p>A few days ago, there was <a href=\"https://stackoverflow.com/questions/32089410/lifetimes-and-references-to-objects-containing-references\">a question</a> where someone had a problem with linked lifetimes of a mutable reference to a type which contained borrowed data itself. The problem was supplying a reference to the type with a borrow of the same lifetime as the borrowed data inside the type.\nI tried to recreate the problem:</p>\n\n<pre><code>struct VecRef&lt;'a&gt;(&amp;'a Vec&lt;u8&gt;);\n\nstruct VecRefRef&lt;'a&gt;(&amp;'a mut VecRef&lt;'a&gt;);\n\nfn main() {\n    let v = vec![8u8, 9, 10];\n    let mut ref_v = VecRef(&amp;v);\n    create(&amp;mut ref_v);\n}\n\nfn create&lt;'b, 'a&gt;(r: &amp;'b mut VecRef&lt;'a&gt;) {\n    VecRefRef(r);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=e395fadea1b07fcb3874&amp;version=nightly\" rel=\"noreferrer\">Example code</a></p>\n\n<p>I explicitly annotated <code>'b</code> here in <code>create()</code>. This does not compile:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0623]: lifetime mismatch\n  --&gt; src/main.rs:12:15\n   |\n11 | fn create&lt;'b, 'a&gt;(r: &amp;'b mut VecRef&lt;'a&gt;) {\n   |                      ------------------\n   |                      |\n   |                      these two types are declared with different lifetimes...\n12 |     VecRefRef(r);\n   |               ^ ...but data from `r` flows into `r` here\n</code></pre>\n\n<p>The lifetime <code>'b</code> is something like <code>'b &lt; 'a</code> and therefore violating the constraint in the <code>VecRefRef&lt;'a&gt;</code> to be of exactly the same lifetime as the referred to <code>VecRef&lt;'a&gt;</code>.</p>\n\n<p>I linked the lifetime of the mutable reference with the borrowed data inside the <code>VecRef&lt;'a&gt;</code>:</p>\n\n<pre><code>fn create&lt;'a&gt;(r: &amp;'a mut VecRef&lt;'a&gt;) {\n    VecRefRef(r);\n}\n</code></pre>\n\n<p>Now it works. But why? How was I even able to supply such a reference? The mutable reference <code>r</code> inside <code>create()</code> has the lifetime of <code>VecRef&lt;'a&gt;</code> not <code>'a</code>. Why wasn't the problem pushed up to the calling side of the function <code>create()</code>?</p>\n\n<p>I noticed another thing I did not understand. If I use an <em>immutable</em> reference inside the <code>VecRefRef&lt;'a&gt;</code> struct, it somehow does not matter any more when supplying a reference with a different lifetime of <code>'a</code>:</p>\n\n<pre><code>struct VecRef&lt;'a&gt;(&amp;'a Vec&lt;u8&gt;);\n\nstruct VecRefRef&lt;'a&gt;(&amp;'a VecRef&lt;'a&gt;); // now an immutable reference\n\nfn main() {\n    let v = vec![8u8, 9, 10];\n    let mut ref_v = VecRef(&amp;v);\n    create(&amp;mut ref_v);\n}\n\nfn create&lt;'b, 'a&gt;(r: &amp;'b mut VecRef&lt;'a&gt;) {\n    VecRefRef(r);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=bdc017a87d1c7d77977e&amp;version=nightly\" rel=\"noreferrer\">Example code</a></p>\n\n<p>This works as opposed to the first example where <code>VecRefRef&lt;'a&gt;</code> took a mutable reference to a <code>VecRef&lt;'a&gt;</code>. I know that mutable references have different aliasing rules (no aliasing at all) but what has that to do with the linked lifetimes here?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 11, "last_activity_date": 1440326370, "creation_date": 1440326370, "answer_id": 32165736, "question_id": 32165539, "link": "https://stackoverflow.com/questions/32165539/unable-to-infer-enough-type-information-about-type-annotations-or-generic-p/32165736#32165736", "title": "Unable to infer enough type information about `_`; type annotations or generic parameter binding required", "body": "<p>You have a spurious semicolon after the <code>Err(...)</code>.  You're telling the compiler to throw away the value you construct and return <code>()</code> instead.  Of course, it doesn't get as far as telling you the return type is wrong: it's more immediately confused by the fact that you've constructed a <code>Result&lt;T, E&gt;::Err(E)</code> without telling it what <code>T</code> is.</p>\n"}], "owner": {"reputation": 1548, "user_id": 892698, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c35f590e9178794d7f4c4f07192d3772?s=128&d=identicon&r=PG", "display_name": "Endel", "link": "https://stackoverflow.com/users/892698/endel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1852, "favorite_count": 0, "accepted_answer_id": 32165736, "answer_count": 1, "score": 6, "last_activity_date": 1440334856, "creation_date": 1440324916, "last_edit_date": 1440334856, "question_id": 32165539, "link": "https://stackoverflow.com/questions/32165539/unable-to-infer-enough-type-information-about-type-annotations-or-generic-p", "title": "Unable to infer enough type information about `_`; type annotations or generic parameter binding required", "body": "<p>I'm trying to return an error Result with a <code>&amp;'static str</code>.</p>\n\n<pre><code>impl Worker {\n    fn get_task_by_name(&amp;self, name: String) -&gt; Result&lt;Box&lt;Task&gt;, &amp;'static str&gt; {\n        Err(\"Task not found!\");\n    }\n}\n</code></pre>\n\n<p>It outputs the following error:</p>\n\n<pre><code>src/lib.rs:84:5: 84:8 error: unable to infer enough type information about `_`; type annotations or generic parameter binding required [E0282]\nsrc/lib.rs:84     Err(\"Task not found!\");\n                  ^~~\n</code></pre>\n\n<p>What could be the problem here?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 67160, "user_id": 1078084, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/wApmM.jpg?s=128&g=1", "display_name": "Akavall", "link": "https://stackoverflow.com/users/1078084/akavall"}, "edited": false, "score": 0, "creation_date": 1440300562, "post_id": 32162749, "comment_id": 52213239, "body": "Thanks. I know you should not do it, I was just curious, since this would be possible in <code>Ruby</code>, for example, I was just exploring how this works in <code>Rust</code>. <code>Rust</code> seems to be interesting in that you can have mutable types as keys (<code>Python</code> and <code>Go</code> would not allow it), but it you cannot change them later!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 67160, "user_id": 1078084, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/wApmM.jpg?s=128&g=1", "display_name": "Akavall", "link": "https://stackoverflow.com/users/1078084/akavall"}, "edited": false, "score": 1, "creation_date": 1440300759, "post_id": 32162749, "comment_id": 52213266, "body": "@Akavall you seem to be conflating the <code>mut</code> modifier on the binding with an innate property of the value itself. If you own a value, you can choose for it to be mutable or not."}, {"owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "reply_to_user": {"reputation": 67160, "user_id": 1078084, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/wApmM.jpg?s=128&g=1", "display_name": "Akavall", "link": "https://stackoverflow.com/users/1078084/akavall"}, "edited": false, "score": 1, "creation_date": 1440302562, "post_id": 32162749, "comment_id": 52213490, "body": "@Akavall this is actually not possible in ruby. If you try to mutate a key in a ruby hash it will break the hash. Here is an example: <a href=\"https://gist.github.com/ddebernardy/7629298\" rel=\"nofollow noreferrer\">gist.github.com/ddebernardy/7629298</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "edited": false, "score": 1, "creation_date": 1440334817, "post_id": 32162749, "comment_id": 52220549, "body": "@Adrian that just shows that it is <i>possible</i> to mutate a key in a hash in Ruby. However, as you are pointing out, doing so makes it impossible to look up the key again. Likewise, it is <i>possible</i> to mutate the key in a hash in Rust, but it requires a bit more work. In the end, the hash will be in an inconsistent state as well."}, {"owner": {"reputation": 67160, "user_id": 1078084, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/wApmM.jpg?s=128&g=1", "display_name": "Akavall", "link": "https://stackoverflow.com/users/1078084/akavall"}, "reply_to_user": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "edited": false, "score": 0, "creation_date": 1440334981, "post_id": 32162749, "comment_id": 52220598, "body": "@Adrian, you are totally right. The <code>Ruby</code> thing was the source of my confusion. Thanks a lot for pointing this out."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1440298486, "creation_date": 1440298486, "answer_id": 32162749, "question_id": 32162658, "link": "https://stackoverflow.com/questions/32162658/is-it-possible-to-modify-a-mutable-vector-when-it-is-a-key-in-hashmap/32162749#32162749", "title": "Is it possible to modify a mutable vector when it is a key in HashMap?", "body": "<p>No, you cannot modify it, and even if you could, you absolutely should never do such a thing.</p>\n\n<p>In your example, the reason you cannot modify the vector is because <em>you no longer own it</em>. You've transferred ownership of it to the map. That's what \"use of moved value\" means.</p>\n\n<p>Let's say you had some way of modifying the key of the map (I'm not going to provide any examples to help prevent people from doing this). The main problem is that you'd be breaking an invariant of the <code>HashMap</code>:</p>\n\n<blockquote>\n  <p>It is a logic error for a key to be modified in such a way that the key's hash, as determined by the Hash trait, or its equality, as determined by the Eq trait, changes while it is in the map.</p>\n</blockquote>\n\n<p>The reason for this is simple once you understand how hashmaps work. When you add a key, an algorithm is run that converts the key into an integer (the key is <em>hashed</em>). Then, this integer is used to find a space in an array to store the value.</p>\n\n<p>If you changed the key, then the value would be stored in the <em>wrong spot in the array</em>. As a simple example, imagine that the hashing algorithm for vectors was simply the number of items in the vector. If you added <code>vec![1]</code> as a key, it would be stored in array slot 1. If you then change the key, it <em>should</em> hash to 2, but would still be stored in slot 1!</p>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 4, "last_activity_date": 1440332686, "creation_date": 1440332686, "answer_id": 32166606, "question_id": 32162658, "link": "https://stackoverflow.com/questions/32162658/is-it-possible-to-modify-a-mutable-vector-when-it-is-a-key-in-hashmap/32166606#32166606", "title": "Is it possible to modify a mutable vector when it is a key in HashMap?", "body": "<p>I am afraid this all stems from a misunderstanding about what <code>mut</code> means.</p>\n\n<p>You need to distinguish two terms:</p>\n\n<ul>\n<li><code>vec![5, 6, 7]</code> produces an <em>instance</em> of the <code>Vec</code> type</li>\n<li><code>my_vec</code> is a <em>binding</em>, that is to say, a name given to an instance of a type, because it's easier to manipulate instances by name (but not necessary, cue <a href=\"https://en.wikipedia.org/wiki/Forth_%28programming_language%29\" rel=\"nofollow\">Forth</a>)</li>\n</ul>\n\n<p>When you declare <code>let mut my_vec</code>, you are:</p>\n\n<ul>\n<li>declaring a mutable <em>binding</em></li>\n<li>to which an <em>instance</em> of <code>Vec</code> is bound</li>\n</ul>\n\n<p>The <em>instance</em> itself cannot be called mutable, it is meaningless as illustrated by the following valid snippet:</p>\n\n<pre><code>let mut my_vec = vec![5, 6, 7];\nlet     other = my_vec;          // ownership transfer\nlet mut yac   = other;           // ownership transfer\n</code></pre>\n\n<p>In this snippet, we see:</p>\n\n<ul>\n<li>an <em>instance</em> of <code>Vec</code> type being bound to a mutable <em>binding</em> <code>my_vec</code></li>\n<li>then being bound to an immutable <em>binding</em> <code>other</code></li>\n<li>then being bound to a mutable <em>binding</em> <code>yac</code></li>\n</ul>\n\n<p>which hopefully showcases that mutability is a property not of the <em>instance</em> but the <em>binding</em>.</p>\n\n<p>This is where <em>inherited mutability</em> comes into play:</p>\n\n<ul>\n<li>If you are in possession of a mutable <em>binding</em> to an <em>instance</em> of <code>T</code> (<code>let mut x: T = ...;</code>), or binding to a mutable reference to an <em>instance</em> of <code>T</code> (<code>let x: &amp;mut T = ...;</code>), then you can not only mutate its fields, but also obtain mutable references to these fields to modify their own fields... recursively.</li>\n<li>And conversely, if all you hold is an immutable reference to an instance of type <code>T</code> (<code>let x: &amp;T = ...;</code>), then all you can do is read its fields or obtain immutable references to these fields to read their own fields... recursively (*).</li>\n</ul>\n\n<p>(*) Ok, Ok, it's a simplification, the <code>cell</code> types for example can be modified via immutable references; that's for another day!</p>\n"}], "owner": {"reputation": 67160, "user_id": 1078084, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/wApmM.jpg?s=128&g=1", "display_name": "Akavall", "link": "https://stackoverflow.com/users/1078084/akavall"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 371, "favorite_count": 0, "accepted_answer_id": 32162749, "answer_count": 2, "score": 4, "last_activity_date": 1440332686, "creation_date": 1440297321, "last_edit_date": 1440299133, "question_id": 32162658, "link": "https://stackoverflow.com/questions/32162658/is-it-possible-to-modify-a-mutable-vector-when-it-is-a-key-in-hashmap", "title": "Is it possible to modify a mutable vector when it is a key in HashMap?", "body": "<p>Here is my example:</p>\n\n<pre><code>use std::collections::HashMap;\n\nfn main() {\n    let mut my_map = HashMap::new();\n    let mut my_vec = vec![5,6,7];    \n    my_map.insert(my_vec, 4);\n\n    // This part is fine, so I can create HashMap\n    // with mutable Vector as key.\n\n    my_vec.push(8);\n}\n</code></pre>\n\n<p>However, I cannot actually modify the vector! <code>my_vec.push(8);</code> causes the following error:</p>\n\n<pre><code>post_test_19.rs:14:5: 14:11 error: use of moved value: `my_vec` [E0382]\npost_test_19.rs:14     my_vec.push(8);\n                       ^~~~~~\npost_test_19.rs:7:19: 7:25 note: `my_vec` moved here because it has type `collections::vec::Vec&lt;i32&gt;`, which is non-copyable\npost_test_19.rs:7     my_map.insert(my_vec, 4);\n                                    ^~~~~~\nerror: aborting due to previous error\n</code></pre>\n\n<p>Now the <code>HashMap</code> owns the <code>Vec</code>, so I cannot modify it.</p>\n\n<p>As far as I understand, you cannot modify a <code>Vec</code> if it is used as key in <code>HashMap</code> even though it is technically mutable. Is my understanding correct? Is there a trick or a corner case that I am missing?</p>\n"}, {"tags": ["collections", "iterator", "rust", "traits"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440276247, "post_id": 32160393, "comment_id": 52208826, "body": "Please include the error message. It tells you what is wrong with your implementation. You may want to review what the type of <code>Iterator::Item</code> is for the iterator you have."}, {"owner": {"reputation": 21581, "user_id": 288703, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/1bb69b75c5e73a7c9f4ebbc4835d622f?s=128&d=identicon&r=PG", "display_name": "Christoph", "link": "https://stackoverflow.com/users/288703/christoph"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440277493, "post_id": 32160393, "comment_id": 52209133, "body": "I don&#39;t think that&#39;s a good idea as it&#39;s pretty lengthy. You can click on the playpen link to see the whole compiler error output."}, {"owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "edited": false, "score": 0, "creation_date": 1440277949, "post_id": 32160393, "comment_id": 52209218, "body": "When you call <code>.iter()</code> on a  <code>Vec&lt;T&gt;</code>, you get an <code>Iterator&lt;Item=&amp;T&gt;</code>. So when you call <code>.iter()</code> on a <code>Vec&lt;&amp;str&gt;</code>, you get an <code>Iterator&lt;Item=&amp;&amp;str&gt;</code>, not a <code>Iterator&lt;Item=&amp;str&gt;</code>. You should look at the <code>.cloned()</code> method for <code>Iterator</code>, it should help solve your problem."}, {"owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "edited": false, "score": 0, "creation_date": 1440278088, "post_id": 32160393, "comment_id": 52209247, "body": "Also, note that in order to iterate through an iterator, you must be able to mutate it (either own the iterator or have a mutable reference to it). So just having an immutable reference to it is sorta useless. I would recommend moving the iterator value into <code>print_strings</code> rather than passing it by reference. If you want to use trait objects for this, you can do that by using <code>Box</code>, but it might be easier to just make <code>print_strings</code> a generic function."}, {"owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "edited": false, "score": 0, "creation_date": 1440278294, "post_id": 32160393, "comment_id": 52209289, "body": "BTW here is a version of your code which works: <a href=\"http://is.gd/KUItXM\" rel=\"nofollow noreferrer\">is.gd/KUItXM</a>"}, {"owner": {"reputation": 21581, "user_id": 288703, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/1bb69b75c5e73a7c9f4ebbc4835d622f?s=128&d=identicon&r=PG", "display_name": "Christoph", "link": "https://stackoverflow.com/users/288703/christoph"}, "edited": false, "score": 0, "creation_date": 1440278406, "post_id": 32160393, "comment_id": 52209312, "body": "Awesome, I have to read up about thise <code>cloned</code> method. Why not post this as an answer?"}], "answers": [{"tags": [], "owner": {"reputation": 13948, "user_id": 283342, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/e3ef6dbec3a443e7cda5b5624311ca08?s=128&d=identicon&r=PG&f=1", "display_name": "Adrian", "link": "https://stackoverflow.com/users/283342/adrian"}, "is_accepted": false, "score": 4, "last_activity_date": 1440278566, "creation_date": 1440278566, "answer_id": 32160918, "question_id": 32160393, "link": "https://stackoverflow.com/questions/32160393/how-do-i-use-the-iterator-trait-to-build-generic-apis/32160918#32160918", "title": "How do I use the Iterator trait to build generic APIs", "body": "<p>When you call <code>.iter()</code> on a <code>Vec&lt;T&gt;</code>, you get an <code>Iterator&lt;Item=&amp;T&gt;</code>. So when you call <code>.iter()</code> on a <code>Vec&lt;&amp;str&gt;</code>, you get an <code>Iterator&lt;Item=&amp;&amp;str&gt;</code>, not a <code>Iterator&lt;Item=&amp;str&gt;</code>. You should look at the <code>.cloned()</code> method for <code>Iterator</code>, it should help solve your problem.</p>\n\n<p>Also, note that in order to iterate through an iterator, you must be able to mutate it (either own the iterator or have a mutable reference to it). So just having an immutable reference to it is sorta useless. I would recommend moving the iterator value into print_strings rather than passing it by reference. If you want to use trait objects for this, you can do that by using <code>Box</code>, but it might be easier to just make print_strings a generic function.</p>\n"}, {"comments": [{"owner": {"reputation": 21581, "user_id": 288703, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/1bb69b75c5e73a7c9f4ebbc4835d622f?s=128&d=identicon&r=PG", "display_name": "Christoph", "link": "https://stackoverflow.com/users/288703/christoph"}, "edited": false, "score": 0, "creation_date": 1440279334, "post_id": 32160957, "comment_id": 52209566, "body": "Ok, that playpen clears it perfectly up. Regarding static dispatch, I was saving some keystrokes for the example :P"}], "tags": [], "owner": {"reputation": 136, "user_id": 4514171, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0f8a112207a96b318a36712ff81204f0?s=128&d=identicon&r=PG&f=1", "display_name": "defyrlt", "link": "https://stackoverflow.com/users/4514171/defyrlt"}, "is_accepted": false, "score": 4, "last_activity_date": 1440279684, "last_edit_date": 1440279684, "creation_date": 1440278880, "answer_id": 32160957, "question_id": 32160393, "link": "https://stackoverflow.com/questions/32160393/how-do-i-use-the-iterator-trait-to-build-generic-apis/32160957#32160957", "title": "How do I use the Iterator trait to build generic APIs", "body": "<p><a href=\"http://is.gd/XeEtWx\" rel=\"nofollow\">playpen</a><br>\nSo the first thing is that you're expecting <code>Iterator&lt;Item=&amp;str&gt;</code>, but it's <code>Iterator&lt;Item=&amp;&amp;str&gt;</code> actually.<br>\nThen, you're trying to call <code>.iter()</code>, but <code>Iterator</code> doesn't have this method. \nYou can simply remove <code>.iter()</code> call and receive (and send ofc) <code>&amp;mut Iterator&lt;...&gt;</code> in order to get <code>for</code> loop working (<code>for</code> loop needs something, that implements <code>IntoIterator</code>, and <code>&amp;mut Iterator</code> is that thing).<br>\nAdd lifetimes and you're all set! :)<br>\nAlso, I'm recommending to use static dispatch. You can see it in the example I provided.</p>\n"}, {"tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 7, "last_activity_date": 1440339386, "last_edit_date": 1440339386, "creation_date": 1440284094, "answer_id": 32161554, "question_id": 32160393, "link": "https://stackoverflow.com/questions/32160393/how-do-i-use-the-iterator-trait-to-build-generic-apis/32161554#32161554", "title": "How do I use the Iterator trait to build generic APIs", "body": "<p>Even better, you can do</p>\n\n<pre><code>fn print_strings&lt;Iterable&gt;(strings: Iterable)\n    where Iterable: IntoIterator,\n          Iterable::Item: AsRef&lt;str&gt;\n{\n    for val in strings {\n        println!(\"{}\", val.as_ref());\n    }\n}\n</code></pre>\n\n<p><sup>(Kudos Shepmaster for the improvement.)</sup></p>\n\n<p>This means that you can call this with <code>&amp;mut Iterator</code>s for dynamic dispatch <em>or</em> concrete iterator or collection types for static dispatch. Further, the iterator type can be anything that can be simply converted to <code>&amp;str</code>, which includes but is not limited to <code>&amp;str</code>, <code>&amp;&amp;str</code> and even <code>String</code>.</p>\n\n<pre><code>print_strings(&amp;strings);\nprint_strings(strings.iter().map(|s| s.to_owned()));\nprint_strings(vec![&amp;&amp;&amp;&amp;\"xyz\"]);\nprint_strings(strings);\nprint_strings(more_strings.values());\n</code></pre>\n"}], "owner": {"reputation": 21581, "user_id": 288703, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/1bb69b75c5e73a7c9f4ebbc4835d622f?s=128&d=identicon&r=PG", "display_name": "Christoph", "link": "https://stackoverflow.com/users/288703/christoph"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 117, "favorite_count": 1, "accepted_answer_id": 32161554, "answer_count": 3, "score": 6, "last_activity_date": 1440339386, "creation_date": 1440274880, "last_edit_date": 1440294929, "question_id": 32160393, "link": "https://stackoverflow.com/questions/32160393/how-do-i-use-the-iterator-trait-to-build-generic-apis", "title": "How do I use the Iterator trait to build generic APIs", "body": "<p>I may not see the forest for the trees but I wonder how do I actually design my methods to not work against hard collection types but against Iterators instead. Consider this method.</p>\n\n<pre><code>pub fn print_strings(strings: Vec&lt;String&gt;) {\n    for val in strings.iter() {\n        println!(\"{}\", val);\n    }\n}\n</code></pre>\n\n<p>Obviously this falls short if I want to use that with an <code>HashSet</code> or <code>HashMap</code>.</p>\n\n<p>So, I tried this:</p>\n\n<pre><code>use std::collections::*;\n\nfn main () {\n    let strings = vec!(\"Foo\", \"Bar\");\n\n    let mut more_strings = HashMap::new();\n    more_strings.insert(\"foo\", \"bar\");\n    more_strings.insert(\"bar\", \"foo\");\n\n    print_strings(&amp;strings.iter());\n    print_strings(&amp;more_strings.values())\n}\n\nfn print_strings(strings: &amp;Iterator&lt;Item=&amp;str&gt;) {\n    for val in strings {\n        println!(\"{}\", val);\n    }\n}\n</code></pre>\n\n<p><strong>Playpen (also to view lengthy compiler error)</strong> </p>\n\n<p><a href=\"http://is.gd/EYIK11\" rel=\"nofollow\">http://is.gd/EYIK11</a></p>\n\n<p>Unfortunately, this doesn't seem to do the trick either. What am I missing?</p>\n"}, {"tags": ["rust", "move-semantics"], "comments": [{"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 2, "creation_date": 1440236236, "post_id": 32154387, "comment_id": 52197492, "body": "Explicitly instantiating (<code>make_move::&lt;&amp;mut i32&gt;(r_original);</code>) works like the original function (no move). Fascinating; I&#39;d assume borrow checking is happening before type inference."}, {"owner": {"reputation": 2922, "user_id": 929981, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/66Mz4.png?s=128&g=1", "display_name": "jtepe", "link": "https://stackoverflow.com/users/929981/jtepe"}, "reply_to_user": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 0, "creation_date": 1440241858, "post_id": 32154387, "comment_id": 52199003, "body": "From dacker&#39;s answer I assume that is the case: Explicitly annotating the type to be a mutable reference triggers a re-borrow of the contents instead of a move, leaving the original reference to be usable again once the new reference (here in make_move&#39;s scope) goes out of scope."}], "answers": [{"tags": [], "owner": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "is_accepted": false, "score": 3, "last_activity_date": 1440239623, "last_edit_date": 1495542239, "creation_date": 1440238320, "answer_id": 32154899, "question_id": 32154387, "link": "https://stackoverflow.com/questions/32154387/why-is-the-mutable-reference-not-moved-here/32154899#32154899", "title": "Why is the mutable reference not moved here?", "body": "<p>I asked something along those lines <a href=\"https://stackoverflow.com/questions/30535529/variable-binding-moving-a-mut-or-borrowing-the-referent\">here</a>.</p>\n\n<p>It seems that in some (many?) cases, instead of a move, a re-borrow takes place. Memory safety is not violated, only the \"moved\" value is still around. I could not find any docs on that behavior either.</p>\n\n<p>@Levans opened a github issue <a href=\"https://github.com/rust-lang/rust/issues/25899\" rel=\"nofollow noreferrer\">here</a>, although I'm not entirely convinced this is just a doc issue: dependably moving out of a &amp;mut reference seems central to Rust's approach of ownership.</p>\n"}, {"comments": [{"owner": {"reputation": 2922, "user_id": 929981, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/66Mz4.png?s=128&g=1", "display_name": "jtepe", "link": "https://stackoverflow.com/users/929981/jtepe"}, "edited": false, "score": 0, "creation_date": 1440266822, "post_id": 32158223, "comment_id": 52206252, "body": "I never thought of it that way. However it seems logical. By &quot;cast away pointer mutability&quot; you mean getting a shared reference from an mutable reference? Like let r: &amp;i32 = r_mut; where r_mut is &amp;mut i32."}, {"owner": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "edited": false, "score": 0, "creation_date": 1440283268, "post_id": 32158223, "comment_id": 52210537, "body": "Nice explanation. This really makes sense. My guess regarding <code>&#39;b</code> would be: it&#39;s the intersection of <code>&#39;a</code> which encompasses <code>move_try</code>&#39;s body and the nested scope where <code>new</code> is defined; so <code>&#39;b</code> would be this nested scope at the end of which <code>new</code>&#39;s borrow ends."}, {"owner": {"reputation": 4073, "user_id": 11498773, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/79d317da8c76af3f45f63986e9783740?s=128&d=identicon&r=PG&f=1", "display_name": "Mihir", "link": "https://stackoverflow.com/users/11498773/mihir"}, "edited": false, "score": 0, "creation_date": 1606925310, "post_id": 32158223, "comment_id": 115112048, "body": "As per the explaination, first 2 snippets seem equivalent but they show different error messages <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7863000c51a6497ffa2a26947cabb138\" rel=\"nofollow noreferrer\">Playground</a>. First snippet says value moved whereas second snippet says still borrowed. Did I misunderstood something?"}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 4073, "user_id": 11498773, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/79d317da8c76af3f45f63986e9783740?s=128&d=identicon&r=PG&f=1", "display_name": "Mihir", "link": "https://stackoverflow.com/users/11498773/mihir"}, "edited": false, "score": 1, "creation_date": 1606960383, "post_id": 32158223, "comment_id": 115124724, "body": "@Mihir Technically <code>let new: &amp;&#39;a mut _ = val;</code> is a reborrow, it&#39;s just a no-op reborrow since the lifetimes are identical."}, {"owner": {"reputation": 4073, "user_id": 11498773, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/79d317da8c76af3f45f63986e9783740?s=128&d=identicon&r=PG&f=1", "display_name": "Mihir", "link": "https://stackoverflow.com/users/11498773/mihir"}, "edited": false, "score": 0, "creation_date": 1606976518, "post_id": 32158223, "comment_id": 115127965, "body": "@Veedrac, it makes sense when you say &quot;&amp;mut T isn&#39;t actually a type&quot;. Although, I am curious,  <code>let new = val</code> moves the mutable reference. Then if we had to explicitly annotate <code>new</code> wanting data to be moved from <code>val</code> to <code>new</code>, how would be do that? <code>let new: _ = val</code>. What would be the exact type of <code>_</code>?"}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 4073, "user_id": 11498773, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/79d317da8c76af3f45f63986e9783740?s=128&d=identicon&r=PG&f=1", "display_name": "Mihir", "link": "https://stackoverflow.com/users/11498773/mihir"}, "edited": false, "score": 1, "creation_date": 1607170125, "post_id": 32158223, "comment_id": 115190923, "body": "@Mihir I don&#39;t think you can, unless you have the whole type in a type variable."}], "tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 12, "last_activity_date": 1440260240, "creation_date": 1440260240, "answer_id": 32158223, "question_id": 32154387, "link": "https://stackoverflow.com/questions/32154387/why-is-the-mutable-reference-not-moved-here/32158223#32158223", "title": "Why is the mutable reference not moved here?", "body": "<p>There might actually be a good reason for this.</p>\n\n<p><code>&amp;mut T</code> isn't <em>actually</em> a type: all borrows are parametrized by some (potentially inexpressible) lifetime.</p>\n\n<p>When one writes</p>\n\n<pre><code>fn move_try(val: &amp;mut ()) {\n    { let new = val; }\n    *val\n}\n\nfn main() {\n    move_try(&amp;mut ());\n}\n</code></pre>\n\n<p>the type inference engine infers <code>typeof new == typeof val</code>, so they share the original lifetime. This means the borrow from <code>new</code> does not end until the borrow from <code>val</code> does.</p>\n\n<p>This means it's equivalent to</p>\n\n<pre><code>fn move_try&lt;'a&gt;(val: &amp;'a mut ()) {\n    { let new: &amp;'a mut _ = val; }\n    *val\n}\n\nfn main() {\n    move_try(&amp;mut ());\n}\n</code></pre>\n\n<p>However, when you write</p>\n\n<pre><code>fn move_try(val: &amp;mut ()) {\n    { let new: &amp;mut _ = val; }\n    *val\n}\n\nfn main() {\n    move_try(&amp;mut ());\n}\n</code></pre>\n\n<p>a cast happens - the same kind of thing that lets you cast away pointer mutability. This means that the lifetime is some (seemingly unspecifiable) <code>'b &lt; 'a</code>. This involves a cast, and thus a reborrow, and so the reborrow is able to fall out of scope.</p>\n\n<p>An always-reborrow rule would probably be nicer, but explicit declaration isn't too problematic.</p>\n"}], "owner": {"reputation": 2922, "user_id": 929981, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/66Mz4.png?s=128&g=1", "display_name": "jtepe", "link": "https://stackoverflow.com/users/929981/jtepe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1501, "favorite_count": 4, "accepted_answer_id": 32158223, "answer_count": 2, "score": 16, "last_activity_date": 1440260240, "creation_date": 1440234941, "last_edit_date": 1440235708, "question_id": 32154387, "link": "https://stackoverflow.com/questions/32154387/why-is-the-mutable-reference-not-moved-here", "title": "Why is the mutable reference not moved here?", "body": "<p>I was under the impression that mutable references (i.e. <code>&amp;mut T</code>) are always moved. That makes perfect sense, since they allow exclusive mutable access.\nIn the following piece of code I assign a mutable reference to another mutable reference and the original is moved. As a result I cannot use the original any more:</p>\n\n<pre><code>let mut value = 900;\nlet r_original = &amp;mut value;\nlet r_new = r_original;\n*r_original; // error: use of moved value *r_original\n</code></pre>\n\n<p>If I have a function like this:</p>\n\n<pre><code>fn make_move(_: &amp;mut i32) {\n}\n</code></pre>\n\n<p>and modify my original example to look like this:</p>\n\n<pre><code>let mut value = 900;\nlet r_original = &amp;mut value;\nmake_move(r_original);\n*r_original; // no complain\n</code></pre>\n\n<p>I would expect that the mutable reference <code>r_original</code> is moved when I call the function <code>make_move</code> with it. However that does not happen. I am still able to use the reference after the call.</p>\n\n<p>If I use a generic function <code>make_move_gen</code>:</p>\n\n<pre><code>fn make_move_gen&lt;T&gt;(_: T) {\n}\n</code></pre>\n\n<p>and call it like this:</p>\n\n<pre><code>let mut value = 900;\nlet r_original = &amp;mut value;\nmake_move_gen(r_original);\n*r_original; // error: use of moved value *r_original\n</code></pre>\n\n<p>The reference is moved again and therefore the program behaves as I would expect.\nWhy is the reference not moved when calling the function <code>make_move</code>?</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=74925cf82cca7907b571&amp;version=nightly\">Code example</a></p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "edited": false, "score": 0, "creation_date": 1440242997, "post_id": 32153382, "comment_id": 52199329, "body": "@Levans, thx for the answer, this is clear to me. The interesting part is really the nested scope: in my example the borrower m1 goes out of scope, in your example, the &quot;self&quot;-borrower remains in scope, despite the curly braces. This makes the error clear to me only in your case."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "edited": false, "score": 0, "creation_date": 1440260855, "post_id": 32153382, "comment_id": 52204479, "body": "&quot;The interesting part is really the nested scope: in my example the borrower m1 goes out of scope&quot; \u2192 Why do you assume the <b>borrow</b>&#39;s scope is the same as that of the <b>borrower</b>&#39;s? The only important aspect of the borrower&#39;s scope is that it must be no larger than the scope of the borrow, and that any borrow <i>of it</i> (eg. <code>&amp;mut &amp;mut T</code>)  is restricted by it. The lifetime of the borrow it holds is limitless - consider <code>let x: &amp;&#39;static str = &quot;foo&quot;</code>."}, {"owner": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "edited": false, "score": 0, "creation_date": 1440279247, "post_id": 32153382, "comment_id": 52209537, "body": "Why do you assume that I assume that? I tried to be explicit by using the term borrow scope instead of lifetime, as explained e.g. <a href=\"http://arthurtw.github.io/2014/11/30/rust-borrow-lifetimes.html\" rel=\"nofollow noreferrer\">here</a>. Of course borrow scopes can be larger than the borrower&#39;s scope but only if there is another borrower outside the first borrower&#39;s scope."}, {"owner": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "edited": false, "score": 0, "creation_date": 1440279627, "post_id": 32153382, "comment_id": 52209654, "body": "But not in this case: <code>m1</code> is the only borrower before <code>m2</code>. You can see that <code>m1</code>&#39;s borrow ends at the closing brace if you comment the line <code>m1.r = &amp;m1.i;</code>: the code compiles. Nothing else borrows <code>s</code> before <code>m2</code>."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "edited": false, "score": 0, "creation_date": 1440280176, "post_id": 32153382, "comment_id": 52209792, "body": "@dacker &quot;But not in this case: <code>m1</code> is the only borrower before <code>m2</code>.&quot; \u2192 No, <code>m1.r = &amp;m1.i;</code> results in <code>s</code> borrowing from <code>m1</code>&#39;s borrow, thus <code>s</code> is mutably borrowing from <code>s</code>. This will evidently last the lifetime of <code>s</code>."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "edited": false, "score": 0, "creation_date": 1440280344, "post_id": 32153382, "comment_id": 52209846, "body": "@dacker I guess the real question is why you expect <code>m1.r = &amp;m1.i;</code> not to force an increase in the lifetime of <code>m1</code>s borrow. It seems obvious that it must."}, {"owner": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "edited": false, "score": 0, "creation_date": 1440280746, "post_id": 32153382, "comment_id": 52209928, "body": "You are right, that is what I expect. All I see is <code>m1.r</code> borrowing from <code>m1.i</code>, no further borrow from <code>s</code>. I was under the impression that the Rust compiler would not do code analysis and so could not &quot;see&quot; that <code>m1.i</code> is actually <code>s.i</code> (which would be a borrow of <code>s</code> as you say)."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "edited": false, "score": 0, "creation_date": 1440281067, "post_id": 32153382, "comment_id": 52210004, "body": "@dacker If it could not see it (or, more accurately, the lifetime of the object you&#39;re assigning into), it would not let you do the operation as it could not verify its safety."}], "tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 6, "last_activity_date": 1440228599, "last_edit_date": 1440228599, "creation_date": 1440227161, "answer_id": 32153382, "question_id": 32151937, "link": "https://stackoverflow.com/questions/32151937/mysterious-borrow-scope-extension/32153382#32153382", "title": "Mysterious borrow scope extension", "body": "<p>First note that</p>\n\n<pre><code>let mut s = S{i: 0, r: &amp;0};\n{\n    s.r = &amp;s.i;\n}\nlet m2 = &amp;mut s;\n</code></pre>\n\n<p>Gives</p>\n\n<pre><code>cannot borrow `s` as mutable because `s.i` is also borrowed as immutable\n</code></pre>\n\n<p>Hopefully this should be clear - if a struct self-borrows then it is borrowed. This points out why any self-borrowing structure is basically useless - it cannot be moved (invalidating its own pointer) nor can and mutable reference be taken to it.</p>\n\n<hr>\n\n<p>Next one needs to understand that immutable references from mutable references count as borrows into the mutable reference, so extend it. For example</p>\n\n<pre><code>let mut v = ();\nlet r1 = &amp;(&amp;mut v);\nlet r2 = &amp;v;\n</code></pre>\n\n<p>gives</p>\n\n<pre><code>cannot borrow `v` as immutable because it is also borrowed as mutable\n</code></pre>\n\n<p>It's not clear if this is legally able to be a new borrow into the original structure, but it as-yet does not act as such.</p>\n"}], "owner": {"reputation": 427, "user_id": 4951150, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9333c2b1123fdbdf3876c3d493dbccfc?s=128&d=identicon&r=PG&f=1", "display_name": "dacker", "link": "https://stackoverflow.com/users/4951150/dacker"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 622, "favorite_count": 1, "accepted_answer_id": 32153382, "answer_count": 1, "score": 10, "last_activity_date": 1440228599, "creation_date": 1440213735, "last_edit_date": 1440218120, "question_id": 32151937, "link": "https://stackoverflow.com/questions/32151937/mysterious-borrow-scope-extension", "title": "Mysterious borrow scope extension", "body": "<p>Why does the compiler reject this code:</p>\n\n<pre><code>struct S&lt;'a&gt; {\n    i: i32,\n    r: &amp;'a i32,\n}\n\nfn main() {\n    let mut s = S{i: 0, r: &amp;0};\n    {\n        let m1 = &amp;mut s;\n        m1.r = &amp;m1.i;\n    }\n    let m2 = &amp;mut s;\n}\n</code></pre>\n\n<p>The error is: \"cannot borrow <code>s</code> as mutable more than once at a time\" (first borrow: <code>m1</code>, second borrow: <code>m2</code>).</p>\n\n<p><strong>Why is the first borrow of <code>s</code> still alive after <code>m1</code> goes out of scope?</strong></p>\n\n<p>I read about borrow scope extension beyond the scope of the original borrower. However, this always seemed to involve another borrower outside the scope of the original borrower that \"took over\" the original borrow, e.g. this code fails with the exact same error, which is clear to me:</p>\n\n<pre><code>fn main() {\n    let mut s = 0;\n    let r: &amp;mut i32;\n    {\n        let m1 = &amp;mut s;\n        r = m1;\n    }\n    let m2 = &amp;mut s;\n}\n</code></pre>\n\n<p>In the first example, if I replace <code>m1.r = &amp;m1.i;</code> with <code>m1.r = &amp;dummy;</code> (dummy defined as some &amp;i32) or with <code>let dummy = &amp;m1.i;</code>, the code compiles. The error occurs only if I store a reference to a field in another field of the borrowed struct. I don't see why this should extend the borrow beyond its scope.</p>\n\n<p>My best guess as to what is wrong with the code is:</p>\n\n<ul>\n<li><p><code>s.r</code>'s original lifetime is the whole of <code>main</code>,</p></li>\n<li><p>when I assign a reference to <code>m1.r</code> it has to be that original lifetime, but <code>&amp;m1.i</code> is only valid for as long as <code>m1</code> lives.</p></li>\n</ul>\n\n<p>But I might be wrong (the error message would be misleading then).</p>\n"}, {"tags": ["generics", "enums", "type-conversion", "rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 3, "last_activity_date": 1440191657, "creation_date": 1440191657, "answer_id": 32149337, "question_id": 32147576, "link": "https://stackoverflow.com/questions/32147576/get-active-value-from-union-style-enum-in-generic-method/32149337#32149337", "title": "Get active value from union-style enum in generic method", "body": "<p>The short answer is that you can't. Check out your function prototype:</p>\n\n<pre><code>fn convert&lt;T&gt;(e: &amp;Value) -&gt; T\n</code></pre>\n\n<p>This says that for any <code>T</code> that the <em>caller chooses</em>, the function has to return that. That would entail a very large number of possibilities, including every type ever created by any user of this code.</p>\n\n<p>However, there's a <em>type</em> of solution for your problem. You just need to look at how the standard library implements <a href=\"http://doc.rust-lang.org/std/primitive.str.html#method.parse\" rel=\"nofollow\"><code>str::parse</code></a>:</p>\n\n<pre><code>fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt; \n    where F: FromStr\n{\n    FromStr::from_str(self)\n}\n</code></pre>\n\n<p><a href=\"http://doc.rust-lang.org/std/str/trait.FromStr.html\" rel=\"nofollow\"><code>FromStr</code></a> is the real hero here, and many types implement it. Any type that implements <code>FromStr</code> can be used with <code>parse</code>.</p>\n\n<p>I believe that you can use <code>FromStr</code> for your case, because your code doesn't make any sense. ^_^ Your example code:</p>\n\n<pre><code>let i = query::&lt;i32&gt;(\"i\");\n</code></pre>\n\n<p>Is specifying the type <strong>twice</strong> \u2014 once as the type parameter <code>&lt;i32&gt;</code>, and once as the string <code>\"i\"</code>. This is quite odd, so my guess is that really the argument is a name of a key-value pair. This makes me think of how the Rust <a href=\"https://github.com/sfackler/rust-postgres\" rel=\"nofollow\">Postgres crate</a> works (pseudocode shown):</p>\n\n<pre><code>let id: i32 = row.get(0);\nlet name: String = row.get(1);\n</code></pre>\n\n<p>I'd believe that you can piggyback on <code>FromStr</code> and add some boilerplate:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::str::FromStr;\n\nstruct ConfigFile {\n    raw: HashMap&lt;String, String&gt;,\n}\n\nimpl ConfigFile {\n    fn read_from_disk() -&gt; Self {\n        let mut map = HashMap::new();\n        map.insert(\"name\".into(), \"Anna\".into());\n        map.insert(\"points\".into(), \"210\".into());\n        map.insert(\"debugging\".into(), \"true\".into());\n        ConfigFile { raw: map }\n    }\n\n    fn get&lt;T&gt;(&amp;self, name: &amp;str) -&gt; Option&lt;T&gt;\n        where T: FromStr\n    {\n        self.raw.get(name).and_then(|v| v.parse().ok())\n    }\n}\n\nfn main() {\n    let conf = ConfigFile::read_from_disk();\n    let n: String = conf.get(\"name\").unwrap();\n    let p: i32    = conf.get(\"points\").unwrap();\n    let d: bool   = conf.get(\"debugging\").unwrap();\n    println!(\"{} has {} points, {}\", n, p, d);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440192109, "post_id": 32149409, "comment_id": 52188194, "body": "Ah, of course this makes sense. This basically creates a trait that parallels <code>FromStr</code>, but is tailored to the source type in question. Very nice!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1440193142, "post_id": 32149409, "comment_id": 52188590, "body": "Although, implementing the trait for <code>i32</code> and having an associated type for <code>i32</code> seems redundant \u2014 I think you don&#39;t want the associated type."}], "tags": [], "owner": {"reputation": 3181, "user_id": 4998184, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/29c803cb4341d0ff630cb3ca04ab7251?s=128&d=identicon&r=PG", "display_name": "eulerdisk", "link": "https://stackoverflow.com/users/4998184/eulerdisk"}, "is_accepted": true, "score": 6, "last_activity_date": 1440192434, "last_edit_date": 1440192434, "creation_date": 1440192016, "answer_id": 32149409, "question_id": 32147576, "link": "https://stackoverflow.com/questions/32147576/get-active-value-from-union-style-enum-in-generic-method/32149409#32149409", "title": "Get active value from union-style enum in generic method", "body": "<p>Here there is a possible solution:</p>\n\n<pre><code>enum Value {\n    Bool(bool),\n    Int(i32),\n    Float(f32),\n    Str(String),\n}\n\nfn get_value(key: &amp;str) -&gt; Value {\n    // read value from file\n    match key {\n        \"b\" =&gt; Value::Bool(true),\n        \"i\" =&gt; Value::Int(666),\n        \"f\" =&gt; Value::Float(42.),\n        \"s\" =&gt; Value::Str(\"\ud83d\ude08\".to_string()),\n         _  =&gt; panic!(\"Key {} not found.\", key),\n    }\n}\n\ntrait ConversionTrait {\n    type Output;\n\n    fn convert(v: &amp;Value) -&gt; Option&lt;Self::Output&gt; {\n        None\n    }\n}\n\nimpl ConversionTrait for i32 {\n    type Output = i32;\n\n    fn convert(v: &amp;Value) -&gt; Option&lt;Self::Output&gt; {\n        match (*v) {\n            Value::Int(x) =&gt; Some(x),\n            _ =&gt; None\n        }\n    }\n}\n\nfn convert&lt;T&gt;(e: &amp;Value) -&gt; Option&lt;T&gt; where T : ConversionTrait&lt;Output = T&gt; {\n    T::convert(e)\n}\n\n\nfn query&lt;T&gt;(t: &amp;str) -&gt; Option&lt;T&gt; where T : ConversionTrait&lt;Output = T&gt; {\n    // \u2026 validation etc.\n    convert::&lt;T&gt;(&amp;get_value(t))\n}\n\nfn main() {\n    let i = query::&lt;i32&gt;(\"i\");\n    // let j = query::&lt;f32&gt;(\"i\"); ConversionTrait not implemented\n    println!(\"{:?}\", i);\n}\n</code></pre>\n\n<p>First of all the <code>convert</code> and <code>query</code> methods could fail, so it's better they return an <code>Option</code> which can be <code>None</code> in case of failure.</p>\n\n<p>Second, in Rust there is no generic specialization at the moment so a possible solution is to define a trait to do the conversion then implement the trait only for the types you want the conversion.\n(with generic specialization you would implement different version of the convert function)</p>\n\n<p>Each implementation of the <code>ConversionTrait</code> above should extract the proper value from the <code>Value</code> object and return it.\nI implemented only the <code>i32</code> version for reference.</p>\n"}, {"tags": [], "owner": {"reputation": 37741, "user_id": 3425536, "user_type": "registered", "accept_rate": 72, "profile_image": "https://graph.facebook.com/1484495923/picture?type=large", "display_name": "emlai", "link": "https://stackoverflow.com/users/3425536/emlai"}, "is_accepted": false, "score": 4, "last_activity_date": 1440236709, "last_edit_date": 1495539865, "creation_date": 1440236709, "answer_id": 32154643, "question_id": 32147576, "link": "https://stackoverflow.com/questions/32147576/get-active-value-from-union-style-enum-in-generic-method/32154643#32154643", "title": "Get active value from union-style enum in generic method", "body": "<p><a href=\"https://stackoverflow.com/a/32149409/3425536\">Andrea P's answer</a> was really helpful. I adapted it a little and also made a macro to avoid code duplication in the <code>impl Convert</code>s. Here's the result just in case anyone is interested:</p>\n\n<pre><code>trait Convert : Sized {\n    fn convert(Value) -&gt; Option&lt;Self&gt;;\n}\n\nmacro_rules! impl_convert {\n    ($t:ty, $id:ident) =&gt; (\n        impl Convert for $t {\n            fn convert(v: Value) -&gt; Option&lt;$t&gt; {\n                match v {\n                    Value::$id(x) =&gt; Some(x),\n                    _ =&gt; None,\n                }\n            }\n        }\n    )\n}\n\nimpl_convert!(bool, Bool);\nimpl_convert!(i32, Int);\nimpl_convert!(f32, Float);\nimpl_convert!(String, Str);\n\nfn query&lt;T: Convert&gt;(t: &amp;str) -&gt; T {\n    // \u2026 validation etc.\n    match T::convert(get_value(t)) {\n        Some(x) =&gt; x,\n        None =&gt; panic!(\"`{}` has an incorrect type\", t),\n    }\n}\n</code></pre>\n\n<p><code>Convert</code> inherits <code>Sized</code> to prevent:</p>\n\n<blockquote>\n  <p><strong>warning</strong>: the trait <code>core::marker::Sized</code> is not implemented for the type <code>Self</code></p>\n</blockquote>\n"}], "owner": {"reputation": 37741, "user_id": 3425536, "user_type": "registered", "accept_rate": 72, "profile_image": "https://graph.facebook.com/1484495923/picture?type=large", "display_name": "emlai", "link": "https://stackoverflow.com/users/3425536/emlai"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 300, "favorite_count": 0, "accepted_answer_id": 32149409, "answer_count": 3, "score": 4, "last_activity_date": 1440236709, "creation_date": 1440183551, "last_edit_date": 1440186398, "question_id": 32147576, "link": "https://stackoverflow.com/questions/32147576/get-active-value-from-union-style-enum-in-generic-method", "title": "Get active value from union-style enum in generic method", "body": "<p>I have code similar to the following:</p>\n\n<pre><code>enum Value {\n    Bool(bool),\n    Int(i32),\n    Float(f32),\n    Str(String),\n}\n\nfn get_value(key: &amp;str) -&gt; Value {\n    // read value from file\n    match key {\n        \"b\" =&gt; Value::Bool(true),\n        \"i\" =&gt; Value::Int(666),\n        \"f\" =&gt; Value::Float(42.),\n        \"s\" =&gt; Value::Str(\"\ud83d\ude08\".to_string()),\n         _  =&gt; panic!(\"Key {} not found.\", str),\n    }\n}\n\nfn convert&lt;T&gt;(e: &amp;Value) -&gt; T {\n    // what to put here?\n}\n\nfn query&lt;T&gt;(t: &amp;str) -&gt; T {\n    // \u2026 validation etc.\n    convert::&lt;T&gt;(&amp;get_value(t))\n}\n\nfn main() {\n    let i = query::&lt;i32&gt;(\"i\");\n}\n</code></pre>\n\n<p>I.e. I need to <code>query</code> some values from a text file. <code>query</code> takes a type parameter and a string key parameter. It then returns the value associated to that key in the text file (if the type parameter and the type of the value don't match, simply <code>panic!</code>). <code>Value</code> and <code>get_value</code> are from a library in the actual code.</p>\n\n<p>However I'm facing a problem when trying to <code>convert</code> a <code>Value</code> instance to the type it holds. If I try to do it with a simple <code>match</code>, I get</p>\n\n<blockquote>\n  <p>error: mismatched types:  expected <code>T</code>,\n      found <code>x</code></p>\n</blockquote>\n\n<p>where <code>x</code> is one of <code>bool</code>/<code>i32</code>/<code>f32</code>/<code>String</code>.</p>\n\n<p>What is the right way to do this in Rust?</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1440180996, "post_id": 32146717, "comment_id": 52183150, "body": "you were simply using too many references everywhere ;) get rid of them and do everything by value and you are fine: <a href=\"http://is.gd/xv3GHi\" rel=\"nofollow noreferrer\">is.gd/xv3GHi</a>"}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1440181401, "post_id": 32146717, "comment_id": 52183374, "body": "@ker Won&#39;t that prevent the <code>mem::replace</code> from doing its job?"}, {"owner": {"reputation": 1342, "user_id": 3033123, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/bfb390ac1abb471ac1090039109d14a0?s=128&d=identicon&r=PG&f=1", "display_name": "zrneely", "link": "https://stackoverflow.com/users/3033123/zrneely"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1440182789, "post_id": 32146717, "comment_id": 52184093, "body": "@ker Wow, I was really overthinking this. Can you make that an answer?"}, {"owner": {"reputation": 1342, "user_id": 3033123, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/bfb390ac1abb471ac1090039109d14a0?s=128&d=identicon&r=PG&f=1", "display_name": "zrneely", "link": "https://stackoverflow.com/users/3033123/zrneely"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1440183079, "post_id": 32146717, "comment_id": 52184231, "body": "@ker Actually, that has a side effect of removing the tree in the case that it already exists, doesn&#39;t it?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1440190378, "post_id": 32146717, "comment_id": 52187602, "body": "I don&#39;t see why you need <code>mem::replace</code>. if you ignore the result of <code>replace</code>, you might as well simply assign..."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1440190504, "post_id": 32146717, "comment_id": 52187658, "body": "@zrneely: yes this removes it from the tree, you need to put it back later. The solution space is very large here, not sure what the idiomatic way would be here."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1440229024, "post_id": 32146717, "comment_id": 52195792, "body": "@ker I&#39;d assume that it&#39;s used in the elided parts of the code, but as it stands <code>*subtree = Some(...)</code> would be more effective. That said, a borrow still seems much more straightforward than temporary removal."}], "answers": [{"tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 4, "last_activity_date": 1440181144, "creation_date": 1440181144, "answer_id": 32146938, "question_id": 32146717, "link": "https://stackoverflow.com/questions/32146717/how-can-i-replace-an-option-within-a-vec/32146938#32146938", "title": "How can I replace an Option within a Vec?", "body": "<p>You're trying to put an <code>&amp;mut</code> inside some structure which lives longer than the thing <code>&amp;mut</code> is pointing to. Here's a reduced example:</p>\n\n<pre><code>use std::mem;\n\npub struct Tree {\n    children: Vec&lt;Option&lt;Box&lt;Tree&gt;&gt;&gt;,\n}\n\nimpl Tree {\n    pub fn mutate(&amp;mut self, x: i64) {\n        let idx: usize = unimplemented!();\n        let mut subtree: Option&lt;&amp;mut Box&lt;Tree&gt;&gt; =\n            self.children.get_mut(idx).unwrap().as_mut();\n\n        let mut new_tree = Tree::new();\n        mem::replace(&amp;mut subtree, Some(&amp;mut Box::new(new_tree)));\n    }\n\n    pub fn new() -&gt; Tree {\n        unimplemented!();\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>The problem is that <code>&amp;mut Box::new(...)</code> is a temporary reference, so you can't just copy it into another structure. Your use of <code>as_mut</code> on the <code>Option</code> is confusing; if you just <em>don't</em> do it your code works fine:</p>\n\n<pre><code>let mut subtree: &amp;mut Option&lt;Box&lt;Tree&gt;&gt; =\n    self.children.get_mut(idx).unwrap();\n\nlet mut new_tree = Tree::new();\nmem::replace(subtree, Some(Box::new(new_tree)));\n</code></pre>\n\n<p><a href=\"http://is.gd/yj0AjO\" rel=\"nofollow\">Here's it in the larger context.</a> <a href=\"http://is.gd/F1QFsp\" rel=\"nofollow\">You can simplify it a bit, too.</a></p>\n"}], "owner": {"reputation": 1342, "user_id": 3033123, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/bfb390ac1abb471ac1090039109d14a0?s=128&d=identicon&r=PG&f=1", "display_name": "zrneely", "link": "https://stackoverflow.com/users/3033123/zrneely"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 165, "favorite_count": 0, "accepted_answer_id": 32146938, "answer_count": 1, "score": 1, "last_activity_date": 1440181144, "creation_date": 1440180315, "last_edit_date": 1440180833, "question_id": 32146717, "link": "https://stackoverflow.com/questions/32146717/how-can-i-replace-an-option-within-a-vec", "title": "How can I replace an Option within a Vec?", "body": "<p>Here's the code (I also put it in a playpen here: <a href=\"http://is.gd/f9O3YG\" rel=\"nofollow\">http://is.gd/f9O3YG</a>):</p>\n\n<pre><code>use std::mem;\n\npub struct Tree {\n    children: Vec&lt;Option&lt;Box&lt;Tree&gt;&gt;&gt;,\n    // other fields\n}\n\nimpl Tree {\n    pub fn mutate(&amp;mut self, x: i64) {\n        if self.is_base_case() {\n            // base case\n            unimplemented!();\n        } else {\n            // recursive case\n            let idx: usize = unimplemented!();\n            let mut subtree: Option&lt;&amp;mut Box&lt;Tree&gt;&gt; = self.children.get_mut(idx).expect(\"child idx out of bounds\").as_mut();\n            match subtree {\n                Some(ref mut subtree) =&gt; unimplemented!(),\n                None =&gt; {\n                    let mut new_tree = Tree::new();\n                    // recurse on the new tree here\n                    mem::replace(&amp;mut subtree, Some(&amp;mut Box::new(new_tree)));\n                },\n            }\n        }\n    }\n\n    pub fn new() -&gt; Tree {\n        unimplemented!();\n    }\n\n    fn is_base_case(&amp;self) -&gt; bool {\n        unimplemented!();\n    }\n}\n\nfn main() {\n    println!(\"it compiled!\");\n}\n</code></pre>\n\n<p>I'm writing a data structure which is a type of tree. It stores its subtrees in a <code>Vec&lt;Option&lt;Box&lt;Tree&gt;&gt;&gt;</code>, since it's not guaranteed to have a subtree in every position. I'm trying to write a method which mutates the tree, possibly creating one of the subtrees if it doesn't exist.</p>\n\n<p>As you can see if you try to run the code in the playpen, my approach doesn't work. I'm not sure what the error message is telling me - my best guess is that it wants the newly created subtree to have the same lifetime as the subtree created on line 14, in order for the replacement to be safe. However, I'm not sure how to make it have that lifetime. It also made me think: since the new subtree will also need to be valid for the entire lifetime of the data structure, shouldn't it have the same lifetime as the parent tree? It might need to be shorter though, since there are other methods which can remove subtrees (I'm using <code>Option::take</code> for that, which works well enough - I checked the documentation for an opposite of that and couldn't find one). Is my approach flawed, and if not, how should I fix my implementation?</p>\n"}, {"tags": ["iterator", "rust", "lifetime"], "comments": [{"owner": {"reputation": 65, "user_id": 4301036, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3732a9cbfbdcfe302171931e49d7a3e9?s=128&d=identicon&r=PG&f=1", "display_name": "Spiderpig", "link": "https://stackoverflow.com/users/4301036/spiderpig"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1440175975, "post_id": 32145163, "comment_id": 52180596, "body": "Ok, thanks, I will try"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1440176061, "post_id": 32145163, "comment_id": 52180646, "body": "And make sure that your code is an <a href=\"/help/mcve\">MCVE</a>. You should be able to remove all fluff that is not <i>directly</i> relevant to your question."}, {"owner": {"reputation": 65, "user_id": 4301036, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3732a9cbfbdcfe302171931e49d7a3e9?s=128&d=identicon&r=PG&f=1", "display_name": "Spiderpig", "link": "https://stackoverflow.com/users/4301036/spiderpig"}, "edited": false, "score": 1, "creation_date": 1440176954, "post_id": 32145163, "comment_id": 52181125, "body": "So I redused my code, is this readable enough?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1440177460, "post_id": 32145163, "comment_id": 52181398, "body": "almost, the <code>Foo</code> type and field is irrelevant for this problem, and is the source of the confusion imo"}], "answers": [{"comments": [{"owner": {"reputation": 65, "user_id": 4301036, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3732a9cbfbdcfe302171931e49d7a3e9?s=128&d=identicon&r=PG&f=1", "display_name": "Spiderpig", "link": "https://stackoverflow.com/users/4301036/spiderpig"}, "edited": false, "score": 0, "creation_date": 1440178533, "post_id": 32145983, "comment_id": 52181945, "body": "Thanks, your explanation helped. But I still have a problem, because I actually need type Foo, but I guess I can cope with it by myself."}, {"owner": {"reputation": 65, "user_id": 4301036, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3732a9cbfbdcfe302171931e49d7a3e9?s=128&d=identicon&r=PG&f=1", "display_name": "Spiderpig", "link": "https://stackoverflow.com/users/4301036/spiderpig"}, "edited": false, "score": 0, "creation_date": 1440178737, "post_id": 32145983, "comment_id": 52182047, "body": "Thank you for the full example, didn&#39;t notice it at first."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 65, "user_id": 4301036, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3732a9cbfbdcfe302171931e49d7a3e9?s=128&d=identicon&r=PG&f=1", "display_name": "Spiderpig", "link": "https://stackoverflow.com/users/4301036/spiderpig"}, "edited": false, "score": 0, "creation_date": 1440190837, "post_id": 32145983, "comment_id": 52187771, "body": "you could actually separate the lifetimes of the <code>foo</code> reference of <code>Rows</code> and the lifetime of the <code>rows</code> reference of <code>RowsIter</code>, but most likely you don&#39;t need that. I simply used the same lifetime for both in the full example. See here for an example where the lifetimes are different: <a href=\"http://is.gd/hb09uj\" rel=\"nofollow noreferrer\">is.gd/hb09uj</a>"}, {"owner": {"reputation": 65, "user_id": 4301036, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3732a9cbfbdcfe302171931e49d7a3e9?s=128&d=identicon&r=PG&f=1", "display_name": "Spiderpig", "link": "https://stackoverflow.com/users/4301036/spiderpig"}, "edited": false, "score": 0, "creation_date": 1440194433, "post_id": 32145983, "comment_id": 52188983, "body": "Thanks again. Maybe you could look at this code and explain why implementation for Foo works, but it doesn&#39;t work for FooMut? Link:  [<a href=\"http://is.gd/5sCMHV\" rel=\"nofollow noreferrer\">is.gd/5sCMHV</a> ]"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 65, "user_id": 4301036, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3732a9cbfbdcfe302171931e49d7a3e9?s=128&d=identicon&r=PG&f=1", "display_name": "Spiderpig", "link": "https://stackoverflow.com/users/4301036/spiderpig"}, "edited": false, "score": 0, "creation_date": 1440238308, "post_id": 32145983, "comment_id": 52198037, "body": "because if you call <code>next</code> twice, you&#39;d end up with two mutable references to the same object"}, {"owner": {"reputation": 65, "user_id": 4301036, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3732a9cbfbdcfe302171931e49d7a3e9?s=128&d=identicon&r=PG&f=1", "display_name": "Spiderpig", "link": "https://stackoverflow.com/users/4301036/spiderpig"}, "edited": false, "score": 0, "creation_date": 1440238433, "post_id": 32145983, "comment_id": 52198072, "body": "Thank you! It makes sense to me now."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 2, "last_activity_date": 1440177545, "creation_date": 1440177545, "answer_id": 32145983, "question_id": 32145163, "link": "https://stackoverflow.com/questions/32145163/lifetime-issue-when-implementing-iterator/32145983#32145983", "title": "Lifetime issue when implementing Iterator", "body": "<p>The lifetime <code>'a</code> in the <code>Row</code> type refers only to one field of the type. The references you are returning have nothing to do with that lifetime. The <code>Iterator</code> trait does not allow you to return lifetimes into the iterator-object itself. That would require adding a new lifetime to the <code>next</code> function.</p>\n\n<p>I suggest you create a <code>RowsIterator</code> type with a reference to your <code>Rows</code> object and handle the iterator-specific stuff in there:</p>\n\n<pre><code>struct Stripe&lt;'a&gt; {\n    cells: &amp;'a [u32],\n}\n\nstruct Rows {\n    vec: Vec&lt;u32&gt;,\n}\n\nstruct RowsIter&lt;'a&gt; {\n    rows: &amp;'a Rows,\n    first: bool,\n}\n\nimpl&lt;'a&gt; std::iter::Iterator for RowsIter&lt;'a&gt; {\n    type Item = Stripe&lt;'a&gt;;\n    fn next(&amp;mut self) -&gt; Option&lt;Stripe&lt;'a&gt;&gt; {\n        if self.first {\n            self.first = false;\n            Some(\n                Stripe {\n                    cells: &amp;self.rows.vec[0..1],\n                }\n            )\n        } else {\n            None\n        }\n    }\n}\n</code></pre>\n\n<p>Full example in the <a href=\"http://is.gd/zupXNo\" rel=\"nofollow\">playground</a></p>\n"}], "owner": {"reputation": 65, "user_id": 4301036, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3732a9cbfbdcfe302171931e49d7a3e9?s=128&d=identicon&r=PG&f=1", "display_name": "Spiderpig", "link": "https://stackoverflow.com/users/4301036/spiderpig"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 145, "favorite_count": 0, "accepted_answer_id": 32145983, "answer_count": 1, "score": 5, "last_activity_date": 1440177545, "creation_date": 1440174284, "last_edit_date": 1440176903, "question_id": 32145163, "link": "https://stackoverflow.com/questions/32145163/lifetime-issue-when-implementing-iterator", "title": "Lifetime issue when implementing Iterator", "body": "<p>I was implementing the <code>Iterator</code> trait for several structs and encountered some problems. Why is implementing <code>Iterator</code> for <code>Rows</code> shows error?\nHere is a link: <a href=\"https://play.rust-lang.org/?gist=41cd51f3c4837f5ffaea&amp;version=stable\" rel=\"nofollow\">link to playground</a></p>\n\n<p>Basically why this doesn't work?</p>\n\n<pre><code>struct Stripe&lt;'a&gt; {\n    cells: &amp;'a [u32],\n}\n\nstruct Rows&lt;'a&gt; {\n    foo: &amp;'a Foo,\n    vec: Vec&lt;u32&gt;,\n    first: bool,\n}\n\nimpl&lt;'a&gt; std::iter::Iterator for Rows&lt;'a&gt; {\n    type Item = Stripe&lt;'a&gt;;\n    fn next(&amp;mut self) -&gt; Option&lt;Stripe&lt;'a&gt;&gt; {\n        if self.first {\n            self.first = false;\n            Some(\n                Stripe {\n                    cells: &amp;self.vec[0..1],\n                }\n            )\n        } else {\n            None\n        }\n    }\n}\n</code></pre>\n"}, {"tags": ["rust", "ownership", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 2, "last_activity_date": 1440156557, "creation_date": 1440156557, "answer_id": 32139179, "question_id": 32138814, "link": "https://stackoverflow.com/questions/32138814/ownership-error-using-builder-pattern/32139179#32139179", "title": "Ownership error using builder pattern", "body": "<p>Because you don't store the builder anywhere.  If it's not stored anywhere, it only exists for, at most, the duration of that expression.  So at the end of the expression, you have a <code>&amp;mut MediaType</code> pointing to a value that is about to be destroyed.</p>\n\n<p>If you look at the example in the linked doc, the author either uses the builder entirely in a single expression <em>or</em> he stores the result of the <code>::new()</code> call.  You can't borrow a temporary and then store that borrow.</p>\n"}], "owner": {"reputation": 1706, "user_id": 4255842, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/b0d7dfd98472547776f7d23112d000f5?s=128&d=identicon&r=PG&f=1", "display_name": "Pyfisch", "link": "https://stackoverflow.com/users/4255842/pyfisch"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 178, "favorite_count": 0, "closed_date": 1440160226, "accepted_answer_id": 32139179, "answer_count": 1, "score": 3, "last_activity_date": 1440156557, "creation_date": 1440155416, "question_id": 32138814, "link": "https://stackoverflow.com/questions/32138814/ownership-error-using-builder-pattern", "closed_reason": "Duplicate", "title": "Ownership error using builder pattern", "body": "<p>I tried to write an API following the <a href=\"https://aturon.github.io/ownership/builders.html\" rel=\"nofollow\">Builder pattern</a> the example is much simplified but still the compliler complains that a borrowed value does not live long enough. </p>\n\n<pre><code>#[derive(Debug)]\npub struct MediaType {\n    toptype: Option&lt;String&gt;,\n    subtype: Option&lt;String&gt;,\n}\n\nimpl MediaType {\n    pub fn new() -&gt; MediaType {\n        MediaType {\n            toptype: None,\n            subtype: None,\n        }\n    }\n\n    pub fn toptype&lt;'a&gt;(&amp;'a mut self, toptype: Option&lt;String&gt;) -&gt; &amp;'a mut MediaType {\n        self.toptype = toptype;\n        self\n    }\n    pub fn subtype&lt;'a&gt;(&amp;'a mut self, subtype: Option&lt;String&gt;) -&gt; &amp;'a mut MediaType {\n        self.subtype = subtype;\n        self\n    }\n}\n\n\nfn main() {\n    let mut tag =  MediaType::new().toptype(Some(\"text\".to_owned())).subtype(Some(\"html\".to_owned()));\n    println!(\"{:?}\", tag);\n}\n</code></pre>\n\n<p>The resulting error message is:</p>\n\n<pre><code>&lt;anon&gt;:27:20: 27:36 error: borrowed value does not live long enough\n&lt;anon&gt;:27     let mut tag =  MediaType::new().toptype(Some(\"text\".to_owned())).subtype(Some(\"html\".to_owned()));\n                             ^~~~~~~~~~~~~~~~\n&lt;anon&gt;:27:103: 29:2 note: reference must be valid for the block suffix following statement 0 at 27:102...\n&lt;anon&gt;:27     let mut tag =  MediaType::new().toptype(Some(\"text\".to_owned())).subtype(Some(\"html\".to_owned()));\n&lt;anon&gt;:28     println!(\"{:?}\", tag);\n&lt;anon&gt;:29 }\n&lt;anon&gt;:27:5: 27:103 note: ...but borrowed value is only valid for the statement at 27:4\n&lt;anon&gt;:27     let mut tag =  MediaType::new().toptype(Some(\"text\".to_owned())).subtype(Some(\"html\".to_owned()));\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n&lt;anon&gt;:27:5: 27:103 help: consider using a `let` binding to increase its lifetime\n&lt;anon&gt;:27     let mut tag =  MediaType::new().toptype(Some(\"text\".to_owned())).subtype(Some(\"html\".to_owned()));\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\nplaypen: application terminated with error code 101\n</code></pre>\n\n<p>both using a two liner</p>\n\n<pre><code>let mut tag = MediaType::new();\ntag.toptype(Some(\"text\".to_owned())).subtype(Some(\"html\".to_owned()));\n</code></pre>\n\n<p>and directly printing MediaType</p>\n\n<pre><code>println!(\"{:?}\", MediaType::new().toptype(Some(\"text\".to_owned())).subtype(Some(\"html\".to_owned())));\n</code></pre>\n\n<p>do work. Why does the borrow checker complain although it does not complain when directly using the value and I followed the builder pattern example?</p>\n\n<p><a href=\"http://is.gd/aNJxcA\" rel=\"nofollow\">Rust Playground</a></p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 125, "user_id": 233300, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/422e7686483301fdc1dfdea6fb91cd05?s=128&d=identicon&r=PG", "display_name": "gnash", "link": "https://stackoverflow.com/users/233300/gnash"}, "edited": false, "score": 1, "creation_date": 1440166641, "post_id": 32132295, "comment_id": 52174674, "body": "Just to make sure, the String is moved and not copied in that case correct?  Does one have to explicitly copy in Rust (unlike C++)?"}, {"owner": {"reputation": 67160, "user_id": 1078084, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/wApmM.jpg?s=128&g=1", "display_name": "Akavall", "link": "https://stackoverflow.com/users/1078084/akavall"}, "edited": false, "score": 1, "creation_date": 1440211332, "post_id": 32132295, "comment_id": 52192528, "body": "<code>let as_str: Vec&lt;_&gt; = (1..6).map(|i| i.to_string()).collect()</code> is another way to achieve what OP is after."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1440130790, "creation_date": 1440130790, "answer_id": 32132295, "question_id": 32132218, "link": "https://stackoverflow.com/questions/32132218/how-do-i-transfer-ownership-of-strings/32132295#32132295", "title": "How do I transfer ownership of strings?", "body": "<p>Give the vector a <code>String</code>, not a reference to one. A <code>Foo</code> is owned, a <code>&amp;Foo</code> is borrowed.</p>\n\n<pre><code>fn main() {\n    let mut as_str: Vec&lt;String&gt; = Vec::new();\n    for i in [1, 2, 3, 4, 5].iter() {\n        let i_str = i.to_string();\n        as_str.push(i_str);\n    }\n}\n</code></pre>\n\n<p>In your example, you are allocating a <code>String</code> inside the for loop body, then taking a reference to it. Since nothing owns the <code>String</code>, it is dropped at the end of the loop body. That means that any references would become invalid. Rust prevents this memory safety violation.</p>\n\n<p>In the real world, you'd never need to specify the type here, type inference is enough:</p>\n\n<pre><code>fn main() {\n    let mut as_str = Vec::new();\n    for i in [1, 2, 3, 4, 5].iter() {\n        let i_str = i.to_string();\n        as_str.push(i_str);\n    }\n}\n</code></pre>\n\n<p>And you'd probably use <code>map</code> to convert one slice of things to another:</p>\n\n<pre><code>fn main() {\n    let as_str: Vec&lt;_&gt; = [1, 2, 3, 4, 5].iter().map(|i| i.to_string()).collect();\n}\n</code></pre>\n\n<p>Incidentally, it never makes sense to have a <code>&amp;String</code>; you might as well have a <code>&amp;str</code>.</p>\n"}], "owner": {"reputation": 125, "user_id": 233300, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/422e7686483301fdc1dfdea6fb91cd05?s=128&d=identicon&r=PG", "display_name": "gnash", "link": "https://stackoverflow.com/users/233300/gnash"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2517, "favorite_count": 1, "accepted_answer_id": 32132295, "answer_count": 1, "score": 6, "last_activity_date": 1440161414, "creation_date": 1440130174, "last_edit_date": 1440130695, "question_id": 32132218, "link": "https://stackoverflow.com/questions/32132218/how-do-i-transfer-ownership-of-strings", "title": "How do I transfer ownership of strings?", "body": "<p>I am new to Rust and have run into a problem similar to the following a few times:</p>\n\n<pre><code>fn main() {\n    let mut as_str: Vec&lt;&amp;String&gt; = Vec::new();\n    for i in [1, 2, 3, 4, 5].iter() {\n        let i_str = i.to_string();\n        as_str.push(&amp;i_str);\n    }\n}\n</code></pre>\n\n<p>Which yields the following error:</p>\n\n<pre><code>&lt;anon&gt;:6:22: 6:27 error: `i_str` does not live long enough\n&lt;anon&gt;:6         as_str.push(&amp;i_str);\n                          ^~~~~\n</code></pre>\n\n<p>How do I transfer ownership of the string to the vector (do not want to copy)?  Do I need a lifetime?  Should it be a str or a String (supposing I do not want to mutate the items themselves in the vector)?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 3, "last_activity_date": 1440123479, "creation_date": 1440123479, "answer_id": 32131384, "question_id": 32130876, "link": "https://stackoverflow.com/questions/32130876/instantiating-a-struct-parameterized-by-a-trait/32131384#32131384", "title": "Instantiating a struct parameterized by a trait", "body": "<p>When you specify a value for a generic type parameter, it has to be a concrete type, not a trait:</p>\n\n<pre><code>trait Migration {}\n\nstruct Foo;\nimpl Migration for Foo {}\n\nfn main() {\n    let migrations: MigrationIndex&lt;Foo&gt; = Default::default();\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 3, "last_activity_date": 1440143233, "creation_date": 1440143233, "answer_id": 32135004, "question_id": 32130876, "link": "https://stackoverflow.com/questions/32130876/instantiating-a-struct-parameterized-by-a-trait/32135004#32135004", "title": "Instantiating a struct parameterized by a trait", "body": "<p>When you use a generic, the generic argument needs to be of a single concrete type. This would cause all objects in the migrations <code>Vec</code> to be of the same type. From your description it does not sound like that's what you want. You want a <code>Vec</code> of different types that implement the same trait. This does not require generics:</p>\n\n<pre><code>#[derive(Default)]\nstruct MigrationIndex {\n    migrations: Vec&lt;Box&lt;Migration&gt;&gt;\n}\nimpl MigrationIndex {\n    // methods for managing the migrations...\n}\n</code></pre>\n\n<p>I also took the liberty of replacing your manual <code>Default</code> impl with the equivalent automatically generated one through the <code>derive</code> attribute.</p>\n\n<p>In fact, in your previous implementation, the <code>Box</code> was entirely unnecessary. If you have a concrete type, you can create a <code>Vec</code> of elements of that type directly. Only when you want to put in different types implementing the same trait do you need the <code>Box</code>, because these types might have different sizes.</p>\n"}], "owner": {"reputation": 79, "user_id": 3791276, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c090675513444a844805eecc77231f42?s=128&d=identicon&r=PG&f=1", "display_name": "user3791276", "link": "https://stackoverflow.com/users/3791276/user3791276"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 307, "favorite_count": 0, "accepted_answer_id": 32135004, "answer_count": 2, "score": 3, "last_activity_date": 1440143233, "creation_date": 1440119436, "last_edit_date": 1440131806, "question_id": 32130876, "link": "https://stackoverflow.com/questions/32130876/instantiating-a-struct-parameterized-by-a-trait", "title": "Instantiating a struct parameterized by a trait", "body": "<p>I'm building a webapp in Rust and trying to implement basic Rails-style database migrations for managing my database. In my code, <code>Migration</code> is a trait with <code>up</code> and <code>down</code> methods to apply and roll back the migration. Each individual database migration is a struct that implements the Migration trait. To keep track of database migrations in the correct order, I built a <code>MigrationIndex</code> class.</p>\n\n<pre><code>struct MigrationIndex&lt;T&gt; {\n    migrations: Vec&lt;Box&lt;T&gt;&gt;\n}\nimpl &lt;T: Migration&gt; MigrationIndex&lt;T&gt; {\n    // methods for managing the migrations...\n}\n\nimpl &lt;T: Migration&gt; Default for MigrationIndex&lt;T&gt; {\n    pub fn default() -&gt; MigrationIndex&lt;T&gt; {\n        MigrationIndex {\n            migrations: vec![]\n        }\n    }\n}\n</code></pre>\n\n<p>So I go to use my class:</p>\n\n<pre><code>let migrations: MigrationIndex = Default::default();\n</code></pre>\n\n<p>But the compiler errors on this line with <code>wrong number of type arguments: expected 1, found 0</code>. So I tried to add the missing trait parameter:</p>\n\n<pre><code>let migrations: MigrationIndex&lt;Migration&gt; = Default::default();\n</code></pre>\n\n<p>But on that line the compiler interprets Migration as a type, not a trait, and again fails to compile. At a guess I tried:</p>\n\n<pre><code>let migrations: MigrationIndex&lt;T: Migration&gt; = Default::default();\n</code></pre>\n\n<p>but that ends up being a syntax error. Now I'm stumped. If a type is parameterized by a trait, how do I specify that trait when I instantiate it?</p>\n"}, {"tags": ["node.js", "rust", "node-ffi"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1440083022, "post_id": 32120031, "comment_id": 52135912, "body": "You may be interested in <a href=\"http://jakegoulding.com/rust-ffi-omnibus/\" rel=\"nofollow noreferrer\"><i>The Rust FFI Omnibus</i></a> as well."}, {"owner": {"reputation": 73, "user_id": 5247718, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/d52Xx.jpg?s=128&g=1", "display_name": "anderspree", "link": "https://stackoverflow.com/users/5247718/anderspree"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440149725, "post_id": 32120031, "comment_id": 52164217, "body": "@Shepmaster oh this is amazing! I was looking for something like this!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440160915, "post_id": 32120031, "comment_id": 52170609, "body": "Great! Be sure to file any issues on Github if you are looking for any specific examples or if anything can be made clearer."}], "answers": [{"comments": [{"owner": {"reputation": 73, "user_id": 5247718, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/d52Xx.jpg?s=128&g=1", "display_name": "anderspree", "link": "https://stackoverflow.com/users/5247718/anderspree"}, "edited": false, "score": 1, "creation_date": 1440146076, "post_id": 32120359, "comment_id": 52161933, "body": "Thank you! that makes sense :)"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 9, "last_activity_date": 1440079273, "creation_date": 1440079273, "answer_id": 32120359, "question_id": 32120031, "link": "https://stackoverflow.com/questions/32120031/calling-rust-from-nodejs/32120359#32120359", "title": "Calling Rust from NodeJS", "body": "<p>The short answer: you cannot export any Rust function for FFI bindings, you need to specifically export Rust functions compatible with C.</p>\n\n<p>Specifically, this means that you need to expose only C-struct compatible objects OR expose opaque pointers (which can only be manipulated through Rust functions).</p>\n\n<p>In your case, <code>Vec&lt;Post&gt;</code> is not compatible with usage in FFI, because <code>Vec</code> is not.</p>\n\n<p>You can find more information in the <a href=\"https://doc.rust-lang.org/book/ffi.html\" rel=\"noreferrer\">FFI Guide</a>.</p>\n"}, {"tags": [], "owner": {"reputation": 10747, "user_id": 3232611, "user_type": "registered", "profile_image": "https://graph.facebook.com/706574971/picture?type=large", "display_name": "zainengineer", "link": "https://stackoverflow.com/users/3232611/zainengineer"}, "is_accepted": false, "score": -1, "last_activity_date": 1576629620, "last_edit_date": 1576629620, "creation_date": 1576627308, "answer_id": 59383795, "question_id": 32120031, "link": "https://stackoverflow.com/questions/32120031/calling-rust-from-nodejs/59383795#59383795", "title": "Calling Rust from NodeJS", "body": "<p>Some data types can be passed directly, using your approach</p>\n\n<p>Export Rust using FFI\n<a href=\"https://svartalf.info/posts/2019-03-01-exposing-ffi-from-the-rust-library/\" rel=\"nofollow noreferrer\">https://svartalf.info/posts/2019-03-01-exposing-ffi-from-the-rust-library/</a></p>\n\n<p>and then call it from nodejs from using something like <a href=\"https://github.com/node-ffi/node-ffi\" rel=\"nofollow noreferrer\">https://github.com/node-ffi/node-ffi</a></p>\n\n<p>May be not using structure that you require, but you can convert data in one or both ends.\nAs a last resort you can use JSON. There will be some overhead but not a lot</p>\n\n<p><a href=\"https://stackoverflow.com/a/42498913/3232611\">https://stackoverflow.com/a/42498913/3232611</a></p>\n\n<p>can use protocol buffers, if JSON performance is bottleneck, but in most cases its not worth complexity</p>\n"}], "owner": {"reputation": 73, "user_id": 5247718, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/d52Xx.jpg?s=128&g=1", "display_name": "anderspree", "link": "https://stackoverflow.com/users/5247718/anderspree"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2736, "favorite_count": 1, "accepted_answer_id": 32120359, "answer_count": 2, "score": 7, "last_activity_date": 1576629620, "creation_date": 1440078395, "last_edit_date": 1492102948, "question_id": 32120031, "link": "https://stackoverflow.com/questions/32120031/calling-rust-from-nodejs", "title": "Calling Rust from NodeJS", "body": "<p>I was trying to build a simple rust rss 'harvester' for my soup.io blog and then post those entries to diaspora with node.js (since there is an npm package for that) </p>\n\n<p>I want to learn how to use rust from node so this is why I'm building this project.</p>\n\n<p>My problem is that I don't know how to call the <code>ffi</code> function with the right types.</p>\n\n<pre><code>var lib = ffi.Library('target/debug/libmain', {\n    'get_soup': ['Vec&lt;Post&gt;', ['String']]\n});\n</code></pre>\n\n<p>The <code>'Vec&lt;Post&gt;'</code> doesn't work.\nI get that I have to use <code>ref</code> for that.\nBut I don't really know how and what that actually does. </p>\n\n<p>I understand that I have to translate the rust types to javascript?</p>\n\n<p><strong>How can I use <code>Vec&lt;Post&gt;</code> in my ffi function?</strong></p>\n\n<p>my github project for that: <a href=\"https://github.com/Realtin/suppe\" rel=\"noreferrer\">Realtin/suppe</a></p>\n\n<p>and here the relevant code:</p>\n\n<h1>Rust Code:</h1>\n\n<pre><code>extern crate rss;\nextern crate hyper;\n\nuse rss::Rss;\nuse std::io::prelude::*;\n\n#[derive(Debug)]\npub struct Post  {\n    title: String,\n    link: String,\n    description: String,\n}\n\nfn main() {\n    let user = \"realtin\".to_string();\n    let vec = get_soup(&amp;user);\n    println!(\"{:?}\", vec[vec.len()-1]);\n}\n\n#[no_mangle]\npub extern fn get_soup(user: &amp;str) -&gt;Vec&lt;Post&gt;{\n    let url = format!(\"http://{}.soup.io/rss\", user);\n    let mut vec = Vec::new();\n\n    let client = hyper::Client::new();\n    let mut response = client.get(&amp;url).send().unwrap();\n\n    let mut suppe = String::new();\n    let _= response.read_to_string(&amp;mut suppe);\n\n    let rss::Rss(channel) = suppe.parse::&lt;rss::Rss&gt;().unwrap();\n\n    for item in channel.items.into_iter().rev() {\n      let item_object = Post {\n           title: item.title.unwrap(),\n           link: item.link.unwrap(),\n           description: item.description.unwrap(),\n        };\n        vec.push(item_object);\n    }\n    return vec;\n}\n</code></pre>\n\n<h1>NodeJS code:</h1>\n\n<pre><code>var ref = require('ref');\nvar StructType = require(\"ref-struct\");\nvar ffi = require('ffi');\n\nvar Post = StructType({\n  title: String,\n  link: String,\n  description: String,\n});\n// var vecPost = ref.refType(ref.types.Object);\n\nvar lib = ffi.Library('target/debug/libmain', {\n    'get_soup': ['Vec&lt;Post&gt;', ['String']]\n});\n\nvar posts = lib.get_soup(\"realtin\");\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 3, "creation_date": 1440078792, "post_id": 32119978, "comment_id": 52132724, "body": "<code>String</code> <i>where</i>?  There&#39;s four different places <code>&amp;str</code> could be replaced with <code>String</code>, all with different reasons why it may or may not work.  Do you mean <i>just</i> changing the type of <code>l</code>?"}], "answers": [{"comments": [{"owner": {"reputation": 2403, "user_id": 3190054, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/b7de233f9b761d1d0d75d64b608aca88?s=128&d=identicon&r=PG&f=1", "display_name": "kezzos", "link": "https://stackoverflow.com/users/3190054/kezzos"}, "edited": false, "score": 0, "creation_date": 1440080847, "post_id": 32120478, "comment_id": 52134215, "body": "Thanks I was really stumped there for a while, that makes it very clear!"}, {"owner": {"reputation": 37741, "user_id": 3425536, "user_type": "registered", "accept_rate": 72, "profile_image": "https://graph.facebook.com/1484495923/picture?type=large", "display_name": "emlai", "link": "https://stackoverflow.com/users/3425536/emlai"}, "edited": false, "score": 0, "creation_date": 1440165851, "post_id": 32120478, "comment_id": 52174031, "body": "&quot;values are destroyed by Rust in reverse lexical order&quot; \u2013 Umm no, they&#39;re destroyed in reverse order of <i>declaration</i>: <a href=\"http://is.gd/LEBmOi\" rel=\"nofollow noreferrer\">is.gd/LEBmOi</a>"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1440178557, "post_id": 32120478, "comment_id": 52181953, "body": "&quot;lexical&quot; as in the order they appear lexically; <i>i.e.</i> in the text."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 5, "last_activity_date": 1440079587, "creation_date": 1440079587, "answer_id": 32120478, "question_id": 32119978, "link": "https://stackoverflow.com/questions/32119978/how-to-use-a-string-instead-of-str-in-iterator-if-else-block/32120478#32120478", "title": "How to use a String instead of &amp;str in iterator, if/else block", "body": "<p>Ok, let's boil this down to just the necessities:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::collections::HashMap;\n\nfn main() { \n    let mut hash = HashMap::&lt;&amp;str, &amp;str&gt;::new();\n    hash.insert(\"this\", \"value\");\n    let l: String = \"this is a borrowed string reference\".to_string();\n    hash.insert(&amp;l, \"stuff\");\n}\n</code></pre>\n\n<p>Compiling this gives us:</p>\n\n<pre><code>&lt;anon&gt;:7:18: 7:19 error: `l` does not live long enough\n&lt;anon&gt;:7     hash.insert(&amp;l, \"stuff\");\n                          ^\n&lt;anon&gt;:4:49: 8:2 note: reference must be valid for the block suffix following statement 0 at 4:48...\n&lt;anon&gt;:4     let mut hash = HashMap::&lt;&amp;str, &amp;str&gt;::new();\n&lt;anon&gt;:5     hash.insert(\"this\", \"value\");\n&lt;anon&gt;:6     let l: String = \"this is a borrowed string reference\".to_string();\n&lt;anon&gt;:7     hash.insert(&amp;l, \"stuff\");\n&lt;anon&gt;:8 }\n&lt;anon&gt;:6:71: 8:2 note: ...but borrowed value is only valid for the block suffix following statement 2 at 6:70\n&lt;anon&gt;:6     let l: String = \"this is a borrowed string reference\".to_string();\n&lt;anon&gt;:7     hash.insert(&amp;l, \"stuff\");\n&lt;anon&gt;:8 }\n</code></pre>\n\n<p>Which tells you more or less <em>exactly</em> what it won't work.  You try to insert a borrowed pointer to the <code>String</code> <code>l</code> into the hashmap.  However, the <code>String</code> simply doesn't live long enough.</p>\n\n<p>Specifically, values are destroyed by Rust in reverse lexical order.  So, when execution gets to the end of the function, Rust will deallocate <code>l</code> <em>first</em>, followed by <code>hash</code>.  This is a problem: it means that there is a window during which <code>hash</code> contains pointers to destroyed data, which Rust absolutely <em>will not allow</em>.</p>\n\n<p>The reason this works with a <code>&amp;str</code> is that a string literal <code>\"like this\"</code> is not merely <code>&amp;str</code>; it's actually <code>&amp;'static str</code>.  This means that a string literal \"lives\" for the entire duration of the program: it <em>never</em> gets destroyed, thus it's safe for the hashmap to hold a pointer to it.</p>\n\n<p>The solution is to ensure the <code>String</code> will outlive the <code>HashMap</code>:</p>\n\n<pre><code>use std::collections::HashMap;\n\nfn main() { \n    // Declare `l` here ...\n    let l;\n    let mut hash = HashMap::&lt;&amp;str, &amp;str&gt;::new();\n    hash.insert(\"this\", \"value\");\n\n    // ... but initialise it *here*.\n    l = \"this is a borrowed string reference\".to_string();\n    hash.insert(&amp;l, \"stuff\");\n}\n</code></pre>\n\n<p>Now, <code>hash</code> gets destroyed <em>first</em>, followed by <code>l</code>.  It's fine to leave a variable uninitialised, so long as you <em>do</em> initialise it prior to reading or using it.</p>\n"}, {"tags": [], "owner": {"reputation": 37741, "user_id": 3425536, "user_type": "registered", "accept_rate": 72, "profile_image": "https://graph.facebook.com/1484495923/picture?type=large", "display_name": "emlai", "link": "https://stackoverflow.com/users/3425536/emlai"}, "is_accepted": false, "score": 2, "last_activity_date": 1440080570, "last_edit_date": 1440080570, "creation_date": 1440079639, "answer_id": 32120490, "question_id": 32119978, "link": "https://stackoverflow.com/questions/32119978/how-to-use-a-string-instead-of-str-in-iterator-if-else-block/32120490#32120490", "title": "How to use a String instead of &amp;str in iterator, if/else block", "body": "<p>If you change <code>l</code> to <code>String</code> you get:</p>\n\n<blockquote>\n  <p>error: <code>l</code> does not live long enough</p>\n</blockquote>\n\n<p>Which is true:</p>\n\n<p><code>name</code> is a reference to one of the substrings of <code>l</code>. You're possibly inserting the <code>name</code> reference to <code>hash</code>, but the lifetime of <code>hash</code> is longer than the lifetime of <code>l</code>. Therefore when the lifetime of <code>l</code> ends, <code>hash</code> would contain invalid references. This is not allowed. F.ex. if you remove the <code>insert</code> line, Rust is happy.</p>\n\n<p>There are multiple ways to fix it, depending on your needs. One of them would be to make the lifetime of <code>hash</code> shorter than the lifetime of <code>l</code>, by instantiating <code>hash</code> after <code>l</code>:</p>\n\n<pre><code>use std::collections::{HashMap};\n\nfn main() { \n    // let l: &amp;str = \"this is a borrowed string reference\";\n    // If the above line was defined as:\n    let l: String = \"this is a string\".to_string();\n\n    let mut hash = HashMap::&lt;&amp;str, &amp;str&gt;::new();\n    hash.insert(\"this\", \"value\");\n\n    let mut all = l.split(\" \");   \n    let name: &amp;str = all.next().unwrap();\n\n    if hash.contains_key(name) == true {\n        hash.remove(name);\n    } else {\n        hash.insert(name, \"stuff\");\n    }\n}\n</code></pre>\n\n<p>Or, you could store copies of the strings in the map.</p>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 1, "last_activity_date": 1440079731, "creation_date": 1440079731, "answer_id": 32120535, "question_id": 32119978, "link": "https://stackoverflow.com/questions/32119978/how-to-use-a-string-instead-of-str-in-iterator-if-else-block/32120535#32120535", "title": "How to use a String instead of &amp;str in iterator, if/else block", "body": "<p>You have a lifetime issue.</p>\n\n<p>Any object inserted into <code>hash</code> must only reference things that outlive <code>hash</code> (or not reference anything at all).</p>\n\n<p>However, here, you define <code>l</code> after <code>hash</code> and therefore <code>l</code> has a shorter lifetime. In turn this means that <code>name</code> which references <code>l</code>'s buffer has a shorter lifetime than <code>hash</code> and thus <code>name</code> is not suitable to be inserted into <code>hash</code> (though it can be used to search/remove).</p>\n\n<p>Switching the order in which <code>l</code> and <code>hash</code> are defined make it work:</p>\n\n<pre><code>use std::collections::{HashMap};\n\nfn main() { \n    let l: String = \"this is a string\".to_string();\n\n    let mut hash = HashMap::&lt;&amp;str, &amp;str&gt;::new();\n    hash.insert(\"this\", \"value\");\n\n    let mut all = l.split(\" \");   \n    let name: &amp;str = all.next().unwrap();\n\n    if hash.contains_key(name) == true {\n        hash.remove(name);\n    } else {\n        hash.insert(name, \"stuff\");\n    }\n}\n</code></pre>\n\n<p>If this is not possible, then use a <code>HashMap&lt;String, String&gt;</code> to avoid lifetime issues.</p>\n"}], "owner": {"reputation": 2403, "user_id": 3190054, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/b7de233f9b761d1d0d75d64b608aca88?s=128&d=identicon&r=PG&f=1", "display_name": "kezzos", "link": "https://stackoverflow.com/users/3190054/kezzos"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 145, "favorite_count": 0, "accepted_answer_id": 32120478, "answer_count": 3, "score": 3, "last_activity_date": 1440080570, "creation_date": 1440078250, "last_edit_date": 1440079095, "question_id": 32119978, "link": "https://stackoverflow.com/questions/32119978/how-to-use-a-string-instead-of-str-in-iterator-if-else-block", "title": "How to use a String instead of &amp;str in iterator, if/else block", "body": "<p>Would someone be kind enough to explain to me why using a <code>String</code> in this script does not work but <code>&amp;str</code> does. Additionally how can I modify it so that it will work with <code>String</code>'s? [version 1.2]</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::collections::{HashMap};\n\nfn main() { \n\n    let mut hash = HashMap::&lt;&amp;str, &amp;str&gt;::new();\n    hash.insert(\"this\", \"value\");\n    let l: &amp;str = \"this is a borrowed string reference\";\n    // If the above line was defined as:\n    //let l: String = \"this is a string\".to_string();\n\n    let mut all = l.split(\" \");   \n    let name: &amp;str = all.next().unwrap();\n\n    if hash.contains_key(name) == true {\n        hash.remove(name);\n    } else {\n        hash.insert(name, \"stuff\");\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "edited": false, "score": 0, "creation_date": 1440058190, "post_id": 32112221, "comment_id": 52118800, "body": "Thanks for the link to the arithmetic operations! I wasn&#39;t aware of them."}], "tags": [], "owner": {"reputation": 3181, "user_id": 4998184, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/29c803cb4341d0ff630cb3ca04ab7251?s=128&d=identicon&r=PG", "display_name": "eulerdisk", "link": "https://stackoverflow.com/users/4998184/eulerdisk"}, "is_accepted": false, "score": 8, "last_activity_date": 1440056551, "last_edit_date": 1440056551, "creation_date": 1440056219, "answer_id": 32112221, "question_id": 32111388, "link": "https://stackoverflow.com/questions/32111388/idiomatic-way-to-add-a-u8-to-i8/32112221#32112221", "title": "Idiomatic way to add a u8 to i8", "body": "<p>You can do this to avoid the overflow and wrap the addition:</p>\n\n<pre><code>val = (val as i8).wrapping_add(delta) as u8;\n</code></pre>\n\n<p><a href=\"https://doc.rust-lang.org/stable/std/primitive.u8.html#method.wrapping_add\">Look here for all the arithmetic operations</a></p>\n"}, {"comments": [{"owner": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "edited": false, "score": 0, "creation_date": 1440058146, "post_id": 32112603, "comment_id": 52118775, "body": "If I write <code>val += delta</code>, it&#39;s pretty evident what a result type should be. I would be OK to use an <code>unsafe</code> block in this particular case to let the compiler know that I know what I&#39;m doing."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "edited": false, "score": 0, "creation_date": 1440058923, "post_id": 32112603, "comment_id": 52119243, "body": "@Tomo: Ah, yes, sorry... you&#39;ve hit a limitation of <code>+=</code> at the moment, but a RFC in final comment period is about to change things :)"}, {"owner": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "edited": false, "score": 0, "creation_date": 1440059993, "post_id": 32112603, "comment_id": 52119862, "body": "Cool. Which RFC number is this?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "edited": false, "score": 0, "creation_date": 1440060558, "post_id": 32112603, "comment_id": 52120188, "body": "@Tomo: My bad, I should have only commented <i>after</i> I edited ^^"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 9, "last_activity_date": 1440059184, "last_edit_date": 1440059184, "creation_date": 1440057379, "answer_id": 32112603, "question_id": 32111388, "link": "https://stackoverflow.com/questions/32111388/idiomatic-way-to-add-a-u8-to-i8/32112603#32112603", "title": "Idiomatic way to add a u8 to i8", "body": "<blockquote>\n  <p>Is there an idiomatic way to add a <code>u8</code> to a <code>i8</code>?</p>\n</blockquote>\n\n<p>The problem of adding a <code>u8</code> to a <code>i8</code> (with <code>+</code>) is: what type should the result be? Neither <code>u8</code> or <code>i8</code> is better, and using <code>i16</code> while correct would probably be surprising.</p>\n\n<p>Thus, for now, mixed-integrals operands are not supported. The idiomatic way is to cast both operands to a common type, which will also be the type of the result. This is already what you are doing.</p>\n\n<blockquote>\n  <p>But, what of <code>u8 += i8</code> ?</p>\n</blockquote>\n\n<p>Unfortunately, at the moment, this is sugar for <code>u8 = u8 + i8</code> and therefore has all the limitations of <code>+</code> even though the result type would not be an issue.</p>\n\n<p>As all annoying limitations of Rust, there's a RFC for it! This is <a href=\"https://github.com/rust-lang/rfcs/pull/953\">PR #953: Overloaded Assignment Operations</a>. This RFC is in final comment period so a decision is expected soon, and hopefully this means that it will be accepted and Rust will gain support for mixed-integrals assignment operations.</p>\n\n<hr>\n\n<p>As a personal preference, for now, I would go for:</p>\n\n<pre><code>val = (val as i16 + delta as i16) as u8;\n</code></pre>\n\n<p>which avoids the branch.</p>\n"}], "owner": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1934, "favorite_count": 0, "accepted_answer_id": 32112603, "answer_count": 2, "score": 8, "last_activity_date": 1440059184, "creation_date": 1440053521, "question_id": 32111388, "link": "https://stackoverflow.com/questions/32111388/idiomatic-way-to-add-a-u8-to-i8", "title": "Idiomatic way to add a u8 to i8", "body": "<p>Consider the following code:</p>\n\n<pre><code>let mut val : u8 = 125;\nlet deltas : [i8; 4] = [5, -5, 5, 5];\n\nlet delta = select_current_delta(deltas);\n\nval += delta;\n</code></pre>\n\n<p>This seems simple. I want to either increase or decrease a byte value based on some criteria (and I have a way to prevent overflow of a <code>u8</code> value).</p>\n\n<p>This, of course, does not compile:</p>\n\n<pre><code> &gt; rustc lala.rs\n lala.rs:7:12: 7:17 error: mismatched types:\n  expected `u8`,\n     found `i8`\n (expected u8,\n     found i8) [E0308]\n lala.rs:7     val += delta;\n                      ^~~~~\n</code></pre>\n\n<p>Duh! Mixing signed and unsigned types seems to be forbidden in Rust. How about this?</p>\n\n<pre><code>val = (val as i8 + delta) as u8;\n</code></pre>\n\n<p>This compiles, but when I try to run it...</p>\n\n<pre><code>&gt; ./lala\nthread '&lt;main&gt;' panicked at 'arithmetic operation overflowed', lala.rs:7\n</code></pre>\n\n<p>Yeah, <code>i8</code>'s max value is 125, adding 5 will overflow, even though the value is perfectly fine for <code>u8</code>.</p>\n\n<p>I was able come up with two solutions that work:</p>\n\n<pre><code>val = (val as i16 + delta as i16) as u8;\n// or\nif delta &lt; 0 { val -= (-delta) as u8 }\nelse { val += delta as u8}\n</code></pre>\n\n<p>Neither of those seem elegant to me. Is there an idiomatic way to add a u8 to a i8?</p>\n"}]