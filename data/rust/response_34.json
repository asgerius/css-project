[{"tags": ["pointers", "memory-management", "rust"], "comments": [{"owner": {"reputation": 95188, "user_id": 440119, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/5ec9ca2a92a94a5470396073129d79e7?s=128&d=identicon&r=PG", "display_name": "Benjamin Lindley", "link": "https://stackoverflow.com/users/440119/benjamin-lindley"}, "edited": false, "score": 4, "creation_date": 1441218724, "post_id": 32360500, "comment_id": 52593997, "body": "<i>&quot;usually non-primitive types/Data-structures are located at the heap&quot;</i> -- Where did you read this? The excerpt you quoted doesn&#39;t say or imply it. There are some languages where this is the case (like Java), but with Rust, the type of an object does not determine where that object is located. You can choose to create an object of any type on either the stack or the heap."}, {"owner": {"reputation": 215, "user_id": 3698624, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/2875386f2772c39fbfc6149282c86748?s=128&d=identicon&r=PG&f=1", "display_name": "user3698624", "link": "https://stackoverflow.com/users/3698624/user3698624"}, "reply_to_user": {"reputation": 95188, "user_id": 440119, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/5ec9ca2a92a94a5470396073129d79e7?s=128&d=identicon&r=PG", "display_name": "Benjamin Lindley", "link": "https://stackoverflow.com/users/440119/benjamin-lindley"}, "edited": false, "score": 0, "creation_date": 1441219258, "post_id": 32360500, "comment_id": 52594282, "body": "&gt;&gt;_Primitive values such as numbers (like 32 in the fiure), characters, and true/false values are stored on the stack, while the value of more complex objects that could grow in size are stored in the heap Memory_&lt;&lt; Rust Essentials (book)."}, {"owner": {"reputation": 95188, "user_id": 440119, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/5ec9ca2a92a94a5470396073129d79e7?s=128&d=identicon&r=PG", "display_name": "Benjamin Lindley", "link": "https://stackoverflow.com/users/440119/benjamin-lindley"}, "edited": false, "score": 2, "creation_date": 1441220310, "post_id": 32360500, "comment_id": 52594895, "body": "I don&#39;t have that book, but did a search on that text, and was able to view a portion of it. He doesn&#39;t expound upon it too much, but I would guess (since he refers to complex objects that could grow in size), he is referring to dynamically allocating structures like <code>String</code> and <code>Vec</code>. But even in that case, the objects themselves can be created on the stack, but internally, they hold pointers to values on the heap. But those values weren&#39;t put on the heap because of what type they are. They were put there explicitly by the implementation functions of <code>String</code> and <code>Vec</code>."}, {"owner": {"reputation": 215, "user_id": 3698624, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/2875386f2772c39fbfc6149282c86748?s=128&d=identicon&r=PG&f=1", "display_name": "user3698624", "link": "https://stackoverflow.com/users/3698624/user3698624"}, "reply_to_user": {"reputation": 95188, "user_id": 440119, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/5ec9ca2a92a94a5470396073129d79e7?s=128&d=identicon&r=PG", "display_name": "Benjamin Lindley", "link": "https://stackoverflow.com/users/440119/benjamin-lindley"}, "edited": false, "score": 0, "creation_date": 1441221334, "post_id": 32360500, "comment_id": 52595433, "body": "Thank you very much for making such an effort!"}], "answers": [{"tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": true, "score": 5, "last_activity_date": 1441222647, "last_edit_date": 1441222647, "creation_date": 1441218598, "answer_id": 32360612, "question_id": 32360500, "link": "https://stackoverflow.com/questions/32360500/stack-reference-of-a-heap-object/32360612#32360612", "title": "Stack-Reference of a Heap-Object", "body": "<p>Your <code>Point</code> actually resides on the stack \u2013 there is no <code>Box</code> or other structure to put it on the heap.</p>\n\n<p>Yes, it is possible (though obviously unsafe) to pass an address to a <code>*ptr</code> (this is a bare pointer) and cast it to a <code>&amp;ptr</code> \u2013 this is unsafe, because the latter are guaranteed to be non-null.</p>\n\n<p>As such, it is of course <em>possible</em> (though wildly unsafe) to access off-heap memory, as long as the underlying system lets you do it (most current systems will probably just kill your process with a Segmentation Fault).</p>\n"}], "owner": {"reputation": 215, "user_id": 3698624, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/2875386f2772c39fbfc6149282c86748?s=128&d=identicon&r=PG&f=1", "display_name": "user3698624", "link": "https://stackoverflow.com/users/3698624/user3698624"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 414, "favorite_count": 0, "accepted_answer_id": 32360612, "answer_count": 1, "score": 2, "last_activity_date": 1441222647, "creation_date": 1441218135, "last_edit_date": 1441219673, "question_id": 32360500, "link": "https://stackoverflow.com/questions/32360500/stack-reference-of-a-heap-object", "title": "Stack-Reference of a Heap-Object", "body": "<p>After reading several articles about <strong>The Heap and the Stack</strong> (Rust-lang) I learned that non-primitive types / data-structures are usually located on the heap, leaving a pointer in the stack, pointing to the address where the specific object is located at the heap.</p>\n\n<blockquote>\n  <p>Heap values are referenced by a variable on the stack, which contains the memory address of the object on the heap. <em>[Rust Essentials, Ivo Balbaert]</em></p>\n</blockquote>\n\n<p>Considering the following example:</p>\n\n<pre><code>struct Point {\n    x: u32,\n    y: u32,\n}\n\nfn main() {\n    let point = Point { x: 8, y: 16 };\n\n    // Is this address the value of the pointer at the stack, which points to\n    // the point-struct allocated in the heap, or is the printed address the \n    // heap-object's one?\n    println!(\"The struct is located at the address {:p}\", &amp;point);\n}\n</code></pre>\n\n<p>In my case, the output was:</p>\n\n<blockquote>\n  <p>The struct is located at the address 0x24fc58</p>\n</blockquote>\n\n<p>So, is <strong>0x24fc58</strong> the value (address) the stack-reference points to, or is it the direct memory-address where the struct-instance is allocated in the heap?</p>\n\n<p>Some additional little questions:</p>\n\n<ul>\n<li>Is this a \"raw-address\", or the address relative to the program's address-space?</li>\n<li>Is it possible to initialize a pointer by directly passing a hex address?</li>\n<li>Is it possible to access memory-addresses which don't lay in the program's address-space?</li>\n</ul>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 10598, "user_id": 371137, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/JAV6o.jpg?s=128&g=1", "display_name": "Perseids", "link": "https://stackoverflow.com/users/371137/perseids"}, "edited": false, "score": 0, "creation_date": 1441220661, "post_id": 32360842, "comment_id": 52595069, "body": "The distinction between concrete lifetimes and generic lifetime parameters is really helpful. Using the same words for both, the explanations I&#39;ve so far read also mix together both <i>concepts</i>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 10598, "user_id": 371137, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/JAV6o.jpg?s=128&g=1", "display_name": "Perseids", "link": "https://stackoverflow.com/users/371137/perseids"}, "edited": false, "score": 0, "creation_date": 1441220773, "post_id": 32360842, "comment_id": 52595126, "body": "@Perseids speaking honestly, I&#39;m not sure that these are the accepted terms, but I&#39;m doing my best to make them so. ^_^ I&#39;m also trying to be better about saying one or the other when they are ambiguous, but it&#39;s so darned convenient to just say &quot;lifetime&quot;."}, {"owner": {"reputation": 1064, "user_id": 865424, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/032f47cb2908b013d42a4614bcc94bb5?s=128&d=identicon&r=PG", "display_name": "B. Striegel", "link": "https://stackoverflow.com/users/865424/b-striegel"}, "edited": false, "score": 4, "creation_date": 1441229795, "post_id": 32360842, "comment_id": 52599713, "body": "We may be getting into the weeds here, but it may be useful to clarify the statement that all programming languages have concrete lifetimes. When using garbage collection, lifetimes can actually be <i>dynamically</i> extended, which is not the case with lifetimes as described by Rust&#39;s lifetime parameters, which are solely compile-time constructs (you&#39;d have to use something like the <code>Rc</code> pointer for dynamic lifetime extension like you&#39;d get in a garbage collected language)."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1064, "user_id": 865424, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/032f47cb2908b013d42a4614bcc94bb5?s=128&d=identicon&r=PG", "display_name": "B. Striegel", "link": "https://stackoverflow.com/users/865424/b-striegel"}, "edited": false, "score": 1, "creation_date": 1441262817, "post_id": 32360842, "comment_id": 52609130, "body": "@B.Striegel: Without reaching for <code>Rc</code>, the buffer of <code>String</code> can see its lifetime &quot;extended&quot; when the <code>String</code> is returned."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 17, "last_activity_date": 1441219442, "creation_date": 1441219442, "answer_id": 32360842, "question_id": 32359619, "link": "https://stackoverflow.com/questions/32359619/do-rust-lifetimes-influence-the-semantics-of-the-compiled-program/32360842#32360842", "title": "Do Rust lifetimes influence the semantics of the compiled program?", "body": "<p>No, lifetimes do not affect the generated machine code in any way. At the end of the day, it's all \"just pointers\" to the compiled code.</p>\n\n<p>Because we are humans speaking a human language, we tend to lump two different but related concepts together: <em>concrete lifetimes</em> and <em>generic lifetime parameters</em>.</p>\n\n<p><strong>All</strong> programming languages have concrete lifetimes. That just corresponds to when a resource will be released. That's what your example shows and indeed, C++ works the same as Rust does there. This is often known as Resource Acquisition Is Initialization (RAII). Garbage-collected languages have lifetimes too, but they can be harder to nail down exactly when they end.</p>\n\n<p>What makes Rust neat in this area are the generic lifetime parameters, the things we know as <code>'a</code> or <code>'static</code>. These allow the compiler to track the underlying pointers so that the programmer doesn't need to worry if the pointer will remain valid long enough. This works for storing references in structs and passing them to and from functions.</p>\n"}], "owner": {"reputation": 10598, "user_id": 371137, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/JAV6o.jpg?s=128&g=1", "display_name": "Perseids", "link": "https://stackoverflow.com/users/371137/perseids"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 813, "favorite_count": 1, "accepted_answer_id": 32360842, "answer_count": 1, "score": 12, "last_activity_date": 1522748491, "creation_date": 1441215133, "last_edit_date": 1522748491, "question_id": 32359619, "link": "https://stackoverflow.com/questions/32359619/do-rust-lifetimes-influence-the-semantics-of-the-compiled-program", "title": "Do Rust lifetimes influence the semantics of the compiled program?", "body": "<p>I'm trying to grok lifetimes in Rust and asked myself whether they are \"just\" a safety measure (and a way to communicate how safety is ensured, or not, in the case of errors) or if there are cases where different choices of lifetimes actually change how the program runs, i.e. whether lifetimes make a semantic difference to the compiled program.</p>\n\n<p>And with \"lifetimes\" I refer to all the pesky little <code>'a</code>, <code>'b</code>, <code>'static</code> markers we include to make the borrow checker happy. Of course, writing </p>\n\n<pre><code>{\n    let foo = File::open(\"foo.txt\")?;\n} \nfoo.write_all(b\"bar\");\n</code></pre>\n\n<p>instead of</p>\n\n<pre><code>let foo = File::open(\"foo.txt\")?;\nfoo.write_all(b\"bar\");\n</code></pre>\n\n<p>will close the file descriptor before the write occurs, even if we could access foo afterwards, but that kind of scoping and destructor-calling also happens in C++.</p>\n"}, {"tags": ["iterator", "rust"], "answers": [{"tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": false, "score": 2, "last_activity_date": 1441202132, "creation_date": 1441202132, "answer_id": 32355169, "question_id": 32354947, "link": "https://stackoverflow.com/questions/32354947/type-issue-with-iterator-collect/32355169#32355169", "title": "Type issue with Iterator collect", "body": "<p>The problem is that while the references may be copied, the tuples cannot.</p>\n\n<p>However, if you don't need the pairs anymore, you can iterate by values:</p>\n\n<pre><code>use std::collections::HashMap;\n\nfn main() {\n  let pairs = vec!((\"foo\", \"bar\"), (\"toto\", \"tata\"));\n  let map: HashMap&lt;&amp;'static str, &amp;'static str&gt; = pairs.into_iter().collect();\n  println!(\"{:?}\", map);\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 34, "last_activity_date": 1441263870, "last_edit_date": 1441263870, "creation_date": 1441202749, "answer_id": 32355408, "question_id": 32354947, "link": "https://stackoverflow.com/questions/32354947/type-issue-with-iterator-collect/32355408#32355408", "title": "Type issue with Iterator collect", "body": "<p>The type <code>&amp;(&amp;str, &amp;str)</code> comes from what <a href=\"http://doc.rust-lang.org/std/primitive.slice.html#method.iter\" rel=\"noreferrer\"><code>iter()</code></a> on a <code>Vec</code> returns:</p>\n\n<pre><code>fn iter(&amp;self) -&gt; Iter&lt;T&gt;\n</code></pre>\n\n<p>where <a href=\"http://doc.rust-lang.org/std/slice/struct.Iter.html\" rel=\"noreferrer\"><code>Iter&lt;T&gt;</code></a> implements <code>Iterator&lt;Item=&amp;T&gt;</code>:</p>\n\n<pre><code>impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {\n    type Item = &amp;'a T\n    ...\n}\n</code></pre>\n\n<p>In other words, <code>iter()</code> on a vector returns an iterator yielding references into the vector.</p>\n\n<p><code>cloned()</code> solves the problem because it is an iterator adapter which converts <code>Iterator&lt;Item=&amp;T&gt;</code> to <code>Iterator&lt;Item=T&gt;</code> if <code>T</code> is cloneable. You can think of it as a shorthand for <code>map(|v| v.clone())</code>:</p>\n\n<pre><code>let v1: Vec&lt;i32&gt; = vec![1, 2, 3, 4];\nlet v2: Vec&lt;_&gt; = v1.iter().cloned().collect();\nlet v3: Vec&lt;_&gt; = v1.iter().map(|v| v.clone()).collect();\nassert_eq!(v2, v3);\n</code></pre>\n\n<p>It happens that <code>(&amp;str, &amp;str)</code> is cloneable because each tuple component is also cloneable (all references are), so <code>cloned()</code> would return an object which implements <code>Iterator&lt;Item=(&amp;str, &amp;str)&gt;</code> - exactly what <code>collect()</code> needs to create a <code>HashMap</code>.</p>\n\n<p>Alternatively, you can use <code>into_iter()</code> to get <code>Iterator&lt;Item=T&gt;</code> from <code>Vec&lt;T&gt;</code>, but then the original vector will be consumed:</p>\n\n<pre><code>use std::collections::HashMap;\n\nfn main() {\n    let pairs = vec!((\"foo\", \"bar\"), (\"toto\", \"tata\"));\n    let map: HashMap&lt;&amp;str, &amp;str&gt; = pairs.into_iter().collect();\n    println!(\"{:?}\", map);\n}\n</code></pre>\n"}], "owner": {"reputation": 12171, "user_id": 432589, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/hPBqu.jpg?s=128&g=1", "display_name": "Jcs", "link": "https://stackoverflow.com/users/432589/jcs"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 14510, "favorite_count": 6, "accepted_answer_id": 32355408, "answer_count": 2, "score": 25, "last_activity_date": 1441280662, "creation_date": 1441201541, "last_edit_date": 1441280662, "question_id": 32354947, "link": "https://stackoverflow.com/questions/32354947/type-issue-with-iterator-collect", "title": "Type issue with Iterator collect", "body": "<p>I am trying to convert a vector of <code>&amp;str</code> pairs into a <code>HashMap</code> with the following code snippet:</p>\n\n<pre><code>use std::collections::HashMap;\n\nfn main() {\n  let pairs = vec!((\"foo\", \"bar\"), (\"toto\", \"tata\"));\n  let map: HashMap&lt;&amp;str, &amp;str&gt; = pairs.iter().collect();\n  println!(\"{:?}\", map);\n}\n</code></pre>\n\n<p>However the compilation fails with this error:</p>\n\n<pre><code>&lt;anon&gt;:5:47: 5:56 error: the trait `core::iter::FromIterator&lt;&amp;(&amp;str, &amp;str)&gt;` is not implemented for the type `std::collections::hash::map::HashMap&lt;&amp;str, &amp;str&gt;` [E0277]\n&lt;anon&gt;:5   let map: HashMap&lt;&amp;str, &amp;str&gt; = pairs.iter().collect();\n</code></pre>\n\n<p>However if I add <code>.cloned()</code> before calling <code>collect()</code> everything works fine:</p>\n\n<pre><code>...\nlet map: HashMap&lt;&amp;str, &amp;str&gt; = pairs.iter().cloned().collect();\n...\n</code></pre>\n\n<p>Even if I understand the error message (there is no implementation of the trait <code>FromIterator&lt;&amp;(&amp;str, &amp;str)&gt;</code> for the type <code>HashMap&lt;&amp;str, &amp;str&gt;</code>) I do not understand where the type <code>&amp;(&amp;str, &amp;str)</code> comes from (according to the method signature in the Rust documentation) and why calling <code>cloned()</code> fixes that problem.</p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 7873, "user_id": 2225104, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/195de66794c596e35bc145c80e9f5515?s=128&d=identicon&r=PG", "display_name": "BitTickler", "link": "https://stackoverflow.com/users/2225104/bittickler"}, "edited": false, "score": 1, "creation_date": 1441195749, "post_id": 32352620, "comment_id": 52578424, "body": "This and other funny rust-stuff is - so I theorize - related to the way they approach things. Now, obviously is_even() could work with the semantics you suggest. Yet, a different implementation of is_even() which would pass the argument to some other function(s) which might or might not persist or change the value or have them treated in other threads would change the semantics. Not sure if my explanation is correct - but this is how I explain this unintuitive behavior to myself."}, {"owner": {"reputation": 1087, "user_id": 3484614, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/PkfbT.jpg?s=128&g=1", "display_name": "Ben S", "link": "https://stackoverflow.com/users/3484614/ben-s"}, "reply_to_user": {"reputation": 7873, "user_id": 2225104, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/195de66794c596e35bc145c80e9f5515?s=128&d=identicon&r=PG", "display_name": "BitTickler", "link": "https://stackoverflow.com/users/2225104/bittickler"}, "edited": false, "score": 1, "creation_date": 1441196937, "post_id": 32352620, "comment_id": 52579285, "body": "@BitTickler: that&#39;s mostly it, yeah. If you pass the argument as <code>Box&lt;i32&gt;</code> then you&#39;re <i>giving it away</i>, and the <code>is_even</code> function is free to mutate it, pass it around, and do what it wants, confident that the <code>main</code> function isn&#39;t going to be able to use it after the function ends."}], "answers": [{"comments": [{"owner": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "edited": false, "score": 1, "creation_date": 1441196407, "post_id": 32352874, "comment_id": 52578871, "body": "&lt;from someone on irc&gt;There is no such thing as an immutable ownership  you can move it into a mutable binding and fiddle with it all you want."}], "tags": [], "owner": {"reputation": 1087, "user_id": 3484614, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/PkfbT.jpg?s=128&g=1", "display_name": "Ben S", "link": "https://stackoverflow.com/users/3484614/ben-s"}, "is_accepted": true, "score": 4, "last_activity_date": 1441196073, "creation_date": 1441196073, "answer_id": 32352874, "question_id": 32352620, "link": "https://stackoverflow.com/questions/32352620/why-cant-i-hold-back-a-box/32352874#32352874", "title": "Why can&#39;t I hold back a box?", "body": "<p>If you want to retain ownership of your box, then you must have <code>is_even</code> <strong>borrow</strong> it, rather than take ownership of it. Here is a working version of your code:</p>\n\n<pre><code>// calling this function move the ownership of nbr to is_even\n// at the end of the function is_even doesn't give the ownership back\nfn is_even(nbr: &amp;Box&lt;i32&gt;) -&gt; bool {\n    **nbr % 2 == 0\n}\n\nfn main() {\n    let integer = Box::new(42);\n    if is_even(&amp;integer) {\n        print!(\"is even \");\n    }\n    println!(\"{}\", integer);\n}\n</code></pre>\n\n<p>Note that <code>is_even</code> now takes a reference (with a <code>&amp;</code>) to the Box, and we have to pass in a reference (again, with a <code>&amp;</code>) when we call the function. Finally, the function now operates on a reference rather than a value, so we need to add another <code>*</code> to de-reference it before we can operate on it.</p>\n\n<p>However, it's a good rule of thumb to avoid using non-mutable references to values that own their contents (such as <code>String</code> or <code>Vec</code> or <code>Box</code>). The function could be re-written as the following:</p>\n\n<pre><code>fn is_even(nbr: &amp;i32) -&gt; bool {\n    *nbr % 2 == 0\n}\n</code></pre>\n\n<p>This works with <em>any</em> reference to an integer, not only ones that are in <code>Box</code>es.</p>\n"}, {"comments": [{"owner": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "edited": false, "score": 3, "creation_date": 1441196914, "post_id": 32352997, "comment_id": 52579265, "body": "I made a rust post and you didn&#39;t edited it ! Are you in a good shape ? :p"}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1441320985, "post_id": 32352997, "comment_id": 52643831, "body": "In fact, the transfer of ownership isn&#39;t <i>ever</i> immutable. Once you are given ownership via a move, you have free reign to outright change it to mutable if you want, whenever you want, though you have the choice to not invoke that privilege. Playground: <a href=\"http://is.gd/B6rHuM\" rel=\"nofollow noreferrer\">is.gd/B6rHuM</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 6, "last_activity_date": 1441196454, "creation_date": 1441196454, "answer_id": 32352997, "question_id": 32352620, "link": "https://stackoverflow.com/questions/32352620/why-cant-i-hold-back-a-box/32352997#32352997", "title": "Why can&#39;t I hold back a box?", "body": "<blockquote>\n  <p>when I call <code>is_even</code>, I give the ownership to this function</p>\n</blockquote>\n\n<p>Exactly. You've transferred ownership. You don't have it any more and the function will do what it wants. In this case, it will free the memory, so you <strong>definitely</strong> can not use it after the call. </p>\n\n<blockquote>\n  <p>that function doesn't need the ownership any more</p>\n</blockquote>\n\n<p>Which is why it is dropped.</p>\n\n<blockquote>\n  <p>It is a immutable (read only) transfer of ownership </p>\n</blockquote>\n\n<p>That doesn't exist. You completely transfer ownership, there's no halfway about it.</p>\n\n<blockquote>\n  <p>so we are sure it is not deleted</p>\n</blockquote>\n\n<p>Actually, we <em>are sure</em> it is freed, and that is a very good thing. Rust manages that for us so you never have to ask \"who should free this?\"</p>\n\n<p>So how do you fix it? That's simple: pass a reference to the inner value, not the whole box. This <em>borrows</em> the value (mutably or not, up to you) and ownership is not transferred. </p>\n\n<pre><code>fn is_even(nbr: &amp;i32) -&gt; bool { ... }\n</code></pre>\n"}], "owner": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 86, "favorite_count": 0, "accepted_answer_id": 32352874, "answer_count": 2, "score": 2, "last_activity_date": 1441196454, "creation_date": 1441195323, "question_id": 32352620, "link": "https://stackoverflow.com/questions/32352620/why-cant-i-hold-back-a-box", "title": "Why can&#39;t I hold back a box?", "body": "<p>Consider the following code (<a href=\"https://play.rust-lang.org/?gist=8de788fb4783fa431c34&amp;version=stable\" rel=\"nofollow\">on playground</a>) :</p>\n\n<pre><code>// calling this function move the ownership of nbr to is_even\n// at the end of the function is_even doesn't give the ownership back\nfn is_even(nbr: Box&lt;i32&gt;) -&gt; bool {\n    *nbr % 2 == 0\n}\n\nfn main() {\n    let integer = Box::new(42);\n    if is_even(integer) {\n        print!(\"is even \");\n    }\n    println!(\"{}\", integer);\n}\n</code></pre>\n\n<p>I get the following error message :</p>\n\n<pre><code>example.rs:10:17: 10:24 error: use of moved value: `integer` [E0382]\nexample.rs:10   println!(\"{}\", integer);\n\nexample.rs:7:13: 7:20 note: `integer` moved here because it has type `Box&lt;i32&gt;`, which is non-copyable\nexample.rs:7    if is_even(integer) {\n</code></pre>\n\n<p>I don't understand why. Ok, when I call <code>is_even</code>, I give the ownership to this function, but at the end of <code>is_even</code> that function doesn't need the ownership any more. It is a immutable (read only) transfer of ownership so we are sure it is not deleted when <code>main</code> hold back <code>integer</code> -> it seems safe to use it back.</p>\n\n<p>Still there is this error. Why and what is the workaround ?</p>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "edited": false, "score": 0, "creation_date": 1441134429, "post_id": 32338976, "comment_id": 52552553, "body": "And what if I want to get a reference to the i32 inside the box (let&#39;s say I want to modify it and have another part of the program to see the changed value) ?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1441134763, "post_id": 32338976, "comment_id": 52552747, "body": "FWIW, I&#39;d write it as <code>arg1.as_ref().map(|x| **x).unwrap_or(0)</code>"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "edited": false, "score": 1, "creation_date": 1441136506, "post_id": 32338976, "comment_id": 52553716, "body": "@Moebius, I&#39;ve updated my answer with an example with references, however, I didn&#39;t exactly understand what do you mean about modifying values. An example would be helpful, but it probably deserves another question anyway."}, {"owner": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "edited": false, "score": 0, "creation_date": 1441142195, "post_id": 32338976, "comment_id": 52556606, "body": "@VladimirMatveev no special use case, I was just asking out of curiosity. Thanks for the solution !"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 19, "last_activity_date": 1529414400, "last_edit_date": 1529414400, "creation_date": 1441133755, "answer_id": 32338976, "question_id": 32338659, "link": "https://stackoverflow.com/questions/32338659/cannot-move-out-of-value-which-is-behind-a-shared-reference-when-unwrapping/32338976#32338976", "title": "Cannot move out of value which is behind a shared reference when unwrapping", "body": "<p><a href=\"https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap\" rel=\"noreferrer\"><code>Option::unwrap()</code></a> consumes the option, that is, it accepts the option by value. However, you don't have a value, you only have a reference to it. That's what the error is about.</p>\n\n<p>Your code should idiomatically be written like this:</p>\n\n<pre><code>fn my_fn(arg1: &amp;Option&lt;Box&lt;i32&gt;&gt;) -&gt; i32 {\n    match arg1 {\n        Some(b) =&gt; **b,\n        None =&gt; 0,\n    }\n}\n\nfn main() {\n    let integer = 42;\n    my_fn(&amp;Some(Box::new(integer)));\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=e1e7c3e7bc6b3ba0f483033b01c3eaa9&amp;version=stable&amp;mode=debug\" rel=\"noreferrer\">on the Rust playground</a>)</p>\n\n<p>Or you can use <code>Option</code> combinators like <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref\" rel=\"noreferrer\"><code>Option::as_ref</code></a> or <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.as_mut\" rel=\"noreferrer\"><code>Option::as_mut</code></a> paired with <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or\" rel=\"noreferrer\"><code>Option::map_or</code></a>, as Shepmaster has suggested:</p>\n\n<pre><code>fn my_fn(arg1: &amp;Option&lt;Box&lt;i32&gt;&gt;) -&gt; i32 {\n    arg1.as_ref().map_or(0, |n| **n)\n}\n</code></pre>\n\n<p>This code uses the fact that <code>i32</code> is automatically copyable. If the type inside the <code>Box</code> weren't <code>Copy</code>, then you wouldn't be able to obtain the inner value by value at all - you would only be able to clone it or to return a reference, for example, like here:</p>\n\n<pre><code>fn my_fn2(arg1: &amp;Option&lt;Box&lt;i32&gt;&gt;) -&gt; &amp;i32 {\n    arg1.as_ref().map_or(&amp;0, |n| n)\n}\n</code></pre>\n\n<p>Since you only have an immutable reference to the option, you can only return an immutable reference to its contents. Rust is smart enough to promote the literal <code>0</code> into a static value to keep in order to be able to  return it in case of absence of the input value.</p>\n"}], "owner": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 10695, "favorite_count": 6, "accepted_answer_id": 32338976, "answer_count": 1, "score": 17, "last_activity_date": 1591210535, "creation_date": 1441132408, "last_edit_date": 1591210535, "question_id": 32338659, "link": "https://stackoverflow.com/questions/32338659/cannot-move-out-of-value-which-is-behind-a-shared-reference-when-unwrapping", "title": "Cannot move out of value which is behind a shared reference when unwrapping", "body": "<p>This is the code I am trying to execute:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn my_fn(arg1: &amp;Option&lt;Box&lt;i32&gt;&gt;) -&gt; i32 {\n    if arg1.is_none() {\n        return 0;\n    }\n    let integer = arg1.unwrap();\n    *integer\n}\n\nfn main() {\n    let integer = 42;\n    my_fn(&amp;Some(Box::new(integer)));\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=851676c975e45fb28359f5f5a863f80e\" rel=\"nofollow noreferrer\">on the Rust playground</a>)</p>\n\n<p>I get the following error in previous versions of Rust:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n --&gt; src/main.rs:5:19\n  |\n5 |     let integer = arg1.unwrap();\n  |                   ^^^^ cannot move out of borrowed content\n</code></pre>\n\n<p>And in more modern versions:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of `*arg1` which is behind a shared reference\n --&gt; src/main.rs:5:19\n  |\n5 |     let integer = arg1.unwrap();\n  |                   ^^^^\n  |                   |\n  |                   move occurs because `*arg1` has type `std::option::Option&lt;std::boxed::Box&lt;i32&gt;&gt;`, which does not implement the `Copy` trait\n  |                   help: consider borrowing the `Option`'s content: `arg1.as_ref()`\n</code></pre>\n\n<p>I see there is already a lot of documentation about borrow checker issues, but after reading it, I still can't figure out the problem.</p>\n\n<p>Why is this an error and how do I solve it?</p>\n"}, {"tags": ["json", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441109698, "post_id": 32331120, "comment_id": 52536734, "body": "Did you try implementing <code>PartialEq</code> as the error message suggests?"}, {"owner": {"reputation": 918, "user_id": 388040, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/de1ad56f8a7b7167491f7f07f66013d9?s=128&d=identicon&r=PG", "display_name": "Kreisquadratur", "link": "https://stackoverflow.com/users/388040/kreisquadratur"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441110291, "post_id": 32331120, "comment_id": 52537160, "body": "No, tbh. I thought the error is incorrect as for this struct equality should be possibly derived. I implemented <code>PartialEq</code> now and it works. However, I still don&#39;t understand why I need to do so. None of the example online seem to do this."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441110668, "post_id": 32331120, "comment_id": 52537416, "body": "<i>for this struct equality should be possibly derived</i> \u2014 no traits are automatically derived, that&#39;s why you have to add <code>#[derive]</code>."}, {"owner": {"reputation": 918, "user_id": 388040, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/de1ad56f8a7b7167491f7f07f66013d9?s=128&d=identicon&r=PG", "display_name": "Kreisquadratur", "link": "https://stackoverflow.com/users/388040/kreisquadratur"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441110917, "post_id": 32331120, "comment_id": 52537604, "body": "Thanks, I start to get it. Adding <code>#[derive(PartialEq, ..)]</code> removes the requirement to implement it by-hand. Will update the title. Apparently I should read more fundamentals of Rust&#39;s language instead of diving heads-forward."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441112114, "post_id": 32331120, "comment_id": 52538567, "body": "I think that diving head-first should be done hand-in-hand with <a href=\"http://doc.rust-lang.org/book/\" rel=\"nofollow noreferrer\">reading up on the fundamentals</a>!"}], "answers": [{"comments": [{"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 0, "creation_date": 1441127088, "post_id": 32331884, "comment_id": 52548591, "body": "The question isn&#39;t &#39;how do I fix this,&#39; it&#39;s &#39;why do I need it."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 0, "creation_date": 1441134833, "post_id": 32331884, "comment_id": 52552784, "body": "@SteveKlabnik note that you are replying to the OP of the question ^_^"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441176717, "post_id": 32331884, "comment_id": 52566478, "body": "@Shepmaster: Whether the answer is from the OP or not, it still does not answer the question as posed (unlike your answer)."}], "tags": [], "owner": {"reputation": 918, "user_id": 388040, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/de1ad56f8a7b7167491f7f07f66013d9?s=128&d=identicon&r=PG", "display_name": "Kreisquadratur", "link": "https://stackoverflow.com/users/388040/kreisquadratur"}, "is_accepted": false, "score": 0, "last_activity_date": 1441111115, "creation_date": 1441111115, "answer_id": 32331884, "question_id": 32331120, "link": "https://stackoverflow.com/questions/32331120/deserialising-json-object-with-rustc-serialize-why-do-i-need-to-implement-parti/32331884#32331884", "title": "Deserialising JSON object with rustc_serialize: why do I need to implement PartialEq?", "body": "<p>The simple answer as hinted by @Shepmaster is to either implement the <code>PartialEq</code> trait or let it be derived, as the error message indicates:</p>\n\n<pre><code>#[derive(RustcDecodable, PartialEq, Debug)]\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 3, "last_activity_date": 1441134879, "last_edit_date": 1441134879, "creation_date": 1441114026, "answer_id": 32332907, "question_id": 32331120, "link": "https://stackoverflow.com/questions/32331120/deserialising-json-object-with-rustc-serialize-why-do-i-need-to-implement-parti/32332907#32332907", "title": "Deserialising JSON object with rustc_serialize: why do I need to implement PartialEq?", "body": "<p><a href=\"http://doc.rust-lang.org/rustc-serialize/rustc_serialize/json/fn.decode.html\" rel=\"nofollow\"><code>json::decode</code></a> is defined as:</p>\n\n<pre><code>pub fn decode&lt;T: Decodable&gt;(s: &amp;str) -&gt; DecodeResult&lt;T&gt;\n</code></pre>\n\n<p>This means that given a string slice, it will attempt to be decoded into a type specified by the user, so long as that type implements <a href=\"http://doc.rust-lang.org/rustc-serialize/rustc_serialize/trait.Decodable.html\" rel=\"nofollow\"><code>Decodable</code></a>. On the page for <code>Decodable</code>, you can see all the implementations of it, including the one for <code>BTreeMap</code>:</p>\n\n<pre><code>impl&lt;K: Decodable + PartialEq + Ord,\n     V: Decodable + PartialEq&gt;\nDecodable for BTreeMap&lt;K, V&gt;\n</code></pre>\n\n<p>This shows that in order to decode to a <code>BTreeMap</code>, both the key and value in the map need to be <code>PartialEq</code>. However, I wasn't clear on why that is actually needed. <code>BTreeMap</code> should only require that the key is <code>Ord</code> and not care about the value at all. To that end, I've opened <a href=\"https://github.com/rust-lang/rustc-serialize/pull/129\" rel=\"nofollow\">a pull request</a> to remove those bounds, and it was accepted! ^_^ I guess that means that the bounds might have just been a typo originally.</p>\n"}], "owner": {"reputation": 918, "user_id": 388040, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/de1ad56f8a7b7167491f7f07f66013d9?s=128&d=identicon&r=PG", "display_name": "Kreisquadratur", "link": "https://stackoverflow.com/users/388040/kreisquadratur"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 358, "favorite_count": 1, "answer_count": 2, "score": 4, "last_activity_date": 1441134879, "creation_date": 1441108933, "last_edit_date": 1441112942, "question_id": 32331120, "link": "https://stackoverflow.com/questions/32331120/deserialising-json-object-with-rustc-serialize-why-do-i-need-to-implement-parti", "title": "Deserialising JSON object with rustc_serialize: why do I need to implement PartialEq?", "body": "<p>I have a file containing a JSON object with unknown keys. I would like to decode this object into a structure but don't understand how to declare this structure. </p>\n\n<pre><code>extern crate rustc_serialize;\nuse rustc_serialize::json;\nuse std::collections::BTreeMap;\n\n#[derive(RustcDecodable, Debug)]\nstruct MyStruct {\n    foo: u8,\n    bar: Vec&lt;String&gt;,\n}\n\nlet raw_json = r#\"{\n    \"A\": {\n        \"foo\": 2,\n        \"bar\": [\"a\", \"b\"],\n    },\n    \"C\": {\n        \"foo\": 1,\n        \"bar\": [\"c\", \"d\"],\n    },\n    :\n}\"#;\n\nlet j: BTreeMap&lt;String, MyStruct&gt; = json::decode(&amp;raw_json).unwrap();\nprintln!(\"{:?}\", j.get(\"A\").unwrap());\n</code></pre>\n\n<p>The following error occurs:</p>\n\n<pre><code>error: the trait `core::cmp::PartialEq` is not implemented for the type `MyStruct` [E0277]\n    let j: BTreeMap&lt;String, MyStruct&gt; = json::decode(&amp;raw_json).unwrap();\n                                        ^~~~~~~~~~~~\n</code></pre>\n\n<p>Would I have to implement <code>Decodable</code> for <code>MyStruct</code> myself then?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1441125552, "post_id": 32334789, "comment_id": 52547745, "body": "So the answer is: yes this is limited to 2GB?"}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1441126657, "post_id": 32334789, "comment_id": 52548371, "body": "@MatthieuM. Yes. I&#39;ve edited my answer to be a bit clearer about this."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 1, "creation_date": 1441148767, "post_id": 32334789, "comment_id": 52558917, "body": "<code>capacity</code> is a <code>usize</code> in both methods, so the maximum capacity of a <code>Vec</code> would be 4GB. However, the allocator might fail if the requested allocation size is over 2GB..."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1441150451, "post_id": 32334789, "comment_id": 52559328, "body": "@FrancisGagn&#233; You are indeed correct, thanks. I&#39;ve updated my comment. I&#39;m not too sure about if it&#39;s even possible to allocate &gt;2GB, but the APIs surely won&#39;t refuse you if you manage."}], "tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 5, "last_activity_date": 1587306699, "last_edit_date": 1587306699, "creation_date": 1441119265, "answer_id": 32334789, "question_id": 32324794, "link": "https://stackoverflow.com/questions/32324794/maximum-size-of-an-array-in-32-bits/32334789#32334789", "title": "Maximum size of an array in 32 bits?", "body": "<p>The internals of <code>Vec</code> do cap the value to 4GB, both in <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity\" rel=\"nofollow noreferrer\"><code>with_capacity</code></a> and <a href=\"https://doc.rust-lang.org/src/collections/vec.rs.html#1256-1257\" rel=\"nofollow noreferrer\"><code>grow_capacity</code></a>, using</p>\n\n<pre><code>let size = capacity.checked_mul(mem::size_of::&lt;T&gt;())\n                   .expect(\"capacity overflow\");\n</code></pre>\n\n<p>which will panic if the pointer overflows.</p>\n\n<p>As such, <code>Vec</code>-allocated slices are also capped in this way in Rust. Given that this is because of an underlying restriction in the allocation API, I would be surprised if any typical type could circumvent this. And if they did, <code>Index</code> on slices would be unsafe due to pointer overflow. So I hope not.</p>\n\n<p>It might still not be possible to allocate all 4GB for other reasons, though. In particular, <code>allocate</code> won't let you allocate more than 2GB (<code>isize::MAX</code> bytes), so <code>Vec</code> is restricted to that.</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1441200942, "post_id": 32353924, "comment_id": 52582350, "body": "I checked the bug and the GEP FAQ, and the limit is not a matter of memory but of number of elements: when you pass <code>i32 1</code> to GEP it steps by 1 element, so with 4 bytes elements it could address into a 4 GB array easily. Note that the example was specifically about <code>Vec&lt;u8&gt;</code> which is a 1 byte element, thus the 2GB limit for this example."}], "tags": [], "owner": {"reputation": 14813, "user_id": 141502, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/zgvfq.png?s=128&g=1", "display_name": "Daniel", "link": "https://stackoverflow.com/users/141502/daniel"}, "is_accepted": false, "score": 3, "last_activity_date": 1441198867, "creation_date": 1441198867, "answer_id": 32353924, "question_id": 32324794, "link": "https://stackoverflow.com/questions/32324794/maximum-size-of-an-array-in-32-bits/32353924#32353924", "title": "Maximum size of an array in 32 bits?", "body": "<p>Rust uses LLVM as compiler backend. The LLVM instruction for pointer arithmetic (<a href=\"http://llvm.org/docs/GetElementPtr.html\" rel=\"nofollow\"><code>GetElementPtr</code></a>) takes signed integer offsets and has undefined behavior on overflow, so it is impossible to index into arrays larger than 2GB when targeting a 32-bit platform.</p>\n\n<p>To avoid undefined behavior, Rust will refuse to allocate more than 2 GB in a single allocation. See Rust issue <a href=\"https://github.com/rust-lang/rust/issues/18726\" rel=\"nofollow\">#18726</a> for details.</p>\n"}], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2622, "favorite_count": 0, "accepted_answer_id": 32334789, "answer_count": 2, "score": 10, "last_activity_date": 1587306699, "creation_date": 1441088398, "question_id": 32324794, "link": "https://stackoverflow.com/questions/32324794/maximum-size-of-an-array-in-32-bits", "title": "Maximum size of an array in 32 bits?", "body": "<p>According to the <a href=\"https://doc.rust-lang.org/reference.html#machine-dependent-integer-types\">Rust Reference</a>:</p>\n\n<blockquote>\n  <p>The <code>isize</code> type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum <code>isize</code> value. This ensures that <code>isize</code> can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</p>\n</blockquote>\n\n<p>This obviously constrain an array to at most 2G elements on 32 bits system, however what is not clear is whether an array is also constrained to at most 2GB of memory.</p>\n\n<p>In C or C++, you would be able to cast the pointers to the first and one past last elements to <code>char*</code> and obtain the difference of pointers from those two; effectively limiting the array to 2GB (lest it overflow <code>intptr_t</code>).</p>\n\n<p>Is an array in 32 bits also limited to 2GB in Rust? Or not?</p>\n"}, {"tags": ["vector", "iterator", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1441091606, "post_id": 32324645, "comment_id": 52525715, "body": "Note that your title does not match your code-sample. After <code>collect</code> you have a <code>Vec</code>, not an iterator, thus you are really asking how to unpack a <code>Vec</code>; it would be best to correct the title."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1441091911, "post_id": 32324645, "comment_id": 52525872, "body": "Personally I\u2019d use <code>let mut parts = line.split_whitespace();</code> followed by <code>let (ip, bytes, int_number) = (parts.next().unwrap(), parts.next().unwrap(), parts.next().unwrap());</code> or more likely <code>if let (Some(ip), Some(bytes), Some(int_number)) = (parts.next(), parts.next(), parts.next())</code>."}], "answers": [{"comments": [{"owner": {"reputation": 560, "user_id": 2520171, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7dea54aa4d218a6d8fc0263dc5a06caa?s=128&d=identicon&r=PG", "display_name": "jv-dev", "link": "https://stackoverflow.com/users/2520171/jv-dev"}, "edited": false, "score": 2, "creation_date": 1570591944, "post_id": 32325143, "comment_id": 102956535, "body": "Answer made in 2015, seems slice patterns went stable in Rust 1.26 (<a href=\"https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html\" rel=\"nofollow noreferrer\">link</a>). Very nice, though does make the else case of the irrefutable pattern a bit of a pain with multiple bindings..."}], "tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": true, "score": 18, "last_activity_date": 1576432803, "last_edit_date": 1576432803, "creation_date": 1441089809, "answer_id": 32325143, "question_id": 32324645, "link": "https://stackoverflow.com/questions/32324645/how-can-i-unpack-destructure-elements-from-a-vector/32325143#32325143", "title": "How can I unpack (destructure) elements from a vector?", "body": "<p>It seems what you need is \"slice patterns\":</p>\n\n<pre><code>fn main() {\n    let line = \"127.0.0.1 1000 what!?\";\n    let v = line.split_whitespace().take(3).collect::&lt;Vec&lt;&amp;str&gt;&gt;();\n\n    if let [ip, port, msg] = &amp;v[..] {\n         println!(\"{}:{} says '{}'\", ip, port, msg);\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=044975c92af9c86096045f88f78cd266\" rel=\"noreferrer\">Playground link</a></p>\n\n<p>Note the <code>if let</code> instead of plain <code>let</code>. Slice patterns are <em>refutable</em>, so we need to take this into account (you may want to have an <code>else</code> branch, too).</p>\n"}], "owner": {"reputation": 2295, "user_id": 584423, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/cdfd5cadef76ea361532bfb20499a5ba?s=128&d=identicon&r=PG", "display_name": "Boden Garman", "link": "https://stackoverflow.com/users/584423/boden-garman"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3566, "favorite_count": 1, "accepted_answer_id": 32325143, "answer_count": 1, "score": 13, "last_activity_date": 1576432803, "creation_date": 1441087692, "last_edit_date": 1441091761, "question_id": 32324645, "link": "https://stackoverflow.com/questions/32324645/how-can-i-unpack-destructure-elements-from-a-vector", "title": "How can I unpack (destructure) elements from a vector?", "body": "<p>I am currently doing the following:</p>\n\n<pre><code>let line_parts = line.split_whitespace().take(3).collect::&lt;Vec&lt;&amp;str&gt;&gt;();\nlet ip = line_parts[0];\nlet bytes = line_parts[1];\nlet int_number = line_parts[2];\n</code></pre>\n\n<p>Is it possible to do something like this?</p>\n\n<pre><code>let [ip, bytes, int_number] = line.split_whitespace().take(3).collect();\n</code></pre>\n\n<p>I'm noticed various references to vector destructuring on some sites but the official docs don't seem to mention it.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1441105712, "post_id": 32324592, "comment_id": 52534238, "body": "Could you provide an example of one of these subtle bugs?"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1441106106, "post_id": 32324592, "comment_id": 52534482, "body": "@Shepmaster: I can&#39;t think of any.  I assume it had something to do with iterators being passed into <code>for</code> loops, getting modified, but leaving the <i>original</i> iterator unmodified."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1441146640, "post_id": 32324592, "comment_id": 52558269, "body": "I found <a href=\"https://github.com/rust-lang/rust/pull/27186#issuecomment-123390413\" rel=\"nofollow noreferrer\">one example</a>, validating your memory."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 9, "last_activity_date": 1441087475, "creation_date": 1441087475, "answer_id": 32324592, "question_id": 32324251, "link": "https://stackoverflow.com/questions/32324251/why-are-iterators-not-copyable/32324592#32324592", "title": "Why are iterators not copyable?", "body": "<p>From <a href=\"https://github.com/rust-lang/rust/pull/20790\">PR #20790</a>:</p>\n\n<blockquote>\n  <p>This PR also makes iterator non-implicitly copyable, as this was source of subtle bugs in the libraries. You can still use <code>clone()</code> to explictly copy the iterator.</p>\n</blockquote>\n"}], "owner": {"reputation": 10598, "user_id": 371137, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/JAV6o.jpg?s=128&g=1", "display_name": "Perseids", "link": "https://stackoverflow.com/users/371137/perseids"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 324, "favorite_count": 0, "accepted_answer_id": 32324592, "answer_count": 1, "score": 7, "last_activity_date": 1441325719, "creation_date": 1441085976, "last_edit_date": 1441325719, "question_id": 32324251, "link": "https://stackoverflow.com/questions/32324251/why-are-iterators-not-copyable", "title": "Why are iterators not copyable?", "body": "<p>Many iterators <a href=\"https://doc.rust-lang.org/std/clone/trait.Clone.html\" rel=\"nofollow\">implement the <code>Clone</code> trait</a>, but none of them <a href=\"https://doc.rust-lang.org/std/marker/trait.Copy.html\" rel=\"nofollow\">implement the <code>Copy</code> trait</a>. At least for simple iterators like <a href=\"https://doc.rust-lang.org/std/slice/struct.Iter.html\" rel=\"nofollow\"><code>std:slice::Iter</code></a>, <a href=\"https://doc.rust-lang.org/src/core/slice.rs.html#799-802\" rel=\"nofollow\">the <code>Clone</code> implementation</a> looks like a memcpy anyway, so why isn't <code>Copy</code> also implemented?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1441062571, "post_id": 32320661, "comment_id": 52517524, "body": "Are you familiar with the <a href=\"https://play.rust-lang.org/\" rel=\"nofollow noreferrer\">Rust Playground</a>? It would allow you to answer questions like &quot;what output does this code have&quot; yourself."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1441091726, "post_id": 32320661, "comment_id": 52525781, "body": "If you wish to store a pointer in an integral, use <code>usize</code> instead of either <code>u32</code> or <code>u64</code>, it&#39;s guaranteed to have the same size as a pointer."}, {"owner": {"reputation": 623, "user_id": 2052557, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/faa146c922ff066fff18c7114209305a?s=128&d=identicon&r=PG", "display_name": "Ja\u016dhien Piatlicki", "link": "https://stackoverflow.com/users/2052557/ja%c5%adhien-piatlicki"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441137099, "post_id": 32320661, "comment_id": 52554053, "body": "@Shepmaster: I know what is the output of this code (I kbow how to run rust programs, yeah ;-) ), the question is about what exact addresses do i get and you answer below sheds light on it."}, {"owner": {"reputation": 623, "user_id": 2052557, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/faa146c922ff066fff18c7114209305a?s=128&d=identicon&r=PG", "display_name": "Ja\u016dhien Piatlicki", "link": "https://stackoverflow.com/users/2052557/ja%c5%adhien-piatlicki"}, "edited": false, "score": 0, "creation_date": 1441137125, "post_id": 32320661, "comment_id": 52554076, "body": "@ Matthieu M.: thanks, I know."}], "answers": [{"comments": [{"owner": {"reputation": 623, "user_id": 2052557, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/faa146c922ff066fff18c7114209305a?s=128&d=identicon&r=PG", "display_name": "Ja\u016dhien Piatlicki", "link": "https://stackoverflow.com/users/2052557/ja%c5%adhien-piatlicki"}, "edited": false, "score": 0, "creation_date": 1441137371, "post_id": 32321242, "comment_id": 52554195, "body": "Seems you are right about what the reference does, thanks. I know how to work with functions. But I need not to work with them in Rust, I need an address because I have some FFI that takes an address of the symbol in the current process (yes, my function is marked as extern, so it has the right call conventions)."}, {"owner": {"reputation": 623, "user_id": 2052557, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/faa146c922ff066fff18c7114209305a?s=128&d=identicon&r=PG", "display_name": "Ja\u016dhien Piatlicki", "link": "https://stackoverflow.com/users/2052557/ja%c5%adhien-piatlicki"}, "edited": false, "score": 0, "creation_date": 1441230192, "post_id": 32321242, "comment_id": 52599874, "body": "&gt; You can still just pass the function as-is to the extern functions that will use the callback. No, I can&#39;t. Extern function accepts addresses. Period. But your comments (with println!) helped, thanks. I have used it in these commits: <a href=\"https://github.com/jauhien/iron-kaleidoscope/commit/154136f732f685eb6ab206e26c1f79a91de2f8b2\" rel=\"nofollow noreferrer\">github.com/jauhien/iron-kaleidoscope/commit/&hellip;</a> and <a href=\"https://github.com/jauhien/iron-llvm/commit/eae180417912eeade7c35b16a12bdce69ebfaf84\" rel=\"nofollow noreferrer\">github.com/jauhien/iron-llvm/commit/&hellip;</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 10, "last_activity_date": 1441138171, "last_edit_date": 1441138171, "creation_date": 1441062525, "answer_id": 32321242, "question_id": 32320661, "link": "https://stackoverflow.com/questions/32320661/how-do-i-obtain-the-address-of-a-function/32321242#32321242", "title": "How do I obtain the address of a function?", "body": "<p>If I just wanted to know the address of a function, I'd probably just print it out:</p>\n\n<pre><code>fn moo() {}\n\nfn main() {\n    println!(\"{:p}\", moo as *const ());\n}\n</code></pre>\n\n<p>However, I can't think of a useful reason to want to do this. Usually, there's something you want to <em>do</em> with the function. In those cases, you might as well just pass the function directly, no need to deal with the address:</p>\n\n<pre><code>fn moo() {}\n\nfn do_moo(f: fn()) {\n    f()\n}\n\nfn main() {\n    do_moo(moo);\n}\n</code></pre>\n\n<p>I'm less sure about this, but I think that <code>std::mem::transmute::&lt;_, u32&gt;(&amp;function)</code> would just create a local variable that points to <code>function</code> and then gets the reference to that variable. This would match how this code works:</p>\n\n<pre><code>fn main() {\n    let a = &amp;42;\n}\n</code></pre>\n\n<blockquote>\n  <p>I need not to work with them in Rust, I need an address because I have some FFI that takes an address of the symbol in the current process</p>\n</blockquote>\n\n<p>You can still just pass the function as-is to the extern functions that will use the callback:</p>\n\n<pre><code>extern {\n    fn a_thing_that_does_a_callback(callback: extern fn(u8) -&gt; bool);\n}\n\nextern fn zero(a: u8) -&gt; bool { a == 0 }\n\nfn main() {\n    unsafe { a_thing_that_does_a_callback(zero); }\n}\n</code></pre>\n"}], "owner": {"reputation": 623, "user_id": 2052557, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/faa146c922ff066fff18c7114209305a?s=128&d=identicon&r=PG", "display_name": "Ja\u016dhien Piatlicki", "link": "https://stackoverflow.com/users/2052557/ja%c5%adhien-piatlicki"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2946, "favorite_count": 0, "accepted_answer_id": 32321242, "answer_count": 1, "score": 7, "last_activity_date": 1441357921, "creation_date": 1441058666, "last_edit_date": 1441357921, "question_id": 32320661, "link": "https://stackoverflow.com/questions/32320661/how-do-i-obtain-the-address-of-a-function", "title": "How do I obtain the address of a function?", "body": "<p>How do I obtain a function address in Rust? What does '&amp;somefunction' exactly mean?</p>\n\n<p>What addresses do I get doing</p>\n\n<pre><code>std::mem::transmute::&lt;_, u32&gt;(function)\n</code></pre>\n\n<p>or</p>\n\n<pre><code>std::mem::transmute::&lt;_, u32&gt;(&amp;function)\n</code></pre>\n\n<p>(on 32-bit system, of course)?</p>\n\n<p>What does</p>\n\n<pre><code>&amp;function as *const _ as *const c_void\n</code></pre>\n\n<p>give?</p>\n\n<p>UPD. The answer by @Shepmaster below gives answer to this question (though giving also other not relevant but may be useful for somebody information). I summarize it here.</p>\n\n<p>Obtaining address is easy, just</p>\n\n<pre><code>funct as *const ()\n</code></pre>\n\n<p>Reference to a function seems to create a local variable just like with</p>\n\n<pre><code>let a = &amp;42;\n</code></pre>\n"}, {"tags": ["struct", "rust", "borrow-checker"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1441033687, "post_id": 32314270, "comment_id": 52503851, "body": "I think that <a href=\"http://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct\" title=\"why cant i store a value and a reference to that value in the same struct\">stackoverflow.com/questions/32300132/&hellip;</a> will answer your question."}, {"owner": {"reputation": 195, "user_id": 2094999, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/86ea77b73d9b1fef33e110a8027c0dd4?s=128&d=identicon&r=PG", "display_name": "Jesse", "link": "https://stackoverflow.com/users/2094999/jesse"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441033756, "post_id": 32314270, "comment_id": 52503890, "body": "I&#39;ll have a look, thanks. I did try google before I posted this btw. :)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441033844, "post_id": 32314270, "comment_id": 52503937, "body": "No worries, it&#39;s a common problem and why that question was created. Hopefully, we will be able to mark a bunch of things as duplicates to make the SEO way better. :-)"}, {"owner": {"reputation": 195, "user_id": 2094999, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/86ea77b73d9b1fef33e110a8027c0dd4?s=128&d=identicon&r=PG", "display_name": "Jesse", "link": "https://stackoverflow.com/users/2094999/jesse"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441035522, "post_id": 32314270, "comment_id": 52504894, "body": "Do you suggest using the owing_ref here, or is there a more idiomatic way to handle this?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441035686, "post_id": 32314270, "comment_id": 52504990, "body": "It looks like having multiple structs is more appropriate."}, {"owner": {"reputation": 195, "user_id": 2094999, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/86ea77b73d9b1fef33e110a8027c0dd4?s=128&d=identicon&r=PG", "display_name": "Jesse", "link": "https://stackoverflow.com/users/2094999/jesse"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441036062, "post_id": 32314270, "comment_id": 52505207, "body": "Putting the Axes2D in its own struct? Could you provide an example?"}, {"owner": {"reputation": 195, "user_id": 2094999, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/86ea77b73d9b1fef33e110a8027c0dd4?s=128&d=identicon&r=PG", "display_name": "Jesse", "link": "https://stackoverflow.com/users/2094999/jesse"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1441036161, "post_id": 32314270, "comment_id": 52505279, "body": "Let us <a href=\"http://chat.stackoverflow.com/rooms/88388/discussion-between-jesse-and-shepmaster\">continue this discussion in chat</a>."}], "owner": {"reputation": 195, "user_id": 2094999, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/86ea77b73d9b1fef33e110a8027c0dd4?s=128&d=identicon&r=PG", "display_name": "Jesse", "link": "https://stackoverflow.com/users/2094999/jesse"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 40, "favorite_count": 0, "closed_date": 1441055029, "answer_count": 0, "score": 0, "last_activity_date": 1441033763, "creation_date": 1441033293, "last_edit_date": 1441033763, "question_id": 32314270, "link": "https://stackoverflow.com/questions/32314270/storing-a-reference-in-a-struct", "closed_reason": "Duplicate", "title": "Storing a reference in a struct", "body": "<p>I am trying to build a wrapper struct around the gnuplot lib for Rust.</p>\n\n<p>I want to plot multiple sets of lines in the same 2D-axes object, therefore I need to keep the <code>Axes2D</code> around.</p>\n\n<p>How can I fix this structure? The <code>figure</code> and the <code>axes</code> fields will live exactly as long as the <code>plot</code> struct itself.</p>\n\n<pre><code>use gnuplot::{Axes2D, Figure, Caption, Color};\n\npub struct Plot {\n    figure: Figure,\n    axes: &amp;mut Axes2D,\n}\n\nimpl Plot {\n    pub fn new() -&gt; Plot {\n        let fig = Figure::new();\n        Plot {\n            figure: fig,\n            axes: fig.axes2d(),\n        }\n    }\n}\n</code></pre>\n\n<p>This fails with the following compiler error:</p>\n\n<pre><code>plot.rs:6:11: 6:22 error: missing lifetime specifier [E0106]\nplot.rs:6     axes: &amp;mut Axes2D,\n</code></pre>\n\n<p>I've tried adding lifetime <code>'a</code> at the struct, field and impl, but this gives me different errors. Since I'm not sure what I'm doing, I was wondering if someone could explain how to achieve this.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1441021172, "post_id": 32307068, "comment_id": 52495716, "body": "Note that on a 32 bits system, <code>isize</code> is limited to 32 bits, so this actually constrains the size of an array to 2GB even though 4GB are available. On 64 bits, I doubt it&#39;ll be an issue."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1441022930, "post_id": 32307068, "comment_id": 52496782, "body": "@MatthieuM.: on existing 64-bit platforms addresses are only 48 bits, so 63 bits is ample."}, {"owner": {"reputation": 17430, "user_id": 309483, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/d797538504a367f277d19bd8369e9a19?s=128&d=identicon&r=PG", "display_name": "Janus Troelsen", "link": "https://stackoverflow.com/users/309483/janus-troelsen"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 3, "creation_date": 1441068378, "post_id": 32307068, "comment_id": 52518823, "body": "@MatthieuM. why is it 2GB and not 2G elements?"}, {"owner": {"reputation": 8764, "user_id": 1162888, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad1b7cc2be3bf5120b508c56590e6293?s=128&d=identicon&r=PG", "display_name": "Simon Sapin", "link": "https://stackoverflow.com/users/1162888/simon-sapin"}, "reply_to_user": {"reputation": 17430, "user_id": 309483, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/d797538504a367f277d19bd8369e9a19?s=128&d=identicon&r=PG", "display_name": "Janus Troelsen", "link": "https://stackoverflow.com/users/309483/janus-troelsen"}, "edited": false, "score": 0, "creation_date": 1441082508, "post_id": 32307068, "comment_id": 52521960, "body": "@JanusTroelsen It is 2G elements, which can be as little as 2GB (even though you\u2019d have enough address space for more) when elements are byte-sized."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 17430, "user_id": 309483, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/d797538504a367f277d19bd8369e9a19?s=128&d=identicon&r=PG", "display_name": "Janus Troelsen", "link": "https://stackoverflow.com/users/309483/janus-troelsen"}, "edited": false, "score": 1, "creation_date": 1441088416, "post_id": 32307068, "comment_id": 52524053, "body": "@JanusTroelsen: I supposed, Rust having low-level capabilities, that one should always be able to compute the difference between a pointer to the first element and a pointer one-past-the-end element, even when casting those pointers to <code>*const u8</code>. Well, <a href=\"http://stackoverflow.com/questions/32324794/maximum-size-of-an-array-in-32-bits\">let&#39;s ask</a>!"}, {"owner": {"reputation": 1417, "user_id": 2430555, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/OenB4.jpg?s=128&g=1", "display_name": "Pedro Paulo Amorim", "link": "https://stackoverflow.com/users/2430555/pedro-paulo-amorim"}, "edited": false, "score": 0, "creation_date": 1568911411, "post_id": 32307068, "comment_id": 102434935, "body": "This link has been removed."}, {"owner": {"reputation": 26037, "user_id": 542190, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c3bb1f122c476561bb9a98a1523e8b5e?s=128&d=identicon&r=PG", "display_name": "filmor", "link": "https://stackoverflow.com/users/542190/filmor"}, "edited": false, "score": 0, "creation_date": 1568962624, "post_id": 32307068, "comment_id": 102449137, "body": "Thanks for the info, I fixed the link now."}], "tags": [], "owner": {"reputation": 26037, "user_id": 542190, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c3bb1f122c476561bb9a98a1523e8b5e?s=128&d=identicon&r=PG", "display_name": "filmor", "link": "https://stackoverflow.com/users/542190/filmor"}, "is_accepted": true, "score": 12, "last_activity_date": 1568962599, "last_edit_date": 1568962599, "creation_date": 1441010217, "answer_id": 32307068, "question_id": 32307004, "link": "https://stackoverflow.com/questions/32307004/what-is-the-rust-equivalent-of-size-t/32307068#32307068", "title": "What is the Rust equivalent of `size_t`?", "body": "<p>That would be <code>usize</code> and <code>isize</code> (pointer-size types, unsigned and signed). The <a href=\"https://doc.rust-lang.org/reference/types/numeric.html#machine-dependent-integer-types\" rel=\"nofollow noreferrer\">reference</a> says that the maximal size of an array is the maximum value of <code>isize</code> such that differences of positions can be calculated.</p>\n\n<p>The functions of <code>std::Vec</code> use <code>usize</code> for all indices, though.</p>\n"}], "owner": {"reputation": 10598, "user_id": 371137, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/JAV6o.jpg?s=128&g=1", "display_name": "Perseids", "link": "https://stackoverflow.com/users/371137/perseids"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3949, "favorite_count": 0, "accepted_answer_id": 32307068, "answer_count": 1, "score": 11, "last_activity_date": 1568962599, "creation_date": 1441010011, "last_edit_date": 1441029340, "question_id": 32307004, "link": "https://stackoverflow.com/questions/32307004/what-is-the-rust-equivalent-of-size-t", "title": "What is the Rust equivalent of `size_t`?", "body": "<p>In more practical terms: <strong>What integer data type should I use for indices in a vector, length of arrays, etc?</strong> </p>\n\n<p>There are lots of discussions on this topic for pre-1.0 Rust floating around on the internet and I can't find an authoritative answer on the final decision.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 3908, "user_id": 1398841, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/s8gQQ.png?s=128&g=1", "display_name": "phoenix", "link": "https://stackoverflow.com/users/1398841/phoenix"}, "edited": false, "score": 1, "creation_date": 1477349701, "post_id": 32304595, "comment_id": 67720763, "body": "See the docs here: <a href=\"https://doc.rust-lang.org/reference.html#self-types\" rel=\"nofollow noreferrer\">doc.rust-lang.org/reference.html#self-types</a>"}, {"owner": {"reputation": 583, "user_id": 2796082, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/893dc5352285592b8a564c2215851d42?s=128&d=identicon&r=PG&f=1", "display_name": "youngmit", "link": "https://stackoverflow.com/users/2796082/youngmit"}, "edited": false, "score": 4, "creation_date": 1525023164, "post_id": 32304595, "comment_id": 87194795, "body": "This documentation was moved to: <a href=\"https://doc.rust-lang.org/reference/types.html#self-types\" rel=\"nofollow noreferrer\">doc.rust-lang.org/reference/types.html#self-types</a>"}], "answers": [{"tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": true, "score": 77, "last_activity_date": 1518359898, "last_edit_date": 1518359898, "creation_date": 1441006614, "answer_id": 32306132, "question_id": 32304595, "link": "https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self/32306132#32306132", "title": "What&#39;s the difference between self and Self?", "body": "<p><code>self</code> when used as first method argument, is a shorthand for <code>self: Self</code>. There are also <code>&amp;self</code>, which is equivalent to <code>self: &amp;Self</code>, and <code>&amp;mut self</code>, which is equivalent to <code>self: &amp;mut Self</code>.</p>\n\n<p><code>Self</code> in method arguments is <em>syntactic sugar</em> for the receiving type of the method (i.e. the type whose <code>impl</code> this method is in). This also allows for generic types without too much repetition.</p>\n"}, {"comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user266003"}, "edited": false, "score": 0, "creation_date": 1441033839, "post_id": 32310313, "comment_id": 52503934, "body": "<b>It may appear either in a trait or an impl</b> - can&#39;t it appear in &quot;struct&quot;?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1441034048, "post_id": 32310313, "comment_id": 52504039, "body": "@jawanam: I personally get <i>error: use of <code>Self</code> outside of an impl or trait</i> if I attempt it. Maybe the restriction is lifted in a more recent version?"}, {"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "edited": false, "score": 1, "creation_date": 1441089261, "post_id": 32310313, "comment_id": 52524443, "body": "No, it&#39;s currently not possible (as of nightly 2015-09-01). Self-referential structs are quite rare, so adding Self-handling in this case was deemed low-priority."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1309, "user_id": 6583956, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/rM8OA.jpg?s=128&g=1", "display_name": "Sergey.quixoticaxis.Ivanov", "link": "https://stackoverflow.com/users/6583956/sergey-quixoticaxis-ivanov"}, "edited": false, "score": 0, "creation_date": 1478878438, "post_id": 32310313, "comment_id": 68340795, "body": "@Sergey.quixoticaxis.Ivanov: Using <code>self</code> or not is not purely syntax, as it is the difference between a method and an associated function. For a plain <code>struct</code>, calling a method or an associated function is in turn mostly syntax (though sugar isn&#39;t that bad). However, things change on traits: specifically, a trait object (used with <code>fn doit(d: &amp;Display)</code> for example) can only be formed on object-safe traits, and associated functions are not object safe (a subset of methods is not safe either)."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 102, "last_activity_date": 1521570388, "last_edit_date": 1521570388, "creation_date": 1441020990, "answer_id": 32310313, "question_id": 32304595, "link": "https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self/32310313#32310313", "title": "What&#39;s the difference between self and Self?", "body": "<p><a href=\"https://doc.rust-lang.org/reference/types.html#self-types\" rel=\"noreferrer\"><code>Self</code></a> is the type of the current object. It may appear either in a <code>trait</code> or an <code>impl</code>, but appears most often in <code>trait</code> where it is a stand-in for whatever type will end up implementing the <code>trait</code> (which is unknown when defining the <code>trait</code>):</p>\n\n<pre><code>trait Clone {\n    fn clone(&amp;self) -&gt; Self;\n}\n</code></pre>\n\n<p>If I then implement <code>Clone</code>:</p>\n\n<pre><code>impl Clone for MyType {\n    // I can use either the concrete type (known here)\n    fn clone(&amp;self) -&gt; MyType;\n\n    // Or I can use Self again, it's shorter after all!\n    fn clone(&amp;self) -&gt; Self;\n}\n</code></pre>\n\n<p>I could also use it in a regular <code>impl</code> if I am lazy (it's shorter!):</p>\n\n<pre><code>impl MySuperLongType {\n    fn new(a: u32) -&gt; Self { ... }\n}\n</code></pre>\n\n<hr>\n\n<p><code>self</code> is the name used in a <code>trait</code> or an <code>impl</code> for the first argument of a method. Using another name is possible, however there is a notable difference:</p>\n\n<ul>\n<li>if using <code>self</code>, the function introduced is a method</li>\n<li>if using any other name, the function introduced is an associated function</li>\n</ul>\n\n<p>In Rust, there is no implicit <code>this</code> argument passed to a type's methods: you have to explicitly pass the \"current object\" as a method parameter. This would result in:</p>\n\n<pre><code>impl MyType {\n    fn doit(this: &amp;MyType, a: u32) { ... }\n}\n</code></pre>\n\n<p>As we have seen, as a shorter form this could also be (still verbose):</p>\n\n<pre><code>impl MyType {\n    fn doit(this: &amp;Self, a: u32) { ... }\n}\n</code></pre>\n\n<p>Which is actually what <code>&amp;self</code> boils down to under the covers.</p>\n\n<pre><code>impl MyType {\n    fn doit(&amp;self, a: u32) { ... }\n}\n</code></pre>\n\n<p>Thus the correspondence table:</p>\n\n<pre><code>self =&gt; self: Self\n&amp;self =&gt; self: &amp;Self\n&amp;mut self =&gt; self: &amp;mut Self\n</code></pre>\n\n<p>The way to invoke those functions change, however:</p>\n\n<pre><code>impl MyType {\n    fn doit(&amp;self, a: u32) {\n        // ...\n    }\n    fn another(this: &amp;Self, a: u32) {\n        // ...\n    }\n}\n\nfn main() {\n    let m = MyType;\n\n    // Both can be used as an associated function\n    MyType::doit(&amp;m, 1);\n    MyType::another(&amp;m, 2);\n\n    // But only `doit` can be used in method position\n    m.doit(3);     // OK: `m` is automatically borrowed\n    m.another(4);  // ERROR: no method named `another`\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 2109, "user_id": 605356, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/13337e3eab8b8bee2e07c014d4a319ac?s=128&d=identicon&r=PG", "display_name": "Johnny Utahh", "link": "https://stackoverflow.com/users/605356/johnny-utahh"}, "edited": false, "score": 0, "creation_date": 1617217278, "post_id": 63877985, "comment_id": 118246060, "body": "Is there any reason why this answer is not correct?  Assuming it&#39;s accurate, I prefer it because it&#39;s concise, and therefore much easier (for me) to initially understand and remember."}, {"owner": {"reputation": 2964, "user_id": 7134134, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/fzCCW.jpg?s=128&g=1", "display_name": "snnsnn", "link": "https://stackoverflow.com/users/7134134/snnsnn"}, "reply_to_user": {"reputation": 2109, "user_id": 605356, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/13337e3eab8b8bee2e07c014d4a319ac?s=128&d=identicon&r=PG", "display_name": "Johnny Utahh", "link": "https://stackoverflow.com/users/605356/johnny-utahh"}, "edited": false, "score": 0, "creation_date": 1617225194, "post_id": 63877985, "comment_id": 118248844, "body": "@JohnnyUtahh It is not incorrect, does not have vote yet."}, {"owner": {"reputation": 2109, "user_id": 605356, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/13337e3eab8b8bee2e07c014d4a319ac?s=128&d=identicon&r=PG", "display_name": "Johnny Utahh", "link": "https://stackoverflow.com/users/605356/johnny-utahh"}, "edited": false, "score": 2, "creation_date": 1617226103, "post_id": 63877985, "comment_id": 118249124, "body": "Got it. And nice answer edits, they help -- without losing the first-sentence conciseness, which is great. I have up-voted."}], "tags": [], "owner": {"reputation": 2964, "user_id": 7134134, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/fzCCW.jpg?s=128&g=1", "display_name": "snnsnn", "link": "https://stackoverflow.com/users/7134134/snnsnn"}, "is_accepted": false, "score": 1, "last_activity_date": 1617226193, "last_edit_date": 1617226193, "creation_date": 1600056657, "answer_id": 63877985, "question_id": 32304595, "link": "https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self/63877985#63877985", "title": "What&#39;s the difference between self and Self?", "body": "<p><code>Self</code> refers to current type that implements the trait, <code>self</code> on the other hand refers to the instance.</p>\n<p>Having <code>self</code> as the first parameter is how rust defines methods. It is just a convention that converts a function into a method, much like in python. Functionally, <code>self</code> is analogous to <code>this</code> in JavaScript.</p>\n<p>For those who don't know the difference between a function and a method, methods are functions that are attached to an instance and invoked via that instance.</p>\n"}], "owner": {"user_type": "does_not_exist", "display_name": "user266003"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 19132, "favorite_count": 15, "accepted_answer_id": 32306132, "answer_count": 3, "score": 73, "last_activity_date": 1617226193, "creation_date": 1440999564, "last_edit_date": 1518356352, "question_id": 32304595, "link": "https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self", "title": "What&#39;s the difference between self and Self?", "body": "<p>I haven't come across <code>Self</code> in the documentation, only in the source code. The documentation only uses <code>self</code>. </p>\n"}, {"tags": ["string", "rust", "string-concatenation"], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": false, "score": 3, "last_activity_date": 1440991040, "creation_date": 1440991040, "answer_id": 32303519, "question_id": 32303423, "link": "https://stackoverflow.com/questions/32303423/how-can-i-concatenate-something-to-the-front-of-a-string/32303519#32303519", "title": "How can I concatenate something to the front of a string?", "body": "<p>Think about what <code>+</code> desugars to:</p>\n\n<pre><code>s = s.add(&amp;s);\n</code></pre>\n\n<p>Now this <code>add</code> is <a href=\"http://doc.rust-lang.org/std/ops/trait.Add.html#tymethod.add\" rel=\"nofollow\">from the <code>Add</code> trait</a> and is effectively this:</p>\n\n<pre><code>fn add(self: String, rhs: &amp;str) -&gt; String;\n</code></pre>\n\n<p>The use of <code>self</code> means that it is taking ownership of the string; you obviously can\u2019t pass a reference to that as the second argument, because it isn\u2019t yours any more.</p>\n\n<p>You might think that it\u2019d be OK doing this, but it\u2019s not; the whole class is unsound, constituting mutable aliasing\u2014both a mutable and immutable reference to the same thing existing at the same time. For this specific case, one way I could imagine it going wrong if permitted is if the string pushing were to reallocate the string; <code>rhs</code> would then conceivably be pointing to non-existent memory when it actually went to use it.</p>\n"}, {"tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": false, "score": 4, "last_activity_date": 1441011641, "creation_date": 1441011641, "answer_id": 32307496, "question_id": 32303423, "link": "https://stackoverflow.com/questions/32303423/how-can-i-concatenate-something-to-the-front-of-a-string/32307496#32307496", "title": "How can I concatenate something to the front of a string?", "body": "<p>Adding a solution to Chris Morgan's answer:</p>\n\n<pre><code>let s = \"s\";\nlet mut double_s = s.to_owned(); // faster, better than to_string()\ndouble_s = double_s + s;\n</code></pre>\n\n<p>You could also use</p>\n\n<pre><code>double_s.push_str(s);\n</code></pre>\n\n<p>instead of the last line.</p>\n"}], "owner": {"reputation": 485, "user_id": 2417339, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/3dcb5c6178e0c06217fc68e005d0308d?s=128&d=identicon&r=PG", "display_name": "Tyler H", "link": "https://stackoverflow.com/users/2417339/tyler-h"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1513, "favorite_count": 0, "answer_count": 2, "score": 4, "last_activity_date": 1441029520, "creation_date": 1440990128, "last_edit_date": 1441029520, "question_id": 32303423, "link": "https://stackoverflow.com/questions/32303423/how-can-i-concatenate-something-to-the-front-of-a-string", "title": "How can I concatenate something to the front of a string?", "body": "<p>I keep getting the error \"Use of moved value\".</p>\n\n<pre><code>let mut s = \"s\".to_string();\ns = s + &amp;s;\n</code></pre>\n"}, {"tags": ["rust", "reference", "lifetime", "borrow-checker"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1441002752, "post_id": 32300132, "comment_id": 52486058, "body": "For the latter example, a definition of <code>Parent</code> and <code>Child</code> could help..."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1441031142, "post_id": 32300132, "comment_id": 52502237, "body": "@MatthieuM. I debated that, but decided against it based on the two linked questions. Neither of those questions looked at the definition of the struct <i>or</i> the method in question, so I thought it would be best to mimic that to that people can more easily match this question to their own situation. Note that I <i>do</i> show the method signature in the answer."}], "answers": [{"comments": [{"owner": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "edited": false, "score": 1, "creation_date": 1451945118, "post_id": 32300133, "comment_id": 56947008, "body": "Is something like this (<a href=\"http://is.gd/wl2IAt\" rel=\"nofollow noreferrer\">is.gd/wl2IAt</a>) considered idiomatic? Ie, to expose the data via methods instead of the raw data."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 36134, "user_id": 493729, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/bU0Kx.jpg?s=128&g=1", "display_name": "Peter Hall", "link": "https://stackoverflow.com/users/493729/peter-hall"}, "edited": false, "score": 2, "creation_date": 1451947374, "post_id": 32300133, "comment_id": 56948132, "body": "@PeterHall sure, it just means that <code>Combined</code> owns the <code>Child</code> which owns the <code>Parent</code>. That may or may not make sense depending on the actual types that you have. Returning references to your own internal data is pretty typical."}, {"owner": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "edited": false, "score": 0, "creation_date": 1479122730, "post_id": 32300133, "comment_id": 68410352, "body": "What is the solution to the heap problem?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "edited": false, "score": 0, "creation_date": 1479131871, "post_id": 32300133, "comment_id": 68416232, "body": "@derekdreery perhaps you could expand on your comment? Why is the entire paragraph talking about the <i>owning_ref</i> crate insufficient?"}, {"owner": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "edited": false, "score": 0, "creation_date": 1479211893, "post_id": 32300133, "comment_id": 68453385, "body": "I haven&#39;t looked at the owning_ref crate, but <i>&quot;The <code>owning_ref</code> crate is a way of representing this case, but requires that the address never move&quot;</i> made me think it&#39;s not possible to use this in all situations. I&#39;ll try to figure it out better by playing with <code>owning_ref</code>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 3250, "user_id": 1259779, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/6d554eab34f0b9d148747d9913b9244d?s=128&d=identicon&r=PG", "display_name": "derekdreery", "link": "https://stackoverflow.com/users/1259779/derekdreery"}, "edited": false, "score": 0, "creation_date": 1479229315, "post_id": 32300133, "comment_id": 68465242, "body": "@derekdreery <i>it&#39;s not possible to use this in all situations</i> \u2014 that&#39;s correct <b>and a good thing</b>. References point to a specific location in memory. When the thing you are pointing to moves from that location, you don&#39;t want to continue pointing there."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1529394346, "post_id": 32300133, "comment_id": 88845504, "body": "Could you return <code>Rc&lt;WhatAboutThis&gt;</code> from <code>creator()</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1529414604, "post_id": 32300133, "comment_id": 88857930, "body": "@Timmmm No: <i>it can never be moved</i>. Returning a value moves it. Moving it into the <code>Rc</code> moves it. Since an <code>Rc</code> uses heap allocation, you can instead use rental / owning_ref."}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1529489267, "post_id": 32300133, "comment_id": 88888554, "body": "I mean I guess theoretically there should be a way to create it in-place inside the <code>Rc</code>, then it would be fine. But yeah it looks like you can&#39;t do that. :-/"}, {"owner": {"reputation": 347, "user_id": 5207376, "user_type": "registered", "accept_rate": 100, "profile_image": "https://graph.facebook.com/929972057068521/picture?type=large", "display_name": "Xu Chen", "link": "https://stackoverflow.com/users/5207376/xu-chen"}, "edited": false, "score": 0, "creation_date": 1532332781, "post_id": 32300133, "comment_id": 89916309, "body": "@Shepmaster Am I correct to say the following: 1. The code in the question is incorrect due to the move semantics, moving of parent makes the <code>&amp;p</code> that child holds no longer valid. 2. And lifetime captures such error perfectly, since <code>&amp;p</code> only has lifetime [2,4], returning it will require a longer lifetime?"}, {"owner": {"reputation": 847, "user_id": 5580553, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/54ef1b5ab609a00c87909b5187cbca3f?s=128&d=identicon&r=PG&f=1", "display_name": "Fynn Becker", "link": "https://stackoverflow.com/users/5580553/fynn-becker"}, "edited": false, "score": 0, "creation_date": 1551696996, "post_id": 32300133, "comment_id": 96721469, "body": "So if I understood correctly with Rust 1.33.0 introducing <code>std::pin::Pin&lt;P&gt;</code> self referential structs are now possible. It might be worth updating this answer with a small note about that."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 847, "user_id": 5580553, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/54ef1b5ab609a00c87909b5187cbca3f?s=128&d=identicon&r=PG&f=1", "display_name": "Fynn Becker", "link": "https://stackoverflow.com/users/5580553/fynn-becker"}, "edited": false, "score": 2, "creation_date": 1551721945, "post_id": 32300133, "comment_id": 96735338, "body": "@FynnBecker it\u2019s still impossible to store a <b>reference</b> and a value to that reference. <code>Pin</code> is mostly a way to know the safety of a struct containing a self referential <b>pointer</b>. The ability to use a raw pointer for the same purpose has existed since Rust 1.0."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 311, "last_activity_date": 1606851212, "last_edit_date": 1606851212, "creation_date": 1440961571, "answer_id": 32300133, "question_id": 32300132, "link": "https://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct/32300133#32300133", "title": "Why can&#39;t I store a value and a reference to that value in the same struct?", "body": "<p>Let's look at <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c1432ed38048684c7eb306540c182cd0\" rel=\"noreferrer\">a simple implementation of this</a>:</p>\n<pre><code>struct Parent {\n    count: u32,\n}\n\nstruct Child&lt;'a&gt; {\n    parent: &amp;'a Parent,\n}\n\nstruct Combined&lt;'a&gt; {\n    parent: Parent,\n    child: Child&lt;'a&gt;,\n}\n\nimpl&lt;'a&gt; Combined&lt;'a&gt; {\n    fn new() -&gt; Self {\n        let parent = Parent { count: 42 };\n        let child = Child { parent: &amp;parent };\n\n        Combined { parent, child }\n    }\n}\n\nfn main() {}\n</code></pre>\n<p>This will fail with the error:</p>\n<pre class=\"lang-none prettyprint-override\"><code>error[E0515]: cannot return value referencing local variable `parent`\n  --&gt; src/main.rs:19:9\n   |\n17 |         let child = Child { parent: &amp;parent };\n   |                                     ------- `parent` is borrowed here\n18 | \n19 |         Combined { parent, child }\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ returns a value referencing data owned by the current function\n\nerror[E0505]: cannot move out of `parent` because it is borrowed\n  --&gt; src/main.rs:19:20\n   |\n14 | impl&lt;'a&gt; Combined&lt;'a&gt; {\n   |      -- lifetime `'a` defined here\n...\n17 |         let child = Child { parent: &amp;parent };\n   |                                     ------- borrow of `parent` occurs here\n18 | \n19 |         Combined { parent, child }\n   |         -----------^^^^^^---------\n   |         |          |\n   |         |          move out of `parent` occurs here\n   |         returning this value requires that `parent` is borrowed for `'a`\n</code></pre>\n<p>To completely understand this error, you have to think about how the\nvalues are represented in memory and what happens when you <em>move</em>\nthose values. Let's annotate <code>Combined::new</code> with some hypothetical\nmemory addresses that show where values are located:</p>\n<pre><code>let parent = Parent { count: 42 };\n// `parent` lives at address 0x1000 and takes up 4 bytes\n// The value of `parent` is 42 \nlet child = Child { parent: &amp;parent };\n// `child` lives at address 0x1010 and takes up 4 bytes\n// The value of `child` is 0x1000\n         \nCombined { parent, child }\n// The return value lives at address 0x2000 and takes up 8 bytes\n// `parent` is moved to 0x2000\n// `child` is ... ?\n</code></pre>\n<p>What should happen to <code>child</code>? If the value was just moved like <code>parent</code>\nwas, then it would refer to memory that no longer is guaranteed to\nhave a valid value in it. Any other piece of code is allowed to store\nvalues at memory address 0x1000. Accessing that memory assuming it was\nan integer could lead to crashes and/or security bugs, and is one of\nthe main categories of errors that Rust prevents.</p>\n<p>This is exactly the problem that <em>lifetimes</em> prevent. A lifetime is a\nbit of metadata that allows you and the compiler to know how long a\nvalue will be valid at its <strong>current memory location</strong>. That's an\nimportant distinction, as it's a common mistake Rust newcomers make.\nRust lifetimes are <em>not</em> the time period between when an object is\ncreated and when it is destroyed!</p>\n<p>As an analogy, think of it this way: During a person's life, they will\nreside in many different locations, each with a distinct address. A\nRust lifetime is concerned with the address you <em>currently reside at</em>,\nnot about whenever you will die in the future (although dying also\nchanges your address). Every time you move it's relevant because your\naddress is no longer valid.</p>\n<p>It's also important to note that lifetimes <em>do not</em> change your code; your\ncode controls the lifetimes, your lifetimes don't control the code. The\npithy saying is &quot;lifetimes are descriptive, not prescriptive&quot;.</p>\n<p>Let's annotate <code>Combined::new</code> with some line numbers which we will use\nto highlight lifetimes:</p>\n<pre><code>{                                          // 0\n    let parent = Parent { count: 42 };     // 1\n    let child = Child { parent: &amp;parent }; // 2\n                                           // 3\n    Combined { parent, child }             // 4\n}                                          // 5\n</code></pre>\n<p>The <em>concrete lifetime</em> of <code>parent</code> is from 1 to 4, inclusive (which I'll\nrepresent as <code>[1,4]</code>). The concrete lifetime of <code>child</code> is <code>[2,4]</code>, and\nthe concrete lifetime of the return value is <code>[4,5]</code>. It's\npossible to have concrete lifetimes that start at zero - that would\nrepresent the lifetime of a parameter to a function or something that\nexisted outside of the block.</p>\n<p>Note that the lifetime of <code>child</code> itself is <code>[2,4]</code>, but that it <strong>refers\nto</strong> a value with a lifetime of <code>[1,4]</code>. This is fine as long as the\nreferring value becomes invalid before the referred-to value does. The\nproblem occurs when we try to return <code>child</code> from the block. This would\n&quot;over-extend&quot; the lifetime beyond its natural length.</p>\n<p>This new knowledge should explain the first two examples. The third\none requires looking at the implementation of <code>Parent::child</code>. Chances\nare, it will look something like this:</p>\n<pre><code>impl Parent {\n    fn child(&amp;self) -&gt; Child { /* ... */ }\n}\n</code></pre>\n<p>This uses <em>lifetime elision</em> to avoid writing explicit <em>generic\nlifetime parameters</em>. It is equivalent to:</p>\n<pre><code>impl Parent {\n    fn child&lt;'a&gt;(&amp;'a self) -&gt; Child&lt;'a&gt; { /* ... */ }\n}\n</code></pre>\n<p>In both cases, the method says that a <code>Child</code> structure will be\nreturned that has been parameterized with the concrete lifetime of\n<code>self</code>. Said another way, the <code>Child</code> instance contains a reference\nto the <code>Parent</code> that created it, and thus cannot live longer than that\n<code>Parent</code> instance.</p>\n<p>This also lets us recognize that something is really wrong with our\ncreation function:</p>\n<pre><code>fn make_combined&lt;'a&gt;() -&gt; Combined&lt;'a&gt; { /* ... */ }\n</code></pre>\n<p>Although you are more likely to see this written in a different form:</p>\n<pre><code>impl&lt;'a&gt; Combined&lt;'a&gt; {\n    fn new() -&gt; Combined&lt;'a&gt; { /* ... */ }\n}\n</code></pre>\n<p>In both cases, there is no lifetime parameter being provided via an\nargument. This means that the lifetime that <code>Combined</code> will be\nparameterized with isn't constrained by anything - it can be whatever\nthe caller wants it to be. This is nonsensical, because the caller\ncould specify the <code>'static</code> lifetime and there's no way to meet that\ncondition.</p>\n<h3>How do I fix it?</h3>\n<p>The easiest and most recommended solution is to not attempt to put\nthese items in the same structure together. By doing this, your\nstructure nesting will mimic the lifetimes of your code. Place types\nthat own data into a structure together and then provide methods that\nallow you to get references or objects containing references as needed.</p>\n<p>There is a special case where the lifetime tracking is overzealous:\nwhen you have something placed on the heap. This occurs when you use a\n<code>Box&lt;T&gt;</code>, for example. In this case, the structure that is moved\ncontains a pointer into the heap. The pointed-at value will remain\nstable, but the address of the pointer itself will move. In practice,\nthis doesn't matter, as you always follow the pointer.</p>\n<p>Some crates provide ways of representing this case, but they\nrequire that the base address <em>never move</em>. This rules out mutating\nvectors, which may cause a reallocation and a move of the\nheap-allocated values.</p>\n<ul>\n<li><a href=\"https://crates.io/crates/rental\" rel=\"noreferrer\">rental</a> (no longer maintained or suppported)</li>\n<li><a href=\"https://crates.io/crates/owning_ref\" rel=\"noreferrer\">owning_ref</a></li>\n<li><a href=\"https://crates.io/crates/ouroboros\" rel=\"noreferrer\">ouroboros</a></li>\n</ul>\n<p>Examples of problems solved with Rental:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/47193584/155423\">Is there an owned version of String::chars?</a></li>\n<li><a href=\"https://stackoverflow.com/q/50496879/155423\">Returning a RWLockReadGuard independently from a method</a></li>\n<li><a href=\"https://stackoverflow.com/q/51664098/155423\">How can I return an iterator over a locked struct member in Rust?</a></li>\n<li><a href=\"https://stackoverflow.com/q/40095383/155423\">How to return a reference to a sub-value of a value that is under a mutex?</a></li>\n<li><a href=\"https://stackoverflow.com/q/43702185/155423\">How do I store a result using Serde Zero-copy deserialization of a Futures-enabled Hyper Chunk?</a></li>\n<li><a href=\"https://stackoverflow.com/q/49300618/155423\">How to store a reference without having to deal with lifetimes?</a></li>\n</ul>\n<p>In other cases, you may wish to move to some type of reference-counting, such as by using <a href=\"https://doc.rust-lang.org/std/rc/struct.Rc.html\" rel=\"noreferrer\"><code>Rc</code></a> or <a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html\" rel=\"noreferrer\"><code>Arc</code></a>.</p>\n<h3>More information</h3>\n<blockquote>\n<p>After moving <code>parent</code> into the struct, why is the compiler not able to get a new reference to <code>parent</code> and assign it to <code>child</code> in the struct?</p>\n</blockquote>\n<p>While it is theoretically possible to do this, doing so would introduce a large amount of complexity and overhead. Every time that the object is moved, the compiler would need to insert code to &quot;fix up&quot; the reference. This would mean that copying a struct is no longer a very cheap operation that just moves some bits around. It could even mean that code like this is expensive, depending on how good a hypothetical optimizer would be:</p>\n<pre><code>let a = Object::new();\nlet b = a;\nlet c = b;\n</code></pre>\n<p>Instead of forcing this to happen for <em>every</em> move, the programmer gets to <em>choose</em> when this will happen by creating methods that will take the appropriate references only when you call them.</p>\n<h3>A type with a reference to itself</h3>\n<p>There's one specific case where you <em>can</em> create a type with a reference to itself. You need to use something like <code>Option</code> to make it in two steps though:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>#[derive(Debug)]\nstruct WhatAboutThis&lt;'a&gt; {\n    name: String,\n    nickname: Option&lt;&amp;'a str&gt;,\n}\n\nfn main() {\n    let mut tricky = WhatAboutThis {\n        name: &quot;Annabelle&quot;.to_string(),\n        nickname: None,\n    };\n    tricky.nickname = Some(&amp;tricky.name[..4]);\n\n    println!(&quot;{:?}&quot;, tricky);\n}\n</code></pre>\n<p>This does work, in some sense, but the created value is highly restricted - it can <em>never</em> be moved. Notably, this means it cannot be returned from a function or passed by-value to anything. A constructor function shows the same problem with the lifetimes as above:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>fn creator&lt;'a&gt;() -&gt; WhatAboutThis&lt;'a&gt; { /* ... */ }\n</code></pre>\n<p>If you try to do this same code with a method, you'll need the alluring but ultimately useless <code>&amp;'a self</code>. When that's involved, this code is even more restricted and you will get borrow-checker errors after the first method call:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>#[derive(Debug)]\nstruct WhatAboutThis&lt;'a&gt; {\n    name: String,\n    nickname: Option&lt;&amp;'a str&gt;,\n}\n\nimpl&lt;'a&gt; WhatAboutThis&lt;'a&gt; {\n    fn tie_the_knot(&amp;'a mut self) {\n       self.nickname = Some(&amp;self.name[..4]); \n    }\n}\n\nfn main() {\n    let mut tricky = WhatAboutThis {\n        name: &quot;Annabelle&quot;.to_string(),\n        nickname: None,\n    };\n    tricky.tie_the_knot();\n\n    // cannot borrow `tricky` as immutable because it is also borrowed as mutable\n    // println!(&quot;{:?}&quot;, tricky);\n}\n</code></pre>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/31067031/155423\">Cannot borrow as mutable more than once at a time in one code - but can in another very similar</a></li>\n</ul>\n<h3>What about <code>Pin</code>?</h3>\n<p><a href=\"https://doc.rust-lang.org/std/pin/struct.Pin.html\" rel=\"noreferrer\"><code>Pin</code></a>, stabilized in Rust 1.33, has this <a href=\"https://doc.rust-lang.org/std/pin/index.html\" rel=\"noreferrer\">in the module documentation</a>:</p>\n<blockquote>\n<p>A prime example of such a scenario would be building self-referential structs, since moving an object with pointers to itself will invalidate them, which could cause undefined behavior.</p>\n</blockquote>\n<p>It's important to note that &quot;self-referential&quot; doesn't necessarily mean using <em>a reference</em>. Indeed, the <a href=\"https://doc.rust-lang.org/std/pin/index.html#example-self-referential-struct\" rel=\"noreferrer\">example of a self-referential struct</a> specifically says (emphasis mine):</p>\n<blockquote>\n<p>We cannot inform the compiler about that with a normal reference,\nsince this pattern cannot be described with the usual borrowing rules.\nInstead <strong>we use a raw pointer</strong>, though one which is known to not be null,\nsince we know it's pointing at the string.</p>\n</blockquote>\n<p>The ability to use a raw pointer for this behavior has existed since Rust 1.0. Indeed, owning-ref and rental use raw pointers under the hood.</p>\n<p>The only thing that <code>Pin</code> adds to the table is a common way to state that a given value is guaranteed to not move.</p>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/49860149/155423\">How to use the Pin struct with self-referential structures?</a></li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 4989, "user_id": 120901, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/981936c810e68793c10f3626f9998c5d?s=128&d=identicon&r=PG", "display_name": "Andrew Y", "link": "https://stackoverflow.com/users/120901/andrew-y"}, "is_accepted": false, "score": 10, "last_activity_date": 1510578390, "last_edit_date": 1510578390, "creation_date": 1510563674, "answer_id": 47260399, "question_id": 32300132, "link": "https://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct/47260399#47260399", "title": "Why can&#39;t I store a value and a reference to that value in the same struct?", "body": "<p>A slightly different issue which causes very similar compiler messages is object lifetime dependency, rather than storing an explicit reference. An example of that is the <a href=\"http://alexcrichton.com/ssh2-rs/ssh2/\" rel=\"noreferrer\">ssh2</a> library. When developing something bigger than a test project, it is tempting to try to put the <code>Session</code> and <code>Channel</code> obtained from that session alongside each other into a struct, hiding the implementation details from the user. However, note that the <a href=\"http://alexcrichton.com/ssh2-rs/ssh2/struct.Channel.html\" rel=\"noreferrer\"><code>Channel</code></a> definition has the <code>'sess</code> lifetime in its type annotation, while <a href=\"http://alexcrichton.com/ssh2-rs/ssh2/struct.Session.html\" rel=\"noreferrer\"><code>Session</code></a> doesn't.</p>\n\n<p>This causes similar compiler errors related to lifetimes.</p>\n\n<p>One way to solve it in a very simple way is to declare the <code>Session</code> outside in the caller, and then for annotate the reference within the struct with a lifetime, similar to the answer in <a href=\"https://users.rust-lang.org/t/solved-first-issue-with-lifetimes/13243/16\" rel=\"noreferrer\">this Rust User's Forum post</a> talking about the same issue while encapsulating SFTP. This will not look elegant and may not always apply - because now you have two entities to deal with, rather than one that you wanted!</p>\n\n<p>Turns out the <a href=\"https://crates.io/crates/rental\" rel=\"noreferrer\">rental crate</a> or the <a href=\"https://crates.io/crates/owning_ref\" rel=\"noreferrer\">owning_ref crate</a> from the other answer are the solutions for this issue too. Let's consider the owning_ref, which has the special object for this exact purpose:\n<a href=\"http://kimundi.github.io/owning-ref-rs/owning_ref/struct.OwningHandle.html\" rel=\"noreferrer\"><code>OwningHandle</code></a>. To avoid the underlying object moving, we allocate it on the heap using a <code>Box</code>, which gives us the following possible solution:</p>\n\n<pre><code>use ssh2::{Channel, Error, Session};\nuse std::net::TcpStream;\n\nuse owning_ref::OwningHandle;\n\nstruct DeviceSSHConnection {\n    tcp: TcpStream,\n    channel: OwningHandle&lt;Box&lt;Session&gt;, Box&lt;Channel&lt;'static&gt;&gt;&gt;,\n}\n\nimpl DeviceSSHConnection {\n    fn new(targ: &amp;str, c_user: &amp;str, c_pass: &amp;str) -&gt; Self {\n        use std::net::TcpStream;\n        let mut session = Session::new().unwrap();\n        let mut tcp = TcpStream::connect(targ).unwrap();\n\n        session.handshake(&amp;tcp).unwrap();\n        session.set_timeout(5000);\n        session.userauth_password(c_user, c_pass).unwrap();\n\n        let mut sess = Box::new(session);\n        let mut oref = OwningHandle::new_with_fn(\n            sess,\n            unsafe { |x| Box::new((*x).channel_session().unwrap()) },\n        );\n\n        oref.shell().unwrap();\n        let ret = DeviceSSHConnection {\n            tcp: tcp,\n            channel: oref,\n        };\n        ret\n    }\n}\n</code></pre>\n\n<p>The result of this code is that we can not use the <code>Session</code> anymore, but it is stored alongside with the <code>Channel</code> which we will be using. Because the <code>OwningHandle</code> object dereferences to <code>Box</code>, which dereferences to <code>Channel</code>, when storing it in a struct, we name it as such. <strong>NOTE:</strong> This is just my understanding. I have a suspicion this may not be correct, since it appears to be quite close to <a href=\"https://github.com/Kimundi/owning-ref-rs/issues/27\" rel=\"noreferrer\">discussion of <code>OwningHandle</code> unsafety</a>. </p>\n\n<p>One curious detail here is that the <code>Session</code> logically has a similar relationship with <code>TcpStream</code> as <code>Channel</code> has to <code>Session</code>, yet its ownership is not taken and there are no type annotations around doing so. Instead, it is up to the user to take care of this, as the documentation of <a href=\"http://alexcrichton.com/ssh2-rs/ssh2/struct.Session.html#method.handshake\" rel=\"noreferrer\">handshake</a> method says:</p>\n\n<blockquote>\n  <p>This session does not take ownership of the socket provided, it is\n  recommended to ensure that the socket persists the lifetime of this\n  session to ensure that communication is correctly performed.</p>\n  \n  <p>It is also highly recommended that the stream provided is not used\n  concurrently elsewhere for the duration of this session as it may\n  interfere with the protocol.</p>\n</blockquote>\n\n<p>So with the <code>TcpStream</code> usage, is completely up to the programmer to ensure the correctness of the code. With the <code>OwningHandle</code>, the attention to where the \"dangerous magic\" happens is drawn using the <code>unsafe {}</code> block.</p>\n\n<p>A further and a more high-level discussion of this issue is in this <a href=\"https://users.rust-lang.org/t/how-to-write-software-without-self-referential-structs/13819/11\" rel=\"noreferrer\">Rust User's Forum thread</a> - which includes a different example and its solution using the rental crate, which does not contain unsafe blocks.</p>\n"}], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 32001, "favorite_count": 100, "accepted_answer_id": 32300133, "answer_count": 2, "score": 276, "last_activity_date": 1615078862, "creation_date": 1440961571, "last_edit_date": 1615078862, "question_id": 32300132, "link": "https://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct", "title": "Why can&#39;t I store a value and a reference to that value in the same struct?", "body": "<p>I have a value and I want to store that value and a reference to\nsomething inside that value in my own type:</p>\n\n<pre><code>struct Thing {\n    count: u32,\n}\n\nstruct Combined&lt;'a&gt;(Thing, &amp;'a u32);\n\nfn make_combined&lt;'a&gt;() -&gt; Combined&lt;'a&gt; {\n    let thing = Thing { count: 42 };\n\n    Combined(thing, &amp;thing.count)\n}\n</code></pre>\n\n<p>Sometimes, I have a value and I want to store that value and a reference to\nthat value in the same structure:</p>\n\n<pre><code>struct Combined&lt;'a&gt;(Thing, &amp;'a Thing);\n\nfn make_combined&lt;'a&gt;() -&gt; Combined&lt;'a&gt; {\n    let thing = Thing::new();\n\n    Combined(thing, &amp;thing)\n}\n</code></pre>\n\n<p>Sometimes, I'm not even taking a reference of the value and I get the\nsame error:</p>\n\n<pre><code>struct Combined&lt;'a&gt;(Parent, Child&lt;'a&gt;);\n\nfn make_combined&lt;'a&gt;() -&gt; Combined&lt;'a&gt; {\n    let parent = Parent::new();\n    let child = parent.child();\n\n    Combined(parent, child)\n}\n</code></pre>\n\n<p>In each of these cases, I get an error that one of the values \"does\nnot live long enough\". What does this error mean?</p>\n"}, {"tags": ["rust", "lifetime", "libssh2", "borrow-checker"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440950713, "post_id": 32298278, "comment_id": 52473385, "body": "This is a duplicate of <a href=\"http://stackoverflow.com/q/32209391/155423\">stackoverflow.com/q/32209391/155423</a> if you change the struct names. Does that help?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1440961662, "post_id": 32298278, "comment_id": 52476631, "body": "Or, for more information, I just attempted to create <a href=\"http://stackoverflow.com/q/32300132/155423\">this canonical question and answer</a>. If that seems useful, we can mark this as a duplicate of that."}, {"owner": {"reputation": 4989, "user_id": 120901, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/981936c810e68793c10f3626f9998c5d?s=128&d=identicon&r=PG", "display_name": "Andrew Y", "link": "https://stackoverflow.com/users/120901/andrew-y"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1510521579, "post_id": 32298278, "comment_id": 81458553, "body": "@Shepmaster - The canonical question somewhat helps thanks for writing it up! But as a Rust beginner who faces this exact same problem as here of encapsulating all the necessary pieces to abstract away an SSH &quot;connection to a device&quot;, I still struggle to come up with a working solution..."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 4989, "user_id": 120901, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/981936c810e68793c10f3626f9998c5d?s=128&d=identicon&r=PG", "display_name": "Andrew Y", "link": "https://stackoverflow.com/users/120901/andrew-y"}, "edited": false, "score": 0, "creation_date": 1510521976, "post_id": 32298278, "comment_id": 81458674, "body": "@AndrewY if you are a beginner, you can just boil down the duplicate as &quot;this is really hard to get right without causing memory unsafety, therefore it&#39;s hard to do in safe Rust&quot;. Unfortunately for you in this case, I don&#39;t think SO&#39;s purpose is to write every Nth variation of a common problem tailored for each unique case. You can look at all the duplicates of that question for more clues, or you could pop into another format (the Rust subreddit, the <a href=\"https://users.rust-lang.org/\" rel=\"nofollow noreferrer\">user&#39;s forum</a>, IRC, our own SO chat, etc.) and hope someone will walk you through the nuances specific to you."}, {"owner": {"reputation": 4989, "user_id": 120901, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/981936c810e68793c10f3626f9998c5d?s=128&d=identicon&r=PG", "display_name": "Andrew Y", "link": "https://stackoverflow.com/users/120901/andrew-y"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1510524203, "post_id": 32298278, "comment_id": 81459438, "body": "@Shepmaster - thanks, the user forum does seem quite helpful.  Particularly, <a href=\"https://users.rust-lang.org/t/solved-first-issue-with-lifetimes/13243/16\" rel=\"nofollow noreferrer\">users.rust-lang.org/t/solved-first-issue-with-lifetimes/1324&zwnj;&#8203;3/&hellip;</a> seems  like a useful idea to play with, so I will go from there."}, {"owner": {"reputation": 4989, "user_id": 120901, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/981936c810e68793c10f3626f9998c5d?s=128&d=identicon&r=PG", "display_name": "Andrew Y", "link": "https://stackoverflow.com/users/120901/andrew-y"}, "edited": false, "score": 0, "creation_date": 1510531381, "post_id": 32298278, "comment_id": 81461460, "body": "I got it working. I have posted the snippet on the rust forum so someone could critique it. Adding here in case it might be useful to someone. <a href=\"https://users.rust-lang.org/t/ssh2-encapsulating-session-and-channel/13839\" rel=\"nofollow noreferrer\">users.rust-lang.org/t/ssh2-encapsulating-session-and-channel&zwnj;&#8203;/&hellip;</a>"}], "owner": {"reputation": 153, "user_id": 5001309, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a554472103521fafdb08ab9d2136356f?s=128&d=identicon&r=PG&f=1", "display_name": "0kp", "link": "https://stackoverflow.com/users/5001309/0kp"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 282, "favorite_count": 0, "closed_date": 1441134909, "answer_count": 0, "score": 0, "last_activity_date": 1441055152, "creation_date": 1440949245, "last_edit_date": 1441055152, "question_id": 32298278, "link": "https://stackoverflow.com/questions/32298278/rust-ssh2session-lifetime-error", "closed_reason": "Duplicate", "title": "Rust: ssh2::Session lifetime error", "body": "<p><strong>Update</strong>: Related questions helped to understand what the problem is but not to solve it.</p>\n\n<p>I now understand that I can not save the <code>Sftp</code> object with <code>Session</code> in the same struct, and better generate <code>Sftp</code> when needed.\nNew Code is:</p>\n\n<pre><code>use std::io::prelude::*;\nuse std::io;\nuse ssh2;\nuse std::net::TcpStream;\nuse std::net::ToSocketAddrs;\nuse std::path::Path;\nuse ssh2::{Session, Sftp, File};\n\npub enum SftpClientError {\n    Ssh(ssh2::Error),\n    Io(io::Error)\n}\n\npub struct SftpClient {\n    session: Session,\n    stream: TcpStream,\n}\n\nimpl SftpClient {\n    pub fn new&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; SftpClient {\n        let mut s = Session::new().unwrap();\n        let mut t = TcpStream::connect(addr).unwrap();\n\n        s.handshake(&amp;t).unwrap();\n\n        SftpClient {\n            session: s,\n            stream: t,\n        }\n    }\n\n    pub fn get_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(File, Sftp), SftpClientError&gt;  {\n        let sftp = self.session.sftp().unwrap();\n        let file = match sftp.create(path) {\n            Ok(o) =&gt; o,\n            Err(e) =&gt; return Err(SftpClientError::Ssh(e)),\n        };\n\n        Ok((file, sftp))\n    }\n}\n</code></pre>\n\n<p>Which outputs a slightly different error. The new error is that <code>sftp</code> in the <code>get_file</code> method, does not live long enough.\nSo how can I make it live long enough to return a <code>File</code> and use it on the caller side?</p>\n\n<p><strong>Old Question</strong></p>\n\n<p>The following code tries to create a struct that contains all required data for a SFTP connection in the rust library <a href=\"https://crates.io/crates/ssh2\" rel=\"nofollow\">ssh2</a>. The struct is given as <code>SftpClient</code> and the <code>new</code> function should generate it.</p>\n\n<pre><code>use std::io::prelude::*;\nuse std::io;\nuse std::net::TcpStream;\nuse std::net::ToSocketAddrs;\nuse ssh2::{Session, Sftp, File};\n\npub struct SftpClient&lt;'s&gt; {\n    session: Session,\n    stream: TcpStream,\n    connection: Sftp&lt;'s&gt;,\n}\n\nimpl&lt;'s&gt; SftpClient&lt;'s&gt; {\n    pub fn new&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; SftpClient&lt;'s&gt; {\n        let mut s = Session::new().unwrap();\n        let mut t = TcpStream::connect(addr).unwrap();\n\n        s.handshake(&amp;t).unwrap();\n\n        let sftp = s.sftp().unwrap();\n        SftpClient {\n            session: s,\n            stream: t,\n            connection: sftp,\n        }\n    }\n}\n</code></pre>\n\n<p>When I compile this code rustc complains that <code>s</code> does not live long enough:</p>\n\n<pre><code>src/sftp.rs:20:20: 20:21 error: `s` does not live long enough\nsrc/sftp.rs:20         let sftp = s.sftp().unwrap();\n                                  ^\nsrc/sftp.rs:14:61: 26:6 note: reference must be valid for the lifetime 's as defined on the block at 14:60...\nsrc/sftp.rs:14     pub fn new&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; SftpClient&lt;'s&gt; {\nsrc/sftp.rs:15         let mut s = Session::new().unwrap();\nsrc/sftp.rs:16         let mut t = TcpStream::connect(addr).unwrap();\nsrc/sftp.rs:17 \nsrc/sftp.rs:18         s.handshake(&amp;t).unwrap();\nsrc/sftp.rs:19 \n               ...\nsrc/sftp.rs:15:45: 26:6 note: ...but borrowed value is only valid for the block suffix following statement 0 at 15:44\nsrc/sftp.rs:15         let mut s = Session::new().unwrap();\nsrc/sftp.rs:16         let mut t = TcpStream::connect(addr).unwrap();\nsrc/sftp.rs:17 \nsrc/sftp.rs:18         s.handshake(&amp;t).unwrap();\nsrc/sftp.rs:19 \nsrc/sftp.rs:20         let sftp = s.sftp().unwrap();\n</code></pre>\n\n<p>I don't understand why <code>s</code> does not live long enough as it's given to <code>SftpClient</code> just like the <code>Sftp</code> struct. From my understanding they should both live their happy lifes until <code>SftpClient</code> is dropped.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 1, "creation_date": 1440936909, "post_id": 32296410, "comment_id": 52469623, "body": "For starters, you can lose <code>explicitType</code> and write <code>for i in 0..256</code>, as long as you cast in <code>foo(i as u8)</code>. Then <code>i</code> will be of type <code>i32</code>. That&#39;s only marginally better though."}, {"owner": {"reputation": 10598, "user_id": 371137, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/JAV6o.jpg?s=128&g=1", "display_name": "Perseids", "link": "https://stackoverflow.com/users/371137/perseids"}, "edited": false, "score": 0, "creation_date": 1440937341, "post_id": 32296410, "comment_id": 52469753, "body": "@delnan: Your tip has brought me to <code>(0..256).map(|byte| byte as u8)</code>, which is just as unintuitive, but at least points out the magic to the reader. And it&#39;s still not good :("}], "answers": [{"comments": [{"owner": {"reputation": 2578, "user_id": 504537, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/4bb06a2b2b151a4531d001af70b6d4f6?s=128&d=identicon&r=PG", "display_name": "incrop", "link": "https://stackoverflow.com/users/504537/incrop"}, "edited": false, "score": 1, "creation_date": 1455968835, "post_id": 32296662, "comment_id": 58735330, "body": "Right now there is open <a href=\"https://github.com/rust-lang/rust/pull/30884\" rel=\"nofollow noreferrer\">pull-request</a> implementing this feature."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 5, "last_activity_date": 1440938359, "creation_date": 1440938359, "answer_id": 32296662, "question_id": 32296410, "link": "https://stackoverflow.com/questions/32296410/how-to-iterate-over-all-byte-values-overflowing-literals-in-0-256/32296662#32296662", "title": "How to iterate over all byte values (overflowing_literals in `0..256`)", "body": "<p>This is issue <a href=\"https://github.com/rust-lang/rust/issues/23635\">Unable to create a range with max value</a>.</p>\n\n<p>The gist of it is that <code>byte</code> is inferred to be <code>u8</code>, and therefore <code>0..256</code> is represented as a <code>Range&lt;u8&gt;</code> but unfortunately <code>256</code> overflows as an <code>u8</code>.</p>\n\n<p>The current work-around is to use a larger integral type and cast to <code>u8</code> later on since <code>256</code> is actually never reached.</p>\n\n<p>There is a <a href=\"https://github.com/rust-lang/rfcs/pull/1192\">RFC for inclusive range with <code>...</code></a> which has entered final comment period; maybe in the future it'll be possible to have <code>for byte in 0...255</code> or its alternative <code>(0..255).inclusive()</code>.</p>\n"}, {"comments": [{"owner": {"reputation": 393, "user_id": 1260665, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/09602b6ab4d97b748358691d9243b61d?s=128&d=identicon&r=PG", "display_name": "Silas Barta", "link": "https://stackoverflow.com/users/1260665/silas-barta"}, "edited": false, "score": 0, "creation_date": 1528245976, "post_id": 50300925, "comment_id": 88430575, "body": "Thanks!  Kind of strange that such a common case needed a relatively new notation."}, {"owner": {"reputation": 1218, "user_id": 3507731, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/yXMo2.png?s=128&g=1", "display_name": "porglezomp", "link": "https://stackoverflow.com/users/3507731/porglezomp"}, "reply_to_user": {"reputation": 393, "user_id": 1260665, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/09602b6ab4d97b748358691d9243b61d?s=128&d=identicon&r=PG", "display_name": "Silas Barta", "link": "https://stackoverflow.com/users/1260665/silas-barta"}, "edited": false, "score": 0, "creation_date": 1588646402, "post_id": 50300925, "comment_id": 108972386, "body": "Syntax ends up inspiring the longest debates, it took a while to settle on <code>..=</code> rather than <code>...</code> or something else."}], "tags": [], "owner": {"reputation": 1218, "user_id": 3507731, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/yXMo2.png?s=128&g=1", "display_name": "porglezomp", "link": "https://stackoverflow.com/users/3507731/porglezomp"}, "is_accepted": false, "score": 9, "last_activity_date": 1526076854, "creation_date": 1526076854, "answer_id": 50300925, "question_id": 32296410, "link": "https://stackoverflow.com/questions/32296410/how-to-iterate-over-all-byte-values-overflowing-literals-in-0-256/50300925#50300925", "title": "How to iterate over all byte values (overflowing_literals in `0..256`)", "body": "<p>As of Rust 1.26, inclusive ranges are stabilized using the syntax <code>..=</code>, so you can write this as:</p>\n\n<pre><code>for byte in 0..=255 {\n    foo(byte);\n}\n</code></pre>\n"}], "owner": {"reputation": 10598, "user_id": 371137, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/JAV6o.jpg?s=128&g=1", "display_name": "Perseids", "link": "https://stackoverflow.com/users/371137/perseids"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1021, "favorite_count": 0, "accepted_answer_id": 32296662, "answer_count": 2, "score": 6, "last_activity_date": 1526076854, "creation_date": 1440936534, "last_edit_date": 1518992551, "question_id": 32296410, "link": "https://stackoverflow.com/questions/32296410/how-to-iterate-over-all-byte-values-overflowing-literals-in-0-256", "title": "How to iterate over all byte values (overflowing_literals in `0..256`)", "body": "<p>I'm trying to iterate over all possible byte (<code>u8</code>) values. Unfortunately my range literals in <code>0..256</code> are cast to <code>u8</code> and <code>256</code> overflows:</p>\n\n<pre><code>fn foo(byte: u8) {\n    println!(\"{}\", byte);\n}\n\nfn main() {\n    for byte in 0..256 {\n        foo(byte);\n        println!(\"Never executed.\");\n    }\n    for byte in 0..1 {\n        foo(byte);\n        println!(\"Executed once.\");\n    }\n}\n</code></pre>\n\n<p>The above compiles with:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>warning: literal out of range for u8\n --&gt; src/main.rs:6:20\n  |\n6 |     for byte in 0..256 {\n  |                    ^^^\n  |\n  = note: #[warn(overflowing_literals)] on by default\n</code></pre>\n\n<p>The first loop body is never executed at all.</p>\n\n<p>My workaround is very ugly and feels brittle because of the cast:</p>\n\n<pre><code>for short in 0..256 {\n    let _explicit_type: u16 = short;\n    foo(short as u8);\n}\n</code></pre>\n\n<p>Is there a better way?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 5, "last_activity_date": 1440936455, "creation_date": 1440936455, "answer_id": 32296390, "question_id": 32296223, "link": "https://stackoverflow.com/questions/32296223/multiple-return-types-from-a-method/32296390#32296390", "title": "Multiple return types from a method", "body": "<p>You could design a solution around <code>trait</code>, but it would probably be much more work than simply adapting your current solution slightly:</p>\n\n<pre><code>struct DateBased{\n    series: String,\n    date: Date\n}\n\nstruct SeasonBased{\n    series: String,\n    season: i32,\n    episode: i32\n}\n\nenum ParsedFile{\n    Date(DateBased),\n    Season(SeasonBased),\n    // etc\n}\n\nfn _populate_datebased(file: DateBased) -&gt; Result&lt;PopulatedFile, TvdbError&gt;;\n\nfn _populate_seasonbased(file: SeasonBased) -&gt; Result&lt;PopulatedFile, TvdbError&gt;;\n\nfn populate(f: ParsedFile) -&gt; Result&lt;PopulatedFile, TvdbError&gt; {\n    return match f {\n        ParsedFile::Date(d) =&gt; _populate_datebased(d),\n        // ...\n    }\n}\n</code></pre>\n\n<p>You can combine <code>enum</code> and <code>struct</code> in Rust, and I personally find it worth it to put name on things specifically because it allows manipulating them more easily.</p>\n"}], "owner": {"reputation": 152698, "user_id": 745, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/edf857d71f672d8f411ef6b8376316b8?s=128&d=identicon&r=PG", "display_name": "dbr", "link": "https://stackoverflow.com/users/745/dbr"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2468, "favorite_count": 0, "accepted_answer_id": 32296390, "answer_count": 1, "score": 7, "last_activity_date": 1440942056, "creation_date": 1440935279, "last_edit_date": 1440942056, "question_id": 32296223, "link": "https://stackoverflow.com/questions/32296223/multiple-return-types-from-a-method", "title": "Multiple return types from a method", "body": "<p>I am trying to write a simple TV-episode file renamer in Rust.</p>\n\n<p>A filename is parsed, and might be one of several types (date-based, season/episode-number based etc). This parsed file is then turned into a \"populated file\" with data from a database (which is then formatted into a new filename)</p>\n\n<p>Initially I tried having the <code>parse</code> method take a filename and return an enum variant:</p>\n\n<pre><code>enum ParsedFile{\n    DateBased{series: String, date: Date},\n    SeasonBased{series: String, season: i32, episode: i32},\n    // etc\n}\n\n\nfn parse(fname:&amp;str) -&gt; Option&lt;ParsedFile&gt;{\n    ...\n}\n</code></pre>\n\n<p>This worked fine, however the methods to take the <code>ParsedFile</code> and do different things for each episode became messy</p>\n\n<p>For example, to separate the <code>ParsedFile-&gt;PopulatedFile</code> translation into separate methods, I have to match the variants, then destructure this in the method</p>\n\n<pre><code>struct PopulatedFile {\n    seriesname: String,\n    season: i32,\n    episode: i32,\n    episodename: String,\n    airdate: Date,\n}\n\nfn _populate_seasonbased(file: ParsedFile) -&gt; Result&lt;PopulatedFile, TvdbError&gt;{\n    // can't just access file.season or file.episode, have to destructure enum again\n}\n\nfn populate(f: ParsedFile) -&gt; Result&lt;PopulatedFile, TvdbError&gt; {\n    return match f {\n        ParsedFile::DateBased{..} =&gt; \n            _populate_datebased(f),\n        // ...\n    }\n}\n</code></pre>\n\n<p>This seemed really clunky, and I'm sure there must be a better way.</p>\n\n<p>It would be nicer to have each episode type as a separate struct, e.g:</p>\n\n<pre><code>struct DateBased{\n    series: String,\n    date: Date\n}\nstruct SeasonBased{\n    series: String,\n    season: i32,\n    episode: i32\n}\n</code></pre>\n\n<p>..then I could, say, implement a <code>ToPopulatedFile</code> trait for each episode type. However I couldn't find a way to write the <code>parse</code> method in this example (i.e write a method which might return a <code>DateBased</code> struct or a <code>SeasonBased</code> struct)</p>\n\n<p>Is there a good way to structure this?</p>\n"}, {"tags": ["macros", "rust"], "answers": [{"comments": [{"owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "edited": false, "score": 1, "creation_date": 1440891452, "post_id": 32291720, "comment_id": 52460847, "body": "It is possible to use <code>cfg</code> with tokens defined by a macro? It seems it only works with compile flags."}, {"owner": {"reputation": 4569, "user_id": 2799243, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cf287bd57ec416f58baa2454fdd28e1e?s=128&d=identicon&r=PG", "display_name": "thomasfuchs", "link": "https://stackoverflow.com/users/2799243/thomasfuchs"}, "edited": false, "score": 1, "creation_date": 1440891967, "post_id": 32291720, "comment_id": 52460961, "body": "@Iceberg it would be good if you provided an example (not only link to docs)."}, {"owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "edited": false, "score": 0, "creation_date": 1440938319, "post_id": 32291720, "comment_id": 52469966, "body": "I wanted to choose the macro in the code, so I did not think to use a feature. It might be an interesting alternative."}], "tags": [], "owner": {"reputation": 356, "user_id": 5280790, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/eac429a5a60ea7f567cc51ad67a95034?s=128&d=identicon&r=PG&f=1", "display_name": "Iceberg", "link": "https://stackoverflow.com/users/5280790/iceberg"}, "is_accepted": false, "score": 2, "last_activity_date": 1440976104, "last_edit_date": 1440976104, "creation_date": 1440891306, "answer_id": 32291720, "question_id": 32291210, "link": "https://stackoverflow.com/questions/32291210/how-to-choose-between-macros-at-compile-time/32291720#32291720", "title": "How to choose between macros at compile time?", "body": "<p>I would recommend using conditional compilation flags for something like this.  See <a href=\"https://doc.rust-lang.org/book/conditional-compilation.html\" rel=\"nofollow\">https://doc.rust-lang.org/book/conditional-compilation.html</a></p>\n\n<p>In your case, it might look something like this:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>#[cfg(feature = \"feature_a\")]\nmacro_rules! use_macro {\n    ($identifier:ident) =&gt; {\n        println!(\"A: {}\", stringify!($identifier));\n    }\n}\n\n#[cfg(feature = \"feature_b\")]\nmacro_rules! use_macro {\n    ($identifier:ident) =&gt; {\n        println!(\"B: {}\", stringify!($identifier));\n    }\n}\n\n#[cfg(feature = \"feature_c\")]\nmacro_rules! use_macro {\n    ($identifier:ident) =&gt; {\n        println!(\"C: {}\", stringify!($identifier));\n    }\n}\n\nfn main() {\n    use_macro!(test);\n}\n</code></pre>\n\n<p>Then add the following to your Cargo.toml file:</p>\n\n<pre class=\"lang-toml prettyprint-override\"><code>[features]\nfeature_a = []\nfeature_b = []\nfeature_c = []\n</code></pre>\n\n<p>If you want it to print out \"C: test\" for example, then run the following:</p>\n\n<pre><code>cargo run --features feature_c\n</code></pre>\n"}], "owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 496, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1440981034, "creation_date": 1440886669, "last_edit_date": 1440981034, "question_id": 32291210, "link": "https://stackoverflow.com/questions/32291210/how-to-choose-between-macros-at-compile-time", "title": "How to choose between macros at compile time?", "body": "<p>I have different versions of the same macro and I want to be able to choose one of them at compile time.</p>\n\n<p>Here is the code I have:</p>\n\n<pre><code>macro_rules! macro_a {\n    ($identifier:ident) =&gt; {\n        println!(\"A: {}\", stringify!($identifier));\n    }\n}\n\nmacro_rules! macro_b {\n    ($identifier:ident) =&gt; {\n        println!(\"B: {}\", stringify!($identifier));\n    }\n}\n\nmacro_rules! macro_c {\n    ($identifier:ident) =&gt; {\n        println!(\"C: {}\", stringify!($identifier));\n    }\n}\n\nmacro_rules! choose_macro {\n    (a) =&gt; {\n        const CHOSEN_MACRO: u32 = 1;\n    };\n    (b) =&gt; {\n        const CHOSEN_MACRO: u32 = 2;\n    };\n    (c) =&gt; {\n        const CHOSEN_MACRO: u32 = 3;\n    };\n}\n\nchoose_macro!(c);\n\nmacro_rules! use_macro {\n    ($identifier:ident) =&gt; {\n        match CHOSEN_MACRO {\n            1 =&gt; macro_a!($identifier),\n            2 =&gt; macro_b!($identifier),\n            3 =&gt; macro_c!($identifier),\n            _ =&gt; unreachable!(),\n        }\n    }\n}\n\nfn main() {\n    use_macro!(test);\n}\n</code></pre>\n\n<p>This will print, as expected:</p>\n\n<pre><code>C: test\n</code></pre>\n\n<p>I wonder if there is a better way to doing this (with macro or attribute or anything else).</p>\n\n<p>It is not clear if the macro is chosen at compile time here. Will Rust remove the match because it is on a constant?</p>\n\n<p><strong>Update:</strong> I prefer to choose the macro in the code, not using compiler flags. Also, I do not want to hide the macros that are not chosen: I want to be able to use them using their real name.</p>\n"}, {"tags": ["macros", "rust"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 13, "last_activity_date": 1440876029, "creation_date": 1440876029, "answer_id": 32289869, "question_id": 32289605, "link": "https://stackoverflow.com/questions/32289605/how-do-i-write-a-wrapper-for-a-macro-without-repeating-the-rules/32289869#32289869", "title": "How do I write a wrapper for a macro without repeating the rules?", "body": "<p><code>macro_rules!</code> is both <em>cleverer</em> and <em>dumber</em> than you might realise.</p>\n\n<p>Initially, <em>all</em> input to a macro begins life as undifferentiated token soup.  An <code>Ident</code> here, <code>StrLit</code> there, <em>etc.</em>  However, when you match and capture a bit of the input, generally the input will be parsed in an Abstract Syntax Tree node; this is the case with <code>expr</code>.</p>\n\n<p>The \"clever\" bit is that when you substitute this capture (for example, <code>$expression</code>), you don't just substitute the tokens that were originally matched: you substitute the <em>entire AST node as a single token</em>.  So there's now this weird not-really-a-token in the output that's an entire syntax element.</p>\n\n<p>The \"dumb\" bit is that this process is basically irreversible and mostly <em>totally invisible</em>.  So let's take your example:</p>\n\n<pre><code>outer!(test);\n</code></pre>\n\n<p>We run this through one level of expansion, and it becomes this:</p>\n\n<pre><code>println!(\"{}\", inner!(test));\n</code></pre>\n\n<p>Except, that's <em>not</em> what it looks like.  To make things clearer, I'm going to <em>invent some non-standard syntax</em>:</p>\n\n<pre><code>println!(\"{}\", inner!( $(test):expr ));\n</code></pre>\n\n<p>Pretend that <code>$(test):expr</code> is a single token: it's an expression which can be represented by the token sequence <code>test</code>.  It is <em>not</em> simply the token sequence <code>test</code>.  This is important, because when the macro interpreter goes to expand that <code>inner!</code> macro, it checks the first rule:</p>\n\n<pre><code>    ($test:ident) =&gt; { stringify!($test) };\n</code></pre>\n\n<p>The problem is that <code>$(test):expr</code> is an expression, <em>not an identifier</em>.  Yes, it <em>contains</em> an identifier, but the macro interpreter doesn't look that deep.  It sees an expression and just <em>gives up</em>.</p>\n\n<p>It fails to match the second rule for the same reason.</p>\n\n<p>So what do you do? ... Well, that depends.  If <code>outer!</code> doesn't do <em>any</em> sort of processing on its input, you can use a <code>tt</code> matcher instead:</p>\n\n<pre><code>macro_rules! outer {\n    ($($tts:tt)*) =&gt; {\n        println!(\"{}\", inner!($($tts)*));\n    }\n}\n</code></pre>\n\n<p><code>tt</code> will match <em>any</em> token tree (see the <a href=\"https://doc.rust-lang.org/book/macros.html\" rel=\"noreferrer\">Macros chapter of the Rust Book</a>).  <code>$($tts:tt)*</code> will match <em>any</em> sequence of tokens, without changing them.  This of this as a way to safely forward a bunch of tokens to another macro.</p>\n\n<p>If you need to do processing on the input <em>and</em> forward it on to the <code>inner!</code> macro... you're probably going to have to repeat the rules.</p>\n"}], "owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 853, "favorite_count": 1, "accepted_answer_id": 32289869, "answer_count": 1, "score": 11, "last_activity_date": 1440876093, "creation_date": 1440874133, "last_edit_date": 1440876093, "question_id": 32289605, "link": "https://stackoverflow.com/questions/32289605/how-do-i-write-a-wrapper-for-a-macro-without-repeating-the-rules", "title": "How do I write a wrapper for a macro without repeating the rules?", "body": "<p>I am trying to make a wrapper for a macro. The trouble is that I don't want to repeat the same rules in both macro. Is there a way to do that?</p>\n\n<p>Here is what I tried:</p>\n\n<pre><code>macro_rules! inner {\n    ($test:ident) =&gt; { stringify!($test) };\n    ($test:ident.run()) =&gt; { format!(\"{}.run()\", stringify!($test)) };\n}\n\nmacro_rules! outer {\n    ($expression:expr) =&gt; {\n        println!(\"{}\", inner!($expression));\n    }\n}\n\nfn main() {\n    println!(\"{}\", inner!(test));\n    println!(\"{}\", inner!(test.run()));\n    outer!(test);\n    outer!(test.run());\n}\n</code></pre>\n\n<p>but I get the following error:</p>\n\n<pre><code>src/main.rs:8:31: 8:42 error: expected ident, found test\nsrc/main.rs:8         println!(\"{}\", inner!($expression));\n                                            ^~~~~~~~~~~\n</code></pre>\n\n<p>If I change the <code>outer</code> macro for this, the code compile:</p>\n\n<pre><code>macro_rules! outer {\n    ($expression:expr) =&gt; {\n        println!(\"{}\", stringify!($expression));\n    }\n}\n</code></pre>\n\n<p>What am I doing wrong?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "edited": false, "score": 3, "creation_date": 1440860686, "post_id": 32287327, "comment_id": 52452471, "body": "It&#39;s not clear to me what exactly your problem is. The format string you mentioned is correct if you want to space-pad your string. Are you using <code>format!</code> when you should be using <code>println!</code> by any chance?"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1440861048, "last_edit_date": 1495535197, "creation_date": 1440861048, "answer_id": 32287508, "question_id": 32287327, "link": "https://stackoverflow.com/questions/32287327/format-string-with-constant-number-of-characters/32287508#32287508", "title": "Format string with constant number of characters", "body": "<p>As <a href=\"https://stackoverflow.com/questions/32287327/format-rust-string-on-constant-number-of-characters#comment52452471_32287327\">fjh says</a>, this works:</p>\n\n<pre><code>fn main() {\n    assert_eq!(\"a   \", format!(\"{:&lt;4}\", 'a'));\n    assert_eq!(\"a   \", format!(\"{:&lt;4}\", \"a\"));\n}\n</code></pre>\n"}], "owner": {"reputation": 4863, "user_id": 2482582, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/yQkZE.jpg?s=128&g=1", "display_name": "Moebius", "link": "https://stackoverflow.com/users/2482582/moebius"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 644, "favorite_count": 0, "accepted_answer_id": 32287508, "answer_count": 1, "score": 3, "last_activity_date": 1440861117, "creation_date": 1440859776, "last_edit_date": 1440861117, "question_id": 32287327, "link": "https://stackoverflow.com/questions/32287327/format-string-with-constant-number-of-characters", "title": "Format string with constant number of characters", "body": "<p>I want my string to be displayed with 4 characters like this: <code>\"a\"</code> -> <code>\"a   \"</code> when I do <code>format!(\"{}\", \"a\")</code>.</p>\n\n<p>I read the <a href=\"https://doc.rust-lang.org/std/fmt/\" rel=\"nofollow\">format documentation</a>, and tried several solutions like <code>{:&lt;4}</code> but it didn't work.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440856796, "post_id": 32285231, "comment_id": 52451311, "body": "This was <a href=\"https://www.reddit.com/r/rust/comments/3itr2s/how_method_of_use_to_lookup_host_in_stdnet/\" rel=\"nofollow noreferrer\">cross-posted to Reddit</a>"}], "answers": [{"comments": [{"owner": {"reputation": 111, "user_id": 5279601, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-rJLjRsFqskc/AAAAAAAAAAI/AAAAAAAAABI/4RctXREg_pI/photo.jpg?sz=128", "display_name": "KoMoRi HiKi", "link": "https://stackoverflow.com/users/5279601/komori-hiki"}, "edited": false, "score": 0, "creation_date": 1440851656, "post_id": 32285441, "comment_id": 52449810, "body": "Thx, but Is this #![feature(lookup_host)] can in nightly version?"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 111, "user_id": 5279601, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-rJLjRsFqskc/AAAAAAAAAAI/AAAAAAAAABI/4RctXREg_pI/photo.jpg?sz=128", "display_name": "KoMoRi HiKi", "link": "https://stackoverflow.com/users/5279601/komori-hiki"}, "edited": false, "score": 0, "creation_date": 1440853425, "post_id": 32285441, "comment_id": 52450307, "body": "<code>lookup_host</code> is unstable, and therefore it&#39;s only available on the nightly version for the moment."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 18, "last_activity_date": 1440847179, "creation_date": 1440847179, "answer_id": 32285441, "question_id": 32285231, "link": "https://stackoverflow.com/questions/32285231/mismatched-types-expected-found-result-when-using-lookup-host/32285441#32285441", "title": "Mismatched types, expected () found Result when using lookup_host", "body": "<p>You can only use the <a href=\"http://doc.rust-lang.org/stable/std/macro.try!.html\"><code>try!</code></a> macro from a function that returns a <a href=\"http://doc.rust-lang.org/stable/std/result/enum.Result.html\"><code>Result</code></a>, because the macro tries to <code>return</code> from the function if the expression is an <code>Err</code>.</p>\n\n<pre><code>#![feature(lookup_host)]\n\nuse std::io::Error;\nuse std::net;\n\nfn main0() -&gt; Result&lt;(), Error&gt; {\n    for host in try!(net::lookup_host(\"rust-lang.org\")) {\n        println!(\"found address : {}\", try!(host));\n    }\n    Ok(())\n}\n\nfn main() {\n    // unwrap() will panic if main0() returns an error.\n    main0().unwrap();\n}\n</code></pre>\n"}], "owner": {"reputation": 111, "user_id": 5279601, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-rJLjRsFqskc/AAAAAAAAAAI/AAAAAAAAABI/4RctXREg_pI/photo.jpg?sz=128", "display_name": "KoMoRi HiKi", "link": "https://stackoverflow.com/users/5279601/komori-hiki"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 9390, "favorite_count": 1, "closed_date": 1440855052, "accepted_answer_id": 32285441, "answer_count": 1, "score": 10, "last_activity_date": 1440854955, "creation_date": 1440845763, "last_edit_date": 1440854955, "question_id": 32285231, "link": "https://stackoverflow.com/questions/32285231/mismatched-types-expected-found-result-when-using-lookup-host", "closed_reason": "Duplicate", "title": "Mismatched types, expected () found Result when using lookup_host", "body": "<p>I am using <a href=\"https://doc.rust-lang.org/std/net/fn.lookup_host.html\">std::net::lookup_host</a>. When I build, an error occurs. I am using Rust 1.2.</p>\n\n<pre><code>use std::net;\nfn main() {\n    for host in try!(net::lookup_host(\"rust-lang.org\")) {\n        println!(\"found address : {}\", try!(host));\n    }\n}\n</code></pre>\n\n<p>Error</p>\n\n<pre><code>&lt;std macros&gt;:5:8: 6:42 error: mismatched types:\n expected `()`,\n    found `core::result::Result&lt;_, _&gt;`\n(expected (),\n    found enum `core::result::Result`) [E0308]\n&lt;std macros&gt;:5 return $ crate:: result:: Result:: Err (\n&lt;std macros&gt;:6 $ crate:: convert:: From:: from ( err ) ) } } )\n&lt;std macros&gt;:1:1: 6:48 note: in expansion of try!\nexam.rs:4:14: 4:53 note: expansion site\nnote: in expansion of for loop expansion\nexam.rs:4:2: 6:3 note: expansion site\n&lt;std macros&gt;:5:8: 6:42 help: run `rustc --explain E0308` to see a detailed explanation\n&lt;std macros&gt;:5:8: 6:42 error: mismatched types:\n expected `()`,\n    found `core::result::Result&lt;_, _&gt;`\n(expected (),\n    found enum `core::result::Result`) [E0308]\n&lt;std macros&gt;:5 return $ crate:: result:: Result:: Err (\n&lt;std macros&gt;:6 $ crate:: convert:: From:: from ( err ) ) } } )\n&lt;std macros&gt;:1:1: 6:48 note: in expansion of try!\nexam.rs:5:34: 5:44 note: expansion site\nnote: in expansion of format_args!\n&lt;std macros&gt;:2:25: 2:56 note: expansion site\n&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!\n&lt;std macros&gt;:3:1: 3:54 note: expansion site\n&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!\nexam.rs:5:3: 5:46 note: expansion site\nnote: in expansion of for loop expansion\nexam.rs:4:2: 6:3 note: expansion site\n&lt;std macros&gt;:5:8: 6:42 help: run `rustc --explain E0308` to see a detailed explanation\nerror: aborting due to 2 previous errors\n</code></pre>\n"}, {"tags": ["rust", "traits"], "answers": [{"comments": [{"owner": {"reputation": 2442, "user_id": 1364327, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/08dd145367a0f55343deb60db7306549?s=128&d=identicon&r=PG", "display_name": "petrbel", "link": "https://stackoverflow.com/users/1364327/petrbel"}, "edited": false, "score": 0, "creation_date": 1440843094, "post_id": 32284662, "comment_id": 52447633, "body": "I think of traits as interfaces in Java, therefore I expect <code>MyInterface i = new MyClass();</code> be working. Anyway, thanks for help, I&#39;ll do it as you proposed."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 2442, "user_id": 1364327, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/08dd145367a0f55343deb60db7306549?s=128&d=identicon&r=PG", "display_name": "petrbel", "link": "https://stackoverflow.com/users/1364327/petrbel"}, "edited": false, "score": 1, "creation_date": 1440852514, "post_id": 32284662, "comment_id": 52450062, "body": "@petrbel: that would be equivalent to <code>let bar: Box&lt;MyTrait&gt; = Box::new(MyStruct::new());</code>."}], "tags": [], "owner": {"reputation": 3724, "user_id": 2036669, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/YPdn3.jpg?s=128&g=1", "display_name": "Jacob Wang", "link": "https://stackoverflow.com/users/2036669/jacob-wang"}, "is_accepted": true, "score": 1, "last_activity_date": 1440841098, "last_edit_date": 1495542122, "creation_date": 1440841098, "answer_id": 32284662, "question_id": 32284443, "link": "https://stackoverflow.com/questions/32284443/object-to-trait-conversion/32284662#32284662", "title": "Object to trait conversion", "body": "<p>You don't need to define <code>bar</code> as a <code>MyTrait</code> object. (This is even the wrong thinking, because rust doesn't really have inheritance. Think of traits as more like interfaces in Java. In this case, it seems like you're treating <code>MyTrait</code> as a superclass of <code>MyStruct</code>)</p>\n\n<p>You can do this</p>\n\n<pre><code>let bar = MyStruct::new();\n</code></pre>\n\n<p>and then just pass it in function defined like this:</p>\n\n<pre><code>fn my_method&lt;T: MyTrait&gt;(param: T) {...}\n\nmy_method(bar)\n</code></pre>\n\n<p>This works because Rust statically checks that <code>bar</code>, which is of type <code>MyStruct</code>, implements the trait <code>MyTrait</code>.</p>\n\n<p>Side note: If you want to create a vector of trait objects, check <a href=\"https://stackoverflow.com/questions/25818082/vector-of-objects-belonging-to-a-trait\">this</a> question.</p>\n"}, {"tags": [], "owner": {"reputation": 864, "user_id": 1854569, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/9f3821f6a6ab7930c9cd7466a6a62faa?s=128&d=identicon&r=PG", "display_name": "Nathan Lilienthal", "link": "https://stackoverflow.com/users/1854569/nathan-lilienthal"}, "is_accepted": false, "score": 1, "last_activity_date": 1441087842, "creation_date": 1441087842, "answer_id": 32324678, "question_id": 32284443, "link": "https://stackoverflow.com/questions/32284443/object-to-trait-conversion/32324678#32324678", "title": "Object to trait conversion", "body": "<p>This is because a trait may be implmented by many types and therefor the size of <code>bar</code> is unknown. However a reference's size would be know, so the following works.</p>\n\n<pre><code>trait MyTrait {}\nstruct MyStruct;\nimpl MyTrait for MyStruct {}\nimpl MyStruct {\n    fn new() -&gt; Self {\n        MyStruct\n    }\n}\n\nfn main() {\n    let foo: MyStruct = MyStruct::new();\n    let bar: &amp;MyTrait = &amp;MyStruct::new();\n}\n</code></pre>\n\n<p>Notice that <code>bar</code> isn't a <code>MyTrait</code>, it's a <code>&amp;MyTrait</code>, this is called a <a href=\"http://doc.rust-lang.org/nightly/book/trait-objects.html\" rel=\"nofollow\">trait object</a>.</p>\n"}], "owner": {"reputation": 2442, "user_id": 1364327, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/08dd145367a0f55343deb60db7306549?s=128&d=identicon&r=PG", "display_name": "petrbel", "link": "https://stackoverflow.com/users/1364327/petrbel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 68, "favorite_count": 0, "accepted_answer_id": 32284662, "answer_count": 2, "score": 0, "last_activity_date": 1441087842, "creation_date": 1440839302, "question_id": 32284443, "link": "https://stackoverflow.com/questions/32284443/object-to-trait-conversion", "title": "Object to trait conversion", "body": "<p>Assuming the following Rust code:</p>\n\n<pre><code>trait  MyTrait {...}\nstruct MyStruct;\nimpl   MyTrait for MyStruct {...}\nimpl   MyStruct {\n     pub fn new() -&gt; MyStruct { MyStruct{...} }\n}\n</code></pre>\n\n<p>I'm able to write:</p>\n\n<pre><code>let foo: MyStruct = MyStruct::new();\n</code></pre>\n\n<p>However I can't </p>\n\n<pre><code>let bar: MyTrait  = MyStruct::new();\n</code></pre>\n\n<p>Other interface-oriented programming languages can do that. Am I missing something? How can I pass various objects to a method that accepts only <code>MyTrait</code>? Do I need to use \"templates\" such as <code>my_method&lt;T: MyTrait&gt;(param: T) {...}</code>?</p>\n"}, {"tags": ["iterator", "rust"], "answers": [{"comments": [{"owner": {"reputation": 1369, "user_id": 1780687, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/d932de85d335ada336cd607f4d2439f9?s=128&d=identicon&r=PG", "display_name": "Nikolai", "link": "https://stackoverflow.com/users/1780687/nikolai"}, "edited": false, "score": 1, "creation_date": 1440848177, "post_id": 32285443, "comment_id": 52448842, "body": "Thanks for the answer. But I don&#39;t quite understand why an empty iterator has to be tied to a concrete collection instance. It looks to me like a flaw in the standard library. An unnecessary heap allocation like this is certainly not a zero cost abstraction."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 2, "creation_date": 1440848614, "post_id": 32285443, "comment_id": 52448954, "body": "It&#39;s if you need that particular type. The slice iterator is an exception: <code>[].iter()</code> and <code>[].iter_mut()</code> both should be fine."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1440848654, "post_id": 32285443, "comment_id": 52448961, "body": "I&#39;d use an enum of the two cases rather than using a boxed iterator."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1440848827, "post_id": 32285443, "comment_id": 52449003, "body": "@bluss, isn&#39;t <code>[]</code> an empty array? It has the same ownership semantics and will be destroyed after the function ends, so you can&#39;t return an iterator from it. Also, enum with two cases would require manual implementation of <code>Iterator</code>, but yes, it is a viable solution."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 1369, "user_id": 1780687, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/d932de85d335ada336cd607f4d2439f9?s=128&d=identicon&r=PG", "display_name": "Nikolai", "link": "https://stackoverflow.com/users/1780687/nikolai"}, "edited": false, "score": 3, "creation_date": 1440849097, "post_id": 32285443, "comment_id": 52449074, "body": "@Nikolai, there is no difference between empty and non-empty iterators. What matters is iterator type. <code>Iterator</code> is a trait, and there are types which implement this trait. Each collection has its own iterator type because data structures are different, and iterators must know about collection implementation. Therefore, iterators for different collections are incompatible. More problems arise when iterators are yielding references, because then they are tied to collections via lifetime parameters in types."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1440850143, "post_id": 32285443, "comment_id": 52449404, "body": "@VladimirMatveev <a href=\"https://play.rust-lang.org/?gist=8f76cbfa64d418f8b364&amp;version=stable\" rel=\"nofollow noreferrer\">It&#39;s fine,</a> rust gives out a static empty array."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440850788, "post_id": 32285443, "comment_id": 52449567, "body": "Indeed, you&#39;re right. This won&#39;t work for anything except slices, though."}, {"owner": {"reputation": 7096, "user_id": 3990767, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/0a5741a212e3b0e6bd46a8a1e6d76a4a?s=128&d=identicon&r=PG", "display_name": "SOFe", "link": "https://stackoverflow.com/users/3990767/sofe"}, "edited": false, "score": 0, "creation_date": 1564478676, "post_id": 32285443, "comment_id": 101035159, "body": "Does the compiler optimize it away somehow? This is unnecessarily allocating heap memory somehow."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 8, "last_activity_date": 1440847198, "creation_date": 1440847198, "answer_id": 32285443, "question_id": 32284362, "link": "https://stackoverflow.com/questions/32284362/how-to-create-an-empty-iterator-for-a-certain-collection-type-list-set-map-in/32285443#32285443", "title": "How to create an empty iterator for a certain collection type (list/set/map) in Rust?", "body": "<p>You cannot do it, not with by-reference iterators, because they are always tied to a concrete collection instance.</p>\n\n<p>What you can do is to return boxed iterator as a trait object:</p>\n\n<pre><code>pub fn adjacent_nodes&lt;'a&gt;(&amp;'a self, node: usize) -&gt; Box&lt;Iterator&lt;Item=usize&gt;+'a&gt; {\n    match self.nodes.get(&amp;node) {\n        Some(x) =&gt; Box::new(x.iter()),\n        _ =&gt; Box::new(::std::iter::empty())\n    }\n}\n</code></pre>\n\n<p><a href=\"http://doc.rust-lang.org/std/iter/fn.empty.html\" rel=\"noreferrer\"><code>std::iter::empty()</code></a> returns an empty iterator, but of course its type is different from those of collection iterators, so you have to use a trait object. I also had to add a lifetime parameter because the iterator returned by <code>iter()</code> is tied to <code>self.nodes</code>, and you need to explain it to the compiler.</p>\n"}], "owner": {"reputation": 1369, "user_id": 1780687, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/d932de85d335ada336cd607f4d2439f9?s=128&d=identicon&r=PG", "display_name": "Nikolai", "link": "https://stackoverflow.com/users/1780687/nikolai"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2258, "favorite_count": 1, "answer_count": 1, "score": 10, "last_activity_date": 1440859203, "creation_date": 1440838755, "last_edit_date": 1440859203, "question_id": 32284362, "link": "https://stackoverflow.com/questions/32284362/how-to-create-an-empty-iterator-for-a-certain-collection-type-list-set-map-in", "title": "How to create an empty iterator for a certain collection type (list/set/map) in Rust?", "body": "<p>I want to write a method which returns an iterator for a collection (e.g.\n<code>LinkedList</code>). But in some cases there's no suitable collection to return an\niterator for. In such cases I'd like to return an \"empty\" iterator which\niterates over no elements. But I couldn't find any associated function to\nconstruct a <code>linked_list::Iter</code> in the <a href=\"https://doc.rust-lang.org/nightly/std/collections/linked_list/struct.Iter.html\" rel=\"noreferrer\">documentation</a>.</p>\n\n<p>Consider the following example:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::collections::LinkedList;\nuse std::collections::linked_list;\n\npub struct Graph {\n    nodes: HashMap&lt;usize, LinkedList&lt;usize&gt;&gt;,\n}\n\nimpl Graph {\n    pub fn adjacent_nodes(&amp;self, node: usize) -&gt; linked_list::Iter&lt;usize&gt; {\n        match self.nodes.get(&amp;node) {\n            Some(x) =&gt; x.iter(),\n            _ =&gt; linked_list::Iter::&lt;usize&gt;::new()\n        }\n    }\n}\n</code></pre>\n\n<p>I'd like to return an iterator over adjacent nodes from the <code>adjacent_nodes</code>\nmethod. But when asked for neighbours of a non-existing node, the method should\nreturn an iterator over nothing, obviously. But how could I create it? The code\nI gave doesn't compile actually:</p>\n\n<pre><code>src/graph.rs:13:18: 13:49 error: no associated item named `new` found for type\n        `collections::linked_list::Iter&lt;'_, usize&gt;` in the current scope\nsrc/graph.rs:13             _ =&gt; linked_list::Iter::&lt;usize&gt;::new()\n                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre>\n\n<p>I guess, I could solve the problem with <code>boxed::Box</code> but it is clearly a\nsuboptimal solution because of unnecessary heap allocation that I try to avoid.</p>\n\n<p>So, my question is: Is it possible in Rust to create an iterator-over-nothing of\nspecific type?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user266003"}, "edited": false, "score": 0, "creation_date": 1440855418, "post_id": 32285406, "comment_id": 52450902, "body": "what does bin has the double &quot;[[&quot;?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 2, "creation_date": 1440857096, "post_id": 32285406, "comment_id": 52451422, "body": "That&#39;s because multiple <code>bin</code> sections are possible. See <a href=\"https://github.com/toml-lang/toml\" rel=\"nofollow noreferrer\">TOML</a> description for more information, in particular, <a href=\"https://github.com/toml-lang/toml#array-of-tables\" rel=\"nofollow noreferrer\">this</a> section."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 3, "last_activity_date": 1440846965, "creation_date": 1440846965, "answer_id": 32285406, "question_id": 32283800, "link": "https://stackoverflow.com/questions/32283800/creating-a-library-and-executable-in-a-single-project/32285406#32285406", "title": "Creating a library and executable in a single project", "body": "<p>Indeed, it's strange that crates.io does not have a clear example of this.</p>\n\n<p>To add both a library and an executable to your crate (BTW, the crate can only have one library in it), you need to defined them in <code>[lib]</code> and <code>[[bin]]</code> sections:</p>\n\n<pre><code>[lib]\nname = \"yourcrate\"\n\n[[bin]]\nname = \"yourcrate_bin_1\"\n\n[[bin]]\nname = \"yourcrate_bin_2\"\n</code></pre>\n\n<p>With the above by default Cargo will look for the library crate root in <code>src/lib.rs</code> and for binaries in <code>src/bin/yourcrate_bin_1.rs</code> and <code>src/bin/yourcrate_bin_2.rs</code>. You can change paths to the crate root files with <code>path</code> option:</p>\n\n<pre><code>[[bin]]\nname = \"yourcrate_bin_2\"\npath = \"src/yourcrate_bin_2.rs\"\n</code></pre>\n"}], "owner": {"user_type": "does_not_exist", "display_name": "user266003"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 937, "favorite_count": 0, "closed_date": 1440855213, "accepted_answer_id": 32285406, "answer_count": 1, "score": 5, "last_activity_date": 1440846965, "creation_date": 1440834011, "question_id": 32283800, "link": "https://stackoverflow.com/questions/32283800/creating-a-library-and-executable-in-a-single-project", "closed_reason": "Duplicate", "title": "Creating a library and executable in a single project", "body": "<p>How do I create a library and executable in one project? I just want to test my library while working on it and using tests isn't always the best way to do that. I believe I have to use <code>[lib]</code> and <code>[???]</code> but I haven't found the information about that at crates.io.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1440852200, "post_id": 32285299, "comment_id": 52449980, "body": "I&#39;m not 100% sure I need the crep field, but I recall doing it that way for a specific reason. Like, I was pretty sure there was <i>something</i> in the library that required the CSvmProb to not die."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 0, "last_activity_date": 1440846202, "creation_date": 1440846202, "answer_id": 32285299, "question_id": 32282995, "link": "https://stackoverflow.com/questions/32282995/is-this-element-rust-marks-as-dead-code-necessary/32285299#32285299", "title": "Is this element Rust marks as &quot;dead code&quot; necessary?", "body": "<blockquote>\n  <p>My question is: is this really dead code, or do I need to maintain raw_data for the memory to stay alive like I think I do?</p>\n</blockquote>\n\n<p>Yes, you need to maintain <code>raw_data</code>, or else <code>crep</code> will be invalidated.</p>\n\n<p>Do you absolutely need that <code>crep</code> field in <code>SvmProb</code>? I would instead suggest you add a <code>crep()</code> method that looks like this:</p>\n\n<pre><code>impl SvmProb {\n    #[inline]\n    fn crep(&amp;mut self) -&gt; CSvmProb {\n        CSvmProb { data: self.raw_data.as_mut_ptr() }\n    }\n}\n</code></pre>\n\n<p>If you need more data to initialize a <code>CSvmProb</code> this way, you'll need to add the corresponding fields to <code>SvmProb</code> first.</p>\n"}], "owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 229, "favorite_count": 0, "accepted_answer_id": 32285299, "answer_count": 1, "score": 0, "last_activity_date": 1440846202, "creation_date": 1440825994, "question_id": 32282995, "link": "https://stackoverflow.com/questions/32282995/is-this-element-rust-marks-as-dead-code-necessary", "title": "Is this element Rust marks as &quot;dead code&quot; necessary?", "body": "<p>I'm writing an FFI wrapper to libsvm. One of the structs it uses has a <code>**struct{int, double}</code> as a member. The exact specification of this isn't important, but it's basically just a list of sparse vectors of doubles.</p>\n\n<p>In my wrapper, obviously I'm allowing data to come in from the Rust side, so I have:</p>\n\n<pre><code>#[repr(C)]\npub struct SvmNode(pub i32, pub f64);\n\n#[repr(C)]\nstruct CSvmProb {\n    data: *mut *mut SvmNode\n    // other fields that aren't important\n}\n\npub struct SvmProb {\n    crep: CSvmProb,\n    data: Vec&lt;Vec&lt;SvmNode&gt;&gt;,\n    // other fields that aren't important\n\n    raw_data: Vec&lt;*mut SvmNode&gt;\n}\n\nextern \"C\" fn do_something(prob: *mut CSvmProb);\n</code></pre>\n\n<p>For reference, the C versions of these things look like:</p>\n\n<pre><code>struct svm_node {\n    int index;\n    double value;\n};\n\nstruct svm_prob {\n    struct svm_node **data; \n    // other fields that aren't important to the question\n};\n\nvoid do_something(svm_prob *prob);\n</code></pre>\n\n<p>The <code>data</code> member is read-only from the Rust side, it's just used for looking up stuff after you construct the problem.</p>\n\n<p>The <code>data</code> field of the <code>SvmProb</code>'s <code>crep</code> is actually just <code>raw_data.as_ptr()</code>. The way it's constructed is by taking the <code>as_mut_ptr</code> from each element of <code>data</code>:</p>\n\n<pre><code>impl SvmProb {\n    pub fn new(mut data: Vec&lt;Vec&lt;SvmNode&gt;&gt;) -&gt; SvmProb {\n        let raw_data = Vec::with_capacity(data.len());\n\n        for v in data.iter_mut() {\n            raw_data.push(v.as_mut_ptr());\n        }\n\n        // ...\n\n        let crep = CSvmProb{ data: raw_data.as_ptr() };\n        SvmProb { data: data, crep: crep }\n    }\n}\n</code></pre>\n\n<p>The problem is, <code>raw_data</code> is never accessed or set after <code>SvmProb</code> is constructed, the <code>raw_data</code> pointer is added to <code>crep</code> before SvmProb is constructed and yielded by the new function. So rustc/Cargo complains about <code>SvmProb</code>'s member <code>raw_data</code> being \"dead code\". </p>\n\n<p>My question is: is this really dead code, or do I need to maintain <code>raw_data</code> for the memory to stay alive like I think I do? Alternatively, is there a way force a <code>Vec</code> to yield its raw pointer and tell it that it will no longer need to manage it when it's <code>drop</code>ped? Alternatively alternatively, is there a way without <code>#[allow(dead_code)]</code> to hint to Rust that the only reason a Vec exists is for memory keep-alive purposes?</p>\n\n<p>I realize I <em>could</em> populate <code>CSvmNode.data</code> by using <code>heap::allocate</code> and a variety of other unsafe accessors, but I feel like using a Vec to manage this and then taking its pointer is safer and less error prone.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "edited": false, "score": 3, "creation_date": 1440824784, "post_id": 32282872, "comment_id": 52443963, "body": "Perhaps for defensive programming reasons? If done the second way, it would erroneously return <code>&quot;crate&quot;</code> for <i>every</i> enum member even if more members were added to the enum later but you forgot to update <code>as_str()</code> to reflect that fact. This way, however, the compiler has a chance to catch these kind of errors."}], "answers": [{"tags": [], "owner": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "is_accepted": true, "score": 3, "last_activity_date": 1440826307, "creation_date": 1440826307, "answer_id": 32283022, "question_id": 32282872, "link": "https://stackoverflow.com/questions/32282872/why-match-on-a-enum-with-a-single-variant-for-returning-a-static-str/32283022#32283022", "title": "Why match on a enum with a single variant for returning a static&#39; str?", "body": "<p>Perhaps for defensive programming reasons? If done the second way, the function would erroneously return <code>\"crate\"</code> for every enum member even if more members were added to the enum later but you forgot to update <code>as_str()</code> to reflect that fact. This way, however, the compiler has a chance to catch these kind of errors.</p>\n"}], "owner": {"reputation": 955, "user_id": 1207998, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/a992586a259ed5c616c7d41de618f6bb?s=128&d=identicon&r=PG", "display_name": "Jos&#233; Manuel", "link": "https://stackoverflow.com/users/1207998/jos%c3%a9-manuel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 281, "favorite_count": 0, "accepted_answer_id": 32283022, "answer_count": 1, "score": 2, "last_activity_date": 1440826307, "creation_date": 1440824427, "question_id": 32282872, "link": "https://stackoverflow.com/questions/32282872/why-match-on-a-enum-with-a-single-variant-for-returning-a-static-str", "title": "Why match on a enum with a single variant for returning a static&#39; str?", "body": "<p>This code is from rustc libsyntax/parse/token.rs:</p>\n\n<pre><code>pub enum SpecialMacroVar {\n    CrateMacroVar,\n}\n\nimpl SpecialMacroVar {\n    pub fn as_str(self) -&gt; &amp;'static str {\n        match self {\n            SpecialMacroVar::CrateMacroVar =&gt; \"crate\",\n        }\n    }\n}\n</code></pre>\n\n<p>Why you would do that and not simply this instead?</p>\n\n<pre><code>impl SpecialMacroVar {\n    pub fn as_str(self) -&gt; &amp;'static str {\n        \"crate\"\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 8256, "user_id": 937324, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/5sD0l.jpg?s=128&g=1", "display_name": "Gabriel Southern", "link": "https://stackoverflow.com/users/937324/gabriel-southern"}, "edited": false, "score": 0, "creation_date": 1440812022, "post_id": 32281418, "comment_id": 52442076, "body": "I&#39;m not sure what you mean by &quot;You probably want to pass in a raw pointer from the Rust side.&quot;  I&#39;m trying to see if I can use the C interface that Go exposes, so in theory the Go library function doesn&#39;t know whether it is called from Rust, C, Python, etc.  The interface that Go exposes has the GoSlice struct which takes the raw pointer that it will then use internally.  At least I think that is what is happening, I&#39;m still figuring things out hence my question."}, {"owner": {"reputation": 1987, "user_id": 5278682, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/34509cba2b4d128dce294dcf5092d300?s=128&d=identicon&r=PG&f=1", "display_name": "Eli Friedman", "link": "https://stackoverflow.com/users/5278682/eli-friedman"}, "reply_to_user": {"reputation": 8256, "user_id": 937324, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/5sD0l.jpg?s=128&g=1", "display_name": "Gabriel Southern", "link": "https://stackoverflow.com/users/937324/gabriel-southern"}, "edited": false, "score": 0, "creation_date": 1440877785, "post_id": 32281418, "comment_id": 52457738, "body": "What I was trying to say is that you should change the Go library so it doesn&#39;t expose a function which takes a slice as an argument."}], "tags": [], "owner": {"reputation": 1987, "user_id": 5278682, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/34509cba2b4d128dce294dcf5092d300?s=128&d=identicon&r=PG&f=1", "display_name": "Eli Friedman", "link": "https://stackoverflow.com/users/5278682/eli-friedman"}, "is_accepted": false, "score": 3, "last_activity_date": 1440807301, "creation_date": 1440807301, "answer_id": 32281418, "question_id": 32281039, "link": "https://stackoverflow.com/questions/32281039/understanding-warning-use-of-derive-with-a-raw-pointer-warning/32281418#32281418", "title": "Understanding &quot;warning: use of `#[derive]` with a raw pointer&quot; warning", "body": "<p>Basically, the warning is just \"this looks suspicious: can you really clone this struct by just copying the raw pointer?\".  If you're sure what you're doing is actually right, you can just implement Copy and Clone by hand.</p>\n\n<p>In this particular case... you probably shouldn't be trying to manipulate a Go slice from Rust code in the first place.  You probably want to pass in a raw pointer from the Rust side, and convert it to a slice in Go code.  Otherwise, the next person who comes along to modify the Go code is going to assume that the lifetime of the slice is managed by the Go garbage collector.</p>\n"}], "owner": {"reputation": 8256, "user_id": 937324, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/5sD0l.jpg?s=128&g=1", "display_name": "Gabriel Southern", "link": "https://stackoverflow.com/users/937324/gabriel-southern"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 150, "favorite_count": 1, "answer_count": 1, "score": 2, "last_activity_date": 1440813343, "creation_date": 1440803425, "last_edit_date": 1440813343, "question_id": 32281039, "link": "https://stackoverflow.com/questions/32281039/understanding-warning-use-of-derive-with-a-raw-pointer-warning", "title": "Understanding &quot;warning: use of `#[derive]` with a raw pointer&quot; warning", "body": "<h3>Summary</h3>\n\n<p>I'm trying to understand what the following warning means and what the best way to silence it is if there's not an actual problem with my code.</p>\n\n<pre><code>warning: use of `#[derive]` with a raw pointer, #[warn(raw_pointer_derive)] on by default\n</code></pre>\n\n<h3>Details</h3>\n\n<p>I am mostly interested in understanding what this warning means, but the details of why I am seeing it are that I have some library code written in Go and I have exported that code and want to call it from Rust. As of version 1.5, Go has an option to generate a C interface. This includes a generated header file that contains the declaration:</p>\n\n<pre><code>typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;\n</code></pre>\n\n<p>I also have an exported function in the generated C file that uses this <code>struct</code>:</p>\n\n<pre><code>extern GoUint64 Foo(GoSlice p0);\n</code></pre>\n\n<p>To call this function from Rust I create a <code>struct</code> as follows:</p>\n\n<pre><code>#[repr(C)]\n#[derive(Copy, Clone)]\npub struct GoSlice {\n    pub data: *const u64,\n    pub len:  c_long,\n    pub cap:  c_long,\n}\n</code></pre>\n\n<p>I also import the function as:</p>\n\n<pre><code>extern fn Foo(data: GoSlice) -&gt; c_ulong;\n</code></pre>\n\n<p>Then when I use the function I do something like:</p>\n\n<pre><code>fn call_foo(arr: &amp;[u64]) -&gt; u64 {\n    let res: u64;\n    let go_slice = GoSlice {\n        data: arr.as_ptr(),\n        len: arr.len() as i64,\n        cap: arr.len() as i64\n    };\n    unsafe {\n        res = Foo(go_slice);\n    }\n    return res;\n}\n</code></pre>\n\n<p>So I think that I need the <code>go_slice</code> object to be copied, which is why I added the <code>#[derive(Copy, Clone)]</code>, but I'm not certain whether the warning means there is a real problem or not.  If not, I'd like to silence it if possible, and if there's an actual problem then I want to fix my code.</p>\n\n<p>I'm using rust nightly and this warning happens with <code>rustc 1.4.0-nightly (20a8412e0 2015-08-28)</code></p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 1987, "user_id": 5278682, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/34509cba2b4d128dce294dcf5092d300?s=128&d=identicon&r=PG&f=1", "display_name": "Eli Friedman", "link": "https://stackoverflow.com/users/5278682/eli-friedman"}, "is_accepted": true, "score": 4, "last_activity_date": 1440805180, "creation_date": 1440805180, "answer_id": 32281244, "question_id": 32280150, "link": "https://stackoverflow.com/questions/32280150/how-can-i-expose-a-safe-wrapper-around-an-owned-pointer/32281244#32281244", "title": "How can I expose a safe wrapper around an owned pointer?", "body": "<blockquote>\n  <p>I could have separate structs for StructA based on whether it's standalone and needs to be freed or if it's a reference, but I'm hoping that's unnecessary.</p>\n</blockquote>\n\n<p>It's necessary.  The difference between an owned <code>StructA *</code> and a borrowed <code>StructA *</code> is precisely the same as the difference between a <code>Box&lt;T&gt;</code> and a <code>&amp;T</code>.  They're both \"just a pointer\", but the semantics are completely different.</p>\n\n<p>Something along these lines is probably what you want:</p>\n\n<pre><code>use std::marker::PhantomData;\nstruct OwnedA(*mut c_void);\nimpl Drop for OwnedA {\n    fn drop(&amp;mut self) { }\n}\nimpl OwnedA {\n    fn deref(&amp;self) -&gt; RefA { RefA(self.0, PhantomData) }\n}\nstruct RefA&lt;'a&gt;(*mut c_void, PhantomData&lt;&amp;'a u8&gt;);\n\nstruct OwnedB(*mut c_void);\n\nimpl Drop for OwnedB {\n    fn drop(&amp;mut self) { }\n}\n\nimpl OwnedB {\n    fn get_a(&amp;self) -&gt; RefA { RefA(get_struct(self.0), PhantomData) }\n}\n</code></pre>\n\n<p>In particular, it's worth noting that lifetime parameter on RefA lets the compiler make sure you don't use a <code>RefA</code> after the backing structure has been freed.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1440855860, "last_edit_date": 1440855860, "creation_date": 1440805724, "answer_id": 32281289, "question_id": 32280150, "link": "https://stackoverflow.com/questions/32280150/how-can-i-expose-a-safe-wrapper-around-an-owned-pointer/32281289#32281289", "title": "How can I expose a safe wrapper around an owned pointer?", "body": "<blockquote>\n  <p>I could have separate structs for StructA based on whether it's standalone and needs to be freed or if it's a reference, but I'm hoping that's unnecessary.</p>\n</blockquote>\n\n<p>I believe this would be the accepted pattern. For backup, I'd point to the fact that this is a normal pattern in the Rust library. <code>&amp;str</code> and <code>String</code>, <code>&amp;[T]</code> and <code>Vec&lt;T&gt;</code>, <code>Path</code> and <code>PathBuf</code>, and probably lots of others I can't think of.</p>\n\n<p>The good news is that you can use similar patterns as these pairs, leveraging <code>Deref</code> or <code>DerefMut</code> to call down to shared implementation:</p>\n\n<pre><code>use std::ops::{Deref, DerefMut};\n\nenum RawFoo {}\n\nfn c_foo_new() -&gt; *const RawFoo { std::ptr::null() }\nfn c_foo_free(_f: *const RawFoo) {}\nfn c_foo_count(_f: *const RawFoo) -&gt; u8 { 42 }\nfn c_foo_make_awesome(_f: *const RawFoo, _v: bool) { }\n\nstruct OwnedFoo(Foo);\n\nimpl OwnedFoo {\n    fn new() -&gt; OwnedFoo {\n        OwnedFoo(Foo(c_foo_new()))\n    }\n}\n\nimpl Drop for OwnedFoo {\n    fn drop(&amp;mut self) { c_foo_free((self.0).0) }\n}\n\nimpl Deref for OwnedFoo {\n    type Target = Foo;\n    fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.0 }\n}\n\nimpl DerefMut for OwnedFoo {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target { &amp;mut self.0 }\n}\n\nstruct Foo(*const RawFoo);\n\nimpl Foo {\n    fn count(&amp;self) -&gt; u8 { c_foo_count(self.0) }\n    fn make_awesome(&amp;mut self, v: bool) { c_foo_make_awesome(self.0, v) }\n}\n\nfn main() {\n    let mut f = OwnedFoo::new();\n    println!(\"{}\", f.count());\n    f.make_awesome(true);\n}\n</code></pre>\n\n<p>Then, when you get a borrowed pointer from your other object, just wrap it up in a <code>&amp;Foo</code>:</p>\n\n<pre><code>use std::mem;\n\nfn c_bar_foo_ref() -&gt; *const RawFoo { std::ptr::null() }\n\n// Ignoring boilerplate for wrapping the raw Bar pointer \nstruct Bar;\n\nimpl Bar {\n    fn new() -&gt; Bar { Bar }\n\n    fn foo(&amp;self) -&gt; &amp;Foo {\n        unsafe { mem::transmute(c_bar_foo_ref()) }\n    }\n\n    fn foo_mut(&amp;mut self) -&gt; &amp;mut Foo {\n        unsafe { mem::transmute(c_bar_foo_ref()) }\n    }\n}\n\nfn main() {\n    let mut b = Bar::new();\n    println!(\"{}\", b.foo().count());\n    b.foo_mut().make_awesome(true);\n\n    // Doesn't work - lifetime constrained to Bar\n    // let nope = Bar::new().foo();\n}\n</code></pre>\n"}], "owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 86, "favorite_count": 0, "accepted_answer_id": 32281244, "answer_count": 2, "score": 4, "last_activity_date": 1440855860, "creation_date": 1440798046, "question_id": 32280150, "link": "https://stackoverflow.com/questions/32280150/how-can-i-expose-a-safe-wrapper-around-an-owned-pointer", "title": "How can I expose a safe wrapper around an owned pointer?", "body": "<p>I'm wrapping a C library that has two structs: one has a pointer to the other.</p>\n\n<pre><code>struct StructA {\n    void * some_mem;\n};\n\nstruct StructB {\n    void * some_mem;\n    struct StructA * some_struct;\n};\n</code></pre>\n\n<p>Both of these structs own memory, so my wrapper has constructors and destructors for both of them.</p>\n\n<pre><code>struct StructA(*mut c_void);\n\nimpl StructA {\n    fn new() -&gt; Self {\n        StructA(c_constructor())\n    }\n}\n\nimpl Drop for StructA {\n    fn drop(&amp;mut self) {\n        let StructA(ptr) = self;\n        c_destructor(ptr);\n    }\n}\n</code></pre>\n\n<p>There's also a function that takes a pointer to <code>StructB</code> and returns its pointer to <code>StructA</code>:</p>\n\n<pre><code>const struct StructA * get_struct(const struct StructB * obj);\n</code></pre>\n\n<p>The user of this function should not free the returned pointer, since it will be freed when the user frees <code>obj</code>.</p>\n\n<p>How can I wrap this function? The problem is that the destructor for <code>StructB</code> frees all its memory, including the one for <code>StructA</code>. So if my wrapping of <code>get_struct</code> returns an object, then the wrapped <code>StructA</code> will be freed twice (right?). It could instead return a reference to an object, but where would that object live?</p>\n\n<p>I could have separate structs for <code>StructA</code> based on whether it's standalone and needs to be freed or if it's a reference, but I'm hoping that's unnecessary.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1440813651, "post_id": 32281669, "comment_id": 52442303, "body": "Is <code>const fn</code> also going to allow things like <code>const sqrt_of_two: f64 = (2.0).sqrt()</code> to be possible?"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1440834632, "post_id": 32281669, "comment_id": 52445680, "body": "You <i>can</i> do it by abusing the heck out of macros... but it&#39;s unlikely to be worth it.  <i>Really</i> unlikely."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1440856225, "post_id": 32281669, "comment_id": 52451117, "body": "@Jsor: Maybe. It is unclear how much Compile Time Function Evaluation (CTFE) Rust will end up having. Personally, I am on the &quot;everything that is self-contained&quot; side, but I am not calling the shots :)"}], "tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": true, "score": 6, "last_activity_date": 1440809896, "creation_date": 1440809896, "answer_id": 32281669, "question_id": 32279858, "link": "https://stackoverflow.com/questions/32279858/how-to-format-a-const-string/32281669#32281669", "title": "How to format a const string", "body": "<p>Well, for one, you should be aware of <a href=\"http://doc.rust-lang.org/stable/std/env/consts/constant.OS.html\" rel=\"noreferrer\">http://doc.rust-lang.org/stable/std/env/consts/constant.OS.html</a></p>\n\n<p>Second, you can't <em>really</em> do this, exactly. You could use the <code>lazy_static</code> crate, but that's still going to end up giving you an allocation.</p>\n\n<p>In the future, when <code>const fn</code> is stable, this should  be easier to do.</p>\n"}], "owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5248, "favorite_count": 0, "accepted_answer_id": 32281669, "answer_count": 1, "score": 3, "last_activity_date": 1440809896, "creation_date": 1440796424, "question_id": 32279858, "link": "https://stackoverflow.com/questions/32279858/how-to-format-a-const-string", "title": "How to format a const string", "body": "<p>How can I make part of a <code>const</code> string conditional on some flag?</p>\n\n<pre><code>#[cfg(target_os = \"macos\")]\nconst OS: &amp;'static str = \"OSx\";\n#[cfg(target_os = \"windows\")]\nconst OS: &amp;'static str = \"Windows\";\n\nconst SOME_STRING: &amp;'static str = format!(\"this os is {}\", OS);\n</code></pre>\n\n<p>This code doesn't compile because the <code>format</code> macro returns a <code>String</code>. I'd like to be able to do this formatting without any allocation. Is it possible to do without making the whole string conditional?</p>\n"}, {"tags": ["rust", "hostname"], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 1, "last_activity_date": 1440792677, "creation_date": 1440792677, "answer_id": 32279068, "question_id": 32278847, "link": "https://stackoverflow.com/questions/32278847/how-to-set-the-hostname-using-only-the-standard-library/32279068#32279068", "title": "How to set the hostname using only the standard library?", "body": "<p>Rust standard library does not provide such function. Moreover, the methods for setting hostname differ across operating systems, so there is no portable way. You can probably make a crate to set the hostname portably and publish it on crates.io, in case someone else would need it.</p>\n"}], "owner": {"reputation": 1577, "user_id": 2381404, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/BpJjh.jpg?s=128&g=1", "display_name": "nein.", "link": "https://stackoverflow.com/users/2381404/nein"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 140, "favorite_count": 0, "accepted_answer_id": 32279068, "answer_count": 1, "score": 0, "last_activity_date": 1440795639, "creation_date": 1440791592, "last_edit_date": 1440795639, "question_id": 32278847, "link": "https://stackoverflow.com/questions/32278847/how-to-set-the-hostname-using-only-the-standard-library", "title": "How to set the hostname using only the standard library?", "body": "<p>Does the Rust standard library offer the possibility to set a machine's hostname? Or do I need to make a system call and set it via the <code>hostname</code> command?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1440767067, "post_id": 32271560, "comment_id": 52422184, "body": "BTW, in your second example I&#39;d say it is more idiomatic to use <code>if let</code>: <code>if let Some(ref mut s) = my_struct { s.field1(5); }</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440767180, "post_id": 32271560, "comment_id": 52422253, "body": "@VladimirMatveev: I was going with minimal modifications to the OP code (as the example might be contrived), but removing the <code>as_mut</code> as you did is just plain better."}, {"owner": {"reputation": 1459, "user_id": 1667955, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/X2hLR.jpg?s=128&g=1", "display_name": "mbrt", "link": "https://stackoverflow.com/users/1667955/mbrt"}, "edited": false, "score": 0, "creation_date": 1440773698, "post_id": 32271560, "comment_id": 52426844, "body": "Good explanation. I&#39;ve tried the second version and it works for me. However Vladimir answer does this in one line."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1459, "user_id": 1667955, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/X2hLR.jpg?s=128&g=1", "display_name": "mbrt", "link": "https://stackoverflow.com/users/1667955/mbrt"}, "edited": false, "score": 0, "creation_date": 1440773828, "post_id": 32271560, "comment_id": 52426931, "body": "@brt: Yep, that&#39;s why I added a disclaimer at the top of my answer; Vladimir&#39;s answer is just plain better :)"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 2, "last_activity_date": 1440767094, "last_edit_date": 1440767094, "creation_date": 1440766435, "answer_id": 32271560, "question_id": 32271392, "link": "https://stackoverflow.com/questions/32271392/modify-struct-field-inside-of-option/32271560#32271560", "title": "Modify struct field inside of Option", "body": "<p><strong>Edit:</strong> <em>Check Vladimir's answer, it's better.</em></p>\n\n<p>Let's remove the chaining, should we?</p>\n\n<pre><code>fn bar() -&gt; Option&lt;MyStruct&gt; {\n    let x: Option&lt;MyStruct&gt; = foo();\n    let x: Option&lt;&amp;mut MyStruct&gt; = x.as_mut();\n    let x: Option&lt;&amp;mut MyStruct&gt; = x.map(|s| s.field1(5));\n    x\n}\n</code></pre>\n\n<p>So, with the fluff removed, the question is:</p>\n\n<blockquote>\n  <p>How can I transform a <code>Option&lt;&amp;mut MyStruct&gt;</code> into a <code>Option&lt;MyStruct&gt;</code>?</p>\n</blockquote>\n\n<p>You cannot as-is, the borrowing rules forbid taking ownership of something you only borrow.</p>\n\n<p>You have two alternatives:</p>\n\n<ul>\n<li>make a clone</li>\n<li>go back to the owner</li>\n</ul>\n\n<p>Let's illustrate them:</p>\n\n<pre><code>// Requires that MyStruct implement Clone,\n// use #[derive(Clone)] to auto-generate the implementation\nfn bar_copy() -&gt; Option&lt;MyStruct&gt; {\n    foo().as_mut().map(|s| s.field1(5).clone())\n}\n\nfn bar_back() -&gt; Option&lt;MyStruct&gt; {\n    let mut my_struct = foo();\n    my_struct.as_mut().map(|s| s.field1(5));\n    my_struct\n}\n</code></pre>\n\n<p>Pick whichever you prefer (I'd pick the latter to avoid copies).</p>\n"}, {"comments": [{"owner": {"reputation": 1459, "user_id": 1667955, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/X2hLR.jpg?s=128&g=1", "display_name": "mbrt", "link": "https://stackoverflow.com/users/1667955/mbrt"}, "edited": false, "score": 0, "creation_date": 1440767489, "post_id": 32271735, "comment_id": 52422483, "body": "This doesn&#39;t work for me. It keeps saying the same error as before: mismatched types. Maybe it is the signature of <code>field1()</code>?"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 1, "creation_date": 1440767821, "post_id": 32271735, "comment_id": 52422714, "body": "You need <code>|mut s| { s.field1(5); s }</code>. The method modifies the object but its return value, the &amp;mut, is useless for returning by-value."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1440771078, "post_id": 32271735, "comment_id": 52424993, "body": "Oh, sorry. You&#39;re right. I don&#39;t know why I used builder-like syntax. I&#39;ve fixed the answer."}, {"owner": {"reputation": 1459, "user_id": 1667955, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/X2hLR.jpg?s=128&g=1", "display_name": "mbrt", "link": "https://stackoverflow.com/users/1667955/mbrt"}, "edited": false, "score": 0, "creation_date": 1440773518, "post_id": 32271735, "comment_id": 52426706, "body": "@VladimirMatveev ok, now it&#39;s working and it&#39;s a minimal change. Solved for me."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 8, "last_activity_date": 1440771079, "last_edit_date": 1440771079, "creation_date": 1440766997, "answer_id": 32271735, "question_id": 32271392, "link": "https://stackoverflow.com/questions/32271392/modify-struct-field-inside-of-option/32271735#32271735", "title": "Modify struct field inside of Option", "body": "<p>There is no reason to use <code>as_mut()</code> at all. Because you need to return <code>MyStruct</code> by value, you can just <code>map</code> on the option:</p>\n\n<pre><code>fn bar() -&gt; Option&lt;MyStruct&gt; {\n    foo().map(|mut s| { s.field1(5); s })\n}\n</code></pre>\n\n<p>That's it. You need to mark <code>s</code> with <code>mut</code> for the same reason you need to do so with <code>let</code>.</p>\n"}, {"comments": [{"owner": {"reputation": 1459, "user_id": 1667955, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/X2hLR.jpg?s=128&g=1", "display_name": "mbrt", "link": "https://stackoverflow.com/users/1667955/mbrt"}, "edited": false, "score": 0, "creation_date": 1440774468, "post_id": 32273993, "comment_id": 52427367, "body": "Yes, this is clear and effective, however I wanted to know why <code>map</code> didn&#39;t work in the way I&#39;ve used it."}], "tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": false, "score": 1, "last_activity_date": 1440773809, "creation_date": 1440773809, "answer_id": 32273993, "question_id": 32271392, "link": "https://stackoverflow.com/questions/32271392/modify-struct-field-inside-of-option/32273993#32273993", "title": "Modify struct field inside of Option", "body": "<p>TBH, I would just do it the obvious way:</p>\n\n<pre><code>fn bar() -&gt; Option&lt;MyStruct&gt; {\n    let mut val = foo();\n    if let Some(ref mut s) = val {\n        s.field1(5);\n    }\n    val\n}\n</code></pre>\n\n<p>It is longer than using <code>map</code>, but I find using <code>map</code> to mutate to be uncomfortable and the explicit mutation I choose also produces much nicer assembly.</p>\n"}, {"comments": [{"owner": {"reputation": 1459, "user_id": 1667955, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/X2hLR.jpg?s=128&g=1", "display_name": "mbrt", "link": "https://stackoverflow.com/users/1667955/mbrt"}, "edited": false, "score": 0, "creation_date": 1440868100, "post_id": 32275091, "comment_id": 52454720, "body": "I don&#39;t know if it&#39;s always as you said. I saw examples where the builder is the result itself and its methods take <code>self</code> by <code>&amp;mut</code>. But maybe it&#39;s clearer to use a different struct for the construction like you suggest."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1440777241, "creation_date": 1440777241, "answer_id": 32275091, "question_id": 32271392, "link": "https://stackoverflow.com/questions/32271392/modify-struct-field-inside-of-option/32275091#32275091", "title": "Modify struct field inside of Option", "body": "<p>Since other people are chiming in with broader suggestions, I'd point out that you can change your \"builder\" syntax to use <code>self</code> by value. For an actual builder, this is usually more ergonomic:</p>\n\n<pre><code>struct MyStruct {\n    field1: i32,\n    field2: i32,\n}\n\nimpl MyStruct {\n    pub fn field1(self, field1: i32) -&gt; Self {\n        MyStruct { field1: field1, ..self }\n    }\n}\n\nfn foo() -&gt; Option&lt;MyStruct&gt; {\n    None\n}\n\nfn bar() -&gt; Option&lt;MyStruct&gt; {\n    foo().map(|s| s.field1(5))\n}\n\nfn main() {\n    bar();\n}\n</code></pre>\n\n<p>I also tend to make a distinction between <em>builders</em> and plain <em>chained method invocation</em>. Namely, a builder should have a <code>build</code> method (or equivalent) that actually returns a different type. A builder is often a short-lived type, and so passing by value rarely causes problems.</p>\n"}], "owner": {"reputation": 1459, "user_id": 1667955, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/X2hLR.jpg?s=128&g=1", "display_name": "mbrt", "link": "https://stackoverflow.com/users/1667955/mbrt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2820, "favorite_count": 1, "accepted_answer_id": 32271735, "answer_count": 4, "score": 2, "last_activity_date": 1440777241, "creation_date": 1440765857, "last_edit_date": 1440766754, "question_id": 32271392, "link": "https://stackoverflow.com/questions/32271392/modify-struct-field-inside-of-option", "title": "Modify struct field inside of Option", "body": "<p>I'm having problems in changing a field of a struct inside of option. This is the code:</p>\n\n<pre><code>struct MyStruct {\n    field1 : i32,\n    field2 : i32,\n    // and many more...\n}\n\nimpl MyStruct {\n    pub fn field1(&amp;mut self, field1 : i32) -&gt; &amp;mut Self {\n        self.field1 = field1;\n        self\n    }\n}\n\nfn foo() -&gt; Option&lt;MyStruct&gt; {\n    None\n}\n\nfn bar() -&gt; Option&lt;MyStruct&gt; {\n    foo().as_mut().map(|s| s.field1(5))\n}\n\nfn main() {\n    bar();\n}\n</code></pre>\n\n<p>The main idea of <code>bar()</code> is to get an <code>Option&lt;MyStruct&gt;</code> from another function returning an <code>Option&lt;MyStruct&gt;</code>, change a field of that struct (in case the result is not <code>None</code>) and return the resulting <code>Option&lt;MyStruct&gt;</code>.</p>\n\n<p>The struct implements the builder pattern, so I've used it.</p>\n\n<p>In this case I get the following error:</p>\n\n<pre><code>test.rs:18:5: 18:40 error: mismatched types:\nexpected `core::option::Option&lt;MyStruct&gt;`,\n    found `core::option::Option&lt;&amp;mut MyStruct&gt;`\n(expected struct `MyStruct`,\n    found &amp;-ptr) [E0308]\ntest.rs:18     foo().as_mut().map(|s| s.field1(5))\n</code></pre>\n\n<p>I've also tried to use <code>Option.take()</code> and to change the signature of the builder method as <code>pub fn field1(mut self, field1 : i32) -&gt; Self</code>, but none of them work.</p>\n\n<p>How can I make this code work?</p>\n\n<p>I know that I could create another <code>Option</code> and map every field of the input to the corresponding field of the output, but <code>MyStruct</code> has a lot of fields and it is tedious.</p>\n"}, {"tags": ["udp", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1440856828, "post_id": 32270156, "comment_id": 52451322, "body": "This was <a href=\"https://www.reddit.com/r/rust/comments/3ipqto/udpsocket_recv_from_performance/\" rel=\"nofollow noreferrer\">cross-posted to Reddit</a>"}, {"owner": {"reputation": 752, "user_id": 7496656, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/zMGuk.jpg?s=128&g=1", "display_name": "Jan Zerebecki", "link": "https://stackoverflow.com/users/7496656/jan-zerebecki"}, "edited": false, "score": 0, "creation_date": 1487958628, "post_id": 32270156, "comment_id": 72033835, "body": "The Reddit threat says it was a kernel issue of Windows and solved by moving to Linux."}], "owner": {"reputation": 117, "user_id": 5276767, "user_type": "registered", "profile_image": "https://graph.facebook.com/889361984487303/picture?type=large", "display_name": "Nico Ul", "link": "https://stackoverflow.com/users/5276767/nico-ul"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 233, "favorite_count": 1, "answer_count": 0, "score": 5, "last_activity_date": 1440766905, "creation_date": 1440761728, "last_edit_date": 1440766905, "question_id": 32270156, "link": "https://stackoverflow.com/questions/32270156/udpsocket-recv-from-performance-issues", "title": "UdpSocket recv_from performance issues", "body": "<p>I'm not sure if this is a language specific problem, but I might as well try.<br>\nFor a project in our company we're trying to implement a data transfer protocol of 22MB large files through UDP. We know TCP is better suited for this, but the hardware development decided it's got to be UDP.<br>\n&nbsp;<br>\nThe logic we've got is the client sends the 22MB file through 1500 byte sized packages. Each package has a unique ID in its header. The first batch of these ~15000 packages takes about a second to transmit, but we of course lose ~2000 packages due to UDP being used.<br>\n&nbsp;<br>\nEvery batch of packages ends with a unique \"end package\", telling us, that the transfer from the client has finished, and we can start requesting lost packages through their unique ID. Because of limitations we are only allowed to request 255 packages at a time, so we've got to send a lot of resend-requests. Due to the end-package we don't have to use a socket timeout, which would have to be ~250ms per request cycle to be efficient in not leaving out still to be transmitted packages, resulting in a lot of lost time.<br>\n&nbsp;<br>\nNow for the actual issue at hand:<br>\nWhile the first cycle of requesting 255 packages and receiving them takes 0.01s, each one after that takes 0.4s. I've tracked down the root of the problem to the \"recv_from\" function. I've made sure that it receives the same amount of packages in every cycle before ending at the \"end-package\", and although it's even down to the exact same amount of bytes, it takes a 40-fold the time.<br>\n&nbsp;  </p>\n\n<pre><code>fn receive( socket: &amp;UdpSocket, buf: &amp;mut [u8;1600] ) -&gt; Vec&lt;Vec&lt;u8&gt;&gt;{\n    let mut res: Vec&lt;Vec&lt;u8&gt;&gt; = vec![];\n\n    let mut x = Duration::seconds( 0 );\n    loop{\n        // time tracking\n        let start = PreciseTime::now();\n        let ( n, _ ) = socket.recv_from( buf ).unwrap();\n        let end = PreciseTime::now();\n        x = x + ( start.to( end ));\n\n        // difference in time doesn't occur here\n        let mut v = vec![];\n        v.push_all( &amp;buf[ 0..n ]);\n\n        // this is an end-package\n        if v[8] == 240 {\n            break;\n        }\n        res.push( v );\n\n    }\n    // first call of this function with 255 received package takes 0.01s, each consecutive call takes 0.4s\n    println!{ \"NOTE: Total transmission time: {}s\", x };\n\n    // the higher this value, the less the difference in times between the first and the consecutive calls\n    // at ~ 500ms it evens out at about 0.02s per call of 255 received packages\n    sleep_ms( 100 );\n res\n}    \n</code></pre>\n\n<p>&nbsp;<br>\nSorry for the huge wall of text, it's just a lot of background that comes with this problem; not even sure if I mentioned everything that's relevant.</p>\n"}, {"tags": ["rust", "closures", "ffi"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440767177, "post_id": 32270030, "comment_id": 52422251, "body": "How does a C client of this library pass caller-specific information? This seems like an example of an API that simply wasn&#39;t designed to allow that. Perhaps the API authors believe that it&#39;s not needed, and that you can make all decisions you need based on <code>(x, y)</code>."}, {"owner": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1440795578, "post_id": 32270030, "comment_id": 52438024, "body": "Well, the C library is not particularly well designed. It relies a lot on <code>static</code>s and global state. And it doesn&#39;t even try to be thread-safe."}], "answers": [{"comments": [{"owner": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "edited": false, "score": 0, "creation_date": 1440762481, "post_id": 32270215, "comment_id": 52419168, "body": "I see. Unfortunately this particular function does not allow passing any user data. So, to make it work I would have to require users to provide an <code>extern &quot;C&quot;</code> function as a parameter to my Rust wrapper? Or is there a way to use a trait/object?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "edited": false, "score": 0, "creation_date": 1440762957, "post_id": 32270215, "comment_id": 52419505, "body": "Unfortunately, I see no other way than passing <code>extern &quot;C&quot;</code> function. Maybe someone else could suggest something, but it is unlikely."}, {"owner": {"reputation": 3963, "user_id": 1390726, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/c765305d9d8dfc09a2f352a5cdf51bdf?s=128&d=identicon&r=PG", "display_name": "tez", "link": "https://stackoverflow.com/users/1390726/tez"}, "edited": false, "score": 0, "creation_date": 1449930919, "post_id": 32270215, "comment_id": 56223886, "body": "@VladimirMatveev I&#39;ve a similar requirement. In my case userdata is passed to callback but it is set using a function like this --&gt; <code>bindings::mosquitto_user_data_set</code>. Due to this my closure is getting destroyed by the time callback is invoked and I&#39;m getting garbage on closed variables. Can you please extend the answer with an example of <code>Box</code> method that you are suggesting?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 3963, "user_id": 1390726, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/c765305d9d8dfc09a2f352a5cdf51bdf?s=128&d=identicon&r=PG", "display_name": "tez", "link": "https://stackoverflow.com/users/1390726/tez"}, "edited": false, "score": 0, "creation_date": 1449940138, "post_id": 32270215, "comment_id": 56226925, "body": "@tez I&#39;ve added an example."}, {"owner": {"reputation": 3963, "user_id": 1390726, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/c765305d9d8dfc09a2f352a5cdf51bdf?s=128&d=identicon&r=PG", "display_name": "tez", "link": "https://stackoverflow.com/users/1390726/tez"}, "edited": false, "score": 0, "creation_date": 1449979862, "post_id": 32270215, "comment_id": 56237528, "body": "@VladimirMatveev Thank you very much. I&#39;m little confused about this. I asked a new question explaining my problem. Can you please take a look at this. <a href=\"http://stackoverflow.com/questions/34247879/rust-closure-as-callback-for-c-bindings-receiving-garbage-value-in-captured-vari\" title=\"rust closure as callback for c bindings receiving garbage value in captured vari\">stackoverflow.com/questions/34247879/&hellip;</a>"}, {"owner": {"reputation": 85, "user_id": 286648, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/6mLlp.png?s=128&g=1", "display_name": "Sgeo", "link": "https://stackoverflow.com/users/286648/sgeo"}, "edited": false, "score": 0, "creation_date": 1526190575, "post_id": 32270215, "comment_id": 87642336, "body": "In your first example, in <code>do_with_callback</code>, why is there no double indirection? Am I missing something, or is there a mistake?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 85, "user_id": 286648, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/6mLlp.png?s=128&g=1", "display_name": "Sgeo", "link": "https://stackoverflow.com/users/286648/sgeo"}, "edited": false, "score": 0, "creation_date": 1526325391, "post_id": 32270215, "comment_id": 87691200, "body": "@Sgeo yep, looks like a mistake. I wonder why Rust even allows this to compile, given that the fat pointer <code>&amp;mut FnMut(...) -&gt; ...</code> should not be really convertible to <code>*mut c_void</code>. Fixed."}, {"owner": {"reputation": 2559, "user_id": 1761795, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/5c38eefbb62d65c1d79682ad03cdfeed?s=128&d=identicon&r=PG", "display_name": "Phil Lord", "link": "https://stackoverflow.com/users/1761795/phil-lord"}, "edited": false, "score": 0, "creation_date": 1545851989, "post_id": 32270215, "comment_id": 94712542, "body": "Why does the first example not work, if the library stores the pointer? I have your second example working, but I don&#39;t understand why the first doesn&#39;t work."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1546249260, "post_id": 32270215, "comment_id": 94808849, "body": "Because in the first example the closure is stored on the stack, and goes out of scope once the <code>do_with_callback</code> function returns, which in general results in memory deallocation and other resource cleanups. Also, stack memory tends to be reused. If the library stores the pointer somewhere to be called later, it would then call the <code>do_something_handler</code> function with an argument pointing to garbage data, which would likely cause crashes or some other nasty behavior."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 33, "last_activity_date": 1526325393, "last_edit_date": 1526325393, "creation_date": 1440761929, "answer_id": 32270215, "question_id": 32270030, "link": "https://stackoverflow.com/questions/32270030/how-do-i-convert-a-rust-closure-to-a-c-style-callback/32270215#32270215", "title": "How do I convert a Rust closure to a C-style callback?", "body": "<p>You cannot do it unless the C API allows passing a user-provided callback parameter. If it does not, you can only use static functions.</p>\n\n<p>The reason is that closures are not \"just\" functions. As their name implies, closures \"close over\" variables from their lexical scope. Each closure has an associated piece of data which holds either values of captured variables (if the <code>move</code> keyword is used) or references to them. This data can be thought of as some unnamed, anonymous <code>struct</code>.</p>\n\n<p>The compiler automatically adds an implementation of the corresponding <code>Fn*</code> traits for these anonymous structs. <a href=\"https://doc.rust-lang.org/std/ops/trait.Fn.html\" rel=\"noreferrer\">As you can see</a>, methods on these traits accept <code>self</code> in addition to the closure arguments. In this context, <code>self</code> is the <code>struct</code> on which the trait is implemented. This means that each function which corresponds to a closure also has an additional parameter which contains the closure environment.</p>\n\n<p>If your C API only allows you to pass functions without any user-defined parameters, you cannot write a wrapper which would allow you to use closures. I guess it <em>may</em> be possible to write some global holder for the closures environment, but I doubt it would be easy and safe.</p>\n\n<p>If your C API does allow passing a user-defined argument, then it is possible to do what you want with trait objects:</p>\n\n<pre><code>extern crate libc;\n\nuse std::mem;\n\nuse libc::{c_int, c_void};\n\nextern \"C\" {\n    fn do_something(f: Option&lt;extern \"C\" fn(x: c_int, arg: *mut c_void) -&gt; c_int&gt;, arg: *mut c_void) -&gt; c_int;\n}\n\nextern \"C\" fn do_something_handler(x: c_int, arg: *mut c_void) -&gt; c_int {\n    let closure: &amp;mut &amp;mut FnMut(i32) -&gt; bool = unsafe { mem::transmute(arg) };\n    closure(x as i32) as c_int\n}\n\npub fn do_with_callback&lt;F&gt;(x: i32, mut callback: F) -&gt; bool\n    where F: FnMut(i32) -&gt; bool\n{\n    // reason for double indirection is described below\n    let mut cb: &amp;mut FnMut(i32) -&gt; bool = &amp;mut callback;\n    let cb = &amp;mut cb;\n    unsafe { do_something(Some(do_something_handler), cb as *mut _ as *mut c_void) &gt; 0 }\n}\n</code></pre>\n\n<p>This will only work if <code>do_something</code> does not store the pointer to the callback somewhere. If it does, you need to use a <code>Box&lt;Fn(..) -&gt; ..&gt;</code> trait object and leak it after you pass it to the function. Then, if possible, it should be obtained back from your C library and disposed of. It could look like this:</p>\n\n<pre><code>extern crate libc;\n\nuse std::mem;\n\nuse libc::{c_int, c_void};\n\nextern \"C\" {\n    fn set_handler(f: Option&lt;extern \"C\" fn(x: c_int, arg: *mut c_void) -&gt; c_int&gt;, arg: *mut c_void);\n    fn invoke_handler(x: c_int) -&gt; c_int;\n    fn unset_handler() -&gt; *mut c_void;\n}\n\nextern \"C\" fn do_something_handler(x: c_int, arg: *mut c_void) -&gt; c_int {\n    let closure: &amp;mut Box&lt;FnMut(i32) -&gt; bool&gt; = unsafe { mem::transmute(arg) };\n    closure(x as i32) as c_int\n}\n\npub fn set_callback&lt;F&gt;(callback: F)\n    where F: FnMut(i32) -&gt; bool,\n          F: 'static\n{\n    let cb: Box&lt;Box&lt;FnMut(i32) -&gt; bool&gt;&gt; = Box::new(Box::new(callback));\n    unsafe {\n        set_handler(Some(do_something_handler), Box::into_raw(cb) as *mut _);\n    }\n}\n\npub fn invoke_callback(x: i32) -&gt; bool {\n    unsafe { invoke_handler(x as c_int) &gt; 0 }\n}\n\npub fn unset_callback() {\n    let ptr = unsafe { unset_handler() };\n    // drop the callback\n    let _: Box&lt;Box&lt;FnMut(i32) -&gt; bool&gt;&gt; = unsafe { Box::from_raw(ptr as *mut _) };\n}\n\nfn main() {\n    let mut y = 0;\n    set_callback(move |x| {\n        y += 1;\n        x &gt; y\n    });\n\n    println!(\"First: {}\", invoke_callback(2));\n    println!(\"Second: {}\", invoke_callback(2));\n\n    unset_callback();\n}\n</code></pre>\n\n<p>Double indirection (i.e. <code>Box&lt;Box&lt;...&gt;&gt;</code>) is necessary because <code>Box&lt;Fn(..) -&gt; ..&gt;</code> is a trait object and therefore a fat pointer, incompatible with <code>*mut c_void</code> because of different size.</p>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488641454, "post_id": 42587849, "comment_id": 72326535, "body": "Both of the code snippets in the other answer compile correctly. Are you saying that there&#39;s a crash when the program is executed?"}, {"owner": {"reputation": 41, "user_id": 7518605, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d68a69ccbacd79e43015b13a0e0b4d1?s=128&d=identicon&r=PG&f=1", "display_name": "Mingun", "link": "https://stackoverflow.com/users/7518605/mingun"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1488742491, "post_id": 42587849, "comment_id": 72354987, "body": "Yes. Just try it in play.rust-lang.org. This site not reports crash, just some <code>println</code>ed strings not printed, which say me, that application crashes. Already one the fact that the different quantity <code>&amp;mut</code> is used during creation pointer and obtaining closure back the index has to guard."}], "tags": [], "owner": {"reputation": 41, "user_id": 7518605, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d68a69ccbacd79e43015b13a0e0b4d1?s=128&d=identicon&r=PG&f=1", "display_name": "Mingun", "link": "https://stackoverflow.com/users/7518605/mingun"}, "is_accepted": false, "score": 4, "last_activity_date": 1488641419, "last_edit_date": 1495541390, "creation_date": 1488572693, "answer_id": 42587849, "question_id": 32270030, "link": "https://stackoverflow.com/questions/32270030/how-do-i-convert-a-rust-closure-to-a-c-style-callback/42587849#42587849", "title": "How do I convert a Rust closure to a C-style callback?", "body": "<p><a href=\"https://stackoverflow.com/users/788207/vladimir-matveev\">The first snippet from Vladimir Matveev</a> no longer works as written. The size of <code>&amp;mut FnMut(i32) -&gt; bool</code> and <code>*mut c_void</code> is different and such casts lead to a crash. Corrected example (<a href=\"https://play.rust-lang.org/?gist=ceea597e4db02826e42e0ad1488617db&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">playpen</a>):</p>\n\n<pre><code>extern crate libc;\n\nuse std::mem::*;\n\nuse libc::c_void;\n\npub fn run&lt;F&gt;(mut callback: F) -&gt; bool\n    where F: FnMut(i32) -&gt; bool\n{\n    let mut cb: &amp;mut FnMut(i32) -&gt; bool = &amp;mut callback;\n    println!(\"sizeof(cb/*-ptr): {}/{}\",\n             size_of::&lt;*mut FnMut(i32) -&gt; bool&gt;(),\n             size_of::&lt;*mut c_void&gt;());\n\n    let ctx = &amp;mut cb as *mut &amp;mut FnMut(i32) -&gt; bool as *mut c_void;\n    println!(\"ctx: {:?}\", ctx);\n    //----------------------------------------------------------\n    // Convert backward\n    let cb2: *mut *mut FnMut(i32) -&gt; bool = unsafe { transmute(ctx) };\n    println!(\"cb2: {:?}\", cb2);\n\n    // this is more useful, but can't be printed, because not implement Debug\n    let closure: &amp;mut &amp;mut FnMut(i32) -&gt; bool = unsafe { transmute(ctx) };\n\n    closure(0xDEAD)\n}\n\nfn main() {\n    println!(\"answer: {}\",\n             run(|x| {\n                 println!(\"What can change nature of a man?\");\n                 x &gt; 42\n             }));\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "is_accepted": false, "score": 4, "last_activity_date": 1488787693, "last_edit_date": 1495541390, "creation_date": 1488787693, "answer_id": 42620494, "question_id": 32270030, "link": "https://stackoverflow.com/questions/32270030/how-do-i-convert-a-rust-closure-to-a-c-style-callback/42620494#42620494", "title": "How do I convert a Rust closure to a C-style callback?", "body": "<p>In C, a function pointer does not have associated context, which is why usually a C callback function usually carry an extra <code>void*</code> argument pass the context...</p>\n\n<pre><code>typedef bool (*listener_t)(int, int, void* user_data);\nbool do_it(void* user_data, int x1, int y1, int x2, int y2, listener_t listener)\n</code></pre>\n\n<p>... or have an API to let to store the user data...</p>\n\n<pre><code>void api_set_user_data(void* user_data);   // &lt;-- caller set the context\nvoid* api_get_user_data();   // &lt;-- callback use this to retrieve context.\n</code></pre>\n\n<hr>\n\n<p>If the library you want to wrap does not provide any of the above, you will need to pass the context via other channels, e.g. via a global variable, though that context will be shared across the whole process:</p>\n\n<pre><code>lazy_static! {\n    static ref REAL_CALLBACK: Mutex&lt;Option&lt;Box&lt;FnMut(c_int, c_int) -&gt; bool + Send&gt;&gt;&gt; = Default::default();\n}\n\nextern \"C\" fn callback(x: c_int, y: c_int) -&gt; bool {\n    if let Some(ref mut real_callback) = *REAL_CALLBACK.lock().unwrap() {\n        real_callback(x, y)\n    } else {\n        panic!(\"&lt;handle error here&gt;\");\n    }\n}\n\nfn main() {\n    *REAL_CALLBACK.lock().unwrap() = Some(Box::new(move |x, y| {\n        println!(\"...\");\n        true\n    }));\n    unsafe {\n        do_it(callback);\n    }\n}\n</code></pre>\n\n<p>It is also possible to create a <a href=\"https://stackoverflow.com/questions/8179521/implementation-of-nested-functions\"><em>trampoline function</em></a> to stick the context directly in the function, but it is extremely difficult and unsafe.</p>\n\n<p><sub><em>Answer manually migrated from <a href=\"https://stackoverflow.com/a/42597209/224671\">https://stackoverflow.com/a/42597209/224671</a></em></sub></p>\n"}], "owner": {"reputation": 3192, "user_id": 9622, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b0616783225972991e011625600e818?s=128&d=identicon&r=PG", "display_name": "Tomo", "link": "https://stackoverflow.com/users/9622/tomo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6829, "favorite_count": 8, "accepted_answer_id": 32270215, "answer_count": 3, "score": 25, "last_activity_date": 1526325393, "creation_date": 1440761275, "last_edit_date": 1488640877, "question_id": 32270030, "link": "https://stackoverflow.com/questions/32270030/how-do-i-convert-a-rust-closure-to-a-c-style-callback", "title": "How do I convert a Rust closure to a C-style callback?", "body": "<p>I'm trying to write a Rusty wrapper for a piece of C API. There is one C construct I struggle with:</p>\n\n<pre><code>typedef bool (*listener_t) (int, int);\nbool do_it(int x1, int y1, int x2, int y2, listener_t listener)\n</code></pre>\n\n<p>The function does its job for a range of numbers unless the listener returns false. In that case it aborts computation. I want to have a Rust wrapper like this:</p>\n\n<pre><code>fn do_with_callback&lt;F&gt;(start: (i32, i32), end: (i32, i32), callback: F)\n    where F: Fn(i32, i32) -&gt; bool\n</code></pre>\n\n<p><code>rust-bindgen</code> created this for me, slightly edited for clarity:</p>\n\n<pre><code>pub type listener_t = Option&lt;extern \"C\" fn(x: c_int, y: c_int) -&gt; c_bool&gt;;\n\npub fn TCOD_line(xFrom: c_int, yFrom: c_int,\n                 xTo: c_int, yTo: c_int,\n                 listener: listener_t) -&gt; c_bool;\n</code></pre>\n\n<p>How should I convert a closure or a trait reference to a C-style callback in my <code>do_with</code> functions:</p>\n\n<pre><code>pub fn do_with_callback&lt;F&gt;(start: (i32, i32), end: (i32, i32), callback: F) -&gt; Self\n    where F: Fn(i32, i32) -&gt; bool\n{\n    let wrapper = ???;\n    unsafe {\n        ffi::do_it(start.0, start.1, end.0, end.1, Some(wrapper))\n    };\n}\n</code></pre>\n"}, {"tags": ["linux", "macos", "rust"], "answers": [{"comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1440753845, "post_id": 32267648, "comment_id": 52414009, "body": "Beat me by <i>7 seconds</i>.  :P  Should also add that the asker&#39;s actual issue is that the <i>index</i> is kept in a GitHub repo; just mirroring the packages themselves isn&#39;t sufficient."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1440754346, "post_id": 32267648, "comment_id": 52414340, "body": "@DK.: isn&#39;t that already contained in my second paragraph? If you think it&#39;s not obvious enough I welcome any edit to make it clearer."}, {"owner": {"reputation": 341, "user_id": 4407799, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/c741afb406509f1b64422fd5fa3879b3?s=128&d=identicon&r=PG&f=1", "display_name": "\u4e60\u660e\u660a", "link": "https://stackoverflow.com/users/4407799/%e4%b9%a0%e6%98%8e%e6%98%8a"}, "edited": false, "score": 0, "creation_date": 1440757662, "post_id": 32267648, "comment_id": 52416377, "body": "Thanks very much. right now,it&#39;s really complicated~~~"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 1, "creation_date": 1440762362, "post_id": 32267648, "comment_id": 52419093, "body": "@MatthieuM. Well, you mention <code>crates.io</code>, but that&#39;s just where the actual package files are stored, not the index.  So even mirroring <i>all</i> of <code>crates.io</code> isn&#39;t going to be sufficient."}, {"owner": {"reputation": 709, "user_id": 10126273, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/6trXt.png?s=128&g=1", "display_name": "Tenders McChiken", "link": "https://stackoverflow.com/users/10126273/tenders-mcchiken"}, "edited": false, "score": 0, "creation_date": 1610344456, "post_id": 32267648, "comment_id": 116093118, "body": "This answer is outdated: Cargo can vendor external dependencies on its own without installing any additional tooling as early as Rust 1.37. See <a href=\"https://stackoverflow.com/a/65254702/10126273\">my answer</a> for more details."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 709, "user_id": 10126273, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/6trXt.png?s=128&g=1", "display_name": "Tenders McChiken", "link": "https://stackoverflow.com/users/10126273/tenders-mcchiken"}, "edited": false, "score": 1, "creation_date": 1610370737, "post_id": 32267648, "comment_id": 116103148, "body": "@TendersMcChiken Thanks; I added the &quot;redirection&quot; notice, now we just your answer to be upvoted so it bubbles up, or for the OP to accept it."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 5, "last_activity_date": 1610370703, "last_edit_date": 1610370703, "creation_date": 1440753820, "answer_id": 32267648, "question_id": 32267233, "link": "https://stackoverflow.com/questions/32267233/how-to-build-a-project-using-cargo-in-an-offline-environment/32267648#32267648", "title": "How to build a project using Cargo in an offline environment?", "body": "<p><strong>For Rust 1.37+ see:</strong> <a href=\"https://stackoverflow.com/a/65254702/147192\">https://stackoverflow.com/a/65254702/147192</a></p>\n<hr />\n<p>The short answer is: up to 1.37 (excluded), it's complicated.</p>\n<p>The long answer is that <code>cargo</code> will attempt to connect to <code>github</code> in order to check the index of the crates that the <code>Cargo.toml</code> file references.</p>\n<p>I recommend you to check the <a href=\"https://github.com/alexcrichton/cargo-vendor\" rel=\"nofollow noreferrer\">cargo-vendor</a> prototype to solve this issue (by aturon, a member of the Rust tooling subteam), and otherwise you could look at how some people <a href=\"https://gmjosack.github.io/posts/dissecting-cratesio-minimum-mirror/\" rel=\"nofollow noreferrer\">created a mirror</a> for crates.io in order to avoid the dependency on Internet.</p>\n<p>There is a demand for Rust builds not to require Internet, and people working on it, however there is no blessed solution for now.</p>\n"}, {"tags": [], "owner": {"reputation": 3908, "user_id": 1398841, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/s8gQQ.png?s=128&g=1", "display_name": "phoenix", "link": "https://stackoverflow.com/users/1398841/phoenix"}, "is_accepted": false, "score": 1, "last_activity_date": 1589744814, "creation_date": 1589744814, "answer_id": 61857845, "question_id": 32267233, "link": "https://stackoverflow.com/questions/32267233/how-to-build-a-project-using-cargo-in-an-offline-environment/61857845#61857845", "title": "How to build a project using Cargo in an offline environment?", "body": "<p>Check out the newly released <a href=\"https://github.com/drmikehenry/romt\" rel=\"nofollow noreferrer\"><code>romt</code> - Rust Offline Mirror Tool</a>.</p>\n\n<p>Romt (Rust Offline Mirror Tool) aids in using the Rust programming language in an offline context. Instructions and tooling are provided for:</p>\n\n<ul>\n<li>Mirroring of Rust ecosystem artifacts:\n\n<ul>\n<li>Toolchains (Rustc, Cargo, libraries, etc.)</li>\n<li>Rustup (toolchain multiplexer)</li>\n<li>Crates.io (community-supplied Crates)</li>\n</ul></li>\n<li>Incremental artifact downloading.</li>\n<li>Incremental artifact transfer to offline network.</li>\n<li>Artifact serving in offline context (offline computer, disconnected network).</li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 709, "user_id": 10126273, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/6trXt.png?s=128&g=1", "display_name": "Tenders McChiken", "link": "https://stackoverflow.com/users/10126273/tenders-mcchiken"}, "is_accepted": false, "score": 4, "last_activity_date": 1617815867, "last_edit_date": 1617815867, "creation_date": 1607702668, "answer_id": 65254702, "question_id": 32267233, "link": "https://stackoverflow.com/questions/32267233/how-to-build-a-project-using-cargo-in-an-offline-environment/65254702#65254702", "title": "How to build a project using Cargo in an offline environment?", "body": "<p>Good News! As of Rust 1.37, you can use Cargo's own <a href=\"https://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html#built-in-cargo-support-for-vendored-dependencies\" rel=\"nofollow noreferrer\"><code>vendor</code> command</a> to download and bundle your crate's dependencies in the crate itself:</p>\n<ol>\n<li><p>First, run <code>cargo vendor</code>. This will setup a new directory named <code>vendor</code> in the root of your crate. It will then download dependencies from crates.io and git, and store them in this new directory.</p>\n</li>\n<li><p>When <code>cargo vendor</code> is done downloading all the required dependencies, it will print a set of instructions that you'll need to follow. At the time of this writing, you only need to copy a few lines to <code>.cargo/config.toml</code>. Note that <code>config.toml</code> is relative to the root of your crate and is not the one in your home directory.</p>\n</li>\n</ol>\n<p>Once you're done, your crate will be completely self-contained as far as dependencies are concerned. You can couple this approach with Rust's <a href=\"https://forge.rust-lang.org/infra/other-installation-methods.html#standalone-installers\" rel=\"nofollow noreferrer\">offline installers</a> to build Rust programs completely offline.</p>\n"}], "owner": {"reputation": 341, "user_id": 4407799, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/c741afb406509f1b64422fd5fa3879b3?s=128&d=identicon&r=PG&f=1", "display_name": "\u4e60\u660e\u660a", "link": "https://stackoverflow.com/users/4407799/%e4%b9%a0%e6%98%8e%e6%98%8a"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2958, "favorite_count": 2, "answer_count": 3, "score": 9, "last_activity_date": 1617815867, "creation_date": 1440752601, "last_edit_date": 1440763858, "question_id": 32267233, "link": "https://stackoverflow.com/questions/32267233/how-to-build-a-project-using-cargo-in-an-offline-environment", "title": "How to build a project using Cargo in an offline environment?", "body": "<p>I have a laptop with an OS X system which can access the internet, and a Linux server which can not access internet for some security reason.</p>\n\n<p>I want to build a Rust project with some dependency on the Linux server. Because the Linux server can not access internet, I run the <code>cargo build</code> command on the OSX laptop and download the dependency source file to the <code>.cargo</code> directory and then copy these files to the Linux server and put them into <code>/root/.cargo</code> directory.</p>\n\n<p>I made the file structures the same, but when I run <code>cargo build</code> on the Linux server, it still tries to connect to <a href=\"https://github.com/rust-lang/crates.io-index\" rel=\"noreferrer\">this</a> website and the build fails. The <code>cargo build</code> command always tries to connect internet although the dep source files are already in the <code>.cargo</code> directory.</p>\n\n<p>How can I build a Rust project with dependencies in an offline environment? Why does copying the source file of the dependencies not work?</p>\n"}, {"tags": ["closures", "rust", "ownership"], "comments": [{"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1440735821, "post_id": 32263184, "comment_id": 52405848, "body": "Try adding statements of the form <code>let x = &amp;x</code> (or <code>let x = &amp;mut x</code> if you need mutability) just before the call to <code>thread::spawn</code>, where <code>x</code> is a variable used in the closure passed to <code>thread::spawn</code>. With these, the closure will capture references, rather than the values directly."}, {"owner": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "reply_to_user": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1440737361, "post_id": 32263184, "comment_id": 52406181, "body": "Then the compiler doesn&#39;t know the references live long enough, because the scope in the map ends before the thread is done."}], "answers": [{"comments": [{"owner": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "edited": false, "score": 0, "creation_date": 1440738661, "post_id": 32263563, "comment_id": 52406508, "body": "Should I switch to scoped threads, or is there a data type I can use that I can share read only access to across threads without locking?"}, {"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "edited": false, "score": 1, "creation_date": 1440745663, "post_id": 32263563, "comment_id": 52409373, "body": "Arc is what you look for."}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 1, "last_activity_date": 1440737643, "creation_date": 1440737643, "answer_id": 32263563, "question_id": 32263184, "link": "https://stackoverflow.com/questions/32263184/wheres-the-illegal-move-in-my-code/32263563#32263563", "title": "Where&#39;s the illegal move in my code?", "body": "<p>Because of how the <code>move</code> closure is inside another closure rather than at the outer level (e.g. if you had a <code>for</code> loop pushing to a vector), the error message really isn\u2019t very good, but if you drop the <code>move</code> keyword you can get somewhat better error messages, along these lines:</p>\n\n<pre><code>&lt;anon&gt;:42:23: 71:10 error: closure may outlive the current function, but it borrows `tried_indices`, which is owned by the current function [E0373]\n&lt;anon&gt;:42         thread::spawn(|| {\n&lt;anon&gt;:43             let mut best_set : Vec&lt;String&gt; = Vec::new();\n&lt;anon&gt;:44             let mut best_count = 0;\n&lt;anon&gt;:45             let mut indices: Vec&lt;usize&gt; = Vec::new();\n&lt;anon&gt;:46             let limit = 1;\n&lt;anon&gt;:47 \n          ...\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:50:45: 50:58 note: `tried_indices` is borrowed here\n&lt;anon&gt;:50                     let mut tried_indices = tried_indices.lock().unwrap();\n                                                      ^~~~~~~~~~~~~\nnote: in expansion of for loop expansion\n&lt;anon&gt;:48:13: 66:14 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:42:23: 71:10 help: to force the closure to take ownership of `tried_indices` (and any other referenced variables), use the `move` keyword, as shown:\n&lt;anon&gt;:           thread::spawn(move || {\n&lt;anon&gt;:               let mut best_set : Vec&lt;String&gt; = Vec::new();\n&lt;anon&gt;:               let mut best_count = 0;\n&lt;anon&gt;:               let mut indices: Vec&lt;usize&gt; = Vec::new();\n&lt;anon&gt;:               let limit = 1;\n&lt;anon&gt;:   \n          ...\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:42:23: 71:10 error: closure may outlive the current function, but it borrows `**files`, which is owned by the current function [E0373]\n&lt;anon&gt;:42         thread::spawn(|| {\n&lt;anon&gt;:43             let mut best_set : Vec&lt;String&gt; = Vec::new();\n&lt;anon&gt;:44             let mut best_count = 0;\n&lt;anon&gt;:45             let mut indices: Vec&lt;usize&gt; = Vec::new();\n&lt;anon&gt;:46             let limit = 1;\n&lt;anon&gt;:47 \n          ...\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:58:25: 58:30 note: `**files` is borrowed here\n&lt;anon&gt;:58                         files[*i].clone()\n                                  ^~~~~\nnote: in expansion of closure expansion\n&lt;anon&gt;:57:40: 59:22 note: expansion site\nnote: in expansion of for loop expansion\n&lt;anon&gt;:48:13: 66:14 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:42:23: 71:10 help: to force the closure to take ownership of `**files` (and any other referenced variables), use the `move` keyword, as shown:\n&lt;anon&gt;:           thread::spawn(move || {\n&lt;anon&gt;:               let mut best_set : Vec&lt;String&gt; = Vec::new();\n&lt;anon&gt;:               let mut best_count = 0;\n&lt;anon&gt;:               let mut indices: Vec&lt;usize&gt; = Vec::new();\n&lt;anon&gt;:               let limit = 1;\n&lt;anon&gt;:   \n          ...\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:42:23: 71:10 error: closure may outlive the current function, but it borrows `**data`, which is owned by the current function [E0373]\n&lt;anon&gt;:42         thread::spawn(|| {\n&lt;anon&gt;:43             let mut best_set : Vec&lt;String&gt; = Vec::new();\n&lt;anon&gt;:44             let mut best_count = 0;\n&lt;anon&gt;:45             let mut indices: Vec&lt;usize&gt; = Vec::new();\n&lt;anon&gt;:46             let limit = 1;\n&lt;anon&gt;:47 \n          ...\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:61:53: 61:57 note: `**data` is borrowed here\n&lt;anon&gt;:61                 let current_count = mets_in_common(&amp;data);\n                                                              ^~~~\nnote: in expansion of for loop expansion\n&lt;anon&gt;:48:13: 66:14 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:42:23: 71:10 help: to force the closure to take ownership of `**data` (and any other referenced variables), use the `move` keyword, as shown:\n&lt;anon&gt;:           thread::spawn(move || {\n&lt;anon&gt;:               let mut best_set : Vec&lt;String&gt; = Vec::new();\n&lt;anon&gt;:               let mut best_count = 0;\n&lt;anon&gt;:               let mut indices: Vec&lt;usize&gt; = Vec::new();\n&lt;anon&gt;:               let limit = 1;\n&lt;anon&gt;:   \n          ...\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:42:23: 71:10 error: closure may outlive the current function, but it borrows `results`, which is owned by the current function [E0373]\n&lt;anon&gt;:42         thread::spawn(|| {\n&lt;anon&gt;:43             let mut best_set : Vec&lt;String&gt; = Vec::new();\n&lt;anon&gt;:44             let mut best_count = 0;\n&lt;anon&gt;:45             let mut indices: Vec&lt;usize&gt; = Vec::new();\n&lt;anon&gt;:46             let limit = 1;\n&lt;anon&gt;:47 \n          ...\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:68:35: 68:42 note: `results` is borrowed here\n&lt;anon&gt;:68                 let mut results = results.lock().unwrap();\n                                            ^~~~~~~\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\n&lt;anon&gt;:42:23: 71:10 help: to force the closure to take ownership of `results` (and any other referenced variables), use the `move` keyword, as shown:\n&lt;anon&gt;:           thread::spawn(move || {\n&lt;anon&gt;:               let mut best_set : Vec&lt;String&gt; = Vec::new();\n&lt;anon&gt;:               let mut best_count = 0;\n&lt;anon&gt;:               let mut indices: Vec&lt;usize&gt; = Vec::new();\n&lt;anon&gt;:               let limit = 1;\n&lt;anon&gt;:   \n          ...\nnote: in expansion of closure expansion\n&lt;anon&gt;:42:23: 71:10 note: expansion site\nnote: in expansion of closure expansion\n&lt;anon&gt;:39:43: 72:6 note: expansion site\nerror: aborting due to 4 previous errors\n</code></pre>\n\n<p>This indicates that there are four variables that get captured, and indicates that two of them are causing trouble when it wishes to capture by value; they are <code>files</code> and <code>data</code>.</p>\n\n<p>Both are vectors, things that can only be accessed from one thread. And <code>thread::spawn</code> requires that it own all the data; the borrow checker cannot reason about the fact that your join guard is joined before <code>data</code> and <code>files</code> are freed.</p>\n"}], "owner": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 140, "favorite_count": 0, "accepted_answer_id": 32263563, "answer_count": 1, "score": 2, "last_activity_date": 1440763907, "creation_date": 1440734802, "last_edit_date": 1440763907, "question_id": 32263184, "link": "https://stackoverflow.com/questions/32263184/wheres-the-illegal-move-in-my-code", "title": "Where&#39;s the illegal move in my code?", "body": "<p>I'm getting error that I'm moving (a) value(s) that I shouldn't be, but the error doesn't make it clear what I'm accidentally moving and I'm missing it when I just look at the code.</p>\n\n<p>Errors:</p>\n\n<pre><code>-*- mode: compilation; default-directory: \"~/Developer/Rust/optimal_subset_finder/src/\" -*-\nCompilation started at Thu Aug 27 21:53:26\n\ncargo build\n   Compiling optimal_subset_finder v0.1.1 (file:///Users/camdennarzt/Developer/Rust/optimal_subset_finder)\nmain.rs:66:23: 98:10 error: cannot move out of captured outer variable in an `FnMut` closure\nmain.rs:66         thread::spawn(move || {\nmain.rs:67             let mut best_set : Vec&lt;String&gt; = Vec::new();\nmain.rs:68             let mut best_count = 0;\nmain.rs:69             let mut rng = thread_rng();\nmain.rs:70             let mut indices = Vec::new();\nmain.rs:71             let limit = attempts.clone()/num_cpus::get();\n           ...\nnote: in expansion of closure expansion\nmain.rs:66:23: 98:10 note: expansion site\nnote: in expansion of closure expansion\nmain.rs:63:57: 99:6 note: expansion site\nmain.rs:66:23: 98:10 error: cannot move out of captured outer variable in an `FnMut` closure\nmain.rs:66         thread::spawn(move || {\nmain.rs:67             let mut best_set : Vec&lt;String&gt; = Vec::new();\nmain.rs:68             let mut best_count = 0;\nmain.rs:69             let mut rng = thread_rng();\nmain.rs:70             let mut indices = Vec::new();\nmain.rs:71             let limit = attempts.clone()/num_cpus::get();\n           ...\nnote: in expansion of closure expansion\nmain.rs:66:23: 98:10 note: expansion site\nnote: in expansion of closure expansion\nmain.rs:63:57: 99:6 note: expansion site\nerror: aborting due to 2 previous errors\nCould not compile `optimal_subset_finder`.\n\nTo learn more, run the command again with --verbose.\n\nCompilation exited abnormally with code 101 at Thu Aug 27 21:53:27\n</code></pre>\n\n<p>code:</p>\n\n<pre><code>extern crate rand;\nextern crate csv;\nextern crate num_cpus;\nextern crate rustc_serialize;\nextern crate docopt;\n\nuse std::fs::File;\nuse csv::Reader;\nuse rand::{thread_rng, sample};\nuse std::thread;\nuse std::io::{self, Write};\nuse std::sync::{Arc, Mutex};\nuse docopt::Docopt;\nuse std::collections::HashSet;\n\nfn as_bool(rdr:&amp;mut Reader&lt;File&gt;)-&gt;Vec&lt;Vec&lt;bool&gt;&gt;{\n    rdr.records().map(|r|{\n        r.unwrap().iter().skip(1).map(|r|{\n            r == \"TRUE\"\n        }).collect()\n    }).collect()\n}\n\nfn as_strings(rdr:&amp;mut Reader&lt;File&gt;)-&gt;Vec&lt;String&gt;{\n    rdr.records().map(|r|{\n        r.unwrap()[0].clone()\n    }).collect()\n}\n\nfn met_n_in_common(n:usize,csv:&amp;Vec&lt;Vec&lt;bool&gt;&gt;)-&gt;bool{\n    csv.iter().all(|r|r[n])\n}\n\nfn mets_in_common(csv:&amp;Vec&lt;Vec&lt;bool&gt;&gt;)-&gt;usize {\n    (0..csv[0].len()).filter(|i| met_n_in_common(*i,csv)).count()\n}\n\nconst USAGE: &amp;'static str = \"\nUsage:\n  ./optimal_subset_finder PATH ATTEMPTS\n\";\n\n#[derive(Debug, RustcDecodable)]\nstruct Args {\n    arg_PATH: String,\n    arg_ATTEMPTS: usize,\n}\n\nfn main() {\n    let args: Args = Docopt::new(USAGE).and_then(|d| d.decode()).unwrap_or_else(|e| e.exit());\n    let attempts = args.arg_ATTEMPTS.clone();\n\n    let mut csv = csv::Reader::from_file(args.arg_PATH.clone()).unwrap();\n    let data = as_bool(&amp;mut csv);\n    csv.seek(0);\n    let files = as_strings(&amp;mut csv);\n\n    let tried_indices = Arc::new(Mutex::new(HashSet::new()));\n    let results = Arc::new(Mutex::new(Vec::new()));\n\n    let mut threads : Vec&lt;_&gt; = (0..num_cpus::get()).map(|i|{\n        let tried_indices = tried_indices.clone();\n        let results = results.clone();\n        thread::spawn(move || {\n            let mut best_set : Vec&lt;String&gt; = Vec::new();\n            let mut best_count = 0;\n            let mut rng = thread_rng();\n            let mut indices = Vec::new();\n            let limit = attempts.clone()/num_cpus::get();\n\n            for _ in (0..limit) {\n                {\n                    let mut tried_indices = tried_indices.lock().unwrap();\n                    while {\n                        let count = *sample(&amp;mut rng, 13..83, 1).first().unwrap();\n                        indices = sample(&amp;mut rng, 0..83, count);\n                        tried_indices.contains(&amp;indices)\n                    }{}\n                    tried_indices.insert(indices.to_owned());\n                };\n                let current_set:Vec&lt;_&gt; = {\n                    indices.iter().map(|i|{\n                        files[*i].clone()\n                    }).collect()\n                };\n                let current_count = mets_in_common(&amp;data);\n                if (current_count &gt; best_count){\n                    best_count = current_count;\n                    best_set = current_set;\n                }\n            }\n            {\n                let mut results = results.lock().unwrap();\n                results.push((best_count,best_set));\n            }\n        })\n    }).collect();\n    for t in threads.into_iter() {\n        t.join();\n    }\n    {\n        let mut results = results.lock().unwrap().to_owned();\n        let first = results.pop().unwrap();\n        let (count,set) = results.into_iter().fold(first,|a,r| if(a.0 &lt; r.0){r}else{a});\n        println!(\"results {:?} {:?}\",count,set);\n    }\n}\n</code></pre>\n"}, {"tags": ["generics", "rust"], "answers": [{"comments": [{"owner": {"reputation": 113, "user_id": 3332686, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/15e2ed5715a8480a4398943918930128?s=128&d=identicon&r=PG&f=1", "display_name": "proc", "link": "https://stackoverflow.com/users/3332686/proc"}, "edited": false, "score": 1, "creation_date": 1609243167, "post_id": 32263221, "comment_id": 115786563, "body": "Note that since rust 1.40 there is a <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.flatten\" rel=\"nofollow noreferrer\">flatten</a> function for <code>Option&lt;Option&lt;T&gt;&gt;</code>."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 6, "last_activity_date": 1440735092, "creation_date": 1440735092, "answer_id": 32263221, "question_id": 32263061, "link": "https://stackoverflow.com/questions/32263061/in-rust-how-to-add-flatten-to-optionoptiont/32263221#32263221", "title": "In Rust, how to &quot;add&quot; `flatten&quot; to Option&lt;Option&lt;T&gt;&gt;?", "body": "<p>You can't write inherent implementations (what you're trying) to types you didn't define, due to coherence (if you could, how do you know someone <em>else</em> hasn't also defined something called <code>flatten</code>?).</p>\n\n<p>Instead, you need to define and implement a trait with the method you want.  Anywhere you want the method, you use the trait:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>trait Flatten&lt;T&gt; {\n    fn flatten(self) -&gt; Option&lt;T&gt;;\n}\n\nimpl&lt;T&gt; Flatten&lt;T&gt; for Option&lt;Option&lt;T&gt;&gt; {\n    fn flatten(self) -&gt; Option&lt;T&gt; {\n        match self {\n            None =&gt; None,\n            Some(v) =&gt; v,\n        }\n    }\n}\n\nfn main() {\n    let x = Some(Some(1));\n    let y = x.flatten();\n    println!(\"{:?}\", y);\n}\n</code></pre>\n\n<p>Also note that I changed the subject of the method from <code>&amp;self</code> to <code>self</code>: you can't move out of a borrow (<em>especially</em> not an immutable one), so taking <code>self</code> by reference doesn't really make sense here.</p>\n"}], "owner": {"reputation": 28896, "user_id": 5295, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/d7535398322ea87021a045d03b16b03f?s=128&d=identicon&r=PG", "display_name": "avernet", "link": "https://stackoverflow.com/users/5295/avernet"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2425, "favorite_count": 0, "closed_date": 1440763726, "accepted_answer_id": 32263221, "answer_count": 1, "score": 4, "last_activity_date": 1440735092, "creation_date": 1440733930, "question_id": 32263061, "link": "https://stackoverflow.com/questions/32263061/in-rust-how-to-add-flatten-to-optionoptiont", "closed_reason": "Duplicate", "title": "In Rust, how to &quot;add&quot; `flatten&quot; to Option&lt;Option&lt;T&gt;&gt;?", "body": "<p>How can I \"add\" a <code>flatten()</code> method to <code>Option&lt;U&gt;</code>, which would only typecheck if and only if <code>U</code> is an <code>Option&lt;T&gt;</code>, or more simply to add it to <code>Option&lt;Option&lt;T&gt;&gt;</code>? Naively, I am trying to write the following, which doesn't compile:</p>\n\n<pre><code>impl Option&lt;Option&lt;T&gt;&gt; {\n    fn flatten(&amp;self) -&gt; Option&lt;T&gt; {\n        match self {\n            None =&gt; None,\n            Some(v) =&gt; v,\n        }\n    }\n}\n\nfn main() {\n    let x = Some(Some(1));\n    let y = x.flatten();\n    println!(\"{:?}\", y);\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 6, "last_activity_date": 1440731819, "creation_date": 1440731819, "answer_id": 32262802, "question_id": 32262669, "link": "https://stackoverflow.com/questions/32262669/comparing-byte-arrays-and-vectors/32262802#32262802", "title": "Comparing byte arrays and vectors", "body": "<p>You can write the following:</p>\n\n<pre><code>assert_eq!(byte_str, &amp;*byte_vec);\n</code></pre>\n\n<p><code>&amp;*</code> may look like a no-op, but in fact, <a href=\"http://doc.rust-lang.org/stable/std/ops/trait.Deref.html\" rel=\"noreferrer\"><code>Deref</code></a> comes into play here and changes the meaning of the unary <code>*</code> operator. <code>&amp;*byte_vec</code> is therefore equivalent to <code>&amp;*(byte_vec.deref())</code>, or just to <code>byte_vec.deref()</code>.</p>\n"}], "owner": {"reputation": 341, "user_id": 384057, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/b8e6ce842c15ea85bc9a1f4aae300adf?s=128&d=identicon&r=PG", "display_name": "Watts", "link": "https://stackoverflow.com/users/384057/watts"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3335, "favorite_count": 1, "accepted_answer_id": 32262802, "answer_count": 1, "score": 2, "last_activity_date": 1440771070, "creation_date": 1440730763, "last_edit_date": 1440771070, "question_id": 32262669, "link": "https://stackoverflow.com/questions/32262669/comparing-byte-arrays-and-vectors", "title": "Comparing byte arrays and vectors", "body": "<p>I'm trying to compare a <code>Vec</code> of bytes read to the very bytes that were read in to the <code>Vec</code>, but I'm having trouble getting the types of the two sides to line up. Here is my code (<a href=\"http://is.gd/goOnYf\" rel=\"nofollow\">http://is.gd/goOnYf</a>):</p>\n\n<pre><code>use std::io::{Cursor, Read};\n// use std::borrow::Borrow;\n\nfn main() {\n    let byte_str = b\"This is a byte string\";\n    let mut byte_vec = Vec::new();\n\n    let mut reader = Cursor::new(byte_str.as_ref());\n    reader.read_to_end(&amp;mut byte_vec).unwrap();\n\n    // assert_eq!(byte_str, byte_vec);\n    // assert_eq!(byte_str, &amp;byte_vec);\n    // assert_eq!(byte_str, byte_vec.as_ref());\n    // assert_eq!(byte_str, byte_vec.borrow());\n\n    let bv: &amp;[u8] = &amp;byte_vec;\n    assert_eq!(byte_str, bv);\n}\n</code></pre>\n\n<p>You can see each of my failed attempts to compare them, before I had to force the <code>Vec</code>'s type with a <code>let</code> binding and compare those.</p>\n\n<p>The first one, <code>assert_eq!(byte_str, byte_vec)</code>, failed with:</p>\n\n<pre><code>`&lt;std macros&gt;:5:8: 5:33 error: the trait `core::cmp::PartialEq&lt;collections::vec::Vec&lt;u8&gt;&gt;` is not implemented for the type `&amp;[u8; 21]`\n</code></pre>\n\n<p>So it looks like I need to turn the <code>Vec</code> on the RHS in to a <code>&amp;[u8]</code>. So I try a shared reference, and get the same error. Then I tried <code>as_ref()</code>, but that (and <code>borrow()</code>) need type annotations that I don't seem to be able to provide inline:</p>\n\n<pre><code>&lt;anon&gt;:13:35: 13:43 error: type annotations required: cannot resolve `collections::vec::Vec&lt;u8&gt; : core::convert::AsRef&lt;_&gt;` [E0283]\n</code></pre>\n\n<p>Is there a simpler way to do this that I'm missing?</p>\n\n<p><strong>Update:</strong> In writing the question, I did find an answer, but it's still kind of clunky:</p>\n\n<pre><code>assert_eq!(byte_str, AsRef::&lt;[u8]&gt;::as_ref(&amp;byte_vec));\n</code></pre>\n\n<p>Is there a better way?</p>\n\n<p><strong>Update 2:</strong> The answer below only worked with some byte arrays I tried it with, but not all. It turns out that all of the handy traits like <code>Debug</code>, <code>PartialEq</code>, etc. are only implemented for arrays with &lt;= 32 elements, so this works:</p>\n\n<pre><code>assert_eq!(b\"01234567890123456789012345678901\", &amp;*byte_vec);\n</code></pre>\n\n<p>but this won't:</p>\n\n<pre><code>assert_eq!(b\"012345678901234567890123456789012\", &amp;*byte_vec);\n</code></pre>\n\n<p>so you have to call <code>as_ref()</code> on it to make it a slice, for which those traits are implemented:</p>\n\n<pre><code>assert_eq!(b\"012345678901234567890123456789012\".as_ref(), &amp;*byte_vec);\n</code></pre>\n"}, {"tags": ["multithreading", "rust", "clone", "traits", "lifetime"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1440707862, "last_edit_date": 1440707862, "creation_date": 1440706649, "answer_id": 32258672, "question_id": 32258264, "link": "https://stackoverflow.com/questions/32258264/cloning-and-moving-traits/32258672#32258672", "title": "Cloning and moving traits", "body": "<blockquote>\n  <p>consider adding an explicit lifetime bound <code>T: 'static</code>...</p>\n</blockquote>\n\n<p>That looks like this:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub fn something&lt;T: 'static + Foo + Clone + Send&gt;(handler: T)\n</code></pre>\n\n<p>which compiles.</p>\n\n<p>In case you are unfamiliar with this syntax, it means that whatever concrete type of <code>T</code> is picked, it must outlive the <code>'static</code> lifetime. This includes any interior references / lifetimes the concrete type may have.</p>\n"}], "owner": {"reputation": 2628, "user_id": 1366913, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/bcd760432e7ba71d5f0c71350886456f?s=128&d=identicon&r=PG", "display_name": "nathansizemore", "link": "https://stackoverflow.com/users/1366913/nathansizemore"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 59, "favorite_count": 0, "accepted_answer_id": 32258672, "answer_count": 1, "score": 0, "last_activity_date": 1440707862, "creation_date": 1440705049, "question_id": 32258264, "link": "https://stackoverflow.com/questions/32258264/cloning-and-moving-traits", "title": "Cloning and moving traits", "body": "<p>I'd like to be able to move a cloned version of an object that implements trait <code>Foo</code> into various threads. I cannot seem to figure out how this is achieved. I've tried cloning and moving a <code>Box&lt;Foo&gt;</code> and specifying the parameter as a generic, but cannot seem make the compiler happy.</p>\n\n<p>My first attempt: </p>\n\n<pre><code>use std::thread;\n\npub trait Foo {\n    fn bar();\n}\n\npub struct Thing;\n\nimpl Thing {\n    pub fn something(handler: Box&lt;Foo&gt;) {\n        let handler_1 = handler.clone();\n        thread::spawn(move || {\n            Thing::another_thread(handler_1)\n        });\n    }\n\n    fn another_thread(handler: Box&lt;Foo&gt;) { }\n}\n</code></pre>\n\n<p>Resulted in the following errors: </p>\n\n<pre><code>error: no method named clone found for type Box&lt;Foo + 'static&gt; in the current scope\nerror: the trait core::marker::Send is not implemented for the type Foo [E0277]\n</code></pre>\n\n<p>Next I tried writing it as a generic parameter...</p>\n\n<pre><code>use std::thread;\n\npub trait Foo {\n    fn bar();\n}\n\npub struct Thing;\n\nimpl Thing {\n    pub fn something&lt;T: Foo + Clone + Send&gt;(handler: T) {\n        let handler_1 = handler.clone();\n        thread::spawn(move || {\n            Thing::another_thread(handler_1)\n        });\n    }\n\n    fn another_thread&lt;T: Foo&gt;(handler: T) { }\n}\n</code></pre>\n\n<p>Received the following error:</p>\n\n<pre><code>error: the parameter type T may not live long enough [E0310]\nhelp: consider adding an explicit lifetime bound T: 'static...\n</code></pre>\n\n<p>Now we've reached the point where I'm lost and I start poking <code>&lt;'a&gt;</code> into every crevice hoping it solves the problem. But, unfortunately, I have no idea what the syntax is for what I'm trying to achieve. Thanks in advance for any help!</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 1221, "user_id": 2636044, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/YauuW.png?s=128&g=1", "display_name": "Onilol", "link": "https://stackoverflow.com/users/2636044/onilol"}, "edited": false, "score": 1, "creation_date": 1440703292, "post_id": 32257273, "comment_id": 52395522, "body": "Regex is what you need."}], "answers": [{"comments": [{"owner": {"reputation": 123, "user_id": 4815835, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/da8d8a56b0daf2af71a157f8fe7ca664?s=128&d=identicon&r=PG&f=1", "display_name": "Keho", "link": "https://stackoverflow.com/users/4815835/keho"}, "edited": false, "score": 0, "creation_date": 1440778608, "post_id": 32257862, "comment_id": 52429799, "body": "Wow, I need to learn more about Rust to understand that code. However I thought after about splitting the string twice with the pattern to gets words and then the opposite pattern. What do you think about my new code ?"}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1440790513, "post_id": 32257862, "comment_id": 52435860, "body": "This will be simpler when <a href=\"http://doc.rust-lang.org/nightly/std/primitive.str.html#method.match_indices\" rel=\"nofollow noreferrer\"><code>str::match_indices</code></a> goes stable."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 4, "last_activity_date": 1534026193, "last_edit_date": 1534026193, "creation_date": 1440703423, "answer_id": 32257862, "question_id": 32257273, "link": "https://stackoverflow.com/questions/32257273/split-a-string-keeping-the-separators/32257862#32257862", "title": "Split a string keeping the separators", "body": "<p>I was not able to find anything in the standard library, so <a href=\"https://github.com/shepmaster/sxd-document/blob/ee354a7735e6d0019cf8e9d3e5adf4e6dc7ac4b8/src/str_ext.rs\" rel=\"nofollow noreferrer\">I wrote my own</a>:</p>\n\n<p>This version uses the unstable pattern API as it's more flexible, but the link above has a fallback that I've hardcoded for my specific stable usecase.</p>\n\n<pre><code>#![feature(pattern)]\n\nuse std::str::pattern::{Pattern, Searcher};\n\n#[derive(Copy, Clone, Debug, PartialEq)]\npub enum SplitType&lt;'a&gt; {\n    Match(&amp;'a str),\n    Delimiter(&amp;'a str),\n}\n\npub struct SplitKeepingDelimiter&lt;'p, P&gt;\nwhere\n    P: Pattern&lt;'p&gt;,\n{\n    searcher: P::Searcher,\n    start: usize,\n    saved: Option&lt;usize&gt;,\n}\n\nimpl&lt;'p, P&gt; Iterator for SplitKeepingDelimiter&lt;'p, P&gt;\nwhere\n    P: Pattern&lt;'p&gt;,\n{\n    type Item = SplitType&lt;'p&gt;;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        if self.start == self.searcher.haystack().len() {\n            return None;\n        }\n\n        if let Some(end_of_match) = self.saved.take() {\n            let s = &amp;self.searcher.haystack()[self.start..end_of_match];\n            self.start = end_of_match;\n            return Some(SplitType::Delimiter(s));\n        }\n\n        match self.searcher.next_match() {\n            Some((start, end)) =&gt; {\n                if self.start == start {\n                    let s = &amp;self.searcher.haystack()[start..end];\n                    self.start = end;\n                    Some(SplitType::Delimiter(s))\n                } else {\n                    let s = &amp;self.searcher.haystack()[self.start..start];\n                    self.start = start;\n                    self.saved = Some(end);\n                    Some(SplitType::Match(s))\n                }\n            }\n            None =&gt; {\n                let s = &amp;self.searcher.haystack()[self.start..];\n                self.start = self.searcher.haystack().len();\n                Some(SplitType::Match(s))\n            }\n        }\n    }\n}\n\npub trait SplitKeepingDelimiterExt: ::std::ops::Index&lt;::std::ops::RangeFull, Output = str&gt; {\n    fn split_keeping_delimiter&lt;P&gt;(&amp;self, pattern: P) -&gt; SplitKeepingDelimiter&lt;P&gt;\n    where\n        P: for&lt;'a&gt; Pattern&lt;'a&gt;,\n    {\n        SplitKeepingDelimiter {\n            searcher: pattern.into_searcher(&amp;self[..]),\n            start: 0,\n            saved: None,\n        }\n    }\n}\n\nimpl SplitKeepingDelimiterExt for str {}\n\n#[cfg(test)]\nmod test {\n    use super::SplitKeepingDelimiterExt;\n\n    #[test]\n    fn split_with_delimiter() {\n        use super::SplitType::*;\n        let delims = &amp;[',', ';'][..];\n        let items: Vec&lt;_&gt; = \"alpha,beta;gamma\".split_keeping_delimiter(delims).collect();\n        assert_eq!(\n            &amp;items,\n            &amp;[\n                Match(\"alpha\"),\n                Delimiter(\",\"),\n                Match(\"beta\"),\n                Delimiter(\";\"),\n                Match(\"gamma\")\n            ]\n        );\n    }\n\n    #[test]\n    fn split_with_delimiter_allows_consecutive_delimiters() {\n        use super::SplitType::*;\n        let delims = &amp;[',', ';'][..];\n        let items: Vec&lt;_&gt; = \",;\".split_keeping_delimiter(delims).collect();\n        assert_eq!(&amp;items, &amp;[Delimiter(\",\"), Delimiter(\";\")]);\n    }\n}\n</code></pre>\n\n<p>You'll note that I needed to track if something was one of the delimiters or not, but that should be easy to adapt if you don't need it.</p>\n"}, {"comments": [{"owner": {"reputation": 13844, "user_id": 12534, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/c248df6104953c22e814d3f4f65b3839?s=128&d=identicon&r=PG", "display_name": "Christian Dav&#233;n", "link": "https://stackoverflow.com/users/12534/christian-dav%c3%a9n"}, "edited": false, "score": 0, "creation_date": 1611638600, "post_id": 40296745, "comment_id": 116509062, "body": "I was playing with this, and realized that renaming <code>matched</code> to <code>separator</code>, made me understand it even better, since what <code>match_indices()</code> is looking for is the separators in the question."}], "tags": [], "owner": {"reputation": 25982, "user_id": 305973, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/cd49db0b676767ea4358b1047c4cddd2?s=128&d=identicon&r=PG", "display_name": "robinst", "link": "https://stackoverflow.com/users/305973/robinst"}, "is_accepted": false, "score": 8, "last_activity_date": 1562514137, "last_edit_date": 1562514137, "creation_date": 1477619193, "answer_id": 40296745, "question_id": 32257273, "link": "https://stackoverflow.com/questions/32257273/split-a-string-keeping-the-separators/40296745#40296745", "title": "Split a string keeping the separators", "body": "<p>Using <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.match_indices\" rel=\"nofollow noreferrer\"><code>str::match_indices</code></a>:</p>\n\n<pre><code>let text = \"Ten. Million. Questions. Let's celebrate all we've done together.\";\n\nlet mut result = Vec::new();\nlet mut last = 0;\nfor (index, matched) in text.match_indices(|c: char| !(c.is_alphanumeric() || c == '\\'')) {\n    if last != index {\n        result.push(&amp;text[last..index]);\n    }\n    result.push(matched);\n    last = index + matched.len();\n}\nif last &lt; text.len() {\n    result.push(&amp;text[last..]);\n}\n\nprintln!(\"{:?}\", result);\n</code></pre>\n\n<p>Prints:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>[\"Ten\", \".\", \" \", \"Million\", \".\", \" \", \"Questions\", \".\", \" \", \"Let\\'s\", \" \", \"celebrate\", \" \", \"all\", \" \", \"we\\'ve\", \" \", \"done\", \" \", \"together\", \".\"]\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 3, "last_activity_date": 1617908049, "last_edit_date": 1617908049, "creation_date": 1592248625, "answer_id": 62395364, "question_id": 32257273, "link": "https://stackoverflow.com/questions/32257273/split-a-string-keeping-the-separators/62395364#62395364", "title": "Split a string keeping the separators", "body": "<p><a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.split_inclusive\" rel=\"nofollow noreferrer\"><code>str::split_inclusive</code></a>, available since Rust 1.51, returns an iterator keeping the delimiters as part of the matched strings, and may be useful in certain cases:</p>\n<pre><code>#[test]\nfn split_with_delimiter() {\n    let items: Vec&lt;_&gt; = &quot;alpha,beta;gamma&quot;\n        .split_inclusive(&amp;[',', ';'][..])\n        .collect();\n    assert_eq!(&amp;items, &amp;[&quot;alpha,&quot;, &quot;beta;&quot;, &quot;gamma&quot;]);\n}\n\n#[test]\nfn split_with_delimiter_allows_consecutive_delimiters() {\n    let items: Vec&lt;_&gt; = &quot;,;&quot;.split_inclusive(&amp;[',', ';'][..]).collect();\n    assert_eq!(&amp;items, &amp;[&quot;,&quot;, &quot;;&quot;]);\n}\n</code></pre>\n"}], "owner": {"reputation": 123, "user_id": 4815835, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/da8d8a56b0daf2af71a157f8fe7ca664?s=128&d=identicon&r=PG&f=1", "display_name": "Keho", "link": "https://stackoverflow.com/users/4815835/keho"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2290, "favorite_count": 2, "answer_count": 3, "score": 12, "last_activity_date": 1617908049, "creation_date": 1440701399, "last_edit_date": 1440778578, "question_id": 32257273, "link": "https://stackoverflow.com/questions/32257273/split-a-string-keeping-the-separators", "title": "Split a string keeping the separators", "body": "<p>Is there a trivial way to split a string keeping the separators?\nInstead of this:</p>\n\n<pre><code>let texte = \"Ten. Million. Questions. Let's celebrate all we've done together.\";\nlet v: Vec&lt;&amp;str&gt; = texte.split(|c: char| !(c.is_alphanumeric() || c == '\\'')).filter(|s| !s.is_empty()).collect();\n</code></pre>\n\n<p>which results with <code>[\"Ten\", \"Million\", \"Questions\", \"Let's\", \"celebrate\", \"all\", \"we've\", \"done\", \"together\"]</code>.</p>\n\n<p>I would like something that gives me :</p>\n\n<p><code>[\"Ten\", \".\", \" \", \"Million\", \".\", \" \", \"Questions\", \".\", \" \", \"Let's\", \"\u00a0\", \"celebrate\", \" \", \"all\", \" \", \"we've\", \" \", \"done\", \" \", \"together\", \".\"]</code>.</p>\n\n<p>I am trying that kind of code (it assumes the string begins with a letter and ends with a 'non'-letter) :</p>\n\n<pre><code>let texte = \"Ten. Million. Questions. Let's celebrate all we've done together.  \";\nlet v1: Vec&lt;&amp;str&gt; = texte.split(|c: char| !(c.is_alphanumeric() || c == '\\'')).filter(|s| !s.is_empty()).collect();\nlet v2: Vec&lt;&amp;str&gt; = texte.split(|c: char| c.is_alphanumeric() || c == '\\'').filter(|s| !s.is_empty()).collect();\nlet mut w: Vec&lt;&amp;str&gt; = Vec::new();\n\nlet mut j = 0;\nfor i in v2 {\n    w.push(v1[j]);\n    w.push(i);\n    j = j+1;\n}\n</code></pre>\n\n<p>It gives me almost the result I wrote earlier but it's good :</p>\n\n<pre><code>[\"Ten\", \". \", \"Million\", \". \", \"Questions\", \". \", \"Let's\", \" \", \"celebrate\", \" \", \"all\", \" \", \"we've\", \" \", \"done\", \" \", \"together\", \".\"]\n</code></pre>\n\n<p>However is there a better way to code that ? Because I tried to enumerate on v2 but it didn't work, and it looks rough to use j in the for loop.</p>\n"}, {"tags": ["multithreading", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1440679891, "post_id": 32249817, "comment_id": 52380165, "body": "Duplicate of <a href=\"http://stackoverflow.com/questions/31644152/processing-vec-in-parallel-how-to-do-safely-or-without-using-unstable-features\" title=\"processing vec in parallel how to do safely or without using unstable features\">stackoverflow.com/questions/31644152/&hellip;</a> ?"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 2, "creation_date": 1440679980, "post_id": 32249817, "comment_id": 52380225, "body": "See also: <a href=\"https://crates.io/crates/scoped_threadpool\" rel=\"nofollow noreferrer\">crates.io/crates/scoped_threadpool</a>"}, {"owner": {"reputation": 7543, "user_id": 1794051, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/4fc6d765eadabca02bdd7b44d6504720?s=128&d=identicon&r=PG", "display_name": "val", "link": "https://stackoverflow.com/users/1794051/val"}, "edited": false, "score": 1, "creation_date": 1440680405, "post_id": 32249817, "comment_id": 52380556, "body": "I think the rust book covers exactly that case here: <a href=\"https://doc.rust-lang.org/book/concurrency.html#safe-shared-mutable-state\" rel=\"nofollow noreferrer\">doc.rust-lang.org/book/&hellip;</a>"}, {"owner": {"reputation": 3181, "user_id": 4998184, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/29c803cb4341d0ff630cb3ca04ab7251?s=128&d=identicon&r=PG", "display_name": "eulerdisk", "link": "https://stackoverflow.com/users/4998184/eulerdisk"}, "edited": false, "score": 2, "creation_date": 1440680605, "post_id": 32249817, "comment_id": 52380705, "body": "See also my response for a similar question which uses pointers: <a href=\"http://stackoverflow.com/questions/31608015/parallel-computing-of-array-elements-in-rust/31609380#31609380\" title=\"parallel computing of array elements in rust\">stackoverflow.com/questions/31608015/&hellip;</a>"}], "answers": [{"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1440681860, "post_id": 32250285, "comment_id": 52381697, "body": "It&#39;d be nice if someone added a link to a pull request into the Rust compiler which fixes the bug which prevents making <code>execute()</code> safe on the stable channel (see the last paragraph)."}, {"owner": {"reputation": 1154, "user_id": 2718447, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/beb3947f85f2dcb663e9566b48c60a1c?s=128&d=identicon&r=PG", "display_name": "anjruu", "link": "https://stackoverflow.com/users/2718447/anjruu"}, "edited": false, "score": 0, "creation_date": 1440690620, "post_id": 32250285, "comment_id": 52388185, "body": "Could I do something like <code>Arc&lt;Mutex&lt;  &amp;mut &#39;a Vec&lt;i32&gt;&gt;&gt;</code>, so that I didn&#39;t have to return an <code>Arc&lt;Mutex&lt;...&gt;&gt;</code>?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 1154, "user_id": 2718447, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/beb3947f85f2dcb663e9566b48c60a1c?s=128&d=identicon&r=PG", "display_name": "anjruu", "link": "https://stackoverflow.com/users/2718447/anjruu"}, "edited": false, "score": 1, "creation_date": 1440692433, "post_id": 32250285, "comment_id": 52389401, "body": "No, you can&#39;t. That&#39;s the whole point of scope-based API actually. You can&#39;t move data with borrowed references inside it into <code>thread::spawn()</code> because it may be unsafe - you could forget to join with the spawned thread, and the references could become invalid. With scoped API the join is enforced statically, and therefore you can share a reference and do not need <code>Arc</code>s."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 7, "last_activity_date": 1440681603, "last_edit_date": 1440681603, "creation_date": 1440680931, "answer_id": 32250285, "question_id": 32249817, "link": "https://stackoverflow.com/questions/32249817/thread-safe-mutable-non-owning-pointer-in-rust/32250285#32250285", "title": "Thread-safe mutable non-owning pointer in Rust?", "body": "<p>The proper way is to use <code>Arc&lt;Mutex&lt;...&gt;&gt;</code> or, for example, <code>Arc&lt;RWLock&lt;...&gt;&gt;</code>. <code>Arc</code> is a shared ownership-based concurrency-safe pointer to immutable data, and <code>Mutex</code>/<code>RWLock</code> introduce synchronized internal mutability. Your code then would look like this:</p>\n\n<pre><code>use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn thread_func(results: Arc&lt;Mutex&lt;Vec&lt;i32&gt;&gt;&gt;, thread_id: i32) {\n    let mut results = results.lock().unwrap();\n    results[thread_id as usize] = thread_id;\n}\n\nfn foo() -&gt; Arc&lt;Mutex&lt;Vec&lt;i32&gt;&gt;&gt; {\n    let results = Arc::new(Mutex::new(vec![0; 4]));\n\n    let guards: Vec&lt;_&gt; = (0..4).map(|i| {\n        let results = results.clone();\n        thread::spawn(move || thread_func(results, i))\n    }).collect();\n\n    for guard in guards {\n        guard.join();\n    }\n\n    results\n}\n</code></pre>\n\n<p>This unfortunately requires you to return <code>Arc&lt;Mutex&lt;Vec&lt;i32&gt;&gt;&gt;</code> from the function because there is no way to \"unwrap\" the value. An alternative is to clone the vector before returning.</p>\n\n<p>However, using a crate like <a href=\"https://crates.io/crates/scoped_threadpool\" rel=\"noreferrer\">scoped_threadpool</a> (whose approach could only be recently made sound; something like it will probably make into the standard library instead of the now deprecated <a href=\"http://doc.rust-lang.org/std/thread/fn.scoped.html\" rel=\"noreferrer\"><code>thread::scoped()</code></a> function, which is unsafe) it can be done in a much nicer way:</p>\n\n<pre><code>extern crate scoped_threadpool;\n\nuse scoped_threadpool::Pool;\n\nfn thread_func(result: &amp;mut i32, thread_id: i32) {\n    *result = thread_id;\n}\n\nfn foo() -&gt; Vec&lt;i32&gt; {\n    let results = vec![0; 4];\n    let mut pool = Pool::new(4);\n\n    pool.scoped(|scope| {\n        for (i, e) in results.iter_mut().enumerate() {\n            scope.execute(move || thread_func(e, i as i32));\n        }\n    });\n\n    results\n}\n</code></pre>\n\n<p>If your <code>thread_func</code> needs to access the whole vector, however, you can't get away without synchronization, so you would need a <code>Mutex</code>, and you would still get the unwrapping problem:</p>\n\n<pre><code>extern crate scoped_threadpool;\n\nuse std::sync::Mutex;\n\nuse scoped_threadpool::Pool;\n\nfn thread_func(results: &amp;Mutex&lt;Vec&lt;u32&gt;&gt;, thread_id: i32) {\n    let mut results = results.lock().unwrap();\n    result[thread_id as usize] = thread_id;\n}\n\nfn foo() -&gt; Vec&lt;i32&gt; {\n    let results = Mutex::new(vec![0; 4]);\n    let mut pool = Pool::new(4);\n\n    pool.scoped(|scope| {\n        for i in 0..4 {\n            scope.execute(move || thread_func(&amp;results, i));\n        }\n    });\n\n    results.lock().unwrap().clone()\n}\n</code></pre>\n\n<p>But at least you don't need any <code>Arc</code>s here. Also <code>execute()</code> method is <code>unsafe</code> if you use stable compiler because it does not have a corresponding fix to make it safe. It is safe on all compiler versions greater than 1.4.0, according to its build script.</p>\n"}], "owner": {"reputation": 1154, "user_id": 2718447, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/beb3947f85f2dcb663e9566b48c60a1c?s=128&d=identicon&r=PG", "display_name": "anjruu", "link": "https://stackoverflow.com/users/2718447/anjruu"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1826, "favorite_count": 1, "accepted_answer_id": 32250285, "answer_count": 1, "score": 7, "last_activity_date": 1440681603, "creation_date": 1440679675, "question_id": 32249817, "link": "https://stackoverflow.com/questions/32249817/thread-safe-mutable-non-owning-pointer-in-rust", "title": "Thread-safe mutable non-owning pointer in Rust?", "body": "<p>I'm trying to parallelize an algorithm I have. This is a sketch of how I would write it in C++:</p>\n\n<pre><code>void thread_func(std::vector&lt;int&gt;&amp; results, int threadid) {\n   results[threadid] = threadid;\n}\n\nstd::vector&lt;int&gt; foo() {\n  std::vector&lt;int&gt; results(4);\n\n  for(int i = 0; i &lt; 4; i++)\n  {\n     spawn_thread(thread_func, results, i);\n  }\n\n  join_threads();\n\n  return results;\n}\n</code></pre>\n\n<p>The point here is that each thread has a reference to a shared, mutable object that it does not own. It seems like this is difficult to do in Rust. Should I try to cobble it together in terms of (and I'm guessing here) <code>Mutex</code>, <code>Cell</code> and <code>&amp;mut</code>, or is there a better pattern I should follow?</p>\n"}, {"tags": ["python", "numpy", "segmentation-fault", "rust", "ffi"], "answers": [{"comments": [{"owner": {"reputation": 2479, "user_id": 178154, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/3325e461df2fda8738f35a8bf4fd735e?s=128&d=identicon&r=PG", "display_name": "big_gie", "link": "https://stackoverflow.com/users/178154/big-gie"}, "edited": false, "score": 0, "creation_date": 1440637242, "post_id": 32238990, "comment_id": 52360113, "body": "So I should use <code>slice::from_raw_parts_mut()</code> instead of <code>Vec::from_raw_parts()</code>, is that it?"}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 5, "last_activity_date": 1440636882, "creation_date": 1440636882, "answer_id": 32238990, "question_id": 32238751, "link": "https://stackoverflow.com/questions/32238751/how-to-fix-a-segmentation-fault-when-passing-an-array-of-int/32238990#32238990", "title": "How to fix a segmentation fault when passing an array of int?", "body": "<p>You should only use <code>Vec::from_raw_parts</code> with data that has been allocated in Rust code with Rust\u2019s allocators. Anything else is truly unsafe.</p>\n\n<p>I expect that Python uses malloc, but Rust uses jemalloc. If jemalloc is instructed to free an address that was not allocated by jemalloc, it will, I believe, crash. Thus, if a vector is freed (i.e. it passes out of scope, its destructor is run) or if it needs to reallocate (e.g. if you push an element onto it), you will encounter a crash.</p>\n\n<p>The first issue is thus that the <code>Vec</code> is having its destructor run; that could be amended by calling <code>std::mem::forget(to_sort)</code> when you\u2019re done with it. The other issue, that any reallocation will crash, is much more dangerous; you have basically made it that you cannot safely access your vector mutably and must be <em>extremely</em> cautious in anything you do with it. Really, you should assume that <em>everything</em> on <code>Vec</code> will make a crash. You should use a <code>&amp;mut [T]</code> instead, if what you want can be done with it.</p>\n"}], "owner": {"reputation": 2479, "user_id": 178154, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/3325e461df2fda8738f35a8bf4fd735e?s=128&d=identicon&r=PG", "display_name": "big_gie", "link": "https://stackoverflow.com/users/178154/big-gie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 461, "favorite_count": 0, "accepted_answer_id": 32238990, "answer_count": 1, "score": 2, "last_activity_date": 1440643854, "creation_date": 1440634840, "last_edit_date": 1440643854, "question_id": 32238751, "link": "https://stackoverflow.com/questions/32238751/how-to-fix-a-segmentation-fault-when-passing-an-array-of-int", "title": "How to fix a segmentation fault when passing an array of int?", "body": "<p>I have a Rust (1.2) library and I want to use its functions from Python (3.4) using Rust's FFI. I'm on OSX 10.10 Yosemite.</p>\n\n<p>Almost all my functions take a mutable slice reference as the input:</p>\n\n<pre><code>pub fn myfunction&lt;T&gt;(array: &amp;mut [T]) { ... }\n</code></pre>\n\n<p>I then expose this function to be used outside of rust with:</p>\n\n<pre><code>#[no_mangle]\npub extern fn ffi_myfunction(array_pointer: *const libc::int8_t, n: libc::size_t) {\n    assert!(!array_pointer.is_null());\n    assert!(n != 0);\n    let mut to_sort = unsafe {\n        slice::from_raw_parts_mut(array_pointer as *mut i8, n as usize)\n    };\n    myfunction(&amp;mut to_sort);\n}\n</code></pre>\n\n<p>This works fine: using python's ctypes module I can call <code>ffi_myfunction()</code> with a numpy array:</p>\n\n<pre><code>#!/usr/bin/env python3\n\nimport ctypes\nimport numpy as np\n\nrustlib = ctypes.CDLL(\"target/debug/libmylib.dylib\")\n\narray = np.arange(5, dtype=np.int8)\n\nrustlib.ffi_myfunction(ctypes.c_void_p(array.ctypes.data), len(array))\n</code></pre>\n\n<p>I also have rust implementation with <code>libc::int16_t</code>, <code>libc::int32_t</code>, and <code>libc::int64_t</code> and I can call them with <code>np.int16</code>, <code>np.int32</code> and <code>np.int64</code>.</p>\n\n<p>I have a second set of Rust functions that I want to call from Python. These functions are slightly different as they take a mutable reference to a vector (not to a slice):</p>\n\n<pre><code>pub fn myotherfunction&lt;T&gt;(array: &amp;mut Vec&lt;T&gt;) { ... }\n</code></pre>\n\n<p>I then create my wrapper as such:</p>\n\n<pre><code>#[no_mangle]\npub extern \"C\" fn ffi_myotherfunction(array_pointer: *const libc::int8_t, n: libc::size_t) {\n    assert!(!array_pointer.is_null());\n    assert!(n != 0);\n    let mut to_sort = unsafe {\n        Vec::from_raw_parts(array_pointer as *mut i8, n as usize, n as usize)\n    };\n    myotherfunction(&amp;mut to_sort);\n}\n</code></pre>\n\n<p>Unfortunately I get a segmentation fault when calling <code>ffi_myotherfunction()</code> from Python.</p>\n\n<p>After some investigation, I can say the following:</p>\n\n<ol>\n<li>Adding a <code>println!()</code> macro anywhere in either <code>myotherfunction()</code> or <code>ffi_myotherfunction()</code> make the function to perform properly. The output is as expected.</li>\n<li>The rust library segfaults for any integer size used (8, 16, 32 and 64 bits integers tried).</li>\n<li>The segfault does not seems to come from <code>myotherfunction()</code> but from the call to <code>Vec::from_raw_parts()</code>. For example I can comment out the call to <code>myotherfunction()</code> from <code>ffi_myotherfunction()</code>, leaving only the unsafe block, and the segfault still happens.</li>\n</ol>\n\n<p>So there seems to be a difference between <code>slice::from_raw_parts_mut()</code> and <code>Vec::from_raw_parts()</code>.</p>\n\n<p>But I cannot understand what is causing that segfault. Am I missing something? Am I doing something wrong? Could there be an issue with how numpy stores its data? Or maybe something about lifetime, borrows or any other rust concepts I'm not getting?</p>\n\n<p>Thank you!</p>\n"}]