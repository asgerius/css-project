[{"tags": ["hashmap", "rust"], "comments": [{"owner": {"reputation": 197, "user_id": 5578790, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/IdI7U.jpg?s=128&g=1", "display_name": "Danek Duvall", "link": "https://stackoverflow.com/users/5578790/danek-duvall"}, "edited": false, "score": 0, "creation_date": 1610831105, "post_id": 27828487, "comment_id": 116258025, "body": "It&#39;s possible to use a <code>BTreeSet</code> as a key to a <code>HashMap</code>, since <code>BTreeSet</code> implements the appropriate traits. I know this isn&#39;t strictly an answer to the original question, but it seems within the scope, anyway: the original question was precisely what I went looking for, but a <code>BTreeSet</code> was, for me, a perfectly fine answer."}], "answers": [{"comments": [{"owner": {"reputation": 63, "user_id": 4430506, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b224e4458057404a1fe107d618001e34?s=128&d=identicon&r=PG&f=1", "display_name": "jojoshua", "link": "https://stackoverflow.com/users/4430506/jojoshua"}, "edited": false, "score": 0, "creation_date": 1420668018, "post_id": 27829190, "comment_id": 44064768, "body": "Thank you for the answer! It affirms that there is a lot I need to learn."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 9, "last_activity_date": 1546739563, "last_edit_date": 1546739563, "creation_date": 1420667070, "answer_id": 27829190, "question_id": 27828487, "link": "https://stackoverflow.com/questions/27828487/is-it-possible-to-use-a-hashset-as-the-key-to-a-hashmap/27829190#27829190", "title": "Is it possible to use a HashSet as the key to a HashMap?", "body": "<p>To make something the key of a <code>HashMap</code>, you need to satisfy 3 traits:</p>\n\n<ol>\n<li><code>Hash</code> \u2014 How do you calculate a hash value for the type?</li>\n<li><code>PartialEq</code> \u2014 How do you decide if two instances of a type are the same?</li>\n<li><code>Eq</code> \u2014 Can you guarantee that the equality is reflexive, symmetric, and transitive? This requires <code>PartialEq</code>.</li>\n</ol>\n\n<p>This is based on the definition of <code>HashMap</code>:</p>\n\n<pre><code>impl&lt;K: Hash + Eq, V&gt; HashMap&lt;K, V, RandomState&gt; {\n    pub fn new() -&gt; HashMap&lt;K, V, RandomState&gt; { /* ... */ }\n}\n</code></pre>\n\n<p>Checking out the docs for <a href=\"https://doc.rust-lang.org/std/collections/struct.HashSet.html\" rel=\"noreferrer\"><code>HashSet</code></a>, you can see what traits it implements (listed at the bottom of the page).</p>\n\n<p>There isn't an implementation of <code>Hash</code> for <code>HashSet</code>, so it cannot be used as a key in a <code>HashMap</code>. That being said, if you have a rational way of computing the hash of a <code>HashSet</code>, then you could create a \"newtype\" around the <code>HashSet</code> and implement these three traits on it.</p>\n\n<p>Here's an example for the \"newtype\":</p>\n\n<pre><code>use std::{\n    collections::{HashMap, HashSet},\n    hash::{Hash, Hasher},\n};\n\nstruct Wrapper&lt;T&gt;(HashSet&lt;T&gt;);\n\nimpl&lt;T&gt; PartialEq for Wrapper&lt;T&gt;\nwhere\n    T: Eq + Hash,\n{\n    fn eq(&amp;self, other: &amp;Wrapper&lt;T&gt;) -&gt; bool {\n        self.0 == other.0\n    }\n}\n\nimpl&lt;T&gt; Eq for Wrapper&lt;T&gt; where T: Eq + Hash {}\n\nimpl&lt;T&gt; Hash for Wrapper&lt;T&gt; {\n    fn hash&lt;H&gt;(&amp;self, _state: &amp;mut H)\n    where\n        H: Hasher,\n    {\n        // do something smart here!!!\n    }\n}\n\nfn main() {\n    let hmap: HashMap&lt;Wrapper&lt;u32&gt;, String&gt; = HashMap::new();\n}\n</code></pre>\n"}], "owner": {"reputation": 63, "user_id": 4430506, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b224e4458057404a1fe107d618001e34?s=128&d=identicon&r=PG&f=1", "display_name": "jojoshua", "link": "https://stackoverflow.com/users/4430506/jojoshua"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1758, "favorite_count": 0, "accepted_answer_id": 27829190, "answer_count": 1, "score": 4, "last_activity_date": 1610756297, "creation_date": 1420664155, "last_edit_date": 1503596439, "question_id": 27828487, "link": "https://stackoverflow.com/questions/27828487/is-it-possible-to-use-a-hashset-as-the-key-to-a-hashmap", "title": "Is it possible to use a HashSet as the key to a HashMap?", "body": "<p>I would like to use a <code>HashSet</code> as the key to a <code>HashMap</code>. Is this possible?</p>\n\n<pre><code>use std::collections::{HashMap, HashSet};\n\nfn main() {\n    let hmap: HashMap&lt;HashSet&lt;usize&gt;, String&gt; = HashMap::new();\n}\n</code></pre>\n\n<p>gives the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `std::collections::HashSet&lt;usize&gt;: std::hash::Hash` is not satisfied\n --&gt; src/main.rs:4:49\n  |\n4 |     let hmap: HashMap&lt;HashSet&lt;usize&gt;, String&gt; = HashMap::new();\n  |                                                 ^^^^^^^^^^^^ the trait `std::hash::Hash` is not implemented for `std::collections::HashSet&lt;usize&gt;`\n  |\n  = note: required by `&lt;std::collections::HashMap&lt;K, V&gt;&gt;::new`\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 6718, "user_id": 2455707, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/768bc63471394edee20bcd4131186118?s=128&d=identicon&r=PG", "display_name": "reem", "link": "https://stackoverflow.com/users/2455707/reem"}, "edited": false, "score": 1, "creation_date": 1420654754, "post_id": 27817036, "comment_id": 44057638, "body": "This will shuffle the bytes of a string, but will randomly error since Rust strings are enforced to be UTF-8 and not every random shuffle of bytes is going to be UTF-8."}, {"owner": {"reputation": 5024, "user_id": 1293385, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7e01e2b0a8da2e2ddf115e57b21cd689?s=128&d=identicon&r=PG", "display_name": "Melle", "link": "https://stackoverflow.com/users/1293385/melle"}, "reply_to_user": {"reputation": 6718, "user_id": 2455707, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/768bc63471394edee20bcd4131186118?s=128&d=identicon&r=PG", "display_name": "reem", "link": "https://stackoverflow.com/users/2455707/reem"}, "edited": false, "score": 0, "creation_date": 1420657483, "post_id": 27817036, "comment_id": 44059270, "body": "@reem, you&#39;re right. I accepted dbaupp&#39;s comment since it&#39;s a great explanation how to go about this in general."}], "tags": [], "owner": {"reputation": 393, "user_id": 2747466, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/85e8697b1855a2aa8e047fd186feba54?s=128&d=identicon&r=PG&f=1", "display_name": "dummydev", "link": "https://stackoverflow.com/users/2747466/dummydev"}, "is_accepted": false, "score": 0, "last_activity_date": 1420626130, "last_edit_date": 1420626130, "creation_date": 1420625553, "answer_id": 27817036, "question_id": 27816488, "link": "https://stackoverflow.com/questions/27816488/how-to-shuffle-a-str-in-place/27817036#27817036", "title": "How to shuffle a str in place", "body": "<p>I am also a beginner with Rust, but what about:</p>\n\n<pre><code>fn main() {\n    // I want to shuffle this string...\n    let value = \"SomeValue\".to_string();\n    let mut bytes = value.into_bytes();\n\n    bytes[0] = bytes[1]; // Shuffle takes place.. sorry but std::rand::thread_rng is not available in the Rust installed on my current machine.\n\n    match String::from_utf8(bytes) { // Should not copy the contents according to documentation.\n        Ok(s) =&gt; println!(\"{}\", s),\n        _ =&gt; println!(\"Error occurred!\")\n    }\n}\n</code></pre>\n\n<p>Also keep in mind that Rust default string encoding is UTF-8 when fiddling around with sequences of bytes. ;)</p>\n\n<hr>\n\n<p>This was a great suggestion, lead me to the following solution, thanks!</p>\n\n<pre><code>use std::rand::{Rng, thread_rng};\n\nfn main() {\n    // I want to shuffle this string...\n    let value: String = \"SomeValue\".to_string();\n    let mut bytes = value.into_bytes();\n\n    thread_rng().shuffle(&amp;mut *bytes.as_mut_slice());\n\n    match String::from_utf8(bytes) { // Should not copy the contents according to documentation.\n        Ok(s) =&gt; println!(\"{}\", s),\n        _ =&gt; println!(\"Error occurred!\")\n    }\n}\n</code></pre>\n\n<p>rustc 0.13.0-nightly (ad9e75938 2015-01-05 00:26:28 +0000)</p>\n"}, {"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 12, "last_activity_date": 1420636313, "last_edit_date": 1420636313, "creation_date": 1420626439, "answer_id": 27817317, "question_id": 27816488, "link": "https://stackoverflow.com/questions/27816488/how-to-shuffle-a-str-in-place/27817317#27817317", "title": "How to shuffle a str in place", "body": "<p>There's no very good way to do this, partly due to the nature of the UTF-8 encoding of strings, and partly due to the inherent properties of Unicode and text.</p>\n\n<p>There's at least three layers of things that could be shuffled in a UTF-8 string:</p>\n\n<ul>\n<li>the raw bytes</li>\n<li>the encoded codepoints</li>\n<li>the graphemes</li>\n</ul>\n\n<p>Shuffling raw bytes is likely to give an invalid UTF-8 string as output unless the string is entirely ASCII. Non-ASCII characters are encoded as special sequences of multiple bytes, and shuffling these will almostly certainly not get them in the right order at the end. Hence shuffling bytes is often not good.</p>\n\n<p>Shuffling codepoints (<code>char</code> in Rust) makes a little bit more sense, but there is still the concept of \"special sequences\", where so-called <a href=\"http://en.wikipedia.org/wiki/Combining_character\">combining characters</a> can be layered on to a single letter adding diacritics etc (e.g. letters like <code>\u00e4</code> can be written as <code>a</code> plus U+0308, the codepoint representing <a href=\"http://en.wikipedia.org/wiki/Diaeresis_%28diacritic%29\">the diaeresis</a>). Hence shuffling characters won't give an invalid UTF-8 string, but it may break up these codepoint sequences and give nonsense output.</p>\n\n<p>This brings me to graphemes: the sequences of codepoints that make up a single visible character (like <code>\u00e4</code> is still a single grapheme when written as one or as two codepoints). This will give the most reliably sensible answer.</p>\n\n<p>Then, once you've decided which you want to shuffle the shuffling strategy can be made:</p>\n\n<ul>\n<li>if the string is guaranteed to be purely ASCII, shuffling the bytes with <code>.shuffle</code> is sensible (with the ASCII assumption, this is equivalent to the others)</li>\n<li>otherwise, there's no standard way to operate in-place, one would get the elements as an iterator (<code>.chars()</code> for codepoints or <code>.graphemes(true)</code> for graphemes), place them into a vector with <code>.collect::&lt;Vec&lt;_&gt;&gt;()</code>, shuffle the vector, and then collect everything back into a new <code>String</code> with e.g. <code>.iter().map(|x| *x).collect::&lt;String&gt;()</code>.</li>\n</ul>\n\n<p>The difficulty of handling codepoints and graphemes is because UTF-8 does not encode them as fixed width, so there's no way to take a random codepoint/grapheme out and insert it somewhere else, or otherwise swap two elements efficiently... Without just decoding everything into an external <code>Vec</code>.</p>\n\n<p>Not being in-place is unfortunate, but strings are hard.</p>\n\n<p>(If your strings are guaranteed to be ASCII, then using a type like the <code>Ascii</code> provided by <a href=\"https://crates.io/crates/ascii\"><code>ascii</code></a> would be a good way to keep things straight, at the type-level.)</p>\n\n<hr>\n\n<p>As an example of the difference of the three things, take a look at:</p>\n\n<pre><code>fn main() {\n    let s = \"U\u034d\u0324\u0355\u031c\u0332\u033c\u031cn\u035c\u0339\u0349\u0345\u032di\u0337\u032ac\u0320\u034d\u0316\u033bo\u0338\u032f\u0316de\u032e\u033b\u034d\u0324\";\n    println!(\"bytes: {}\", s.bytes().count());\n    println!(\"chars: {}\", s.chars().count());\n    println!(\"graphemes: {}\", s.graphemes(true).count());\n}\n</code></pre>\n\n<p>It prints:</p>\n\n<pre><code>bytes: 57\nchars: 32\ngraphemes: 7\n</code></pre>\n\n<p>(<a href=\"http://eeemo.net/\">Generate your own</a>, it demonstrates putting multiple combining character on to a single letter.)</p>\n"}, {"comments": [{"owner": {"reputation": 303, "user_id": 1079170, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a44d49f351b48a00038ccb2549bbcd3f?s=128&d=identicon&r=PG", "display_name": "Will", "link": "https://stackoverflow.com/users/1079170/will"}, "edited": false, "score": 0, "creation_date": 1576398614, "post_id": 27832094, "comment_id": 104881934, "body": "This worked like a charm. The only detail is that since you posted the answer rand has reorganized their code. shuffle is now part of the SliceRandom trait so you use: use rand::seq::SliceRandom; and to shuffle: gslice.shuffle(&amp;mut rng);"}], "tags": [], "owner": {"reputation": 663, "user_id": 1043636, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/926a7e9d35a01745fc3e1cfeed30349e?s=128&d=identicon&r=PG", "display_name": "Arien Malec", "link": "https://stackoverflow.com/users/1043636/arien-malec"}, "is_accepted": false, "score": 3, "last_activity_date": 1420684626, "creation_date": 1420684626, "answer_id": 27832094, "question_id": 27816488, "link": "https://stackoverflow.com/questions/27816488/how-to-shuffle-a-str-in-place/27832094#27832094", "title": "How to shuffle a str in place", "body": "<p>Putting together the suggestion above:</p>\n\n<pre><code>use std::rand::{Rng, thread_rng};\n\nfn str_shuffled(s: &amp;str) -&gt; String {\n    let mut graphemes = s.graphemes(true).collect::&lt;Vec&lt;&amp;str&gt;&gt;();\n    let mut gslice = graphemes.as_mut_slice();\n    let mut rng = thread_rng();\n    rng.shuffle(gslice);\n    gslice.iter().map(|x| *x).collect::&lt;String&gt;()\n}\n\n\nfn main() {\n    println!(\"{}\", str_shuffled(\"Hello, World!\"));\n    println!(\"{}\", str_shuffled(\"selam d\u00fcnya\"));\n    println!(\"{}\", str_shuffled(\"\u4f60\u597d\u4e16\u754c\"));\n    println!(\"{}\", str_shuffled(\"\u03b3\u03b5\u03b9\u03ac \u03c3\u03bf\u03c5 \u03ba\u03cc\u03c3\u03bc\u03bf\u03c2\"));\n    println!(\"{}\", str_shuffled(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u043b\u0442\u0435 \u043c\u0438\u0440\"));\n\n}\n</code></pre>\n"}], "owner": {"reputation": 5024, "user_id": 1293385, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7e01e2b0a8da2e2ddf115e57b21cd689?s=128&d=identicon&r=PG", "display_name": "Melle", "link": "https://stackoverflow.com/users/1293385/melle"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1246, "favorite_count": 0, "accepted_answer_id": 27817317, "answer_count": 3, "score": 4, "last_activity_date": 1420684626, "creation_date": 1420623831, "question_id": 27816488, "link": "https://stackoverflow.com/questions/27816488/how-to-shuffle-a-str-in-place", "title": "How to shuffle a str in place", "body": "<p>I want to shuffle a String in place in Rust, but I seem to miss something. The fix is probably trivial...</p>\n\n<pre><code>use std::rand::{Rng, thread_rng};\n\nfn main() {\n    // I want to shuffle this string...\n    let mut value: String = \"SomeValue\".to_string();\n    let mut bytes = value.as_bytes();\n    let mut slice: &amp;mut [u8] = bytes.as_mut_slice();\n\n    thread_rng().shuffle(slice);\n\n    println!(\"{}\", value); \n}\n</code></pre>\n\n<p>The error I get is</p>\n\n<pre><code>&lt;anon&gt;:8:36: 8:41 error: cannot borrow immutable dereference of `&amp;`-pointer `*bytes` as mutable\n&lt;anon&gt;:8         let mut slice: &amp;mut [u8] = bytes.as_mut_slice();\n                                            ^~~~~\n</code></pre>\n\n<p>I read about String::as_mut_vec() but it's unsafe so I'd rather not use it.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 1517, "user_id": 1822567, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/tcIOG.jpg?s=128&g=1", "display_name": "kieran", "link": "https://stackoverflow.com/users/1822567/kieran"}, "edited": false, "score": 0, "creation_date": 1420627352, "post_id": 27816023, "comment_id": 44041136, "body": "I too am scratching my head at this one -- it&#39;s totally hosed <a href=\"https://github.com/bjz/algebra\" rel=\"nofollow noreferrer\">github.com/bjz/algebra</a>"}, {"owner": {"reputation": 1517, "user_id": 1822567, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/tcIOG.jpg?s=128&g=1", "display_name": "kieran", "link": "https://stackoverflow.com/users/1822567/kieran"}, "edited": false, "score": 1, "creation_date": 1420627883, "post_id": 27816023, "comment_id": 44041426, "body": "although have look at this issue on the rust-lang tracker: <a href=\"https://github.com/rust-lang/rust/issues/20550\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/20550</a>"}], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 16, "last_activity_date": 1420844827, "last_edit_date": 1420844827, "creation_date": 1420635385, "answer_id": 27820018, "question_id": 27816023, "link": "https://stackoverflow.com/questions/27816023/what-is-corekindssized-is-not-implemented-for-the-type-self-in-rust/27820018#27820018", "title": "What is &#39;core::kinds::Sized` is not implemented for the type `Self&#39; in rust?", "body": "<p>There's two things going on here: trait objects coercions (the error), and object safety (fixing it).</p>\n\n<h2>The error</h2>\n\n<p>As suggested by the error message, the difficult part of the code is the <code>Foo::new(self)</code>, and this is because <code>pub fn new&lt;T&gt;(parent: &amp;Array&lt;T&gt;) -&gt; ...</code>, that is, <code>self</code> is being coerced to an <code>&amp;Array&lt;T&gt;</code> trait object. I'll simplify the code to:</p>\n\n<pre><code>trait Array {\n  fn as_foo(&amp;self) {\n    let _ = self as &amp;Array; // coerce to a trait object\n  }\n}\n\nfn main() {}\n</code></pre>\n\n<p>which gives the same thing:</p>\n\n<pre><code>&lt;anon&gt;:3:13: 3:27 error: the trait `core::kinds::Sized` is not implemented for the type `Self`\n&lt;anon&gt;:3     let _ = self as &amp;Array; // coerce to a trait object\n                     ^~~~~~~~~~~~~~\n</code></pre>\n\n<p><code>Self</code> is the stand-in name for the type that implements the trait. Unlike most generic parameters, <code>Self</code> is possibly-unsized (<code>?Sized</code>) by default, since <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0546-Self-not-sized-by-default.md\" rel=\"noreferrer\">RFC 546</a> and <a href=\"https://github.com/rust-lang/rust/pull/20341\" rel=\"noreferrer\">#20341</a> for the purposes of allowing e.g. <code>impl Array&lt;T&gt; for Array&lt;T&gt;</code> to work by default more often (we'll come to this later).</p>\n\n<p>The variable <code>self</code> has type <code>&amp;Self</code>. If <code>Self</code> is a sized type, then this is a normal reference: a single pointer. If <code>Self</code> is an unsized type (like <code>[T]</code> or a trait), then <code>&amp;Self</code> (<code>&amp;[T]</code> or <code>&amp;Trait</code>) is a slice/trait object: a fat pointer.</p>\n\n<p>The error appears because the only references <code>&amp;T</code> that can be cast to a trait object are when <code>T</code> is sized: Rust doesn't support making fat pointers fatter, only thin pointer &rarr; fat pointer is valid. Hence, since the compiler doesn't <em>know</em> that <code>Self</code> will always be <code>Sized</code> (remember, it's special and <code>?Sized</code> by default) it has to assume the worst: that the coercion is not legal, and so it's disallowed.</p>\n\n<h2>Fixing it</h2>\n\n<p>It seems logical that the fix we're looking for is to ensure that <code>Self: Sized</code> when we want to do a coercion. The obvious way to do this would be to make <code>Self</code> <em>always</em> <code>Sized</code>, that is, override the default <code>?Sized</code> bound as follows:</p>\n\n<pre><code>trait Array: Sized {\n  fn as_foo(&amp;self) {\n    let _ = self as &amp;Array; // coerce to a trait object\n  }\n}\n\nfn main() {}\n</code></pre>\n\n<p>Looks good!</p>\n\n<p>Except there's the small point that it doesn't work; but at least it's for a difference reason, we're making progress! Trait objects can only be made out of traits that are \"object safe\" (i.e. safe to be made into a trait object), and having <code>Sized</code> <code>Self</code> is one of the things that breaks object safety:</p>\n\n<pre><code>&lt;anon&gt;:3:13: 3:17 error: cannot convert to a trait object because trait `Array` is not object-safe [E0038]\n&lt;anon&gt;:3     let _ = self as &amp;Array; // coerce to a trait object\n                     ^~~~\n&lt;anon&gt;:3:13: 3:17 note: the trait cannot require that `Self : Sized`\n&lt;anon&gt;:3     let _ = self as &amp;Array; // coerce to a trait object\n                     ^~~~\n&lt;anon&gt;:3:13: 3:17 note: the trait cannot require that `Self : Sized`\n&lt;anon&gt;:3     let _ = self as &amp;Array; // coerce to a trait object\n                     ^~~~\n</code></pre>\n\n<p>(I filed the double printing of the note as <a href=\"https://github.com/rust-lang/rust/issues/20692\" rel=\"noreferrer\">#20692</a>.)</p>\n\n<p>Back to the drawing board. There's a few other \"easy\" possibilities for a solution:</p>\n\n<ul>\n<li>define an extension trait <code>trait ArrayExt: Sized + Array { fn as_foo(&amp;self) { ... } }</code> and implement it for all <code>Sized + Array</code> types</li>\n<li>just use a free function <code>fn array_as_foo&lt;A: Array&gt;(x: &amp;A) { ... }</code></li>\n</ul>\n\n<p>However, these don't necessarily work for every use case, e.g. specific types can't customise the behaviour by overloading the default method. However, fortunately there is a fix!</p>\n\n<h3>The Turon Trick</h3>\n\n<p>(Named for Aaron Turon, who discovered it.)</p>\n\n<p>Using generalised <code>where</code> clauses we can be highly specific about when <code>Self</code> should implement <code>Sized</code>, restricting it to just the method(s) where it is required, without infecting the rest of the trait:</p>\n\n<pre><code>trait Array {\n  fn as_foo(&amp;self) where Self: Sized {\n    let _ = self as &amp;Array; // coerce to a trait object\n  }\n}\n\nfn main() {}\n</code></pre>\n\n<p>This compiles just fine! By using the <code>where</code> clause like this, the compiler understands that (a) the coercion is legal because <code>Self</code> is <code>Sized</code> so <code>self</code> is a thin pointer, and (b) that the method is illegal to call on a trait object anyway, and so doesn't break object safety. To see it being disallowed, changing the body of <code>as_foo</code> to</p>\n\n<pre><code>let x = self as &amp;Array; // coerce to a trait object\nx.as_foo();\n</code></pre>\n\n<p>gives</p>\n\n<pre><code>&lt;anon&gt;:4:7: 4:15 error: the trait `core::kinds::Sized` is not implemented for the type `Array`\n&lt;anon&gt;:4     x.as_foo();\n               ^~~~~~~~\n</code></pre>\n\n<p>as expected.</p>\n\n<h2>Wrapping it all up</h2>\n\n<p>Making this change to the original unsimplified code is as simple adding that <code>where</code> clause to the <code>as_foo</code> method:</p>\n\n<pre><code>struct Foo&lt;'a, T&gt; { //'\n  parent:&amp;'a (Array&lt;T&gt; + 'a)\n}\n\nimpl&lt;'a, T&gt; Foo&lt;'a, T&gt; {\n  pub fn new(parent:&amp;Array&lt;T&gt;) -&gt; Foo&lt;T&gt; {\n    return Foo {\n      parent: parent\n    };\n  }\n}\n\ntrait Array&lt;T&gt; {\n  fn as_foo(&amp;self) -&gt; Foo&lt;T&gt; where Self: Sized {\n    return Foo::new(self);\n  }\n}\n\nfn main() {\n}\n</code></pre>\n\n<p>which compiles without error. (NB. I had to remove the unnecessary <code>&lt;T&gt;</code> in <code>pub fn new&lt;T&gt;</code> because that was causing inference failures.)</p>\n\n<p>(I have some in-progress blog posts that go into trait objects, object safety and the Turon trick, they will appear on <a href=\"http://www.reddit.com/r/rust\" rel=\"noreferrer\">/r/rust</a> in the near future: <a href=\"http://huonw.github.io/blog/2015/01/peeking-inside-trait-objects/\" rel=\"noreferrer\">first one</a>.)</p>\n"}], "owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1935, "favorite_count": 2, "accepted_answer_id": 27820018, "answer_count": 1, "score": 10, "last_activity_date": 1420844827, "creation_date": 1420622416, "last_edit_date": 1420730145, "question_id": 27816023, "link": "https://stackoverflow.com/questions/27816023/what-is-corekindssized-is-not-implemented-for-the-type-self-in-rust", "title": "What is &#39;core::kinds::Sized` is not implemented for the type `Self&#39; in rust?", "body": "<p>This used to work:</p>\n\n<pre><code>struct Foo&lt;'a, T&gt; {\n  parent:&amp;'a (Array&lt;T&gt; + 'a)\n}\n\nimpl&lt;'a, T&gt; Foo&lt;'a, T&gt; { //'\n  pub fn new&lt;T&gt;(parent:&amp;Array&lt;T&gt;) -&gt; Foo&lt;T&gt; {\n    return Foo {\n      parent: parent\n    };\n  }\n}\n\ntrait Array&lt;T&gt; {\n  fn as_foo(&amp;self) -&gt; Foo&lt;T&gt; {\n    return Foo::new(self);\n  }\n}\n\nfn main() {\n}\n</code></pre>\n\n<p>Now it errors:</p>\n\n<blockquote>\n  <p>:15:21: 15:25 error: the trait <code>core::kinds::Sized</code> is not implemented for the type <code>Self</code>\n  :15     return Foo::new(self);</p>\n</blockquote>\n\n<p>I can kind of guess what's wrong; it's saying that my impl of Foo&lt;'a, T> is for T, not Sized? T, but I'm not trying to store a Sized? element in it; I'm storing a <em>reference</em> to a Sized element in it. That should be a pointer, fixed size.</p>\n\n<p>I don't see what's wrong with what I'm doing, or why it's wrong?</p>\n\n<p>For example, I should (I think...) be able to store a &amp;Array in my Foo, no problem. I can't see any reason this would force my Foo instance to be unsized.</p>\n\n<p>playpen link: <a href=\"http://is.gd/eZSZYv\" rel=\"noreferrer\">http://is.gd/eZSZYv</a></p>\n"}, {"tags": ["rust", "rust-obsolete"], "comments": [{"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 1, "creation_date": 1420620345, "post_id": 27815315, "comment_id": 44037238, "body": "Close-voter: why is this offtopic?"}], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 11, "last_activity_date": 1420620481, "creation_date": 1420620481, "answer_id": 27815506, "question_id": 27815315, "link": "https://stackoverflow.com/questions/27815315/how-to-rewrite-code-to-new-unboxed-closures/27815506#27815506", "title": "How to rewrite code to new unboxed closures", "body": "<p>This requires <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0387-higher-ranked-trait-bounds.md\">higher rank trait bounds</a>, specifically, higher rank lifetimes. The full unsugared syntax would be <code>F: for&lt;'a&gt; FnOnce&lt;(&amp;'a mut Builder,), ()&gt;</code>.</p>\n\n<p>Using a lifetime on the function can't work, e.g. if we had </p>\n\n<pre><code>pub fn build&lt;'b, F&gt;(rules: F) -&gt; Builder where F: FnOnce&lt;(&amp;'b mut Builder,), ()&gt;\n</code></pre>\n\n<p>This says that <code>build</code> works with whatever lifetime the caller wishes (e.g. they could chose <code>'b</code> == <code>'static</code>), but this is invalid, because there is a specific concrete lifetime that needs to be the used: the lifetime of the <code>&amp;mut builder</code> inside the function. Using <code>F: for&lt;'a&gt; ...</code> in a bound says that <code>F</code> works with any lifetime <code>'a</code>, so the compiler sees that it is legal to substitute in the one of <code>&amp;mut builder</code>.</p>\n\n<p>As I hinted above, that's the really ugly unsugared syntax. There's two successive ways this can be made much nicer. Firstly, the canonical way to use the closure traits is the <code>()</code> sugar: <code>for&lt;'a&gt; FnOnce(&amp;'a mut Builder) -&gt; ()</code>, or, like with the rest of Rust, the <code>-&gt; ()</code> can be dropped: <code>for&lt;'a&gt; FnOnce(&amp;'a mut Builder)</code>. (NB. this is just sugar for <code>FnOnce&lt;...&gt;</code>, but only the sugared syntax will be stabilised for interacting with these traits at 1.0.)</p>\n\n<p>Then, the paren syntax has a little extra rule: it automatically inserts lifetimes that act like <code>for&lt;'a&gt;</code> (specifically, it undergoes <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0141-lifetime-elision.md\">lifetime elision</a> with any inserted lifetime placed into a <code>for</code> on the trait), so just <code>F: FnOnce(&amp;mut Builder)</code> is equivalent to <code>F: for&lt;'a&gt; FnOnce(&amp;'a mut Builder)</code>, and it's the recommended version.</p>\n\n<p>Applying these fixes to your playpen example:</p>\n\n<pre><code>pub fn initialize_with_closure&lt;F&gt;(rules: F) -&gt; uint where F: FnOnce(&amp;mut uint) {\n    let mut i = 0;\n    rules(&amp;mut i);\n\n    i\n}\n\n// equivalently\npub fn initialize_with_closure_explicit&lt;F&gt;(rules: F) -&gt; uint where F: for&lt;'a&gt; FnOnce(&amp;'a mut uint) -&gt; () {\n    let mut i = 0;\n    rules(&amp;mut i);\n\n    i\n}\n\npub fn main() {\n    initialize_with_closure(|i: &amp;mut uint| *i = *i + 20);\n    initialize_with_closure_explicit(|i: &amp;mut uint| *i = *i + 20);\n}\n</code></pre>\n\n<p><a href=\"http://play.rust-lang.org/?code=pub%20fn%20initialize_with_closure%3CF%3E%28rules%3A%20F%29%20-%3E%20uint%20where%20F%3A%20FnOnce%28%26mut%20uint%29%20%7B%0A%20%20%20%20let%20mut%20i%20%3D%200%3B%0A%20%20%20%20rules%28%26mut%20i%29%3B%0A%0A%20%20%20%20i%0A%7D%0A%2F%2F%20equivalently%0Apub%20fn%20initialize_with_closure_explicit%3CF%3E%28rules%3A%20F%29%20-%3E%20uint%20where%20F%3A%20for%3C%27a%3E%20FnOnce%28%26%27a%20mut%20uint%29%20-%3E%20%28%29%20%7B%0A%20%20%20%20let%20mut%20i%20%3D%200%3B%0A%20%20%20%20rules%28%26mut%20i%29%3B%0A%0A%20%20%20%20i%0A%7D%0A%0Apub%20fn%20main%28%29%20%7B%0A%20%20%20%20initialize_with_closure%28%7Ci%3A%20%26mut%20uint%7C%20*i%20%3D%20*i%20%2B%2020%29%3B%0A%20%20%20%20initialize_with_closure_explicit%28%7Ci%3A%20%26mut%20uint%7C%20*i%20%3D%20*i%20%2B%2020%29%3B%0A%7D%0A\">playpen</a></p>\n"}], "owner": {"reputation": 155, "user_id": 1643246, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dc76ec0558976425ac2eb80610b87c0e?s=128&d=identicon&r=PG", "display_name": "Stanislav Panferov", "link": "https://stackoverflow.com/users/1643246/stanislav-panferov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 615, "favorite_count": 1, "accepted_answer_id": 27815506, "answer_count": 1, "score": 9, "last_activity_date": 1507370784, "creation_date": 1420619718, "last_edit_date": 1507370784, "question_id": 27815315, "link": "https://stackoverflow.com/questions/27815315/how-to-rewrite-code-to-new-unboxed-closures", "title": "How to rewrite code to new unboxed closures", "body": "<p>Can somebody help me to rewrite this piece of code with new unboxed closures:</p>\n\n<pre><code>struct Builder;\npub fn build(rules: |params: &amp;mut Builder|) -&gt; Builder {\n    let mut builder = Builder::new();\n    rules(&amp;mut builder);\n\n    builder\n}\n</code></pre>\n\n<p>I tried to write like this, but I got a lifetime error:</p>\n\n<pre><code>pub fn build&lt;F&gt;(rules: F) -&gt; Builder where F: FnOnce&lt;(&amp;mut Builder,), ()&gt; {\n    let mut builder = Builder::new();\n    rules(&amp;mut builder);\n\n    builder\n}\n\nvalico/src/builder.rs:48:59: 48:71 error: missing lifetime specifier [E0106]\nvalico/src/builder.rs:48     pub fn build&lt;F&gt;(rules: F) -&gt; Builder where F: FnOnce&lt;(&amp;mut Builder,), ()&gt; {\n                                                                                   ^~~~~~~~~~~~\n</code></pre>\n\n<p>What lifetime I need to specify? <a href=\"https://play.rust-lang.org/?gist=863634b2fd5af9693dc2f172fec7f64f\" rel=\"nofollow noreferrer\">Simplified example in the sandbox</a>.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 4, "last_activity_date": 1420588977, "creation_date": 1420588977, "answer_id": 27809381, "question_id": 27809095, "link": "https://stackoverflow.com/questions/27809095/need-help-understanding-iterator-lifetimes/27809381#27809381", "title": "Need help understanding Iterator lifetimes", "body": "<p>The <a href=\"https://github.com/rust-lang/rust/blob/ea6f65c5f1a3f84e010d2cef02a0160804e9567a/src/libcore/ops.rs#L805-L810\" rel=\"nofollow\">definition</a> of <code>Index</code> is:</p>\n\n<pre><code>pub trait Index&lt;Index: ?Sized&gt; {\n    type Output: ?Sized;\n    /// The method for the indexing (`Foo[Bar]`) operation\n    fn index&lt;'a&gt;(&amp;'a self, index: &amp;Index) -&gt; &amp;'a Self::Output;\n}\n</code></pre>\n\n<p>Specifically, <code>index</code> returns a reference to an element where the reference has the same lifetime as <code>self</code>. That is, it borrows <code>self</code>.</p>\n\n<p>In your case, the <code>self</code> of the <code>index</code> call (which could be <code>&amp;self.items[idx]</code> btw) is <code>self.items</code>, so the compiler sees that the return value has to be restricted to be borrowed from <code>self.items</code>, but <code>items</code> is owned by <code>next</code>'s <code>self</code>, so a borrow from <code>self.items</code> is a borrow from <code>self</code> itself.</p>\n\n<p>That is to say, the compiler can only guarantee the return value of <code>index</code> is valid for as long as <code>self</code> lives (and various concerns about mutation), so the lifetimes of <code>&amp;mut self</code> and the returned <code>&amp;...</code> have to be linked.</p>\n\n<p>If one compiles it, to see the error, linking the references is what the compiler suggests: </p>\n\n<pre><code>&lt;anon&gt;:23:29: 23:40 error: cannot infer an appropriate lifetime for autoref due to conflicting requirements\n&lt;anon&gt;:23             Some(self.items.index(&amp;idx))\n                                      ^~~~~~~~~~~\n&lt;anon&gt;:17:5: 25:6 help: consider using an explicit lifetime parameter as shown: fn next(&amp;'a mut self) -&gt; Option&lt;&amp;'a &lt;I as Index&lt;uint&gt;&gt;::Output&gt;\n&lt;anon&gt;:17     fn next(&amp;mut self) -&gt; Option&lt;&amp;'a &lt;I as Index&lt;uint&gt;&gt;::Output&gt; {\n&lt;anon&gt;:18         if (self.current_idx &gt;= self.len) {\n&lt;anon&gt;:19             None\n&lt;anon&gt;:20         } else {\n&lt;anon&gt;:21             let idx = self.current_idx;\n&lt;anon&gt;:22             self.current_idx += self.stride;\n          ...\n</code></pre>\n\n<p>However, the suggested signature <code>fn next(&amp;'a mut self) -&gt; Option&lt;&amp;'a &lt;I as Index&lt;uint&gt;&gt;::Output&gt;</code> is more restrictive than signature of the <code>Iterator</code> trait, and so is illegal. (Iterators with this arrangement of lifetimes may be useful, but they do not work with many common consumers, like <code>.collect</code>.)</p>\n\n<p>The problem the compiler is protecting against is demonstrated by a type like:</p>\n\n<pre><code>struct IndexablePair&lt;T&gt;  {\n    x: T, y: T\n}\n\nimpl Index&lt;uint&gt; for IndexablePair&lt;T&gt; {\n    type Output = T;\n    fn index(&amp;self, index: &amp;uint) -&gt; &amp;T {\n        match *index {\n            0 =&gt; &amp;self.x,\n            1 =&gt; &amp;self.y,\n            _ =&gt; panic!(\"out of bounds\")\n        }\n    }\n}\n</code></pre>\n\n<p>This stores two <code>T</code>s inline (e.g. straight on the stack) and allows for indexing them <code>pair[0]</code> and <code>pair[1]</code>. The <code>index</code> method returns a pointer straight into that memory (e.g. the stack), so if an <code>IndexablePair</code> value moves in memory, those pointers will become invalid, e.g. (assume <code>Stride::new(items: I, len: uint, stride: uint)</code>):</p>\n\n<pre><code>let pair = IndexablePair { x: \"foo\".to_string(), y: \"bar\".to_string() };\n\nlet mut stride = Stride::new(pair, 2, 1);\n\nlet value = stride.next();\n\n// allocate some memory and move stride into, changing its address\nlet mut moved = box stride;\n\nprintln!(\"value is {}\", value);\n</code></pre>\n\n<p>That penultimate line is bad! It invalidates <code>value</code> because the <code>stride</code>, and it's field <code>items</code> (the pair) is moved in memory so the reference inside <code>value</code> is then pointing to moved data; which is highly unsafe and very bad.</p>\n\n<p>The suggested lifetimes stop this problem (and several other problematic ones) by borrowing <code>stride</code> and disallowing the move, but, as we saw above we can't use that.</p>\n\n<p>A technique to resole this is to separate the memory storing the elements from the iterator itself, that is, change the definition of <code>Stride</code> to:</p>\n\n<pre><code>pub struct Stride&lt;'a, I: Index&lt;uint&gt; + 'a&gt; {\n    items: &amp;'a I,\n    len: uint,\n    current_idx: uint,\n    stride: uint,\n}\n</code></pre>\n\n<p>(Adding a reference to <code>items</code>.)</p>\n\n<p>The compiler then has the guarantee that the memory storing the elements is independent of the <code>Stride</code> value (that is, moving <code>Stride</code> around in memory won't invalidate the old elements) because there's a non-owning pointer separating them. This version compiles fine:</p>\n\n<pre><code>use std::ops::Index;\n\n#[derive(Clone)]\npub struct Stride&lt;'a, I: Index&lt;uint&gt; + 'a&gt; {\n    items: &amp;'a I,\n    len: uint,\n    current_idx: uint,\n    stride: uint,\n}\n\nimpl&lt;'a, I&gt; Iterator for Stride&lt;'a, I&gt; where I: Index&lt;uint&gt; {\n    type Item = &amp;'a &lt;I as Index&lt;uint&gt;&gt;::Output;\n\n    #[inline]\n    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a &lt;I as Index&lt;uint&gt;&gt;::Output&gt; {\n        if (self.current_idx &gt;= self.len) {\n            None\n        } else {\n            let idx = self.current_idx;\n            self.current_idx += self.stride;\n            Some(self.items.index(&amp;idx))\n        }\n    }\n}\n</code></pre>\n\n<p>(Theoretically one could add a <code>?Sized</code> bound in there, probably by manually implementing <code>Clone</code> instead of <code>derive</code>ing it, so that <code>Stride</code> can be used directly with a <code>&amp;[T]</code>, i.e. <code>Stride::new(items: &amp;I, ...)</code> <code>Stride::new(&amp;[1, 2, 3], ...)</code> would work, rather than having to have a double layer of <code>Stride::new(&amp;&amp;[1, 2, 3], ...)</code> as the default <code>Sized</code> bound requires.)</p>\n\n<p><a href=\"http://play.rust-lang.org/?code=%23!%5Bfeature%28associated_types%29%5D%0A%0Ause%20std%3A%3Aops%3A%3AIndex%3B%0A%0A%23%5Bderive%28Clone%29%5D%0Apub%20struct%20Stride%3C%27a%2C%20I%3A%20Index%3Cuint%3E%20%2B%20%27a%3E%20%7B%0A%20%20%20%20items%3A%20%26%27a%20I%2C%0A%20%20%20%20len%3A%20uint%2C%0A%20%20%20%20current_idx%3A%20uint%2C%0A%20%20%20%20stride%3A%20uint%2C%0A%7D%0A%0Aimpl%3C%27a%2C%20I%3E%20Iterator%20for%20Stride%3C%27a%2C%20I%3E%20where%20I%3A%20Index%3Cuint%3E%20%7B%0A%20%20%20%20type%20Item%20%3D%20%26%27a%20%3CI%20as%20Index%3Cuint%3E%3E%3A%3AOutput%3B%0A%0A%20%20%20%20%23%5Binline%5D%0A%20%20%20%20fn%20next%28%26mut%20self%29%20-%3E%20Option%3C%26%27a%20%3CI%20as%20Index%3Cuint%3E%3E%3A%3AOutput%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20%28self.current_idx%20%3E%3D%20self.len%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20None%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20idx%20%3D%20self.current_idx%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.current_idx%20%2B%3D%20self.stride%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some%28self.items.index%28%26idx%29%29%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main%28%29%20%7B%7D\" rel=\"nofollow\">playpen</a></p>\n"}], "owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 631, "favorite_count": 0, "accepted_answer_id": 27809381, "answer_count": 1, "score": 0, "last_activity_date": 1420588977, "creation_date": 1420587084, "question_id": 27809095, "link": "https://stackoverflow.com/questions/27809095/need-help-understanding-iterator-lifetimes", "title": "Need help understanding Iterator lifetimes", "body": "<p>Consider the following code:</p>\n\n<pre><code>#[derive(Clone)]\npub struct Stride&lt;'a, I: Index&lt;uint&gt; + 'a&gt; {\n    items: I,\n    len: uint,\n    current_idx: uint,\n    stride: uint,\n}\n\nimpl&lt;'a, I&gt; Iterator for Stride&lt;'a, I&gt; where I: Index&lt;uint&gt; {\n    type Item = &amp;'a &lt;I as Index&lt;uint&gt;&gt;::Output;\n\n    #[inline]\n    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a &lt;I as Index&lt;uint&gt;&gt;::Output&gt; {\n        if (self.current_idx &gt;= self.len) {\n            None\n        } else {\n            let idx = self.current_idx;\n            self.current_idx += self.stride;\n            Some(self.items.index(&amp;idx))\n        }\n    }\n}\n</code></pre>\n\n<p>This currently errors, saying that the compiler cannot infer an appropriate lifetime for the <code>Some(self.items.index(&amp;idx))</code> line. What should the lifetime of the return value be? I believe it should be the same lifetime as <code>self.items</code>, because the <code>Index</code> trait method returns a reference with the same lifetime as the <code>Index</code> implementor.</p>\n"}, {"tags": ["linux", "rust", "rust-obsolete"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 4, "creation_date": 1420564051, "post_id": 27803491, "comment_id": 44016093, "body": "Can you reliable reproduce this, across different workloads and sessions? And what&#39;s your exact platform? I think the answer may well be hidden in your operating system&#39;s scheduler rather than any Rust code."}, {"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420564383, "post_id": 27803491, "comment_id": 44016292, "body": "I&#39;ve edited the Question."}, {"owner": {"reputation": 16871, "user_id": 1281385, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/3590d48970d9b0e96fabb0b23614be61?s=128&d=identicon&r=PG", "display_name": "exussum", "link": "https://stackoverflow.com/users/1281385/exussum"}, "edited": false, "score": 1, "creation_date": 1420564427, "post_id": 27803491, "comment_id": 44016315, "body": "&quot;I can reproduce this very reliably, but it doesn&#39;t happen 100% of the time.&quot; how reliable is that ?"}, {"owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "reply_to_user": {"reputation": 16871, "user_id": 1281385, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/3590d48970d9b0e96fabb0b23614be61?s=128&d=identicon&r=PG", "display_name": "exussum", "link": "https://stackoverflow.com/users/1281385/exussum"}, "edited": false, "score": 0, "creation_date": 1420564467, "post_id": 27803491, "comment_id": 44016339, "body": "@exussum: That must be 99% of the time ;-)"}, {"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 1, "creation_date": 1420564488, "post_id": 27803491, "comment_id": 44016353, "body": "I am able to reproduce this on <a href=\"http://is.gd/er2Xc1\" rel=\"nofollow noreferrer\">play.rust-lang.org</a> (Try changing <code>+ 1</code> to <code>+ 0</code>)."}, {"owner": {"reputation": 9542, "user_id": 985296, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/fb867640ddc6aee363d96530573845b0?s=128&d=identicon&r=PG", "display_name": "stefan", "link": "https://stackoverflow.com/users/985296/stefan"}, "edited": false, "score": 0, "creation_date": 1420565026, "post_id": 27803491, "comment_id": 44016645, "body": "That&#39;s why you shouldn&#39;t just guess when things are done, but check it (I&#39;ve never done rust, so I don&#39;t know if the following piece of code is actually (thread-)safe, but it definitely works something along that way): <a href=\"http://is.gd/KcHr3P\" rel=\"nofollow noreferrer\">play.rust-lang.org</a>. You may use a <a href=\"http://doc.rust-lang.org/std/sync/struct.Condvar.html\" rel=\"nofollow noreferrer\">condvar</a> for this to make it beautiful"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1420565048, "post_id": 27803491, "comment_id": 44016654, "body": "I think this will boil down to things like &quot;what version and options was your kernel compiled with&quot; and &quot;how many other programs are you running at the same time&quot; and &quot;what process scheduler are you using with what options&quot;. Said another way, there&#39;s probably some setting somewhere that schedules threads that happens to do one thing for &gt;= 1ms and another for &lt; 1ms."}, {"owner": {"reputation": 198293, "user_id": 707111, "user_type": "moderator", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/oXZkh.jpg?s=128&g=1", "display_name": "Ry-", "link": "https://stackoverflow.com/users/707111/ry"}, "edited": false, "score": 0, "creation_date": 1420565599, "post_id": 27803491, "comment_id": 44016920, "body": "Can you reproduce it with this? <a href=\"https://gist.github.com/rninty/c15c45afe5e570e139cf\" rel=\"nofollow noreferrer\">gist.github.com/rninty/c15c45afe5e570e139cf</a>"}, {"owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "reply_to_user": {"reputation": 9542, "user_id": 985296, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/fb867640ddc6aee363d96530573845b0?s=128&d=identicon&r=PG", "display_name": "stefan", "link": "https://stackoverflow.com/users/985296/stefan"}, "edited": false, "score": 0, "creation_date": 1420565700, "post_id": 27803491, "comment_id": 44016969, "body": "@stefan Your playpen example goes into an infinite loop - <code>done</code> is not shared between the threads because of <code>move</code>."}, {"owner": {"reputation": 9542, "user_id": 985296, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/fb867640ddc6aee363d96530573845b0?s=128&d=identicon&r=PG", "display_name": "stefan", "link": "https://stackoverflow.com/users/985296/stefan"}, "reply_to_user": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "edited": false, "score": 0, "creation_date": 1420565767, "post_id": 27803491, "comment_id": 44017007, "body": "@wingedsubmariner As I said: never done anything with rust before. But this should be possible with a condvar as I also said."}, {"owner": {"reputation": 9542, "user_id": 985296, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/fb867640ddc6aee363d96530573845b0?s=128&d=identicon&r=PG", "display_name": "stefan", "link": "https://stackoverflow.com/users/985296/stefan"}, "reply_to_user": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "edited": false, "score": 0, "creation_date": 1420566086, "post_id": 27803491, "comment_id": 44017181, "body": "@wingedsubmariner <a href=\"http://is.gd/UeaN62\" rel=\"nofollow noreferrer\">is.gd/UeaN62</a> I gather that&#39;s a valid approach, is it?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 9542, "user_id": 985296, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/fb867640ddc6aee363d96530573845b0?s=128&d=identicon&r=PG", "display_name": "stefan", "link": "https://stackoverflow.com/users/985296/stefan"}, "edited": false, "score": 1, "creation_date": 1420566258, "post_id": 27803491, "comment_id": 44017278, "body": "@stefan it&#39;s probably easier to use a <a href=\"http://doc.rust-lang.org/std/sync/mpsc/fn.channel.html\" rel=\"nofollow noreferrer\">channel</a>, but that&#39;s starting to get into a new question that I&#39;d encourage you to ask separately!"}, {"owner": {"reputation": 9542, "user_id": 985296, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/fb867640ddc6aee363d96530573845b0?s=128&d=identicon&r=PG", "display_name": "stefan", "link": "https://stackoverflow.com/users/985296/stefan"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420566423, "post_id": 27803491, "comment_id": 44017380, "body": "@Shepmaster I&#39;m not actually interested in this. I just wanted to point out that there are ways (no matter how they are called in this language and no matter which one is optimal) to actually do this properly ;-)"}, {"owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "reply_to_user": {"reputation": 9542, "user_id": 985296, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/fb867640ddc6aee363d96530573845b0?s=128&d=identicon&r=PG", "display_name": "stefan", "link": "https://stackoverflow.com/users/985296/stefan"}, "edited": false, "score": 0, "creation_date": 1420566512, "post_id": 27803491, "comment_id": 44017431, "body": "@stefan Your solution with the condvar looks perfectly valid to me. A channel may be simpler, but this works perfectly fine."}, {"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "reply_to_user": {"reputation": 198293, "user_id": 707111, "user_type": "moderator", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/oXZkh.jpg?s=128&g=1", "display_name": "Ry-", "link": "https://stackoverflow.com/users/707111/ry"}, "edited": false, "score": 0, "creation_date": 1420567217, "post_id": 27803491, "comment_id": 44017798, "body": "@U2744SNOWFLAKE I can&#39;t, even when using 1 as an argument. Also, I sometimes get 2 <code>some output</code> lines with that code."}], "answers": [{"tags": [], "owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "is_accepted": true, "score": 28, "last_activity_date": 1420572686, "last_edit_date": 1420572686, "creation_date": 1420566151, "answer_id": 27804151, "question_id": 27803491, "link": "https://stackoverflow.com/questions/27803491/how-is-999%c2%b5s-too-short-but-1000%c2%b5s-just-right/27804151#27804151", "title": "How is 999&#181;s too short but 1000&#181;s just right?", "body": "<p>The <code>sleep</code> function sleeps in increments of 1 millisecond, and if the number of milliseconds is less than 1 it does not sleep at all. Here is the relevant <a href=\"http://doc.rust-lang.org/src/std/io/timer.rs.html#98-103\">excerpt from the code</a>:</p>\n\n<pre><code>pub fn sleep(&amp;mut self, duration: Duration) {\n    // Short-circuit the timer backend for 0 duration\n    let ms = in_ms_u64(duration);\n    if ms == 0 { return }\n    self.inner.sleep(ms);\n}\n</code></pre>\n\n<p>In your code, 999 microseconds made it not sleep at all, and the main thread ended before the spawned thread could print its output. With 1000 microseconds, i.e. 1 millisecond, the main thread slept, giving the spawned thread a chance to run.</p>\n"}, {"comments": [{"owner": {"reputation": 7824, "user_id": 3899431, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/UeEzu.jpg?s=128&g=1", "display_name": "Luis Colorado", "link": "https://stackoverflow.com/users/3899431/luis-colorado"}, "reply_to_user": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420781474, "post_id": 27841566, "comment_id": 44112403, "body": "that&#39;s not a reason to downvote... If it where, the thread might be closed and not allow more comments.  I try to give some help, not to read all stackoverflow before answering."}, {"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420820139, "post_id": 27841566, "comment_id": 44131838, "body": "The Answer I&#39;m referring to was already Accepted on the Question you were Answering."}], "tags": [], "owner": {"reputation": 7824, "user_id": 3899431, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/UeEzu.jpg?s=128&g=1", "display_name": "Luis Colorado", "link": "https://stackoverflow.com/users/3899431/luis-colorado"}, "is_accepted": false, "score": -3, "last_activity_date": 1420728565, "last_edit_date": 1420728565, "creation_date": 1420724628, "answer_id": 27841566, "question_id": 27803491, "link": "https://stackoverflow.com/questions/27803491/how-is-999%c2%b5s-too-short-but-1000%c2%b5s-just-right/27841566#27841566", "title": "How is 999&#181;s too short but 1000&#181;s just right?", "body": "<p>The most probable thing is you have your kernel configured to have a TICK of 1000Hz (once clock interrupt per millisecond)  Perhaps you can improve it recompiling on a finer grained clock or a tickless kernel and recompiling your kernel to allow finer clock resolution.  The 1000Hz clock tick is nowadays standard in Linux kernels running on pc (and most of ARMs and embedded Linux).</p>\n\n<p>This is not a newbie issue, so perhaps you'll have to ask for local help to reconfigure and recompile your kernel to cope with more time resolution.</p>\n"}], "owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 380, "favorite_count": 0, "accepted_answer_id": 27804151, "answer_count": 2, "score": 6, "last_activity_date": 1436653757, "creation_date": 1420563617, "last_edit_date": 1495539880, "question_id": 27803491, "link": "https://stackoverflow.com/questions/27803491/how-is-999%c2%b5s-too-short-but-1000%c2%b5s-just-right", "title": "How is 999&#181;s too short but 1000&#181;s just right?", "body": "<p>When I run the following code, I get <code>some output</code>:</p>\n\n<pre><code>use std::thread::Thread;\n\nstatic DELAY: i64 = 1000;\n\nfn main() {\n    Thread::spawn(move || {\n        println!(\"some output\");\n    });\n\n    std::io::timer::sleep(std::time::duration::Duration::microseconds(DELAY));\n}\n</code></pre>\n\n<p>But if I set <code>DELAY</code> to 999, I get nothing. I think that 999 and 1000 are close enough not to cause such a difference, meaning there must be something else going on here. I've tried also with <code>Duration::nanoseconds</code> (999_999 and 1_000_000), and I see the same behavior.</p>\n\n<p>My platform is Linux and I can reproduce this behavior nearly all the time: using 999 results in <code>some output</code> in way less than 1% of runs.</p>\n\n<hr>\n\n<p>As a sidenote, I am aware that this approach <a href=\"https://stackoverflow.com/q/27770032\">is wrong</a>.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 17, "last_activity_date": 1499109682, "last_edit_date": 1499109682, "creation_date": 1420561087, "answer_id": 27802702, "question_id": 27801810, "link": "https://stackoverflow.com/questions/27801810/how-to-bound-the-type-of-iteratoritem/27802702#27802702", "title": "How to bound the type of Iterator::Item?", "body": "<p>You can introduce a second generic type parameter and place the bound on that:</p>\n\n<pre><code>fn somefunc&lt;A: Int, I: Iterator&lt;Item = A&gt;&gt;(mut xs: I) {\n    xs.next().unwrap().pow(2);\n}\n</code></pre>\n\n<p>You can also place trait bounds on the associated type itself </p>\n\n<pre><code>fn somefunc&lt;I: Iterator&gt;(mut xs: I)\nwhere\n    I::Item: Int,\n{\n    xs.next().unwrap().pow(2);\n}\n</code></pre>\n"}], "owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1878, "favorite_count": 2, "accepted_answer_id": 27802702, "answer_count": 1, "score": 11, "last_activity_date": 1499109887, "creation_date": 1420558101, "last_edit_date": 1499109887, "question_id": 27801810, "link": "https://stackoverflow.com/questions/27801810/how-to-bound-the-type-of-iteratoritem", "title": "How to bound the type of Iterator::Item?", "body": "<p>I'm not sure how to specify bounds on the type of the output of the iterator for generic iterators. Before Rust 1.0, I used to be able to do this:</p>\n\n<pre><code>fn somefunc&lt;A: Int, I: Iterator&lt;A&gt;&gt;(xs: I) {\n    xs.next().unwrap().pow(2);\n}\n</code></pre>\n\n<p>But now, I'm not sure how to put bounds on the iterator's <code>Item</code> type.</p>\n\n<pre><code>fn somefunc&lt;I: Iterator&gt;(xs: I) {\n    xs.next().unwrap().pow(2);\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: no method named `pow` found for type `&lt;I as std::iter::Iterator&gt;::Item` in the current scope\n --&gt; src/main.rs:2:28\n  |\n2 |         xs.next().unwrap().pow(2);\n  |                            ^^^\n</code></pre>\n\n<p>How can I get this to work?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1420514080, "post_id": 27791532, "comment_id": 43992777, "body": "Have you looked at how the existing Rust bindings for OpenGL handle this same problem?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 22, "creation_date": 1420528309, "post_id": 27791532, "comment_id": 43996827, "body": "<i>Yes, this is necessary, it is the OpenGL subsystem, and making multiple copies of this and passing it around everywhere would add confusion, rather than relieve it.</i> =&gt; this is not the definition of <i>necessary</i>, it is maybe <i>convenient</i> (at first) but not necessary."}, {"owner": {"reputation": 2295, "user_id": 1099089, "user_type": "registered", "accept_rate": 11, "profile_image": "https://www.gravatar.com/avatar/a0bf49f333363ebd26ae2d0df3be9533?s=128&d=identicon&r=PG", "display_name": "stevenkucera", "link": "https://stackoverflow.com/users/1099089/stevenkucera"}, "edited": false, "score": 3, "creation_date": 1420591035, "post_id": 27791532, "comment_id": 44028278, "body": "Yes you have a point. Although since OpenGL is a big state machine anyway, I am close to certain there will not be a clone of it anywhere, whose use would only result in OpenGL errors."}], "answers": [{"comments": [{"owner": {"reputation": 2295, "user_id": 1099089, "user_type": "registered", "accept_rate": 11, "profile_image": "https://www.gravatar.com/avatar/a0bf49f333363ebd26ae2d0df3be9533?s=128&d=identicon&r=PG", "display_name": "stevenkucera", "link": "https://stackoverflow.com/users/1099089/stevenkucera"}, "edited": false, "score": 80, "creation_date": 1420678082, "post_id": 27826181, "comment_id": 44068372, "body": "After a lot of thought I&#39;m convinced not to use the Singleton, and instead use no global variables at all and pass everything around. Makes the code more self-documenting since it is clear what functions access the renderer. If I want to change back to singleton, it will be easier to do that than the other way around."}, {"owner": {"reputation": 121, "user_id": 3221248, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f4169d9da08bf5fc7453c9d89fdf092a?s=128&d=identicon&r=PG", "display_name": "Moises Silva", "link": "https://stackoverflow.com/users/3221248/moises-silva"}, "edited": false, "score": 5, "creation_date": 1470503464, "post_id": 27826181, "comment_id": 64981855, "body": "Thanks for the answer, it helped a lot. I just thought I&#39;d let here a comment to describe what I see as a valid use case for lazy_static!. I am using it to interface to a C application that allows loading/unloading modules (shared objects) and the rust code is one of these modules. I don&#39;t see much option than using a global on load because I have no control over main() at all and how the core application interfaces with my module. I basically needed a vector of things that can be added on runtime after my mod is loaded."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 121, "user_id": 3221248, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f4169d9da08bf5fc7453c9d89fdf092a?s=128&d=identicon&r=PG", "display_name": "Moises Silva", "link": "https://stackoverflow.com/users/3221248/moises-silva"}, "edited": false, "score": 1, "creation_date": 1470503755, "post_id": 27826181, "comment_id": 64981950, "body": "@MoisesSilva there&#39;s always going to be <i>some</i> reason to need a singleton, but it&#39;s unnecessary to use it in many of the cases it is used. Without knowing your code, it&#39;s possible that the C application should allow each module to return a &quot;user data&quot; <code>void *</code> which is then passed back into each module&#39;s methods. This is a typical extension pattern for C code. If the application doesn&#39;t allow for this and you cannot change it, then yes, a singleton may be a good solution."}, {"owner": {"reputation": 121, "user_id": 3221248, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f4169d9da08bf5fc7453c9d89fdf092a?s=128&d=identicon&r=PG", "display_name": "Moises Silva", "link": "https://stackoverflow.com/users/3221248/moises-silva"}, "edited": false, "score": 1, "creation_date": 1470668166, "post_id": 27826181, "comment_id": 65030228, "body": "Yeah passing around context would work, but this is a large application we don&#39;t really have much control over and changing the interface to modules would imply updating hundreds of third party modules or creating a new module API, both changes involve far more work than just writing a plugin module using lazy-static."}, {"owner": {"reputation": 139, "user_id": 4326664, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2662d670b04eaa625f0d205c61418557?s=128&d=identicon&r=PG", "display_name": "Worik", "link": "https://stackoverflow.com/users/4326664/worik"}, "edited": false, "score": 1, "creation_date": 1526939254, "post_id": 27826181, "comment_id": 87927594, "body": "Not a good answer. <code>Avoid global state in general</code> but global state is a thing and need representation.  And the code for <code>external static</code> is flawed and will not compile on rustc 1.24.1"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 139, "user_id": 4326664, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2662d670b04eaa625f0d205c61418557?s=128&d=identicon&r=PG", "display_name": "Worik", "link": "https://stackoverflow.com/users/4326664/worik"}, "edited": false, "score": 5, "creation_date": 1526939406, "post_id": 27826181, "comment_id": 87927638, "body": "@Worik would you care to explain why? I discourage people from doing something that is a poor idea in most languages (even the OP agreed that a global was a bad choice for their application). That&#39;s what <b>in general</b> means. I then show two solutions for how to do it anyway. I just tested the <code>lazy_static</code> example in Rust 1.24.1 and it works exactly. There&#39;s no <code>external static</code> anywhere here. Perhaps you need to check things on your end to make sure you&#39;ve understood the answer fully."}, {"owner": {"reputation": 139, "user_id": 4326664, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2662d670b04eaa625f0d205c61418557?s=128&d=identicon&r=PG", "display_name": "Worik", "link": "https://stackoverflow.com/users/4326664/worik"}, "edited": false, "score": 0, "creation_date": 1527028357, "post_id": 27826181, "comment_id": 87968238, "body": "Why what?    Global state applies to things like the environment a system runs in.  This can mean a lot: Physical location, actual time of day are obvious examples that are common.  But domain specific things like credentials or branding colours.  In system programming it is very common to have significant set of data the is global to the system - the direction the car is moving in, the altitude of the aeroplane, the time since the fuse was lit....   As for the example you provided I could not make it work - I am new to Rust.  You left out a edit to Cargo.toml IIRC"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 139, "user_id": 4326664, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2662d670b04eaa625f0d205c61418557?s=128&d=identicon&r=PG", "display_name": "Worik", "link": "https://stackoverflow.com/users/4326664/worik"}, "edited": false, "score": 1, "creation_date": 1527033679, "post_id": 27826181, "comment_id": 87969626, "body": "@Worik if you need help with the basics of how to use a crate, I suggest you re-read <a href=\"https://doc.rust-lang.org/book/second-edition/\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i></a>. The <a href=\"https://doc.rust-lang.org/book/second-edition/ch02-00-guessing-game-tutorial.html\" rel=\"nofollow noreferrer\">chapter on creating a guessing game</a> shows how to add dependencies."}, {"owner": {"reputation": 5090, "user_id": 491770, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/I2mn1.png?s=128&g=1", "display_name": "Justin Thomas", "link": "https://stackoverflow.com/users/491770/justin-thomas"}, "edited": false, "score": 0, "creation_date": 1557450284, "post_id": 27826181, "comment_id": 98778217, "body": "Why not use     static mut SINGLETON: *const SingletonReader = std::ptr::null() ???"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 5090, "user_id": 491770, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/I2mn1.png?s=128&g=1", "display_name": "Justin Thomas", "link": "https://stackoverflow.com/users/491770/justin-thomas"}, "edited": false, "score": 1, "creation_date": 1557450933, "post_id": 27826181, "comment_id": 98778308, "body": "@JustinThomas <i>cribbed from <a href=\"https://github.com/rust-lang/rust/blob/2a8cb678e61e91c160d80794b5fdd723d0d4211c/src/libstd/io/stdio.rs#L217-L247\" rel=\"nofollow noreferrer\">the Rust 1.0 implementation of <code>stdin</code></a></i>. It appears <a href=\"https://github.com/rust-lang/rust/commit/3903ea96f557dc923cf73d3905554083cd921a01\" rel=\"nofollow noreferrer\"><code>ptr::null</code> only became <code>const</code> in 1.4.0</a>."}, {"owner": {"reputation": 5090, "user_id": 491770, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/I2mn1.png?s=128&g=1", "display_name": "Justin Thomas", "link": "https://stackoverflow.com/users/491770/justin-thomas"}, "edited": false, "score": 0, "creation_date": 1557527347, "post_id": 27826181, "comment_id": 98809190, "body": "@Shepmaster Thanks!  Are there any good Rust communities where noobs can ask questions?  Instead of continuing to open terrible Stackoverflow questions :)"}, {"owner": {"reputation": 3067, "user_id": 53991, "user_type": "registered", "accept_rate": 48, "profile_image": "https://www.gravatar.com/avatar/2191b5cfee9c0fb7de571ac6cac45512?s=128&d=identicon&r=PG", "display_name": "perrohunter", "link": "https://stackoverflow.com/users/53991/perrohunter"}, "edited": false, "score": 0, "creation_date": 1560979174, "post_id": 27826181, "comment_id": 99919174, "body": "I liked your <code>Manual, dependency-free implementation</code>, how would you go about writing tests for code that uses this singleton instance? since each test is ran in it&#39;s own thread, and the state is shared it complicates testing right?"}, {"owner": {"reputation": 650, "user_id": 996314, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/4d6f299c3fe907046a23f106f7b56995?s=128&d=identicon&r=PG&f=1", "display_name": "Rokit", "link": "https://stackoverflow.com/users/996314/rokit"}, "edited": false, "score": 0, "creation_date": 1590960644, "post_id": 27826181, "comment_id": 109871973, "body": "@Shepmaster Is it frowned upon to use global variables in a library?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 650, "user_id": 996314, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/4d6f299c3fe907046a23f106f7b56995?s=128&d=identicon&r=PG&f=1", "display_name": "Rokit", "link": "https://stackoverflow.com/users/996314/rokit"}, "edited": false, "score": 1, "creation_date": 1591014622, "post_id": 27826181, "comment_id": 109887570, "body": "@Rokit there&#39;s always exceptions, but yes, I&#39;d say that it&#39;s generally a bad idea to have global mutable variables in a library. Those prevent easily using the library in multiple different concurrent contexts. Immutable global variables are less bad (such as a compiled <code>Regex</code>)."}, {"owner": {"reputation": 743, "user_id": 409461, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/d792b8d5a8caa2e8de80a0bd87bc8f44?s=128&d=identicon&r=PG", "display_name": "decades", "link": "https://stackoverflow.com/users/409461/decades"}, "edited": false, "score": 0, "creation_date": 1603565283, "post_id": 27826181, "comment_id": 114080045, "body": "Wondering about the &quot;non-answer answer&quot;? How could a mutable reference to an early created object be thread-safe?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 743, "user_id": 409461, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/d792b8d5a8caa2e8de80a0bd87bc8f44?s=128&d=identicon&r=PG", "display_name": "decades", "link": "https://stackoverflow.com/users/409461/decades"}, "edited": false, "score": 0, "creation_date": 1603723812, "post_id": 27826181, "comment_id": 114118985, "body": "@decades a mutable reference can be thread-safe, depending on the type of threads (see <a href=\"https://stackoverflow.com/q/32750829/155423\">How can I pass a reference to a stack variable to a thread?</a>). You can also create a <code>Mutex</code> and pass immutable references to it around. You can also create an <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> and clone it and hand the clone to spawned threads. All of those can be passed around as normal variables."}, {"owner": {"reputation": 743, "user_id": 409461, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/d792b8d5a8caa2e8de80a0bd87bc8f44?s=128&d=identicon&r=PG", "display_name": "decades", "link": "https://stackoverflow.com/users/409461/decades"}, "edited": false, "score": 0, "creation_date": 1603813617, "post_id": 27826181, "comment_id": 114152673, "body": "@Shepmaster Yes, thanks. I learned a lot during the past tow days :) Anyway, I still do not fully understand, what is the disadvantage of using with global state compared to passing mutable references to that state around. But don&#39;t bother, maybe I get wiser on my journey through Rust :)"}, {"owner": {"reputation": 448, "user_id": 4584387, "user_type": "registered", "accept_rate": 55, "profile_image": "https://i.stack.imgur.com/gRotu.png?s=128&g=1", "display_name": "tga", "link": "https://stackoverflow.com/users/4584387/tga"}, "edited": false, "score": 0, "creation_date": 1605894435, "post_id": 27826181, "comment_id": 114801986, "body": "Is there anyway to tell rust, I want to use a <code>static mut</code>, but it&#39;ll only be used on the main thread and do no harm? <code>unsafe</code> in this case is fine but I wonder if there&#39;s a safe way to allow me use on main thread, and prevent me from using on another thread"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 448, "user_id": 4584387, "user_type": "registered", "accept_rate": 55, "profile_image": "https://i.stack.imgur.com/gRotu.png?s=128&g=1", "display_name": "tga", "link": "https://stackoverflow.com/users/4584387/tga"}, "edited": false, "score": 0, "creation_date": 1605895062, "post_id": 27826181, "comment_id": 114802247, "body": "@tga you may want <a href=\"https://doc.rust-lang.org/std/macro.thread_local.html\" rel=\"nofollow noreferrer\"><code>thread_local!</code></a> instead. There is no syntax to indicate that a <code>static mut</code> is scoped to a specific thread. The Rust <i>language</i> has no concept of threads, so such syntax wouldn&#39;t make sense to me. The knowledge that you are only ever going to use something on a single thread is outside what can be statically verified. I&#39;d <i>highly</i> recommend just creating the value in <code>main</code> and passing it around."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 255, "last_activity_date": 1617370171, "last_edit_date": 1617370171, "creation_date": 1420655425, "answer_id": 27826181, "question_id": 27791532, "link": "https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton/27826181#27826181", "title": "How do I create a global, mutable singleton?", "body": "<h2>Non-answer answer</h2>\n<p>Avoid global state in general. Instead, construct the object somewhere early (perhaps in <code>main</code>), then pass mutable references to that object into the places that need it. This will usually make your code easier to reason about and doesn't require as much bending over backwards.</p>\n<p>Look hard at yourself in the mirror before deciding that you want global mutable variables. There are rare cases where it's useful, so that's why it's worth knowing how to do.</p>\n<p>Still want to make one...?</p>\n<h3>Tips</h3>\n<p>In the 3 following solutions:</p>\n<ul>\n<li>If you remove the <a href=\"https://doc.rust-lang.org/std/sync/struct.Mutex.html\" rel=\"noreferrer\"><code>Mutex</code></a> then you have a <strong>global singleton without any mutability</strong>.</li>\n<li>You can also use a <a href=\"https://doc.rust-lang.org/std/sync/struct.RwLock.html\" rel=\"noreferrer\"><code>RwLock</code></a> instead of a <code>Mutex</code> to <strong>allow multiple concurrent readers</strong>.</li>\n</ul>\n<h3>Using <code>lazy-static</code></h3>\n<p>The <a href=\"https://crates.io/crates/lazy_static\" rel=\"noreferrer\">lazy-static</a> crate can take away some of the drudgery of manually creating a singleton. Here is a global mutable vector:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>use lazy_static::lazy_static; // 1.4.0\nuse std::sync::Mutex;\n\nlazy_static! {\n    static ref ARRAY: Mutex&lt;Vec&lt;u8&gt;&gt; = Mutex::new(vec![]);\n}\n\nfn do_a_call() {\n    ARRAY.lock().unwrap().push(1);\n}\n\nfn main() {\n    do_a_call();\n    do_a_call();\n    do_a_call();\n\n    println!(&quot;called {}&quot;, ARRAY.lock().unwrap().len());\n}\n</code></pre>\n<h3>Using <code>once_cell</code></h3>\n<p>The <a href=\"https://crates.io/crates/once_cell\" rel=\"noreferrer\">once_cell</a> crate can take away some of the drudgery of manually creating a singleton. Here is a global mutable vector:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>use once_cell::sync::Lazy; // 1.3.1\nuse std::sync::Mutex;\n\nstatic ARRAY: Lazy&lt;Mutex&lt;Vec&lt;u8&gt;&gt;&gt; = Lazy::new(|| Mutex::new(vec![]));\n\nfn do_a_call() {\n    ARRAY.lock().unwrap().push(1);\n}\n\nfn main() {\n    do_a_call();\n    do_a_call();\n    do_a_call();\n\n    println!(&quot;called {}&quot;, ARRAY.lock().unwrap().len());\n}\n</code></pre>\n<h3>Using <code>std::sync::SyncLazy</code></h3>\n<p>The standard library is in <a href=\"https://github.com/rust-lang/rust/issues/74465\" rel=\"noreferrer\">the process</a> of adding <code>once_cell</code>'s functionality, currently called <a href=\"https://doc.rust-lang.org/nightly/std/lazy/struct.SyncLazy.html\" rel=\"noreferrer\"><code>SyncLazy</code></a>:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>#![feature(once_cell)] // 1.53.0-nightly (2021-04-01 d474075a8f28ae9a410e)\nuse std::{lazy::SyncLazy, sync::Mutex};\n\nstatic ARRAY: SyncLazy&lt;Mutex&lt;Vec&lt;u8&gt;&gt;&gt; = SyncLazy::new(|| Mutex::new(vec![]));\n\nfn do_a_call() {\n    ARRAY.lock().unwrap().push(1);\n}\n\nfn main() {\n    do_a_call();\n    do_a_call();\n    do_a_call();\n\n    println!(&quot;called {}&quot;, ARRAY.lock().unwrap().len());\n}\n</code></pre>\n<h3>A special case: atomics</h3>\n<p>If you only need to track an integer value, you can directly use an <a href=\"https://doc.rust-lang.org/std/sync/atomic/\" rel=\"noreferrer\">atomic</a>:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>use std::sync::atomic::{AtomicUsize, Ordering};\n\nstatic CALL_COUNT: AtomicUsize = AtomicUsize::new(0);\n\nfn do_a_call() {\n    CALL_COUNT.fetch_add(1, Ordering::SeqCst);\n}\n\nfn main() {\n    do_a_call();\n    do_a_call();\n    do_a_call();\n\n    println!(&quot;called {}&quot;, CALL_COUNT.load(Ordering::SeqCst));\n}\n</code></pre>\n<h3>Manual, dependency-free implementation</h3>\n<p>This is greatly cribbed from <a href=\"https://github.com/rust-lang/rust/blob/2a8cb678e61e91c160d80794b5fdd723d0d4211c/src/libstd/io/stdio.rs#L217-L247\" rel=\"noreferrer\">the Rust 1.0 implementation of <code>stdin</code></a> with some tweaks for modern Rust. You should also look at the modern implementation of <a href=\"https://github.com/rust-lang/rust/blob/1.42.0/src/libstd/io/lazy.rs\" rel=\"noreferrer\"><code>io::Lazy</code></a>. I've commented inline with what each line does.</p>\n<pre class=\"lang-rust prettyprint-override\"><code>use std::sync::{Arc, Mutex, Once};\nuse std::time::Duration;\nuse std::{mem, thread};\n\n#[derive(Clone)]\nstruct SingletonReader {\n    // Since we will be used in many threads, we need to protect\n    // concurrent access\n    inner: Arc&lt;Mutex&lt;u8&gt;&gt;,\n}\n\nfn singleton() -&gt; SingletonReader {\n    // Initialize it to a null value\n    static mut SINGLETON: *const SingletonReader = 0 as *const SingletonReader;\n    static ONCE: Once = Once::new();\n\n    unsafe {\n        ONCE.call_once(|| {\n            // Make it\n            let singleton = SingletonReader {\n                inner: Arc::new(Mutex::new(0)),\n            };\n\n            // Put it in the heap so it can outlive this call\n            SINGLETON = mem::transmute(Box::new(singleton));\n        });\n\n        // Now we give out a copy of the data that is safe to use concurrently.\n        (*SINGLETON).clone()\n    }\n}\n\nfn main() {\n    // Let's use the singleton in a few threads\n    let threads: Vec&lt;_&gt; = (0..10)\n        .map(|i| {\n            thread::spawn(move || {\n                thread::sleep(Duration::from_millis(i * 10));\n                let s = singleton();\n                let mut data = s.inner.lock().unwrap();\n                *data = i as u8;\n            })\n        })\n        .collect();\n\n    // And let's check the singleton every so often\n    for _ in 0u8..20 {\n        thread::sleep(Duration::from_millis(5));\n\n        let s = singleton();\n        let data = s.inner.lock().unwrap();\n        println!(&quot;It is: {}&quot;, *data);\n    }\n\n    for thread in threads.into_iter() {\n        thread.join().unwrap();\n    }\n}\n</code></pre>\n<p>This prints out:</p>\n<pre class=\"lang-none prettyprint-override\"><code>It is: 0\nIt is: 1\nIt is: 1\nIt is: 2\nIt is: 2\nIt is: 3\nIt is: 3\nIt is: 4\nIt is: 4\nIt is: 5\nIt is: 5\nIt is: 6\nIt is: 6\nIt is: 7\nIt is: 7\nIt is: 8\nIt is: 8\nIt is: 9\nIt is: 9\nIt is: 9\n</code></pre>\n<p>This code compiles with Rust 1.42.0. The real implementations of <code>Stdin</code> use some unstable features to attempt to free the allocated memory, which this code does not.</p>\n<p>Really, you'd probably want to make <code>SingletonReader</code> implement <a href=\"https://doc.rust-lang.org/std/ops/trait.Deref.html\" rel=\"noreferrer\"><code>Deref</code></a> and <a href=\"https://doc.rust-lang.org/std/ops/trait.DerefMut.html\" rel=\"noreferrer\"><code>DerefMut</code></a> so you didn't have to poke into the object and lock it yourself.</p>\n<p>All of this work is what lazy-static or once_cell do for you.</p>\n<h3>The meaning of &quot;global&quot;</h3>\n<p>Please note that you can still use normal Rust scoping and module-level privacy to control access to a <code>static</code> or <code>lazy_static</code> variable. This means that you can declare it in a module or even inside of a function and it won't be accessible outside of that module / function. This is good for controlling access:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>use lazy_static::lazy_static; // 1.2.0\n\nfn only_here() {\n    lazy_static! {\n        static ref NAME: String = String::from(&quot;hello, world!&quot;);\n    }\n    \n    println!(&quot;{}&quot;, &amp;*NAME);\n}\n\nfn not_here() {\n    println!(&quot;{}&quot;, &amp;*NAME);\n}\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>error[E0425]: cannot find value `NAME` in this scope\n  --&gt; src/lib.rs:12:22\n   |\n12 |     println!(&quot;{}&quot;, &amp;*NAME);\n   |                      ^^^^ not found in this scope\n</code></pre>\n<p>However, the variable is still global in that there's one instance of it that exists across the entire program.</p>\n"}, {"tags": [], "owner": {"reputation": 23, "user_id": 8187156, "user_type": "registered", "profile_image": "https://lh5.googleusercontent.com/-TXmvvYI5658/AAAAAAAAAAI/AAAAAAAAAA0/nk3xT41zKxM/photo.jpg?sz=128", "display_name": "unpluggedcoder", "link": "https://stackoverflow.com/users/8187156/unpluggedcoder"}, "is_accepted": false, "score": 1, "last_activity_date": 1595476506, "creation_date": 1595476506, "answer_id": 63046651, "question_id": 27791532, "link": "https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton/63046651#63046651", "title": "How do I create a global, mutable singleton?", "body": "<p>Use <a href=\"https://github.com/koute/memory-profiler/blob/master/preload/src/spin_lock.rs\" rel=\"nofollow noreferrer\">SpinLock</a> for global access.</p>\n<pre class=\"lang-rust prettyprint-override\"><code>#[derive(Default)]\nstruct ThreadRegistry {\n    pub enabled_for_new_threads: bool,\n    threads: Option&lt;HashMap&lt;u32, *const Tls&gt;&gt;,\n}\n\nimpl ThreadRegistry {\n    fn threads(&amp;mut self) -&gt; &amp;mut HashMap&lt;u32, *const Tls&gt; {\n        self.threads.get_or_insert_with(HashMap::new)\n    }\n}\n\nstatic THREAD_REGISTRY: SpinLock&lt;ThreadRegistry&gt; = SpinLock::new(Default::default());\n\nfn func_1() {\n    let thread_registry = THREAD_REGISTRY.lock();  // Immutable access\n    if thread_registry.enabled_for_new_threads {\n    }\n}\n\nfn func_2() {\n    let mut thread_registry = THREAD_REGISTRY.lock();  // Mutable access\n    thread_registry.threads().insert(\n        // ...\n    );\n}\n</code></pre>\n<p>If you want mutable state(NOT Singleton), see <a href=\"https://blog.sentry.io/2018/04/05/you-cant-rust-that\" rel=\"nofollow noreferrer\">What Not to Do in Rust</a> for more descriptions.</p>\n<p>Hope it's helpful.</p>\n"}, {"tags": [], "owner": {"reputation": 101, "user_id": 3425115, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/abc0881c5dc28e2856f52fd0093c5bcd?s=128&d=identicon&r=PG&f=1", "display_name": "Paul Houghton", "link": "https://stackoverflow.com/users/3425115/paul-houghton"}, "is_accepted": false, "score": 3, "last_activity_date": 1607437627, "creation_date": 1607437627, "answer_id": 65200809, "question_id": 27791532, "link": "https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton/65200809#65200809", "title": "How do I create a global, mutable singleton?", "body": "<p>From <a href=\"https://blog.sentry.io/2018/04/05/you-cant-rust-that\" rel=\"nofollow noreferrer\">What Not To Do In Rust</a></p>\n<blockquote>\n<p>To recap: instead of using interior mutability where an object changes\nits internal state, consider using a pattern where you promote new\nstate to be current and current consumers of the old state will\ncontinue to hold on to it by putting an Arc into an RwLock.</p>\n</blockquote>\n<pre><code>use std::sync::{Arc, RwLock};\n\n#[derive(Default)]\nstruct Config {\n    pub debug_mode: bool,\n}\n\nimpl Config {\n    pub fn current() -&gt; Arc&lt;Config&gt; {\n        CURRENT_CONFIG.with(|c| c.read().unwrap().clone())\n    }\n    pub fn make_current(self) {\n        CURRENT_CONFIG.with(|c| *c.write().unwrap() = Arc::new(self))\n    }\n}\n\nthread_local! {\n    static CURRENT_CONFIG: RwLock&lt;Arc&lt;Config&gt;&gt; = RwLock::new(Default::default());\n}\n\nfn main() {\n    Config { debug_mode: true }.make_current();\n    if Config::current().debug_mode {\n        // do something\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 2295, "user_id": 1099089, "user_type": "registered", "accept_rate": 11, "profile_image": "https://www.gravatar.com/avatar/a0bf49f333363ebd26ae2d0df3be9533?s=128&d=identicon&r=PG", "display_name": "stevenkucera", "link": "https://stackoverflow.com/users/1099089/stevenkucera"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 73858, "favorite_count": 69, "answer_count": 3, "score": 183, "last_activity_date": 1617370171, "creation_date": 1420513889, "last_edit_date": 1483977919, "question_id": 27791532, "link": "https://stackoverflow.com/questions/27791532/how-do-i-create-a-global-mutable-singleton", "title": "How do I create a global, mutable singleton?", "body": "<p>What is the best way to create and use a struct with only one instantiation in the system? Yes, this is necessary, it is the OpenGL subsystem, and making multiple copies of this and passing it around everywhere would add confusion, rather than relieve it. </p>\n\n<p>The singleton needs to be as efficient as possible. It doesn't seem possible to store an arbitrary object on the static area, as it contains a <code>Vec</code> with a destructor. The second option is to store an (unsafe) pointer on the static area, pointing to a heap allocated singleton. What is the most convenient and safest way to do this, while keeping syntax terse.</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 1, "creation_date": 1420610026, "post_id": 27790311, "comment_id": 44033584, "body": "related: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0141-lifetime-elision.md#lifetime-elision-in-structs\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/blob/master/text/&hellip;</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 8, "last_activity_date": 1484698351, "last_edit_date": 1484698351, "creation_date": 1420504498, "answer_id": 27790311, "question_id": 27790168, "link": "https://stackoverflow.com/questions/27790168/explicit-lifetime-declarations-in-trait-objects-held-by-structs/27790311#27790311", "title": "Explicit lifetime declarations in trait objects held by structs", "body": "<blockquote>\n  <p>why the lifetime isn't for the object that the trait is a trait on</p>\n</blockquote>\n\n<p>Because the reference to the trait object and the trait object itself might have different lifetimes. Here's an example of a trait that is implemented for a reference:</p>\n\n<pre><code>trait Quack {\n    fn quack(&amp;self) { println!(\"Quack\") }\n}\n\nimpl&lt;'a&gt; Quack for &amp;'a bool {}\n\nstruct MasterQuack&lt;'a&gt; {\n    q: &amp;'a (Quack + 'a),\n}\n\nfn main() {\n    let a = true;\n    // a.quack(); // Nope, not defined\n    (&amp;a).quack();\n\n    // MasterQuack {q: &amp;a}; // Nope, this would be a reference to a boolean, which isn't Quack\n    MasterQuack {q: &amp;&amp;a};\n}\n</code></pre>\n\n<p>One thing to note is that it's perfectly fine to have <code>&amp;'a (Trait + 'b)</code> - that is, a reference to a trait that itself has a / is a reference, and those lifetimes are different. You said as much with</p>\n\n<blockquote>\n  <p>Is there a case where the trait and the underlying object would have different lifetimes?</p>\n</blockquote>\n\n<p>But it's more a case of \"the underlying object has references with different lifetimes\".</p>\n\n<blockquote>\n  <p>why can't Rust just do The Right Thing(tm)</p>\n</blockquote>\n\n<p>As of <a href=\"https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0599-default-object-bound.md\" rel=\"nofollow noreferrer\">RFC 599</a> this now compiles:</p>\n\n<pre><code>struct Bar&lt;'a&gt; {\n    foo: &amp;'a Foo,\n}\n</code></pre>\n"}], "owner": {"reputation": 663, "user_id": 1043636, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/926a7e9d35a01745fc3e1cfeed30349e?s=128&d=identicon&r=PG", "display_name": "Arien Malec", "link": "https://stackoverflow.com/users/1043636/arien-malec"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1349, "favorite_count": 1, "accepted_answer_id": 27790311, "answer_count": 1, "score": 7, "last_activity_date": 1484698351, "creation_date": 1420503446, "last_edit_date": 1495540912, "question_id": 27790168, "link": "https://stackoverflow.com/questions/27790168/explicit-lifetime-declarations-in-trait-objects-held-by-structs", "title": "Explicit lifetime declarations in trait objects held by structs", "body": "<p>In the answer to <a href=\"https://stackoverflow.com/questions/26212397/rust-lang-references-to-traits-in-structs\">this question</a> there's a discussion of how to refer to trait objects held by structs which requires the following syntax:</p>\n\n<pre><code>struct Bar&lt;'a&gt; {\n    foo: &amp;'a (Foo + 'a),\n}\n</code></pre>\n\n<p>This is per <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0438-precedence-of-plus.md\" rel=\"nofollow noreferrer\">RFC 438</a></p>\n\n<p>Could I ask for more explanation of the double lifetime declaration? Levans said:</p>\n\n<blockquote>\n  <p>You have to specify the lifetime two times : once for the lifetime of\n  the reference, and once for the trait object itself, because traits\n  can be implemented for references, and if the underlying object is a\n  reference, you must specify its lifetime as well.</p>\n</blockquote>\n\n<p>I understand the notion of a lifetime for the reference in the struct. But I don't understand why the lifetime isn't for the object that the trait is a trait on. Put another way, I don't know what it means to hold a reference for a trait without holding a reference to the underlying thing that it's a trait for.</p>\n\n<p>Is there a case where the trait and the underlying object would have different lifetimes? What would it mean to hold onto a reference to a trait without holding on to the underlying thing the trait is on?</p>\n\n<p>Asking yet another way, why can't Rust just do The Right Thing(tm) with:</p>\n\n<pre><code>struct Bar&lt;'a&gt; {\n    foo: &amp;'a Foo,\n}\n</code></pre>\n\n<p>where The Right Thing(tm) would be to interpret that as equivalent to the declaration above?</p>\n\n<p>Sorry to bombard with questions, but I felt like I was doing something pretty basic (use a trait as a generic facet), and I had to go down the rabbit hole pretty deep, and I'd like to understand why the rabbit hole is that deep.</p>\n\n<p>The error message: <code>error: explicit lifetime bound required</code> was decidedly unhelpful, because there is a lifetime bound already.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 9, "last_activity_date": 1432428913, "last_edit_date": 1432428913, "creation_date": 1420499746, "answer_id": 27789564, "question_id": 27789346, "link": "https://stackoverflow.com/questions/27789346/why-does-calling-a-method-on-a-mutable-reference-involve-borrowing/27789564#27789564", "title": "Why does calling a method on a mutable reference involve &quot;borrowing&quot;?", "body": "<blockquote>\n  <p>I'm just calling a method on a mutable reference, why would that line involve borrowing?</p>\n</blockquote>\n\n<p>When you call a method on an object that's going to mutate the object, you can't have <em>any other references</em> to that object outstanding. If you did, your mutation could invalidate those references and leave your program in an inconsistent state. For example, say that you had gotten a value out of your hashmap and then added a new value. Adding the new value hits a magic limit and forces memory to be reallocated, your value now points off to nowhere! When you use that value... bang goes the program!</p>\n\n<p>In this case, it looks like you want to do the relatively common \"append or insert if missing\" operation. You will want to use <a href=\"http://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.entry\" rel=\"nofollow\"><code>entry</code></a> for that:</p>\n\n<pre><code>use std::collections::BTreeMap;\n\nfn main() {\n    let mut map = BTreeMap::new();\n\n    {\n        let nicknames = map.entry(\"joe\").or_insert(Vec::new());\n        nicknames.push(\"shmoe\");\n\n        // Using scoping to indicate that we are done with borrowing `nicknames`\n        // If we didn't, then we couldn't borrow map as\n        // immutable because we could still change it via `nicknames`\n    }\n\n    println!(\"{:?}\", map)\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 113292, "user_id": 4376, "user_type": "registered", "accept_rate": 64, "profile_image": "https://www.gravatar.com/avatar/b9c927e051202fc198e70659d9827d2f?s=128&d=identicon&r=PG", "display_name": "Nathan Long", "link": "https://stackoverflow.com/users/4376/nathan-long"}, "is_accepted": false, "score": 1, "last_activity_date": 1432428259, "creation_date": 1432428259, "answer_id": 30419008, "question_id": 27789346, "link": "https://stackoverflow.com/questions/27789346/why-does-calling-a-method-on-a-mutable-reference-involve-borrowing/30419008#30419008", "title": "Why does calling a method on a mutable reference involve &quot;borrowing&quot;?", "body": "<h2>Because you're calling a method that borrows as mutable</h2>\n\n<p>I had a similar question yesterday about Hash, until I noticed something in the docs. <a href=\"https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.insert\" rel=\"nofollow\">The docs for BTreeMap</a> show a method signature for <code>insert</code> starting with <code>fn insert(&amp;mut self..</code></p>\n\n<p>So when you call <code>.insert</code>, you're implicitly asking that function to borrow the BTreeMap as mutable.</p>\n"}], "owner": {"reputation": 165, "user_id": 3312029, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/2400585c4ddcca6d78d3f2aec9d1a94b?s=128&d=identicon&r=PG", "display_name": "Matt Chaput", "link": "https://stackoverflow.com/users/3312029/matt-chaput"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1712, "favorite_count": 0, "accepted_answer_id": 27789564, "answer_count": 2, "score": 4, "last_activity_date": 1501888266, "creation_date": 1420498604, "last_edit_date": 1501888266, "question_id": 27789346, "link": "https://stackoverflow.com/questions/27789346/why-does-calling-a-method-on-a-mutable-reference-involve-borrowing", "title": "Why does calling a method on a mutable reference involve &quot;borrowing&quot;?", "body": "<p>I'm learning Rust and I'm trying to cargo-cult this code into compiling:</p>\n\n<pre><code>use std::vec::Vec;\nuse std::collections::BTreeMap;\n\nstruct Occ {\n    docnum: u64,\n    weight: f32,\n}\n\nstruct PostWriter&lt;'a&gt; {\n    bytes: Vec&lt;u8&gt;,\n    occurrences: BTreeMap&lt;&amp;'a [u8], Vec&lt;Occ&gt;&gt;,\n}\n\nimpl&lt;'a&gt; PostWriter&lt;'a&gt; {\n    fn new() -&gt; PostWriter&lt;'a&gt; {\n        PostWriter {\n            bytes: Vec::new(),\n            occurrences: BTreeMap::new(),\n        }\n    }\n\n    fn add_occurrence(&amp;'a mut self, term: &amp;[u8], occ: Occ) {\n        let occurrences = &amp;mut self.occurrences;\n        match occurrences.get_mut(term) {\n            Some(x) =&gt; x.push(occ),\n            None =&gt; {\n                // Add the term bytes to the big vector of all terms\n                let termstart = self.bytes.len();\n                self.bytes.extend(term);\n                // Create a new occurrences vector\n                let occs = vec![occ];\n                // Take the appended term as a slice to use as a key\n                // ERROR: cannot borrow `*occurrences` as mutable more than once at a time\n                occurrences.insert(&amp;self.bytes[termstart..], occs);\n            }\n        }\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>I get an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0499]: cannot borrow `*occurrences` as mutable more than once at a time\n  --&gt; src/main.rs:34:17\n   |\n24 |         match occurrences.get_mut(term) {\n   |               ----------- first mutable borrow occurs here\n...\n34 |                 occurrences.insert(&amp;self.bytes[termstart..], occs);\n   |                 ^^^^^^^^^^^ second mutable borrow occurs here\n35 |             }\n36 |         }\n   |         - first borrow ends here\n</code></pre>\n\n<p>I don't understand... I'm just calling a method on a mutable reference, why would that line involve borrowing?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420491045, "post_id": 27787516, "comment_id": 43985194, "body": "What ultimately owns your bytestrings?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420496844, "post_id": 27787516, "comment_id": 43987970, "body": "Could you explain more why &quot;using vectors seems wasteful&quot;?"}, {"owner": {"reputation": 165, "user_id": 3312029, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/2400585c4ddcca6d78d3f2aec9d1a94b?s=128&d=identicon&r=PG", "display_name": "Matt Chaput", "link": "https://stackoverflow.com/users/3312029/matt-chaput"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420498875, "post_id": 27787516, "comment_id": 43988797, "body": "I was just thinking of over-allocation and whatever bookkeeping overhead a vector has. But I suppose I could shrink the vectors to fit before putting them in map."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420500009, "post_id": 27787516, "comment_id": 43989168, "body": "<code>Vec</code> by itself is <a href=\"https://github.com/rust-lang/rust/blob/f11f3e7baeba3f5acf08cc6fbfee559c00e9f96e/src/libcollections/vec.rs#L136-L140\" rel=\"nofollow noreferrer\">pretty bare-bones</a>, just a pointer, a length, and a capacity. Shrinking it could be useful, as could putting it all in one place and just using slices (which are just a pointer and a length). What&#39;s the ballpark number of keys and how long are they on average? Is it worth worrying about this level of minutia (a.k.a. have you benchmarked)? ^_^"}], "answers": [{"comments": [{"owner": {"reputation": 165, "user_id": 3312029, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/2400585c4ddcca6d78d3f2aec9d1a94b?s=128&d=identicon&r=PG", "display_name": "Matt Chaput", "link": "https://stackoverflow.com/users/3312029/matt-chaput"}, "edited": false, "score": 0, "creation_date": 1420496432, "post_id": 27787726, "comment_id": 43987796, "body": "I was hoping I could somehow have the BTreeMap own the keys, since that&#39;s the only place they need to be. If that&#39;s not possible, I&#39;ll have the object holding the BTreeMap also hold a big Vec&lt;u8&gt; of all the bytes concatenated and use slices of it as the keys."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 165, "user_id": 3312029, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/2400585c4ddcca6d78d3f2aec9d1a94b?s=128&d=identicon&r=PG", "display_name": "Matt Chaput", "link": "https://stackoverflow.com/users/3312029/matt-chaput"}, "edited": false, "score": 0, "creation_date": 1420497015, "post_id": 27787726, "comment_id": 43988051, "body": "You cannot express sibling lifetimes, so you won&#39;t be able to have one object that both owns the bytestrings and has references to those bytestrings. It is not possible to ensure that the references will be valid for the appropriate length."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1420491236, "creation_date": 1420491236, "answer_id": 27787726, "question_id": 27787516, "link": "https://stackoverflow.com/questions/27787516/how-do-you-make-a-btreemap-with-byte-array-keys/27787726#27787726", "title": "How do you make a BTreeMap with byte array keys?", "body": "<pre><code>use std::collections::BTreeMap;\n\nfn main() {\n    let key1 = b\"1234\";\n    let key2 = b\"5678\";\n\n    let mut map = BTreeMap::new();\n\n    map.insert(key1, true);\n    map.insert(key2, false);\n\n    println!(\"{}\", map);\n}\n</code></pre>\n\n<p>As you saw, <code>[u8]</code> is a type that doesn't have any size, which means you can't actually <em>store</em> one of them somewhere. Instead, you will want to store a \"slice of u8s\", written <code>&amp;[u8]</code>, as the key. In this example, I just created some throw-away slices, but yours will likely come from some owning object.</p>\n"}], "owner": {"reputation": 165, "user_id": 3312029, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/2400585c4ddcca6d78d3f2aec9d1a94b?s=128&d=identicon&r=PG", "display_name": "Matt Chaput", "link": "https://stackoverflow.com/users/3312029/matt-chaput"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 647, "favorite_count": 0, "answer_count": 1, "score": 3, "last_activity_date": 1420516205, "creation_date": 1420490368, "last_edit_date": 1420516205, "question_id": 27787516, "link": "https://stackoverflow.com/questions/27787516/how-do-you-make-a-btreemap-with-byte-array-keys", "title": "How do you make a BTreeMap with byte array keys?", "body": "<p>Just starting to (try to) learn Rust. How do I use \"bytestrings\" as keys in a std::collections::BTreeMap?</p>\n\n<p>It seems like I can't use [u8] because the type requires a fixed size.</p>\n\n<p>Using vectors, e.g.</p>\n\n<pre><code>BTreeMap&lt;Vec&lt;u8&gt;, MyType&gt;\n</code></pre>\n\n<p>...seems wasteful.</p>\n\n<p>I could try concatting all the bytestrings into one Vec and use slices of that as the BTree keys, but is there a better way to do this?</p>\n"}, {"tags": ["rust", "rust-cargo"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420487876, "post_id": 27786355, "comment_id": 43983684, "body": "It&#39;s probably just fallout from the changes pre 1.0 alpha / beta / release. What version of Rust are you running? Ideally, you will be running the nightly, but this version also has lots of changes happening."}, {"owner": {"reputation": 11, "user_id": 2060034, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cabc146aceaaa244dc04e70c6a0b3087?s=128&d=identicon&r=PG", "display_name": "Pablo Bngs", "link": "https://stackoverflow.com/users/2060034/pablo-bngs"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420490206, "post_id": 27786355, "comment_id": 43984805, "body": "Sorry, I forgot to attach the Rust version, it is rustc 0.13.0-nightly (636663172 2014-12-28 16:21:58 +0000)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420510391, "post_id": 27786355, "comment_id": 43991935, "body": "I have <code>rustc 0.13.0-dev (5773bdeff 2015-01-04 21:36:41 +0000)</code>. I created a new Cargo project, added the same dependency and was able to build. I think you will just want to update. Wild changing times!"}, {"owner": {"reputation": 11, "user_id": 2060034, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cabc146aceaaa244dc04e70c6a0b3087?s=128&d=identicon&r=PG", "display_name": "Pablo Bngs", "link": "https://stackoverflow.com/users/2060034/pablo-bngs"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1420553055, "post_id": 27786355, "comment_id": 44009022, "body": "I updated Rust and those errors are gone.  But I still can not build due to a new different error. I&#39;ll take it easy and keep reading the documentation. Thank you very much."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420557133, "post_id": 27786355, "comment_id": 44011615, "body": "Just <a href=\"http://blog.rust-lang.org/2014/12/12/1.0-Timeline.html\" rel=\"nofollow noreferrer\">wait until Friday, 2015-01-09</a>. Then things should settle a bit."}], "owner": {"reputation": 11, "user_id": 2060034, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cabc146aceaaa244dc04e70c6a0b3087?s=128&d=identicon&r=PG", "display_name": "Pablo Bngs", "link": "https://stackoverflow.com/users/2060034/pablo-bngs"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 1553, "favorite_count": 0, "answer_count": 0, "score": 1, "last_activity_date": 1420888257, "creation_date": 1420485681, "last_edit_date": 1420888257, "question_id": 27786355, "link": "https://stackoverflow.com/questions/27786355/could-not-compile-openssl-sys", "title": "Could not compile openssl-sys", "body": "<p>I added openssl dependency to Cargo.toml.</p>\n\n<pre><code>[dependencies.openssl]\nopenssl = \"0.2.12\"\n</code></pre>\n\n<p>But when I try to build and execute, it cannot compile that crate due to:</p>\n\n<pre><code>type std::sync::mutex::StaticMutexGuard does not implement any method in scope named unwrap\n</code></pre>\n\n<p>Full output:</p>\n\n<pre><code>pablo@boreth:~/pruebas/rust/hello_world$ cargo run --verbose\n       Fresh pkg-config v0.1.3\n   Compiling openssl-sys v0.2.12\n     Running `rustc /home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs --crate-name openssl-sys --crate-type lib -g -C metadata=e45df04b75965aa1 -C extra-filename=-e45df04b75965aa1 --out-dir /home/pablo/pruebas/rust/hello_world/target/deps --emit=dep-info,link -L /home/pablo/pruebas/rust/hello_world/target/deps -L /home/pablo/pruebas/rust/hello_world/target/deps -Awarnings -L native=/usr/lib/x86_64-linux-gnu -l ssl -l crypto`\n/home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs:203:54: 203:62 error: type `std::sync::mutex::StaticMutexGuard` does not implement any method in scope named `unwrap`\n/home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs:203             (*GUARDS)[n as uint] = Some(mutex.lock().unwrap());\n                                                                                                                                                   ^~~~~~~~\n/home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs:214:14: 226:11 error: type `std::sync::once::Once` does not implement any method in scope named `call_once`\n/home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs:214         INIT.call_once(|| {\n/home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs:215             SSL_library_init();\n/home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs:216             SSL_load_error_strings();\n/home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs:217\n/home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs:218             let num_locks = CRYPTO_num_locks();\n/home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs:219             let mutexes = box range(0, num_locks).map(|_| MUTEX_INIT).collect::&lt;Vec&lt;_&gt;&gt;();\n                                                                                              ...\nerror: aborting due to 2 previous errors\nCould not compile `openssl-sys`.\n\nCaused by:\n  Process didn't exit successfully: `rustc /home/pablo/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.2.12/src/lib.rs --crate-name openssl-sys --crate-type lib -g -C metadata=e45df04b75965aa1 -C extra-filename=-e45df04b75965aa1 --out-dir /home/pablo/pruebas/rust/hello_world/target/deps --emit=dep-info,link -L /home/pablo/pruebas/rust/hello_world/target/deps -L /home/pablo/pruebas/rust/hello_world/target/deps -Awarnings -L native=/usr/lib/x86_64-linux-gnu -l ssl -l crypto` (status=101)\n</code></pre>\n\n<p>I'm using Ubuntu Ubuntu 14.04.1 LTS (Trusty Tahr), and I've installed libssl-dev.</p>\n\n<pre><code>pablo@boreth:~$ uname -a\nLinux boreth 3.13.0-43-generic #72-Ubuntu SMP Mon Dec 8 19:35:06 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux\npablo@boreth:~$ dpkg -l libssl-dev\nDeseado=Desconocido/Instalar/Eliminar/Purgar/Retener\n| Estado=No/Instalado/Config-files/Desempaquetado/Medio-conf/Medio-inst/espera-disparo/pendiente-disparo\n|/ Err?=(ninguno)/Requiere-reinst (Estado,Err: may\u00fasc.=malo)\n||/ Nombre                                     Versi\u00f3n                    Arquitectura               Descripci\u00f3n\n+++-==========================================-==========================-==========================-=========================================================================================\nii  libssl-dev:amd64                           1.0.1f-1ubuntu2.7          amd64                      Secure Sockets Layer toolkit - development files\n</code></pre>\n\n<p>rustc and cargo versions:</p>\n\n<pre><code>$ rustc -V\nrustc 0.13.0-nightly (636663172 2014-12-28 16:21:58 +0000)\n$ cargo -V\ncargo 0.0.1-pre-nightly (26ac282 2014-12-30 00:13:39 +0000)\n</code></pre>\n\n<p>Does anyone know a solution or I should wait for an update?</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1420484025, "post_id": 27785671, "comment_id": 43981857, "body": "While I suppose it&#39;s possible that Rust could choose to elide the lifetimes in a struct definition, it does not do that now. You will only see the term <code>lifetime elision</code> used for functions / methods."}], "answers": [{"comments": [{"owner": {"reputation": 5885, "user_id": 1036017, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d979bbbad7e4d9533f5d592dda0a150d?s=128&d=identicon&r=PG", "display_name": "RajV", "link": "https://stackoverflow.com/users/1036017/rajv"}, "edited": false, "score": 4, "creation_date": 1420491795, "post_id": 27785916, "comment_id": 43985517, "body": "It&#39;s not clear from this answer why lifetime is <i>necessary</i> when declaring a struct."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 5885, "user_id": 1036017, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d979bbbad7e4d9533f5d592dda0a150d?s=128&d=identicon&r=PG", "display_name": "RajV", "link": "https://stackoverflow.com/users/1036017/rajv"}, "edited": false, "score": 0, "creation_date": 1420493218, "post_id": 27785916, "comment_id": 43986288, "body": "Did you catch the comment I added to your question? If I am understanding you, then the answer is &quot;because the compiler requires it&quot;. If you have references in your structure, you have to specify what the lifetime(s) of those references are. There is no lifetime elision for struct declarations, although I suppose that the compiler could automatically put <code>&#39;a</code> for every lifetime. To get that, you&#39;d have to make a feature request to Rust itself."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 5885, "user_id": 1036017, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d979bbbad7e4d9533f5d592dda0a150d?s=128&d=identicon&r=PG", "display_name": "RajV", "link": "https://stackoverflow.com/users/1036017/rajv"}, "edited": false, "score": 1, "creation_date": 1420493254, "post_id": 27785916, "comment_id": 43986312, "body": "@RajV, because there is no obvious way to go without them. Non-static references inside a struct <i>necessarily</i> means that there should be at least one lifetime parameter, but there can be more, and it would mean a different thing."}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 0, "creation_date": 1420610122, "post_id": 27785916, "comment_id": 44033607, "body": "relevant: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0141-lifetime-elision.md#lifetime-elision-in-structs\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/blob/master/text/&hellip;</a>"}, {"owner": {"reputation": 912, "user_id": 4051639, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3f8dad1151cf8fac00430e7c3561dae8?s=128&d=identicon&r=PG", "display_name": "Garcia Hurtado", "link": "https://stackoverflow.com/users/4051639/garcia-hurtado"}, "edited": false, "score": 1, "creation_date": 1423777112, "post_id": 27785916, "comment_id": 45298229, "body": "@Shepmaster, &quot;There is no lifetime elision for struct declarations, although I suppose that the compiler could automatically put &#39;a for every lifetime&#39;&quot;. The question is precisely that: <b>why</b> doesn&#39;t the compiler do lifetime elision for structs? It seems in the spirit of Rust to do so, and it seems to me there would be a good reason for this. I don&#39;t think your answer addresses that question at all, it only provides examples for explicit lifetime declarations, so I&#39;m very surprised it was accepted."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 912, "user_id": 4051639, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3f8dad1151cf8fac00430e7c3561dae8?s=128&d=identicon&r=PG", "display_name": "Garcia Hurtado", "link": "https://stackoverflow.com/users/4051639/garcia-hurtado"}, "edited": false, "score": 0, "creation_date": 1423778669, "post_id": 27785916, "comment_id": 45298999, "body": "@GarciaHurtado I&#39;ve added a bit more to my answer, but ultimately the reason is &quot;because it doesn&#39;t yet&quot;, which I know isn&#39;t a satisfying reason. I am unaware of any technical reasons that prevent it though."}, {"owner": {"reputation": 912, "user_id": 4051639, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3f8dad1151cf8fac00430e7c3561dae8?s=128&d=identicon&r=PG", "display_name": "Garcia Hurtado", "link": "https://stackoverflow.com/users/4051639/garcia-hurtado"}, "edited": false, "score": 0, "creation_date": 1423793609, "post_id": 27785916, "comment_id": 45303718, "body": "@Shepmaster, thank you! the additional information you added certainly does help clarify the current state of affairs."}, {"owner": {"reputation": 5656, "user_id": 692168, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/31b911c42785d51ca73b172d3a38b06f?s=128&d=identicon&r=PG", "display_name": "AxiomaticNexus", "link": "https://stackoverflow.com/users/692168/axiomaticnexus"}, "edited": false, "score": 0, "creation_date": 1555962389, "post_id": 27785916, "comment_id": 98269265, "body": "&quot;This says that start and end can have different lifetimes, so long as the lifetime of end outlives the lifetime of start&quot; - I still do not understand why I, as a the author of the struct, should ever impose such a constraint on the consumers of my API. The only constraint I care about, is that the references remain valid for at least as long as the instance of the struct remains valid, which should be implicit and accomplished without explicit lifetime notation. Why would I ever want any other lifetime constraint beyond that?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 5656, "user_id": 692168, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/31b911c42785d51ca73b172d3a38b06f?s=128&d=identicon&r=PG", "display_name": "AxiomaticNexus", "link": "https://stackoverflow.com/users/692168/axiomaticnexus"}, "edited": false, "score": 0, "creation_date": 1555966125, "post_id": 27785916, "comment_id": 98270617, "body": "@AxiomaticNexus you seem to be asking <a href=\"https://stackoverflow.com/questions/29861388/when-is-it-useful-to-define-multiple-lifetimes-in-a-struct\">why have multiple lifetimes in one struct</a>. In other cases, you can just use a generic type which will then have a lifetime within it and you don\u2019t need any explicit lifetimes"}, {"owner": {"reputation": 5656, "user_id": 692168, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/31b911c42785d51ca73b172d3a38b06f?s=128&d=identicon&r=PG", "display_name": "AxiomaticNexus", "link": "https://stackoverflow.com/users/692168/axiomaticnexus"}, "edited": false, "score": 0, "creation_date": 1556025340, "post_id": 27785916, "comment_id": 98291028, "body": "@Shepmaster That answer you linked makes absolute sense! Finally got this after so long, but now another question arises. When I&#39;m declaring my struct, what should I base my decision on what the lifetime of the references should be? If my struct has implementation methods, then I can base my decision on those methods&#39; requirements; otherwise, should I make each reference have its own lifetime, since that gives the most flexibility to the consumer of he struct? Or should I have all references share the same lifetime?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 5656, "user_id": 692168, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/31b911c42785d51ca73b172d3a38b06f?s=128&d=identicon&r=PG", "display_name": "AxiomaticNexus", "link": "https://stackoverflow.com/users/692168/axiomaticnexus"}, "edited": false, "score": 0, "creation_date": 1556028844, "post_id": 27785916, "comment_id": 98293210, "body": "@AxiomaticNexus now it sounds like you are asking <a href=\"https://stackoverflow.com/questions/44709632/\">why ever use one lifetime</a>?"}, {"owner": {"reputation": 5656, "user_id": 692168, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/31b911c42785d51ca73b172d3a38b06f?s=128&d=identicon&r=PG", "display_name": "AxiomaticNexus", "link": "https://stackoverflow.com/users/692168/axiomaticnexus"}, "edited": false, "score": 0, "creation_date": 1556029621, "post_id": 27785916, "comment_id": 98293684, "body": "@Shepmaster So... the answer is: Yes, generally speaking, err for multiple lifetimes unless the implementation block of the struct requires anything stricter. Did I get that right?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 5656, "user_id": 692168, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/31b911c42785d51ca73b172d3a38b06f?s=128&d=identicon&r=PG", "display_name": "AxiomaticNexus", "link": "https://stackoverflow.com/users/692168/axiomaticnexus"}, "edited": false, "score": 1, "creation_date": 1556039490, "post_id": 27785916, "comment_id": 98299259, "body": "@AxiomaticNexus I\u2019d personally stick to one lifetime until something forces me to use multiple. That might change if I was writing a public API that I\u2019d be hesitant to alter after releasing."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 15, "last_activity_date": 1555965633, "last_edit_date": 1555965633, "creation_date": 1420483864, "answer_id": 27785916, "question_id": 27785671, "link": "https://stackoverflow.com/questions/27785671/why-can-the-lifetimes-not-be-elided-in-a-struct-definition/27785916#27785916", "title": "Why can the lifetimes not be elided in a struct definition?", "body": "<p>When you define a struct, you aren't making a relation between the lifetime of the struct and the lifetime of the fields. As you point out, the references in the fields <em>have</em> to live longer than the struct.</p>\n\n<p>Instead, what you are doing is providing a \"generic lifetime\" that will be specialized when you create the struct. This is similar to having a struct with a type parameter:</p>\n\n<pre><code>struct Foo&lt;T&gt;\n    foo: T,\n}\n</code></pre>\n\n<p>When you construct the struct, appropriate lifetimes (or types) will be inserted by the compiler, and then it checks that everything still works out.</p>\n\n<p>The other thing is that you can specify the lifetimes with respect <em>to each other</em>:</p>\n\n<pre><code>struct Line&lt;'a, 'b: 'a&gt; {\n    start: &amp;'a Point,\n    end: &amp;'b Point,\n}\n</code></pre>\n\n<p>This says that <code>start</code> and <code>end</code> can have <em>different</em> lifetimes, so long as the lifetime of <code>end</code> <strong>outlives</strong> the lifetime of <code>start</code>.</p>\n\n<blockquote>\n  <p>why doesn't the compiler do lifetime elision for structs? It seems in the <strong>spirit of Rust</strong> to do so</p>\n</blockquote>\n\n<p>(emphasis mine)</p>\n\n<p>I actually believe that Rust tends towards <em>explicitness</em>, especially when it comes to defining top-level items (like functions, structs).</p>\n\n<p>The rules for lifetime elision for functions have a pretty small scope and were <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0141-lifetime-elision.md#the-impact\" rel=\"noreferrer\">empirically found in RFC 141</a> to have a high success rate (87%). This was a very good ergonomic return on investment.</p>\n\n<p>Perhaps at some point, similar elision will occur for structs, but it hasn't been a big enough problem <em>yet</em>. If you feel strongly about this, then I'd highly recommend asking for consensus on the <a href=\"http://users.rust-lang.org/\" rel=\"noreferrer\">user forum</a>, progressing to the developer forum, then ultimately making an RFC.</p>\n\n<p><a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2093-infer-outlives.md\" rel=\"noreferrer\">RFC 2093</a> adds a small amount of inference. Before it is implemented, you have to express that a generic type as a reference needs to outlive the reference:</p>\n\n<pre><code>struct Foo&lt;'a, T: 'a&gt; {\n    start: &amp;'a T,\n}\n</code></pre>\n\n<p>There's no case in which you <em>wouldn't</em> want this bound, so after the RFC is implemented, you can just say:</p>\n\n<pre><code>struct Foo&lt;'a, T&gt; {\n    start: &amp;'a T,\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 2, "last_activity_date": 1420773901, "creation_date": 1420773901, "answer_id": 27853356, "question_id": 27785671, "link": "https://stackoverflow.com/questions/27785671/why-can-the-lifetimes-not-be-elided-in-a-struct-definition/27853356#27853356", "title": "Why can the lifetimes not be elided in a struct definition?", "body": "<p>Suppose we have a constructor for <code>Line</code>:</p>\n\n<pre><code>impl&lt;'a&gt; Line&lt;'a&gt; {\n    fn new(start: &amp;'a Point, end: &amp;'a Point) -&gt; Line&lt;'a&gt; { // '\n        Line {\n            start: start,\n            end: end,\n        }\n    }\n}\n</code></pre>\n\n<p><code>new</code> returns a <code>Line&lt;'a&gt;</code>. To be able to parameterize a type with a lifetime (as we do here with <code>Line&lt;'a&gt;</code>), this type must define lifetime parameters! Although the compiler <em>could</em> automatically define lifetime parameters when necessary, it's much easier to figure out that a type has lifetime parameters (or not) by just looking at its definition in the source code.</p>\n\n<p>Lifetime parameters on structs and enums play an important role in the borrow checker. They let the compiler know that a struct retains borrows to some values. The compiler can then return errors when you try to mutate a value that has active borrows.</p>\n\n<pre><code>fn main() {\n    let mut start = Point { x: 2, y: 4 };\n    let end = Point { x: 7, y: 10 };\n    let line = Line::new(&amp;start, &amp;end);\n    start.x = 3; // error: cannot assign to `start.x` because it is borrowed\n}\n</code></pre>\n"}], "owner": {"reputation": 5885, "user_id": 1036017, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/d979bbbad7e4d9533f5d592dda0a150d?s=128&d=identicon&r=PG", "display_name": "RajV", "link": "https://stackoverflow.com/users/1036017/rajv"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2672, "favorite_count": 2, "accepted_answer_id": 27785916, "answer_count": 2, "score": 20, "last_activity_date": 1555965633, "creation_date": 1420482711, "last_edit_date": 1530109611, "question_id": 27785671, "link": "https://stackoverflow.com/questions/27785671/why-can-the-lifetimes-not-be-elided-in-a-struct-definition", "title": "Why can the lifetimes not be elided in a struct definition?", "body": "<pre><code>struct Point {\n    x: u32,\n    y: u32,\n}\n\nstruct Line&lt;'a&gt; {\n    start: &amp;'a Point,\n    end: &amp;'a Point,\n}\n</code></pre>\n\n<p>Here, the only possible option for the <code>start</code> and <code>end</code> fields is to have a lifetime the same or longer than the <code>Line</code> variable that contains them. I can't even imagine how one will go about using a lifetime specifier to say that the fields have a shorter lifespan. </p>\n\n<p>Why do I have to explicitly specify a lifetime here? Is elision not possible in this situation and if so why not? </p>\n"}, {"tags": ["string", "rust", "conditional-statements", "user-input"], "answers": [{"comments": [{"owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 0, "creation_date": 1420456216, "post_id": 27773539, "comment_id": 43966652, "body": "What about Windows, should it be &quot;\\r\\n&quot;?"}, {"owner": {"reputation": 185, "user_id": 4414317, "user_type": "registered", "accept_rate": 75, "profile_image": "https://lh3.googleusercontent.com/-z7zBoPJUaLQ/AAAAAAAAAAI/AAAAAAAAABI/lhiohDzAXCA/photo.jpg?sz=128", "display_name": "Joe", "link": "https://stackoverflow.com/users/4414317/joe"}, "edited": false, "score": 0, "creation_date": 1420458837, "post_id": 27773539, "comment_id": 43967903, "body": "It tells me bool` is not implemented for the type `&amp;str when I add that"}, {"owner": {"reputation": 185, "user_id": 4414317, "user_type": "registered", "accept_rate": 75, "profile_image": "https://lh3.googleusercontent.com/-z7zBoPJUaLQ/AAAAAAAAAAI/AAAAAAAAABI/lhiohDzAXCA/photo.jpg?sz=128", "display_name": "Joe", "link": "https://stackoverflow.com/users/4414317/joe"}, "edited": false, "score": 0, "creation_date": 1420459672, "post_id": 27773539, "comment_id": 43968298, "body": "I realized it has to go in the if statement after I looked at docs. Thanks!"}, {"owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "reply_to_user": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 0, "creation_date": 1420468429, "post_id": 27773539, "comment_id": 43973185, "body": "@ArtemGr That sounds right, but I don&#39;t know enough about Windows to be sure."}, {"owner": {"reputation": 6718, "user_id": 2455707, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/768bc63471394edee20bcd4131186118?s=128&d=identicon&r=PG", "display_name": "reem", "link": "https://stackoverflow.com/users/2455707/reem"}, "edited": false, "score": 2, "creation_date": 1420477089, "post_id": 27773539, "comment_id": 43978324, "body": "You should not need <code>as_slice</code>, since <code>String</code> implements <code>Deref&lt;Target=str&gt;</code>. <code>let line = io::stdin().read_line(); let trimmed = line.trim_right_chars(..);</code> should work."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1420496079, "post_id": 27773539, "comment_id": 43987645, "body": "And I&#39;d suggest using just <a href=\"http://doc.rust-lang.org/std/str/trait.StrExt.html#tymethod.trim\" rel=\"nofollow noreferrer\"><code>trim</code></a> or <a href=\"http://doc.rust-lang.org/std/str/trait.StrExt.html#tymethod.trim_right\" rel=\"nofollow noreferrer\"><code>trim_right</code></a> instead of trying to worry about cross-platform newlines :-)"}, {"owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420566948, "post_id": 27773539, "comment_id": 44017654, "body": "@Shepmaster <code>trim_right</code> would also eat other trailing whitespace, which might not be a good thing."}], "tags": [], "owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "is_accepted": true, "score": 10, "last_activity_date": 1420569500, "last_edit_date": 1420569500, "creation_date": 1420433105, "answer_id": 27773539, "question_id": 27773313, "link": "https://stackoverflow.com/questions/27773313/why-does-my-string-not-match-when-reading-user-input-from-stdin/27773539#27773539", "title": "Why does my string not match when reading user input from stdin?", "body": "<p><code>read_line</code> includes the terminating newline in the returned string. Add <code>.trim_right_matches(\"\\r\\n\")</code> to your definition of <code>correct_name</code> to remove the terminating newline.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 15, "last_activity_date": 1569065864, "last_edit_date": 1592644375, "creation_date": 1473972670, "answer_id": 39520154, "question_id": 27773313, "link": "https://stackoverflow.com/questions/27773313/why-does-my-string-not-match-when-reading-user-input-from-stdin/39520154#39520154", "title": "Why does my string not match when reading user input from stdin?", "body": "<p>Instead of <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.trim_right_matches\" rel=\"noreferrer\"><code>trim_right_matches</code></a>, I'd recommend using <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.trim_right\" rel=\"noreferrer\"><code>trim_right</code></a> or even better, just <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.trim\" rel=\"noreferrer\"><code>trim</code></a>:</p>\n<pre><code>use std::io;\n\nfn main() {\n    let mut correct_name = String::new();\n    io::stdin().read_line(&amp;mut correct_name).expect(&quot;Failed to read line&quot;);\n\n    let correct_name = correct_name.trim();\n\n    if correct_name == &quot;y&quot; {\n        println!(&quot;matched y!&quot;);\n    } else if correct_name.trim() == &quot;n&quot; {\n        println!(&quot;matched n!&quot;);\n    }\n}\n</code></pre>\n<p>This last case handles lots of types of whitespace:</p>\n<blockquote>\n<p>Returns a string slice with leading and trailing whitespace removed.</p>\n<p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property White_Space.</p>\n</blockquote>\n<p>So Windows / Linux / macOS shouldn't matter.</p>\n<hr />\n<p>You could also use the trimmed result's length to truncate the original <code>String</code>, but in this case you should only use <code>trim_right</code>!</p>\n<pre><code>let trimmed_len = correct_name.trim_right().len();\ncorrect_name.truncate(trimmed_len);\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479233759, "post_id": 40616378, "comment_id": 68467812, "body": "What benefit / difference is there from <code>trim</code> / <code>trim_right</code> / <code>trim_right_matches</code>?"}, {"owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1479237707, "post_id": 40616378, "comment_id": 68470026, "body": "This is using the <code>trim_right_matches</code> function so the chomp function is a shortcut. There is also a trait for doing in-place trimming using <code>truncate</code> thought. So the benefit is mainly to have a shorter way to trim newlines."}], "tags": [], "owner": {"reputation": 8813, "user_id": 389119, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/05241abffd72dcdcd1dc9d6833706ba9?s=128&d=identicon&r=PG", "display_name": "antoyo", "link": "https://stackoverflow.com/users/389119/antoyo"}, "is_accepted": false, "score": 2, "last_activity_date": 1479231863, "creation_date": 1479231863, "answer_id": 40616378, "question_id": 27773313, "link": "https://stackoverflow.com/questions/27773313/why-does-my-string-not-match-when-reading-user-input-from-stdin/40616378#40616378", "title": "Why does my string not match when reading user input from stdin?", "body": "<p>You can use the <a href=\"https://crates.io/crates/chomp-nl\" rel=\"nofollow noreferrer\"><code>chomp-nl</code> crate</a> which provides a <a href=\"https://docs.rs/chomp-nl/0.1.1/chomp_nl/fn.chomp.html\" rel=\"nofollow noreferrer\"><code>chomp</code> function</a> which returns a string slice without the newline characters.</p>\n\n<p>There is also a <a href=\"https://docs.rs/chomp-nl/0.1.1/chomp_nl/trait.ChompInPlace.html\" rel=\"nofollow noreferrer\">trait <code>ChompInPlace</code></a> if you prefer to do this in-place.</p>\n\n<p>Disclaimer: I am the author of this library.</p>\n"}], "owner": {"reputation": 185, "user_id": 4414317, "user_type": "registered", "accept_rate": 75, "profile_image": "https://lh3.googleusercontent.com/-z7zBoPJUaLQ/AAAAAAAAAAI/AAAAAAAAABI/lhiohDzAXCA/photo.jpg?sz=128", "display_name": "Joe", "link": "https://stackoverflow.com/users/4414317/joe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2075, "favorite_count": 5, "accepted_answer_id": 27773539, "answer_count": 3, "score": 11, "last_activity_date": 1579529244, "creation_date": 1420431146, "last_edit_date": 1579529244, "question_id": 27773313, "link": "https://stackoverflow.com/questions/27773313/why-does-my-string-not-match-when-reading-user-input-from-stdin", "title": "Why does my string not match when reading user input from stdin?", "body": "<p>I'm trying to get user input and check if the user put in \"y\" or \"n\". Surprisingly, in the below code, neither the <code>if</code> nor the <code>if else</code> case executes! Apparently, <code>correct_name</code> is neither \"y\" nor \"n\". How can that be? Am I doing my string conversion wrong or something? </p>\n\n<pre><code>use std::io;\n\nfn main() {\n    let mut correct_name = String::new();\n    io::stdin().read_line(&amp;mut correct_name).expect(\"Failed to read line\");\n    if correct_name == \"y\" {\n        println!(\"matched y!\");\n    } else if correct_name == \"n\" {\n        println!(\"matched n!\");\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "is_accepted": true, "score": 3, "last_activity_date": 1420440750, "creation_date": 1420440750, "answer_id": 27774705, "question_id": 27773073, "link": "https://stackoverflow.com/questions/27773073/reading-documentation-specifically-bounded-traits/27774705#27774705", "title": "Reading documentation, specifically bounded traits", "body": "<p>That's what's referred to as a <em>blanket implementation</em>, i.e. an implementation for all types <code>T</code> that already implement <code>Buffer</code>, and the documentation system doesn't currently follow transitive implementations like that (i.e. <code>BufferedReader</code> impls <code>Buffer</code>, and so <code>BufferPrelude</code> is \"blanket impl'd\" for <code>BufferedReader</code>).</p>\n\n<p>The quickest way to have found this would've been to look for the method in particular, so <code>lines</code>, using the search feature. This would have led you to, indeed, <a href=\"http://doc.rust-lang.org/std/io/trait.BufferPrelude.html\" rel=\"nofollow\"><code>BufferPrelude</code></a>, where you would notice that it's \"only\" implemented for types that implement <code>Buffer</code>, so you would deduce that <code>BufferedReader</code> must implement <code>Buffer</code>. To verify this you could click on <a href=\"http://doc.rust-lang.org/std/io/trait.Buffer.html\" rel=\"nofollow\"><code>Buffer</code></a> and look at the \"implementors\" at the bottom.</p>\n"}], "owner": {"reputation": 325, "user_id": 170993, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/5b9b07a1e96b1b5acee26709f699c0d1?s=128&d=identicon&r=PG", "display_name": "nqe", "link": "https://stackoverflow.com/users/170993/nqe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 72, "favorite_count": 0, "accepted_answer_id": 27774705, "answer_count": 1, "score": 1, "last_activity_date": 1420515255, "creation_date": 1420428969, "last_edit_date": 1420515255, "question_id": 27773073, "link": "https://stackoverflow.com/questions/27773073/reading-documentation-specifically-bounded-traits", "title": "Reading documentation, specifically bounded traits", "body": "<p>Looking up how to read from stdin in rust-0.13, I got to <a href=\"http://doc.rust-lang.org/std/io/\" rel=\"nofollow\">this page</a>, which had the following code:</p>\n\n<pre><code>for line in io::stdin().lock().lines() {\n    print!(\"{}\", line.unwrap());\n}\n</code></pre>\n\n<p>I tried following the docs to figure out what exactly is happening, but got stuck with the lines() function. At the end I went through the code (pretty awesome that they have a link to it in the docs) and found <a href=\"http://doc.rust-lang.org/src/std/io/mod.rs.html#1536\" rel=\"nofollow\">BufferPrelude</a> which answered where lines() came from:</p>\n\n<pre><code>impl&lt;T: Buffer&gt; BufferPrelude for T {...}\n</code></pre>\n\n<p>My question is - was there an easier to figure what was happening? Does the documentation engine simply not catch this type of logic?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420428374, "post_id": 27772980, "comment_id": 43956837, "body": "How generic do you need it to be? Do you have a sample of types you need to support?"}, {"owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420428543, "post_id": 27772980, "comment_id": 43956891, "body": "I&#39;d like to support as many types as possible, but I&#39;m mostly looking to support slices and circular buffers (RingBuf)."}], "answers": [{"tags": [], "owner": {"reputation": 8764, "user_id": 1162888, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad1b7cc2be3bf5120b508c56590e6293?s=128&d=identicon&r=PG", "display_name": "Simon Sapin", "link": "https://stackoverflow.com/users/1162888/simon-sapin"}, "is_accepted": false, "score": 1, "last_activity_date": 1452454248, "creation_date": 1452454248, "answer_id": 34709874, "question_id": 27772980, "link": "https://stackoverflow.com/questions/27772980/is-there-a-generic-way-of-accessing-a-container-of-mutable-elements/34709874#34709874", "title": "Is there a generic way of accessing a container of mutable elements?", "body": "<p>You can require more bounds:</p>\n\n<pre><code>fn mutate&lt;'a, A, I&gt;(items: I) \nwhere I: Iterator&lt;Item=&amp;'a mut A&gt;,\n      I: ExactSizeIterator,\n      I: RandomAccessIterator,\n      I: Clone {\n</code></pre>\n"}], "owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 177, "favorite_count": 0, "answer_count": 1, "score": 3, "last_activity_date": 1452454248, "creation_date": 1420428005, "question_id": 27772980, "link": "https://stackoverflow.com/questions/27772980/is-there-a-generic-way-of-accessing-a-container-of-mutable-elements", "title": "Is there a generic way of accessing a container of mutable elements?", "body": "<p>I would like to mutate elements in a container. The only thing I care about is the length of the container and the fact that the container's elements are ordered (i.e. there is a first element, a second element, etc.). But I'm struggling to do this.</p>\n\n<p>My first attempt was to use an <code>Iterator</code> of mutable references:</p>\n\n<pre><code>fn mutate&lt;'a, A, I&gt;(items: I) where I: Iterator&lt;&amp;'a mut A&gt;\n</code></pre>\n\n<p>The problem is that I need to iterate more than once over the elements. But to avoid aliasing mutable references, structs like <code>Slice</code>'s <code>IterMut</code> don't implement <code>Clone</code> or <code>RandomAccessIterator</code>. So as far as I know, I can't use the same iterator to iterate over mutable references more than once.</p>\n\n<p>So then I looked at the <code>IndexMut</code> trait. This seems to be what I want, but I can't find another trait that specifies the length of a container. And the <code>Slice</code> struct that implements <code>IndexMut</code> does bounds checking for each access, which is undesirable.</p>\n\n<p>So is there a way to do what I want? It would be nice to use <code>Iterator</code>s, since what I really want to do is to iterate over the mutable elements several times.</p>\n"}, {"tags": ["multithreading", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420404496, "post_id": 27770032, "comment_id": 43951248, "body": "possible duplicate of <a href=\"http://stackoverflow.com/questions/27677466/why-do-some-statements-not-execute-when-they-are-run-in-a-task\">Why do some statements not execute when they are run in a task?</a>"}], "answers": [{"comments": [{"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420406357, "post_id": 27770082, "comment_id": 43951867, "body": "What does <i>outlive</i> mean in the docs? Also, how would you modify my code so it works with <code>join</code>?"}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420406854, "post_id": 27770082, "comment_id": 43952023, "body": "It means what you think it means, it&#39;s just that the main thread is special and different from the rest. No other thread may outlive the main thread; the program ends once the main thread is finished. I linked the documentation to the <code>join</code> method. It returns a <code>Result</code> that may contain the result of the thread, if any. In your case you no result, i.e. <code>()</code>. So you call <code>join</code> instead of detach, and you can then inspect the value returned by <code>join</code> if you like, to determine whether the thread failed for any reason."}, {"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420410000, "post_id": 27770082, "comment_id": 43952982, "body": "Replacing <code>detach</code> with <code>join</code> results in a program that displays <code>message 0: A --&gt; B</code>, and then waits forever."}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420411642, "post_id": 27770082, "comment_id": 43953460, "body": "Remove the calls to <code>detach</code> or <code>join</code>, so that you&#39;re left with the <code>JoinGuard</code> for each one. Then after the calls to spawn, call <code>join</code> on each of the guards. The call to <code>join</code> waits until that thread finishes before continuing, so by joining on the first one immediately, the second thread doesn&#39;t start until the first one finishes, and the first one can&#39;t finish because the second one hasn&#39;t started for it to interact with."}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420503562, "post_id": 27770082, "comment_id": 43990255, "body": "By the way, the explicit calls to join --- the last two lines in my example --- are not necessary. They are implicitly called when the JoinGuard is dropped. In other words, you can remove the last two lines and it should work as intended, as long as you don&#39;t explicitly call detach like you did in your original code."}, {"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420506422, "post_id": 27770082, "comment_id": 43990929, "body": "It does indeed, though I get build warnings about unused variables."}, {"owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "reply_to_user": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420506696, "post_id": 27770082, "comment_id": 43990992, "body": "Try not binding them to a variable, i.e. remove the &quot;let t1 =&quot; parts. If that doesn&#39;t work, then prepend the name of the variable with an underscore, e.g. _t1"}, {"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420534807, "post_id": 27770082, "comment_id": 43999301, "body": "I had to prefix the variables with underscores. The other method didn&#39;t work."}, {"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1420886933, "post_id": 27770082, "comment_id": 44152228, "body": "The edit you rolled back was fixing compiler errors made by a younger rustc."}], "tags": [], "owner": {"reputation": 32558, "user_id": 101090, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/066290971688c0a44cc4159a9f210dcf?s=128&d=identicon&r=PG", "display_name": "Jorge Israel Pe&#241;a", "link": "https://stackoverflow.com/users/101090/jorge-israel-pe%c3%b1a"}, "is_accepted": true, "score": 4, "last_activity_date": 1427329914, "last_edit_date": 1427329914, "creation_date": 1420403709, "answer_id": 27770082, "question_id": 27770032, "link": "https://stackoverflow.com/questions/27770032/why-are-these-threads-quitting-before-finishing-their-work/27770082#27770082", "title": "Why are these threads quitting before finishing their work?", "body": "<blockquote>\n  <p>The doc says these threads should outlive their parents, but here it seems they die as soon as the parent (in this case, <code>main</code>), dies.</p>\n</blockquote>\n\n<p>This does not apply to the main thread; the program ends once the main thread is finished.</p>\n\n<p>What you want to do is have the main thread wait until the other threads finish, i.e. you want to \"join\" the child thread to the main thread. See the <a href=\"http://doc.rust-lang.org/std/thread/struct.JoinGuard.html#method.join\" rel=\"nofollow\"><code>join</code></a> method for this.</p>\n\n<pre><code>let (atx, arx) = channel();\nlet (btx, brx) = channel();\n\nlet guard0 = thread::scoped(move || {\n    transceiver(atx, \"A --&gt; B\", brx, \"A &lt;-- B\");\n});\n\nlet guard1 = thread::scoped(move || {\n    transceiver(btx, \"B --&gt; A\", arx, \"B &lt;-- A\");\n});\n\nguard0.join();\nguard1.join();\n</code></pre>\n\n<p>Note that the calls to <code>join</code> are implicit when the <code>JoinGuard</code> drops, but they're made explicit here for illustration.</p>\n"}], "owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 170, "favorite_count": 0, "accepted_answer_id": 27770082, "answer_count": 1, "score": 0, "last_activity_date": 1427354134, "creation_date": 1420403445, "last_edit_date": 1427354134, "question_id": 27770032, "link": "https://stackoverflow.com/questions/27770032/why-are-these-threads-quitting-before-finishing-their-work", "title": "Why are these threads quitting before finishing their work?", "body": "<p>Given the following code:</p>\n\n<pre><code>use std::sync::mpsc::{channel, Sender, Receiver};\nuse std::thread;\n\nfn transceiver(\n    tx: Sender&lt;u32&gt;,   tx_string: &amp;str,\n    rx: Receiver&lt;u32&gt;, rx_string: &amp;str,\n) {\n    let message_count = 3;\n    for message in 0..message_count {\n        println!(\"message {}: {}\", message, tx_string);\n        tx.send(message).unwrap();\n        println!(\"message {}: {}\", rx.recv().unwrap(), rx_string);\n    }\n}\n\nfn main() {\n\n    let (atx, arx) = channel();\n    let (btx, brx) = channel();\n\n    thread::spawn(move || {\n        transceiver(atx, \"A --&gt; B\", brx, \"A &lt;-- B\");\n    });\n\n    thread::spawn(move || {\n        transceiver(btx, \"B --&gt; A\", arx, \"B &lt;-- A\");\n    });\n}\n</code></pre>\n\n<p>I get no output. I had to add a delay at the end of <code>main</code>:</p>\n\n<pre><code>std::old_io::timer::sleep(std::time::duration::Duration::seconds(1));\n</code></pre>\n\n<p>After that, I get this output:</p>\n\n<pre><code>message 0: B --&gt; A\nmessage 0: A --&gt; B\nmessage 0: A &lt;-- B\nmessage 0: B &lt;-- A\nmessage 1: B --&gt; A\nmessage 1: A --&gt; B\nmessage 1: A &lt;-- B\nmessage 2: A --&gt; B\nmessage 1: B &lt;-- A\nmessage 2: B --&gt; A\nmessage 2: B &lt;-- A\nmessage 2: A &lt;-- B\n</code></pre>\n\n<p>The doc says these threads should outlive their parents, but here it seems they die as soon as the parent (in this case, <code>main</code>), dies.</p>\n"}, {"tags": ["rust", "rust-cargo"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1420404569, "post_id": 27770031, "comment_id": 43951279, "body": "As an aside, you shouldn&#39;t manually edit <code>Cargo.lock</code>. Humans edit <code>Cargo.toml</code>, Cargo edits <code>Cargo.lock</code>."}, {"owner": {"reputation": 1836, "user_id": 2726965, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/40d4c49a770f83d4480cb85a5cdf7b78?s=128&d=identicon&r=PG", "display_name": "diogovk", "link": "https://stackoverflow.com/users/2726965/diogovk"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420406871, "post_id": 27770031, "comment_id": 43952029, "body": "Yeah, but if I had the exact Cargo.lock which generated that build, I should be able to generate the exact same build. So ideally there should be an way for me to tell cargo to build a Cargo.lock exactly like the one that generated that build, including dependency of dependency&#39;s version."}], "answers": [{"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1420404322, "post_id": 27770160, "comment_id": 43951199, "body": "FWIW, this would require manually downloading corresponding package versions and extracting them somewhere."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1420404648, "post_id": 27770160, "comment_id": 43951303, "body": "@VladimirMatveev yeah, good point. I reordered my two suggestions as &quot;specify all the versions&quot; is probably a better solution (if it works in this case)"}, {"owner": {"reputation": 1836, "user_id": 2726965, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/40d4c49a770f83d4480cb85a5cdf7b78?s=128&d=identicon&r=PG", "display_name": "diogovk", "link": "https://stackoverflow.com/users/2726965/diogovk"}, "edited": false, "score": 0, "creation_date": 1420405807, "post_id": 27770160, "comment_id": 43951697, "body": "I know the repository for rustc-serialize, but I don&#39;t know which commit generated the package version 0.1.5.  How do I download the package source for a specific version?  How do I know which commit generated a specific package version?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420406155, "post_id": 27770160, "comment_id": 43951825, "body": "Normally I&#39;d say to just grab the git tag for <code>0.1.5</code>, but it seems they aren&#39;t pushing those. That&#39;s no good... That being said, you can check <a href=\"https://github.com/rust-lang/rustc-serialize/commits/master/Cargo.toml\" rel=\"nofollow noreferrer\">the history for that file</a>, and you can spelunk a bit and get to <a href=\"https://github.com/rust-lang/rustc-serialize/commit/523f31969ffbaae9bd71760bc1f96013382142aa\" rel=\"nofollow noreferrer\">the commit that bumped the version number</a>"}, {"owner": {"reputation": 1836, "user_id": 2726965, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/40d4c49a770f83d4480cb85a5cdf7b78?s=128&d=identicon&r=PG", "display_name": "diogovk", "link": "https://stackoverflow.com/users/2726965/diogovk"}, "edited": false, "score": 0, "creation_date": 1420406511, "post_id": 27770160, "comment_id": 43951911, "body": "Yeah, sure I can guess the commit which generated the package. But by cargo&#39;s philosophy I should be able to generate the exact same build. If I guessed the commit there&#39;s no guarantee that it would be the exact build. So it would solve my problem, but it&#39;s not ideal."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420408050, "post_id": 27770160, "comment_id": 43952384, "body": "Well, you can only generate the same build if you have the same <code>Cargo.lock</code>. In this case, Iron is a library, so it doesn&#39;t maintain a lockfile and it&#39;s up to the end application(s) to create a lockfile. The CI build isn&#39;t the ideal place to be starting this, but neither is it fun trying to keep pace with a language going to 1.0!"}, {"owner": {"reputation": 1836, "user_id": 2726965, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/40d4c49a770f83d4480cb85a5cdf7b78?s=128&d=identicon&r=PG", "display_name": "diogovk", "link": "https://stackoverflow.com/users/2726965/diogovk"}, "edited": false, "score": 0, "creation_date": 1420411595, "post_id": 27770160, "comment_id": 43953445, "body": "I&#39;m sorry but it &quot;feels wrong&quot; to me. If I could go back in time to the state crate.io was in the date of the compilation I could get a build running. But because there were updates in packages in crate.io I no longer can, even though crate.io contains the packages in the specific version I want. It feels to me like a &quot;regression&quot; that is not really cargo&#39;s user&#39;s fault. The user is then obligated to download and compile each of those packages, and set the path in .cargo/config. This would be useful even after rust is stabilized."}, {"owner": {"reputation": 8897, "user_id": 2474, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/7ea904f852dda8cefbeeebe012f1932d?s=128&d=identicon&r=PG", "display_name": "rix0rrr", "link": "https://stackoverflow.com/users/2474/rix0rrr"}, "edited": false, "score": 0, "creation_date": 1460308614, "post_id": 27770160, "comment_id": 60669546, "body": "FWIW, the &quot;first idea&quot; works perfectly, and is the recommended way if you have multiple libraries that depend on the same crate that need to interoperate."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1475460984, "last_edit_date": 1592644375, "creation_date": 1420404191, "answer_id": 27770160, "question_id": 27770031, "link": "https://stackoverflow.com/questions/27770031/set-specific-version-of-the-dependency-of-a-projects-dependency-in-cargo-toml-o/27770160#27770160", "title": "Set specific version of the dependency of a project&#39;s dependency in Cargo.toml or Cargo.lock", "body": "<h3>Current idea</h3>\n<p>I think you are going to have to check out Iron, modify <code>Cargo.toml</code> to specify versions (as you have already done). Then you need to repeat the process, checking out <code>url</code>, modify its <code>Cargo.toml</code>, then make sure you are using your version of <code>url</code> in Iron's <code>Cargo.toml</code>. Rinse and repeat. This all sounds terrible :-(</p>\n<h3>First idea</h3>\n<p>From the <a href=\"http://doc.crates.io/specifying-dependencies.html#overriding-with-local-dependencies\" rel=\"nofollow noreferrer\">Cargo docs</a>:</p>\n<blockquote>\n<p>Similar to before, let\u2019s say you\u2019re working on a project, <code>uuid</code>, which depends on <code>rand</code>. This time you're the one who finds a bug in <code>rand</code>, and you want to write a patch and be able to test out your patch by using your version of <code>rand</code> in <code>uuid</code>.</p>\n<p>A path override is communicated to Cargo through the <code>.cargo/config</code> configuration mechanism. If Cargo finds this configuration when building your package, it will use the override on your local machine instead of the source specified in your <code>Cargo.toml</code>.</p>\n<p>Inside that file, put this:</p>\n<pre><code>paths = [&quot;/path/to/project/rand&quot;]\n</code></pre>\n</blockquote>\n<h3>Second idea</h3>\n<p><strong>Note</strong> This probably won't work. A thing someone told me when I was first starting Rust is that you can have multiple versions of the same library compiled into one binary. That would mean that there's no one place you can specify a version that applies all over, like you could with a Gemfile.</p>\n<p>You might be able to simply specify versions (or SHA hashes?) for each dependency that you know works with your Rust version. Cargo should be able to resolve the transitive dependencies and simply lock you to a previous version (if there is one that fits all the requirements).</p>\n"}, {"comments": [{"owner": {"reputation": 149903, "user_id": 14637, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/1904e7096278a10f1dfb3fdc0ceb53cc?s=128&d=identicon&r=PG", "display_name": "Thomas", "link": "https://stackoverflow.com/users/14637/thomas"}, "edited": false, "score": 8, "creation_date": 1603378243, "post_id": 59296817, "comment_id": 114024030, "body": "This answer would be more helpful if it included an example. The use case as mentioned in the question is not covered in the official documentation."}], "tags": [], "owner": {"reputation": 444, "user_id": 6828183, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a0fafca8db114e3a90ddb4089f15306a?s=128&d=identicon&r=PG&f=1", "display_name": "Rene", "link": "https://stackoverflow.com/users/6828183/rene"}, "is_accepted": false, "score": 2, "last_activity_date": 1576117468, "creation_date": 1576117468, "answer_id": 59296817, "question_id": 27770031, "link": "https://stackoverflow.com/questions/27770031/set-specific-version-of-the-dependency-of-a-projects-dependency-in-cargo-toml-o/59296817#59296817", "title": "Set specific version of the dependency of a project&#39;s dependency in Cargo.toml or Cargo.lock", "body": "<p>Since the anwser provided, Cargo has added the <code>[patch]</code> section to the manifest which allows you to do this use case.</p>\n\n<p><a href=\"https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#overriding-dependencies\" rel=\"nofollow noreferrer\">overriding-dependencies</a></p>\n"}], "owner": {"reputation": 1836, "user_id": 2726965, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/40d4c49a770f83d4480cb85a5cdf7b78?s=128&d=identicon&r=PG", "display_name": "diogovk", "link": "https://stackoverflow.com/users/2726965/diogovk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4793, "favorite_count": 1, "answer_count": 2, "score": 6, "last_activity_date": 1576117468, "creation_date": 1420403441, "last_edit_date": 1420404180, "question_id": 27770031, "link": "https://stackoverflow.com/questions/27770031/set-specific-version-of-the-dependency-of-a-projects-dependency-in-cargo-toml-o", "title": "Set specific version of the dependency of a project&#39;s dependency in Cargo.toml or Cargo.lock", "body": "<p>Let's say my project A depends on library B that depends on library C.</p>\n\n<p>Library B sets the dependency version to \"*\" (any) so cargo will download the latest version of C.</p>\n\n<p>How can I instruct cargo to build library B to using a specific version of library C?</p>\n\n<hr>\n\n<p>Currently I'm trying to build <a href=\"https://github.com/iron/iron\" rel=\"noreferrer\">iron</a>.</p>\n\n<p>The current build is failing, but I can see the last successful build in <a href=\"https://travis-ci.org/iron/iron/builds/45254195\" rel=\"noreferrer\">https://travis-ci.org/iron/iron/builds/45254195</a>, including rust version and cargo package versions.</p>\n\n<p>So I downloaded the specific rust nightly used in the build, and I've set the the direct dependencies of iron to the ones used in that build, by editing Cargo.toml:</p>\n\n<pre><code>(...)\n[dependencies]\nhyper = \"0.0.18\"\ntypemap = \"0.0.5\"\nurl = \"0.2.9\"\n(...)\n</code></pre>\n\n<p>But rust-serialized, which is a dependency of the \"url\" and \"time\" packages is downloaded in the latest version which doesn't compile with my specific rust version.</p>\n\n<p>If I used the version used in the Travis build above I'm sure it will compile successfully.</p>\n"}, {"tags": ["string", "rust"], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 21, "last_activity_date": 1529347559, "last_edit_date": 1529347559, "creation_date": 1420403598, "answer_id": 27770058, "question_id": 27769681, "link": "https://stackoverflow.com/questions/27769681/should-i-implement-display-or-tostring-to-render-a-type-as-a-string/27770058#27770058", "title": "Should I implement Display or ToString to render a type as a string?", "body": "<p>You should not implement <a href=\"http://doc.rust-lang.org/std/string/trait.ToString.html\" rel=\"noreferrer\"><code>ToString</code></a> manually. The <code>ToString</code> trait is already implemented for all types which implement <code>fmt::Display</code>:</p>\n\n<pre><code>impl&lt;T&gt; ToString for T\nwhere\n    T: Display + ?Sized, \n{ /* ... */ }\n</code></pre>\n\n<p>If you implement <code>Display</code>, <code>to_string()</code> will be available on your type automatically.</p>\n\n<p><a href=\"https://doc.rust-lang.org/std/fmt/trait.Display.html\" rel=\"noreferrer\"><code>fmt::Display</code></a> is intended to be implemented manually for those select few types which should be displayed to the user, while <a href=\"https://doc.rust-lang.org/std/fmt/trait.Debug.html\" rel=\"noreferrer\"><code>fmt::Debug</code></a> is expected to be implemented for <em>all</em> types in such a way that represents their internals most nicely (for most types this means that they should have <code>#[derive(Debug)]</code> on them).</p>\n\n<p>In order to obtain the string representation of <code>fmt::Debug</code> output you need to use <code>format!(\"{:?}\", value)</code>, with <code>{:?}</code> being a placeholder for types which implement <code>fmt::Debug</code>.</p>\n\n<p><a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0565-show-string-guidelines.md\" rel=\"noreferrer\">RFC 565</a> defines guidelines for when to use <code>fmt::Debug</code> and <code>fmt::Display</code>.</p>\n"}], "owner": {"reputation": 1549, "user_id": 104180, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/b7513dc7fb65986529417c59f044901e?s=128&d=identicon&r=PG", "display_name": "Ray", "link": "https://stackoverflow.com/users/104180/ray"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4254, "favorite_count": 2, "accepted_answer_id": 27770058, "answer_count": 1, "score": 14, "last_activity_date": 1529347559, "creation_date": 1420401294, "last_edit_date": 1524865698, "question_id": 27769681, "link": "https://stackoverflow.com/questions/27769681/should-i-implement-display-or-tostring-to-render-a-type-as-a-string", "title": "Should I implement Display or ToString to render a type as a string?", "body": "<p>I have a type <code>Foo</code> that I want to be able to display to the end user as a string, is it more idiomatic to do this by implementing <a href=\"https://doc.rust-lang.org/std/fmt/trait.Display.html\" rel=\"noreferrer\"><code>Display</code></a> or by implementing <a href=\"https://doc.rust-lang.org/std/string/trait.ToString.html\" rel=\"noreferrer\"><code>ToString</code></a>?</p>\n\n<p>If <code>Display</code> is the way to go, how would I actually end up with a <code>String</code>? I suspect I need to make use of <code>write!</code>, but I'm not entirely sure how.</p>\n"}, {"tags": ["string", "iterator", "rust"], "answers": [{"comments": [{"owner": {"reputation": 1549, "user_id": 104180, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/b7513dc7fb65986529417c59f044901e?s=128&d=identicon&r=PG", "display_name": "Ray", "link": "https://stackoverflow.com/users/104180/ray"}, "edited": false, "score": 0, "creation_date": 1420403240, "post_id": 27769789, "comment_id": 43950843, "body": "Do you know if there&#39;s been discussion about implementing those methods for iterators before? Is it not done because it&#39;s tricky or because no one&#39;s got around to it?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 1549, "user_id": 104180, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/b7513dc7fb65986529417c59f044901e?s=128&d=identicon&r=PG", "display_name": "Ray", "link": "https://stackoverflow.com/users/104180/ray"}, "edited": false, "score": 0, "creation_date": 1420403347, "post_id": 27769789, "comment_id": 43950886, "body": "@Ray, it is most certainly that no one&#39;s got around to it. I&#39;m not aware of any discussions, and for some reason (laziness, most probably :() I didn&#39;t start any myself."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 10, "last_activity_date": 1516297870, "last_edit_date": 1516297870, "creation_date": 1420401968, "answer_id": 27769789, "question_id": 27769635, "link": "https://stackoverflow.com/questions/27769635/string-join-on-strings-in-vec-in-reverse-order-without-a-collect/27769789#27769789", "title": "String join on strings in Vec in reverse order without a `collect`", "body": "<p>I believe this is the shortest you can get:</p>\n\n<pre><code>fn main() {\n    let v = vec![\"a\".to_string(), \"b\".to_string(), \"c\".to_string()];\n    let mut r = v.iter()\n        .rev()\n        .fold(String::new(), |r, c| r + c.as_str() + \".\");\n    r.pop();\n    println!(\"{}\", r);\n}\n</code></pre>\n\n<p>The addition operation on <code>String</code> takes its left operand by value and pushes the second operand in-place, which is very nice - it does not cause any reallocations. You don't even need to <code>clone()</code> the contained strings.</p>\n\n<p>I think, however, that the lack of <code>concat()</code>/<code>connect()</code> methods on iterators is a serious drawback. It bit me a lot too.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1516297810, "last_edit_date": 1516297810, "creation_date": 1420406002, "answer_id": 27770425, "question_id": 27769635, "link": "https://stackoverflow.com/questions/27769635/string-join-on-strings-in-vec-in-reverse-order-without-a-collect/27770425#27770425", "title": "String join on strings in Vec in reverse order without a `collect`", "body": "<p>Here's an iterator extension trait that I whipped up, just for you!</p>\n\n<pre><code>pub trait InterleaveExt: Iterator + Sized {\n    fn interleave(self, value: Self::Item) -&gt; Interleave&lt;Self&gt; {\n        Interleave {\n            iter: self.peekable(),\n            value: value,\n            me_next: false,\n        }\n    }\n}\n\nimpl&lt;I: Iterator&gt; InterleaveExt for I {}\n\npub struct Interleave&lt;I&gt;\nwhere\n    I: Iterator,\n{\n    iter: std::iter::Peekable&lt;I&gt;,\n    value: I::Item,\n    me_next: bool,\n}\n\nimpl&lt;I&gt; Iterator for Interleave&lt;I&gt;\nwhere\n    I: Iterator,\n    I::Item: Clone,\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        // Don't return a value if there's no next item\n        if let None = self.iter.peek() {\n            return None;\n        }\n\n        let next = if self.me_next {\n            Some(self.value.clone())\n        } else {\n            self.iter.next()\n        };\n\n        self.me_next = !self.me_next;\n        next\n    }\n}\n</code></pre>\n\n<p>It can be called like so:</p>\n\n<pre><code>fn main() {\n    let a = &amp;[\"a\", \"b\", \"c\"];\n    let s: String = a.iter().cloned().rev().interleave(\".\").collect();\n    println!(\"{}\", s);\n\n    let v = vec![\"a\".to_string(), \"b\".to_string(), \"c\".to_string()];\n    let s: String = v.iter().map(|s| s.as_str()).rev().interleave(\".\").collect();\n    println!(\"{}\", s);\n}\n</code></pre>\n\n<p>I've since learned that this iterator adapter already exists in itertools under the name <a href=\"https://docs.rs/itertools/0.5.9/itertools/trait.Itertools.html#method.intersperse\" rel=\"nofollow noreferrer\"><code>intersperse</code></a> \u2014 go use that instead!.</p>\n\n<h3>Cheating answer</h3>\n\n<p>You never said you <em>needed</em> the original vector after this, so we can reverse it in place and just use <code>join</code>...</p>\n\n<pre><code>let mut v = vec![\"a\".to_string(), \"b\".to_string(), \"c\".to_string()];\nv.reverse();\nprintln!(\"{}\", v.join(\".\"))\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": false, "score": 7, "last_activity_date": 1486855385, "last_edit_date": 1486855385, "creation_date": 1466237853, "answer_id": 37894829, "question_id": 27769635, "link": "https://stackoverflow.com/questions/27769635/string-join-on-strings-in-vec-in-reverse-order-without-a-collect/37894829#37894829", "title": "String join on strings in Vec in reverse order without a `collect`", "body": "<p>I don't know if they've heard our Stack Overflow prayers or what, but the <a href=\"https://crates.io/crates/itertools\" rel=\"nofollow noreferrer\">itertools</a> crate happens to have just the method you need - <a href=\"https://docs.rs/itertools/*/itertools/fn.join.html\" rel=\"nofollow noreferrer\"><code>join</code></a>.</p>\n\n<p>With it, your example might be laid out as follows:</p>\n\n<pre><code>use itertools::Itertools;\nlet v = [\"a\", \"b\", \"c\"];\nlet connected = v.iter().rev().join(\".\");\n</code></pre>\n"}], "owner": {"reputation": 1549, "user_id": 104180, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/b7513dc7fb65986529417c59f044901e?s=128&d=identicon&r=PG", "display_name": "Ray", "link": "https://stackoverflow.com/users/104180/ray"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2158, "favorite_count": 1, "accepted_answer_id": 27770425, "answer_count": 3, "score": 6, "last_activity_date": 1516297870, "creation_date": 1420400939, "question_id": 27769635, "link": "https://stackoverflow.com/questions/27769635/string-join-on-strings-in-vec-in-reverse-order-without-a-collect", "title": "String join on strings in Vec in reverse order without a `collect`", "body": "<p>I'm trying to join strings in a vector into a single string, in reverse from their order in the vector. The following works:</p>\n\n<pre><code>let v = vec![\"a\".to_string(), \"b\".to_string(), \"c\".to_string()];\nv.iter().rev().map(|s| s.clone()).collect::&lt;Vec&lt;String&gt;&gt;().connect(\".\")\n</code></pre>\n\n<p>However, this ends up creating a temporary vector that I don't actually need. Is it possible to do this without a <code>collect</code>? I see that <code>connect</code> is a <code>StrVector</code> method. Is there nothing for raw iterators?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420397085, "post_id": 27768956, "comment_id": 43948798, "body": "I see you linked to the 0.12 docs. Be aware that Rust is quickly changing in preparation for a 1.0 alpha / beta / release. It&#39;s recommended to track the nightly builds (and docs)."}, {"owner": {"reputation": 191, "user_id": 2021149, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/2e54ce8e2a85707376526aaa64915c53?s=128&d=identicon&r=PG", "display_name": "RohanC", "link": "https://stackoverflow.com/users/2021149/rohanc"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420398026, "post_id": 27768956, "comment_id": 43949132, "body": "Oh wow, you&#39;re right. The link on the nightly docs seems to be completely different. Thanks for the tip!"}], "answers": [{"comments": [{"owner": {"reputation": 191, "user_id": 2021149, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/2e54ce8e2a85707376526aaa64915c53?s=128&d=identicon&r=PG", "display_name": "RohanC", "link": "https://stackoverflow.com/users/2021149/rohanc"}, "edited": false, "score": 0, "creation_date": 1420398975, "post_id": 27769200, "comment_id": 43949481, "body": "Haha, thanks a lot for your answer! I learned a new feature that isn&#39;t currently on the guide!"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 1, "creation_date": 1420598487, "post_id": 27769200, "comment_id": 44030019, "body": "<code>Copy</code> used to be implemented automatically by the compiler on types that met certain criteria. This is no longer the case, and that&#39;s why one must now write <code>#[deriving(Copy)]</code>."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1420397982, "creation_date": 1420397982, "answer_id": 27769200, "question_id": 27768956, "link": "https://stackoverflow.com/questions/27768956/passing-a-component-of-a-pointer-by-value/27769200#27769200", "title": "Passing a component of a pointer by value", "body": "<p>As you said, your changed <code>compute_distance</code> wants a <em>value</em> as the first parameter. This means that the function is going to take ownership of the argument.</p>\n\n<p>However, you are attempting to pass a smaller piece of a structure (<code>origin</code> is embedded in <code>Rectangle</code>). To do this, Rust would have to give ownership of <em>part</em> of <code>Rectangle</code> to the method, but exactly what state would <code>Rectangle</code> be left in? A very broken one, so Rust prevents you from doing that. Yay, you didn't shoot yourself in the foot!</p>\n\n<p>\"But wait\", you say, \"it's totally cool if the function gets a <em>copy</em> of <code>origin</code>\". You, as a human, can recognize that and tell the compiler that it's \"totally cool\":</p>\n\n<pre><code>#[deriving(Copy)]\nstruct Point { /* ... */ }\n</code></pre>\n\n<p>Now Rust knows that it is safe to make a bit-for-bit copy of a <code>Point</code> if it would like to. Huzzah!</p>\n\n<p>\"But <strong>wait</strong>\", you say, \"what if it's <em>not</em> cool to make a bit-for-bit copy? My structure needs more love than being treated like a bag of bits!\". Again, as an intelligent human, you can express that:</p>\n\n<pre><code>#[deriving(Clone)]\nstruct Point { /* ... */ }\n\n// later...\n\non_the_stack.origin.clone()\n</code></pre>\n\n<p>Now you can make an explicit call (<code>clone()</code>) to get a semantic duplicate of the option. Because this could be an expensive operation, the compiler won't do it for you.</p>\n\n<p><strong>A note on <code>deriving</code></strong></p>\n\n<p>As I write this answer, <code>deriving</code> is transitioning to <code>derive</code>. Adjust as needed for your code.</p>\n"}], "owner": {"reputation": 191, "user_id": 2021149, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/2e54ce8e2a85707376526aaa64915c53?s=128&d=identicon&r=PG", "display_name": "RohanC", "link": "https://stackoverflow.com/users/2021149/rohanc"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 36, "favorite_count": 0, "accepted_answer_id": 27769200, "answer_count": 1, "score": 0, "last_activity_date": 1420398181, "creation_date": 1420396658, "last_edit_date": 1420398181, "question_id": 27768956, "link": "https://stackoverflow.com/questions/27768956/passing-a-component-of-a-pointer-by-value", "title": "Passing a component of a pointer by value", "body": "<p>I've just started out with Rust, so some of my concepts may be wrong. I'd really appreciate corrections if this is the case.</p>\n\n<p>I was following the <a href=\"http://doc.rust-lang.org/0.12.0/guide-lifetimes.html\" rel=\"nofollow\">lifetimes guide</a> and trying some of the examples. I modified the rectangle example a little.</p>\n\n<p>I changed the <code>compute_distance</code> function to accept <code>Point</code> by value in the first parameter.\nI then removed the <code>&amp;</code> before <code>on_the_stack.origin</code> in the call to <code>compute_distance</code>.</p>\n\n<p>This gives me the following error:</p>\n\n<blockquote>\n  <p>cannot move out of dereference of <code>&amp;</code>-pointer</p>\n</blockquote>\n\n<p>If instead I add the <code>&amp;</code> before the <code>on_the_stack.origin</code> call as well as accept <code>Point</code> by reference in the <code>compute_distance</code> function, it works without a hitch. </p>\n\n<p>The second method working makes sense to me, but why does my original approach throw an error?</p>\n\n<pre><code>use std::num::Float;\n\nstruct Point {\n    x : f64,\n    y : f64\n}\n\nstruct Size {w: f64, h: f64}\nstruct Rectangle {origin: Point, size: Size}\n\n#[cfg(not(test))]\nfn main() {\n    let on_the_stack = &amp;Rectangle{origin: Point {x: 1.0, y: 2.0},\n                                  size: Size {w: 3.0, h: 4.0}};\n\n    let on_the_heap = box Rectangle {origin: Point {x: 5.0, y: 6.0},\n                                  size: Size {w: 3.0, h: 4.0}};\n\n    println!(\"Distance: {}\", compute_distance(on_the_stack.origin,&amp;on_the_heap.origin));\n}\n\nfn compute_distance ( p1:Point,p2:&amp;Point) -&gt; f64 {\n    let x_d = p1.x - p2.x;\n    let y_d = p1.y - p2.y;\n    Float::sqrt(x_d * x_d + y_d * y_d)\n}\n</code></pre>\n"}, {"tags": ["iterator", "rust", "fold"], "answers": [{"comments": [{"owner": {"reputation": 519, "user_id": 148082, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/df7b85d1b95d9a5d8b1b5d022a838a86?s=128&d=identicon&r=PG", "display_name": "Andreas Arnold", "link": "https://stackoverflow.com/users/148082/andreas-arnold"}, "edited": false, "score": 0, "creation_date": 1420324027, "post_id": 27760120, "comment_id": 43931392, "body": "That&#39;s perfect, thank you! Though I have a question then (regarding your point 1): I added the ref because I thought that data inside the closure would then be a copy of the data vector, and not point to the same data vector. How does Rust decide when to pass a value by reference and when by value?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 519, "user_id": 148082, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/df7b85d1b95d9a5d8b1b5d022a838a86?s=128&d=identicon&r=PG", "display_name": "Andreas Arnold", "link": "https://stackoverflow.com/users/148082/andreas-arnold"}, "edited": false, "score": 0, "creation_date": 1420324359, "post_id": 27760120, "comment_id": 43931497, "body": "Rust doesn&#39;t &quot;decide&quot; anything for you; it&#39;s all up to the programmer. <a href=\"http://doc.rust-lang.org/std/iter/trait.IteratorExt.html#tymethod.fold\" rel=\"nofollow noreferrer\"><code>fold</code></a> accepts an initial value of type <code>B</code> and a function that takes a <code>B</code> and a single iterator value and returns a <code>B</code>. In this case, your <code>B</code> is a <code>Vec&lt;u64&gt;</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 519, "user_id": 148082, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/df7b85d1b95d9a5d8b1b5d022a838a86?s=128&d=identicon&r=PG", "display_name": "Andreas Arnold", "link": "https://stackoverflow.com/users/148082/andreas-arnold"}, "edited": false, "score": 0, "creation_date": 1420324588, "post_id": 27760120, "comment_id": 43931551, "body": "Also note that your closure doesn&#39;t <i>capture</i> any variables from its context, it&#39;s simply working on arguments provided to the closure. The closure could be Fn, FnOnce, or FnMut, all of which are variants on how the closure captures its environment."}, {"owner": {"reputation": 519, "user_id": 148082, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/df7b85d1b95d9a5d8b1b5d022a838a86?s=128&d=identicon&r=PG", "display_name": "Andreas Arnold", "link": "https://stackoverflow.com/users/148082/andreas-arnold"}, "edited": false, "score": 0, "creation_date": 1420327250, "post_id": 27760120, "comment_id": 43932277, "body": "I see where my thinking went wrong now. Thanks a log! I thought that not using a ref would move the vector out of the <code>fold</code>. But I guess it gets moved backed at the end of the closure, that&#39;s why it works."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 10, "last_activity_date": 1607536928, "last_edit_date": 1607536928, "creation_date": 1420323453, "answer_id": 27760120, "question_id": 27760022, "link": "https://stackoverflow.com/questions/27760022/is-it-possible-to-use-a-fold-with-a-vec/27760120#27760120", "title": "Is it possible to use a fold with a Vec?", "body": "<p>Here's <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0e9ca90652f9bef275700a597f56d1e0\" rel=\"nofollow noreferrer\">a working version</a>:</p>\n<pre><code>fn main() {\n    let z = (2..12).fold(vec![1u64, 1], |mut data, _| {\n        data.push(data[data.len() - 2] + data[data.len() - 1]);\n        data\n    });\n    println!(&quot;{:?}&quot;, z.last())\n}\n</code></pre>\n<p>There are a few problems with your approach:</p>\n<ol>\n<li><code>data: &amp;mut Vec&lt;uint&gt;</code> (or <code>usize</code> in modern Rust) \u2014 Your accumulator variable isn't a &quot;reference to a mutable vector&quot;, it's just a &quot;mutable vector&quot;.</li>\n<li><code>data[-2]</code> \u2014 Rust doesn't implicitly index from the back of the array for negative values. In fact, the index doesn't even accept negative values! It wants a <code>usize</code>, so your <code>-2</code> and <code>-1</code> would have become very large numbers!</li>\n</ol>\n"}], "owner": {"reputation": 519, "user_id": 148082, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/df7b85d1b95d9a5d8b1b5d022a838a86?s=128&d=identicon&r=PG", "display_name": "Andreas Arnold", "link": "https://stackoverflow.com/users/148082/andreas-arnold"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2952, "favorite_count": 0, "accepted_answer_id": 27760120, "answer_count": 1, "score": 4, "last_activity_date": 1607536928, "creation_date": 1420322676, "last_edit_date": 1607536878, "question_id": 27760022, "link": "https://stackoverflow.com/questions/27760022/is-it-possible-to-use-a-fold-with-a-vec", "title": "Is it possible to use a fold with a Vec?", "body": "<p>I was thinking about how to implement Fibonacci in Rust, and thought I could do it with a <code>fold</code>.</p>\n<p>What I came up with is the following:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>// Editor's note: this code sample predates Rust 1.0 and \n// is not valid syntax. The concepts remain valid.\n\nrange(2, generations).fold(vec![1u, 1], |data: &amp;mut Vec&lt;uint&gt;, value| {\n    data.push(data[-2] + data[-1]);\n\n    data\n}).last()\n</code></pre>\n<p>However, this does not compile because I can't get <code>data</code> into the <code>fold</code> in a way the borrow checker likes. Either it is immutable, or it is borrowed multiple times or then the last <code>data</code> is out of scope and I can't return <code>data</code> to <code>fold</code>.</p>\n<p>Is there a way to use fold with a <code>Vec</code>? Or do I have to resort to to a loop?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420311899, "post_id": 27758387, "comment_id": 43927618, "body": "To be a good open-source citizen, I&#39;d recommend fixing the compilation issues in <code>rust-http</code> and submitting a pull request. You can even change your <code>Cargo.toml</code> to point to your fork with the fixes until upstream accepts the changes."}, {"owner": {"reputation": 6718, "user_id": 2455707, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/768bc63471394edee20bcd4131186118?s=128&d=identicon&r=PG", "display_name": "reem", "link": "https://stackoverflow.com/users/2455707/reem"}, "edited": false, "score": 3, "creation_date": 1420319224, "post_id": 27758387, "comment_id": 43930015, "body": "You should not use <code>rust-http</code>, as it is old and completely deprecated. Use <a href=\"https://github.com/hyperium/hyper\" rel=\"nofollow noreferrer\"><code>hyper</code></a> instead."}], "answers": [{"comments": [{"owner": {"reputation": 5258, "user_id": 446988, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/9dd013e199a89d9e9f8e723188b4c075?s=128&d=identicon&r=PG", "display_name": "lassej", "link": "https://stackoverflow.com/users/446988/lassej"}, "edited": false, "score": 1, "creation_date": 1420312370, "post_id": 27758472, "comment_id": 43927808, "body": "Cool, thanks! I&#39;ll try to fix the compilation issues as soon as I&#39;ve finished my hello world app :)"}, {"owner": {"reputation": 648, "user_id": 1736338, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8b8038508304fd4651b6595179ba241c?s=128&d=identicon&r=PG&f=1", "display_name": "M. Leonhard", "link": "https://stackoverflow.com/users/1736338/m-leonhard"}, "edited": false, "score": 0, "creation_date": 1599039063, "post_id": 27758472, "comment_id": 112647093, "body": "If you get a &quot;not available for download&quot; error then try an earlier date.  Today is 2020-09-02 and &quot;rustup install nightly-2020-08-29&quot; works."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 30, "last_activity_date": 1471886831, "last_edit_date": 1471886831, "creation_date": 1420311726, "answer_id": 27758472, "question_id": 27758387, "link": "https://stackoverflow.com/questions/27758387/is-it-possible-to-download-previous-nightly-builds/27758472#27758472", "title": "Is it possible to download previous nightly builds?", "body": "<p>If you are using <a href=\"https://rustup.rs/\" rel=\"noreferrer\">rustup</a> (the currently preferred manner of installing Rust):</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>rustup install nightly-2016-06-03\n</code></pre>\n\n<p>If you want to use the standalone Rust installers, previous versions are kept. From this <a href=\"http://www.reddit.com/r/rust/comments/2p9ekl/does_anyone_archive_the_nightly/\" rel=\"noreferrer\">Reddit thread</a>, which links to this <a href=\"https://github.com/rust-lang/rust/issues/14796#issuecomment-62053531\" rel=\"noreferrer\">Rust issue</a>:</p>\n\n<blockquote>\n  <p>They are officially hosted.</p>\n  \n     <pre class=\"lang-none prettyprint-override\"><code>wget https://static.rust-lang.org/dist/2014-12-08/rust-nightly-x86_64-apple-darwin.pkg\nwget https://static.rust-lang.org/dist/2014-12-12/rust-nightly-x86_64-unknown-linux-gnu.tar.gz\n</code></pre>\n</blockquote>\n\n<p>If you are still using rustup<b>.sh</b> (not <strong>.rs</strong>), you should be able to use something like:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>rustup.sh --channel=nightly --date=2016-06-03\n</code></pre>\n"}], "owner": {"reputation": 5258, "user_id": 446988, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/9dd013e199a89d9e9f8e723188b4c075?s=128&d=identicon&r=PG", "display_name": "lassej", "link": "https://stackoverflow.com/users/446988/lassej"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5367, "favorite_count": 4, "accepted_answer_id": 27758472, "answer_count": 1, "score": 21, "last_activity_date": 1471886831, "creation_date": 1420311264, "last_edit_date": 1420404328, "question_id": 27758387, "link": "https://stackoverflow.com/questions/27758387/is-it-possible-to-download-previous-nightly-builds", "title": "Is it possible to download previous nightly builds?", "body": "<p>I have downloaded the latest Rust nightly and added this dependency to Cargo.toml:</p>\n\n<pre><code>[dependencies.http]\n\ngit = \"https://github.com/chris-morgan/rust-http.git\"\n</code></pre>\n\n<p>I'm getting lots of errors for <code>cargo build</code>:</p>\n\n<pre><code>...\nerror: aborting due to 7 previous errors\n...\nerror: aborting due to previous error\nCould not compile `regex`.\n</code></pre>\n\n<p>I guess this is because some dependencies have not been updated to the latest rust version. Is it possible to download the nightly from yesterday or the day before?</p>\n\n<p>Installed versions:</p>\n\n<pre><code>$ rustc --version\nrustc 0.13.0-nightly (c89417130 2015-01-02 21:56:13 +0000)\n$ cargo --version\ncargo 0.0.1-pre-nightly (1a1868b 2014-12-31 21:39:41 +0000)\n</code></pre>\n"}, {"tags": ["closures", "rust", "lifetime"], "answers": [{"tags": [], "owner": {"reputation": 6718, "user_id": 2455707, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/768bc63471394edee20bcd4131186118?s=128&d=identicon&r=PG", "display_name": "reem", "link": "https://stackoverflow.com/users/2455707/reem"}, "is_accepted": true, "score": 8, "last_activity_date": 1420302210, "last_edit_date": 1420302210, "creation_date": 1420290902, "answer_id": 27755254, "question_id": 27754877, "link": "https://stackoverflow.com/questions/27754877/lifetime-woes-when-using-threads/27755254#27755254", "title": "Lifetime woes when using threads", "body": "<p>The lifetime constraint that is causing this problem is the one in <code>Thread::spawn</code>, which requires the <code>FnOnce</code> closure to be <code>Send</code>. <code>Send</code> requires <code>'static</code>, which means that the data contains no non-<code>'static</code> data. Your data, <code>Foo</code>, contains a borrowed <code>str</code>, which is not <code>'static</code>, which makes <code>Foo</code> non-<code>'static</code>. As a result, you can't send <code>Foo</code> across threads.</p>\n\n<p>Why is this? Since <code>Foo</code> contains a borrow, it is valid for only a small lifetime. If Rust allowed you to send an instance of <code>Foo</code> to another thread, then that thread could easily use <code>Foo</code> long after the data it borrows has become invalid.</p>\n\n<p>You might think that this is actually overly restrictive, and you'd be right. There's no reason to not allow <em>local</em> parallelism as long as you can prove to the borrow checker that the thread terminates within some lifetime. There are currently no constructs in Rust to do this, but there are some future solutions for this problem, such as <a href=\"https://github.com/rust-lang/rfcs/pull/458\">this RFC</a> which extends the <code>Send</code> trait to allow local parallelism.</p>\n"}], "owner": {"reputation": 1116, "user_id": 455959, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/8de605661eec54733350cd848d1b76ac?s=128&d=identicon&r=PG", "display_name": "Shum", "link": "https://stackoverflow.com/users/455959/shum"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1099, "favorite_count": 2, "accepted_answer_id": 27755254, "answer_count": 1, "score": 6, "last_activity_date": 1496775518, "creation_date": 1420288240, "last_edit_date": 1496775518, "question_id": 27754877, "link": "https://stackoverflow.com/questions/27754877/lifetime-woes-when-using-threads", "title": "Lifetime woes when using threads", "body": "<p>I'm having a hard time getting this to compile:</p>\n\n<pre><code>use std::thread::{self, JoinHandle};\n\nstruct Foo&lt;'c&gt; {\n    foo: &amp;'c str,\n}\n\nimpl&lt;'c&gt; Foo&lt;'c&gt; {\n    fn use_in_another_thread&lt;F&gt;(self, mut cb: F) -&gt; JoinHandle&lt;Foo&lt;'c&gt;&gt;\n        where F: FnOnce(&amp;mut Foo),\n              F: Send\n    {\n        thread::spawn(move || {\n            cb(&amp;mut self);\n            self\n        })\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>As far as I can see the lifetimes are sound, but I'm getting errors...</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0477]: the type `[closure@src/main.rs:12:23: 15:10 cb:F, self:Foo&lt;'c&gt;]` does not fulfill the required lifetime\n  --&gt; src/main.rs:12:9\n   |\n12 |         thread::spawn(move || {\n   |         ^^^^^^^^^^^^^\n   |\n   = note: type must outlive the static lifetime\n\nerror[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n  --&gt; src/main.rs:14:13\n   |\n14 |             self\n   |             ^^^^\n   |\nnote: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 11:4...\n  --&gt; src/main.rs:11:5\n   |\n11 |       {\n   |  _____^ starting here...\n12 | |         thread::spawn(move || {\n13 | |             cb(&amp;mut self);\n14 | |             self\n15 | |         })\n16 | |     }\n   | |_____^ ...ending here\nnote: ...so that expression is assignable (expected std::thread::JoinHandle&lt;Foo&lt;'c&gt;&gt;, found std::thread::JoinHandle&lt;Foo&lt;'_&gt;&gt;)\n  --&gt; src/main.rs:12:9\n   |\n12 |           thread::spawn(move || {\n   |  _________^ starting here...\n13 | |             cb(&amp;mut self);\n14 | |             self\n15 | |         })\n   | |__________^ ...ending here\n   = note: but, the lifetime must be valid for the static lifetime...\nnote: ...so that the type `Foo&lt;'_&gt;` will meet its required lifetime bounds\n  --&gt; src/main.rs:12:9\n   |\n12 |         thread::spawn(move || {\n   |         ^^^^^^^^^^^^^\n</code></pre>\n\n<p>I don't understand what lifetimes the errors are referring to - the lifetime of the closure body? - or why they must outlive the static lifetime.</p>\n"}, {"tags": ["string", "rust", "ffi"], "answers": [{"comments": [{"owner": {"reputation": 1753, "user_id": 953348, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/68cd573b9d5bb7d2467c4c5ae21570d6?s=128&d=identicon&r=PG", "display_name": "Christian Hudon", "link": "https://stackoverflow.com/users/953348/christian-hudon"}, "edited": false, "score": 0, "creation_date": 1420301306, "post_id": 27751326, "comment_id": 43924144, "body": "That&#39;s exactly what I wanted to know. And including references to existing Rust code showing what&#39;s done is great. Thank you! I will go comment on the bug later."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1420254230, "creation_date": 1420254230, "answer_id": 27751326, "question_id": 27751137, "link": "https://stackoverflow.com/questions/27751137/c-string-ffi-is-there-something-like-stringfrom-raw-buf-with-max-len/27751326#27751326", "title": "C string FFI: Is there something like String::from_raw_buf_with_max_len", "body": "<p>The Rust standard library itself doesn't really seem to handle this possibility:</p>\n\n<ul>\n<li><a href=\"https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src/libstd/sys/common/net.rs#L307-L329\" rel=\"nofollow\">net.rs</a></li>\n<li><a href=\"https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src/libstd/sys/unix/os.rs#L91-L114\" rel=\"nofollow\">unix/os.rs</a></li>\n<li><a href=\"https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src/libstd/sys/unix/os.rs#L125-L136\" rel=\"nofollow\">unix/os.rs</a></li>\n<li><a href=\"https://github.com/rust-lang/rust/blob/c89417130f042c58adc60012e7cddc4ef70b70b9/src/libstd/sys/windows/backtrace.rs#L360\" rel=\"nofollow\">windows/backtrace.rs</a></li>\n</ul>\n\n<p>This is probably unintentional, and IMO, a bug should be filed with Rust.</p>\n\n<p>So I don't think there is an easy solution right now. The one I can come up with is this</p>\n\n<pre><code>#![feature(slicing_syntax)]\n\nextern crate libc;\n\nuse std::c_str::CString;\n\nfn main() {\n    let errbuf = ['o' as libc::c_char; 256];\n    if errbuf.iter().any(|c| *c == 0 as libc::c_char) {\n        unsafe { CString::new(errbuf.as_ptr(), false).to_string() };\n    } else {\n        panic!(\"FFI returned invalid string!\");\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 1753, "user_id": 953348, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/68cd573b9d5bb7d2467c4c5ae21570d6?s=128&d=identicon&r=PG", "display_name": "Christian Hudon", "link": "https://stackoverflow.com/users/953348/christian-hudon"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 898, "favorite_count": 1, "accepted_answer_id": 27751326, "answer_count": 1, "score": 3, "last_activity_date": 1450811639, "creation_date": 1420251794, "last_edit_date": 1450811639, "question_id": 27751137, "link": "https://stackoverflow.com/questions/27751137/c-string-ffi-is-there-something-like-stringfrom-raw-buf-with-max-len", "title": "C string FFI: Is there something like String::from_raw_buf_with_max_len", "body": "<p><strong>Note</strong> (May 2015): this question was about the Rust language before it stabilized and 1.0 was released, and is now mostly of historical interest: the code will not compile on stable Rust, etc.</p>\n\n<hr>\n\n<p>I'm writing a wrapper over libpcap for a project I'm working on, and to learn Rust (which I just started doing). I'm working on writing a safe Rust over around this right now:</p>\n\n<pre><code>#[link(name = \"pcap\")]\nextern {\n    fn pcap_lookupdev(errormsg: *mut libc::c_char) -&gt; *const libc::c_char;\n}\n</code></pre>\n\n<p>Here's what I've got so far:</p>\n\n<pre><code>fn lookupdev() -&gt; Result&lt;String, String&gt; {\n    // Capacity must be at least PCAP_ERRBUF_SIZE\n    let mut errbuf = [0 as c_char, ..256];\n\n    let result = unsafe {\n        let ptr = pcap_lookupdev(errbuf.as_mut_ptr() as *mut libc::c_char);\n        if ptr.is_null() {\n            None\n        }\n        else {\n            Some(CString::new(ptr, false))\n        }\n    };\n\n    match result {\n          Some(result) =&gt; Ok(result.as_str().unwrap().to_string()),\n          None =&gt; Err(unsafe { String::from_raw_buf(errbuf.as_ptr() as *const u8) })\n    }\n}\n</code></pre>\n\n<p>This works, but I don't like the use from <code>String::from_raw_buf</code>, which will happily walk all over gigabytes of memory instead of stopping when it reaches the end of errbuf.</p>\n\n<p>I can write something that loops over <code>errbuf</code> manually and converts it to a Rust string (stopping at the end of the buffer), but in my mind this is a C FFI idiom for strings (pass an allocated block of memory, where a string can be written) that should be supported by the Rust standard library. However, I could't find anything in the Rust FFI guide nor in the standard library documentation.</p>\n\n<p>What's the best way of handling this FFI case in Rust? Is there at least a <code>String::from_raw_buf_with_maxlen</code> or a <code>String::from_array</code>?</p>\n"}, {"tags": ["data-structures", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420250813, "post_id": 27750985, "comment_id": 43913143, "body": "Creating a <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a> would help you understand the problem and also help us help you."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420255941, "post_id": 27750985, "comment_id": 43913948, "body": "There are lots of questions about linked lists of this nature. Perusing some of those could prove useful as well. <a href=\"http://stackoverflow.com/questions/27742032/boxed-value-does-not-live-long-enough\">Here&#39;s one from earlier today</a> where Chris Morgan does a bang-up job explaining."}], "answers": [{"comments": [{"owner": {"reputation": 37807, "user_id": 293686, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/1426a9fd5267e73d9e30ebaac1bde144?s=128&d=identicon&r=PG", "display_name": "Maur&#237;cio Linhares", "link": "https://stackoverflow.com/users/293686/maur%c3%adcio-linhares"}, "edited": false, "score": 0, "creation_date": 1420253283, "post_id": 27751076, "comment_id": 43913590, "body": "So, how do I represent a data structure when I need &quot;add in the middle&quot; semantics?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 37807, "user_id": 293686, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/1426a9fd5267e73d9e30ebaac1bde144?s=128&d=identicon&r=PG", "display_name": "Maur&#237;cio Linhares", "link": "https://stackoverflow.com/users/293686/maur%c3%adcio-linhares"}, "edited": false, "score": 0, "creation_date": 1420254314, "post_id": 27751076, "comment_id": 43913735, "body": "@Maur&#237;cioLinhares there&#39;s multiple ways of solving your problem, as I alluded to in my last paragraph. You have to decide what is right for your solution."}, {"owner": {"reputation": 36583, "user_id": 42610, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/5ea9e348dc045d53f5659eadf3e695b2?s=128&d=identicon&r=PG", "display_name": "liori", "link": "https://stackoverflow.com/users/42610/liori"}, "edited": false, "score": 0, "creation_date": 1432803648, "post_id": 27751076, "comment_id": 49079599, "body": "I might be a little bit confused, but does Box::new(self) make a new copy of self?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1432435405, "last_edit_date": 1432435405, "creation_date": 1420251177, "answer_id": 27751076, "question_id": 27750985, "link": "https://stackoverflow.com/questions/27750985/cannot-move-out-of-dereference-of-mut-pointer-while-building-a-sorted-linke/27751076#27751076", "title": "`cannot move out of dereference of `&amp;mut`-pointer` while building a sorted linked list", "body": "<p>Here's a <a href=\"http://is.gd/tN9FSE\" rel=\"nofollow\">similar example</a>:</p>\n\n<pre><code>enum E { Hello }\nstruct A(E);\n\nfn main() {\n    let mut a = A(E::Hello);\n    let b = &amp;mut a;\n    let c = b.0;\n}\n</code></pre>\n\n<p>And the errors:</p>\n\n<pre><code>&lt;anon&gt;:7:13: 7:14 error: cannot move out of dereference of `&amp;mut`-pointer\n&lt;anon&gt;:7     let c = b.0;\n                     ^\n&lt;anon&gt;:7:9: 7:10 note: attempting to move value to here\n&lt;anon&gt;:7     let c = b.0;\n                 ^\n&lt;anon&gt;:7:9: 7:10 help: to prevent the move, use `ref c` or `ref mut c` to capture value by reference\n&lt;anon&gt;:7     let c = b.0;\n                 ^\n</code></pre>\n\n<p>Note that the compiler tells you how to prevent the error in this case.</p>\n\n<p>The problem is that your <code>self.value</code> is not <a href=\"http://doc.rust-lang.org/std/kinds/trait.Copy.html\" rel=\"nofollow\"><code>Copy</code>able</a>. That means that when you assign it, you are <em>moving</em> it out of the <code>NodeItem</code> (<code>self</code>), thus leaving it no longer fully defined! This would be a bad thing, so Rust prevents you from doing it.</p>\n\n<p>You have to decide what the right way of fixing your problem is. The easiest is to ensure that <code>T</code> is copyable (or maybe <a href=\"http://doc.rust-lang.org/std/clone/trait.Clone.html\" rel=\"nofollow\"><code>Clone</code>able</a>, depending on your data). However, you probably <em>don't</em> want to be copying your data all around. I would investigate changing your code to prevent copying the node around and just updating entries. You may need to use something like <a href=\"http://doc.rust-lang.org/std/mem/fn.swap.html\" rel=\"nofollow\"><code>swap</code></a>.</p>\n\n<h3>Where I take all the fun out of exploring a new language</h3>\n\n<pre><code>#[derive(Debug)]\nstruct Node&lt;T&gt; {\n    v: T,\n    next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\n\nimpl&lt;T&gt; Node&lt;T&gt; {\n    fn new(v: T) -&gt; Node&lt;T&gt; { Node { v: v, next: None } }\n\n    fn push_front(self, head: T) -&gt; Node&lt;T&gt; {\n        Node {\n            v: head,\n            next: Some(Box::new(self)),\n        }\n    }\n\n    fn push_back(&amp;mut self, tail: T) {\n        match self.next {\n            Some(ref mut next) =&gt; next.push_back(tail), \n            None =&gt; self.next = Some(Box::new(Node::new(tail))),\n        }\n    }\n\n    fn push_after(&amp;mut self, v: T) {\n        let old_next = self.next.take();\n\n        let new_next = Node {\n            v: v,\n            next: old_next,\n        };\n\n        self.next = Some(Box::new(new_next));\n    }\n}\n\nfn main() {\n    let mut n = Node::new(2u8);\n    n.push_back(3u8);\n    let mut n = n.push_front(0u8);\n    n.push_after(1u8);\n\n    println!(\"{:?}\", n);\n}\n</code></pre>\n"}], "owner": {"reputation": 37807, "user_id": 293686, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/1426a9fd5267e73d9e30ebaac1bde144?s=128&d=identicon&r=PG", "display_name": "Maur&#237;cio Linhares", "link": "https://stackoverflow.com/users/293686/maur%c3%adcio-linhares"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 386, "favorite_count": 0, "accepted_answer_id": 27751076, "answer_count": 1, "score": 2, "last_activity_date": 1432435405, "creation_date": 1420250283, "last_edit_date": 1420251264, "question_id": 27750985, "link": "https://stackoverflow.com/questions/27750985/cannot-move-out-of-dereference-of-mut-pointer-while-building-a-sorted-linke", "title": "`cannot move out of dereference of `&amp;mut`-pointer` while building a sorted linked list", "body": "<p>So, I'm learning Rust and decided to build a sorted linked list. Everything looks nice until I reach the add method, here's the code:</p>\n\n<pre><code>struct NodeItem&lt;'a, V:'a + Ord&gt; {\n  value : V,\n  next : Box&lt;Option&lt;NodeItem&lt;'a,V&gt;&gt;&gt; // '\n}\n\nimpl &lt;'a, V:'a + Ord&gt; NodeItem&lt;'a,V&gt; { // '\n\n  fn new(value : V) -&gt; NodeItem&lt;'a,V&gt; { // '\n    NodeItem { value : value, next : box None }\n  }\n\n  fn add(&amp;mut self, value : V) {\n\n    match self.value.cmp(&amp;value) {\n      Less =&gt; {\n        self.next = box Some(NodeItem {value: self.value, next : self.next });\n        self.value = value;\n      },\n      Equal | Greater =&gt; {\n        match *self.next {\n          Some(ref mut next) =&gt; next.add(value),\n          None =&gt; self.next = box Some(NodeItem::new(value)),\n        }\n      },\n    }\n\n  }\n\n}\n</code></pre>\n\n<p>The compiler complains with:</p>\n\n<pre><code>/home/mauricio/projects/rust/data_structures/src/lists/mod.rs:16:47: 16:51 error: cannot move out of dereference of `&amp;mut`-pointer\n/home/mauricio/projects/rust/data_structures/src/lists/mod.rs:16         self.next = box Some(NodeItem {value: self.value, next : self.next });\n                                                                                                               ^~~~\n/home/mauricio/projects/rust/data_structures/src/lists/mod.rs:16:66: 16:70 error: cannot move out of dereference of `&amp;mut`-pointer\n/home/mauricio/projects/rust/data_structures/src/lists/mod.rs:16         self.next = box Some(NodeItem {value: self.value, next : self.next });\n</code></pre>\n\n<p>What is exactly the problem here? I understand that I am moving a reference somewhere else, but shouldn't the lifetime parameters show that these items have a related \"life\"?</p>\n\n<p>This is using the nightly from 21/12/14.</p>\n"}, {"tags": ["linker", "operating-system", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420235603, "post_id": 27748964, "comment_id": 43909318, "body": "I thought this sounded familiar. You should include a link to the <a href=\"https://github.com/rust-lang/rust/issues/20379\" rel=\"nofollow noreferrer\">Rust issue you opened</a>, which was then closed."}, {"owner": {"reputation": 1010, "user_id": 2067665, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/0c86e226759ee03937af84103fd1b1ab?s=128&d=identicon&r=PG", "display_name": "ragingSloth", "link": "https://stackoverflow.com/users/2067665/ragingsloth"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420237022, "post_id": 27748964, "comment_id": 43909795, "body": "I hadn&#39;t seen the last post about relocation models haha"}], "answers": [{"comments": [{"owner": {"reputation": 1010, "user_id": 2067665, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/0c86e226759ee03937af84103fd1b1ab?s=128&d=identicon&r=PG", "display_name": "ragingSloth", "link": "https://stackoverflow.com/users/2067665/ragingsloth"}, "edited": false, "score": 0, "creation_date": 1420236948, "post_id": 27749102, "comment_id": 43909768, "body": "thanks for all the help the past few weeks. that totally did it."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1420235973, "last_edit_date": 1495540674, "creation_date": 1420235973, "answer_id": 27749102, "question_id": 27748964, "link": "https://stackoverflow.com/questions/27748964/how-do-i-provide-or-remove-the-dependency-on-global-offset-table/27749102#27749102", "title": "How do I provide or remove the dependency on _GLOBAL_OFFSET_TABLE_?", "body": "<p>Based on these two comments in the Rust issue you opened:</p>\n\n<blockquote>\n  <p>If you don't want the pic or dynamic-no-pic relocation models then you should ask for the static model.</p>\n</blockquote>\n\n<p>And</p>\n\n<blockquote>\n  <p>the relocation model can be controlled via the <code>-C relocation-model=...</code> argument</p>\n</blockquote>\n\n<p>And checking to see <a href=\"https://stackoverflow.com/q/9685699/155423\">what the global offset table is</a> anyway, I think you want to update your compiler command to be:</p>\n\n<pre><code>rustc -O --target i686-unknown-linux-gnu --crate-type lib -o  main.o --emit obj -C relocation-model=static main.rs\n</code></pre>\n"}], "owner": {"reputation": 1010, "user_id": 2067665, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/0c86e226759ee03937af84103fd1b1ab?s=128&d=identicon&r=PG", "display_name": "ragingSloth", "link": "https://stackoverflow.com/users/2067665/ragingsloth"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1296, "favorite_count": 0, "accepted_answer_id": 27749102, "answer_count": 1, "score": 1, "last_activity_date": 1420236026, "creation_date": 1420235184, "last_edit_date": 1420236026, "question_id": 27748964, "link": "https://stackoverflow.com/questions/27748964/how-do-i-provide-or-remove-the-dependency-on-global-offset-table", "title": "How do I provide or remove the dependency on _GLOBAL_OFFSET_TABLE_?", "body": "<p>I'm working on an OS in Rust, and I am encountering the following error when I try to link:</p>\n\n<blockquote>\n  <p>undefined reference to '_GLOBAL_OFFSET_TABLE_'</p>\n</blockquote>\n\n<p>This is caused by, as best as I can tell, any Rust function that invokes another. I also have <code>#[no_std]</code> on. My linker script doesn't include such a reference to <code>_GLOBAL_OFFSET_TABLE_</code>, should it?</p>\n\n<pre><code>OUTPUT_FORMAT(\"binary\")\nENTRY(start)\nphys = 0x0010000;\nSECTIONS\n{\n\n   .text phys : AT(phys) {\n   code = .;\n   *(.text)\n   *(.rodata)\n   . = ALIGN(4096);\n}\n.data : AT(phys + (data - code)) {\n    data = .;\n    *(.data)\n    . = ALIGN(4096);\n}\n.bss : AT(phys + (bss - code)) {\n    bss = .;\n    *(.bss)\n    . = ALIGN(4096);\n}\nend = .;\n}\n</code></pre>\n\n<p>I build with</p>\n\n<pre><code>&gt;nasm -f aout -o start.o start.asm\n&gt;rustc -O --target i686-unknown-linux-gnu --crate-type lib -o  main.o --emit obj main.rs\n&gt;ld -melf_i386 -Tlink.ld -o kernel.bin start.o main.o\nmain.0.rs:(.text.main+0xb): undefined reference to '_GLOBAL_OFFSET_TABLE_'\n&gt;nm main.o         \n         U _GLOBAL_OFFSET_TABLE_\n00000000 T main\n00000000 T memcmp\n... \n</code></pre>\n\n<p>How do I include this symbol? Is there a way to remove my dependency on it? The full code with Makefiles is here if anyone wants to try building it: <a href=\"https://github.com/ragingSloth/rustboot\" rel=\"nofollow\">https://github.com/ragingSloth/rustboot</a></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 2844, "user_id": 1672895, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/e2c0bc44937a75bf39547dd8711a2775?s=128&d=identicon&r=PG", "display_name": "carlodurso", "link": "https://stackoverflow.com/users/1672895/carlodurso"}, "edited": false, "score": 0, "creation_date": 1420228590, "post_id": 27747785, "comment_id": 43906700, "body": "As it&#39;s currently written, it\u2019s hard to tell exactly what you&#39;re asking. See the <a href=\"http://stackoverflow.com/help/how-to-ask\">How to Ask page</a> for help clarifying this question."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420228783, "post_id": 27747785, "comment_id": 43906774, "body": "You may also want to add some background to your question. It really sounds like you are asking how to have global mutable shared data, which is pretty against-the-grain for Rust."}, {"owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "edited": false, "score": 1, "creation_date": 1420263120, "post_id": 27747785, "comment_id": 43915091, "body": "You might be able to adapt Kimundi&#39;s gist be having it implement DerefMut instead of Deref."}], "answers": [{"comments": [{"owner": {"reputation": 101, "user_id": 4413523, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/899248bcf5b5ffe957758ad482c82128?s=128&d=identicon&r=PG", "display_name": "Jack", "link": "https://stackoverflow.com/users/4413523/jack"}, "edited": false, "score": 1, "creation_date": 1420250062, "post_id": 27747898, "comment_id": 43913006, "body": "Thank you.  Your link to stdin is exactly what I&#39;m looking for and also a great example of when this is appropriate."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 11, "last_activity_date": 1585682416, "last_edit_date": 1585682416, "creation_date": 1420229060, "answer_id": 27747898, "question_id": 27747785, "link": "https://stackoverflow.com/questions/27747785/how-to-create-a-static-mutable-hashmap/27747898#27747898", "title": "How to create a static mutable hashmap?", "body": "<p>For maintained answers, see <a href=\"https://stackoverflow.com/q/27791532/155423\">How do I create a global, mutable singleton?</a>, as this question should have been marked as a duplicate.</p>\n\n<hr>\n\n<p>Seeing as how you already have a solution for a global object that is non-mutable, perhaps you can use one of the <a href=\"https://doc.rust-lang.org/std/cell/index.html\" rel=\"nofollow noreferrer\"><code>cell</code></a> containers to add interior mutability?</p>\n\n<p>Realistically, this sounds like a a <em>bad idea</em>. Global mutable state is problematic. Why can't you pass in a mutable hashmap to the methods / objects that need it?</p>\n\n<p>You may also what to check out <a href=\"https://github.com/rust-lang/rust/blob/4b40bc85cbc1d072179c92ce01655db0272aa598/src/libstd/io/stdio.rs#L215-L245\" rel=\"nofollow noreferrer\">the implementation of <code>stdin</code></a>, which provides safe access to a true global singleton.</p>\n"}], "owner": {"reputation": 101, "user_id": 4413523, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/899248bcf5b5ffe957758ad482c82128?s=128&d=identicon&r=PG", "display_name": "Jack", "link": "https://stackoverflow.com/users/4413523/jack"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4001, "favorite_count": 2, "closed_date": 1420280876, "accepted_answer_id": 27747898, "answer_count": 1, "score": 7, "last_activity_date": 1585682416, "creation_date": 1420228454, "last_edit_date": 1420228841, "question_id": 27747785, "link": "https://stackoverflow.com/questions/27747785/how-to-create-a-static-mutable-hashmap", "closed_reason": "Needs details or clarity", "title": "How to create a static mutable hashmap?", "body": "<p>How do I create a static mutable hashmap?  I am ok with unsafe code.</p>\n\n<p>The normal static does not allow globals with constructors.</p>\n\n<p>As an example, I want what is at <a href=\"https://gist.github.com/Kimundi/8782487\" rel=\"noreferrer\">https://gist.github.com/Kimundi/8782487</a> but HASHMAP to be mutable.</p>\n\n<p>I understand that global shared mutable state is not what very rust-ish but I just want to know if such a thing is possible.</p>\n"}, {"tags": ["closures", "rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420241838, "post_id": 27750044, "comment_id": 43911211, "body": "Creating a new set of traits is an interesting idea! I assume the sugaring is pretty tied to the compiler, and that there&#39;s nothing I can do as an end user to steal it for new traits?"}, {"owner": {"reputation": 6718, "user_id": 2455707, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/768bc63471394edee20bcd4131186118?s=128&d=identicon&r=PG", "display_name": "reem", "link": "https://stackoverflow.com/users/2455707/reem"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420290449, "post_id": 27750044, "comment_id": 43921016, "body": "You might be able to do something like blanket implement the new traits for the old traits, then you&#39;d get implicit &quot;conversion&quot; from closure syntax to the unsafe traits. You still won&#39;t get the functional call syntax, but that&#39;s a fine tradeoff I think."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420317369, "post_id": 27750044, "comment_id": 43929466, "body": "<a href=\"http://is.gd/OgyWaO\" rel=\"nofollow noreferrer\">I gave that a shot</a>, but it&#39;s not as useful as it could have been. The problem is that the compiler still complains when we &quot;call&quot; the unsafe fn in the closure, because it doesn&#39;t know that the <code>unsafe</code> will be passed through, so there&#39;s no chance of using the sugar."}], "tags": [], "owner": {"reputation": 6718, "user_id": 2455707, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/768bc63471394edee20bcd4131186118?s=128&d=identicon&r=PG", "display_name": "reem", "link": "https://stackoverflow.com/users/2455707/reem"}, "is_accepted": true, "score": 2, "last_activity_date": 1420241714, "creation_date": 1420241714, "answer_id": 27750044, "question_id": 27746662, "link": "https://stackoverflow.com/questions/27746662/can-i-create-an-unsafe-closure/27750044#27750044", "title": "Can I create an &quot;unsafe closure&quot;?", "body": "<p>It's not possible to create an <code>unsafe</code> closure in the same vein as an <code>unsafe fn</code>, since closures are just anonymous types with implementations of the <code>Fn</code>, <code>FnMut</code>, and/or <code>FnOnce</code> family of traits. Since those traits do not have <code>unsafe</code> methods, it's not possible to create a closure which is <code>unsafe</code> to call.</p>\n\n<p>You could create a second set of closure traits with <code>unsafe</code> methods, then write implementations for those, but you would lose much of the closure sugar.</p>\n"}], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 876, "favorite_count": 0, "accepted_answer_id": 27750044, "answer_count": 1, "score": 4, "last_activity_date": 1420241714, "creation_date": 1420222760, "question_id": 27746662, "link": "https://stackoverflow.com/questions/27746662/can-i-create-an-unsafe-closure", "title": "Can I create an &quot;unsafe closure&quot;?", "body": "<p>I have some code that, when simplified, looks like:</p>\n\n<pre><code>fn foo() -&gt; Vec&lt;u8&gt; {\n    unsafe {\n        unsafe_iterator().map(|n| wrap_element(n)).collect()\n    }\n}\n</code></pre>\n\n<p>The iterator returns items that would be invalidated if the underlying data changed. Sadly, I'm unable to rely on the normal Rust mechanism of <code>mut</code> here (I'm doing some... odd things).</p>\n\n<p>To rectify the unsafe-ness, I traverse the iterator all at once and make copies of each item (via <code>wrap_element</code>) and then throw it all into a <code>Vec</code>. This works because nothing else has a chance to come in and modify the underlying data.</p>\n\n<p>The code works as-is now, but since I use this idiom a few times, I wanted to DRY up my code a bit:</p>\n\n<pre><code>fn zap&lt;F&gt;(f: F) -&gt; Vec&lt;u8&gt;\n    where F: FnOnce() -&gt; UnsafeIter\n{\n    f().map(|n| wrap_element(n)).collect()\n}\n\nfn foo() -&gt; Vec&lt;u8&gt; {\n    zap(|| unsafe { unsafe_iterator() }) // Unsafe block\n}\n</code></pre>\n\n<p>My problem with this solution is that the call to <code>unsafe_iterator</code> is unsafe, and it's the <code>wrap_element</code> / <code>collect</code> that makes it safe again. The way that the code is structured does not convey that at all.</p>\n\n<p>I'd like to somehow mark my closure as being <code>unsafe</code> and then it's <code>zap</code>s responsibility to make it safe again.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1420202576, "post_id": 27742424, "comment_id": 43895655, "body": "<code>ref mut next_node</code> and <code>&amp;mut **next_node</code> should be written <code>box ref mut next_node</code> and <code>next_node</code>."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1420202746, "post_id": 27742424, "comment_id": 43895726, "body": "@ChrisMorgan Thanks a lot, incorporated that!"}], "tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "is_accepted": false, "score": 5, "last_activity_date": 1420202520, "creation_date": 1420202520, "answer_id": 27742424, "question_id": 27742032, "link": "https://stackoverflow.com/questions/27742032/boxed-value-does-not-live-long-enough/27742424#27742424", "title": "Boxed value does not live long enough", "body": "<p>Your attempts to fix the other compiler errors have, unfortunately, led you to a dark place of inconsistency. First you need to make up your mind whether you want a <code>Box&lt;List&gt;</code> or a <code>List</code> as your handle for the head of a (sub-)list. Let's go with <code>List</code> because that is more flexible and generally the path of least resistance.</p>\n\n<p>Then, you need to realize there is a difference between <code>mut list: &amp;List</code> and <code>list: &amp;mut List</code>. The first is a read-only reference which you can change to point at other read-only things. The second is a read-write reference which you can <em>not</em> change to point at other read-write things. There's also <code>mut list: &amp;mut List</code> because these two capabilities are orthogonal.</p>\n\n<p>In <code>add</code>, when you write <code>list = ...</code>, you are only affecting <em>your local variable</em>. It has no effect on the caller. You want to change the list node the caller sees! Since we said we wanted to deal with <code>List</code>, not boxes, we'll change the contents of the list nodes that exist (replacing the final <code>End</code> with a <code>Node(..., box End)</code>). That is, signature and code change as follows:</p>\n\n<pre><code>fn add(list: &amp;mut List, x: uint) {\n    match *list {\n        List::End =&gt; *list = List::Node(x, box List::End),\n        List::Node(_, box ref mut next_node) =&gt; add(next_node, x),\n    }\n}\n</code></pre>\n\n<p>Note that <code>*list =</code> is different from <code>list =</code>, in that we now change the contents of the list node in-place instead of making our local reference point at a different node.</p>\n\n<p>For consistency and ergonomics (and a tiny bit of efficiency), you should probably change <code>new</code> to return a bare <code>List</code>, i.e.:</p>\n\n<pre><code>fn new() -&gt; List {\n    List::End\n}\n</code></pre>\n\n<p>This also saves you all the nasty reborrowing (<code>&amp;*</code>) in the calls:</p>\n\n<pre><code>let list = new(); // type: List\nadd(&amp;mut list, 10);\n</code></pre>\n\n<p>Finally, as for why the box did not live long enough: Well, you basically created a local/temporary box, took a reference to it, and then attempted to pass on the reference without keeping the box alive. A box <a href=\"http://doc.rust-lang.org/guide-ownership.html\" rel=\"noreferrer\">without an owner</a> is deallocated, so you need to give it an owner. In the fixed code above, the owner is the <code>next</code> field of the <code>List::Node</code> we create and write to the <code>&amp;mut List</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 9, "last_activity_date": 1420203088, "creation_date": 1420203088, "answer_id": 27742538, "question_id": 27742032, "link": "https://stackoverflow.com/questions/27742032/boxed-value-does-not-live-long-enough/27742538#27742538", "title": "Boxed value does not live long enough", "body": "<p>I think you\u2019re missing some key details of Rust; there are three things that I think we need to deal with:</p>\n\n<ol>\n<li>How patterns work;</li>\n<li>The distinction between immutable (<code>&amp;</code>) and mutable (<code>&amp;mut</code>) references;</li>\n<li>How Rust\u2019s ownership model works (because of your <code>&amp;*box</code> attempts).</li>\n</ol>\n\n<p>I\u2019ll deal with the patterns part first; in <code>fn add(mut list: &amp;List, x: uint)</code>, there are two patterns being used, <code>mut list</code> and <code>x</code>. Other examples of patterns are the left hand side of <code>let lhs = rhs;</code> and the bit before the <code>=&gt;</code> on each branch of a <code>match</code> expression. How are these patterns applied to calls, effectively? It\u2019s really like you\u2019re doing this:</p>\n\n<pre><code>fn add(__arg_0: &amp;List, __arg_1: uint) {\n    let mut list = __arg_0;\n    let x = __arg_1;\n    \u2026\n}\n</code></pre>\n\n<p>Perhaps that way of looking at things will make it clearer; the signature of a function <em>does not take the patterns that the variables are bound to into account at all</em>. Your function signature is actually in canonical form <code>fn add(&amp;List, uint)</code>. The <code>mut list</code> part just means that you are binding the <code>&amp;List</code> value to a mutable name; that is, you can assign a new value to the <code>list</code> name, but it has no effect outside the function, it\u2019s purely a matter of the binding of a variable to a location.</p>\n\n<p>Now onto the second issue: learn the distinction between immutable references (type <code>&amp;T</code>, value <code>&amp;x</code>) and mutable references (type <code>&amp;mut T</code>, value <code>&amp;x</code>). These are so fundamental that I won\u2019t go into much detail here\u2014they\u2019re documented sufficiently elsewhere and you should probably read those things. Suffice it to say: if you wish to mutate something, you need <code>&amp;mut</code>, not <code>&amp;</code>, so your <code>add</code> method needs to take <code>&amp;mut List</code>.</p>\n\n<p>The third issue, that of ownership: in Rust, each object is owned in <em>precisely one</em> location; there is no garbage collection or anything, and this uniqueness of ownership means that as soon as an object passes out of scope it is destroyed. In this case, the offending expression is <code>&amp;*(box List::Node(x, box List::End))</code>. You have boxed a value, but you haven\u2019t actually stored it anywhere: you have just tried to take a reference to the value contained inside it, but the box will be immediately dropped. What you actually want in this case is to modify the contents of the <code>List</code>; you want to write <code>*list = List::Node(x, box List::End)</code>, meaning \u201cstore a <code>List::Node</code> value inside the contents of <code>list</code>\u201d instead of <code>list = &amp;\u2026</code>, meaning \u201cassign to the variable <code>list</code> a new reference\u201d.</p>\n\n<p>You\u2019ve also gone a tad overboard with the boxing of values; I\u2019d tend to say that <code>new()</code> should return a <code>List</code>, not a <code>Box&lt;List&gt;</code>, though the question is slightly open to debate. Anyway, here\u2019s the <code>add</code> method that I end up with:</p>\n\n<pre><code>fn add(list: &amp;mut List, x: uint) {\n    match *list {\n        List::End =&gt; *list = List::Node(x, box List::End),\n        List::Node(_, box ref mut next_node) =&gt; add(next_node, x),\n    }\n}\n</code></pre>\n\n<p>The main bit you may have difficulty with there is the pattern <code>box ref mut next_node</code>. The <code>box ref mut</code> part reads \u201ctake the value out of its box, then create a mutable reference to that value\u201d; hence, given a <code>Box&lt;List&gt;</code>, it produces a <code>&amp;mut List</code> referring to the contents of that box. Remember that patterns are completely back to front compared with normal expressions.</p>\n\n<p>Finally, I would strongly recommend using <code>impl</code>s for all of this, putting all the methods on the <code>List</code> type:</p>\n\n<pre><code>enum List {\n    Node(uint, Box&lt;List&gt;),\n    End,\n}\n\nimpl List {\n    fn new() -&gt; List {\n        List::End\n    }\n\n    fn add(&amp;mut self, x: uint) {\n        match *self {\n            List::End =&gt; *self = List::Node(x, box List::End),\n            List::Node(_, box ref mut next_node) =&gt; next_node.add(x),\n        }\n    }\n}\n\nfn main() {\n    let mut list = List::new();\n\n    list.add(10);\n}\n</code></pre>\n"}], "owner": {"reputation": 3008, "user_id": 3204951, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/8aca84582c72a22e9cb5245571103d92?s=128&d=identicon&r=PG", "display_name": "Nate Mara", "link": "https://stackoverflow.com/users/3204951/nate-mara"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 802, "favorite_count": 0, "accepted_answer_id": 27742538, "answer_count": 2, "score": 5, "last_activity_date": 1420203088, "creation_date": 1420200750, "question_id": 27742032, "link": "https://stackoverflow.com/questions/27742032/boxed-value-does-not-live-long-enough", "title": "Boxed value does not live long enough", "body": "<p>I'm trying to implement a cons list in Rust as an exercise. I've managed to solve all of my compiler errors except this one:</p>\n\n<pre><code>Compiling list v0.0.1 (file:///home/nate/git/rust/list)\n/home/nate/git/rust/list/src/main.rs:18:24: 18:60 error: borrowed value does not live long enough\n/home/nate/git/rust/list/src/main.rs:18         List::End =&gt; list = &amp;*(box List::Node(x, box List::End)),\n                                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/nate/git/rust/list/src/main.rs:16:34: 21:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 16:33...\n/home/nate/git/rust/list/src/main.rs:16 fn add(mut list: &amp;List, x: uint) {\n/home/nate/git/rust/list/src/main.rs:17     match *list {\n/home/nate/git/rust/list/src/main.rs:18         List::End =&gt; list = &amp;*(box List::Node(x, box List::End)),\n/home/nate/git/rust/list/src/main.rs:19         List::Node(_, ref next_node) =&gt; add(&amp;**next_node, x),\n/home/nate/git/rust/list/src/main.rs:20     }\n/home/nate/git/rust/list/src/main.rs:21 }\n/home/nate/git/rust/list/src/main.rs:18:16: 18:60 note: ...but borrowed value is only valid for the expression at 18:15\n/home/nate/git/rust/list/src/main.rs:18         List::End =&gt; list = &amp;*(box List::Node(x, box List::End)),\n                                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\nCould not compile `list`.\n\nTo learn more, run the command again with --verbose.\n</code></pre>\n\n<p>And the code that I'm trying to compile:</p>\n\n<pre><code>enum List {\n    Node(uint, Box&lt;List&gt;),\n    End,\n}\n\nfn main() {\n    let mut list = new();\n\n    add(&amp;*list, 10);\n    //add(list, 20);\n    //add(list, 30);\n\n    print(&amp;*list);\n}\n\nfn add(mut list: &amp;List, x: uint) {\n    match *list {\n        List::End =&gt; list = &amp;*(box List::Node(x, box List::End)),\n        List::Node(_, ref next_node) =&gt; add(&amp;**next_node, x),\n    }\n}\n\nfn new() -&gt; Box&lt;List&gt; {\n    box List::End\n}\n</code></pre>\n\n<p>So why don't the boxed values live long enough? Is it because I immediately dereference them? I tried it this way:</p>\n\n<pre><code>match *list {\n    List::End =&gt; {\n        let end = box List::Node(x, box List::End);\n        list = &amp;*end;\n    }\n    List::Node(_, ref next_node) =&gt; add(&amp;**next_node, x),\n}\n</code></pre>\n\n<p>But I got exactly the same error. What am I missing?</p>\n"}, {"tags": ["rust", "travis-ci"], "comments": [{"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 0, "creation_date": 1420201475, "post_id": 27741937, "comment_id": 43895167, "body": "Is there a reason why you aren&#39;t using the nightlies? It&#39;s pretty hard at this point to not use them, I think."}, {"owner": {"reputation": 13, "user_id": 4412341, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-VIVkl27HnUU/AAAAAAAAAAI/AAAAAAAAEws/CKGT8oTpt1Y/photo.jpg?sz=128", "display_name": "Johan Brinch", "link": "https://stackoverflow.com/users/4412341/johan-brinch"}, "reply_to_user": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 0, "creation_date": 1420201676, "post_id": 27741937, "comment_id": 43895258, "body": "Mostly because I want to focus on moving the project forward instead of upgrading the code :-) I did start out using the nightlies, but I have limited time and after adding a few dependencies it took too much of it to upgrade code and find compatible versions of dependencies."}, {"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 0, "creation_date": 1420204109, "post_id": 27741937, "comment_id": 43896270, "body": "Yeah, I think you&#39;re stuck between a rock and a hard place. If you have a lot of dependencies, it can be frustrating waiting for them to update. At this point, <code>0.12</code> feels ancient unfortunately. :-/"}, {"owner": {"reputation": 13, "user_id": 4412341, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-VIVkl27HnUU/AAAAAAAAAAI/AAAAAAAAEws/CKGT8oTpt1Y/photo.jpg?sz=128", "display_name": "Johan Brinch", "link": "https://stackoverflow.com/users/4412341/johan-brinch"}, "reply_to_user": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 0, "creation_date": 1422383290, "post_id": 27741937, "comment_id": 44723964, "body": "Indeed. I&#39;m going to upgrade to 1.0 alpha now. All my dependencies have upgraded already. Hopefully the friendly compiler will have helpful suggestions in this endeavour; there&#39;s definitely a lot of changes."}], "answers": [{"comments": [{"owner": {"reputation": 13, "user_id": 4412341, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-VIVkl27HnUU/AAAAAAAAAAI/AAAAAAAAEws/CKGT8oTpt1Y/photo.jpg?sz=128", "display_name": "Johan Brinch", "link": "https://stackoverflow.com/users/4412341/johan-brinch"}, "edited": false, "score": 0, "creation_date": 1422383182, "post_id": 27744641, "comment_id": 44723889, "body": "This is probably more work than it is worth, specially now that Rust 1.0 is near. In fact, I think I&#39;ll upgrade to 1.0 alpha now that it&#39;s been announced. Thanks for the writeout though!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1420213438, "creation_date": 1420213438, "answer_id": 27744641, "question_id": 27741937, "link": "https://stackoverflow.com/questions/27741937/how-to-make-travis-ci-work-with-rust-0-12-0-and-cargo/27744641#27744641", "title": "How to make Travis CI work with Rust 0.12.0 and Cargo?", "body": "<p>I agree that tracking nightly is probably the best bet. If there are dependencies you rely on that aren't being updated, then maybe that's a sign that they wont be updated come 1.0 time, either!</p>\n\n<p>All that being said, Travis does allow you to install things before your build. This is completely untested, but you might be able to do something like</p>\n\n<pre><code>before_script:\n  - wget https://static.rust-lang.org/dist/rust-0.12.0-x86_64-unknown-linux-gnu.tar.gz\n  - tar -xvf rust-0.12.0-x86_64-unknown-linux-gnu.tar.gz\n  - ./rust-0.12.0-x86_64-unknown-linux-gnu/install.sh --prefix /tmp/rust-0.12/\n  - export PATH=$PATH:$PWD/tmp/rust-0.12/bin\n  - export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PWD/tmp/rust-0.12/lib\n</code></pre>\n\n<p>This would download Rust 0.12, unpack and install it somewhere writable (doesn't really matter where). Then you setup env vars to point out where Rust is. Do the same to download a compatible version of Cargo.</p>\n\n<p>If Travis has a \"bare\" language pack, that would be the best. Otherwise you could try using the Rust buildpack, or maybe just anything else (to avoid dealing with multiple <code>rustc</code> versions).</p>\n"}], "owner": {"reputation": 13, "user_id": 4412341, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-VIVkl27HnUU/AAAAAAAAAAI/AAAAAAAAEws/CKGT8oTpt1Y/photo.jpg?sz=128", "display_name": "Johan Brinch", "link": "https://stackoverflow.com/users/4412341/johan-brinch"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 266, "favorite_count": 1, "accepted_answer_id": 27744641, "answer_count": 1, "score": 1, "last_activity_date": 1420213438, "creation_date": 1420200286, "question_id": 27741937, "link": "https://stackoverflow.com/questions/27741937/how-to-make-travis-ci-work-with-rust-0-12-0-and-cargo", "title": "How to make Travis CI work with Rust 0.12.0 and Cargo?", "body": "<p>I am trying to make Travis CI build and test the contents of my GitHub repository, which is compatible with Rust 0.12.0 and an older Cargo:</p>\n\n<pre><code>rustc 0.12.0 (ba4081a5a 2014-10-07 13:44:41 -0700)\ncargo 0.0.1-pre-nightly (861c07f 2014-10-07 23:29:57 +0000)\n</code></pre>\n\n<p>I have specified Rust 0.12.0 in the .travis.yml:</p>\n\n<pre><code>language: rust\nrust: 0.12.0\nscript:\n  - cargo build --verbose\n  - cargo test --verbose\n  - rustdoc --test README.md -L target\n  - cargo doc\n</code></pre>\n\n<p>The issue I seem to be hitting is that Travis will pick the latest Cargo nightly:\n    cargo 0.0.1-pre-nightly (fd5d7a9 2014-12-25 04:28:40 +0000)</p>\n\n<p>But this newer version is incompatible with Rust 0.12.0, as it is now using --emit=dep-info where it used to use --dep-info:</p>\n\n<pre><code>--dep-info [FILENAME]\n                    Output dependency info to &lt;filename&gt; after compiling,\n                    in a format suitable for use by Makefiles\n</code></pre>\n\n<p>This gives rustc invocation errors, as the value for is --emit is invalid:</p>\n\n<pre><code>Running `rustc src/sqlite3.rs --crate-name sqlite3 --crate-type lib -g -C metadata=1c7080eec8c6f90d -C extra-filename=-1c7080eec8c6f90d --out-dir target/deps --emit=dep-info,link -L target/deps -L target/deps -Awarnings`\n...\nerror: unknown emission type: `dep-info`\n...\nCould not compile `sqlite3`.\n</code></pre>\n\n<p>I have been looking at other repositories for how to get around this, but it seems they either do not use Cargo with 0.12.0 (which works with Travis) or hit the same issue, like here: <a href=\"https://travis-ci.org/eliovir/rust-ini\" rel=\"nofollow\">https://travis-ci.org/eliovir/rust-ini</a></p>\n\n<p>I have failed to find any repository that works with Travis, rust 0.12.0 and Cargo. If I can specify the version of Cargo somewhere, I would be able to get around this, but I have failed to find a way to do so in the .travis.yml file.</p>\n\n<p>Of course, with Rust 1.0 coming up, I will just wait for it, if there is no obvious solution that I have overlooked :-)</p>\n"}, {"tags": ["optimization", "vector", "rust"], "comments": [{"owner": {"reputation": 14973, "user_id": 128186, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/46c330659979615fe50c46f5f553b39f?s=128&d=identicon&r=PG", "display_name": "Arjan", "link": "https://stackoverflow.com/users/128186/arjan"}, "edited": false, "score": 9, "creation_date": 1420152416, "post_id": 27735337, "comment_id": 43882202, "body": "Compile with <code>-O</code>"}, {"owner": {"reputation": 15260, "user_id": 1968182, "user_type": "registered", "accept_rate": 0, "profile_image": "https://i.stack.imgur.com/E5nF2.jpg?s=128&g=1", "display_name": "Ulrich Eckhardt", "link": "https://stackoverflow.com/users/1968182/ulrich-eckhardt"}, "edited": false, "score": 1, "creation_date": 1420152913, "post_id": 27735337, "comment_id": 43882292, "body": "I&#39;d use a set containing the found numbers. Other than that, use a profiler to find out what takes the most time."}, {"owner": {"reputation": 4503, "user_id": 98460, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/bCJzr.jpg?s=128&g=1", "display_name": "OderWat", "link": "https://stackoverflow.com/users/98460/oderwat"}, "reply_to_user": {"reputation": 15260, "user_id": 1968182, "user_type": "registered", "accept_rate": 0, "profile_image": "https://i.stack.imgur.com/E5nF2.jpg?s=128&g=1", "display_name": "Ulrich Eckhardt", "link": "https://stackoverflow.com/users/1968182/ulrich-eckhardt"}, "edited": false, "score": 1, "creation_date": 1420153610, "post_id": 27735337, "comment_id": 43882436, "body": "Compilation with -O makes it about 13 times faster and brings it into the range I had expected! So is that the trick?  No &quot;better use some other types / slices instead of what you did?&quot;. @UlrichEckhardt I think a set will be slower. It may save memory though."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1420153660, "post_id": 27735337, "comment_id": 43882448, "body": "Also note that access to vector elements by index always includes boundary checks. For large numbers it may cause some overhead."}, {"owner": {"reputation": 4503, "user_id": 98460, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/bCJzr.jpg?s=128&g=1", "display_name": "OderWat", "link": "https://stackoverflow.com/users/98460/oderwat"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1420153892, "post_id": 27735337, "comment_id": 43882509, "body": "@VladimirMatveev OK, but what alternatives exists to that (besides using &#39;unsafe&#39; I guess)?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1420158079, "post_id": 27735337, "comment_id": 43883501, "body": "There are methods for unchecked indexing, but the do require <code>unsafe</code>. I suggest you only drop to using them only as a last resort. <i>The</i> proper way to access vector elements without bounds checking is iterators, but I don&#39;t see how they could be used here."}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 8, "creation_date": 1420158895, "post_id": 27735337, "comment_id": 43883645, "body": "You can use a <code>std::collections::Bitv</code> which is effectively a <code>Vec&lt;bool&gt;</code> that packs the booleans into individual bits, cutting memory use 8 times, which dramatically improves cache behaviour."}, {"owner": {"reputation": 4503, "user_id": 98460, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/bCJzr.jpg?s=128&g=1", "display_name": "OderWat", "link": "https://stackoverflow.com/users/98460/oderwat"}, "reply_to_user": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1420166973, "post_id": 27735337, "comment_id": 43885113, "body": "@dbaupp rewriting it with Bitv was trivial. It is slightly faster than the Vec&lt;bool&gt; for the original 100,000,000 and uses a lot less memory. For comparison (on my machine) using 1,000,000,000 as target the original source (with -O) uses 1,001 GB Mem and about 10 seconds. The Bitv version uses 126 MB an 7,9 seconds. Switching to unsafe indexing in my original code did nearly nothing at all. If I did it right that is (<code>unsafe { *sieve.unsafe_mut(j)=true; }</code>)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1420212932, "post_id": 27735337, "comment_id": 43899920, "body": "@OderWat sounds like you should sum all this up as a self-answer!"}, {"owner": {"reputation": 4503, "user_id": 98460, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/bCJzr.jpg?s=128&g=1", "display_name": "OderWat", "link": "https://stackoverflow.com/users/98460/oderwat"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420215008, "post_id": 27735337, "comment_id": 43900870, "body": "@Shepmaster Yes, I guess I will do that. Currently I am still trying out some stuff and even the new nightly &quot;asked&quot; me to change the code (again) :)"}], "owner": {"reputation": 4503, "user_id": 98460, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/bCJzr.jpg?s=128&g=1", "display_name": "OderWat", "link": "https://stackoverflow.com/users/98460/oderwat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 543, "favorite_count": 0, "answer_count": 0, "score": 3, "last_activity_date": 1488254952, "creation_date": 1420151671, "last_edit_date": 1420216325, "question_id": 27735337, "link": "https://stackoverflow.com/questions/27735337/how-to-speed-up-vecbool-in-my-sieve-of-eratosthenes", "title": "How to speed up Vec&lt;bool&gt; in my Sieve of Eratosthenes?", "body": "<p>Why is this straight forward implementation of sieve in Rust so slow and how to speed it up?</p>\n\n<pre><code>use std::num::Float;\nuse std::iter::range_step;\n\nfn eratosthenes(n: uint) -&gt; Vec&lt;bool&gt; {\n    let mut sieve = Vec::from_elem(n+1,true);\n\n    sieve[0] = false;\n    sieve[1] = false;\n\n    let m = ((n as f64).sqrt()) as uint;\n\n    for i in range(0u, m+1) {\n        if sieve[i] {\n            for j in range_step(i*i, n+1, i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    sieve\n}\n\nfn main() {\n    eratosthenes(100_000_000);\n    /*    \n    let mut found = Vec::new();\n    for (i,&amp;sieve) in sieve.iter().enumerate() {\n        if sieve {\n            found.push(i);\n        }\n    }\n    println!(\"Primes found: {}\",found.len());\n    */\n}\n</code></pre>\n\n<p>P.S.: I am not asking about a better algorithm but how to use Vec (Slice?) properly to make this decently fast!</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 8863, "user_id": 592235, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/b07992c174ed5b627e20a32ab9c43ef5?s=128&d=identicon&r=PG", "display_name": "Mike Vella", "link": "https://stackoverflow.com/users/592235/mike-vella"}, "edited": false, "score": 4, "creation_date": 1420147142, "post_id": 27734760, "comment_id": 43880914, "body": "That does work, although it&#39;s a bit ugly! Why does the original error happen? Printing a string in this way is a very common task in almost all modern languages and the error message given is really ambiguous."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1420147448, "post_id": 27734760, "comment_id": 43880973, "body": "It&#39;s not ambigous, but it does make the assumption you know what a &quot;literal&quot; is. <code>&quot;foo&quot;</code> is a string literal. <code>8</code> is a numeric literal. <code>let s = &quot;foo&quot;</code> is assigning the value of a string literal to a variable, and <code>println!(s)</code> is passing a variable to the macro."}, {"owner": {"reputation": 8863, "user_id": 592235, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/b07992c174ed5b627e20a32ab9c43ef5?s=128&d=identicon&r=PG", "display_name": "Mike Vella", "link": "https://stackoverflow.com/users/592235/mike-vella"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1420147610, "post_id": 27734760, "comment_id": 43881009, "body": "@Shepmaster thanks - could you provide an answer providing some more detail on this? I expect many other rust users will encounter this error coming from languages like Python and it would be helpful to have your explanation."}, {"owner": {"reputation": 10216, "user_id": 854207, "user_type": "registered", "accept_rate": 62, "profile_image": "https://i.stack.imgur.com/R6DhK.jpg?s=128&g=1", "display_name": "paul", "link": "https://stackoverflow.com/users/854207/paul"}, "edited": false, "score": 0, "creation_date": 1522962911, "post_id": 27734760, "comment_id": 86375040, "body": "what macro check is the literal (string, numeric and so on) and a variable assigned with let is not any of those things."}, {"owner": {"reputation": 3469, "user_id": 2574612, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/4b008a3d7ce933943329e84c1dbe6db7?s=128&d=identicon&r=PG", "display_name": "Nicholas Pipitone", "link": "https://stackoverflow.com/users/2574612/nicholas-pipitone"}, "edited": false, "score": 0, "creation_date": 1539119298, "post_id": 27734760, "comment_id": 92383834, "body": "It&#39;s not expected that coming from a new language you should just guess how functions work. I mean, compare C++&#39;s <code>std::cout</code>, which has a vastly different syntax. Learning a new language means read tutorials and documentation, and only use what you&#39;ve learned. Otherwise you might get unexpected behavior or even worse, security vulnerabilities (Or just, weird bugs like using a mutable array function&#39;s return value, without realizing that it changed the original array. Rust&#39;s <code>mut</code> fixes that but other languages don&#39;t have <code>mut</code>)."}], "tags": [], "owner": {"reputation": 4874, "user_id": 595304, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/e4cc4011841c2a363c66e259c68a567f?s=128&d=identicon&r=PG", "display_name": "evotopid", "link": "https://stackoverflow.com/users/595304/evotopid"}, "is_accepted": false, "score": 59, "last_activity_date": 1523034086, "last_edit_date": 1523034086, "creation_date": 1420146930, "answer_id": 27734760, "question_id": 27734708, "link": "https://stackoverflow.com/questions/27734708/println-error-expected-a-literal-format-argument-must-be-a-string-literal/27734760#27734760", "title": "println! error: expected a literal / format argument must be a string literal", "body": "<p>This should work:</p>\n\n<pre><code>fn main() {\n    let c = \"hello\";\n    println!(\"{}\", c);\n}\n</code></pre>\n\n<p>The string <code>\"{}\"</code> is a template where <code>{}</code> will be replaced by the next argument passed to <code>println!</code>. </p>\n"}, {"comments": [{"owner": {"reputation": 8863, "user_id": 592235, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/b07992c174ed5b627e20a32ab9c43ef5?s=128&d=identicon&r=PG", "display_name": "Mike Vella", "link": "https://stackoverflow.com/users/592235/mike-vella"}, "edited": false, "score": 1, "creation_date": 1420147927, "post_id": 27734844, "comment_id": 43881102, "body": "Why is it impossible at compile time to tell that c came from a literal at compile time?"}, {"owner": {"reputation": 4874, "user_id": 595304, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/e4cc4011841c2a363c66e259c68a567f?s=128&d=identicon&r=PG", "display_name": "evotopid", "link": "https://stackoverflow.com/users/595304/evotopid"}, "edited": false, "score": 0, "creation_date": 1420148008, "post_id": 27734844, "comment_id": 43881120, "body": "I think the real issue is that if <code>c = &quot;{}&quot;</code> and the macro is resolved at compile time, it would be really hard for the compiler to be sure if it further arguments are to be expected and so the validation wouldn&#39;t be possible to be assured at compile time..."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 4, "creation_date": 1420148138, "post_id": 27734844, "comment_id": 43881157, "body": "I assume it&#39;s not impossible <i>forever</i>, just not right now with how macros are implemented. Macros take <a href=\"http://doc.rust-lang.org/guide-macros.html\" rel=\"nofollow noreferrer\">portions of the AST</a> which I assume only has type information. Your question would involve knowing the source of the type and enough information to determine it&#39;s &quot;safe&quot;. In addition, it might interact poorly with type inference - you want to know the type before it&#39;s been picked yet!"}, {"owner": {"reputation": 8863, "user_id": 592235, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/b07992c174ed5b627e20a32ab9c43ef5?s=128&d=identicon&r=PG", "display_name": "Mike Vella", "link": "https://stackoverflow.com/users/592235/mike-vella"}, "edited": false, "score": 0, "creation_date": 1420148562, "post_id": 27734844, "comment_id": 43881276, "body": "Thanks, I think I understand now (or I&#39;m less confused anyway) - @Shepmaster, could you add that bit about Macros and the AST to your answer? Quite useful info."}, {"owner": {"reputation": 6509, "user_id": 356011, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/d17ff41be1044be6fb5ef186b83efb20?s=128&d=identicon&r=PG", "display_name": "marathon", "link": "https://stackoverflow.com/users/356011/marathon"}, "edited": false, "score": 0, "creation_date": 1502249887, "post_id": 27734844, "comment_id": 78121798, "body": "I&#39;d argue there&#39;s some gain to be had by making this work.  log4rs uses the same macro scheme.  Any time an error string gets kicked back in a result from a function and you want to log it with say <code>error!(err)</code>, you can&#39;t.   You have to use the <code>error!(&quot;{}&quot;, err)</code> hack.   It&#39;s not the end of the world, but it is a mild irritant.  :)"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 58, "last_activity_date": 1523034206, "last_edit_date": 1523034206, "creation_date": 1420147617, "answer_id": 27734844, "question_id": 27734708, "link": "https://stackoverflow.com/questions/27734708/println-error-expected-a-literal-format-argument-must-be-a-string-literal/27734844#27734844", "title": "println! error: expected a literal / format argument must be a string literal", "body": "<p>TL;DR If you don't care <em>why</em> and just want to fix it, see <a href=\"https://stackoverflow.com/a/27734760/155423\">the sibling answer</a>.</p>\n\n<hr>\n\n<p>The reason that </p>\n\n<pre><code>fn main() {\n    let c = \"hello\";\n    println!(c);\n}\n</code></pre>\n\n<p>Cannot work is because the <code>println!</code> macro looks at the string <em>at compile time</em> and verifies that the arguments and argument specifiers match in amount and type (this is a very good thing!). At this point in time, during macro evaluation, it's not possible to tell that <code>c</code> came from a literal or a function or what have you.</p>\n\n<p>Here's an example of what the macro expands out to:</p>\n\n<pre><code>let c = \"hello\";\nmatch (&amp;c,) {\n    (__arg0,) =&gt; {\n        #[inline]\n        #[allow(dead_code)]\n        static __STATIC_FMTSTR: &amp;'static [&amp;'static str] = &amp;[\"\"];\n        ::std::io::stdio::println_args(&amp;::std::fmt::Arguments::new(\n            __STATIC_FMTSTR,\n            &amp;[::std::fmt::argument(::std::fmt::Show::fmt, __arg0)]\n        ))\n    }\n};\n</code></pre>\n\n<p>I don't think that it's actually <em>impossible</em> for the compiler to figure this out, but it would probably take a lot of work (potentially for little gain). Macros operate on portions of the AST, which I assume only has type information. To work in this case, the AST would have to include the source of the identifier and enough information to determine it's \"safe\". In addition, it might interact poorly with type inference - you'd want to know the type before it's been picked yet!</p>\n\n<p>The error message asks for a \"string literal\". There's a <a href=\"https://stackoverflow.com/questions/485119/what-does-the-word-literal-mean\">SO</a> question about what that means, which links to the <a href=\"http://en.wikipedia.org/wiki/Literal_%28computer_programming%29\" rel=\"noreferrer\">Wikipedia entry</a>:</p>\n\n<blockquote>\n  <p>a literal is a notation for representing a fixed value in source code</p>\n</blockquote>\n\n<p><code>\"foo\"</code> is a string literal, <code>8</code> is a numeric literal. <code>let s = \"foo\"</code> is a statement that assigns the value of a string literal to an identifier (variable). <code>println!(s)</code> is a statement that provides an identifier to the macro.</p>\n"}, {"comments": [{"owner": {"reputation": 775, "user_id": 2861181, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/5504ac4f8f9b9d83bc777f7e688af73d?s=128&d=identicon&r=PG", "display_name": "mattforni", "link": "https://stackoverflow.com/users/2861181/mattforni"}, "edited": false, "score": 1, "creation_date": 1457542675, "post_id": 29293481, "comment_id": 59456176, "body": "If you&#39;re going to go with the macro approach, you may as well just put the <code>println!</code> inside the macro, like so <code>macro_rules! cell_format { ( $e:expr ) =&gt; ( println!(&quot;{:&lt;10}&quot;, $e) ); }</code>"}], "tags": [], "owner": {"reputation": 677, "user_id": 1091016, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/13c049617eeaa4993d5639457f520f83?s=128&d=identicon&r=PG", "display_name": "sol_var", "link": "https://stackoverflow.com/users/1091016/sol-var"}, "is_accepted": false, "score": 3, "last_activity_date": 1427431574, "creation_date": 1427431574, "answer_id": 29293481, "question_id": 27734708, "link": "https://stackoverflow.com/questions/27734708/println-error-expected-a-literal-format-argument-must-be-a-string-literal/29293481#29293481", "title": "println! error: expected a literal / format argument must be a string literal", "body": "<p>If you really want to define the first argument of println! in one place, I found a way to do it.  You can use a macro:</p>\n\n<pre><code>macro_rules! hello {() =&gt; (\"hello\")};\nprintln!(hello!());\n</code></pre>\n\n<p>Doesn't look too useful here, but I wanted to use the same formatting in a few places, and in this case the method was very helpful:</p>\n\n<pre><code>macro_rules! cell_format {() =&gt; (\"{:&lt;10}\")};  // Pads with spaces on right\n                                              // to fill up 10 characters\nprintln!(cell_format!(), \"Foo\");\nprintln!(cell_format!(), 456);\n</code></pre>\n\n<p>The macro saved me from having to duplicate the formatting option in my code.</p>\n\n<p>You could also, obviously, make the macro more fancy and take arguments if necessary to print different things with different arguments.</p>\n"}, {"tags": [], "owner": {"reputation": 10380, "user_id": 530634, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/c9929d2d4c53790b35e9cf7a8e566b05?s=128&d=identicon&r=PG", "display_name": "tjb", "link": "https://stackoverflow.com/users/530634/tjb"}, "is_accepted": false, "score": 3, "last_activity_date": 1523034708, "last_edit_date": 1523034708, "creation_date": 1467547927, "answer_id": 38169829, "question_id": 27734708, "link": "https://stackoverflow.com/questions/27734708/println-error-expected-a-literal-format-argument-must-be-a-string-literal/38169829#38169829", "title": "println! error: expected a literal / format argument must be a string literal", "body": "<p>If your format string will be reused only a moderate number of times, and only some variable data will be changed, then a small function may be a better option than a macro:</p>\n\n<pre><code>fn pr(x: &amp;str) {\n    println!(\"Some stuff that will always repeat, something variable: {}\", x);\n}\n\npr(\"I am the variable data\");\n</code></pre>\n\n<p>Outputs</p>\n\n<blockquote>\n  <p>Some stuff that will always repeat, something variable: I am the variable data</p>\n</blockquote>\n"}], "owner": {"reputation": 8863, "user_id": 592235, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/b07992c174ed5b627e20a32ab9c43ef5?s=128&d=identicon&r=PG", "display_name": "Mike Vella", "link": "https://stackoverflow.com/users/592235/mike-vella"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 27219, "favorite_count": 15, "accepted_answer_id": 27734844, "answer_count": 4, "score": 66, "last_activity_date": 1523034708, "creation_date": 1420146614, "last_edit_date": 1515986932, "question_id": 27734708, "link": "https://stackoverflow.com/questions/27734708/println-error-expected-a-literal-format-argument-must-be-a-string-literal", "title": "println! error: expected a literal / format argument must be a string literal", "body": "<p>This extremely simple Rust program:</p>\n\n<pre><code>fn main() {\n    let c = \"hello\";\n    println!(c);\n}\n</code></pre>\n\n<p>throws the following compile-time error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: expected a literal\n --&gt; src/main.rs:3:14\n  |\n3 |     println!(c);\n  |              ^\n</code></pre>\n\n<p>In previous versions of Rust, the error said:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: format argument must be a string literal.\n     println!(c);\n              ^\n</code></pre>\n\n<p>Replacing the program with:</p>\n\n<pre><code>fn main() {\n    println!(\"Hello\");    \n}\n</code></pre>\n\n<p>Works fine.</p>\n\n<p>The meaning of this error isn't clear to me and a Google search hasn't really shed light on it. Why does passing <code>c</code> to the <code>println!</code> macro cause a compile time error? This seems like quite unusual behaviour.</p>\n"}, {"tags": ["rust", "type-systems", "lifetime"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420135612, "post_id": 27732042, "comment_id": 43877986, "body": "It would be useful if you could make your example both <a href=\"http://stackoverflow.com/help/mcve\">smaller and compilable</a>. If we can  paste it into the <a href=\"http://play.rust-lang.org/\" rel=\"nofollow noreferrer\">playpen</a> and run it to see your error, then it&#39;s a lot easier to help."}], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 2, "last_activity_date": 1420199195, "last_edit_date": 1420199195, "creation_date": 1420142575, "answer_id": 27734174, "question_id": 27732042, "link": "https://stackoverflow.com/questions/27732042/rust-lifetime-issue-need-a-hand/27734174#27734174", "title": "rust: lifetime issue, need a hand", "body": "<p>I think you're trying to outsmart yourself. You don't need to be able to store a reader or a mutable reference to a reader at the same time, because you <a href=\"http://doc.rust-lang.org/std/io/trait.ByRefReader.html\" rel=\"nofollow\">can easily convert</a> such mutable reference to a full-fledged reader. Without these complications your code will look like this (note the example of <code>by_ref()</code> below):</p>\n\n<pre><code>#![feature(slicing_syntax)]\n\nuse std::cell::RefCell;\nuse std::rc::Rc;\nuse std::str::FromStr;\nuse std::default::Default;\nuse std::io::ByRefReader;\n\npub struct IStream&lt;R&gt; where R: Reader {\n    istream: Rc&lt;RefCell&lt;R&gt;&gt;\n}\n\nimpl&lt;R&gt; Clone for IStream&lt;R&gt; where R: Reader {\n    fn clone(&amp;self) -&gt; IStream&lt;R&gt; {\n        IStream {\n            istream: self.istream.clone()\n        }\n    }\n}\n\nimpl&lt;'b, F, R&gt; Shr&lt;&amp;'b mut F, IStream&lt;R&gt;&gt; for IStream&lt;R&gt; where R: Reader, F: FromStr + Default {\n    fn shr(self, output: &amp;'b mut F) -&gt; IStream&lt;R&gt; {  // '\n        let mut real_reader = self.istream.borrow_mut();\n\n        let mut buf = String::new(); // a string buffer\n        loop {\n            if let Ok(byte) = real_reader.read_byte() {\n                if byte == '\\u{A}' as u8 || byte == '\\u{20}' as u8 {\n                    break\n                } else {\n                    buf.push(byte as char);\n                }\n            } else {\n                break\n            }\n        }\n\n        *output = FromStr::from_str(buf[]).unwrap_or_default();\n\n        self.clone()\n    }\n}\n\nfn main() {\n    let mut stdin = std::io::stdin();\n    let stdin_ref: &amp;mut _ = &amp;mut stdin;  // a mutable reference to a reader\n\n    let is = IStream { istream: Rc::new(RefCell::new(stdin_ref.by_ref())) };\n\n    let mut x: uint = 0;\n    let mut y: uint = 0;\n\n    is &gt;&gt; &amp;mut x &gt;&gt; &amp;mut y;\n\n    println!(\"{}, {}\", x, y);\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1432435225, "last_edit_date": 1432435225, "creation_date": 1420142927, "answer_id": 27734225, "question_id": 27732042, "link": "https://stackoverflow.com/questions/27732042/rust-lifetime-issue-need-a-hand/27734225#27734225", "title": "rust: lifetime issue, need a hand", "body": "\n\n<p>Here's a reproduction of the error you mentioned:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::cell::RefCell;\n\nfn foo&lt;'a&gt;(rc: &amp;'a RefCell&lt;u8&gt;) { \n    let b: &amp;'a u8 = &amp;*rc.borrow();\n}\n\nfn main() {\n}\n</code></pre>\n\n<p>This fails to compile with</p>\n\n<blockquote>\n  <p>borrowed value does not live long enough</p>\n</blockquote>\n\n<p>By definition, the result of <code>borrow()</code> has a scope that is tied to the scope it's called in, you can't \"trick\" it by specifying a different lifetime. All that does is make the compiler tell you you can't do that.</p>\n"}], "owner": {"reputation": 39, "user_id": 4410329, "user_type": "registered", "profile_image": "https://lh6.googleusercontent.com/-ISkpQHwkgXE/AAAAAAAAAAI/AAAAAAAACQg/JHzCZp1iyZQ/photo.jpg?sz=128", "display_name": "Young Woo", "link": "https://stackoverflow.com/users/4410329/young-woo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 176, "favorite_count": 1, "answer_count": 2, "score": 2, "last_activity_date": 1432435225, "creation_date": 1420126022, "question_id": 27732042, "link": "https://stackoverflow.com/questions/27732042/rust-lifetime-issue-need-a-hand", "title": "rust: lifetime issue, need a hand", "body": "<p>I am making an analog of c++'s iostream for rust recently, but get confused by the lifetime system.\nI want to store a reference of reader or a bare reader in the <code>IStream</code>, so I store an <code>Q</code> in the structure. And than I use an phantom type <code>D</code> for converting <code>Q</code> to <code>R</code>.</p>\n\n<p>Here's the explaination:</p>\n\n<ul>\n<li><code>R</code> is the <code>Reader</code> where I actually need. </li>\n<li><code>Q</code> is the store type of <code>R</code>, so <code>Q</code> maybe a bare <code>R</code> or reference <code>&amp;mut R</code>.</li>\n<li>I use <code>D</code> to convert <code>Q</code> to <code>R</code>.  Because <code>borrow_from_mut(&amp;mut R)</code> gives me an <code>&amp;mut R</code>, and <code>borrow_from_mut(R)</code> also gives me an <code>&amp;mut R</code>. Thus it could be <code>D: BorrowFromMut&lt;Q&gt;</code>.</li>\n<li>and <code>D</code> can be converted to <code>R</code> by derefrence. So <code>&amp;mut D: DerefMut&lt;R&gt;</code></li>\n<li>because <code>&amp;mut D</code> can be dereferenced to <code>D</code>, but I need the <code>&amp;mut D</code> dereferenced to <code>R</code>, here must use a <code>trait object</code> to dynamic dispatch the <code>deref_mut</code> method, because of the absence of <code>UFCS</code>.(trick: <code>let tmp: &amp;'c mut Q = &amp;mut *self.istream.borrow_mut();</code>)</li>\n</ul>\n\n<p>Such trick makes <code>IStream</code> able to store both <code>&amp;mut R</code> and <code>R</code>.</p>\n\n<p>But the code can't compile because of a lifetime issue:</p>\n\n<pre><code>let tmp: &amp;'c mut Q = &amp;mut *self.istream.borrow_mut();\n//the Q borrowed from the RefCell only valid in the block, doesn't out live 'c.\n</code></pre>\n\n<p>how can I solve it?</p>\n\n<p>here is the code sample:</p>\n\n<pre><code>pub struct IStream&lt;'a,'b,R:'a+'b,Q:'a+'b,Sized? D:'b&gt; where R: Reader, D: BorrowFromMut&lt;Q&gt;, &amp;'b mut D: DerefMut&lt;R&gt; {\n    istream: Rc&lt;RefCell&lt;Q&gt;&gt;\n}\n\nimpl&lt;'a,'b,R,Q,D&gt; Clone for IStream&lt;'a,'b,R,Q,D&gt; where R: Reader, D: BorrowFromMut&lt;Q&gt;, &amp;'b mut D: DerefMut&lt;R&gt; {\n    fn clone(&amp;self) -&gt; IStream&lt;'a,'b,R,Q,D&gt; {\n        IStream {\n            istream: self.istream.clone()\n        }\n    }\n}\n\nimpl&lt;'a,'b,'c,F,R,Q,D&gt; Shr&lt;&amp;'b mut F,IStream&lt;'a,'c,R,Q,D&gt;&gt; for IStream&lt;'a,'c,R,Q,D&gt; where R: Reader, F: FromStr + Default, D: BorrowFromMut&lt;Q&gt;, &amp;'c mut D: DerefMut&lt;R&gt; {\n    fn shr(mut self, output: &amp;mut F) -&gt; IStream&lt;'a,'c,R,Q,D&gt; {\n        let tmp: &amp;'c mut Q = &amp;mut *self.istream.borrow_mut();\n        let mut reader: &amp;mut D = BorrowFromMut::borrow_from_mut(tmp);\n        let mut real_reader: &amp;DerefMut&lt;R&gt; = &amp;reader;\n\n        let mut buf = String::new(); // a string buffer\n\n        loop {\n            if let Ok(byte) = (*real_reader.deref_mut()).read_byte() {\n                if byte == '\\u{A}' as u8 || byte == '\\u{20}' as u8 {\n                    break\n                } else {\n                    buf.push(byte as char);\n                }\n            } else {\n                break\n            }\n        }\n\n        *output = FromStr::from_str(buf[]).unwrap_or_default();\n        IStream {\n            istream: self.istream.clone()\n        }\n    }\n}\n</code></pre>\n"}]