[{"tags": ["compiler-construction", "rust", "rust-compiler-plugin"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1463006055, "post_id": 37174361, "comment_id": 61883419, "body": "What exactly do you expect the crate attribute to do? Insert the call into every function of the crate?"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 2, "creation_date": 1463024162, "post_id": 37174361, "comment_id": 61888023, "body": "Did you try catching <code>ItemKind::Mod</code> in <a href=\"https://github.com/llogiq/flamer/blob/f4828cc91768109fa66f8cbbe57a285c0477c436/src/lib.rs#L29\" rel=\"nofollow noreferrer\">github.com/llogiq/flamer/blob/&hellip;</a> and iterating over its contents (recursively)?"}, {"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1463024969, "post_id": 37174361, "comment_id": 61888216, "body": "@Lukas Kalbertodt: exactly."}, {"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "reply_to_user": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1463025028, "post_id": 37174361, "comment_id": 61888232, "body": "@huon: No I didn&#39;t try that, because I thought it would walk automatically."}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 2, "creation_date": 1463028793, "post_id": 37174361, "comment_id": 61889273, "body": "The compiler walks the AST to find all the things with syntax extension attributes, and passes each annotated one into the syntax extension, but doesn&#39;t do anything automatically for the children (unless those children have attributes, of course). If the syntax extension wants to handle children without attributes on each one, it has to do the walking itself."}], "answers": [{"tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": true, "score": 2, "last_activity_date": 1463345962, "last_edit_date": 1463345962, "creation_date": 1463079174, "answer_id": 37195242, "question_id": 37174361, "link": "https://stackoverflow.com/questions/37174361/how-to-modify-all-items-of-a-crate-in-a-compiler-plugin/37195242#37195242", "title": "How to modify all items of a crate in a compiler plugin?", "body": "<p>@huon's comment </p>\n\n<blockquote>\n  <p>Did you try catching ItemKind::Mod in github.com/llogiq/flamer/blob/\u2026 and iterating over its contents (recursively)?</p>\n</blockquote>\n\n<p>was spot on \u2013 I just added a commit that handles mod and trait items by walking them. I'll also probably add code to walk functions to handle inner items and fns.</p>\n\n<p>The code looks like this:</p>\n\n<pre><code>fn flame_item(i: &amp;Item) -&gt; Item {\n    let base = i.clone();\n    Item {\n        node: match i.node {\n            ItemKind::Mod(ref m) =&gt;\n                ItemKind::Mod(flame_mod(m)),\n            ItemKind::Trait(unsafety, ref generic, ref bounds, ref tis) =&gt;\n                ItemKind::Trait(unsafety,\n                                generic.clone(),\n                                bounds.clone(),\n                                flame_items(tis)),\n        .. // other item types as usual: items, traitimpls, implitems\n\n            _ =&gt; return base\n        },\n        ..base\n    }\n}\n\nfn flame_mod(m: &amp;Mod) -&gt; Mod {\n    Mod {\n        inner: m.inner,\n        items: m.items.iter().map(|i| P(flame_item(i))).collect()\n    }\n}\n\nfn flame_items(items: &amp;[TraitItem]) -&gt; Vec&lt;TraitItem&gt; {\n    items.iter().map(flame_trait_item).collect()\n}\n</code></pre>\n"}], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 92, "favorite_count": 0, "accepted_answer_id": 37195242, "answer_count": 1, "score": 5, "last_activity_date": 1463345962, "creation_date": 1463005957, "last_edit_date": 1463006057, "question_id": 37174361, "link": "https://stackoverflow.com/questions/37174361/how-to-modify-all-items-of-a-crate-in-a-compiler-plugin", "title": "How to modify all items of a crate in a compiler plugin?", "body": "<p>I'm trying to build a syntax extension that expands an attribute into calls. Before:</p>\n\n<pre><code>#[flame]\nfn flamed() {\n    ..\n}\n</code></pre>\n\n<p>After:</p>\n\n<pre><code>fn flamed() {\n    flame::start_guard(\"flamed\");\n    ..\n}\n</code></pre>\n\n<p>This already <a href=\"https://github.com/llogiq/flamer\">works</a>. However, I'd also like it to work if I have the <code>#[flame]</code> attribute at the crate level (like <code>#![flame]</code>). Is this possible and if so, how?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "edited": false, "score": 0, "creation_date": 1462998026, "post_id": 37172343, "comment_id": 61879711, "body": "Option number 2. I never saw option 1 or 3 used in rust. In your example, what happens when <code>close</code> is called more than one time?"}, {"owner": {"reputation": 9933, "user_id": 678410, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/57083a995514ca4e66842dec135edd6f?s=128&d=identicon&r=PG", "display_name": "Anders Forsgren", "link": "https://stackoverflow.com/users/678410/anders-forsgren"}, "reply_to_user": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "edited": false, "score": 0, "creation_date": 1462998513, "post_id": 37172343, "comment_id": 61879977, "body": "Well spotted, the if-closed should of course go in the close() method and not in the drop(). Edited."}], "answers": [{"comments": [{"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 1, "creation_date": 1463140480, "post_id": 37173021, "comment_id": 61949774, "body": "For the error reporting case, you could still have more Rustic sematics by having <code>fn close(self) -&gt; Result</code> instead of <code>fn close(&amp;mut self) -&gt; Result</code>. Where the <code>Error</code> the result returns maybe contains <code>self</code>so you can do extra handling. The real issue here is use-after-resource-release."}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 0, "creation_date": 1463172805, "post_id": 37173021, "comment_id": 61969300, "body": "closer to the latter."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1463173120, "last_edit_date": 1495540790, "creation_date": 1462999746, "answer_id": 37173021, "question_id": 37172343, "link": "https://stackoverflow.com/questions/37172343/how-to-wrap-a-native-library-with-init-exit-semantics/37173021#37173021", "title": "How to wrap a native library with init/exit semantics", "body": "<p>Idiomatically, I believe you would just implement <code>Drop</code>. I am unaware of any standard library types that implement the pattern of allowing the user to dispose a resource manually (calling a method) and automatically (by dropping).</p>\n\n<p>This even leads to some strange cases. For example, closing a file via a function like <code>fclose</code> can generate errors. However, a Rust destructor can not return a failure code to the user. This means that <a href=\"https://github.com/rust-lang/rust/blob/1.8.0/src/libstd/sys/unix/fd.rs#L125-L134\" rel=\"nofollow noreferrer\">errors like that are swallowed</a>.</p>\n\n<p>This leads to the reason that you <em>may</em> want to support both. Your <code>close</code> method could return a <code>Result</code> and then you could ignore that result in <code>Drop</code>.</p>\n\n<hr>\n\n<p>As <a href=\"https://stackoverflow.com/questions/37172343/how-to-wrap-a-native-library-with-init-exit-semantics/37173021?noredirect=1#comment61949774_37173021\">Jsor points out</a>, you'd probably want your <code>close</code> method to accept the type by value. I also realized you could use a <code>NULL</code> value to indicate if the value had been closed or not.</p>\n\n<pre><code>use std::ptr;\n\nenum NativeDevice {} // Opaque pointer to C struct\n\nfn ffi_open_native_device() -&gt; *mut NativeDevice {\n    0x1 as *mut NativeDevice\n}\n\nfn ffi_close_native_device(_: *mut NativeDevice) -&gt; u8 {\n    println!(\"Close was called\");\n    0\n}\n\nstruct Device {\n    native_device: *mut NativeDevice,\n}\n\nimpl Device {\n    fn new() -&gt; Device {\n        let dev = ffi_open_native_device();\n        assert!(!dev.is_null());\n\n        Device {\n            native_device: dev,\n        }\n    }\n\n    fn close(mut self) -&gt; Result&lt;(), &amp;'static str&gt; {\n        if self.native_device.is_null() { return Ok(()) }\n\n        let result = ffi_close_native_device(self.native_device);\n        self.native_device = ptr::null_mut();\n        // Important to indicate that the device has already been cleaned up        \n\n        match result {\n            0 =&gt; Ok(()),\n            _ =&gt; Err(\"Something wen't boom\"),\n        }\n    }\n}\n\nimpl Drop for Device {\n    fn drop(&amp;mut self) {\n        if self.native_device.is_null() { return }\n        let _ = ffi_close_native_device(self.native_device);\n        // Ignoring failure to close here!\n    }\n}\n\nfn main() {\n    let _implicit = Device::new();\n    let explicit = Device::new();\n\n    explicit.close().expect(\"Couldn't close it\");\n}\n</code></pre>\n\n<hr>\n\n<p>If you had some kind of recoverable error that might occur when closing the device, you could return the object back to the user to try again:</p>\n\n<pre><code>enum Error {\n    RecoverableError(Device),\n    UnknownError,\n}\n\nfn close(mut self) -&gt; Result&lt;(), Error&gt; {\n    if self.native_device.is_null() {\n        return Ok(());\n    }\n\n    let result = ffi_close_native_device(self.native_device);\n\n    match result {\n        0 =&gt; {\n            self.native_device = ptr::null_mut();\n            // Important to indicate that the device has already been cleaned up\n            Ok(())\n        },\n        1 =&gt; Err(Error::RecoverableError(self)),\n        _ =&gt; {\n            self.native_device = ptr::null_mut();\n            // Important to indicate that the device has already been cleaned up\n            Err(Error::UnknownError)\n        },\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 9933, "user_id": 678410, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/57083a995514ca4e66842dec135edd6f?s=128&d=identicon&r=PG", "display_name": "Anders Forsgren", "link": "https://stackoverflow.com/users/678410/anders-forsgren"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 149, "favorite_count": 0, "accepted_answer_id": 37173021, "answer_count": 1, "score": 5, "last_activity_date": 1463173120, "creation_date": 1462997291, "last_edit_date": 1462999296, "question_id": 37172343, "link": "https://stackoverflow.com/questions/37172343/how-to-wrap-a-native-library-with-init-exit-semantics", "title": "How to wrap a native library with init/exit semantics", "body": "<p>I made a wrapper around a C library which creates a device that you must explicitly close.</p>\n\n<p>Writing the raw FFI functions was easy, but how do I make it ergonomic Rust in a higher level wrapper? </p>\n\n<p>Specifically, should I be doing it the RAII style and only using <code>Drop</code> to ensure the close is called when it goes out of scope, instead of exposing the <code>close()</code> method to the caller? Which way is the most idiomatic in Rust?</p>\n\n<p>There are basically 3 options:</p>\n\n<ol>\n<li>Thin wrapper that requires the same <code>close()</code> calls as the C library;</li>\n<li>RAII style that has no exposed <code>close()</code>, only a <code>Drop</code> implementation;</li>\n<li>C# <code>dispose()</code>-style implementation that tracks the closed state and allows both forms of closing.</li>\n</ol>\n\n<p>The last form looks like this:</p>\n\n<pre><code>pub enum NativeDevice {} // Opaque pointer to C struct\n\nfn ffi_open_native_device() -&gt; *mut NativeDevice { unimplemented!() }\nfn ffi_close_native_device(_: *mut NativeDevice) {}\nfn ffi_foo(_: *mut NativeDevice, _: u32) -&gt; u32 { unimplemented!() }\n\npub struct Device {\n    native_device: *mut NativeDevice,\n    closed: bool,\n}\n\nimpl Device {\n    pub fn new() -&gt; Device {\n        Device {\n            native_device: ffi_open_native_device(),\n            closed: false,\n        }\n    }\n\n    pub fn foo(&amp;self, arg: u32) -&gt; u32 {\n        ffi_foo(self.native_device, arg)\n    }\n\n    pub fn close(&amp;mut self) {\n        if !self.closed {\n            ffi_close_native_device(self.native_device);\n            self.closed = true;\n        }\n    }\n}\n\nimpl Drop for Device {\n    fn drop(&amp;mut self) {\n        self.close();\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 4, "creation_date": 1462967852, "post_id": 37158911, "comment_id": 61859190, "body": "<i>E0107 doesn&#39;t help at all.</i> \u2014 The compiler <b>tells</b> you how to get more information: &quot;help: run <code>rustc --explain E0107</code> to see a detailed explanation&quot;. Read the <i>entire</i> compiler message."}], "answers": [{"comments": [{"owner": {"reputation": 211, "user_id": 3429608, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17fb0f77c04c2ad6956abe0a2f585fda?s=128&d=identicon&r=PG&f=1", "display_name": "MrSpock", "link": "https://stackoverflow.com/users/3429608/mrspock"}, "edited": false, "score": 0, "creation_date": 1462972542, "post_id": 37159052, "comment_id": 61863049, "body": "I don&#39;t know how to adapt this example to Vec&lt;T&gt;. Whatever I tried I&#39;m getting errors. I tried Vec&lt;&#39;a Downstream&gt;, Vec&lt;&#39;a&gt;&lt;Downstream&gt; and I&#39;m still getting errors."}, {"owner": {"reputation": 211, "user_id": 3429608, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17fb0f77c04c2ad6956abe0a2f585fda?s=128&d=identicon&r=PG&f=1", "display_name": "MrSpock", "link": "https://stackoverflow.com/users/3429608/mrspock"}, "edited": false, "score": 0, "creation_date": 1462973453, "post_id": 37159052, "comment_id": 61863817, "body": "Thanks ! My problem was that lifetime &#39;a marker is often before element. I didn&#39;t thought to put it behind."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 211, "user_id": 3429608, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17fb0f77c04c2ad6956abe0a2f585fda?s=128&d=identicon&r=PG&f=1", "display_name": "MrSpock", "link": "https://stackoverflow.com/users/3429608/mrspock"}, "edited": false, "score": 0, "creation_date": 1462980231, "post_id": 37159052, "comment_id": 61869193, "body": "@MrSpock: Before and after are completely different. <code>&amp;&#39;a T</code> is a reference to a <code>T</code> with a lifetime <code>&#39;a</code> while <code>Blabla&lt;A, B&gt;</code> is a type <code>Blabla</code> with two generic parameters <code>A</code> and <code>B</code> which may be either types or lifetimes. A reference to the <code>Downstream&lt;&#39;a&gt;</code> type would be <code>&amp;&#39;b Downstream&lt;&#39;a&gt;</code>. The name <code>Downstream</code> alone is not a type, it&#39;s incomplete without its full list of generic parameters; it is just that sometimes the compilers allows you not to note them down because it figures them out."}], "tags": [], "owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "is_accepted": false, "score": 3, "last_activity_date": 1462960524, "creation_date": 1462960524, "answer_id": 37159052, "question_id": 37158911, "link": "https://stackoverflow.com/questions/37158911/wrong-number-of-lifetime-parameters-when-nesting-lifetime-inside-vec/37159052#37159052", "title": "Wrong number of lifetime parameters when nesting lifetime inside Vec", "body": "<pre><code>downstreams: Vec&lt;Downstream&gt;,\n</code></pre>\n\n<p>should be</p>\n\n<pre><code>downstreams: Vec&lt;Downstream&lt;'a&gt;&gt;,\n</code></pre>\n\n<hr>\n\n<blockquote>\n  <p>E0107 doesn't help at all.</p>\n</blockquote>\n\n<p>You should run <code>rustc --explain E0107</code>.</p>\n\n<p>The output of that command currently starts with some nice examples:</p>\n\n<blockquote>\n  <p>This error means that an incorrect number of lifetime parameters were\n  provided for a type (like a struct or enum) or trait.</p>\n  \n  <p>Some basic examples include:</p>\n\n<pre><code>struct Foo&lt;'a&gt;(&amp;'a str);\nenum Bar { A, B, C }\n\nstruct Baz&lt;'a&gt; {\n    foo: Foo,     // error: expected 1, found 0\n    bar: Bar&lt;'a&gt;, // error: expected 0, found 1\n}\n</code></pre>\n</blockquote>\n"}], "owner": {"reputation": 211, "user_id": 3429608, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17fb0f77c04c2ad6956abe0a2f585fda?s=128&d=identicon&r=PG&f=1", "display_name": "MrSpock", "link": "https://stackoverflow.com/users/3429608/mrspock"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 745, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1462967767, "creation_date": 1462960171, "last_edit_date": 1462967767, "question_id": 37158911, "link": "https://stackoverflow.com/questions/37158911/wrong-number-of-lifetime-parameters-when-nesting-lifetime-inside-vec", "title": "Wrong number of lifetime parameters when nesting lifetime inside Vec", "body": "<p>I'm trying to build a structure that contains references to a vector of another struct like this:</p>\n\n<pre><code>pub struct Downstream&lt;'a&gt; {\n    frequency: i32,\n    slot: i32,\n    connector: i32,\n    description: String,\n    cablemac: &amp;'a CableMac,\n}\n\npub struct Upstream&lt;'a&gt; {\n    downstreams: Vec&lt;Downstream&gt;,\n}\n</code></pre>\n\n<p>Whatever I try, I always get this lifetime error:</p>\n\n<pre><code>src/e6000/mod.rs:13:22: 13:32 error: wrong number of lifetime parameters: expected 1, found 0 [E0107]\nsrc/e6000/mod.rs:13     downstreams: Vec&lt;Downstream&gt;,\n</code></pre>\n\n<p>E0107 doesn't help at all.</p>\n\n<p>Where and how so I put an <code>'a</code> to get this working?</p>\n"}, {"tags": ["string", "substring", "rust"], "answers": [{"comments": [{"owner": {"reputation": 47414, "user_id": 52817, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/74fUU.png?s=128&g=1", "display_name": "laktak", "link": "https://stackoverflow.com/users/52817/laktak"}, "edited": false, "score": 0, "creation_date": 1462959090, "post_id": 37158376, "comment_id": 61852971, "body": "Didn&#39;t see <code>chars()</code>, thanks! Would it also be possible to map the char index to a byte offset and create a slice from that?"}, {"owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "reply_to_user": {"reputation": 47414, "user_id": 52817, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/74fUU.png?s=128&g=1", "display_name": "laktak", "link": "https://stackoverflow.com/users/52817/laktak"}, "edited": false, "score": 2, "creation_date": 1462959705, "post_id": 37158376, "comment_id": 61853398, "body": "@laktak, you can use <code>str::char_indices</code> for that. <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.char_indices\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/primitive.str.html#method.char_indices</a>"}, {"owner": {"reputation": 3025, "user_id": 1356047, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/da6592df871c28f69e0480dd4edb5f9a?s=128&d=identicon&r=PG", "display_name": "Jonas Berlin", "link": "https://stackoverflow.com/users/1356047/jonas-berlin"}, "edited": false, "score": 0, "creation_date": 1592163353, "post_id": 37158376, "comment_id": 110319933, "body": "In the second example I think you meant <code>b&quot;Hello, world!&quot;</code> ?"}], "tags": [], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "is_accepted": true, "score": 38, "last_activity_date": 1592197709, "last_edit_date": 1592197709, "creation_date": 1462958861, "answer_id": 37158376, "question_id": 37157926, "link": "https://stackoverflow.com/questions/37157926/is-there-a-method-like-javascripts-substr-in-rust/37158376#37158376", "title": "Is there a method like JavaScript&#39;s substr in Rust?", "body": "<p>For characters, you can use <code>s.chars().skip(pos).take(len)</code>:</p>\n\n<pre><code>fn main() {\n    let s = \"Hello, world!\";\n    let ss: String = s.chars().skip(7).take(5).collect();\n    println!(\"{}\", ss);\n}\n</code></pre>\n\n<p>Beware of the definition of Unicode characters though.</p>\n\n<p>For bytes, you can use the slice syntax:</p>\n\n<pre><code>fn main() {\n    let s = b\"Hello, world!\";\n    let ss = &amp;s[7..12];\n    println!(\"{:?}\", ss);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 47414, "user_id": 52817, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/74fUU.png?s=128&g=1", "display_name": "laktak", "link": "https://stackoverflow.com/users/52817/laktak"}, "edited": false, "score": 0, "creation_date": 1462976732, "post_id": 37161510, "comment_id": 61866563, "body": "&quot;not hiding anything from you that might take up CPU cycles&quot; - can you explain why substr might be more expensive than any of the trim functions it has?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 47414, "user_id": 52817, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/74fUU.png?s=128&g=1", "display_name": "laktak", "link": "https://stackoverflow.com/users/52817/laktak"}, "edited": false, "score": 2, "creation_date": 1462977134, "post_id": 37161510, "comment_id": 61866881, "body": "Well... the trim functions are expected to get rid of all whitespace they encounter. This is a O(n) operation by definition. But using a <code>substr</code> method the user might assume that it is O(1), because they are entering indices."}, {"owner": {"reputation": 2071, "user_id": 1567205, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/b992b962d4271e53116da769c84eb4e7?s=128&d=identicon&r=PG", "display_name": "JavaRunner", "link": "https://stackoverflow.com/users/1567205/javarunner"}, "edited": false, "score": 0, "creation_date": 1592740096, "post_id": 37161510, "comment_id": 110526766, "body": "Just craziness :)"}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 12, "last_activity_date": 1462967665, "last_edit_date": 1462967665, "creation_date": 1462966724, "answer_id": 37161510, "question_id": 37157926, "link": "https://stackoverflow.com/questions/37157926/is-there-a-method-like-javascripts-substr-in-rust/37161510#37161510", "title": "Is there a method like JavaScript&#39;s substr in Rust?", "body": "<p>You can use the <a href=\"https://doc.rust-lang.org/std/str/struct.Chars.html#method.as_str\"><code>as_str</code></a> method on the <a href=\"https://doc.rust-lang.org/std/str/struct.Chars.html\"><code>Chars</code></a> iterator to get back a <code>&amp;str</code> slice after you have stepped on the iterator. So to skip the first <code>start</code> chars, you can call</p>\n\n<pre><code>let s = \"Some text to slice into\";\nlet mut iter = s.chars();\niter.by_ref().nth(start); // eat up start values\nlet slice = iter.as_str(); // get back a slice of the rest of the iterator\n</code></pre>\n\n<p>Now if you also want to limit the length, you first need to figure out the byte-position of the <code>length</code> character:</p>\n\n<pre><code>let end_pos = slice.char_indices().nth(length).map(|(n, _)| n).unwrap_or(0);\nlet substr = &amp;slice[..end_pos];\n</code></pre>\n\n<p>This might feel a little roundabout, but Rust is not hiding anything from you that might take up CPU cycles. That said, I wonder why there's no crate yet that offers a <code>substr</code> method.</p>\n"}, {"tags": [], "owner": {"reputation": 146, "user_id": 1656730, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/be499eddedbe30ab62cde4c717cc2c14?s=128&d=identicon&r=PG", "display_name": "user1656730", "link": "https://stackoverflow.com/users/1656730/user1656730"}, "is_accepted": false, "score": 4, "last_activity_date": 1496941142, "last_edit_date": 1496941142, "creation_date": 1496939084, "answer_id": 44441010, "question_id": 37157926, "link": "https://stackoverflow.com/questions/37157926/is-there-a-method-like-javascripts-substr-in-rust/44441010#44441010", "title": "Is there a method like JavaScript&#39;s substr in Rust?", "body": "<p>For <code>my_string.substring(start, len)</code>-like syntax, you can write a custom trait:</p>\n\n<pre><code>trait StringUtils {\n    fn substring(&amp;self, start: usize, len: usize) -&gt; Self;\n}\n\nimpl StringUtils for String {\n    fn substring(&amp;self, start: usize, len: usize) -&gt; Self {\n        self.chars().skip(start).take(len).collect()\n    }\n}\n\n// Usage:\nfn main() {\n    let phrase: String = \"this is a string\".to_string();\n    println!(\"{}\", phrase.substring(5, 8)); // prints \"is a str\"\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 96, "user_id": 150512, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/257cb7806f1990415b3399540208f4f2?s=128&d=identicon&r=PG", "display_name": "carlo.milanesi", "link": "https://stackoverflow.com/users/150512/carlo-milanesi"}, "is_accepted": false, "score": 4, "last_activity_date": 1549159402, "last_edit_date": 1549159402, "creation_date": 1549119437, "answer_id": 54494217, "question_id": 37157926, "link": "https://stackoverflow.com/questions/37157926/is-there-a-method-like-javascripts-substr-in-rust/54494217#54494217", "title": "Is there a method like JavaScript&#39;s substr in Rust?", "body": "<p>This code performs both substring-ing and string-slicing, without panicking nor allocating:</p>\n\n<pre><code>use std::ops::{Bound, RangeBounds};\n\ntrait StringUtils {\n    fn substring(&amp;self, start: usize, len: usize) -&gt; &amp;str;\n    fn slice(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; &amp;str;\n}\n\nimpl StringUtils for str {\n    fn substring(&amp;self, start: usize, len: usize) -&gt; &amp;str {\n        let mut char_pos = 0;\n        let mut byte_start = 0;\n        let mut it = self.chars();\n        loop {\n            if char_pos == start { break; }\n            if let Some(c) = it.next() {\n                char_pos += 1;\n                byte_start += c.len_utf8();\n            }\n            else { break; }\n        }\n        char_pos = 0;\n        let mut byte_end = byte_start;\n        loop {\n            if char_pos == len { break; }\n            if let Some(c) = it.next() {\n                char_pos += 1;\n                byte_end += c.len_utf8();\n            }\n            else { break; }\n        }\n        &amp;self[byte_start..byte_end]\n    }\n    fn slice(&amp;self, range: impl RangeBounds&lt;usize&gt;) -&gt; &amp;str {\n        let start = match range.start_bound() {\n            Bound::Included(bound) | Bound::Excluded(bound) =&gt; *bound,\n            Bound::Unbounded =&gt; 0,\n        };\n        let len = match range.end_bound() {\n            Bound::Included(bound) =&gt; *bound + 1,\n            Bound::Excluded(bound) =&gt; *bound,\n            Bound::Unbounded =&gt; self.len(),\n        } - start;\n        self.substring(start, len)\n    }\n}\n\nfn main() {\n    let s = \"abcd\u00e8fghij\";\n    // All three statements should print:\n    // \"abcd\u00e8, abcd\u00e8fghij, d\u00e8fgh, d\u00e8fghij.\"\n    println!(\"{}, {}, {}, {}.\",\n        s.substring(0, 5),\n        s.substring(0, 50),\n        s.substring(3, 5),\n        s.substring(3, 50));\n    println!(\"{}, {}, {}, {}.\",\n        s.slice(..5),\n        s.slice(..50),\n        s.slice(3..8),\n        s.slice(3..));\n    println!(\"{}, {}, {}, {}.\",\n        s.slice(..=4),\n        s.slice(..=49),\n        s.slice(3..=7),\n        s.slice(3..));\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1583340986, "post_id": 60530516, "comment_id": 107085760, "body": "This is not like JavaScript: <code>&quot;\u30a6\u30a3\u30ad\u30da\u30c7\u30a3\u30a2\u3078\u3088\u3046\u3053\u305d&quot;.substr(1, 3)</code> vs <code>&amp;&quot;\u30a6\u30a3\u30ad\u30da\u30c7\u30a3\u30a2\u3078\u3088\u3046\u3053\u305d&quot;[1..3]</code>. One &quot;works&quot;, the other doesn&#39;t."}, {"owner": {"reputation": 11358, "user_id": 2708650, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-iuLvd5ToDQ8/AAAAAAAAAAI/AAAAAAAAAEA/aGdWcMU2x_4/photo.jpg?sz=128", "display_name": "Ian MacDonald", "link": "https://stackoverflow.com/users/2708650/ian-macdonald"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1583342477, "post_id": 60530516, "comment_id": 107086505, "body": "@Shepmaster Correct. This does not work for all characters. The <code>skip.take.collect</code> method is ideal."}], "tags": [], "owner": {"reputation": 11358, "user_id": 2708650, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-iuLvd5ToDQ8/AAAAAAAAAAI/AAAAAAAAAEA/aGdWcMU2x_4/photo.jpg?sz=128", "display_name": "Ian MacDonald", "link": "https://stackoverflow.com/users/2708650/ian-macdonald"}, "is_accepted": false, "score": 0, "last_activity_date": 1583339262, "last_edit_date": 1583339262, "creation_date": 1583339089, "answer_id": 60530516, "question_id": 37157926, "link": "https://stackoverflow.com/questions/37157926/is-there-a-method-like-javascripts-substr-in-rust/60530516#60530516", "title": "Is there a method like JavaScript&#39;s substr in Rust?", "body": "<p>You can also use <code>.to_string()[ &lt;range&gt; ]</code>.</p>\n\n<p>This example takes an immutable slice of the original string, then mutates that string to demonstrate the original slice is preserved.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let mut s: String = \"Hello, world!\".to_string();\n\nlet substring: &amp;str = &amp;s.to_string()[..6];\n\ns.replace_range(..6, \"Goodbye,\");\n\nprintln!(\"{}   {} universe!\", s, substring);\n\n//    Goodbye, world!   Hello, universe!\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 11, "user_id": 14892051, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/156003937cfa5b223ae2c6d29a754ce7?s=128&d=identicon&r=PG&f=1", "display_name": "tolvanea", "link": "https://stackoverflow.com/users/14892051/tolvanea"}, "is_accepted": false, "score": 1, "last_activity_date": 1609162539, "last_edit_date": 1609162539, "creation_date": 1609083755, "answer_id": 65467480, "question_id": 37157926, "link": "https://stackoverflow.com/questions/37157926/is-there-a-method-like-javascripts-substr-in-rust/65467480#65467480", "title": "Is there a method like JavaScript&#39;s substr in Rust?", "body": "<p>The solution given by oli_obk does not handle last index of string slice. It can be fixed with <code>.chain(once(s.len()))</code>.</p>\n<p>Here function <code>substr</code> implements a substring slice with error handling. If invalid index is passed to function, then a valid part of string slice is returned with <code>Err</code>-variant. All corner cases should be handled correctly.</p>\n<pre><code>fn substr(s: &amp;str, begin: usize, length: Option&lt;usize&gt;) -&gt; Result&lt;&amp;str, &amp;str&gt; {\n    use std::iter::once;\n    let mut itr = s.char_indices().map(|(n, _)| n).chain(once(s.len()));\n    let beg = itr.nth(begin);\n    if beg.is_none() {\n        return Err(&quot;&quot;);\n    } else if length == Some(0) {\n        return Ok(&quot;&quot;);\n    }\n    let end = length.map_or(Some(s.len()), |l| itr.nth(l-1));\n    if let Some(end) = end {\n        return Ok(&amp;s[beg.unwrap()..end]);\n    } else {\n        return Err(&amp;s[beg.unwrap()..s.len()]);\n    }\n}\nlet s = &quot;abc\ud83d\ude42&quot;;\nassert_eq!(Ok(&quot;bc&quot;), substr(s, 1, Some(2)));\nassert_eq!(Ok(&quot;c\ud83d\ude42&quot;), substr(s, 2, Some(2)));\nassert_eq!(Ok(&quot;c\ud83d\ude42&quot;), substr(s, 2, None));\nassert_eq!(Err(&quot;c\ud83d\ude42&quot;), substr(s, 2, Some(99)));\nassert_eq!(Ok(&quot;&quot;), substr(s, 2, Some(0)));\nassert_eq!(Err(&quot;&quot;), substr(s, 5, Some(4)));\n</code></pre>\n<p>Note that this does not handle unicode grapheme clusters. For example, <code>&quot;y\u0306es&quot;</code> contains 4 unicode <code>char</code>s but 3 grapheme clusters. Crate <a href=\"https://crates.io/crates/unicode-segmentation\" rel=\"nofollow noreferrer\">unicode-segmentation</a> solves this problem. Unicode grapheme clusters are handled correctly if part</p>\n<pre><code>let mut itr = s.char_indices()...\n</code></pre>\n<p>is replaced with</p>\n<pre><code>use unicode_segmentation::UnicodeSegmentation;\nlet mut itr = s.grapheme_indices(true)...\n</code></pre>\n<p>Then also following works</p>\n<pre><code>assert_eq!(Ok(&quot;y\u0306&quot;), substr(&quot;y\u0306es&quot;, 0, Some(1)));\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 13844, "user_id": 12534, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/c248df6104953c22e814d3f4f65b3839?s=128&d=identicon&r=PG", "display_name": "Christian Dav&#233;n", "link": "https://stackoverflow.com/users/12534/christian-dav%c3%a9n"}, "is_accepted": false, "score": 0, "last_activity_date": 1611383362, "creation_date": 1611383362, "answer_id": 65856404, "question_id": 37157926, "link": "https://stackoverflow.com/questions/37157926/is-there-a-method-like-javascripts-substr-in-rust/65856404#65856404", "title": "Is there a method like JavaScript&#39;s substr in Rust?", "body": "<p>I would suggest you use the crate <a href=\"https://crates.io/crates/substring\" rel=\"nofollow noreferrer\">substring</a>. (And look at <a href=\"https://github.com/Anders429/substring/blob/master/src/lib.rs\" rel=\"nofollow noreferrer\">its source code</a> if you want to learn how to do this properly.)</p>\n"}], "owner": {"reputation": 47414, "user_id": 52817, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/74fUU.png?s=128&g=1", "display_name": "laktak", "link": "https://stackoverflow.com/users/52817/laktak"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 14165, "favorite_count": 7, "accepted_answer_id": 37158376, "answer_count": 7, "score": 26, "last_activity_date": 1611383362, "creation_date": 1462957739, "last_edit_date": 1496941212, "question_id": 37157926, "link": "https://stackoverflow.com/questions/37157926/is-there-a-method-like-javascripts-substr-in-rust", "title": "Is there a method like JavaScript&#39;s substr in Rust?", "body": "<p>I looked at the Rust <a href=\"http://doc.rust-lang.org/std/string/struct.String.html\" rel=\"noreferrer\">docs for <code>String</code></a> but I can't find a way to extract a substring.</p>\n\n<p>Is there a method like JavaScript's <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr\" rel=\"noreferrer\"><code>substr</code></a> in Rust? If not, how would you implement it?</p>\n\n<pre><code>str.substr(start[, length])\n</code></pre>\n\n<p>The closest is probably <code>slice_unchecked</code> but it uses byte offsets instead of character indexes and is marked <code>unsafe</code>.</p>\n"}, {"tags": ["vector", "iterator", "rust"], "comments": [{"owner": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "edited": false, "score": 0, "creation_date": 1462940121, "post_id": 37152766, "comment_id": 61843175, "body": "This sounds pretty well suited for something recursive."}, {"owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "edited": false, "score": 3, "creation_date": 1462948114, "post_id": 37152766, "comment_id": 61846057, "body": "The <code>unsafe</code> way would probably be faster, but I am not sure whether it&#39;s worth it."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1462970358, "post_id": 37152766, "comment_id": 61861140, "body": "FWIW, I would do it exactly as you&#39;ve described it, push in-order and then reverse it. Since you are sure to have some profiling to test if a one-pass solution is more efficient, can you show us the results of that profiling that indicates the two-pass solution is not efficient?"}, {"owner": {"reputation": 3023, "user_id": 1691145, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/4b6744a17b41f3b0e5c7554a43a04094?s=128&d=identicon&r=PG", "display_name": "Justin Raymond", "link": "https://stackoverflow.com/users/1691145/justin-raymond"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462983784, "post_id": 37152766, "comment_id": 61871581, "body": "@Shepmaster I think you are right that two passes are better. The tradeoff between simplicity of the code and performance is not worth a single pass."}, {"owner": {"reputation": 3023, "user_id": 1691145, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/4b6744a17b41f3b0e5c7554a43a04094?s=128&d=identicon&r=PG", "display_name": "Justin Raymond", "link": "https://stackoverflow.com/users/1691145/justin-raymond"}, "edited": false, "score": 0, "creation_date": 1462984087, "post_id": 37152766, "comment_id": 61871766, "body": "Although I&#39;m not sure why two passes would ever be more efficient than one pass. The only reason I could think of is the direction would confuse the pre-fetcher, but Intel CPUs can detect streams of memory accesses in either forward or backward direction (<a href=\"http://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus\" title=\"c for loop indexing is forward indexing faster in new cpus\">stackoverflow.com/questions/1950878/&hellip;</a>). This cofr is part of a raytracer, where performance is very important and the code segment may run millions of times for a large image."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462967986, "post_id": 37155107, "comment_id": 61859305, "body": "Is the idea that you&#39;d actually leave the data in the backwards order, but make accesses work back-to-front? Clever. You&#39;d have to watch out for any other cases (iterators, etc.) when you expose those."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462970033, "post_id": 37155107, "comment_id": 61860895, "body": "@Shepmaster: Yes, it&#39;s the idea, and indeed it means reversing all accesses."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 5, "last_activity_date": 1462955054, "last_edit_date": 1462955054, "creation_date": 1462949492, "answer_id": 37155107, "question_id": 37152766, "link": "https://stackoverflow.com/questions/37152766/most-efficient-way-to-fill-a-vector-from-back-to-front/37155107#37155107", "title": "Most efficient way to fill a vector from back to front", "body": "<blockquote>\n  <p>Is there a way to do this in a single pass?</p>\n</blockquote>\n\n<p>If you don't mind adapting the vector, it's relatively easy.</p>\n\n<pre><code>struct RevVec&lt;T&gt; {\n    data: Vec&lt;T&gt;,\n}\n\nimpl&lt;T&gt; RevVec&lt;T&gt; {\n    fn push_front(&amp;mut self, t: T) { self.data.push(t); }\n}\n\nimpl&lt;T&gt; Index&lt;usize&gt; for RevVec&lt;T&gt; {\n    type Output = T;\n    fn index(&amp;self, index: usize) -&gt; &amp;T {\n        &amp;self.data[self.len() - index - 1]\n    }\n}\n\nimpl&lt;T&gt; IndexMut&lt;usize&gt; for RevVec&lt;T&gt; {\n    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {\n        let len = self.len();\n        &amp;mut self.data[len - index - 1]\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1463168222, "post_id": 37217874, "comment_id": 61967155, "body": "You <a href=\"https://play.rust-lang.org/?gist=fe502c56f90352547b08a70fb8d5f991&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">probably don&#39;t need to use pointer offsets</a>. Also, your code has non-idiomatic Rust, like the UFCS call to <code>Vec::set_len</code>, explicit types, <code>&amp;Vec</code> instead of <code>&amp;[T]</code>, wider <code>unsafe</code> blocks than needed, <code>return</code> statements, spaces before <code>:</code> in types, etc. You may want to get idiomatic reviews at some point."}, {"owner": {"reputation": 3023, "user_id": 1691145, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/4b6744a17b41f3b0e5c7554a43a04094?s=128&d=identicon&r=PG", "display_name": "Justin Raymond", "link": "https://stackoverflow.com/users/1691145/justin-raymond"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1463168578, "post_id": 37217874, "comment_id": 61967356, "body": "Anyone with more experience with the language is welcome to improve the solution."}, {"owner": {"reputation": 5189, "user_id": 5223757, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/FdOvO.png?s=128&g=1", "display_name": "wizzwizz4", "link": "https://stackoverflow.com/users/5223757/wizzwizz4"}, "edited": false, "score": 0, "creation_date": 1561625479, "post_id": 37217874, "comment_id": 100128834, "body": "@JustinRaymond You&#39;re missing a few <code>assert!</code> / <code>assert_eq!</code> calls there. That <code>unsafe</code> code doesn&#39;t look safe to me."}], "tags": [], "owner": {"reputation": 3023, "user_id": 1691145, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/4b6744a17b41f3b0e5c7554a43a04094?s=128&d=identicon&r=PG", "display_name": "Justin Raymond", "link": "https://stackoverflow.com/users/1691145/justin-raymond"}, "is_accepted": true, "score": 3, "last_activity_date": 1463167485, "creation_date": 1463167485, "answer_id": 37217874, "question_id": 37152766, "link": "https://stackoverflow.com/questions/37152766/most-efficient-way-to-fill-a-vector-from-back-to-front/37217874#37217874", "title": "Most efficient way to fill a vector from back to front", "body": "<p>The solution using <code>unsafe</code> is below. The unsafe version is slightly more than 2x as fast as the safe version using <code>reverse()</code>. The idea is to use <code>Vec::with_capacity(usize)</code> to allocate the vector, then use <a href=\"https://doc.rust-lang.org/std/ptr/fn.write.html\" rel=\"nofollow\"><code>ptr::write(dst: *mut T, src: T)</code></a> to write the elements into the vector back to front. <a href=\"https://doc.rust-lang.org/std/primitive.pointer.html\" rel=\"nofollow\"><code>offset(self, count: isize) -&gt; *const T</code></a> is used to calculate the offset into the vector.</p>\n\n<pre><code>extern crate time;\nuse std::fmt::Debug;\nuse std::ptr;\nuse time::PreciseTime;\n\nfn scanl&lt;T, F&gt;(u : &amp;Vec&lt;T&gt;, f : F) -&gt; Vec&lt;T&gt;\n    where T : Clone,\n          F : Fn(&amp;T, &amp;T) -&gt; T {\n    let mut v = Vec::with_capacity(u.len());\n\n    for x in u.iter().rev() {\n        let b = match v.last() {\n            None =&gt; (*x).clone(),\n            Some(y) =&gt; f(x, &amp;y),\n        };\n        v.push(b);\n    }\n    v.reverse();\n    return v;\n}\n\nfn unsafe_scanl&lt;T, F&gt;(u : &amp;Vec&lt;T&gt; , f : F) -&gt; Vec&lt;T&gt;\n    where T : Clone + Debug,\n          F : Fn(&amp;T, &amp;T) -&gt; T {\n    unsafe {\n        let mut v : Vec&lt;T&gt; = Vec::with_capacity(u.len());\n\n        let cap = v.capacity();\n        let p = v.as_mut_ptr();\n\n        match u.last() {\n            None =&gt; return v,\n            Some(x) =&gt; ptr::write(p.offset((u.len()-1) as isize), x.clone()),\n        };\n        for i in (0..u.len()-1).rev() {\n            ptr::write(p.offset(i as isize), f(v.get_unchecked(i+1), u.get_unchecked(i)));\n        }\n        Vec::set_len(&amp;mut v, cap);\n        return v;\n    }\n}\n\npub fn bench_scanl() {\n    let lo : u64 = 0;\n    let hi : u64 = 1000000;\n    let v : Vec&lt;u64&gt; = (lo..hi).collect();\n\n    let start = PreciseTime::now();\n    let u = scanl(&amp;v, |x, y| x + y);\n    let end= PreciseTime::now();\n    println!(\"{:?}\\n in {}\", u.len(), start.to(end));\n\n    let start2 = PreciseTime::now();\n    let u = unsafe_scanl(&amp;v, |x, y| x + y);\n    let end2 = PreciseTime::now();\n    println!(\"2){:?}\\n in {}\", u.len(), start2.to(end2));\n}\n</code></pre>\n"}], "owner": {"reputation": 3023, "user_id": 1691145, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/4b6744a17b41f3b0e5c7554a43a04094?s=128&d=identicon&r=PG", "display_name": "Justin Raymond", "link": "https://stackoverflow.com/users/1691145/justin-raymond"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1802, "favorite_count": 0, "accepted_answer_id": 37217874, "answer_count": 2, "score": 6, "last_activity_date": 1463167485, "creation_date": 1462938478, "last_edit_date": 1462970141, "question_id": 37152766, "link": "https://stackoverflow.com/questions/37152766/most-efficient-way-to-fill-a-vector-from-back-to-front", "title": "Most efficient way to fill a vector from back to front", "body": "<p>I am trying to populate a vector with a sequence of values. In order to calculate the first value I need to calculate the second value, which depends on the third value etc etc.</p>\n\n<pre><code>let mut bxs = Vec::with_capacity(n);\n\nfor x in info {\n    let b = match bxs.last() {\n        Some(bx) =&gt; union(&amp;bx, &amp;x.bbox),\n        None =&gt; x.bbox.clone(),\n    };\n    bxs.push(b);\n}\nbxs.reverse();\n</code></pre>\n\n<p>Currently I just fill the vector front to back using <code>v.push(x)</code> and then reverse the vector using <code>v.reverse()</code>. Is there a way to do this in a single pass?</p>\n"}, {"tags": ["string", "rust"], "comments": [{"owner": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "edited": false, "score": 2, "creation_date": 1462919929, "post_id": 37150002, "comment_id": 61838064, "body": "I think you answered your own question :)"}, {"owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "edited": false, "score": 0, "creation_date": 1463067428, "post_id": 37150002, "comment_id": 61915576, "body": "You can even move out the vector using <a href=\"https://doc.rust-lang.org/stable/std/string/struct.String.html#method.into_bytes\" rel=\"nofollow noreferrer\"><code>String::into_bytes</code></a>."}], "answers": [{"comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1462921015, "post_id": 37150091, "comment_id": 61838436, "body": "Should that be <code>as_mut_vec</code>?"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1462922086, "post_id": 37150091, "comment_id": 61838780, "body": "@mcarton Absolutely! Thanks, will fix that."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 8, "last_activity_date": 1462962952, "last_edit_date": 1462962952, "creation_date": 1462919986, "answer_id": 37150091, "question_id": 37150002, "link": "https://stackoverflow.com/questions/37150002/is-string-in-rust-basically-a-vector/37150091#37150091", "title": "Is String in Rust basically a vector?", "body": "<p>Yes and no. The underlying buffer that <code>String</code> uses to save its data is a <code>Vec</code>. This makes sense, because often you want similar allocation strategies for both strings and vectors. Doing all the allocation by hand in the <code>String</code> impl would be a waste of time and a lot of duplicate code.</p>\n\n<p>Note, however, that the <code>vec</code> field is private, so you can't access it directly (using only safe methods). This means that the (safe) <code>String</code> interface can enforce valid UTF8 data in the vector. </p>\n\n<p>But yes: <code>String</code> is just a UTF8-enforcing wrapper around some kind of buffer.</p>\n\n<hr>\n\n<p>There was a fairly long discussion just prior to the release of Rust 1.0 about whether or not to expose this internal vector via the interface. The result of the discussion was to keep the problematic method <a href=\"http://doc.rust-lang.org/collections/string/struct.String.html#method.as_mut_vec\" rel=\"nofollow\"><code>as_mut_vec</code></a>. This method is of course handy in some cases but makes it impossible to change the implementation of the string later on.</p>\n"}], "owner": {"reputation": 2141, "user_id": 744184, "user_type": "registered", "accept_rate": 96, "profile_image": "https://www.gravatar.com/avatar/b3c344835e7d6c28d221702306647db6?s=128&d=identicon&r=PG", "display_name": "user", "link": "https://stackoverflow.com/users/744184/user"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 155, "favorite_count": 0, "accepted_answer_id": 37150091, "answer_count": 1, "score": 2, "last_activity_date": 1462962952, "creation_date": 1462919439, "last_edit_date": 1462920328, "question_id": 37150002, "link": "https://stackoverflow.com/questions/37150002/is-string-in-rust-basically-a-vector", "title": "Is String in Rust basically a vector?", "body": "<p>From the <a href=\"https://github.com/rust-lang/rust/blob/1.8.0/src/libcollections/string.rs#L263-L265\" rel=\"nofollow\">source</a>:</p>\n\n<pre><code>pub struct String {\n    vec: Vec&lt;u8&gt;, // &lt;- ?\n}\n\nimpl String {\n    // ...\n    pub fn new() -&gt; String {\n        String { vec: Vec::new() } // &lt;- ?\n    }\n    // ...\n }\n</code></pre>\n"}, {"tags": ["string", "rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 29, "last_activity_date": 1516759159, "last_edit_date": 1516759159, "creation_date": 1462918635, "answer_id": 37149882, "question_id": 37149831, "link": "https://stackoverflow.com/questions/37149831/what-is-the-difference-between-these-3-ways-of-declaring-a-string-in-rust/37149882#37149882", "title": "What is the difference between these 3 ways of declaring a string in Rust?", "body": "<pre><code>let hello1 = \"Hello, world!\";\n</code></pre>\n\n<p>This creates a <em>string slice</em> (<code>&amp;str</code>). Specifically, a <code>&amp;'static str</code>, a string slice that lives for the entire duration of the program. No heap memory is allocated; the data for the string lives within the binary of the program itself.</p>\n\n<pre><code>let hello2 = \"Hello, world!\".to_string();\n</code></pre>\n\n<p>This uses the formatting machinery to format <em>any</em> type that implements <code>Display</code>, creating an owned, allocated string (<code>String</code>). In versions of Rust before 1.9.0 (specifically because of <a href=\"https://github.com/rust-lang/rust/commit/fc8cf9c5afd531e825b3ae9a57f618c149dd3893\" rel=\"noreferrer\">this commit</a>), this is slower than directly converting using <code>String::from</code>. In version 1.9.0 and after, calling <code>.to_string()</code> on a string literal is the same speed as <code>String::from</code>.</p>\n\n<pre><code>let hello3 = String::from(\"Hello, world!\");\n</code></pre>\n\n<p>This converts a string slice to an owned, allocated string (<code>String</code>) in an efficient manner.</p>\n\n<pre><code>let hello4 = \"hello, world!\".to_owned();\n</code></pre>\n\n<p>The same as <code>String::from</code>.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/31331356/155423\">How to create a String directly?</a></li>\n<li><a href=\"https://stackoverflow.com/q/24158114/155423\">What are the differences between Rust&#39;s `String` and `str`?</a></li>\n</ul>\n"}], "owner": {"reputation": 2141, "user_id": 744184, "user_type": "registered", "accept_rate": 96, "profile_image": "https://www.gravatar.com/avatar/b3c344835e7d6c28d221702306647db6?s=128&d=identicon&r=PG", "display_name": "user", "link": "https://stackoverflow.com/users/744184/user"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1786, "favorite_count": 1, "accepted_answer_id": 37149882, "answer_count": 1, "score": 17, "last_activity_date": 1516759159, "creation_date": 1462918289, "last_edit_date": 1462918442, "question_id": 37149831, "link": "https://stackoverflow.com/questions/37149831/what-is-the-difference-between-these-3-ways-of-declaring-a-string-in-rust", "title": "What is the difference between these 3 ways of declaring a string in Rust?", "body": "<pre><code>let hello1 = \"Hello, world!\";\nlet hello2 = \"Hello, world!\".to_string();\nlet hello3 = String::from(\"Hello, world!\");\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "is_accepted": false, "score": 0, "last_activity_date": 1462891609, "creation_date": 1462891609, "answer_id": 37141914, "question_id": 37141691, "link": "https://stackoverflow.com/questions/37141691/why-can-a-variable-be-bound-to-another-value-even-its-ownership-has-moved/37141914#37141914", "title": "Why can a variable be bound to another value even its ownership has moved?", "body": "<p>I'm pretty sure this is a bug, since adding the line <code>println!(\"{}\", x.s)</code> at the end causes the compiler to complain.</p>\n"}], "owner": {"reputation": 9, "user_id": 6315766, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-Zm9PzSlY4mw/AAAAAAAAAAI/AAAAAAAAAH0/02KJKpgEE20/photo.jpg?sz=128", "display_name": "Houwu Chen", "link": "https://stackoverflow.com/users/6315766/houwu-chen"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 41, "favorite_count": 0, "closed_date": 1462891527, "answer_count": 1, "score": 0, "last_activity_date": 1462891609, "creation_date": 1462891141, "last_edit_date": 1462891421, "question_id": 37141691, "link": "https://stackoverflow.com/questions/37141691/why-can-a-variable-be-bound-to-another-value-even-its-ownership-has-moved", "closed_reason": "Duplicate", "title": "Why can a variable be bound to another value even its ownership has moved?", "body": "<p>In the following code, the ownership of <code>MyStruct { s: 5u32 }</code> is moved to <code>y</code> by <code>let y = x;</code>, but why does <code>x.s = 6</code> still work?</p>\n\n<pre><code>struct MyStruct {\n    s: u32,\n}\n\nfn main() {\n    let mut x = MyStruct { s: 5u32 };\n    let y = x;\n    x.s = 6; //why this line does not cause an error?\n    println!(\"{}\", y.s);\n}\n</code></pre>\n"}, {"tags": ["reflection", "rust", "introspection"], "comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1462891160, "post_id": 37140768, "comment_id": 61821907, "body": "You can\u2019t do that without a <i>rustc</i> plugin (works only on a nightly)."}, {"owner": {"reputation": 1509, "user_id": 2782135, "user_type": "registered", "accept_rate": 80, "profile_image": "https://graph.facebook.com/1796563079/picture?type=large", "display_name": "Alexander Arutinyants", "link": "https://stackoverflow.com/users/2782135/alexander-arutinyants"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1462892240, "post_id": 37140768, "comment_id": 61822753, "body": "Thanks @mcarton. I&#39;ll read about <a href=\"https://doc.rust-lang.org/book/compiler-plugins.html\" rel=\"nofollow noreferrer\">Compiler Plugins</a>. I really like to keep certain data in one place, so using field&#39;s name could be great. And I could move to nightly, so any help appreciated."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1462892641, "post_id": 37140768, "comment_id": 61823057, "body": "Unlikely to need a compiler plugin for your actual usecase; can probably use <code>#[derive(RustcDecodable)]</code> as <a href=\"https://github.com/BurntSushi/rust-csv\" rel=\"nofollow noreferrer\">described in the repository</a>. Doesn&#39;t answer the question you are asking though, which is a generic way to list <b>any</b> structs field names. My old friend, the <a href=\"http://xyproblem.info/\" rel=\"nofollow noreferrer\">XY Problem</a>."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1462892818, "post_id": 37140768, "comment_id": 61823193, "body": "Now that I think of it, syntax plugins are expanded before type analysis, so it would be rather tricky even in a plugin. There is some starter doc in <a href=\"https://doc.rust-lang.org/book/compiler-plugins.html\" rel=\"nofollow noreferrer\">the book</a>. You\u2019d need a <a href=\"https://manishearth.github.io/rust-internals-docs/rustc_plugin/registry/struct.Registry.html\" rel=\"nofollow noreferrer\">macro</a> and maybe a custom attribute for the type to inspect."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462892926, "post_id": 37140768, "comment_id": 61823272, "body": "@Shepmaster <code>#[derive(RustcDecodable)]</code> is a plugin :), but yeah, let\u2019s not reinvent the wheel. Also serde is usually better."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1462894477, "post_id": 37140768, "comment_id": 61824357, "body": "@mcarton an interesting philosophical question: &quot;Is a plugin that is always plugged-in still a plugin?&quot; ^_^. But as you pointed out, the important thing is to reuse existing work and potentially avoid needing to use the nightly compiler. Serde even has stable support (via <code>build.rs</code>) for pre-processing &quot;syntax extensions&quot;."}, {"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 1, "creation_date": 1488193630, "post_id": 37140768, "comment_id": 72107810, "body": "This can be also done by implementing your own procedural macro where you parse AST and create a trait implementation for your struct which returns the field names. I have done it personally 2 weeks ago but the code is not public and this question has already been closed. So just letting you know this is possible by some <code>#[derive(Introspection)]</code>."}, {"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 1, "creation_date": 1488440208, "post_id": 37140768, "comment_id": 72233841, "body": "@AlexanderArutinyants I will make it public during a week. I may tell you here when it happens if you are interested in this solution (all it needs is just to add <code>#[derive(Introspection)]</code> to your enum or struct."}, {"owner": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1488451443, "post_id": 37140768, "comment_id": 72241155, "body": "@AlexanderArutinyants <a href=\"https://github.com/vityafx/introspection\" rel=\"nofollow noreferrer\">here it is</a>. Hope this helps. I have not provide enough docs yet but you may already use it. I have plans for extending it&#39;s functionality in some future but somethings are just impossible to do :("}], "answers": [{"comments": [{"owner": {"reputation": 4622, "user_id": 996886, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/lSuAl.png?s=128&g=1", "display_name": "melak47", "link": "https://stackoverflow.com/users/996886/melak47"}, "edited": false, "score": 2, "creation_date": 1462897602, "post_id": 37143906, "comment_id": 61826397, "body": "Similar question and solution: <a href=\"http://stackoverflow.com/a/29986760/996886\">stackoverflow.com/a/29986760/996886</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 4622, "user_id": 996886, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/lSuAl.png?s=128&g=1", "display_name": "melak47", "link": "https://stackoverflow.com/users/996886/melak47"}, "edited": false, "score": 1, "creation_date": 1462900436, "post_id": 37143906, "comment_id": 61827971, "body": "@melak47 good point! Do you think that this question should be marked as a duplicate?"}, {"owner": {"reputation": 14227, "user_id": 1770633, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/11949228f54da11ed6dd248cd73a1e00?s=128&d=identicon&r=PG", "display_name": "jayphelps", "link": "https://stackoverflow.com/users/1770633/jayphelps"}, "edited": false, "score": 0, "creation_date": 1482689566, "post_id": 37143906, "comment_id": 69850417, "body": "can you enhance it..? hold on, I&#39;ll enhance it."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 20, "last_activity_date": 1462896846, "creation_date": 1462896846, "answer_id": 37143906, "question_id": 37140768, "link": "https://stackoverflow.com/questions/37140768/how-to-get-struct-field-names-in-rust/37143906#37143906", "title": "How to get struct field names in Rust?", "body": "<p>The current main method of metaprogramming in Rust is <a href=\"http://doc.rust-lang.org/stable/book/macros.html\">via macros</a>. In this case, you can capture all the field names and then add a method that returns string forms of them:</p>\n\n<pre><code>macro_rules! zoom_and_enhance {\n    (struct $name:ident { $($fname:ident : $ftype:ty),* }) =&gt; {\n        struct $name {\n            $($fname : $ftype),*\n        }\n\n        impl $name {\n            fn field_names() -&gt; &amp;'static [&amp;'static str] {\n                static NAMES: &amp;'static [&amp;'static str] = &amp;[$(stringify!($fname)),*];\n                NAMES\n            }\n        }\n    }\n}\n\nzoom_and_enhance!{\nstruct Export {\n    first_name: String,\n    last_name: String,\n    gender: String,\n    date_of_birth: String,\n    address: String\n}\n}\n\nfn main() {\n    println!(\"{:?}\", Export::field_names());\n}\n</code></pre>\n\n<p>For advanced macros, be sure to check out <a href=\"https://danielkeep.github.io/tlborm/book/README.html\"><em>The Little Book of Rust Macros</em></a>.</p>\n"}], "owner": {"reputation": 1509, "user_id": 2782135, "user_type": "registered", "accept_rate": 80, "profile_image": "https://graph.facebook.com/1796563079/picture?type=large", "display_name": "Alexander Arutinyants", "link": "https://stackoverflow.com/users/2782135/alexander-arutinyants"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 9185, "favorite_count": 1, "closed_date": 1462910257, "accepted_answer_id": 37143906, "answer_count": 1, "score": 12, "last_activity_date": 1462896846, "creation_date": 1462888813, "last_edit_date": 1462888993, "question_id": 37140768, "link": "https://stackoverflow.com/questions/37140768/how-to-get-struct-field-names-in-rust", "closed_reason": "Duplicate", "title": "How to get struct field names in Rust?", "body": "<p>Is there some equivalent of JS's <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" rel=\"noreferrer\">Object.keys()</a> for Rust's <a href=\"https://doc.rust-lang.org/book/structs.html\" rel=\"noreferrer\">struct</a>?</p>\n\n<p>I need something to generate CSV headers (I use <a href=\"http://burntsushi.net/rustdoc/csv/\" rel=\"noreferrer\">rust-csv</a>) from structure field names.</p>\n\n<pre><code>struct Export {\n    first_name: String,\n    last_name: String,\n    gender: String,\n    date_of_birth: String,\n    address: String\n}\n\n//... some code\n\nlet mut wrtr = Writer::from_file(\"/home/me/export.csv\").unwrap().delimiter(b'\\t');\n\nwrtr.encode(/* WHAT TO WRITE HERE TO GET STRUCT NAMES as tuple of strings or somethings */).is_ok()\n</code></pre>\n"}, {"tags": ["vector", "iterator", "rust", "max"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1462844150, "post_id": 37127209, "comment_id": 61796263, "body": "<a href=\"http://stackoverflow.com/questions/29884402/how-do-i-implement-ord-for-a-struct\">Implement <code>Ord</code></a> for a wrapper type around the <code>f64</code>. This forces you to define how <code>NaN</code> is handled. <a href=\"http://stackoverflow.com/q/28247990/155423\">Examples exist</a> for similar things."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1526142420, "post_id": 37127209, "comment_id": 87632654, "body": "Do <b>not</b> use <code>.unwrap_or(Less)</code> \u2014 this <a href=\"https://stackoverflow.com/a/50308360/155423\">gives unstable results in the presence of NaN</a>."}], "answers": [{"comments": [{"owner": {"reputation": 5770, "user_id": 2980246, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/hpOec.png?s=128&g=1", "display_name": "jayelm", "link": "https://stackoverflow.com/users/2980246/jayelm"}, "edited": false, "score": 0, "creation_date": 1462917241, "post_id": 37144472, "comment_id": 61837193, "body": "Seems like no intrinsic way to do this without implementing/including a wrapper type, so I&#39;ll accept this. Thanks!"}], "tags": [], "owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "is_accepted": true, "score": 4, "last_activity_date": 1462898814, "creation_date": 1462898814, "answer_id": 37144472, "question_id": 37127209, "link": "https://stackoverflow.com/questions/37127209/using-max-by-key-on-a-vector-of-floats/37144472#37144472", "title": "Using max_by_key on a vector of floats", "body": "<p>If you do not want to create a wrapper type you can use the <a href=\"https://crates.io/crates/ordered-float\" rel=\"nofollow\">ordered_float</a> or <a href=\"https://crates.io/crates/ord_subset\" rel=\"nofollow\">ord_subset</a> crate. For example</p>\n\n<pre><code>extern crate ordered_float;\nextern crate ord_subset;\n\n#[test]\nfn test_example_() {\n    use ordered_float::OrderedFloat;\n    // OrderedFloat -&gt; NaN is greater than all other values and equal to itself.\n    // NotNaN -&gt; NotNaN::new panics if called with NaN.\n\n    let mut a: Vec&lt;f64&gt; = vec![-3.0, 0.2, 1.4];\n\n    let max = *a.iter().max_by_key(|n| OrderedFloat(n.abs())).unwrap();\n    assert_eq!(-3.0, max);\n\n    a.sort_by_key(|n| OrderedFloat(n.abs()));\n    assert_eq!(vec![0.2, 1.4, -3.0], a);\n}\n\n#[test]\nfn test_example_ord_subset() {\n    use ord_subset::OrdSubsetIterExt;\n\n    let a: Vec&lt;f64&gt; = vec![-3.0, 0.2, 1.4];\n\n    // For f64, NaN is ignored.\n    let max = *a.iter().ord_subset_max_by_key(|n| n.abs()).unwrap();\n    assert_eq!(-3.0, max);\n\n    // ord_subset does not help with the sorting problem in the question\n}\n</code></pre>\n"}], "owner": {"reputation": 5770, "user_id": 2980246, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/hpOec.png?s=128&g=1", "display_name": "jayelm", "link": "https://stackoverflow.com/users/2980246/jayelm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2380, "favorite_count": 0, "accepted_answer_id": 37144472, "answer_count": 1, "score": 2, "last_activity_date": 1526142332, "creation_date": 1462838046, "last_edit_date": 1526142332, "question_id": 37127209, "link": "https://stackoverflow.com/questions/37127209/using-max-by-key-on-a-vector-of-floats", "title": "Using max_by_key on a vector of floats", "body": "<p>I want to use <code>max_by_key</code> to get the maximum value from a vector of <code>f64</code>s based on a certain key. This is a simple example, with a small vector and <code>abs</code> as the key:</p>\n\n<pre><code>let a: Vec&lt;f64&gt; = vec![-3.0, 0.2, 1.4];\n*a.iter().max_by_key(|n| n.abs()).unwrap()\n</code></pre>\n\n<p>However, since <code>f64</code> does not implement <code>Ord</code>, I get</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>    error[E0277]: the trait bound `f64: std::cmp::Ord` is not satisfied\n --&gt; src/main.rs:3:15\n  |\n3 |     *a.iter().max_by_key(|n| n.abs()).unwrap();\n  |               ^^^^^^^^^^ the trait `std::cmp::Ord` is not implemented for `f64`\n</code></pre>\n\n<p>Similarly, <code>sort_by_key</code> fails with the same error:</p>\n\n<pre><code>a.sort_by_key(|n| n.abs())\n</code></pre>\n\n<p>I know I can get around the partial ordering restriction to sort a vector of floats with <code>sort_by</code></p>\n\n<pre><code>b.sort_by(|m, n| m.partial_cmp(n).unwrap_or(Less))\n</code></pre>\n\n<p>but that would have to be called on a vector <code>b</code> for which I've computed the key (in this case <code>abs</code>) for each element of <code>a</code>, and then I would have to go back and find the corresponding element of <code>a</code>, which seems complicated and slow. As the number of items in the list grows, I'd like to minimize passes through the data.</p>\n\n<p>Are there any workarounds?</p>\n"}, {"tags": ["lua", "rust", "rust-cargo"], "comments": [{"owner": {"reputation": 3821, "user_id": 3677376, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/345ca06e9690f13ec2cde085a7ef6e57?s=128&d=identicon&r=PG&f=1", "display_name": "siffiejoe", "link": "https://stackoverflow.com/users/3677376/siffiejoe"}, "edited": false, "score": 0, "creation_date": 1462833117, "post_id": 37126284, "comment_id": 61793672, "body": "Compiling the C modules against stock Lua 5.3 (any release) should work fine. If you don&#39;t want to rely on separate dynamic libraries, you could link statically and add the relevant <code>luaopen_*</code> functions to <code>package.preload</code>. <code>rust-lua53</code> even seems to have a <code>preload_library</code> method for just that ..."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 3821, "user_id": 3677376, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/345ca06e9690f13ec2cde085a7ef6e57?s=128&d=identicon&r=PG&f=1", "display_name": "siffiejoe", "link": "https://stackoverflow.com/users/3677376/siffiejoe"}, "edited": false, "score": 0, "creation_date": 1462835279, "post_id": 37126284, "comment_id": 61794268, "body": "I&#39;d forgotten that Lua is ABI compatible in minor releases, thanks, so the &quot;getting away with it&quot; works. It still seems non-ideal downloading Lua separately in each crate for that though, so I&#39;d be interested in any improvements to the situation."}, {"owner": {"reputation": 3821, "user_id": 3677376, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/345ca06e9690f13ec2cde085a7ef6e57?s=128&d=identicon&r=PG&f=1", "display_name": "siffiejoe", "link": "https://stackoverflow.com/users/3677376/siffiejoe"}, "edited": false, "score": 0, "creation_date": 1462845891, "post_id": 37126284, "comment_id": 61796619, "body": "On Unixes you only need the public Lua headers (4 files) for building extension modules. You could just add those to your repository. But what do you need the crates for? LFS and LPeg are most likely available in your favorite deb or rpm repository, or you could use LuaRocks or LuaDist to build the Lua extension modules. That&#39;s what they are designed for."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 3821, "user_id": 3677376, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/345ca06e9690f13ec2cde085a7ef6e57?s=128&d=identicon&r=PG&f=1", "display_name": "siffiejoe", "link": "https://stackoverflow.com/users/3677376/siffiejoe"}, "edited": false, "score": 0, "creation_date": 1462862020, "post_id": 37126284, "comment_id": 61801447, "body": "I don&#39;t <i>need</i> crates, but I thought it might be nice to split those out as more generally useful."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 3821, "user_id": 3677376, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/345ca06e9690f13ec2cde085a7ef6e57?s=128&d=identicon&r=PG&f=1", "display_name": "siffiejoe", "link": "https://stackoverflow.com/users/3677376/siffiejoe"}, "edited": false, "score": 0, "creation_date": 1462862241, "post_id": 37126284, "comment_id": 61801554, "body": "I like the idea of embedding LuaRocks as a more general solution, but I&#39;m not convinced about using distribution packages. Lua 5.3 isn&#39;t that common yet, and I&#39;d prefer not to need the administrator to have to install things."}], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 786, "favorite_count": 1, "answer_count": 0, "score": 1, "last_activity_date": 1462832028, "creation_date": 1462832028, "question_id": 37126284, "link": "https://stackoverflow.com/questions/37126284/building-lua-modules-for-lua-embedded-in-rust-rust-lua53", "title": "Building Lua modules for Lua embedded in Rust (rust-lua53)", "body": "<p>I'm currently using the <a href=\"https://github.com/jcmoyer/rust-lua53\" rel=\"nofollow\">rust-lua53</a> crate to embed Lua into a Rust project.  rust-lua53 downloads and builds the Lua tarball during \"cargo build\" (in its build.rs).</p>\n\n<p>I'd like to make other Lua libraries (written in C) available to Lua code in my application, eg <a href=\"http://www.inf.puc-rio.br/~roberto/lpeg/\" rel=\"nofollow\">LPeg</a> or <a href=\"https://keplerproject.github.io/luafilesystem/\" rel=\"nofollow\">LFS</a>, but it's not obvious to me how to do it.</p>\n\n<p>My ideas so far are:</p>\n\n<ul>\n<li>Build the libraries against a stock Lua and hope I get away with it (or have to check it matches every subsequent rust-lua53 release)</li>\n<li>Somehow expose the relevant headers from rust-lua53 (can a crate include extra files like that?)</li>\n<li>Change to a different Rust/Lua binding which somehow makes this easier.</li>\n<li>Fork rust-lua53 and make it embed the extra libraries I want as well as the plain Lua interpreter.</li>\n<li>Implement the functionality in Rust instead of relying on C libraries.  Plausible for LFS in my application, but re-implementing LPeg is beyond what I want to do right now!</li>\n</ul>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 13883, "user_id": 2883245, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/NPpPG.jpg?s=128&g=1", "display_name": "erip", "link": "https://stackoverflow.com/users/2883245/erip"}, "edited": false, "score": 0, "creation_date": 1462832418, "post_id": 37126325, "comment_id": 61793411, "body": "What makes C++ moves particularly unsafe?"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 13883, "user_id": 2883245, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/NPpPG.jpg?s=128&g=1", "display_name": "erip", "link": "https://stackoverflow.com/users/2883245/erip"}, "edited": false, "score": 1, "creation_date": 1462832539, "post_id": 37126325, "comment_id": 61793447, "body": "While in Rust, the compiler guarantees that the programmer can&#39;t access an object that has been moved, C++ allows using the moved object. In particularly bad cases you could access pointers to freed memory or other invalid data."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1462832768, "post_id": 37126325, "comment_id": 61793532, "body": "This is not more unsafe than anything else in C++. Eg. in C++ a copy constructor might copy a raw pointer and then you\u2019d get a double-free. C++ just expects you to implement a well-behaved {copy,move} constructor here."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1462832863, "post_id": 37126325, "comment_id": 61793562, "body": "Sorry, I didn&#39;t mean to say that C++ moves are unsaf<i>er</i> than everything else in C++."}, {"owner": {"reputation": 143, "user_id": 1157452, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/063562595b02fab8db45db8793dcaa2d?s=128&d=identicon&r=PG", "display_name": "royalstream", "link": "https://stackoverflow.com/users/1157452/royalstream"}, "edited": false, "score": 0, "creation_date": 1462832907, "post_id": 37126325, "comment_id": 61793576, "body": "Thanks for the answer. I understand C++11/14 move semantics but C++ is a language I&#39;m confortable with. With Rust I&#39;m just starting to get my feet wet and I want to know whats going on behind the curtains. You are right, I was assuming Rust was (magically) avoiding a copy altogether when move semantics were used on a non-Copy type."}, {"owner": {"reputation": 143, "user_id": 1157452, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/063562595b02fab8db45db8793dcaa2d?s=128&d=identicon&r=PG", "display_name": "royalstream", "link": "https://stackoverflow.com/users/1157452/royalstream"}, "edited": false, "score": 0, "creation_date": 1462833022, "post_id": 37126325, "comment_id": 61793635, "body": "Regarding the recursive data structure, what&#39;s wrong with storing two references/pointers to BinaryTreeNode instead of boxing them?"}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 143, "user_id": 1157452, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/063562595b02fab8db45db8793dcaa2d?s=128&d=identicon&r=PG", "display_name": "royalstream", "link": "https://stackoverflow.com/users/1157452/royalstream"}, "edited": false, "score": 0, "creation_date": 1462833561, "post_id": 37126325, "comment_id": 61793788, "body": "@royalstream Well... who would be responsible for freeing it then? A <code>Box</code> is just a pointer, that frees the memory when it goes out of scope. Of course you could pre-allocate all tree-nodes somewhere else and take care of deallocation is some special way. But it&#39;s easiest to say that the parent node owns it&#39;s children and hence is responsible for freeing them."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1462833612, "post_id": 37126325, "comment_id": 61793798, "body": "If you were using references who would own the nodes? As for raw pointers they are avoided in Rust because unsafe."}, {"owner": {"reputation": 143, "user_id": 1157452, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/063562595b02fab8db45db8793dcaa2d?s=128&d=identicon&r=PG", "display_name": "royalstream", "link": "https://stackoverflow.com/users/1157452/royalstream"}, "edited": false, "score": 0, "creation_date": 1462834483, "post_id": 37126325, "comment_id": 61794063, "body": "I was thinking of references using a lifetime parameter (like I&#39;ve seen in several examples). But you&#39;re right, that will imply someone else owns them which is unnatural for such a structure. Thanks again."}, {"owner": {"reputation": 4240, "user_id": 1541330, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/9d7b0057ffc24e644c4a30ba599d7753?s=128&d=identicon&r=PG&f=1", "display_name": "U007D", "link": "https://stackoverflow.com/users/1541330/u007d"}, "reply_to_user": {"reputation": 143, "user_id": 1157452, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/063562595b02fab8db45db8793dcaa2d?s=128&d=identicon&r=PG", "display_name": "royalstream", "link": "https://stackoverflow.com/users/1157452/royalstream"}, "edited": false, "score": 0, "creation_date": 1474579058, "post_id": 37126325, "comment_id": 66601409, "body": "@royalstream Since null references are not valid in Rust, they would have to reference actual instances of BinaryTreeNode (in this example).  That would put us back to infinite recursion."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 5, "last_activity_date": 1462832421, "last_edit_date": 1462832421, "creation_date": 1462832246, "answer_id": 37126325, "question_id": 37125998, "link": "https://stackoverflow.com/questions/37125998/boxx-vs-move-semantics-on-x/37126325#37126325", "title": "Box&lt;X&gt; vs move semantics on X", "body": "<p><strong>First of all:</strong> C++11 (and newer) has move semantics with rvalue references, too. So your question would also apply to C++. Keep in mind though, that C++'s move semantics are -- unlike Rust's ones -- highly unsafe.</p>\n\n<p><strong>Second:</strong> the word \"move semantic\" somehow hints the absence of a \"copy\", which is not true. Suppose you have a <code>struct</code> with 100 64-bit integers. If you would transfer an object of this struct via move semantics, those 100 integers will be copied (of course, the compiler's optimizer can often remove those copies, but anyway...). The advantage of move semantics comes to play when dealing with objects that deal with some kind of data on the heap (or pointers in general). </p>\n\n<p>For example, take a look at <code>Vec</code> (similar to C++'s <code>vector</code>): the type itself only contains a pointer and two pointer-sized integer (<code>ptr</code>, <code>len</code> and <code>cap</code>). Those three times 64bit are still copied when the vector is moved, but the main data of the vector (which lives on the heap) is not touched. </p>\n\n<hr>\n\n<p>That being said, let's discuss the main question: \"<strong>Why to use <code>Box</code> at all?</strong>\". There are actually many use cases:</p>\n\n<ul>\n<li><em>Unsized types</em>: some types (e.g. Trait-objects which also includes closures) are unsized, meaning their size is not known to the compiler. But the compiler has to know the size of each stack frame -- hence those unsized types cannot live on the stack. </li>\n<li><em>Recursive data structures</em>: think of a <code>BinaryTreeNode</code> struct. It saves two members named \"left\" and \"right\" of type... <code>BinaryTreeNode</code>? That won't work. So you can box both children so that the compiler knows the size of your struct.</li>\n<li><em>Huge structs</em>: think of the 100 integer struct mentioned above. If you don't want to copy it every time, you can allocate it on the heap (this happens pretty seldom).</li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": false, "score": 1, "last_activity_date": 1462832258, "creation_date": 1462832258, "answer_id": 37126327, "question_id": 37125998, "link": "https://stackoverflow.com/questions/37125998/boxx-vs-move-semantics-on-x/37126327#37126327", "title": "Box&lt;X&gt; vs move semantics on X", "body": "<p>There are cases where you can\u2019t return <code>X</code> eg. if <code>X</code> is <code>?Sized</code> (traits, non-compile-time-sized arrays, etc.). In those cases <code>Box&lt;X&gt;</code> will still work.</p>\n"}], "owner": {"reputation": 143, "user_id": 1157452, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/063562595b02fab8db45db8793dcaa2d?s=128&d=identicon&r=PG", "display_name": "royalstream", "link": "https://stackoverflow.com/users/1157452/royalstream"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 222, "favorite_count": 1, "accepted_answer_id": 37126325, "answer_count": 2, "score": 3, "last_activity_date": 1462832421, "creation_date": 1462830437, "question_id": 37125998, "link": "https://stackoverflow.com/questions/37125998/boxx-vs-move-semantics-on-x", "title": "Box&lt;X&gt; vs move semantics on X", "body": "<p>I have an easy question regarding <code>Box&lt;X&gt;</code>. \nI understand what it does, it allocates <code>X</code> on the heap.\nIn C++ you use the <strong>new</strong> operator to allocate something on the heap so it can outlive the current scope (because if you create something on the stack it goes away at the end of the current block).</p>\n\n<p>But reading Rust's documentation, it <strong>looks</strong> like you can create something on the stack and still return it taking advantage of the language's move semantics without having to resort to the heap.\nThen it's not clear to me when to use <code>Box&lt;X&gt;</code> as opposed to simply <code>X</code>. </p>\n\n<p>I just started reading about Rust so I apologize if I'm missing something obvious.</p>\n"}, {"tags": ["iterator", "rust", "flatmap"], "comments": [{"owner": {"reputation": 49065, "user_id": 13422, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/94b309d78a1253a334e9b82643a8dc97?s=128&d=identicon&r=PG", "display_name": "Zan Lynx", "link": "https://stackoverflow.com/users/13422/zan-lynx"}, "edited": false, "score": 1, "creation_date": 1462902372, "post_id": 37124645, "comment_id": 61829019, "body": "In C++ programs referencing a temporary like this is one of the most common errors I discover. It usually lasts just long enough to pass testing, until the compiler updates or someone adds a new variable to the local scope. Nice that it caught this one for you."}], "answers": [{"tags": [], "owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "is_accepted": true, "score": 2, "last_activity_date": 1462825148, "creation_date": 1462825148, "answer_id": 37124734, "question_id": 37124645, "link": "https://stackoverflow.com/questions/37124645/flat-map-on-chars-causes-borrow-checker-error/37124734#37124734", "title": "flat_map on Chars causes borrow checker error", "body": "<p>Iterators are lazy and can only live as long as their iteratee lives. <code>j.to_string()</code> is temporary and only lives inside the closure, hence the closure cannot return <code>j.to_string().chars()</code>.\nA simple solution would be to collect the characters before returning:</p>\n\n<pre><code>fn main() {\n    let iter = (1..).flat_map(|j| j.to_string().chars().collect::&lt;Vec&lt;_&gt;&gt;());\n    for i in iter {\n        println!(\"{}\", i);\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1462906867, "post_id": 37145452, "comment_id": 61831678, "body": "Mine was a simple way to get around the error but this would be better in real life."}], "tags": [], "owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "is_accepted": false, "score": 2, "last_activity_date": 1462903409, "last_edit_date": 1462903409, "creation_date": 1462902049, "answer_id": 37145452, "question_id": 37124645, "link": "https://stackoverflow.com/questions/37124645/flat-map-on-chars-causes-borrow-checker-error/37145452#37145452", "title": "flat_map on Chars causes borrow checker error", "body": "<p>One problem with the solution that uses <code>collect</code> is that it keeps allocating strings and vectors. If you need a implementation that does the minimum allocation, you can implement your own iterator:</p>\n\n<pre><code>#[derive(Default)]\nstruct NumChars {\n    num: usize,\n    num_str: Vec&lt;u8&gt;,\n    next_index: usize,\n}\n\nimpl Iterator for NumChars {\n    type Item = char;\n\n    fn next(&amp;mut self) -&gt; Option&lt;char&gt; {\n        use std::io::Write;\n        if self.next_index &gt;= self.num_str.len() {\n            self.next_index = 0;\n            self.num += 1;\n            self.num_str.clear();\n            write!(&amp;mut self.num_str, \"{}\", self.num).expect(\"write failed\");\n        }\n\n        let index = self.next_index;\n        self.next_index += 1;\n        Some(self.num_str[index] as char)\n    }\n}\n\nfn main() {\n    assert_eq!(\n        vec!['1', '2', '3', '4', '5', '6', '7', '8', '9', '1', '0', '1', '1'],\n        NumChars::default().take(13).collect::&lt;Vec&lt;_&gt;&gt;()\n    );\n}\n</code></pre>\n"}], "owner": {"reputation": 192, "user_id": 2288351, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dd14cd2413d2c7c5e02c14df879802b4?s=128&d=identicon&r=PG", "display_name": "lennoff", "link": "https://stackoverflow.com/users/2288351/lennoff"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 69, "favorite_count": 0, "accepted_answer_id": 37124734, "answer_count": 2, "score": 1, "last_activity_date": 1462903409, "creation_date": 1462824800, "question_id": 37124645, "link": "https://stackoverflow.com/questions/37124645/flat-map-on-chars-causes-borrow-checker-error", "title": "flat_map on Chars causes borrow checker error", "body": "<p>I'm trying to generate a sequence like this: <code>1,2,3,4,5,6,7,8,9,1,0,1,1,1,2...</code></p>\n\n<pre><code>fn main() {\n    let iter = (1..).flat_map(|j| j.to_string().chars());\n    for i in iter {\n        println!(\"{}\", i);\n    }\n}\n</code></pre>\n\n<p>This does not work, because <code>j.to_string()</code> goes out of scope I believe (but why?)</p>\n\n<pre><code>p040.rs:2:35: 2:48 error: borrowed value does not live long enough\np040.rs:2     let iter = (1..).flat_map(|j| j.to_string().chars());\n                                            ^~~~~~~~~~~~~\np040.rs:2:58: 6:2 note: reference must be valid for the block suffix following statement 0 at 2:57...\np040.rs:2     let iter = (1..).flat_map(|j| j.to_string().chars());\np040.rs:3     for i in iter {\np040.rs:4         println!(\"{}\", i);\np040.rs:5     }\np040.rs:6 }\np040.rs:2:35: 2:56 note: ...but borrowed value is only valid for the block at 2:34\np040.rs:2     let iter = (1..).flat_map(|j| j.to_string().chars());\n                                            ^~~~~~~~~~~~~~~~~~~~~\n</code></pre>\n\n<p>How could I solve this compiler error?</p>\n"}, {"tags": ["segmentation-fault", "rust", "ffi", "libspotify"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462821961, "post_id": 37123707, "comment_id": 61788538, "body": "<i>I currently do not have a Linux machine at my disposal</i> \u2014 Docker and various VM solutions are free to use and downloading and installing something like Ubuntu is very straight-forward. Not that you have to do this, but don&#39;t think you need a whole machine."}, {"owner": {"reputation": 612, "user_id": 2000501, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/300e000ea32ccfe1f64d0c0917250760?s=128&d=identicon&r=PG", "display_name": "Moritz Gunz", "link": "https://stackoverflow.com/users/2000501/moritz-gunz"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462865654, "post_id": 37123707, "comment_id": 61803470, "body": "I just tried running my code on a VM, and it segfaults too! So there might be something wrong with the interop code."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462884354, "post_id": 37123707, "comment_id": 61816669, "body": "Can you try <code>app_key.as_ptr() as *const c_void</code> instead? My guess is that you are casting the slice to a void pointer, not the data contained within the slice. <code>0x1C0</code> is 448 in decimal, which could <i>conceivably</i> be the length of the slice."}, {"owner": {"reputation": 612, "user_id": 2000501, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/300e000ea32ccfe1f64d0c0917250760?s=128&d=identicon&r=PG", "display_name": "Moritz Gunz", "link": "https://stackoverflow.com/users/2000501/moritz-gunz"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462890816, "post_id": 37123707, "comment_id": 61821621, "body": "<code>.as_ptr()</code>returns a <code>*const c_char</code>, so I&#39;m not sure that casting it to a const void would help. It probably won&#39;t even compile since Spotify requests a const char."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462891100, "post_id": 37123707, "comment_id": 61821860, "body": "The important part is <code>as_ptr</code>. The void cast was just keeping what you already had; remove it if unneeded."}, {"owner": {"reputation": 612, "user_id": 2000501, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/300e000ea32ccfe1f64d0c0917250760?s=128&d=identicon&r=PG", "display_name": "Moritz Gunz", "link": "https://stackoverflow.com/users/2000501/moritz-gunz"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462902839, "post_id": 37123707, "comment_id": 61829296, "body": "Ah, I misread your post (was on mobile). Thought you were referring to the strings. Sill no luck, though."}], "owner": {"reputation": 612, "user_id": 2000501, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/300e000ea32ccfe1f64d0c0917250760?s=128&d=identicon&r=PG", "display_name": "Moritz Gunz", "link": "https://stackoverflow.com/users/2000501/moritz-gunz"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 82, "favorite_count": 0, "answer_count": 0, "score": 3, "last_activity_date": 1462821353, "creation_date": 1462821353, "question_id": 37123707, "link": "https://stackoverflow.com/questions/37123707/sp-session-create-segfaults-when-called-from-rust-ffi", "title": "sp_session_create segfaults when called from Rust FFI", "body": "<p>Since Spotify is unlikely to provide a successor to libspotify anytime soon, I'm trying to wrap it into a thin Rust library that I can use for other projects. I'm using Bindings generated from the header file by rust-bindgen. Since they are quite long (~1100 lines) and not that easy to shrink down to only the important bits, I created a <a href=\"http://pastebin.com/ggXsRKAr\" rel=\"nofollow\">pastebin</a> containing the code.</p>\n\n<p>Calling <a href=\"https://developer.spotify.com/docs/libspotify/12.1.51/api_8h.html#a181d0940997cb8b69869449cd826cf88\" rel=\"nofollow\">sp_build_id</a> works just fine, invoking <a href=\"https://developer.spotify.com/docs/libspotify/12.1.51/group__session.html#gaf2891f2daced4ff6da84219d6376b3aa\" rel=\"nofollow\">sp_session_create</a> on the other hand, causes a segfault at address <code>0x000001C0</code>. Searching for libspotify and that memory address yielded <a href=\"https://stackoverflow.com/questions/17438339/c-marshall-strings-to-utf8-char\">this post</a>. It suggests that something is wrong with the string marshalling, I just cannot figure out what it could be or if it indeed is the string marshalling.</p>\n\n<p>This is how I call the method:</p>\n\n<pre><code>fn main() {\n    let app_key = include_bytes!(env!(\"SP_APP_KEY_PATH\"));\n    let cache_path = ::std::ffi::CString::new(env!(\"SP_CACHE_PATH\")).unwrap();\n\n    let config = sp_session_config {\n        api_version: 12,\n        cache_location: cache_path.as_ptr(),\n        settings_location: cache_path.as_ptr(),\n        application_key: &amp;app_key[..] as *const _ as *const ::std::os::raw::c_void,\n        application_key_size: app_key.len() as u64,\n        ..Default::default()\n    };\n\n    let mut ptr = ::std::ptr::null_mut();\n    match unsafe { sp_session_create(&amp;config, &amp;mut ptr) } {\n        Enum_sp_error::SP_ERROR_OK =&gt; println!(\"Session creation succeeded!\"),\n        err =&gt; println!(\"Session creation failed! {:?}\", err)\n    }\n}\n</code></pre>\n\n<p><code>SP_CACHE_PATH</code> points to a folder in my PC in which libspotify can store its assets and <code>SP_APP_KEY_PATH</code> points to the binary file with the application key. This all works fine (I have checked the generated code after the macros).</p>\n\n<p><code>sp_session_create</code> looks like this:</p>\n\n<pre><code>#[link(name = \"libspotify\")]\nextern \"system\" {\n    pub fn sp_session_create(config: *const sp_session_config, sess: *mut *mut sp_session) -&gt; sp_error;\n}\n</code></pre>\n\n<p>The <code>system</code>-callconv expands to <code>stdcall</code> on 32-bit and <code>cdecl</code> on 64-bit, so it should just work for libspotify.</p>\n\n<p>I'm running Windows 10, Rust nightly 1.10 32-bit MSVC and I'm using libspotify 12.1.51. I currently do not have a Linux machine at my disposal, so it's kinda hard to test the code on other operating systems. I'd be glad if somebody else could try to test out the code and see if it works for them or not. I'd also gladly appreciate any ideas on how I might improve the FFI code.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1462814291, "last_edit_date": 1592644375, "creation_date": 1462814291, "answer_id": 37121739, "question_id": 37120675, "link": "https://stackoverflow.com/questions/37120675/getting-enumerate-to-work-as-exactsizeiterator-in-rust/37121739#37121739", "title": "Getting Enumerate to work as ExactSizeIterator in Rust", "body": "<p>The <a href=\"http://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html\" rel=\"nofollow noreferrer\">docs for <code>ExactSizeIterator</code></a> state:</p>\n<blockquote>\n<p>An iterator that knows its exact length.</p>\n<p>Many <code>Iterator</code>s don't know how many times they will iterate, but some do. If an iterator knows how many times it can iterate, providing access to that information can be useful. For example, if you want to iterate backwards, a good start is to know where the end is.</p>\n</blockquote>\n<p>But that's not the actual trait required by <code>rev</code>!</p>\n<pre><code>fn rev(self) -&gt; Rev&lt;Self&gt; \n    where Self: DoubleEndedIterator\n</code></pre>\n<p>The <code>ExactSizeIterator</code> requirement comes from <code>Enumerate</code>'s implementation of <code>DoubleEndedIterator</code>:</p>\n<pre><code>impl&lt;I&gt; DoubleEndedIterator for Enumerate&lt;I&gt;\n    where I: ExactSizeIterator + DoubleEndedIterator\n</code></pre>\n<blockquote>\n<p>Is it possible to get an <code>ExactSizeIterator</code> in this case, or does the length of the iterator need to be baked in at compile time?</p>\n</blockquote>\n<p>The <code>Chars</code> iterator needs to support <em>both</em> <code>ExactSizeIterator</code> and <code>DoubleEndedIterator</code>, but it only natively supports <code>DoubleEndedIterator</code>.</p>\n<p>In order to implement <code>ExactSizeIterator</code> for <code>Chars</code>, you'd need to be able to look at an arbitrary string and know (in a small enough time) how many characters it is made of. This is not generally possible with the UTF-8 encoding, the only encoding of Rust strings.</p>\n<p>The length of the iterator is never a compile-time constant.</p>\n<blockquote>\n<p>is it just a matter of specifying the iterator with something like <code>as ExactSizeIterator</code></p>\n</blockquote>\n<p>You cannot make a type into something it is not.</p>\n<p>If you <em>really</em> need this, you could collect it all into a big <code>Vec</code>:</p>\n<pre><code>fn main() {\n    let chars: Vec&lt;_&gt; = &quot;dummy string&quot;.chars().collect();\n    for (j, val) in chars.into_iter().enumerate().rev() {\n        println!(&quot;{}, {}&quot;, j, val)\n    }\n}\n</code></pre>\n<p>It's also possible you actually want the characters in reverse order with the count in increasing direction:</p>\n<pre><code>fn main() {\n    for (j, val) in &quot;dummy string&quot;.chars().rev().enumerate() {\n        println!(&quot;{}, {}&quot;, j, val)\n    }\n}\n</code></pre>\n<p>But you said this:</p>\n<blockquote>\n<p>a character and its index in the slice</p>\n</blockquote>\n<p>Since strings are UTF-8, it's possible you mean you want the number of <em>bytes</em> into the slice. That can be found with the <a href=\"http://doc.rust-lang.org/std/primitive.str.html#method.char_indices\" rel=\"nofollow noreferrer\"><code>char_indices</code></a> iterator:</p>\n<pre><code>fn main() {\n    for (j, val) in &quot;dummy string&quot;.char_indices().rev() {\n        println!(&quot;{}, {}&quot;, j, val)\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 623, "user_id": 1569573, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/38b8d6aa83833a196b04a61d0ccd6dcb?s=128&d=identicon&r=PG", "display_name": "Don Rowe", "link": "https://stackoverflow.com/users/1569573/don-rowe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 590, "favorite_count": 0, "accepted_answer_id": 37121739, "answer_count": 1, "score": 0, "last_activity_date": 1462814291, "creation_date": 1462810682, "last_edit_date": 1462813465, "question_id": 37120675, "link": "https://stackoverflow.com/questions/37120675/getting-enumerate-to-work-as-exactsizeiterator-in-rust", "title": "Getting Enumerate to work as ExactSizeIterator in Rust", "body": "<p>I want to use Rust's <a href=\"https://doc.rust-lang.org/std/iter/struct.Enumerate.html\" rel=\"nofollow\" title=\"Enumerate\"><code>Enumerate</code></a> to get both a character and its index in the slice from each iteration:</p>\n\n<pre><code>fn main() {\n    for (j, val) in \"dummy string\".chars().enumerate().rev() {\n        // ...\n    }\n}\n</code></pre>\n\n<p>When I compile with <code>cargo run</code> I get:</p>\n\n<pre><code>error: the trait `core::iter::ExactSizeIterator` is not implemented for the type `core::str::Chars&lt;'_&gt;` [E0277]\n    for (j, val) in \"dummy string\".chars().enumerate().rev() {\n                                                       ^~~\nhelp: see the detailed explanation for E0277\n\nerror: the trait `core::iter::ExactSizeIterator` is not implemented for the type `core::str::Chars&lt;'_&gt;` [E0277]\n    for (j, val) in \"dummy string\".chars().enumerate().rev() {\n        // ...\n    }\n</code></pre>\n\n<p>I can understand why this would fail: the <code>rev</code> method needs an <code>ExactSizeIterator</code> since it needs to know the last element in the slice and its index from the beginning. Is it possible to get an <code>ExactSizeIterator</code> in this case, or does the length of the iterator need to be baked in at compile time? If it is possible, is it just a matter of specifying the iterator with something like <code>as ExactSizeIterator</code> or something like that?</p>\n"}, {"tags": ["io", "rust", "child-process"], "comments": [{"owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 1, "creation_date": 1462790076, "post_id": 37109336, "comment_id": 61768346, "body": "- &quot;<i>so I want to avoid spawning a thread per task</i>&quot; - <code>Popen.communicate</code> does in fact use threads when working with more than two pipes: <a href=\"http://stackoverflow.com/a/12965273/257568\">stackoverflow.com/a/12965273/257568</a>. So, in your case, can the communication be limited to two pipes?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 0, "creation_date": 1462798537, "post_id": 37109336, "comment_id": 61773750, "body": "@ArtemGr Do you mean <b>less</b> than two pipes? The comment in the linked question says &quot;If we are only using one pipe, or no pipe at all&quot;."}, {"owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462811679, "post_id": 37109336, "comment_id": 61782841, "body": "@Shepmaster Right, sorry, if there&#39;s less than one pipe then threading or non-blocking I/O is unnecessary."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 0, "creation_date": 1462813065, "post_id": 37109336, "comment_id": 61783626, "body": "@ArtemGr lol, <i>less than one</i> would only be zero pipes, and <i>any</i> I/O would be unnecessary ;-)"}, {"owner": {"reputation": 483, "user_id": 4280035, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e442215473aa322da127ee74c79c7477?s=128&d=identicon&r=PG&f=1", "display_name": "hellcatv", "link": "https://stackoverflow.com/users/4280035/hellcatv"}, "edited": false, "score": 0, "creation_date": 1462814050, "post_id": 37109336, "comment_id": 61784195, "body": "Popen.communicate does not use threads on OSX or linux: instead it uses poll (see   def _communicate_with_poll(self, input) in <a href=\"https://svn.python.org/projects/stackless/trunk/Lib/subprocess.py\" rel=\"nofollow noreferrer\">svn.python.org/projects/stackless/trunk/Lib/subprocess.py</a> )"}, {"owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 0, "creation_date": 1462816084, "post_id": 37109336, "comment_id": 61785270, "body": "- &quot;<i>instead it uses poll</i>&quot; - So... Async IO is not yet integrated into the Rust standard library (<a href=\"https://github.com/rust-lang/rfcs/issues/1081\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/issues/1081</a>) so your best bet for something like <code>poll</code> is an external crate, like <code>mio</code>."}], "answers": [{"comments": [{"owner": {"reputation": 483, "user_id": 4280035, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e442215473aa322da127ee74c79c7477?s=128&d=identicon&r=PG&f=1", "display_name": "hellcatv", "link": "https://stackoverflow.com/users/4280035/hellcatv"}, "edited": false, "score": 0, "creation_date": 1462814144, "post_id": 37116642, "comment_id": 61784250, "body": "Interesting...this other stackoverflow question hints at possible use of mio to solve the problem, but no further explanation is given <a href=\"http://stackoverflow.com/questions/34611742/how-do-i-read-the-output-of-a-child-process-without-blocking-in-rust\" title=\"how do i read the output of a child process without blocking in rust\">stackoverflow.com/questions/34611742/&hellip;</a>"}, {"owner": {"reputation": 483, "user_id": 4280035, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e442215473aa322da127ee74c79c7477?s=128&d=identicon&r=PG&f=1", "display_name": "hellcatv", "link": "https://stackoverflow.com/users/4280035/hellcatv"}, "edited": false, "score": 0, "creation_date": 1462814584, "post_id": 37116642, "comment_id": 61784461, "body": "We can also assume this is another type of process like gunzip where the input and output ratios are unpredictable"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": -1, "last_activity_date": 1462799288, "creation_date": 1462799288, "answer_id": 37116642, "question_id": 37109336, "link": "https://stackoverflow.com/questions/37109336/equivalent-of-pythons-subprocess-communicate-in-rust/37116642#37116642", "title": "Equivalent of Python&#39;s subprocess.communicate in Rust?", "body": "<p>In <em>this</em> particular example, you know that the input and output amounts are equivalent, so you don't need threads at all. You can just write a bit and then read a bit:</p>\n\n<pre><code>use std::io::{self, Cursor, Read, Write};\n\nstatic DATA: [u8; 1024 * 4096] = [0x3f; 1024 * 4096];\nconst TRANSFER_LIMIT: u64 = 32 * 1024;\n\nfn main() {\n    let mut child = std::process::Command::new(\"cat\")\n        .stdout(std::process::Stdio::piped())\n        .stdin(std::process::Stdio::piped())\n        .spawn()\n        .expect(\"Could not start child\");\n\n    let mut input = Cursor::new(&amp;DATA[..]);\n    let mut output = Cursor::new(Vec::new());\n\n    match (child.stdin.as_mut(), child.stdout.as_mut()) {\n        (Some(stdin), Some(stdout)) =&gt; {\n            while input.position() &lt; input.get_ref().len() as u64 {\n                io::copy(&amp;mut input.by_ref().take(TRANSFER_LIMIT), stdin).expect(\"Could not copy input\");\n                io::copy(&amp;mut stdout.take(TRANSFER_LIMIT), &amp;mut output).expect(\"Could not copy output\");\n            }\n        },\n        _ =&gt; panic!(\"child process input and output were not opened\"),\n    }\n\n    child.wait().expect(\"Could not join child\");\n    let res = output.into_inner();\n\n    assert_eq!(res.len(), DATA.len());\n    assert_eq!(&amp;*res, &amp;DATA[..]);\n}\n</code></pre>\n\n<p>If you didn't have that specific restriction, you will need to use <code>select</code> from the libc crate, which requires file descriptors for the pipes so will probably restrict your code to running on Linux / OS X.</p>\n\n<p>You could also start threads, one for each pipe (and reuse the parent thread for one of the pipes), but you've already ruled that out.</p>\n"}, {"comments": [{"owner": {"reputation": 483, "user_id": 4280035, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e442215473aa322da127ee74c79c7477?s=128&d=identicon&r=PG&f=1", "display_name": "hellcatv", "link": "https://stackoverflow.com/users/4280035/hellcatv"}, "edited": false, "score": 0, "creation_date": 1464741433, "post_id": 37201466, "comment_id": 62603901, "body": "I just released a crate to solve this issue <a href=\"https://crates.io/crates/subprocess-communicate\" rel=\"nofollow noreferrer\">crates.io/crates/subprocess-communicate</a>"}], "tags": [], "owner": {"reputation": 483, "user_id": 4280035, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e442215473aa322da127ee74c79c7477?s=128&d=identicon&r=PG&f=1", "display_name": "hellcatv", "link": "https://stackoverflow.com/users/4280035/hellcatv"}, "is_accepted": true, "score": 0, "last_activity_date": 1464741424, "last_edit_date": 1464741424, "creation_date": 1463114873, "answer_id": 37201466, "question_id": 37109336, "link": "https://stackoverflow.com/questions/37109336/equivalent-of-pythons-subprocess-communicate-in-rust/37201466#37201466", "title": "Equivalent of Python&#39;s subprocess.communicate in Rust?", "body": "<p>Well it wasn't a small amount of code to get this done, and I needed a combination of mio and nix, because mio wouldn't set AsRawFd items to be nonblocking when they were pipes, so this had to be done first.</p>\n\n<p>Here's the result</p>\n\n<pre><code>extern crate mio;\nextern crate bytes;\n\nuse mio::*;\nuse std::io;\nuse mio::unix::{PipeReader, PipeWriter};\nuse std::process::{Command, Stdio};\nuse std::os::unix::io::AsRawFd;\nuse nix::fcntl::FcntlArg::F_SETFL;\nuse nix::fcntl::{fcntl, O_NONBLOCK};\nextern crate nix;\n\nstruct SubprocessClient {\n    stdin: PipeWriter,\n    stdout: PipeReader,\n    output : Vec&lt;u8&gt;,\n    input : Vec&lt;u8&gt;,\n    input_offset : usize,\n    buf : [u8; 65536],\n}\n\n\n// Sends a message and expects to receive the same exact message, one at a time\nimpl SubprocessClient {\n    fn new(stdin: PipeWriter, stdout : PipeReader, data : &amp;[u8]) -&gt; SubprocessClient {\n        SubprocessClient {\n            stdin: stdin,\n            stdout: stdout,\n            output : Vec::&lt;u8&gt;::new(),\n            buf : [0; 65536],\n            input : data.to_vec(),\n            input_offset : 0,\n        }\n    }\n\n    fn readable(&amp;mut self, _event_loop: &amp;mut EventLoop&lt;SubprocessClient&gt;) -&gt; io::Result&lt;()&gt; {\n        println!(\"client socket readable\");\n\n\n        match self.stdout.try_read(&amp;mut self.buf[..]) {\n            Ok(None) =&gt; {\n                println!(\"CLIENT : spurious read wakeup\");\n            }\n            Ok(Some(r)) =&gt; {\n                println!(\"CLIENT : We read {} bytes!\", r);\n                self.output.extend(&amp;self.buf[0..r]);\n            }\n            Err(e) =&gt; {\n                return Err(e);\n            }\n        };\n        return Ok(());\n    }\n\n    fn writable(&amp;mut self, event_loop: &amp;mut EventLoop&lt;SubprocessClient&gt;) -&gt; io::Result&lt;()&gt; {\n        println!(\"client socket writable\");\n\n        match self.stdin.try_write(&amp;(&amp;self.input)[self.input_offset..]) {\n            Ok(None) =&gt; {\n                println!(\"client flushing buf; WOULDBLOCK\");\n            }\n            Ok(Some(r)) =&gt; {\n                println!(\"CLIENT : we wrote {} bytes!\", r);\n                self.input_offset += r;\n            }\n            Err(e) =&gt; println!(\"not implemented; client err={:?}\", e)\n        }\n        if self.input_offset == self.input.len() {\n            event_loop.shutdown();\n        }\n        return Ok(());\n    }\n\n}\n\nimpl Handler for SubprocessClient {\n    type Timeout = usize;\n    type Message = ();\n\n    fn ready(&amp;mut self, event_loop: &amp;mut EventLoop&lt;SubprocessClient&gt;, token: Token,\n             events: EventSet) {\n        println!(\"ready {:?} {:?}\", token, events);\n        if events.is_readable() {\n            let _x = self.readable(event_loop);\n        }\n        if events.is_writable() {\n            let _y = self.writable(event_loop);\n        }\n    }\n}\n\n\n\npub fn from_nix_error(err: ::nix::Error) -&gt; io::Error {\n    io::Error::from_raw_os_error(err.errno() as i32)\n}\n\nfn set_nonblock(s: &amp;AsRawFd) -&gt; io::Result&lt;()&gt; {\n    fcntl(s.as_raw_fd(), F_SETFL(O_NONBLOCK)).map_err(from_nix_error)\n                                             .map(|_| ())\n}\n\n\nconst TEST_DATA : [u8; 1024 * 4096] = [40; 1024 * 4096];\npub fn echo_server() {\n    let mut event_loop = EventLoop::&lt;SubprocessClient&gt;::new().unwrap();\n    let process =\n           Command::new(\"cat\")\n           .stdin(Stdio::piped())\n           .stdout(Stdio::piped())\n           .spawn().unwrap();\n    let raw_stdin_fd;\n    match process.stdin {\n      None =&gt; unreachable!(),\n      Some(ref item) =&gt; {\n          let err = set_nonblock(item);\n          match err {\n             Ok(()) =&gt; {},\n             Err(e) =&gt; panic!(e),\n          }\n          raw_stdin_fd = item.as_raw_fd();\n      },\n    }\n    let raw_stdout_fd;\n    match process.stdout {\n      None =&gt; unreachable!(),\n      Some(ref item) =&gt; {\n          let err = set_nonblock(item);\n          match err {\n             Ok(()) =&gt; {},\n             Err(e) =&gt; panic!(e),\n          }\n          raw_stdout_fd = item.as_raw_fd();},\n    }\n    //println!(\"listen for connections {:?} {:?}\", , process.stdout.unwrap().as_raw_fd());\n    let mut subprocess = SubprocessClient::new(PipeWriter::from(Io::from_raw_fd(raw_stdin_fd)),\n                                               PipeReader::from(Io::from_raw_fd(raw_stdout_fd)),\n                                               &amp;TEST_DATA[..]);\n    let stdout_token : Token = Token(0);\n    let stdin_token : Token = Token(1);\n    event_loop.register(&amp;subprocess.stdout, stdout_token, EventSet::readable(),\n                        PollOpt::level()).unwrap();\n\n    // Connect to the server\n    event_loop.register(&amp;subprocess.stdin, stdin_token, EventSet::writable(),\n                        PollOpt::level()).unwrap();\n\n    // Start the event loop\n    event_loop.run(&amp;mut subprocess).unwrap();\n    let res = process.wait_with_output();\n    match res {\n       Err(e) =&gt; {panic!(e);},\n       Ok(output) =&gt; {\n          subprocess.output.extend(&amp;output.stdout);\n          println!(\"Final output was {:}\\n\", output.stdout.len());\n       },\n    }\n    println!(\"{:?}\\n\", subprocess.output.len());\n}\n\nfn main() {\n  echo_server();\n}\n</code></pre>\n\n<p>Basically the only way to close stdin was to call process.wait_with_output since the Stdin has no close primitive</p>\n\n<p>Once this happened, the remaining input could extend the output data vector.</p>\n\n<p>There's now a crate that does this</p>\n\n<p><a href=\"https://crates.io/crates/subprocess-communicate\" rel=\"nofollow\">https://crates.io/crates/subprocess-communicate</a></p>\n"}], "owner": {"reputation": 483, "user_id": 4280035, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e442215473aa322da127ee74c79c7477?s=128&d=identicon&r=PG&f=1", "display_name": "hellcatv", "link": "https://stackoverflow.com/users/4280035/hellcatv"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1197, "favorite_count": 1, "accepted_answer_id": 37201466, "answer_count": 2, "score": 3, "last_activity_date": 1464741424, "creation_date": 1462776418, "last_edit_date": 1462795293, "question_id": 37109336, "link": "https://stackoverflow.com/questions/37109336/equivalent-of-pythons-subprocess-communicate-in-rust", "title": "Equivalent of Python&#39;s subprocess.communicate in Rust?", "body": "<p>I'm trying to port this Python script that sends and receives input to a helper process to Rust:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>import subprocess\ndata = chr(0x3f) * 1024 * 4096\nchild = subprocess.Popen(['cat'], stdin=subprocess.PIPE,   stdout=subprocess.PIPE)\noutput, _ = child.communicate(data)\nassert output == data\n</code></pre>\n\n<p>My attempt worked fine until the input buffer exceeded 64k because presumably the OS's pipe buffer filled up before the input was written.</p>\n\n<pre><code>use std::io::Write;\n\nconst DATA: [u8; 1024 * 4096] = [0x3f; 1024 * 4096];\n\nfn main() {\n    let mut child = std::process::Command::new(\"cat\")\n                        .stdout(std::process::Stdio::piped())\n                        .stdin(std::process::Stdio::piped())\n                        .spawn()\n                        .unwrap();\n    match child.stdin {\n        Some(ref mut stdin) =&gt; {\n            match stdin.write_all(&amp;DATA[..]) {\n                Ok(_size) =&gt; {}\n                Err(err) =&gt; panic!(err),\n            }\n        }\n        None =&gt; unreachable!(),\n    }\n    let res = child.wait_with_output();\n    assert_eq!(res.unwrap().stdout.len(), DATA.len())\n}\n</code></pre>\n\n<p>Is there a <code>subprocess.communicate</code> equivalent in Rust? Maybe a <code>select</code> equivalent? Can mio be used to solve this problem? Also, there seems to be no way to close stdin.</p>\n\n<p>The goal here is to make a high performance system, so I want to avoid spawning a thread per task.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 115, "user_id": 1959884, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/xcmtm.jpg?s=128&g=1", "display_name": "Xiaohong Deng", "link": "https://stackoverflow.com/users/1959884/xiaohong-deng"}, "edited": false, "score": 0, "creation_date": 1462768999, "post_id": 37107288, "comment_id": 61757720, "body": "I saw many similar questions in Java. But in Rust a typical reference could be created by <code>&amp;mut</code> syntax. I want to make sure what kind of copy move keyword makes when it comes to a reference type."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1462772418, "post_id": 37107288, "comment_id": 61758784, "body": "&quot;The borrow checker can see that there would be multiple references to the heap allocated data...&quot;  No, it really can&#39;t.  The borrow checker doesn&#39;t understand heap references <i>at all</i>.  The compiler just doesn&#39;t allow non-<code>Copy</code> values to be moved more than once; having internal pointers to the heap has nothing to do with it."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1462774524, "post_id": 37107288, "comment_id": 61759601, "body": "@DK. Apologies - I left implementation of the Copy trait out of the answer, attempting not to confuse the situation more. I probably should have included that. My original revision was just trying to point out how pass by value works in general with heap allocated types. I will fix this up when not in transit."}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 0, "last_activity_date": 1462774738, "last_edit_date": 1462774738, "creation_date": 1462763758, "answer_id": 37107288, "question_id": 37107059, "link": "https://stackoverflow.com/questions/37107059/move-keyword-of-closures-when-concerning-a-vector/37107288#37107288", "title": "Move keyword of closures when concerning a vector", "body": "<p>\"By reference\" is a term thrown around a lot.. and its very rarely used correctly in any language. When a vector is moved, it is copied \"by value\". A vector is made up of a few things though (may not be 100% accurate but generally is for structures like this.. or a slice in Go):</p>\n\n<ul>\n<li>A pointer to the heap data.</li>\n<li>A length.</li>\n<li>A capacity.</li>\n</ul>\n\n<p>This doesn't change the heap allocated data.. there is just now another pointer pointing to it. Copying this data is pretty cheap - its just 3 integers.</p>\n\n<p>The TLDR is: your assumption is correct. Whatever is determined to be a \"reference\" is generally what gets copied in a \"pass-by-value\" environment. </p>\n\n<p>EDIT: I removed the useless comparison to C# references.. but the short version is: C# is \"pass-by-value\" and as such passing a reference type into a method is not \"passing by reference\" - the reference is copied.</p>\n"}, {"comments": [{"owner": {"reputation": 115, "user_id": 1959884, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/xcmtm.jpg?s=128&g=1", "display_name": "Xiaohong Deng", "link": "https://stackoverflow.com/users/1959884/xiaohong-deng"}, "edited": false, "score": 0, "creation_date": 1462774479, "post_id": 37107590, "comment_id": 61759580, "body": "My intention is to understand the behavior of move keyword. My understanding is it is equivalent to move semantics of general variable binding. And it&#39;s true it will compile if <code>for i in 0..3</code> block is removed. But change <code>0..3</code> to <code>0..1</code> won&#39;t. Why is that?"}, {"owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "reply_to_user": {"reputation": 115, "user_id": 1959884, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/xcmtm.jpg?s=128&g=1", "display_name": "Xiaohong Deng", "link": "https://stackoverflow.com/users/1959884/xiaohong-deng"}, "edited": false, "score": 0, "creation_date": 1462774893, "post_id": 37107590, "comment_id": 61759783, "body": "@XiaohongDeng, compiler probably can&#39;t figure out the loop will only run one time for <code>0..1</code> e.g. there won&#39;t be a second move of <code>data</code>."}], "tags": [], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "is_accepted": false, "score": 1, "last_activity_date": 1462770131, "last_edit_date": 1462770131, "creation_date": 1462766718, "answer_id": 37107590, "question_id": 37107059, "link": "https://stackoverflow.com/questions/37107059/move-keyword-of-closures-when-concerning-a-vector/37107590#37107590", "title": "Move keyword of closures when concerning a vector", "body": "<p>Implementation of <code>move</code> may be a <code>memcpy</code> or a no-op, depending on the compiler optimization. Here the compiler is checking in the language level rather than the implementation.</p>\n\n<p>Here the error happens because you are trying to move <code>data</code> three times.</p>\n\n<p>What you did with</p>\n\n<pre><code>thread::spawn(move || {\n    data[i] += 1;\n});\n</code></pre>\n\n<p>was to move <code>data</code> to a newly spawned thread, and increment the <code>i</code>th value. And you are doing this three times by spawning three threads.</p>\n\n<p>If you want to change the values in the original vector, you will need to use reference, and to make sure the reference is valid throughout the entire scope of those new threads. <code>std::thread::spawn</code> can not do that, you may want to look at <a href=\"http://aturon.github.io/crossbeam-doc/crossbeam/struct.Scope.html\" rel=\"nofollow\">crossbeam::Scope</a>.</p>\n\n<p>For implementation, deep copy is usually not necessary for <code>move</code>, and it is usually not used to avoid expensive heap allocation.</p>\n"}, {"tags": [], "owner": {"reputation": 356, "user_id": 5280790, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/eac429a5a60ea7f567cc51ad67a95034?s=128&d=identicon&r=PG&f=1", "display_name": "Iceberg", "link": "https://stackoverflow.com/users/5280790/iceberg"}, "is_accepted": true, "score": 3, "last_activity_date": 1462927048, "creation_date": 1462927048, "answer_id": 37151183, "question_id": 37107059, "link": "https://stackoverflow.com/questions/37107059/move-keyword-of-closures-when-concerning-a-vector/37151183#37151183", "title": "Move keyword of closures when concerning a vector", "body": "<blockquote>\n  <p>Does it mean that the copy only copies the metadata on the stack not\n  the real data on the heap? In other words, the reference is copied\n  because the data type itself is a reference type by nature, not\n  referring to the reference created by &amp;mut syntax. Is it true for all\n  data types that the move keyword copies data on the stack? So when it\n  comes to type like i32 it copies by value, and by reference if it is\n  type like vector.</p>\n</blockquote>\n\n<p>When ownership of a variable is transferred, a deep copy is not performed.  All of the pointers still point to the same values, and the heap memory is not touched.  Transfer of ownership is an inexpensive operation by design.  If you need a deep copy, you can explicitly call the <code>clone</code> method on a <code>Vec</code>.  Certain types where cloning is inexpensive (such as <code>i32</code>) implement the <code>Copy</code> trait, which means <code>clone</code> will automatically be called if you try to pass ownership of the same value to multiple destinations.</p>\n\n<blockquote>\n  <p>My original intention is to understand the exact behavior of the move\n  keyword. After a closer look at the Rust docs, I think it follows move\n  semantics of general variable bindings. In this case, the ownership of\n  \"data\" can only be transferred once. Though change 0..3 to 0..1\n  doesn't make a difference. Also it's true that the metadata on the\n  stack is copied, not the heap data.</p>\n</blockquote>\n\n<p>Using <code>0..1</code> doesn't work because the compiler doesn't check that the iterable range <code>0..1</code> contains only a single element.  So using <code>0..1</code> doesn't compile, but removing the <code>for</code> loop altogether is logically equivalent and does compile</p>\n\n<pre><code>use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let mut data = vec![1, 2, 3];\n\n    thread::spawn(move || {\n        data[0] += 1;\n    });\n\n    thread::sleep(Duration::from_millis(50));\n}\n</code></pre>\n\n<p>If we try to access <code>data</code> again after we passed it to <code>thread::spawn</code>, we will get a compile error like <code>error: use of moved value: 'data'</code>.  This is what the <code>move</code> keyword did.  Since <code>data</code> has been moved to the closure, that closure is now responsible for deallocating its memory.  It's also worth noting that this code would not compile without the <code>move</code> keyword, since in that case <code>data</code> would be deallocated at the end of the <code>main</code> function, but the thread might outlive the <code>main</code> function.</p>\n"}], "owner": {"reputation": 115, "user_id": 1959884, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/xcmtm.jpg?s=128&g=1", "display_name": "Xiaohong Deng", "link": "https://stackoverflow.com/users/1959884/xiaohong-deng"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1684, "favorite_count": 0, "accepted_answer_id": 37151183, "answer_count": 3, "score": 4, "last_activity_date": 1462927048, "creation_date": 1462761495, "last_edit_date": 1462795142, "question_id": 37107059, "link": "https://stackoverflow.com/questions/37107059/move-keyword-of-closures-when-concerning-a-vector", "title": "Move keyword of closures when concerning a vector", "body": "<p>I was told that when using the <code>move</code> keyword in a closure, the closure takes ownership of copies of variables in its environment. But this code will not compile:</p>\n\n<pre><code>use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let mut data = vec![1, 2, 3];\n\n    for i in 0..3 {\n        thread::spawn(move || {\n            data[i] += 1;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n</code></pre>\n\n<p>The error message is</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>8:17 error: capture of moved value: `data`\n    data[i] += 1;\n    ^~~~\n</code></pre>\n\n<p>Some explanation for this</p>\n\n<blockquote>\n  <p>Rust knows this wouldn't be safe! If we had a reference to data in each thread, and the thread takes ownership of the reference, we'd have three owners!</p>\n</blockquote>\n\n<p>Does it mean that the copy only copies the metadata on the stack not the real data on the heap? In other words, the reference is copied because the data type itself is a reference type by nature, not referring to the reference created by <code>&amp;mut</code> syntax. Is it true for all data types that the <code>move</code> keyword copies data on the stack? So when it comes to type like <code>i32</code> it copies by value, and by reference if it is type like vector.</p>\n\n<p>My original intention is to understand the exact behavior of the <code>move</code> keyword. After a closer look at the Rust docs, I think it follows move semantics of general variable bindings. In this case, the ownership of \"data\" can only be transferred once. Though change <code>0..3</code> to <code>0..1</code> doesn't make a difference. Also it's true that the metadata on the stack is copied, not the heap data.</p>\n"}, {"tags": ["ruby", "rubygems", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462732222, "post_id": 37102967, "comment_id": 61748698, "body": "You may want to make your <i>primary</i> distribution method be downloading pre-built binary libraries. Not many people will have the Rust compiler installed. Of course, having a fallback solution that builds from Rust source would be useful too."}], "answers": [{"tags": [], "owner": {"reputation": 2359, "user_id": 1837084, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/67dya.jpg?s=128&g=1", "display_name": "Oleg Antonyan", "link": "https://stackoverflow.com/users/1837084/oleg-antonyan"}, "is_accepted": false, "score": 2, "last_activity_date": 1463231584, "last_edit_date": 1463231584, "creation_date": 1462731355, "answer_id": 37103225, "question_id": 37102967, "link": "https://stackoverflow.com/questions/37102967/how-can-i-build-a-rust-library-when-installing-a-gem/37103225#37103225", "title": "How can I build a Rust library when installing a gem?", "body": "<p>Turns out I can do this:</p>\n\n<pre><code># rust/extconf.rb\nrequire 'mkmf'\ncreate_makefile 'rust/rustgem'\nsystem(\"cd #{File.dirname(__FILE__)} &amp;&amp; cargo build --release\")\n</code></pre>\n\n<p>In this case, <code>create_makefile</code> will create an empty Makefile. Then make will return 0 <code>make: Nothing to be done for 'all'.</code> which is what we need, and then <code>system</code> call will do the work. </p>\n\n<p>Or somewhat better:</p>\n\n<pre><code>require 'mkmf'\ncreate_makefile 'rutgem'\nFile.write('Makefile', \"all:\\n\\tcargo build --release\\nclean:\\n\\trm -rf target\\ninstall: ;\")\n</code></pre>\n\n<p>I'm not sure if this is good solution. If you know a better one please tell it.</p>\n\n<p><strong>UPDATE</strong>\nActually, you can put <code>Makefile</code> along with empty <code>extconf.rb</code> in the same directory and it will work. Blog post about Ruby-Rust integration: <a href=\"http://undefined-reference.org/2016/05/14/writing-rubygem-in-rust.html\" rel=\"nofollow\">http://undefined-reference.org/2016/05/14/writing-rubygem-in-rust.html</a></p>\n"}], "owner": {"reputation": 2359, "user_id": 1837084, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/67dya.jpg?s=128&g=1", "display_name": "Oleg Antonyan", "link": "https://stackoverflow.com/users/1837084/oleg-antonyan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 238, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1463231584, "creation_date": 1462729850, "last_edit_date": 1462732113, "question_id": 37102967, "link": "https://stackoverflow.com/questions/37102967/how-can-i-build-a-rust-library-when-installing-a-gem", "title": "How can I build a Rust library when installing a gem?", "body": "<p>I'm building a gem with Rust and I need to know how to run the Rust compiler when installing the gem. With a C-extension, I can use <code>mkmf</code> to generate a Makefile. But how can I run <code>cargo build --release</code>?</p>\n\n<p>The directory structure looks like this:</p>\n\n<pre><code>.\n\u251c\u2500\u2500 bin\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 console\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 setup\n\u251c\u2500\u2500 CODE_OF_CONDUCT.md\n\u251c\u2500\u2500 Gemfile\n\u251c\u2500\u2500 Gemfile.lock\n\u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 rmpd_adschedule\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 version.rb\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rustgem.rb\n\u251c\u2500\u2500 LICENSE.txt\n\u251c\u2500\u2500 Rakefile\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 rustgem.gemspec\n\u251c\u2500\u2500 rust\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.lock\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 lib.rs\n\u2514\u2500\u2500 spec\n    \u251c\u2500\u2500 rustgem.rb\n    \u2514\u2500\u2500 spec_helper.rb\n</code></pre>\n\n<p>I've created a Rake task to build the Rust library:</p>\n\n<pre><code>task :compile do\n  sh \"cd #{File.dirname(__FILE__)}/rust &amp;&amp; cargo build --release\"\nend\n</code></pre>\n\n<p>But how to run this Rake task when installing the gem? Or how to generate a suitable Makefile with <code>mkmf</code>? The Makefile should look like this:</p>\n\n<pre><code>all:\n    cd rust/ &amp;&amp; cargo build --release\n</code></pre>\n\n<p>But it doesn't work if I put it into the root directory, and I don't know how to tell <code>mkmf</code> to generate this exact Makefile.</p>\n\n<p>I found one stupid way to do this when the gem is loading:</p>\n\n<pre><code>module Rustgem\n  system(\"cd #{File.dirname(__FILE__)}/../rust &amp;&amp; cargo build --release\")\nend\n</code></pre>\n\n<p>But this is not a good solution.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462711589, "post_id": 37097489, "comment_id": 61742321, "body": "You may be interested in reading through the source of <a href=\"https://github.com/PistonDevelopers/hematite\" rel=\"nofollow noreferrer\">Hematite</a>, a Minecraft clone written in Rust using Piston."}], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 2, "last_activity_date": 1462726777, "last_edit_date": 1462726777, "creation_date": 1462700123, "answer_id": 37098355, "question_id": 37097489, "link": "https://stackoverflow.com/questions/37097489/changing-key-of-hashmap-from-child-method/37098355#37098355", "title": "Changing key of HashMap from child method", "body": "<p>You can't modify the key of a <code>HashMap</code> directly. From <a href=\"http://doc.rust-lang.org/std/collections/struct.HashMap.html\" rel=\"nofollow\">the <code>HashMap</code> documentation</a>:</p>\n\n<blockquote>\n  <p>It is a logic error for a key to be modified in such a way that the key's hash, as determined by the <code>Hash</code> trait, or its equality, as determined by the <code>Eq</code> trait, changes while it is in the map.</p>\n</blockquote>\n\n<p>There you have to remove and reinsert the <code>Tile</code>, which you already try to do. You can't, however, remove and reinsert while you still borrow the object. In the <code>update</code> method the <code>Tile</code> object is borrowed via <code>&amp;self</code>. So you have to do it outside of this method. </p>\n\n<p>Sadly, you also can't remove and reinsert while iterating through the <code>HashMap</code> since it would invalidate the iterator. One possibility would be to collect all modified objects in a <code>Vec</code> while iterating through the map and insert those into the map afterwards.</p>\n\n<hr>\n\n<p>However, consider using a different data structure. It's difficult to reason about that without knowing how many tiles you will have, how often they change position and so on. You could separate your world into chunks, like e.g. Minecraft does, with each chunk spanning some quadratic area of size N x N. Each chunk could save it's Tiles in a <code>Vec</code> of size <code>N^2</code> then. But again: impossible to say what data structure would suit you best with the information given. Also: such question wouldn't fit SO.</p>\n\n<p>Some additional remarks:</p>\n\n<ul>\n<li>You could use a tuple <code>(i32, i32)</code> instead of <code>[i32; 2]</code> which would let you destructure it like so: <code>for ((x, y), tile) in &amp;app.world.tiles</code>. </li>\n<li><s>You don't need to put every <code>Tile</code> into a <code>Box</code>: the <code>HashMap</code> already owns the objects; boxing them would only introduce one additional layer of indirection.</s> Consider using a different design that allows you to store many objects \"inline\". The <code>Box</code> introduces another layer of indirection -- something moderns CPUs don't like at all. A great read about this topic is <a href=\"http://gameprogrammingpatterns.com/data-locality.html\" rel=\"nofollow\">this section of the game-programming-patterns book</a>.</li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": false, "score": 2, "last_activity_date": 1462707578, "creation_date": 1462707578, "answer_id": 37099400, "question_id": 37097489, "link": "https://stackoverflow.com/questions/37097489/changing-key-of-hashmap-from-child-method/37099400#37099400", "title": "Changing key of HashMap from child method", "body": "<p>Consider how</p>\n\n<pre><code>let new_pos = [self.x + 1, self.y];\nif world.tiles.get(&amp;new_pos).is_none() {\n    world.tiles.remove(&amp;[self.x, self.y]);\n    world.tiles.insert(new_pos, Box::new(*self));\n    self.x = new_pos[0];\n    self.y = new_pos[1];\n}\n</code></pre>\n\n<p>Moves tiles right when they are able, but at the <em>same time</em> you're iterating over your <code>HashMap</code>. This means you might do this:</p>\n\n<ul>\n<li>Get value at position <code>[0, 0]</code>, reinsert at <code>[1, 0]</code>.</li>\n<li>Get value at position <code>[1, 0]</code>, reinsert at <code>[2, 0]</code>.</li>\n<li>Get value at position <code>[2, 0]</code>, reinsert at <code>[3, 0]</code>.</li>\n<li>...etc.</li>\n</ul>\n\n<p>...or you might not. This is shared mutation, and this is why Rust says no.</p>\n\n<p>The typical way to do this is to collect values into a new allocation. <a href=\"https://play.rust-lang.org/?gist=c8479ea0bd67e4268a3b23971b7ef0fe&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">Here's an example.</a></p>\n\n<pre><code>use std::boxed::Box;\nuse std::collections::HashMap;\nuse std::fmt;\n\npub type TileMap = HashMap&lt;(i32, i32), Box&lt;Tile&gt;&gt;;\n\npub trait Tile: fmt::Debug {\n    fn new(x: i32, y: i32) -&gt; Self where Self: Sized;\n    fn update_into(&amp;self, app: &amp;App, new_tiles: &amp;mut TileMap);\n}\n\n#[derive(Copy, Clone, Debug)]\npub struct DirtTile {\n    pub x: i32,\n    pub y: i32\n}\n\nimpl Tile for DirtTile {\n    fn new(x: i32, y: i32) -&gt; DirtTile {\n        return DirtTile { x: x, y: y };\n    }\n\n    fn update_into(&amp;self, app: &amp;App, new_tiles: &amp;mut TileMap) {\n        let world = &amp;app.world;\n\n        let new_pos = (self.x + 1, self.y);\n        if world.tiles.get(&amp;new_pos).is_none() {\n            new_tiles.insert(new_pos, Box::new(DirtTile::new(self.x + 1, self.y)));\n        }\n        else {\n            new_tiles.insert((self.x, self.y), Box::new(*self));\n        }\n    }\n}\n\npub struct World {\n    tiles: TileMap,\n}\n\npub struct App {\n    world: World,\n}\n\nfn main() {\n    let mut app = App { world: World { tiles: HashMap::new() } };\n\n    app.world.tiles.insert((0, 0), Box::new(DirtTile::new(0, 0)));\n\n    let mut new_tiles = HashMap::new();\n    for (_, tile) in &amp;app.world.tiles {\n        tile.update_into(&amp;app, &amp;mut new_tiles);\n    }\n    app.world.tiles = new_tiles;\n\n    println!(\"{:?}\", app.world.tiles);\n}\n</code></pre>\n\n<p>That said, your use of dynamic dispatch is probably not optimal. Consider an enum instead if possible, <a href=\"https://play.rust-lang.org/?gist=84924ec535f41c69c18d01f036f4b48c&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">maybe like this</a>.</p>\n"}], "owner": {"reputation": 141, "user_id": 4016460, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=128", "display_name": "Oscar Rainford", "link": "https://stackoverflow.com/users/4016460/oscar-rainford"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 853, "favorite_count": 1, "answer_count": 2, "score": 1, "last_activity_date": 1462726777, "creation_date": 1462693689, "last_edit_date": 1462711432, "question_id": 37097489, "link": "https://stackoverflow.com/questions/37097489/changing-key-of-hashmap-from-child-method", "title": "Changing key of HashMap from child method", "body": "<p>I'm working on a 2D sandbox game that implements tiles in piston. The basic structure of this is an <code>App</code> struct, which stores a <code>world: World</code> struct, which has a <code>tiles: HashMap</code> property of <code>Box&lt;Tile&gt;</code>s, with the key being an X-Y position of where the tile is.</p>\n\n<p>To render this, I loop through the coordinates of every tile space on the screen and if there is a tile in the hashmap with those co-ordinates, I call <code>tile.render(&amp;context, &amp;mut gl);</code>.</p>\n\n<p>I now need to implement a <code>Tile.update()</code> method which will be called each update, however this method would need to have the ability to modify the co-ordinates of the block which means modifying the key of the tile itself in the hashmap, but I can't pass the hashmap to the <code>tile.update()</code> function since accessing the tile would borrow the hashmap.</p>\n\n<p>How do I accomplish this in the least hacky/most elegant way possible? Is there a better method I should be using to store the tiles that will allow this to work? Changing the co-ordinates from outside the <code>Tile.update()</code> method is not possible.</p>\n\n<p>This is pretty much what I'm trying to do. I know why it won't work, I'm just not sure how to get around it:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::boxed::Box;\n\npub trait Tile {\n    fn new(x: i32, y: i32) -&gt; Self where Self: Sized;\n    fn render(&amp;self, camera_x: i32, camera_y: i32);\n    fn update(&amp;mut self, app: &amp;mut App);\n}\n\npub struct DirtTile {\n    pub x: i32,\n    pub y: i32,\n}\n\nimpl Tile for DirtTile {\n    fn new(x: i32, y: i32) -&gt; DirtTile {\n        return DirtTile { x: x, y: y };\n    }\n\n    fn render(&amp;self, camera_x: i32, camera_y: i32) {\n        // render\n    }\n\n    fn update(&amp;mut self, app: &amp;mut App) {\n        let world = app.world;\n\n        // update pos\n        let new_pos = [self.x + 1, self.y];\n        if world.tiles.get(&amp;new_pos).is_none() {\n            world.tiles.remove(&amp;[self.x, self.y]);\n            world.tiles.insert(new_pos, Box::new(*self));\n            self.x = new_pos[0];\n            self.y = new_pos[1];\n        }\n    }\n}\n\npub struct World {\n    tiles: HashMap&lt;[i32; 2], Box&lt;Tile&gt;&gt;,\n}\n\npub struct App {\n    world: World,\n}\n\nfn main() {\n    let mut app = App { world: World { tiles: HashMap::new() } };\n\n    app.world.tiles.insert([0, 0], Box::new(DirtTile::new(0, 0)));\n\n    for (xy, tile) in &amp;app.world.tiles {\n        tile.update(&amp;mut app);\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=30ac409603b9b42117565fe756e7b5e2&amp;version=stable&amp;backtrace=0\" rel=\"nofollow\">Playground</a></p>\n"}, {"tags": ["vector", "iterator", "rust"], "comments": [{"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1462693689, "post_id": 37097395, "comment_id": 61737969, "body": "Do you want to use <code>unsafe</code>?"}, {"owner": {"reputation": 8789, "user_id": 539465, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/2acba600ecfbe1cc2e7f3c94b686ac84?s=128&d=identicon&r=PG", "display_name": "Valentin Lorentz", "link": "https://stackoverflow.com/users/539465/valentin-lorentz"}, "reply_to_user": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 1, "creation_date": 1462694066, "post_id": 37097395, "comment_id": 61738052, "body": "I would prefer not to."}, {"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1462696244, "post_id": 37097395, "comment_id": 61738547, "body": "Is it suitable if you use other structures like <a href=\"http://numeric.rs/doc/numeric/tensor/struct.Tensor.html\" rel=\"nofollow noreferrer\">numeric::Tensor</a>, which supports reshaping?"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 1, "creation_date": 1462696620, "post_id": 37097395, "comment_id": 61738640, "body": "They&#39;re <code>u64</code>s; there&#39;s no practical difference between cloning and moving them."}, {"owner": {"reputation": 8789, "user_id": 539465, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/2acba600ecfbe1cc2e7f3c94b686ac84?s=128&d=identicon&r=PG", "display_name": "Valentin Lorentz", "link": "https://stackoverflow.com/users/539465/valentin-lorentz"}, "reply_to_user": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1462698215, "post_id": 37097395, "comment_id": 61739027, "body": "@kennytm That would require copying the data too, so no."}, {"owner": {"reputation": 8789, "user_id": 539465, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/2acba600ecfbe1cc2e7f3c94b686ac84?s=128&d=identicon&r=PG", "display_name": "Valentin Lorentz", "link": "https://stackoverflow.com/users/539465/valentin-lorentz"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1462698221, "post_id": 37097395, "comment_id": 61739030, "body": "@DK. It&#39;s just to have a simple example. In practice I have structs."}, {"owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1462700355, "post_id": 37097395, "comment_id": 61739516, "body": "@DK. It&#39;s possible to transmute the <code>Vec&lt;u64&gt;</code> into <code>Vec&lt;(u64, u64)&gt;</code> in O(1) time, there is a practical difference."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "reply_to_user": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1462708194, "post_id": 37097395, "comment_id": 61741407, "body": "@kennytm That seems like a sure-fire way to break the <code>Vec</code>."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 3, "creation_date": 1462708672, "post_id": 37097395, "comment_id": 61741544, "body": "@ValentinLorentz If you only need pairs it should be trivial. Just <code>fn next(&amp;mut self) -&gt; Option&lt;(T, T)&gt; { match (self.next(), self.next()) { (Some(x), Some(x)) =&gt; Some((x, x)), _ =&gt; None } }</code> on the <code>Vec</code>&#39;s iterator."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "edited": false, "score": 0, "creation_date": 1462711203, "post_id": 37097395, "comment_id": 61742220, "body": "@kennytm I don&#39;t think that OP is asking about preserving the allocation <i>of the <code>Vec</code></i>, but the allocation of the items contained <i>within the <code>Vec</code></i>."}], "answers": [{"comments": [{"owner": {"reputation": 1106, "user_id": 161659, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/jKJ7J.jpg?s=128&g=1", "display_name": "Sebastian Ullrich", "link": "https://stackoverflow.com/users/161659/sebastian-ullrich"}, "edited": false, "score": 1, "creation_date": 1462979578, "post_id": 37099876, "comment_id": 61868686, "body": "You could replace <code>peek</code> with a <code>(None, None)</code> case"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1462980226, "last_edit_date": 1495540357, "creation_date": 1462710805, "answer_id": 37099876, "question_id": 37097395, "link": "https://stackoverflow.com/questions/37097395/alternative-to-vecchunks-that-consumes-the-vector/37099876#37099876", "title": "Alternative to Vec::chunks() that consumes the vector", "body": "<blockquote>\n  <p>I want consume the vector <code>flat</code> so I don't have to clone its elements when constructing the pair. </p>\n</blockquote>\n\n<p>Convert the input <code>Vec</code> into an iterator, then take two things from the iterator at a time. Essentially, you want the same thing as <a href=\"https://stackoverflow.com/a/37033906/155423\">processing a <code>Range</code> (an iterator) in chunks</a>:</p>\n\n<pre><code>fn to_pairs&lt;T&gt;(flat: Vec&lt;T&gt;) -&gt; Vec&lt;(T, T)&gt; {\n    let len = flat.len();\n\n    assert!(len % 2 == 0);\n    let mut pairs = Vec::with_capacity(len / 2);\n\n    let mut input = flat.into_iter().peekable();\n\n    while input.peek().is_some() {\n        match (input.next(), input.next()) {\n            (Some(a), Some(b)) =&gt; pairs.push((a, b)),\n            _ =&gt; unreachable!(\"Cannot have an odd number of values\"),\n        }\n    }\n\n    pairs\n}\n\nfn main() {\n    assert_eq!(vec![(1,2), (3,4)], to_pairs(vec![1,2,3,4]));\n    assert_eq!(vec![(true,true), (false,false)], to_pairs(vec![true,true,false,false]));\n}\n</code></pre>\n\n<p>The <code>assert!(len % 2 == 0);</code> is quite important here, as <code>Iterator</code> makes no guarantees about what happens <strong>after</strong> the first time <code>next</code> returns <code>None</code>. Since we call <code>next</code> twice without checking the first value, we could be triggering that case. In other cases, you'd want to use <a href=\"http://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fuse\" rel=\"nofollow noreferrer\"><code>fuse</code></a>.</p>\n\n<p>As <a href=\"https://stackoverflow.com/questions/37097395/alternative-to-vecchunks-that-consumes-the-vector/37099876?noredirect=1#comment61868686_37099876\">pointed out by Kha</a>, you could simplify the <code>while</code> loop a bit:</p>\n\n<pre><code>let mut input = flat.into_iter();\n\nwhile let (Some(a), Some(b)) = (input.next(), input.next()) {\n    pairs.push((a, b));\n}\n</code></pre>\n"}], "owner": {"reputation": 8789, "user_id": 539465, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/2acba600ecfbe1cc2e7f3c94b686ac84?s=128&d=identicon&r=PG", "display_name": "Valentin Lorentz", "link": "https://stackoverflow.com/users/539465/valentin-lorentz"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 102, "favorite_count": 0, "answer_count": 1, "score": 2, "last_activity_date": 1462980226, "creation_date": 1462692842, "question_id": 37097395, "link": "https://stackoverflow.com/questions/37097395/alternative-to-vecchunks-that-consumes-the-vector", "title": "Alternative to Vec::chunks() that consumes the vector", "body": "<p>I have the following function, which takes a vector as argument and returns a vector of its pairs of elements:</p>\n\n<pre><code>fn to_pairs(flat: Vec&lt;u64&gt;) -&gt; Vec&lt;(u64, u64)&gt; {\n    assert!(flat.len() % 2 == 0);\n    let mut pairs = Vec::new();\n    pairs.reserve(flat.len() / 2);\n    for pair in flat.chunks(2) {\n        assert!(pair.len() == 2);\n        pairs.push((pair.get(0).unwrap().clone(), pair.get(1).unwrap().clone()));\n    }\n    pairs\n}\n</code></pre>\n\n<p>I want consume the vector <code>flat</code> so I don't have to clone its elements when constructing the pair.\nIs it possible to do so without reimplementing a variation of <code>Vec::chunks()</code> myself?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "edited": false, "score": 0, "creation_date": 1462571257, "post_id": 37081817, "comment_id": 61708480, "body": "Thanks for the answer! However, with your <code>bars2</code> example that takes <code>mut self</code>, the whole struct is moved and then discarded within the function. What I would like is something like <code>bars2</code>, but with only a partial move for the field accessed--"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "edited": false, "score": 0, "creation_date": 1462573872, "post_id": 37081817, "comment_id": 61709369, "body": "@kardeiz added examples for more than one field"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 4, "last_activity_date": 1462573861, "last_edit_date": 1462573861, "creation_date": 1462570823, "answer_id": 37081817, "question_id": 37080837, "link": "https://stackoverflow.com/questions/37080837/maybe-move-field-inside-struct-method/37081817#37081817", "title": "Maybe move field inside struct method", "body": "<blockquote>\n  <p>Is there some special reference type I can return from my bars function that will let me move it</p>\n</blockquote>\n\n<p>These two concepts are incompatible. A reference points to a location in memory. When you move a value, you change its location in memory, invalidating any references. Accessing old references leads to memory unsafety, so Rust prevents it.</p>\n\n<p>I'd just create another method that destructures the type:</p>\n\n<pre><code>fn bars2(mut self) -&gt; Vec&lt;Bar&gt; {\n    self.bars();\n    self.bars.expect(\"Impossible, we just ensured it was there\")\n}\n</code></pre>\n\n<p>Then you can use this method when you wish to take ownership:</p>\n\n<pre><code>fn main() {\n    let mut foo = Foo { bars: None };\n    for x in foo.bars() {\n        // by ref\n    }\n    for x in foo.bars2() {\n        // by value\n    }\n}\n</code></pre>\n\n<p>In <em>this</em> case, this works just the same, as there's only the one field in the struct. Once the value is moved into <code>bars2</code> and the vector is moved out of <code>self</code>, there's nothing left in the original struct to get!</p>\n\n<p>If you did have multiple values, you could extend the method to return a tuple with each value:</p>\n\n<pre><code>fn bars2(mut self) -&gt; (Vec&lt;Bar&gt;, String) {\n    self.bars();\n    let b = self.bars.expect(\"Impossible, we just ensured it was there\");\n    (b, self.owned_name)\n}\n</code></pre>\n\n<p>Or if there's lots of other values that you don't care about, you could simply <a href=\"http://doc.rust-lang.org/std/option/enum.Option.html#method.take\" rel=\"nofollow\"><code>take</code></a> the one value:</p>\n\n<pre><code>fn bars2(&amp;mut self) -&gt; Vec&lt;Bar&gt; {\n    self.bars();\n    self.bars.take().expect(\"Impossible, we just ensured it was there\")\n}\n</code></pre>\n\n<p>Note that this only requires <code>&amp;mut self</code> and leaves <code>self.bars</code> as a <code>None</code>. In other cases that don't have an <code>Option</code>, <code>mem::swap</code> or <code>mem::replace</code> can potentially be used.</p>\n\n<p>Additionally:</p>\n\n<ol>\n<li>Lifetime elision means you don't need any explicit lifetimes on <code>fn bars</code>.</li>\n<li>It's probably better to return a <code>&amp;[T]</code> instead of a <code>&amp;Vec&lt;T&gt;</code>, as it hides the internal implementation better.</li>\n<li>Don't name your struct fields with a leading underscore. A leading underscore indicates to Rust programmers that the value is deliberately unused, but these are very clearly used. Rust isn't C++ where member variables and methods are in the same namespace. </li>\n</ol>\n"}], "owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 426, "favorite_count": 1, "answer_count": 1, "score": 2, "last_activity_date": 1462573861, "creation_date": 1462566167, "last_edit_date": 1462569936, "question_id": 37080837, "link": "https://stackoverflow.com/questions/37080837/maybe-move-field-inside-struct-method", "title": "Maybe move field inside struct method", "body": "<p>I have the following objects:</p>\n\n<pre><code>#[derive(Debug)]\nstruct Bar(pub i32);\n\n#[derive(Debug)]\nstruct Foo {\n    pub bars: Vec&lt;Bar&gt;\n}\n</code></pre>\n\n<p>Assuming I am in a context where I own the <code>Foo</code>, I can move the field:</p>\n\n<pre><code>for x in foo.bars { /* ... */ } \n</code></pre>\n\n<p>or I can just use it by reference</p>\n\n<pre><code>for x in &amp;foo.bars { /* ... */ } \n</code></pre>\n\n<p>However, I want to load my <code>Vec&lt;Bar&gt;</code> dynamically (e.g., from a database), I might have something like this:</p>\n\n<pre><code>#[derive(Debug)]\nstruct Bar(pub i32);\n\n#[derive(Debug)]\nstruct Foo {\n    pub __bars: Option&lt;Vec&lt;Bar&gt;&gt;\n}\n\nimpl Foo {    \n    pub fn bars&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a Vec&lt;Bar&gt; {\n        if self.__bars.is_none() {\n            // load data here\n            self.__bars = Some(Vec::new());\n        }        \n        self.__bars.as_ref().unwrap()        \n    }    \n}\n</code></pre>\n\n<p>But now I can't move that field (even when I own the struct). Both</p>\n\n<pre><code>for x in *foo.bars() { }\n</code></pre>\n\n<p>and </p>\n\n<pre><code>for x in foo.bars() { let y = *x; }\n</code></pre>\n\n<p>give me a <code>cannot move out of borrowed content</code> error.</p>\n\n<p>I could do something like:</p>\n\n<pre><code>impl Foo\n    pub fn load_bars(&amp;mut self) {\n        if self.__bars.is_none() {\n            // load data here\n            self.__bars = Some(Vec::new());\n        }\n    }\n}\n\nlet foo = Foo { /* ... */ };\nfoo.load_bars();\nfor x in foo.__bars.unwrap() { }\n</code></pre>\n\n<p>But that is way less \"pleasant\". Is there some special reference type I can return from my <code>bars</code> function that will let me move it later when I need to (and can)?</p>\n"}, {"tags": ["file", "io", "rust"], "comments": [{"owner": {"reputation": 273, "user_id": 3495523, "user_type": "registered", "accept_rate": 18, "profile_image": "https://i.stack.imgur.com/pBmm2.jpg?s=128&g=1", "display_name": "Townsheriff", "link": "https://stackoverflow.com/users/3495523/townsheriff"}, "edited": false, "score": 0, "creation_date": 1604943615, "post_id": 37079342, "comment_id": 114495714, "body": "Why do you have closure for fill_buf? I had issue that this closure fixes. Could you please point me to the right direction."}, {"owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "reply_to_user": {"reputation": 273, "user_id": 3495523, "user_type": "registered", "accept_rate": 18, "profile_image": "https://i.stack.imgur.com/pBmm2.jpg?s=128&g=1", "display_name": "Townsheriff", "link": "https://stackoverflow.com/users/3495523/townsheriff"}, "edited": false, "score": 1, "creation_date": 1605034156, "post_id": 37079342, "comment_id": 114527765, "body": "@Townsheriff, do you mean, why is <code>reader.fill_buf()?</code> in a block (<code>let length = { ... }</code>)? If so, it is because the borrow checker back in 2016 was not as sophisticated as it is now. If I were to put the <code>fill_buf</code> and <code>consume</code> in the same scope, rustc would complain <code>cannot borrow `reader` as mutable more than once at a time</code>. <code>fill_buf</code> returns a reference to the underlying reader, so putting it in a shorter lived scope could be what is solving your issue."}, {"owner": {"reputation": 273, "user_id": 3495523, "user_type": "registered", "accept_rate": 18, "profile_image": "https://i.stack.imgur.com/pBmm2.jpg?s=128&g=1", "display_name": "Townsheriff", "link": "https://stackoverflow.com/users/3495523/townsheriff"}, "edited": false, "score": 0, "creation_date": 1605086928, "post_id": 37079342, "comment_id": 114542133, "body": "Yeah, that is exactly what I encountered in todays stable rust version. Big thanks and cheers!"}], "answers": [{"comments": [{"owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "edited": false, "score": 0, "creation_date": 1462567627, "post_id": 37080739, "comment_id": 61707056, "body": "Thanks for the answer! I thought <code>BufReader</code> was being useful for me since it resized the buffer for me when I got to the end of the reader, but I just realized that&#39;s pretty trivial..."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1462571299, "post_id": 37080739, "comment_id": 61708497, "body": "<i>since it resized the buffer</i> \u2014 I doubt that it resizes the buffer, but the slice is presumably shortened to reflect the number of bytes read. But you are right that the return value of <code>Read::read</code> tells you how much of the buffer is valid. It&#39;s <b>very important</b> to use that, otherwise you can get into a problem like Heartbleed where a buffer is reused with old content! That might be a good reason to use <code>BufReader</code>."}, {"owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "edited": false, "score": 0, "creation_date": 1462896881, "post_id": 37080739, "comment_id": 61825967, "body": "Sorry, you&#39;re right, I meant &quot;shortened the length of the buffer&quot;."}], "tags": [], "owner": {"reputation": 1987, "user_id": 5278682, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/34509cba2b4d128dce294dcf5092d300?s=128&d=identicon&r=PG&f=1", "display_name": "Eli Friedman", "link": "https://stackoverflow.com/users/5278682/eli-friedman"}, "is_accepted": true, "score": 11, "last_activity_date": 1554641687, "last_edit_date": 1554641687, "creation_date": 1462565781, "answer_id": 37080739, "question_id": 37079342, "link": "https://stackoverflow.com/questions/37079342/what-is-the-most-efficient-way-to-read-a-large-file-in-chunks-without-loading-th/37080739#37080739", "title": "What is the most efficient way to read a large file in chunks without loading the entire file in memory at once?", "body": "<p>I don't think you can write code more efficient than that.  <code>fill_buf</code> on a <code>BufReader</code> over a <code>File</code> is <a href=\"https://github.com/rust-lang/rust/blob/1.33.0/src/libstd/io/buffered.rs#L246-L257\" rel=\"nofollow noreferrer\">basically just a straight call to <code>read(2)</code></a>.</p>\n\n<p>That said, <code>BufReader</code> isn't really a useful abstraction when you use it like that; it would probably be less awkward to just call <code>file.read(&amp;mut buf)</code> directly.</p>\n"}], "owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4720, "favorite_count": 4, "accepted_answer_id": 37080739, "answer_count": 1, "score": 20, "last_activity_date": 1554662313, "creation_date": 1462560164, "last_edit_date": 1554662313, "question_id": 37079342, "link": "https://stackoverflow.com/questions/37079342/what-is-the-most-efficient-way-to-read-a-large-file-in-chunks-without-loading-th", "title": "What is the most efficient way to read a large file in chunks without loading the entire file in memory at once?", "body": "<p>What is the most efficient general purpose way of reading \"large\" files (which may be text or binary), without going into <code>unsafe</code> territory? I was surprised how few relevant results there were when I did a web search for \"rust read large file in chunks\".</p>\n\n<p>For example, one of my use cases is to calculate an MD5 checksum for a file using <code>rust-crypto</code> (the <code>Md5</code> module allows you to add <code>&amp;[u8]</code> chunks iteratively).</p>\n\n<p>Here is what I have, which seems to perform slightly better than some other methods like <code>read_to_end</code>:</p>\n\n<pre><code>use std::{\n    fs::File,\n    io::{self, BufRead, BufReader},\n};\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    const CAP: usize = 1024 * 128;\n    let file = File::open(\"my.file\")?;\n    let mut reader = BufReader::with_capacity(CAP, file);\n\n    loop {\n        let length = {\n            let buffer = reader.fill_buf()?;\n            // do stuff with buffer here\n            buffer.len()\n        };\n        if length == 0 {\n            break;\n        }\n        reader.consume(length);\n    }\n\n    Ok(())\n}\n</code></pre>\n"}, {"tags": ["iterator", "streaming", "rust", "lifetime", "borrow-checker"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1462548651, "post_id": 37075674, "comment_id": 61696946, "body": "Amusingly, you are trying to create what is called a <i>streaming iterator</i>, one that returns references to <b>itself</b> as part of the contract. There are projects <a href=\"https://github.com/emk/rust-streaming\" rel=\"nofollow noreferrer\">1</a> <a href=\"http://burntsushi.net/rustdoc/fst/trait.Streamer.html\" rel=\"nofollow noreferrer\">2</a>, Reddit threads <a href=\"https://www.reddit.com/r/rust/comments/303a09/looking_for_more_information_on_streaming/\" rel=\"nofollow noreferrer\">1</a>, <a href=\"https://www.reddit.com/r/rust/comments/2t1rxx\" rel=\"nofollow noreferrer\">2</a>, <a href=\"https://users.rust-lang.org/t/x/1096\" rel=\"nofollow noreferrer\">forum posts</a> and even <a href=\"http://stackoverflow.com/q/31969710/155423\">SO questions</a> about the topic."}], "answers": [{"tags": [], "owner": {"reputation": 31, "user_id": 4928925, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0489f93c144daa248a3b45d9b6b24f0d?s=128&d=identicon&r=PG&f=1", "display_name": "Jos van den Oever", "link": "https://stackoverflow.com/users/4928925/jos-van-den-oever"}, "is_accepted": false, "score": 1, "last_activity_date": 1462788084, "creation_date": 1462788084, "answer_id": 37112864, "question_id": 37075674, "link": "https://stackoverflow.com/questions/37075674/how-to-use-lifetimes-for-nesting-mutable-access/37112864#37112864", "title": "How to use lifetimes for nesting mutable access?", "body": "<p>There is a workaround. Instead of having a trait with a <code>next()</code> function, one can use a trait with an <code>iterate</code> function. In the example below, <code>TarStreamIterator</code> has a function <code>iterate</code> can accept a closure. (Alternatively, <code>iterator</code> could be called <code>for_each</code>.)</p>\n\n<p>The implementation still has a <code>next</code> function, but the borrow checker accepts this form.</p>\n\n<p>This short example does not actually do anything with the streams.</p>\n\n<pre><code>use std::io;\n// generic version of std::io::Read\ntrait Stream&lt;T&gt; {\n    fn read(&amp;mut self) -&gt; io::Result&lt;&amp;[T]&gt;;\n}\ntrait StreamIterator&lt;T&gt; {\n    // call `f` on each of the streams in the iterator\n    fn iterate&lt;F&gt;(&amp;mut self, mut f: F) where F: FnMut(&amp;mut Stream&lt;T&gt;);\n}\nstruct FileStream {\n}\nimpl&lt;T&gt; Stream&lt;T&gt; for FileStream {\n    fn read(&amp;mut self) -&gt; io::Result&lt;&amp;[T]&gt; {\n        Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"\"))\n    }\n}\nstruct TarStream&lt;'a&gt; {\n    stream: &amp;'a mut Stream&lt;u8&gt;\n}\nimpl&lt;'a&gt; Stream&lt;u8&gt; for TarStream&lt;'a&gt; {\n    fn read(&amp;mut self) -&gt; io::Result&lt;&amp;[u8]&gt; {\n        self.stream.read()\n    }\n}\nstruct TarStreamIterator&lt;'a&gt; {\n    stream: &amp;'a mut Stream&lt;u8&gt;\n}\nimpl&lt;'a&gt; TarStreamIterator&lt;'a&gt; {\n    // pass the next embedded stream or None if there are no more\n    fn next(&amp;mut self) -&gt; Option&lt;TarStream&gt; {\n        Some(TarStream{stream: self.stream})\n    }\n}\nimpl&lt;'a&gt; StreamIterator&lt;u8&gt; for TarStreamIterator&lt;'a&gt; {\n    fn iterate&lt;F&gt;(&amp;mut self, mut f: F) where F: FnMut(&amp;mut Stream&lt;u8&gt;) {\n        while let Some(mut substream) = self.next() {\n            f(&amp;mut substream);\n        }\n    }\n}\nfn analyze_as_tar(stream: &amp;mut Stream&lt;u8&gt;) {\n    TarStreamIterator{stream: stream}.iterate(|substream| {\n        analyze(substream);\n    });\n}\nfn analyze(s: &amp;mut Stream&lt;u8&gt;) {\n    analyze_as_tar(s)\n}\nfn main() {\n    let mut fs = FileStream{};\n    analyze(&amp;mut fs);\n}\n</code></pre>\n"}], "owner": {"reputation": 31, "user_id": 4928925, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0489f93c144daa248a3b45d9b6b24f0d?s=128&d=identicon&r=PG&f=1", "display_name": "Jos van den Oever", "link": "https://stackoverflow.com/users/4928925/jos-van-den-oever"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 82, "favorite_count": 0, "answer_count": 1, "score": 2, "last_activity_date": 1462788084, "creation_date": 1462546999, "question_id": 37075674, "link": "https://stackoverflow.com/questions/37075674/how-to-use-lifetimes-for-nesting-mutable-access", "title": "How to use lifetimes for nesting mutable access?", "body": "<p>I'm writing code in Rust for parsing streams, <code>trait Stream</code>. The streams can consist of other streams. The trait <code>StreamIterator</code> gives access to the substreams. This is when parsing tar files, zip files and other files that contain files.</p>\n\n<p>While writing this code, I've been unsuccessfully fighting the borrow checker.</p>\n\n<p>The code below is a simplified example. In <code>main</code> a file is opened as a stream. That stream is passed to the <code>analyze</code> function which tries to open the stream as a <code>TarStreamIterator</code> to iterate of the streams in the tar. Each embedded stream is also analyzed.</p>\n\n<p>I think that I might to introduce a second lifetime in the <code>StreamIterator</code> trait.</p>\n\n<pre><code>use std::io;\ntrait Stream&lt;T&gt; {\n    fn read(&amp;mut self) -&gt; io::Result&lt;&amp;[T]&gt;;\n}\ntrait StreamIterator&lt;'a,T,S: Stream&lt;T&gt;&gt; {\n    fn next(&amp;'a mut self) -&gt; Option&lt;io::Result&lt;S&gt;&gt;;\n}\nstruct FileStream {\n}\nimpl&lt;T&gt; Stream&lt;T&gt; for FileStream {\n    fn read(&amp;mut self) -&gt; io::Result&lt;&amp;[T]&gt; {\n        Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"\"))\n    }\n}\nstruct TarStream&lt;'a&gt; {\n    stream: &amp;'a mut Stream&lt;u8&gt;\n}\nimpl&lt;'a&gt; Stream&lt;u8&gt; for TarStream&lt;'a&gt; {\n    fn read(&amp;mut self) -&gt; io::Result&lt;&amp;[u8]&gt; {\n        self.stream.read()\n    }\n}\nstruct TarStreamIterator&lt;'a&gt; {\n    stream: &amp;'a mut Stream&lt;u8&gt;\n}\nimpl&lt;'a&gt; StreamIterator&lt;'a,u8,TarStream&lt;'a&gt;&gt; for TarStreamIterator&lt;'a&gt; {\n    fn next(&amp;'a mut self) -&gt; Option&lt;io::Result&lt;TarStream&gt;&gt; {\n        // todo: read tar header\n        Some(Ok(TarStream{stream: self.stream}))\n    }\n}\nfn analyzeAsTar(s: &amp;mut Stream&lt;u8&gt;) -&gt; bool {\n    let mut tar = TarStreamIterator{stream: s};\n    while let Some(Ok(mut substream)) = tar.next() {\n        analyze(&amp;mut substream);\n    }\n    true\n}\nfn analyze(s: &amp;mut Stream&lt;u8&gt;) -&gt; bool {\n    analyzeAsTar(s)\n}\nfn main() {\n    let mut fs = FileStream{};\n    analyze(&amp;mut fs);\n}\n</code></pre>\n\n<p>This gives this error:</p>\n\n<pre><code>&lt;anon&gt;:38:41: 38:44 error: cannot borrow `tar` as mutable more than once at a time [E0499]\n&lt;anon&gt;:38     while let Some(Ok(mut substream)) = tar.next() {\n                                                  ^~~\n&lt;anon&gt;:38:41: 38:44 help: see the detailed explanation for E0499\n&lt;anon&gt;:38:41: 38:44 note: previous borrow of `tar` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `tar` until the borrow ends\n&lt;anon&gt;:38     while let Some(Ok(mut substream)) = tar.next() {\n                                                  ^~~\n&lt;anon&gt;:42:2: 42:2 note: previous borrow ends here\n&lt;anon&gt;:36 fn analyzeAsTar(s: &amp;mut Stream&lt;u8&gt;) -&gt; bool {\n          ...\n&lt;anon&gt;:42 }\n</code></pre>\n"}, {"tags": ["rust", "llvm", "llvm-ir"], "answers": [{"comments": [{"owner": {"reputation": 3299, "user_id": 230504, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/acadd9b0700b9fcdfbc74aa6faffeb86?s=128&d=identicon&r=PG", "display_name": "Leonardo Marques", "link": "https://stackoverflow.com/users/230504/leonardo-marques"}, "edited": false, "score": 0, "creation_date": 1462702247, "post_id": 37093668, "comment_id": 61739969, "body": "This bug ticket is from 2015. I&#39;ve tried with the latest stable rust version and it still happens, so does it mean that rust still uses an older version of llvm?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 3299, "user_id": 230504, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/acadd9b0700b9fcdfbc74aa6faffeb86?s=128&d=identicon&r=PG", "display_name": "Leonardo Marques", "link": "https://stackoverflow.com/users/230504/leonardo-marques"}, "edited": false, "score": 1, "creation_date": 1462715488, "post_id": 37093668, "comment_id": 61743341, "body": "@LeonardoMarques Rust is open source, so you can just browse <a href=\"https://github.com/rust-lang/rust\" rel=\"nofollow noreferrer\">the repository</a> to see what version of LLVM they have. In this case, Rust has a <a href=\"https://github.com/rust-lang/llvm\" rel=\"nofollow noreferrer\">fork of LLVM</a> with small changes that haven&#39;t been upstreamed yet. This work is kept in various <a href=\"https://github.com/rust-lang/llvm/branches\" rel=\"nofollow noreferrer\">branches</a>. From my nightly build of Rust from 2016-05-03, <code>llc</code> self-identifies as LLVM 3.8.0."}], "tags": [], "owner": {"reputation": 8022, "user_id": 164925, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/35f656cad1ff0d8797c598930dda7faa?s=128&d=identicon&r=PG", "display_name": "Anton Korobeynikov", "link": "https://stackoverflow.com/users/164925/anton-korobeynikov"}, "is_accepted": true, "score": 2, "last_activity_date": 1462654841, "creation_date": 1462654841, "answer_id": 37093668, "question_id": 37075622, "link": "https://stackoverflow.com/questions/37075622/invalid-field-subprograms-while-parsing-llvm-ir-generated-by-rust/37093668#37093668", "title": "Invalid field &#39;subprograms&#39; while parsing LLVM-IR generated by Rust", "body": "<p>There were breaking changes in debug metadata format recently.</p>\n\n<p>See <a href=\"http://llvm.org/PR27284\" rel=\"nofollow\">http://llvm.org/PR27284</a> for more information</p>\n"}], "owner": {"reputation": 3299, "user_id": 230504, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/acadd9b0700b9fcdfbc74aa6faffeb86?s=128&d=identicon&r=PG", "display_name": "Leonardo Marques", "link": "https://stackoverflow.com/users/230504/leonardo-marques"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 441, "favorite_count": 0, "accepted_answer_id": 37093668, "answer_count": 1, "score": 1, "last_activity_date": 1462715648, "creation_date": 1462546840, "last_edit_date": 1462715648, "question_id": 37075622, "link": "https://stackoverflow.com/questions/37075622/invalid-field-subprograms-while-parsing-llvm-ir-generated-by-rust", "title": "Invalid field &#39;subprograms&#39; while parsing LLVM-IR generated by Rust", "body": "<p>I'm getting \"invalid field 'subprograms'\" when parsing LLVM-IR generated from Rust. It happens immediately at <code>!0</code>. </p>\n\n<p>Code used to parse:</p>\n\n<pre><code>MemoryBuffer* buf = MemoryBuffer::getMemBuffer(StringRef(fC)).release();\nSMDiagnostic err;\nLLVMContext *Context=new LLVMContext();\nModule* module = parseIR(buf-&gt;getMemBufferRef(), err, *Context).release();\nif(!module){\n    NSString* errorMsg=[NSString stringWithFormat:@\"%@ at line:%@ col:%@\\n&gt;&gt;%@\",[NSString stringWithCString:err.getMessage().str().c_str() encoding:NSUTF8StringEncoding], @(err.getLineNo()), @(err.getColumnNo()), [NSString stringWithCString:err.getLineContents().str().c_str() encoding:NSUTF8StringEncoding]];\n    NSError* error=[[NSError alloc] initWithDomain:errorMsg code:-1 userInfo:nil];\n    //Deal with NSError later\n}\nDebugInfoFinder* dif = new DebugInfoFinder();\ndif-&gt;processModule(*module);\n</code></pre>\n\n<p>Where it happens:</p>\n\n<pre><code>!0 = distinct !DICompileUnit(language: 36864, file: !1, producer: \"rustc version 1.7.0 (a5d1e7a59 2016-02-29)\", isOptimized: true, runtimeVersion: 0, emissionKind: 1, enums: !2, retainedTypes: !10, subprograms: !29)\n</code></pre>\n\n<p>The reference is just an array of references to subprograms as expected:</p>\n\n<pre><code>!29 = !{!30, !47, !55, !65, !77, !83, !92, !99, !113, !114}\n!30 = !DISubprogram(name: \"main\", linkageName: \"_ZN8fizzbuzz4mainE\", scope: !32, file: !31, line: 3, type: !33, isLocal: true, isDefinition: true, scopeLine: 3, flags: DIFlagPrototyped, isOptimized: true, function: void ()* @_ZN4main20hbe8861d85740ed2deaaE, templateParams: !35, variables: !36)\n</code></pre>\n\n<p>I think the IR code looks OK; could this be an issue with the LLVM version used by Rust vs. the one used by the llvm-ir parsing snippet?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 19680, "user_id": 562222, "user_type": "registered", "accept_rate": 57, "profile_image": "https://i.stack.imgur.com/jgGXb.jpg?s=128&g=1", "display_name": "qed", "link": "https://stackoverflow.com/users/562222/qed"}, "edited": false, "score": 0, "creation_date": 1462550153, "post_id": 37075146, "comment_id": 61697992, "body": "Interesting. Will it help if I move the <code>let len = self.len(); if len == self.capacity() { let (lower, _) = iterator.size_hint();        self.reserve(lower.saturating_add(1));  }</code> part before the while loop?"}, {"owner": {"reputation": 19680, "user_id": 562222, "user_type": "registered", "accept_rate": 57, "profile_image": "https://i.stack.imgur.com/jgGXb.jpg?s=128&g=1", "display_name": "qed", "link": "https://stackoverflow.com/users/562222/qed"}, "edited": false, "score": 0, "creation_date": 1462550191, "post_id": 37075146, "comment_id": 61698010, "body": "In fact, I think we don&#39;t need to check <code>self.capacity()</code> at all, should just go ahead and reserve."}, {"owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "reply_to_user": {"reputation": 19680, "user_id": 562222, "user_type": "registered", "accept_rate": 57, "profile_image": "https://i.stack.imgur.com/jgGXb.jpg?s=128&g=1", "display_name": "qed", "link": "https://stackoverflow.com/users/562222/qed"}, "edited": false, "score": 0, "creation_date": 1462552931, "post_id": 37075146, "comment_id": 61699579, "body": "Adding a <code>reserve</code> before the loop is sufficient to trigger the <code>unzip</code> trick. Removing the <code>reserve</code> inside the loop may not be a good idea.  I think that this scheme helps with iterators that keeps updating the <code>size_hint</code> to be more accurate."}, {"owner": {"reputation": 19680, "user_id": 562222, "user_type": "registered", "accept_rate": 57, "profile_image": "https://i.stack.imgur.com/jgGXb.jpg?s=128&g=1", "display_name": "qed", "link": "https://stackoverflow.com/users/562222/qed"}, "edited": false, "score": 0, "creation_date": 1462553902, "post_id": 37075146, "comment_id": 61700179, "body": "Sufficient only if you are unzipping into <code>Vec</code>s, right?"}, {"owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "reply_to_user": {"reputation": 19680, "user_id": 562222, "user_type": "registered", "accept_rate": 57, "profile_image": "https://i.stack.imgur.com/jgGXb.jpg?s=128&g=1", "display_name": "qed", "link": "https://stackoverflow.com/users/562222/qed"}, "edited": false, "score": 0, "creation_date": 1462554030, "post_id": 37075146, "comment_id": 61700255, "body": "Right. Only sufficient if unzipping into <code>Vec</code>s."}], "tags": [], "owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "is_accepted": true, "score": 5, "last_activity_date": 1462546863, "last_edit_date": 1462546863, "creation_date": 1462545400, "answer_id": 37075146, "question_id": 37074656, "link": "https://stackoverflow.com/questions/37074656/whats-the-purpose-of-sizehint-in-iteratorunzip/37075146#37075146", "title": "What&#39;s the purpose of SizeHint in Iterator::unzip?", "body": "<p>It is a cool trick. By giving this size hint, it gives <code>ts</code> and <code>us</code> the chance to reserve the space for the <code>extend</code> calls in the loop. According to the <a href=\"https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.size_hint\" rel=\"nofollow\"><code>documentation</code></a></p>\n\n<blockquote>\n  <p><code>size_hint()</code> is primarily intended to be used for optimizations such as reserving space for the elements of the iterator, but must not be trusted to e.g. omit bounds checks in unsafe code. An incorrect implementation of <code>size_hint()</code> should not lead to memory safety violations.</p>\n</blockquote>\n\n<p>Note that the creation of <code>SizeHint</code> is necessary because the <code>extend</code> call in for loop is made with a <code>Some</code> value (<code>Optional</code> implements the <code>Iterator</code> trait), and the <code>size_hint</code> for a <code>Some</code> value is <code>(1, Some(1))</code>. That doesn't help with pre allocation.</p>\n\n<p>But looking at the code for <a href=\"https://github.com/rust-lang/rust/blob/1.8.0/src/libcollections/vec.rs#L1377\" rel=\"nofollow\"><code>Vec</code></a>, this will have no effect (neither in <a href=\"https://github.com/rust-lang/rust/blob/1.8.0/src/libstd/collections/hash/map.rs#L1641\" rel=\"nofollow\"><code>HashMap</code></a> and <a href=\"https://github.com/rust-lang/rust/blob/1.8.0/src/libcollections/vec_deque.rs#L2097\" rel=\"nofollow\"><code>VecDeque</code></a>). Others <code>Extend</code> implementations may be different. </p>\n\n<p>The execution of <code>ts.extend(SizeHint(lo, hi, marker::PhantomData));</code> does not trigger a <code>resize</code>, since <code>next</code> returns <code>None</code>. Maybe some one should write a patch.</p>\n\n<pre><code>impl&lt;T&gt; Vec&lt;T&gt; {\n    fn extend_desugared&lt;I: Iterator&lt;Item = T&gt;&gt;(&amp;mut self, mut iterator: I) {\n        // This function should be the moral equivalent of:\n        //\n        //      for item in iterator {\n        //          self.push(item);\n        //      }\n        while let Some(element) = iterator.next() {\n            let len = self.len();\n            if len == self.capacity() {\n                let (lower, _) = iterator.size_hint();\n                self.reserve(lower.saturating_add(1));\n            }\n            unsafe {\n                ptr::write(self.get_unchecked_mut(len), element);\n                // NB can't overflow since we would have had to alloc the address space\n                self.set_len(len + 1);\n            }\n        }\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": false, "score": 5, "last_activity_date": 1462563897, "creation_date": 1462563897, "answer_id": 37080284, "question_id": 37074656, "link": "https://stackoverflow.com/questions/37074656/whats-the-purpose-of-sizehint-in-iteratorunzip/37080284#37080284", "title": "What&#39;s the purpose of SizeHint in Iterator::unzip?", "body": "<p>It's a dubious hack!</p>\n\n<p>It implements an iterator with a fake (overestimated) size hint to encourage the produced collection to reserve the eventually appropriate capacity up front.</p>\n\n<p>Cool trick but, it does so by implementing a size hint where the estimated lower bound is greater than the actual number of elements produced (0). If the lower bound is not known, the iterator should return a lower bound of 0. This implementation is arguably very buggy for this reason, and the collection's Extend impl may react with bugginess as a result (but of course not memory unsafety.)</p>\n"}], "owner": {"reputation": 19680, "user_id": 562222, "user_type": "registered", "accept_rate": 57, "profile_image": "https://i.stack.imgur.com/jgGXb.jpg?s=128&g=1", "display_name": "qed", "link": "https://stackoverflow.com/users/562222/qed"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1054, "favorite_count": 0, "accepted_answer_id": 37075146, "answer_count": 2, "score": 8, "last_activity_date": 1462563897, "creation_date": 1462544012, "last_edit_date": 1462545319, "question_id": 37074656, "link": "https://stackoverflow.com/questions/37074656/whats-the-purpose-of-sizehint-in-iteratorunzip", "title": "What&#39;s the purpose of SizeHint in Iterator::unzip?", "body": "<p>From the Rust standard library <a href=\"https://github.com/rust-lang/rust/blob/1.8.0/src/libcore/iter.rs#L2052-L2080\">implementation of <code>unzip</code></a>:</p>\n\n<pre><code>fn unzip&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB) where\n    FromA: Default + Extend&lt;A&gt;,\n    FromB: Default + Extend&lt;B&gt;,\n    Self: Sized + Iterator&lt;Item=(A, B)&gt;,\n{\n    struct SizeHint&lt;A&gt;(usize, Option&lt;usize&gt;, marker::PhantomData&lt;A&gt;);\n    impl&lt;A&gt; Iterator for SizeHint&lt;A&gt; {\n        type Item = A;\n\n        fn next(&amp;mut self) -&gt; Option&lt;A&gt; { None }\n        fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {\n            (self.0, self.1)\n        }\n    }\n\n    let (lo, hi) = self.size_hint();\n    let mut ts: FromA = Default::default();\n    let mut us: FromB = Default::default();\n\n    ts.extend(SizeHint(lo, hi, marker::PhantomData));\n    us.extend(SizeHint(lo, hi, marker::PhantomData));\n\n    for (t, u) in self {\n        ts.extend(Some(t));\n        us.extend(Some(u));\n    }\n\n    (ts, us)\n}\n</code></pre>\n\n<p>These two lines:</p>\n\n<pre><code>ts.extend(SizeHint(lo, hi, marker::PhantomData));\nus.extend(SizeHint(lo, hi, marker::PhantomData));\n</code></pre>\n\n<p>don't actually extend <code>ts</code> or <code>us</code> by anything, since the <code>next</code> method of <code>SizeHint</code> returns <code>None</code>. What's the purpose of doing so?</p>\n"}, {"tags": ["rust", "file-permissions", "bitwise-operators"], "answers": [{"tags": [], "owner": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "is_accepted": false, "score": 2, "last_activity_date": 1462493466, "creation_date": 1462493466, "answer_id": 37062238, "question_id": 37062143, "link": "https://stackoverflow.com/questions/37062143/how-to-check-if-file-is-executable-using-bitwise-operations-in-rust/37062238#37062238", "title": "How to check if file is executable using bitwise operations in Rust?", "body": "<p>You're close, you'll want to use this (I use <code>unwrap()</code> in the example for brevity):</p>\n\n<pre><code>let mode = fs::metadata(&amp;f).unwrap().mode();\nif mode &amp; 0o111 != 0 {\n    println!(\"binary...\");\n}\n</code></pre>\n\n<p>Credit due to <a href=\"https://github.com/rust-lang/rust/blob/77987ba89894997c174ac8b01185c0dc12913fa5/src/tools/tidy/src/bins.rs#L39\" rel=\"nofollow\">some code</a> I was working with a while ago.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1462495152, "last_edit_date": 1462495152, "creation_date": 1462493603, "answer_id": 37062258, "question_id": 37062143, "link": "https://stackoverflow.com/questions/37062143/how-to-check-if-file-is-executable-using-bitwise-operations-in-rust/37062258#37062258", "title": "How to check if file is executable using bitwise operations in Rust?", "body": "<p>In Rust, a leading <code>0</code> does not mean a number is in octal. You want to use the prefix <code>0o</code> instead:</p>\n\n<pre><code>fn main() {\n    println!(\"{}\", 0111);  // 111\n    println!(\"{}\", 0o111); //  73\n}\n</code></pre>\n\n<p><a href=\"http://doc.rust-lang.org/reference.html#numbers\" rel=\"nofollow\">Other prefixes</a> you may be interested in:</p>\n\n<pre><code>0xBEEF // Hex    (Base 16) =&gt; 48879\n0o1234 // Octal  (Base  8) =&gt;   668\n0b0101 // Binary (Base  2) =&gt;     5\n</code></pre>\n"}], "owner": {"reputation": 20521, "user_id": 1135424, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/rvwBS.jpg?s=128&g=1", "display_name": "nbari", "link": "https://stackoverflow.com/users/1135424/nbari"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 742, "favorite_count": 0, "accepted_answer_id": 37062258, "answer_count": 2, "score": 1, "last_activity_date": 1462495152, "creation_date": 1462492767, "last_edit_date": 1462493324, "question_id": 37062143, "link": "https://stackoverflow.com/questions/37062143/how-to-check-if-file-is-executable-using-bitwise-operations-in-rust", "title": "How to check if file is executable using bitwise operations in Rust?", "body": "<p>In many programming languages one can find if file is executable or not,  by doing a <a href=\"https://en.wikipedia.org/wiki/Bitwise_operation\" rel=\"nofollow\">bitwise and</a> between the <a href=\"https://en.wikipedia.org/wiki/File_system_permissions\" rel=\"nofollow\">mode bits</a> and <code>0111</code>, something like:</p>\n\n<pre><code>is_exec = (mode &amp; 0111) != 0 \n</code></pre>\n\n<p>Where <code>mode</code> represents the mode bits with an octal value something like <code>100755</code>, or <code>755</code>.</p>\n\n<p>Command line example:</p>\n\n<pre><code>perl -e 'printf \"%o\\n\", (stat \"file\")[2] &amp; 0111'\n</code></pre>\n\n<p>I am trying to follow this approach using Rust, but can't make it work, this is the code I am using:</p>\n\n<pre><code>fn print_dir(path: &amp;PathBuf) {                                                                                                                                            \n    let files = match fs::read_dir(&amp;path) {                                                                                                                               \n        Err(f) =&gt; {                                                                                                                                                       \n            println!(\"{}\", f);                                                                                                                                            \n            return;                                                                                                                                                       \n        }                                                                                                                                                                 \n        Ok(f) =&gt; f                                                                                                                                                        \n    };                                                                                                                                                                    \n\n    for f in files {                                                                                                                                                      \n        let file = f.unwrap();                                                                                                                                            \n        let mode = file.metadata().unwrap().permissions().mode();                                                                                                         \n        println!(\"path: {} {:o} - {} {:0}\", file.path().display(), mode, mode, mode &amp; 0111);                                                                              \n    }                                                                                                                                                                     \n} \n</code></pre>\n\n<p>The <code>mode &amp; 0111</code> is not behaving like expected as it always returns positives. I tried similar code in Go, and it was very straight forward:</p>\n\n<pre><code>var is_exec bool\nif m := f.Mode(); !m.IsDir() &amp;&amp; m&amp;0111 != 0 {\n    is_exec = true\n}\n</code></pre>\n\n<p>Any idea of how to do this with Rust?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 10831, "user_id": 23760, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/6b24e6790cb03535ea082d8d73d0a235?s=128&d=identicon&r=PG", "display_name": "ZeissS", "link": "https://stackoverflow.com/users/23760/zeisss"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462490731, "post_id": 37061819, "comment_id": 61670620, "body": "I will try the Vec solution they use, but my error is completly different."}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1462506601, "post_id": 37061819, "comment_id": 61674064, "body": "What difference are you encountering with the error? They&#39;re using a <code>Vec</code>, but an array is essentially identical: <code>let actions: [fn(State) -&gt; State; 7] = [...];</code> should be sufficient to make it work."}, {"owner": {"reputation": 10831, "user_id": 23760, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/6b24e6790cb03535ea082d8d73d0a235?s=128&d=identicon&r=PG", "display_name": "ZeissS", "link": "https://stackoverflow.com/users/23760/zeisss"}, "reply_to_user": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1462545554, "post_id": 37061819, "comment_id": 61694867, "body": "The <code>Vec</code> worked, but IMO it should work with an array too. See the error above."}], "owner": {"reputation": 10831, "user_id": 23760, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/6b24e6790cb03535ea082d8d73d0a235?s=128&d=identicon&r=PG", "display_name": "ZeissS", "link": "https://stackoverflow.com/users/23760/zeisss"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 57, "favorite_count": 0, "closed_date": 1462490860, "answer_count": 0, "score": 0, "last_activity_date": 1462492149, "creation_date": 1462490405, "last_edit_date": 1462492149, "question_id": 37061819, "link": "https://stackoverflow.com/questions/37061819/how-can-i-define-a-list-of-functions-to-call", "closed_reason": "Duplicate", "title": "How can I define a list of functions to call?", "body": "<p>I am trying to implement this <a href=\"https://www.reddit.com/r/dailyprogrammer/comments/4cb7eh\" rel=\"nofollow\">Reddit coding challenge</a>, but I get an error I don't understand and my searching was of no help.</p>\n\n<pre><code>#[derive(Debug)]\nstruct State {}\n\nfn button_clicked(state: State) -&gt; State {\n    state\n}\n\nfn cycle_complete(state: State) -&gt; State {\n    state\n}\n\nfn main() {\n    let actions = [\n        button_clicked,\n        cycle_complete,\n        button_clicked,\n        button_clicked,\n        button_clicked,\n        button_clicked,\n        button_clicked\n    ];\n    let mut state = State {};\n    for action in actions.iter() {\n        state = action(state);\n        println!(\"State = {:?}\", state);\n    }\n}\n</code></pre>\n\n<p>When I try to build this, I get:</p>\n\n<pre><code>$ cargo build\n   Compiling garageautomata v0.1.0 (file:///Users/zeisss/p/rust-example/garageautomata)\nsrc/main.rs:41:9: 41:23 error: mismatched types:\n expected `fn(State) -&gt; State {button_clicked}`,\n    found `fn(State) -&gt; State {cycle_complete}`\n(expected fn item,\n    found a different fn item) [E0308]\nsrc/main.rs:41         cycle_complete,\n                       ^~~~~~~~~~~~~~\nsrc/main.rs:41:9: 41:23 help: run `rustc --explain E0308` to see a detailed explanation\nerror: aborting due to previous error\nerror: Could not compile `garageautomata`.\n\nTo learn more, run the command again with --verbose.\n</code></pre>\n\n<p>(since the code is shortened, line 41 refers to first occurrence of <code>cycle_complete</code> in <code>main</code>).</p>\n\n<p>I am using Rust 1.8.0.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1526744189, "last_edit_date": 1526744189, "creation_date": 1462491811, "answer_id": 37062007, "question_id": 37061794, "link": "https://stackoverflow.com/questions/37061794/why-does-atomicusize-not-implement-send/37062007#37062007", "title": "Why does AtomicUsize not implement Send?", "body": "<p>It's a trick! <code>AtomicUsize</code> <em>does</em> implement <code>Send</code>:</p>\n\n<pre><code>use std::sync::atomic::AtomicUsize;\n\nfn checker&lt;T&gt;(_: T) where T: Send {}\n\nfn main() {\n    checker(AtomicUsize::default());\n}\n</code></pre>\n\n<p>In fact, there's even an <a href=\"https://github.com/rust-lang/rust/blob/1.8.0/src/test/run-pass/sync-send-atomics.rs\" rel=\"nofollow noreferrer\">automated test that ensures this is the case</a>.</p>\n\n<h3>Rust 1.26</h3>\n\n<p><a href=\"https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html#synthetic-implementations\" rel=\"nofollow noreferrer\">These <em>auto traits</em> are now documented</a>, thanks to a <a href=\"https://github.com/rust-lang/rust/pull/47833\" rel=\"nofollow noreferrer\">change made to rustdoc</a>.</p>\n\n<h3>Previous versions</h3>\n\n<p>The gotcha lies in how <code>Send</code> is implemented:</p>\n\n<blockquote>\n  <p>This trait is automatically derived when the compiler determines it's appropriate.</p>\n</blockquote>\n\n<p>This means that Rustdoc doesn't know that <code>Send</code> is implemented for a type because most types don't implement it explicitly.</p>\n\n<p>This explains why <code>AtomicPtr&lt;T&gt;</code> shows up in the implementers list: it has a special implementation that ignores the type of <code>T</code>.</p>\n"}], "owner": {"reputation": 147, "user_id": 6139957, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/K4Wxj.jpg?s=128&g=1", "display_name": "J. Dunne", "link": "https://stackoverflow.com/users/6139957/j-dunne"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 354, "favorite_count": 0, "accepted_answer_id": 37062007, "answer_count": 1, "score": 5, "last_activity_date": 1526744189, "creation_date": 1462490231, "last_edit_date": 1462490719, "question_id": 37061794, "link": "https://stackoverflow.com/questions/37061794/why-does-atomicusize-not-implement-send", "title": "Why does AtomicUsize not implement Send?", "body": "<p><code>std::sync::atomic::AtomicUsize</code> implements <code>Sync</code> which means immutable references are free of data races when shared between multiple threads. Why does <code>AtomicUsize</code> not implement <code>Send</code>? Is there state which is linked to the thread that created the atomic or is this a language design decision relating to the way atomics are intended to be used i.e. via a <code>Arc&lt;_&gt;</code> etc.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 4257, "user_id": 3347227, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/160c472b1c6c43b47cc98cc01d3ce317?s=128&d=identicon&r=PG", "display_name": "Erik Vesteraas", "link": "https://stackoverflow.com/users/3347227/erik-vesteraas"}, "is_accepted": true, "score": 3, "last_activity_date": 1462486103, "last_edit_date": 1462486103, "creation_date": 1462485771, "answer_id": 37061021, "question_id": 37060330, "link": "https://stackoverflow.com/questions/37060330/safe-way-to-push-the-local-value-into-a-static-mut/37061021#37061021", "title": "Safe way to push the local value into a static mut", "body": "<p>Without changing the type of <code>TABLE</code> the answer is no.</p>\n\n<p>To paraphrase <a href=\"https://doc.rust-lang.org/book/const-and-static.html\" rel=\"nofollow\">the section on static in the Rust book</a>:</p>\n\n<blockquote>\n  <p>Because <code>TABLE</code> is mutable, one thread could be updating it while another is reading it, causing memory unsafety. Both accessing and mutating a <code>static mut</code> is unsafe, and so must be done in an <code>unsafe</code> block</p>\n</blockquote>\n\n<p>If you know you will only ever have one thread, you could decide to live with the unsafe blocks, but if not you will need to change the type of the table to safely access it from multiple threads.</p>\n\n<p>To do this safely you need mutual exclusion. The standard library provides <a href=\"https://doc.rust-lang.org/std/sync/struct.Mutex.html\" rel=\"nofollow\"><code>std::sync::Mutex</code></a>. To create a static reference to a <code>Mutex</code> though, you will need <a href=\"https://crates.io/crates/lazy_static\" rel=\"nofollow\">the crate <code>lazy_static</code></a>. With those two ingredients you can use your table like this:</p>\n\n<pre><code>#[macro_use]\nextern crate lazy_static;\n\nuse std::sync::Mutex;\n\nlazy_static! {\n    static ref TABLE: Mutex&lt;[KV; 100]&gt; = Mutex::new([KV { k: -1, v: -1 }; 100]);\n}\n\n#[derive(Debug, Clone, Copy)]\nstruct KV {\n    k: i32,\n    v: i32,\n}\n\nfn update_table(i: usize, elem: KV) {\n    let mut table = TABLE.lock().unwrap();\n    table[i] = elem;\n}\n\nfn read_table(i: usize) -&gt; KV {\n    let table = TABLE.lock().unwrap();\n    table[i]\n}\n\nfn main() {\n    update_table(5, KV { k: 23, v: 35 });\n\n    println!(\"{:?}\", read_table(5));\n}\n</code></pre>\n\n<p>Remember to add <code>lazy_static</code> to your Cargo.toml:</p>\n\n<pre><code>[dependencies]\nlazy_static = \"0.1.*\"\n</code></pre>\n"}], "owner": {"reputation": 2503, "user_id": 1792540, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/00a116dbd784e6357445f496f6453947?s=128&d=identicon&r=PG", "display_name": "sndyuk", "link": "https://stackoverflow.com/users/1792540/sndyuk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 351, "favorite_count": 1, "accepted_answer_id": 37061021, "answer_count": 1, "score": 2, "last_activity_date": 1462486103, "creation_date": 1462482611, "question_id": 37060330, "link": "https://stackoverflow.com/questions/37060330/safe-way-to-push-the-local-value-into-a-static-mut", "title": "Safe way to push the local value into a static mut", "body": "<p>Is there safe way to push the local value <code>kv</code> into a <code>static mut TABLE</code>?</p>\n\n<pre><code>static mut TABLE: [KV; 100] = [KV { k: -1, v: -1 }; 100];\n\n#[derive(Debug, Clone, Copy)]\nstruct KV {\n    k: i32,\n    v: i32,\n}\n\nfn fun(i: usize) {\n    let kv = KV { k: 0, v: 0 };\n    unsafe {\n        TABLE[i] = kv;\n    }\n}\n</code></pre>\n"}, {"tags": ["unit-testing", "macros", "rust"], "answers": [{"tags": [], "owner": {"reputation": 2672, "user_id": 223936, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j58Xn.jpg?s=128&g=1", "display_name": "Plastikfan", "link": "https://stackoverflow.com/users/223936/plastikfan"}, "is_accepted": true, "score": 3, "last_activity_date": 1462491533, "last_edit_date": 1462491533, "creation_date": 1462477896, "answer_id": 37059110, "question_id": 37058836, "link": "https://stackoverflow.com/questions/37058836/how-to-use-ty-in-a-rust-macro/37059110#37059110", "title": "How to use ty in a Rust macro", "body": "<p>Well I realised I didn't need <code>ty</code> after all. I can just specify the type as an <code>ident</code> parameter so the following does work:</p>\n\n<pre><code>macro_rules! unit_test {\n    ($name:ident $fixt:ident $ftype:ident $expr:expr) =&gt; (\n        #[test]\n        fn $name() {\n            let mut $fixt = $ftype::setup();\n            $expr;\n\n            teardown(&amp;mut $fixt);\n        }\n    )\n}\n\nunit_test! (foo_fixture_should_be_initialised_using_generic_macro f FooTestFixture {\n    assert_eq!(f.name, \"Initialised\");\n});\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "is_accepted": false, "score": 3, "last_activity_date": 1536103102, "last_edit_date": 1536103102, "creation_date": 1462477904, "answer_id": 37059114, "question_id": 37058836, "link": "https://stackoverflow.com/questions/37058836/how-to-use-ty-in-a-rust-macro/37059114#37059114", "title": "How to use ty in a Rust macro", "body": "<p>A <code>ty</code> cannot be directly followed by an <code>expr</code>. It must be <a href=\"https://doc.rust-lang.org/book/first-edition/macros.html#syntactic-requirements\" rel=\"nofollow noreferrer\">followed by a specific set of tokens</a>:</p>\n\n<ul>\n<li><code>=&gt;</code></li>\n<li><code>,</code></li>\n<li><code>=</code></li>\n<li><code>|</code></li>\n<li><code>;</code></li>\n<li><code>:</code></li>\n<li><code>&gt;</code></li>\n<li><code>[</code></li>\n<li><code>{</code></li>\n<li><code>as</code></li>\n<li><code>where</code></li>\n</ul>\n\n<p>Similar restriction exists after an <code>expr</code>, <code>stmt</code>, <code>path</code> and <code>pat</code>. This was introduced in RFC 550 to <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md\" rel=\"nofollow noreferrer\">future-proof potential change in Rust syntax</a>.</p>\n\n<p>To fix it you need to change your macro's pattern, e.g.</p>\n\n<pre><code>macro_rules! unit_test {\n    ($name:ident $fixt:ident&lt;$ftype:ty&gt; $expr:expr) =&gt; (\n//                          ^         ^ followed by '&gt;' is OK\n\nunit_test! (test_name fixture_name&lt;FooTestFixture&gt; f {    \n//                                ^              ^\n</code></pre>\n"}], "owner": {"reputation": 2672, "user_id": 223936, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j58Xn.jpg?s=128&g=1", "display_name": "Plastikfan", "link": "https://stackoverflow.com/users/223936/plastikfan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1642, "favorite_count": 0, "accepted_answer_id": 37059110, "answer_count": 2, "score": 4, "last_activity_date": 1536103102, "creation_date": 1462476687, "question_id": 37058836, "link": "https://stackoverflow.com/questions/37058836/how-to-use-ty-in-a-rust-macro", "title": "How to use ty in a Rust macro", "body": "<p>I'm try to compose a generic solution to provide fixtures for unit testing Rust code. I have come up with a macro, which allows the user to define <em>setup</em> and <em>teardown</em> methods. Here is my solution so far:</p>\n\n<pre><code>struct FooTestFixture {\n    pub name : String\n}\n\nimpl FooTestFixture {\n    fn setup() -&gt; FooTestFixture {\n        FooTestFixture { name: String::from(\"Initialised\") }\n    }\n}\n\nfn teardown(fixture : &amp;mut FooTestFixture) {\n    fixture.name = \"\".to_string();\n}\n\nmacro_rules! unit_test {\n    ($name:ident $fixt:ident $expr:expr) =&gt; (\n        #[test]\n        fn $name() {\n            let mut $fixt : FooTestFixture = FooTestFixture::setup();\n            $expr;\n\n            teardown(&amp;mut $fixt);\n        }\n    )\n}\n\nunit_test! (heap_foo_fixture_should_be_initialised_using_macro f {\n    assert_eq!(f.name, \"Initialised\");\n});\n</code></pre>\n\n<p>This works. The only problem is, that the macro unit_test is not generic, and is bound to the fixture name <em>FooTestFixture</em>. This means that each test module needs to redefine this macro for every test fixture, which is not ideal. What I'd like to be able to do is to also introduce a type variable and use that type in the macro expansion. Delving more into macros I have found that there is a 'ty' item, that represents a type, and I thought I could do this ...</p>\n\n<pre><code>macro_rules! unit_test {\n    ($name:ident $fixt:ident $ftype:ty $expr:expr) =&gt; (\n        #[test]\n        fn $name() {\n            let mut $fixt : $ftype = $ftype::setup();\n            $expr;\n\n            teardown(&amp;mut $fixt);\n        }\n    )\n}\n\nunit_test! (heap_foo_fixture_should_be_initialised_using_macro FooTestFixture f {\n    assert_eq!(f.name, \"Initialised\");\n});\n</code></pre>\n\n<p>However, this doesn't work and results in the following error:</p>\n\n<blockquote>\n  <p>src\\tests\\heap_fixture_with_new.rs:48:40: 48:50 error: <code>$ftype:ty</code> is\n  followed by <code>$expr:expr</code>, which is not allowed for <code>ty</code> fragments\n  src\\tests\\heap_fixture_with_new.rs:48     ($name:ident $fixt:ident\n  $ftype:ty $expr:expr) => (</p>\n</blockquote>\n\n<p>As you can see, in the macro definition, I have replaced references to FooTestFixture with $ftype.</p>\n\n<p>Is what I'm trying to achieve possible? It's almost like I'd like the macro to be generic, allowing you to pass in a type, to be used inside the macro definition.</p>\n"}, {"tags": ["rust", "traits", "lifetime", "specialization"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 9, "last_activity_date": 1617325873, "last_edit_date": 1617325873, "creation_date": 1462460863, "answer_id": 37054072, "question_id": 37053567, "link": "https://stackoverflow.com/questions/37053567/is-it-possible-to-specialize-on-a-static-lifetime/37054072#37054072", "title": "Is it possible to specialize on a static lifetime?", "body": "<p>Rust 1.51.0 does not have specialization of any kind. If I'm reading <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md#interaction-with-lifetimes\" rel=\"nofollow noreferrer\">the specialization RFC</a> correctly, then lifetime specialization will <strong>not</strong> be supported even when the RFC is implemented:</p>\n<blockquote>\n<p>A hard constraint in the design of the trait system is that dispatch\ncannot depend on lifetime information. In particular, <strong>we both cannot,\nand should not allow specialization based on lifetimes</strong>:</p>\n<ul>\n<li><p>We can't, because when the compiler goes to actually generate code (&quot;trans&quot;), lifetime information has been erased -- so we'd have no\nidea what specializations would soundly apply.</p>\n</li>\n<li><p>We shouldn't, because lifetime inference is subtle and would often lead to counterintuitive results. For example, you could easily fail\nto get <code>'static</code> even if it applies, because inference is choosing the\nsmallest lifetime that matches the other constraints.</p>\n</li>\n</ul>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>There's some examples further in the link that indicate some of the concrete issues.</p>\n<p>I recommend using a <code>Cow</code> to handle the &quot;owned or borrowed&quot; case.</p>\n"}, {"tags": [], "owner": {"reputation": 11723, "user_id": 3356777, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/1c7bee1f2c7ba7f81ddb902b83626558?s=128&d=identicon&r=PG&f=1", "display_name": "attdona", "link": "https://stackoverflow.com/users/3356777/attdona"}, "is_accepted": false, "score": -1, "last_activity_date": 1525531699, "last_edit_date": 1525531699, "creation_date": 1525415024, "answer_id": 50168450, "question_id": 37053567, "link": "https://stackoverflow.com/questions/37053567/is-it-possible-to-specialize-on-a-static-lifetime/50168450#50168450", "title": "Is it possible to specialize on a static lifetime?", "body": "<p>I write this answer after reading this <a href=\"https://stackoverflow.com/questions/50159002/different-implementations-for-static-and-non-static-arguments\">duplicated post</a> asking how to define a method/function that behaves differently when it is passed a static string or a non-static string.</p>\n\n<p>This is not possible, so a workaround may be using a wrapper type to wrap the string argument in an <code>enum</code>:</p>\n\n<pre><code>enum MyString {\n    Static(&amp;'static str),\n    Heap(String),\n}\n\nfn bar(arg: &amp;MyString) {\n    match arg {\n        &amp;MyString::Static(ref name) =&gt; println!(\"my first pc was {}\", name),\n        &amp;MyString::Heap(ref name) =&gt; println!(\"I dont know {}\", name),\n    }\n}\n\nfn main() {\n    let mut v = Vec::new();\n\n    let forever: &amp;'static str = \"zx-spectrum\";\n    let local: &amp;str = &amp;\"commodore64\".to_string();\n\n    v.push(MyString::Static(forever));\n\n    // ERROR: try to insert 'a lifetime\n    // v.push(Mystring::Static(local));\n    v.push(MyString::Heap(local.to_string()));\n\n    v.push(MyString::Heap(\"muggle\".to_string()));\n\n    bar(&amp;v[0]);\n    bar(&amp;v[1]);\n}\n</code></pre>\n\n<p><code>MyString</code> stores a statically-allocated string literal as a <code>&amp;'static str</code> and all other strings as a <code>String</code>.  </p>\n\n<p>As pointed in the comments below, the standard library provides a type that fits the borrowed/owned case: the smart pointer <a href=\"https://doc.rust-lang.org/std/borrow/enum.Cow.html\" rel=\"nofollow noreferrer\"><code>Cow</code></a>.</p>\n\n<p>The enum <code>MyString</code> used in this example is just a specific enum for managing string types. </p>\n\n<p>The only difference stems from a somewhat more specific naming of the enum and its variants related to the specific usage: <code>MyString::Static(\"forever\")</code> versus <code>Cow::Borrowed(\"forever\")</code> and <code>MyString::Heap(str)</code> versus <code>Cow::Owned(str)</code>.</p>\n\n<p>Does this help improve mnemonics and code readability? I'm quite sure that this holds only for novices or occasional Rust programmers, not for seasoned Rustaceans.  </p>\n"}], "owner": {"reputation": 2584, "user_id": 1094609, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/2f03a85e1167ccb340e3d1cb2da67995?s=128&d=identicon&r=PG", "display_name": "Craig M. Brandenburg", "link": "https://stackoverflow.com/users/1094609/craig-m-brandenburg"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 529, "favorite_count": 0, "accepted_answer_id": 37054072, "answer_count": 2, "score": 4, "last_activity_date": 1617325873, "creation_date": 1462459508, "last_edit_date": 1617325853, "question_id": 37053567, "link": "https://stackoverflow.com/questions/37053567/is-it-possible-to-specialize-on-a-static-lifetime", "title": "Is it possible to specialize on a static lifetime?", "body": "<p>I want to specialize <code>&amp;'static str</code> from <code>&amp;'a str</code>:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>use std::borrow::Cow;\n\nstruct MyString {\n    inner: Cow&lt;'static, str&gt;,\n}\n\nimpl From&lt;&amp;'static str&gt; for MyString {\n    fn from(x: &amp;'static str) -&gt; Self {\n        MyString {\n            inner: Cow::Borrowed(x),\n        }\n    }\n}\n\nimpl&lt;T: Into&lt;String&gt;&gt; From&lt;T&gt; for MyString {\n    fn from(x: T) -&gt; Self {\n        MyString {\n            inner: Cow::Owned(x.into()),\n        }\n    }\n}\n\nfn main() {\n    match MyString::from(&quot;foo&quot;).inner {\n        Cow::Borrowed(..) =&gt; (),\n        _ =&gt; {\n            panic!();\n        }\n    }\n\n    let s = String::from(&quot;bar&quot;);\n    match MyString::from(s.as_ref()).inner {\n        Cow::Owned(..) =&gt; (),\n        _ =&gt; {\n            panic!();\n        }\n    }\n\n    match MyString::from(String::from(&quot;qux&quot;)).inner {\n        Cow::Owned(..) =&gt; (),\n        _ =&gt; {\n            panic!();\n        }\n    }\n}\n</code></pre>\n<p>The gist is that <code>MyString</code> stores a statically-allocated string literal as a <code>&amp;'static str</code> and all other strings as a <code>String</code>. This allows <code>MyString</code> to avoid having a lifetime parameter\u2014i.e., <code>MyString&lt;'a&gt;</code>, which is critical for my API, all while allowing the caller to pass in any kind of string and have <code>MyString</code> automatically do the correct thing.</p>\n<p>The problem is that the code doesn't compile:</p>\n<pre class=\"lang-none prettyprint-override\"><code>error[E0119]: conflicting implementations of trait `std::convert::From&lt;&amp;'static str&gt;` for type `MyString`:\n  --&gt; src/main.rs:15:1\n   |\n7  | impl From&lt;&amp;'static str&gt; for MyString {\n   | ------------------------------------ first implementation here\n...\n15 | impl&lt;T: Into&lt;String&gt;&gt; From&lt;T&gt; for MyString {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `MyString`\n</code></pre>\n<p>Is there any trick that allows me to do what I want? If not, is lifetime specialization something that Rust will ever support?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 20035, "user_id": 2971, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/f3f6251940b41a2251e7a9f4b745a7f2?s=128&d=identicon&r=PG", "display_name": "Magnus Hoff", "link": "https://stackoverflow.com/users/2971/magnus-hoff"}, "edited": false, "score": 2, "creation_date": 1462446053, "post_id": 37048629, "comment_id": 61645263, "body": "I take it as a rule to only use <code>if let</code> if I assign/destructure something, so I might write <code>if let Some(ch) = sc.next() ...</code> since I get <code>ch</code> out of it, but not <code>if let None = foo(sc)</code>."}], "answers": [{"tags": [], "owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "is_accepted": false, "score": 2, "last_activity_date": 1462450726, "last_edit_date": 1462450726, "creation_date": 1462445897, "answer_id": 37048828, "question_id": 37048629, "link": "https://stackoverflow.com/questions/37048629/is-an-if-let-or-a-normal-if-condition-better/37048828#37048828", "title": "Is an if-let or a normal if condition better?", "body": "<blockquote>\n  <p>So my questions is: Is it ok using a == b instead of if let a = b?</p>\n</blockquote>\n\n<p>Yes, that's absolutely fine.</p>\n\n<p>One thing to note, though, is that the former will only compile if you're working on some type <code>Option&lt;T&gt;</code> where <code>T</code> implements <code>PartialEq</code>, while the latter will work regardless. This is because <code>Option&lt;T&gt;</code> only implements <code>PartialEq</code> if <code>T</code> implements <code>PartialEq</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1462450516, "last_edit_date": 1495541766, "creation_date": 1462447489, "answer_id": 37049375, "question_id": 37048629, "link": "https://stackoverflow.com/questions/37048629/is-an-if-let-or-a-normal-if-condition-better/37049375#37049375", "title": "Is an if-let or a normal if condition better?", "body": "<p>Echoing and expanding on <a href=\"https://stackoverflow.com/questions/37048629/rust-if-let-vs-normal-if-condition-which-way-is-better#comment61645263_37048629\">Magnus Hoff's point</a>, I only use <code>if let</code> when I care about the value being matched against. In this example, I'd use something like <a href=\"http://doc.rust-lang.org/std/option/enum.Option.html#method.is_none\" rel=\"noreferrer\"><code>Option::is_none</code></a> to further highlight that I don't care:</p>\n\n<pre><code>if foo().is_none() { \n</code></pre>\n\n<p>This has the tiny benefit of sidestepping the requirement for the wrapped <code>T</code> to implement <code>PartialEq</code>, as <a href=\"https://stackoverflow.com/a/37048828/155423\">fjh points out</a>.</p>\n\n<p>In my experience however, this <em>particular</em> construct is rarely seen because usually you want to do something in the <code>Some</code> case. Once you have multiple branches, I upgrade to a <code>match</code> statement.</p>\n"}], "owner": {"reputation": 181, "user_id": 5703811, "user_type": "registered", "accept_rate": 75, "profile_image": "https://lh3.googleusercontent.com/-KdwVWNc1XnU/AAAAAAAAAAI/AAAAAAAAABc/c7Btbcrq2e8/photo.jpg?sz=128", "display_name": "KuanYu Chu", "link": "https://stackoverflow.com/users/5703811/kuanyu-chu"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1765, "favorite_count": 1, "accepted_answer_id": 37049375, "answer_count": 2, "score": 5, "last_activity_date": 1462450726, "creation_date": 1462445402, "last_edit_date": 1462447508, "question_id": 37048629, "link": "https://stackoverflow.com/questions/37048629/is-an-if-let-or-a-normal-if-condition-better", "title": "Is an if-let or a normal if condition better?", "body": "<p>For example:</p>\n\n<pre><code>fn foo() -&gt; Option&lt;()&gt; {\n     // ...\n}\n\nfn bar() -&gt; Option&lt;()&gt; {\n    if let None = foo() { // &lt;---- here\n        return None;\n    }\n}\n</code></pre>\n\n<p>Then I changed the if-statement to:</p>\n\n<pre><code>if None == foo()\n</code></pre>\n\n<p>and it also works.</p>\n\n<p>Is it ok to use <code>a == b</code> instead of <code>if let a = b</code>?</p>\n"}, {"tags": ["rust", "mutable", "borrow-checker", "borrowing"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1462448493, "post_id": 37046567, "comment_id": 61646809, "body": "<b>Trees</b> are pretty natural data structures in Rust, but when you add parent pointers to a tree you have a <b>graph</b>. Graphs are <i>much</i> harder because the ownership of each node becomes very murky. Please check out some existing questions (<a href=\"http://stackoverflow.com/q/28608823/155423\">1</a>, <a href=\"http://stackoverflow.com/q/16911554/155423\">2</a>, <a href=\"http://stackoverflow.com/q/34747464/155423\">3</a>, <a href=\"http://stackoverflow.com/q/27001067/155423\">4</a>, <a href=\"http://stackoverflow.com/q/36565833/155423\">5</a>, and there are more) and then either mark this as a duplicate or <a href=\"https://stackoverflow.com/posts/37046567/edit\">edit</a> your question to explain the difference."}, {"owner": {"reputation": 235, "user_id": 2495121, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5eb47317ab09b894221f8d0e42f11624?s=128&d=identicon&r=PG", "display_name": "dromtrund", "link": "https://stackoverflow.com/users/2495121/dromtrund"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462468644, "post_id": 37046567, "comment_id": 61659871, "body": "@Shepmaster Thanks. The goal is not to create a search tree, but a full on back-traceable tree structure of independent objects. The accepted answer in your first post starts with &quot;You can&#39;t represent an arbitrary graph structure in safe rust.&quot;. Is this really the case? I mean.. it&#39;s a pretty fundamental way of representing relationships. Are there no ways of pointing to an object without owning it?"}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 2, "creation_date": 1462479487, "post_id": 37046567, "comment_id": 61666072, "body": "@dromtrund There&#39;s some stuff you can do with weak reference counters, but honestly in most cases it&#39;s probably better for your sanity to do with <code>unsafe</code> and raw pointers as long as you don&#39;t expose the unsafe bits to users."}, {"owner": {"reputation": 17491, "user_id": 901827, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/86a6acccf7e8dbe398ebda4f8524ed50?s=128&d=identicon&r=PG", "display_name": "LinearZoetrope", "link": "https://stackoverflow.com/users/901827/linearzoetrope"}, "edited": false, "score": 2, "creation_date": 1462479664, "post_id": 37046567, "comment_id": 61666163, "body": "The other way I never see mentioned is to store the tree nodes in a <code>Vec</code> or something and assign each one a unique <code>Copy</code>-able ID, and then instead of holding a child/parent pointer just store the ID of your child/parent."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 2, "creation_date": 1462480826, "post_id": 37046567, "comment_id": 61666805, "body": "See <a href=\"http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html\" rel=\"nofollow noreferrer\">Learning Rust With Entirely Too Many Linked Lists</a> which should walk you through a few different solutions to this."}], "owner": {"reputation": 235, "user_id": 2495121, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5eb47317ab09b894221f8d0e42f11624?s=128&d=identicon&r=PG", "display_name": "dromtrund", "link": "https://stackoverflow.com/users/2495121/dromtrund"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 347, "favorite_count": 0, "answer_count": 0, "score": 3, "last_activity_date": 1462448239, "creation_date": 1462439138, "last_edit_date": 1462448239, "question_id": 37046567, "link": "https://stackoverflow.com/questions/37046567/boxing-a-reference-to-mut-self", "title": "Boxing a reference to &amp;mut self", "body": "<p>I'm new to Rust, and as part of the learning process, I'm attempting to create a tree structure where each node has a vector of children and a reference to its parent. I want to create an <code>addChild()</code> function to the node, which takes the value of the new node (<code>i32</code>s for now), adds it to the child-list, and passes a reference to itself as a parent. Following Rust by Example's <a href=\"http://rustbyexample.com/custom_types/enum/testcase_linked_list.html\" rel=\"nofollow\">linked list example</a>, I'm trying to reference the parent with a <code>Box&lt;&gt;</code>. Since I'm both modifying the parent and passing a reference to it, I got stuck, as the borrow checker doesn't want me to dereference the <code>&amp;mut self</code> (see the code below).</p>\n\n<p>From this I have two questions:</p>\n\n<ol>\n<li><p>What is the correct way to keep a reference the parent in a tree structure? In C I would keep a simple pointer to the parent and some arbitrary collection for the children.</p></li>\n<li><p>How are you supposed to both modify and pass a reference to an object in the same function in Rust?</p></li>\n</ol>\n\n<p>Below is the full code for my enum and impl, with an additional test-function to modify self without passing it.</p>\n\n<hr>\n\n<pre><code>#[derive(Hash, Eq, PartialEq)]\nenum Node {\n    Elem {\n        value: i32,\n        parent: Box&lt;Node&gt;,\n        children: Vec&lt;Node&gt;,\n    },\n    Nil,\n}\n\nimpl Node {\n    fn new(value: i32, parent: Box&lt;Node&gt;) -&gt; Node {\n        return Node::Elem {\n            value: value,\n            parent: parent,\n            children: Vec::new(),\n        };\n    }\n\n    // This function works fine\n    fn setValue(&amp;mut self, v: i32) {\n        match self {\n            &amp;mut Node::Elem { ref mut value, .. } =&gt; *value = v,\n            &amp;mut Node::Nil =&gt; {}\n        }\n    }\n\n    fn addChild(&amp;mut self, value: i32) {\n        match self {\n            &amp;mut Node::Elem { ref mut children, .. } =&gt; {\n                (*children).push(Node::new(value, Box::new(*self)))\n                // Produces E0507 (Cannot move out of borrowed context)\n            } \n            &amp;mut Node::Nil =&gt; println!(\"Failed to add children to empty node\"),\n        }\n    }\n}\n</code></pre>\n"}, {"tags": ["arrays", "rust"], "answers": [{"tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": true, "score": 3, "last_activity_date": 1462426551, "creation_date": 1462426551, "answer_id": 37043155, "question_id": 37043067, "link": "https://stackoverflow.com/questions/37043067/how-to-modify-the-last-item-of-an-array/37043155#37043155", "title": "How to modify the last item of an array?", "body": "<p>This will hopefully be fixed with the introduction of non-lexical lifetimes and the accompanying changes soon into the future (seems like it could be solved?).</p>\n\n<p>For now though, you can satisfy the borrow checker by splitting that calculation out:</p>\n\n<pre><code>let n = arr.len() - 1;\nlet last = &amp;mut arr[n];\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 827, "user_id": 962163, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f6cfe6e59978b1bb04311df2d846c579?s=128&d=identicon&r=PG", "display_name": "limon", "link": "https://stackoverflow.com/users/962163/limon"}, "edited": false, "score": 0, "creation_date": 1462428133, "post_id": 37043424, "comment_id": 61635613, "body": "yes, much cleaner. and that reminds me the return type should be an Option in case of an empty array, thanks."}, {"owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "reply_to_user": {"reputation": 827, "user_id": 962163, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f6cfe6e59978b1bb04311df2d846c579?s=128&d=identicon&r=PG", "display_name": "limon", "link": "https://stackoverflow.com/users/962163/limon"}, "edited": false, "score": 0, "creation_date": 1462428316, "post_id": 37043424, "comment_id": 61635687, "body": "@limon , yes, if you cannot guarantee the array is not empty, or this this function is public, thus out side of your control on how they will be used, then <code>Option</code> is a better choice."}], "tags": [], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "is_accepted": false, "score": 6, "last_activity_date": 1462458173, "last_edit_date": 1462458173, "creation_date": 1462427852, "answer_id": 37043424, "question_id": 37043067, "link": "https://stackoverflow.com/questions/37043067/how-to-modify-the-last-item-of-an-array/37043424#37043424", "title": "How to modify the last item of an array?", "body": "<p>If you only need the last, you can use <code>std::slice::last_mut</code></p>\n\n<pre><code>fn double_last(arr: &amp;mut[i32]) -&gt; &amp;i32 {\n    let last = arr.last_mut().unwrap();\n    *last *= 2;\n    last\n}\n</code></pre>\n"}], "owner": {"reputation": 827, "user_id": 962163, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f6cfe6e59978b1bb04311df2d846c579?s=128&d=identicon&r=PG", "display_name": "limon", "link": "https://stackoverflow.com/users/962163/limon"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2249, "favorite_count": 2, "accepted_answer_id": 37043155, "answer_count": 2, "score": 5, "last_activity_date": 1462458173, "creation_date": 1462426171, "question_id": 37043067, "link": "https://stackoverflow.com/questions/37043067/how-to-modify-the-last-item-of-an-array", "title": "How to modify the last item of an array?", "body": "<p>Since <code>arr</code> is borrowed as mutable, the length of <code>arr</code> can't be gotten by calling <code>len()</code>. I'm stuck here, what's the right way to do it?</p>\n\n<pre><code>fn double_last(arr: &amp;mut[i32]) -&gt; &amp;i32 {\n    let last = &amp;mut arr[arr.len() - 1];  // borrow checker error.\n    //let last = &amp;mut arr[3];            // fine\n    *last *= 2;\n    last\n}\n\nfn main() {\n    let mut a = [1,2,3,4];\n    println!(\"{}\", double_last(&amp;mut a));\n    println!(\"{:?}\", a);\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1462447721, "post_id": 37042634, "comment_id": 61646327, "body": "<a href=\"http://doc.rust-lang.org/stable/book/\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i></a> covers these topics: <a href=\"http://doc.rust-lang.org/stable/book/enums.html\" rel=\"nofollow noreferrer\">enums</a>, <a href=\"http://doc.rust-lang.org/stable/book/match.html\" rel=\"nofollow noreferrer\"><code>match</code></a>, and <a href=\"http://doc.rust-lang.org/stable/book/patterns.html\" rel=\"nofollow noreferrer\">patterns</a>."}], "answers": [{"comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user266003"}, "edited": false, "score": 0, "creation_date": 1462428740, "post_id": 37042774, "comment_id": 61635864, "body": "if they all had the same underlying type, say, u32 like A does, how would get that variable?"}, {"owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "edited": false, "score": 1, "creation_date": 1462429390, "post_id": 37042774, "comment_id": 61636162, "body": "@OskarK. Then you will need to use <code>match</code>: <code>let v = match my_struct1.my_enum { MyEnum::A(a) =&gt; a, MyEnum::B(b) =&gt; b, MyEnum::C(c) =&gt; c };</code>."}], "tags": [], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "is_accepted": true, "score": 4, "last_activity_date": 1462424715, "creation_date": 1462424715, "answer_id": 37042774, "question_id": 37042634, "link": "https://stackoverflow.com/questions/37042634/get-the-underlying-variable-of-an-enum/37042774#37042774", "title": "Get the underlying variable of an enum", "body": "<p>Pattern matching is not limited to <code>match</code>. If you only care about one type of the variant, you can also do</p>\n\n<pre><code>if let MyEnum::B(s) = my_struct1.my_enum {\n    println!(\"{}\", s);\n}\n</code></pre>\n\n<p>The <code>println</code> line will only be run when the value of <code>my_struct1.my_enum</code> is actually of type <code>MyEnum::B</code>. Rust <code>enum</code> is safe. It is not like C <code>union</code>, which you can unsafely access the underlying value as you wish no matter which type the value actually is.</p>\n"}], "owner": {"user_type": "does_not_exist", "display_name": "user266003"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1998, "favorite_count": 0, "accepted_answer_id": 37042774, "answer_count": 1, "score": 3, "last_activity_date": 1523411953, "creation_date": 1462424035, "last_edit_date": 1523411953, "question_id": 37042634, "link": "https://stackoverflow.com/questions/37042634/get-the-underlying-variable-of-an-enum", "title": "Get the underlying variable of an enum", "body": "<p>My simplified code:</p>\n\n<pre><code>enum MyEnum {\n    A(u32),\n    B(String),\n    C(i32),\n}\n\npub struct MyStruct {\n    aa: String,\n    bb: u16,\n    my_enum: MyEnum,\n}\n\nlet my_struct1 = MyStruct { /*...*/ };\n</code></pre>\n\n<p>How can I get the underlying variable of <code>my_struct1.my_enum</code> which could be a <code>u32</code>, <code>String</code> or <code>i32</code>. Is it only by pattern matching?</p>\n"}]