[{"tags": ["python", "variables", "rust", "var"], "comments": [{"owner": {"reputation": 59346, "user_id": 444036, "user_type": "registered", "accept_rate": 97, "profile_image": "https://i.stack.imgur.com/My2AZ.jpg?s=128&g=1", "display_name": "Paulo Scardine", "link": "https://stackoverflow.com/users/444036/paulo-scardine"}, "edited": false, "score": 0, "creation_date": 1516221629, "post_id": 48309591, "comment_id": 83604891, "body": "You need something like <a href=\"https://github.com/lukemetz/rustpy\" rel=\"nofollow noreferrer\">github.com/lukemetz/rustpy</a> or <a href=\"https://github.com/dgrunwald/rust-cpython\" rel=\"nofollow noreferrer\">github.com/dgrunwald/rust-cpython</a>"}, {"owner": {"reputation": 2630, "user_id": 8150371, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Yqtry.jpg?s=128&g=1", "display_name": "Stack", "link": "https://stackoverflow.com/users/8150371/stack"}, "edited": false, "score": 3, "creation_date": 1516221702, "post_id": 48309591, "comment_id": 83604935, "body": "1. You can save the urls in a file and make python load the urls from the file. 2. You can pass url as command line args to the python file."}, {"owner": {"user_type": "does_not_exist", "display_name": "user9216466"}, "edited": false, "score": 0, "creation_date": 1516222238, "post_id": 48309591, "comment_id": 83605200, "body": "I think I like the idea of the urls in a file, but then comes the problem of telling Python WHEN to download the files. Maybe the program reads the text file for a signal?"}, {"owner": {"reputation": 1470, "user_id": 2075745, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/6f9a084d236381e1882c4e28edb5151f?s=128&d=identicon&r=PG", "display_name": "user25064", "link": "https://stackoverflow.com/users/2075745/user25064"}, "edited": false, "score": 0, "creation_date": 1516222277, "post_id": 48309591, "comment_id": 83605224, "body": "see also <a href=\"https://github.com/PyO3/pyo3\" rel=\"nofollow noreferrer\">github.com/PyO3/pyo3</a>"}, {"owner": {"user_type": "does_not_exist", "display_name": "user9216466"}, "edited": false, "score": 0, "creation_date": 1516222762, "post_id": 48309591, "comment_id": 83605480, "body": "Stack, would the code I posted also function if instead of url = &#39;insert url here&#39; I put url = x ?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1516231401, "post_id": 48309591, "comment_id": 83609063, "body": "It is really unclear what your desired architecture is. There are lots of ways to invoke Python code from Rust and vice versa (and in general, to invoke one program from another), including: 1) run Rust program as a subprocess from Python; 2) run Python program as a subprocess from Rust; 3) embed Python interpreter in a Rust program and run the script in it; 4) use the Rust program as a native module in a Python program; 5) run Rust and Python programs separately and use one of the zillion IPC mechanisms to communicate between them. You need to consider all these options and choose one."}, {"owner": {"reputation": 22505, "user_id": 1411457, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/XqssD.png?s=128&g=1", "display_name": "harmic", "link": "https://stackoverflow.com/users/1411457/harmic"}, "edited": false, "score": 1, "creation_date": 1516234241, "post_id": 48309591, "comment_id": 83609799, "body": "It&#39;s not that clear to me why you need to use python in the first place. Your example program is just downloading three copies of the file using 3 different python libs. But if all you are trying to do is download a file why not do it directly in rust?"}], "owner": {"user_type": "does_not_exist", "display_name": "user9216466"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 332, "favorite_count": 0, "answer_count": 0, "score": 0, "last_activity_date": 1516225491, "creation_date": 1516221407, "last_edit_date": 1516225491, "question_id": 48309591, "link": "https://stackoverflow.com/questions/48309591/send-rust-variable-to-python", "title": "Send Rust variable to Python?", "body": "<p>I am building a Rust program in which the user types in a command, and then the program reads the command and responds accordingly. One of these commands is to download a file from a set site. </p>\n\n<p>I have a .py file with the following code that I made a while ago that downloads files from a set site:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>import urllib\nimport urllib2\nimport requests\n\nurl = 'http://www.blog.pythonlibrary.org/wpcontent/uploads/2012/06/wxDbViewer.zip'\n\nprint \"downloading with urllib\"\nurllib.urlretrieve(url, \"code.zip\")\n\nprint \"downloading with urllib2\"\nf = urllib2.urlopen(url)\ndata = f.read()\nwith open(\"code2.zip\", \"wb\") as code:\ncode.write(data)\n\nprint \"downloading with requests\"\nr = requests.get(url)\nwith open(\"code3.zip\", \"wb\") as code:\ncode.write(r.content)\n</code></pre>\n\n<p>The URLs in the code are not ones that I will be using; they are examples.</p>\n\n<p>If the Rust program sets the site it needs to go to as a variable, is there a way that I could send the variable to my Python program? I know you can send Python to Rust:</p>\n\n<p><a href=\"https://stackoverflow.com/questions/31074994/passing-a-list-of-strings-from-python-to-rust\">Passing a list of strings from Python to Rust</a></p>\n\n<p><a href=\"http://www.joesacher.com/blog/2017/08/24/ptr-types/\" rel=\"nofollow noreferrer\">http://www.joesacher.com/blog/2017/08/24/ptr-types/</a></p>\n\n<p>Is there a way to do this in the other direction? </p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 4, "creation_date": 1516219277, "post_id": 48308759, "comment_id": 83603673, "body": "Just to be clear: you need to access the <code>Vec&lt;T&gt;</code> as a <code>&amp;[U]</code>, <code>&amp;mut [U]</code>, or a <code>&amp;mut Vec&lt;U&gt;</code>?  (Hint: The slice alternatives are vastly simpler)."}, {"owner": {"reputation": 3489, "user_id": 1350184, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/EQnef.jpg?s=128&g=1", "display_name": "tversteeg", "link": "https://stackoverflow.com/users/1350184/tversteeg"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1516219678, "post_id": 48308759, "comment_id": 83603883, "body": "@bluss for my situation <code>&amp;mut [U]</code> would be acceptable although <code>&amp;mut Vec&lt;U&gt;</code> is preferable."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1516219808, "post_id": 48308759, "comment_id": 83603949, "body": "If <code>&amp;mut [U]</code> is acceptable, then <a href=\"https://stackoverflow.com/q/40006219/155423\">it&#39;s preferred over <code>&amp;mut Vec&lt;U&gt;</code></a>."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 1, "creation_date": 1516226954, "post_id": 48308759, "comment_id": 83607360, "body": "There was a time long long ago where <code>Vec</code> had a <code>fn map_in_place&lt;U, F&gt;(self, f: F) -&gt; Vec&lt;U&gt;</code> method, that would work when <code>T</code> and <code>U</code> were the same size. It was removed in Rust 1.4, but there seem to be a crate that does that. Probably overkill though in that case."}], "answers": [{"comments": [{"owner": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "edited": false, "score": 1, "creation_date": 1516265812, "post_id": 48309116, "comment_id": 83619911, "body": "<i>There is no guarantee that the two types will have the same size</i>. At least, this can be verified: <code>std::mem::size_of</code>."}, {"owner": {"reputation": 478030, "user_id": 279627, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/2dceea858ad8f1577bec6ddaa0485d15?s=128&d=identicon&r=PG", "display_name": "Sven Marnach", "link": "https://stackoverflow.com/users/279627/sven-marnach"}, "edited": false, "score": 0, "creation_date": 1552166036, "post_id": 48309116, "comment_id": 96909711, "body": "For a no-op in-place conversion, you don&#39;t need anything nearly as complex as the old <code>map_in_place()</code>. The reason for its complexity was mainly that it had to deal with the intermediate states when parts of the vector already have type <code>U</code> and the remainder still is type <code>T</code>. Getting this right even in the event of panics is quite involved. If the source and destination types have the same memory layout though, and you only want to <i>reinterpret</i> the memory as a different type, then this can be done relatively easily."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 13, "last_activity_date": 1583264590, "last_edit_date": 1583264590, "creation_date": 1516219359, "answer_id": 48309116, "question_id": 48308759, "link": "https://stackoverflow.com/questions/48308759/how-do-i-convert-a-vect-to-a-vecu-without-copying-the-vector/48309116#48309116", "title": "How do I convert a Vec&lt;T&gt; to a Vec&lt;U&gt; without copying the vector?", "body": "<p>You <em>cannot</em> change the type of a value in place in safe Rust. There is no guarantee that the two types will have the same size or the same semantics.</p>\n\n<p>This applies to a single value (<code>T</code> -> <code>U</code>) as well as aggregate values (<code>Vec&lt;T&gt;</code> -> <code>Vec&lt;U&gt;</code>, <code>HashMap&lt;K1, V1&gt;</code> -> <code>HashMap&lt;K2, V2&gt;</code>). Note that aggregate values are really just a special case of \"single\" values.</p>\n\n<hr>\n\n<p>The best thing to do is to create a new vector:</p>\n\n<pre><code>let buffer2 = buffer.into_iter().map(Foo).collect();\n</code></pre>\n\n<p>You could also adjust <code>do_something_using_foo</code> to take in a common generic type that both <code>Foo</code> and <code>u32</code> implement:</p>\n\n<pre><code>use std::borrow::{Borrow, BorrowMut};\n\n#[derive(Debug, Clone)]\nstruct Foo(u32);\n\nimpl Borrow&lt;u32&gt; for Foo {\n    fn borrow(&amp;self) -&gt; &amp;u32 {\n        &amp;self.0\n    }\n}\n\nimpl BorrowMut&lt;u32&gt; for Foo {\n    fn borrow_mut(&amp;mut self) -&gt; &amp;mut u32 {\n        &amp;mut self.0\n    }\n}\n\nfn do_something_using_foo&lt;T&gt;(buffer: &amp;mut [T])\nwhere\n    T: BorrowMut&lt;u32&gt;,\n{\n}\n\nfn main() {\n    let mut buffer_u32 = vec![0u32; 100];\n    let mut buffer_foo = vec![Foo(0); 100];\n\n    do_something_using_foo(&amp;mut buffer_u32);\n    do_something_using_foo(&amp;mut buffer_foo);\n}\n</code></pre>\n\n<hr>\n\n<p>In unsafe Rust, it is technically possible \u2014 you can shoot yourself in the foot as much as you'd like.</p>\n\n<p>You can use something like <a href=\"https://doc.rust-lang.org/std/mem/fn.transmute.html\" rel=\"nofollow noreferrer\"><code>std::mem::transmute</code></a> if you know what you are doing. </p>\n\n<p>However, it's undefined behavior to use <code>transmute</code> with <code>Vec</code> as the representation of <code>Vec</code> is not defined. Instead, see <a href=\"https://stackoverflow.com/a/55081958/155423\">Sven Marnach's answer</a>.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/30026893/155423\">Using map with Vectors</a></li>\n<li><a href=\"https://stackoverflow.com/q/49690459/155423\">Converting a Vec&lt;u32&gt; to Vec&lt;u8&gt; in-place and with minimal overhead</a></li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 478030, "user_id": 279627, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/2dceea858ad8f1577bec6ddaa0485d15?s=128&d=identicon&r=PG", "display_name": "Sven Marnach", "link": "https://stackoverflow.com/users/279627/sven-marnach"}, "is_accepted": false, "score": 11, "last_activity_date": 1573070815, "last_edit_date": 1573070815, "creation_date": 1552165679, "answer_id": 55081958, "question_id": 48308759, "link": "https://stackoverflow.com/questions/48308759/how-do-i-convert-a-vect-to-a-vecu-without-copying-the-vector/55081958#55081958", "title": "How do I convert a Vec&lt;T&gt; to a Vec&lt;U&gt; without copying the vector?", "body": "<p>According to the <a href=\"https://doc.rust-lang.org/std/mem/fn.transmute.html\" rel=\"nofollow noreferrer\">documentation of <code>std::mem::transmute()</code></a>, using <code>Vec::from_raw_parts</code> combined with <code>ManuallyDrop</code> is the best option, as of Rust 1.38:</p>\n\n<pre><code>let v_from_raw = unsafe {\n    // Ensure the original vector is not dropped.\n    let mut v_clone = std::mem::ManuallyDrop::new(v_orig);\n    Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut U,\n                        v_clone.len(),\n                        v_clone.capacity())\n};\n</code></pre>\n\n<p>The prerequisite for this is that <code>T</code> and <code>U</code> have the same size, the same minimum alignment and that all bit patterns that are valid for <code>T</code> are also valid for <code>U</code>. If you define <code>T</code> and <code>U</code> as in your question, you don't have a guarantee for this.</p>\n\n<p><code>struct U(T)</code> defines a tuple struct, and the memory layout of such a struct is completely undefined. However, it is possible to force the memory representations to be identical by using <a href=\"https://doc.rust-lang.org/reference/type-layout.html#the-transparent-representation\" rel=\"nofollow noreferrer\">the <code>transparent</code> representation</a>:</p>\n\n<pre><code>#[repr(transparent)]\nstruct U(T);\n</code></pre>\n\n<h1>Future possibilities</h1>\n\n<p>Nightly Rust has <a href=\"https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.into_raw_parts\" rel=\"nofollow noreferrer\"><code>Vec::into_raw_parts</code></a>, which reduces the amount of code and places to go wrong:</p>\n\n<pre><code>#![feature(vec_into_raw_parts)]\n\nfn convert_using_into_raw_parts(v: Vec&lt;T&gt;) -&gt; Vec&lt;U&gt; {\n    let (ptr, len, cap) = v.into_raw_parts();\n    unsafe { Vec::from_raw_parts(ptr as *mut U, len, cap) }\n}\n</code></pre>\n\n<p>There's also an open RFC <a href=\"https://github.com/rust-lang/rfcs/pull/2756\" rel=\"nofollow noreferrer\">Collection Transmute #2756</a> which proposes adding a <code>Vec::transmute</code> method.</p>\n"}], "owner": {"reputation": 3489, "user_id": 1350184, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/EQnef.jpg?s=128&g=1", "display_name": "tversteeg", "link": "https://stackoverflow.com/users/1350184/tversteeg"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2674, "favorite_count": 1, "accepted_answer_id": 48309116, "answer_count": 2, "score": 11, "last_activity_date": 1583264590, "creation_date": 1516218016, "last_edit_date": 1516219620, "question_id": 48308759, "link": "https://stackoverflow.com/questions/48308759/how-do-i-convert-a-vect-to-a-vecu-without-copying-the-vector", "title": "How do I convert a Vec&lt;T&gt; to a Vec&lt;U&gt; without copying the vector?", "body": "<p>I want to convert a <code>Vec&lt;T&gt;</code> to a <code>Vec&lt;U&gt;</code> where <code>T</code> is a primitive of some sort and <code>U</code> is a newtype of <code>T</code>: <code>struct U(T)</code>. </p>\n\n<p>I tried something like this:</p>\n\n<pre><code>struct Foo(u32);\n\nfn do_something_using_foo(buffer: &amp;mut Vec&lt;Foo&gt;) {}\n\nfn main() {\n    let buffer: Vec&lt;u32&gt; = vec![0; 100];\n\n    do_something_using_foo(&amp;mut buffer as Vec&lt;Foo&gt;);\n}\n</code></pre>\n\n<p>I don't want to make a copy of the vector, I want to wrap the <code>u32</code> fields in the newtype <code>Foo</code>.</p>\n\n<p>This gives the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; main.rs:8:28\n  |\n8 |     do_something_using_foo(&amp;mut buffer as Vec&lt;Foo&gt;);\n  |                            ^^^^^^^^^^^^^^^^^^^^^^^ expected mutable reference, found struct `std::vec::Vec`\n  |\n  = note: expected type `&amp;mut std::vec::Vec&lt;Foo&gt;`\n         found type `std::vec::Vec&lt;Foo&gt;`\n  = help: try with `&amp;mut &amp;mut buffer as Vec&lt;Foo&gt;`\n\nerror: non-scalar cast: `&amp;mut std::vec::Vec&lt;u32&gt;` as `std::vec::Vec&lt;Foo&gt;`\n --&gt; main.rs:8:28\n  |\n8 |     do_something_using_foo(&amp;mut buffer as Vec&lt;Foo&gt;);\n  |                            ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error(s)\n</code></pre>\n"}, {"tags": ["generics", "recursion", "rust", "traits", "toml"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516213272, "post_id": 48306882, "comment_id": 83600487, "body": "Probably a duplicate of <a href=\"https://stackoverflow.com/q/46805540/155423\">Is it possible to compose a chain of functions at runtime?</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516213448, "post_id": 48306882, "comment_id": 83600606, "body": "See also <a href=\"https://stackoverflow.com/q/48288640/155423\">Generic struct with a reference to the same type but with any concrete type</a> which avoids the recursive issue."}], "answers": [{"tags": [], "owner": {"reputation": 3583, "user_id": 1391026, "user_type": "registered", "accept_rate": 53, "profile_image": "https://www.gravatar.com/avatar/af98bdbeea8772f2d90d47d507098256?s=128&d=identicon&r=PG", "display_name": "musicmatze", "link": "https://stackoverflow.com/users/1391026/musicmatze"}, "is_accepted": false, "score": 2, "last_activity_date": 1516218133, "last_edit_date": 1516218133, "creation_date": 1516217162, "answer_id": 48308567, "question_id": 48306882, "link": "https://stackoverflow.com/questions/48306882/chainable-queries-on-toml-documents/48308567#48308567", "title": "Chainable Queries on TOML documents", "body": "<p>The whole approach for the problem was wrong. I implemented it the following way:</p>\n\n<ul>\n<li>The <code>Query</code> trait provides a function for chaining queries. That function returns a <code>Chain</code>.</li>\n<li>The <code>Chain</code> type implements <code>Query</code> by executing the first element and passing the result (if <code>Ok</code>) to the second query.</li>\n</ul>\n\n<p>Using this the problem can be solved:</p>\n\n<pre><code>use std::marker::PhantomData;\n\nuse toml::Value;\nuse error::Result;\n\npub trait Query&lt;Prev&gt;\nwhere\n    Prev: Sized,\n    Self: Sized,\n{\n    type Output: Sized;\n\n    fn execute(&amp;self, target: &amp;mut Value, prev_result: Option&lt;Prev&gt;) -&gt; Result&lt;Self::Output&gt;;\n\n    fn chain&lt;Q&gt;(self, other: Q) -&gt; Chain&lt;Self, Prev, Q&gt;\n    where\n        Q: Query&lt;Self::Output&gt;,\n    {\n        Chain {\n            first: self,\n            _p: PhantomData,\n            second: other,\n        }\n    }\n}\n\npub struct Chain&lt;A, P, B&gt;\nwhere\n    A: Query&lt;P&gt;,\n    B: Query&lt;A::Output&gt;,\n    P: Sized,\n{\n    first: A,\n    _p: PhantomData&lt;P&gt;,\n    second: B,\n}\n\nimpl&lt;A, P, B&gt; Query&lt;P&gt; for Chain&lt;A, P, B&gt;\nwhere\n    A: Query&lt;P&gt;,\n    B: Query&lt;A::Output&gt;,\n    P: Sized,\n{\n    type Output = B::Output;\n\n    fn execute(&amp;self, target: &amp;mut Value, prev_result: Option&lt;P&gt;) -&gt; Result&lt;Self::Output&gt; {\n        let p = self.first.execute(target, prev_result)?;\n        self.second.execute(target, Some(p))\n    }\n}\n\npub trait QueryExecutor {\n    fn query&lt;Q, T&gt;(&amp;mut self, q: &amp;Q) -&gt; Result&lt;Q::Output&gt;\n    where\n        Q: Query&lt;T&gt;;\n}\n\nimpl QueryExecutor for Value {\n    fn query&lt;Q, T&gt;(&amp;mut self, q: &amp;Q) -&gt; Result&lt;Q::Output&gt;\n    where\n        Q: Query&lt;T&gt;,\n    {\n        q.execute(self, None as Option&lt;T&gt;)\n    }\n}\n</code></pre>\n\n<p>(full code including tests <a href=\"https://github.com/matthiasbeyer/toml-query/pull/28/files#diff-944604969255b8318a6691f5120f0df8\" rel=\"nofollow noreferrer\">here</a>)</p>\n"}], "owner": {"reputation": 3583, "user_id": 1391026, "user_type": "registered", "accept_rate": 53, "profile_image": "https://www.gravatar.com/avatar/af98bdbeea8772f2d90d47d507098256?s=128&d=identicon&r=PG", "display_name": "musicmatze", "link": "https://stackoverflow.com/users/1391026/musicmatze"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 52, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1516218133, "creation_date": 1516210462, "last_edit_date": 1516213217, "question_id": 48306882, "link": "https://stackoverflow.com/questions/48306882/chainable-queries-on-toml-documents", "title": "Chainable Queries on TOML documents", "body": "<p>I'm trying to implement a chainable query execution for TOML documents.</p>\n\n<p>A <code>Query</code> is a thing that changes a TOML document and might return another <code>Query</code> object which shall be executed after itself. A <code>Query</code> which is executed gets the result of the previous query (if any).</p>\n\n<p>The problem is that the return types are generic. A query might return a <code>Vec&lt;i64&gt;</code>, but its successor might return a <code>String</code> ... thus, the return type of one <code>Query</code> depends directly on the return type of its successor.</p>\n\n<p>Here's my code so far:</p>\n\n<pre><code>extern crate either;\nextern crate toml;\n\nuse either::Either;\nuse toml::Value;\n\ntype Result&lt;T&gt; = ::std::result::Result&lt;T, ()&gt;; // for simplicity\n\npub trait Query&lt;Prev&gt;\nwhere\n    Prev: Sized,\n    Self: Sized,\n{\n    type Output: Sized;\n    type Next: Query&lt;Self::Output&gt;;\n\n    fn execute(&amp;self, target: &amp;mut Value, prev_result: Option&lt;Prev&gt;) -&gt; Result&lt;Self::Output&gt;;\n\n    fn next(self) -&gt; Option&lt;Self::Next&gt;;\n}\n\nfn execute_query&lt;Q, Prev&gt;(\n    doc: &amp;mut Value,\n    query: &amp;Q,\n    prev_result: Option&lt;Prev&gt;,\n) -&gt; Result&lt;Either&lt;Q::Output, &lt;Q::Next as Query&lt;Q::Output&gt;&gt;::Output&gt;&gt;\nwhere\n    Q: Query&lt;Prev&gt;,\n{\n    let result = query.execute(doc, prev_result)?;\n\n    if let Some(next_query) = query.next() {\n        let next_result: &lt;Q::Next as Query&lt;Q::Output&gt;&gt;::Output =\n            match execute_query(doc, &amp;next_query, Some(result)) {\n                Ok(Either::Left(t)) =&gt; t,\n                Ok(Either::Right(t)) =&gt; return Ok(Either::Right(t)), // error happens here\n                Err(e) =&gt; return Err(e),\n            };\n\n        Ok(Either::Right(next_result))\n    } else {\n        Ok(Either::Left(result))\n    }\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=02245c0818e563107ed8c3b2f84caeae&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a>)</p>\n\n<p>The error is that the return type is recursive (as the whole problem is recursive):</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:37:65\n   |\n37 |                 Ok(Either::Right(t)) =&gt; return Ok(Either::Right(t)), // error happens here\n   |                                                                 ^ expected type parameter, found associated type\n   |\n   = note: expected type `&lt;&lt;Q as Query&lt;Prev&gt;&gt;::Next as Query&lt;&lt;Q as Query&lt;Prev&gt;&gt;::Output&gt;&gt;::Output`\n              found type `&lt;&lt;&lt;Q as Query&lt;Prev&gt;&gt;::Next as Query&lt;&lt;Q as Query&lt;Prev&gt;&gt;::Output&gt;&gt;::Next as Query&lt;&lt;&lt;Q as Query&lt;Prev&gt;&gt;::Next as Query&lt;&lt;Q as Query&lt;Prev&gt;&gt;::Output&gt;&gt;::Output&gt;&gt;::Output`\n</code></pre>\n\n<hr>\n\n<p>The title is not very expressive. I'm sorry about that, I don't know how to describe better.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516198373, "post_id": 48302817, "comment_id": 83590904, "body": "TL;DR the duplicates: It&#39;s now ambiguous what code should be invoked when you call <code>From::from(MyClass)</code> \u2014 should it be the code in this crate of the blanket implementation from the standard library. This ambiguity is not allowed."}, {"owner": {"reputation": 2227, "user_id": 1037094, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/7949edc53b97713ab2030bffa38b3610?s=128&d=identicon&r=PG", "display_name": "Manuel Schmidt", "link": "https://stackoverflow.com/users/1037094/manuel-schmidt"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516203684, "post_id": 48302817, "comment_id": 83594609, "body": "But if I remove my AsRef, I cannot call From on my class. So there is NO implementation left, if remove mine."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516205604, "post_id": 48302817, "comment_id": 83595928, "body": "<i>there is NO implementation left, if remove mine.</i> \u2014 sure there is: <a href=\"https://doc.rust-lang.org/std/convert/trait.From.html\" rel=\"nofollow noreferrer\"><code>impl&lt;T&gt; From&lt;T&gt; for T</code></a>. That&#39;s the one that the compiler is telling you about: <i><code>note: conflicting implementation in crate `core`:            - impl&lt;T&gt; std::convert::From&lt;T&gt; for T;</code></i>"}], "owner": {"reputation": 2227, "user_id": 1037094, "user_type": "registered", "accept_rate": 72, "profile_image": "https://www.gravatar.com/avatar/7949edc53b97713ab2030bffa38b3610?s=128&d=identicon&r=PG", "display_name": "Manuel Schmidt", "link": "https://stackoverflow.com/users/1037094/manuel-schmidt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 345, "favorite_count": 0, "closed_date": 1516197639, "answer_count": 0, "score": 0, "last_activity_date": 1516198051, "creation_date": 1516197272, "last_edit_date": 1516197601, "question_id": 48302817, "link": "https://stackoverflow.com/questions/48302817/conflicting-implementations-with-asref-and-from-implementation", "closed_reason": "Duplicate", "title": "conflicting implementations with AsRef and From implementation", "body": "<p><code>MyClass</code> is just a byte array. Since  I want flexible conversions to and from <code>MyClass</code>, I implemented <code>From</code>  as <code>From&lt;T&gt; for MyClass where T: AsRef&lt;[u8]&gt;</code>. This works, but as soon as I implement the corresponding <code>AsRef&lt;[u8]&gt; for MyClass</code> I get an \"conflicting implementations\" error.</p>\n\n<pre><code>use std::convert::{AsRef, From};\n\nconst MY_SIZE: usize = 32;\n\npub struct MyClass(pub [u8; MY_SIZE]);\n\nimpl AsRef&lt;[u8]&gt; for MyClass {\n    fn as_ref(&amp;self) -&gt; &amp;[u8] {\n        &amp;self.0\n    }\n}\n\nimpl&lt;T&gt; From&lt;T&gt; for MyClass\nwhere\n    T: AsRef&lt;[u8]&gt;,\n{\n    fn from(byteable: T) -&gt; Self {\n        let bytes: &amp;[u8] = byteable.as_ref();\n        assert_eq!(bytes.len(), MY_SIZE);\n        let mut dst: [u8; MY_SIZE] = [0; MY_SIZE];\n        dst.copy_from_slice(&amp;bytes);\n        MyClass(dst)\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0119]: conflicting implementations of trait `std::convert::From&lt;MyClass&gt;` for type `MyClass`:\n  --&gt; src/main.rs:13:1\n   |\n13 | / impl&lt;T&gt; From&lt;T&gt; for MyClass\n14 | | where\n15 | |     T: AsRef&lt;[u8]&gt;,\n16 | | {\n...  |\n23 | |     }\n24 | | }\n   | |_^\n   |\n   = note: conflicting implementation in crate `core`:\n           - impl&lt;T&gt; std::convert::From&lt;T&gt; for T;\n</code></pre>\n\n<p>Can I avoid the error or is there a better way to design this library?</p>\n"}, {"tags": ["reference", "rust", "pass-by-reference"], "owner": {"reputation": 68, "user_id": 9229623, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5ad087efc399b11bf64c035265b28e30?s=128&d=identicon&r=PG&f=1", "display_name": "Steranoid", "link": "https://stackoverflow.com/users/9229623/steranoid"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 29, "favorite_count": 0, "closed_date": 1516197219, "answer_count": 0, "score": 1, "last_activity_date": 1516195210, "creation_date": 1516195210, "question_id": 48302157, "link": "https://stackoverflow.com/questions/48302157/reference-to-value", "closed_reason": "Duplicate", "title": "Reference to value", "body": "<p>I have an issue concerning the way references behave in rust :\nI made an example to show my misunderstanding, of course there is a much simpler version of the function, this is not the point, the point is the behaviour of references in Rust.</p>\n\n<p>Consider these five following functions :</p>\n\n<p>This code compile perfectly</p>\n\n<pre><code>fn add2(parameter : &amp;isize) -&gt; isize {\n    let a : isize = parameter + 2;\n    a\n}\n</code></pre>\n\n<p>This code don't compile : mismatched type, expected isize, found &amp;isize</p>\n\n<pre><code>fn add2(parameter : &amp;isize) -&gt; isize {\n    let a : isize = parameter;\n    a + 2\n}\n</code></pre>\n\n<p>This code don't compile either : casting &amp;isize as isize is invalid cannot cast &amp;isize as isize (well, I expected it here)</p>\n\n<pre><code>fn add2(parameter : &amp;isize) -&gt; isize {\n    let a : isize = parameter as isize;\n    a + 2\n}\n</code></pre>\n\n<p>This code compile</p>\n\n<pre><code>fn add2(parameter : &amp;isize) -&gt; isize {\n    let a : isize = *parameter;\n    a + 2\n}\n</code></pre>\n\n<p>And finally, this code compile too</p>\n\n<pre><code>fn add2(parameter : &amp;isize) -&gt; isize {\n    let a : isize = *parameter + 2;\n    a\n}\n</code></pre>\n\n<p>So my questions are :</p>\n\n<ul>\n<li>Why is the first one compiling if the second one does not ? (operator+ overload for references ?)</li>\n<li>Why auto-dereference mecanism doesn't work on the second one ? (and on the third one)</li>\n</ul>\n"}, {"tags": ["network-programming", "rust", "udp"], "comments": [{"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 0, "creation_date": 1516178656, "post_id": 48294831, "comment_id": 83578197, "body": "This is a problem for C as well: <a href=\"http://www.microhowto.info/howto/listen_for_and_receive_udp_datagrams_in_c.html\" rel=\"nofollow noreferrer\">microhowto.info/howto/&hellip;</a>"}, {"owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 0, "creation_date": 1516179667, "post_id": 48294831, "comment_id": 83578789, "body": "Temporarily getting 65k of uninitialized memory from stack shouldn&#39;t be a big deal."}, {"owner": {"reputation": 743, "user_id": 3999297, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/UrT5t.png?s=128&g=1", "display_name": "Lukor", "link": "https://stackoverflow.com/users/3999297/lukor"}, "reply_to_user": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 0, "creation_date": 1516192049, "post_id": 48294831, "comment_id": 83586713, "body": "@ArtemGr it probably isn&#39;t, but why would I allocate that much if I could just grow only if I need the space? because most packets are probably only a few bytes long"}, {"owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 1, "creation_date": 1516192478, "post_id": 48294831, "comment_id": 83587013, "body": "@Lukor Because extra system calls are much more expensive than getting some space from the stack."}, {"owner": {"reputation": 743, "user_id": 3999297, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/UrT5t.png?s=128&g=1", "display_name": "Lukor", "link": "https://stackoverflow.com/users/3999297/lukor"}, "reply_to_user": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "edited": false, "score": 0, "creation_date": 1516192609, "post_id": 48294831, "comment_id": 83587104, "body": "@ArtemGr okay, I guess that makes sense, thank you"}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1516201186, "post_id": 48302666, "comment_id": 83592783, "body": "I would use the word <i>pool</i> instead of <i>magazine</i> here; is there a specific connotation to magazine I am not aware of that would make it a better fit? Were you thinking about a machine gun maybe?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1516201486, "post_id": 48302666, "comment_id": 83592994, "body": "@MatthieuM. changed. Magazine is kind of an obscure term I have stuck in my head for whatever reason, but I didn&#39;t make it up. See <a href=\"http://www.parrot.org/sites/www.parrot.org/files/vmem.pdf\" rel=\"nofollow noreferrer\"><i>Magazines and Vmem: Extending the Slab Allocator to Many CPUs and Arbitrary Resources</i></a> and <a href=\"https://books.google.com/books?id=r_cecYD4AKkC&amp;pg=PA226&amp;lpg=PA226&amp;dq=memory+magazine+layer&amp;source=bl&amp;ots=oEpjeYtAAQ&amp;sig=4NV4OoA5kr9skdyppUSFgNFiB9w&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwiw07KNot_YAhVEUKwKHSr7C18Q6AEIVTAK#v=onepage&amp;q=memory%20magazine%20layer&amp;f=false\" rel=\"nofollow noreferrer\"><i>Solaris Internals: Core Kernel Components</i></a>."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1516202150, "last_edit_date": 1516202150, "creation_date": 1516196826, "answer_id": 48302666, "question_id": 48294831, "link": "https://stackoverflow.com/questions/48294831/how-do-i-receive-arbitrary-length-data-using-a-udpsocket/48302666#48302666", "title": "How do I receive arbitrary length data using a UdpSocket?", "body": "<p>Check out the next method in the docs, <a href=\"https://doc.rust-lang.org/std/net/struct.UdpSocket.html#method.peek_from\" rel=\"nofollow noreferrer\"><code>UdpSocket::peek_from</code></a> (emphasis mine):</p>\n\n<blockquote>\n  <p>Receives a single datagram message on the socket, <strong>without removing it from the queue</strong>.</p>\n</blockquote>\n\n<p>You can use this to read a fixed amount of data, such as the leading 4 bytes containing the length of the entire packet. You can use <a href=\"https://crates.io/crates/byteorder\" rel=\"nofollow noreferrer\">byteorder</a> to get the length as a number then allocate exactly the right amount of space and call <code>recv_from</code>.</p>\n\n<hr>\n\n<p>Now, is this a good idea? </p>\n\n<p>As <a href=\"https://stackoverflow.com/questions/48294831/how-do-i-receive-arbitrary-length-data-using-a-udpsocket/48302666#comment83587013_48294831\">ArtemGr states</a>:</p>\n\n<blockquote>\n  <p>Because extra system calls are much more expensive than getting some space from the stack. </p>\n</blockquote>\n\n<p>And from <a href=\"https://stackoverflow.com/a/8003202/155423\">the linked question</a>:</p>\n\n<blockquote>\n  <p>Obviously at some point you will start wondering if doubling the number of system calls to save memory is worth it. I think it isn't.</p>\n</blockquote>\n\n<p>With the recent Spectre / Meltdown events, now's a pretty good time to be be reminded to avoid extra syscalls.</p>\n\n<p>You could, as suggested, just allocate a \"big enough\" array ahead of time. You'll need to track how many bytes you've actually read vs allocated though. I recommend something like <a href=\"https://crates.io/crates/arrayvec\" rel=\"nofollow noreferrer\">arrayvec</a> to make it easier.</p>\n\n<p>You could instead implement a pool of pre-allocated buffers on the heap. When you read from the socket, you use a buffer or create a new one. When you are done with the buffer, you put it back in the pool for reuse. That way, you incur the memory allocation once and are only passing around small <code>Vec</code>s on the stack.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/29239586/155423\">How can I create a stack-allocated vector-like container?</a></li>\n<li><a href=\"https://stackoverflow.com/q/2862071/155423\">How large should my recv buffer be when calling recv in the socket library</a></li>\n<li><a href=\"https://stackoverflow.com/q/8003170/155423\">How to read UDP packet with variable length in C</a></li>\n</ul>\n"}], "owner": {"reputation": 743, "user_id": 3999297, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/UrT5t.png?s=128&g=1", "display_name": "Lukor", "link": "https://stackoverflow.com/users/3999297/lukor"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 361, "favorite_count": 0, "accepted_answer_id": 48302666, "answer_count": 1, "score": 2, "last_activity_date": 1516202150, "creation_date": 1516170430, "last_edit_date": 1516196649, "question_id": 48294831, "link": "https://stackoverflow.com/questions/48294831/how-do-i-receive-arbitrary-length-data-using-a-udpsocket", "title": "How do I receive arbitrary length data using a UdpSocket?", "body": "<p>I am writing an application which sends and receives packages using UDP. However, the <a href=\"https://doc.rust-lang.org/std/net/struct.UdpSocket.html#method.recv_from\" rel=\"nofollow noreferrer\">documentation of <code>recv_from</code></a> states:</p>\n\n<blockquote>\n  <p>If a message is too long to fit in the supplied buffer, excess bytes may be discarded.</p>\n</blockquote>\n\n<p>Is there any way to receive all bytes and write them into a vector? Do I really have to allocate an array with the maximum packet length (which, as far as I know, is 65,507 bytes for IPv4) in order to be sure to receive all data? That seems a bit much for me.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516199376, "post_id": 48294707, "comment_id": 83591598, "body": "<i>and I know Rust isn&#39;t really OO</i> \u2014 citation required. If you think that &quot;OO&quot; means &quot;has inheritance&quot;, there&#39;s a lot of programmers that would like to have a word with you."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516199924, "post_id": 48294707, "comment_id": 83591959, "body": "The question doesn&#39;t even attempt to show what the desired &quot;inheritance&quot; <i>is</i>. All that&#39;s been presented is code that doesn&#39;t even compile."}], "answers": [{"tags": [], "owner": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "is_accepted": false, "score": 2, "last_activity_date": 1516199528, "last_edit_date": 1516199528, "creation_date": 1516180658, "answer_id": 48297450, "question_id": 48294707, "link": "https://stackoverflow.com/questions/48294707/how-can-i-re-organize-my-structures-and-traits-to-have-a-base-behavior-and-a-con/48297450#48297450", "title": "How can I re-organize my structures and traits to have a base behavior and a container of inherited behaviors?", "body": "<p>The question is quite generic but as a general answer: if you want to replace an inheritance mechanism, do some composition:</p>\n\n<pre><code>struct Thing {\n    stuff: i32,\n    extension: Box&lt;ThingExtension&gt;,\n}\n\nimpl Thing {\n    fn new(stuff: i32, extension: Box&lt;ThingExtension&gt;) -&gt; Self {\n        Thing { stuff, extension }\n    }\n}\n\ntrait ThingExtension {\n    fn do_something(&amp;self, stuff: i32);\n}\n</code></pre>\n\n<p>This snippet is self-understandable: the user will implement the <code>ThingExtension</code> trait to build a real <code>Thing</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 339, "user_id": 9210924, "user_type": "registered", "profile_image": "https://lh6.googleusercontent.com/-4wYHrjZFWfw/AAAAAAAAAAI/AAAAAAAAAEs/Ql3GeOp43dk/photo.jpg?sz=128", "display_name": "Daniel Wilkins", "link": "https://stackoverflow.com/users/9210924/daniel-wilkins"}, "is_accepted": false, "score": 1, "last_activity_date": 1516199061, "last_edit_date": 1516199061, "creation_date": 1516193691, "answer_id": 48301713, "question_id": 48294707, "link": "https://stackoverflow.com/questions/48294707/how-can-i-re-organize-my-structures-and-traits-to-have-a-base-behavior-and-a-con/48301713#48301713", "title": "How can I re-organize my structures and traits to have a base behavior and a container of inherited behaviors?", "body": "<p>Boiethios is right in that you should use composition. I wanted to give you a more specific example related to what you are trying to accomplish. In Rust, inheritance doesn't exist so we use composition to accomplish the task of having different structures that need the same functionality.</p>\n\n<p>It starts with a trait, in your case that looks something like this</p>\n\n<pre><code>trait Scene {\n    fn is_active(&amp;self) -&gt; bool;\n    fn is_ready(&amp;self) -&gt; bool;\n    fn start(&amp;mut self);\n    fn update(&amp;mut self);\n    fn stop(&amp;mut self);\n}\n</code></pre>\n\n<p>This scene trait can now be used to create a <code>SceneBase</code> struct</p>\n\n<pre><code>struct SceneBase {\n    active: bool,\n    ready: bool,\n}\n\nimpl SceneBase {\n    fn new() -&gt; SceneBase {\n        SceneBase {\n            active: false,\n            ready: false,\n        }\n    }\n}\n\nimpl Scene for SceneBase {\n    fn is_active(&amp;self) -&gt; bool {\n        self.active\n    }\n\n    fn is_ready(&amp;self) -&gt; bool {\n        self.ready\n    }\n\n    fn start(&amp;mut self) {\n        self.active = true;\n    }\n\n    fn update(&amp;mut self) {\n        println!(\"scene update.\");\n        self.ready = true;\n    }\n\n    fn stop(&amp;mut self) {\n        self.ready = false;\n        self.active = false;\n    }\n}\n</code></pre>\n\n<p>We have declared the trait <code>Scene</code> and implemented it for <code>SceneBase</code>. We use <strong>composition</strong> to add the same functionality to the <code>MySceneOne</code> and <code>MySceneTwo</code> structures:</p>\n\n<pre><code>struct MySceneOne {\n    scene: Box&lt;Scene&gt;,\n}\n\nstruct MySceneTwo {\n    scene: Box&lt;Scene&gt;,\n}\n</code></pre>\n\n<p>The other part of this is using the functionality that we provided. We  create another trait that retrieves the <code>Scene</code> for us and implement it for our scenes:</p>\n\n<pre><code>trait GetScene {\n    fn get_scene(&amp;mut self) -&gt; &amp;mut Scene;\n}\n\nimpl GetScene for MySceneOne {\n    fn get_scene(&amp;mut self) -&gt; &amp;mut Scene {\n        &amp;mut *self.scene\n    }\n}\n</code></pre>\n\n<p>Now we can add our scenes generically in a collection. Here I use a <code>Vec</code> but you could create your own that provides the container functionality you are looking for.</p>\n\n<pre><code>let mut v: Vec&lt;Box&lt;GetScene&gt;&gt; = Vec::new();\nlet my_scene = MySceneOne {\n    scene: Box::new(SceneBase::new())\n};\nlet my_other_scene = MySceneTwo {\n    scene: Box::new(SceneBase::new())\n};\n\nv.push(Box::new(my_scene));\nv.push(Box::new(my_other_scene));\n</code></pre>\n\n<p>Next we want to use our scenes so we make a function that takes a <code>GetScene</code> and then does something with the scene in this case the update.</p>\n\n<pre><code>fn update_scene(b: &amp;mut Box&lt;GetScene&gt;) {\n    let scene = b.get_scene();\n    scene.update();\n}\n</code></pre>\n\n<p>After we have our function we can now call it for the scenes we have in our <code>Vec</code>.</p>\n\n<pre><code>for scene in v.iter_mut() {\n    update_scene(scene);\n}\n</code></pre>\n\n<p>For a complete example I created this <a href=\"https://play.rust-lang.org/?gist=500b870ca17fc60d01208c901f54fee5&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a></p>\n"}, {"tags": [], "owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "is_accepted": true, "score": 1, "last_activity_date": 1516199311, "last_edit_date": 1516199311, "creation_date": 1516195398, "answer_id": 48302223, "question_id": 48294707, "link": "https://stackoverflow.com/questions/48294707/how-can-i-re-organize-my-structures-and-traits-to-have-a-base-behavior-and-a-con/48302223#48302223", "title": "How can I re-organize my structures and traits to have a base behavior and a container of inherited behaviors?", "body": "<p>You are on the right track: if you want common implementation then you have to stick with traits.</p>\n\n<p>Let's look at you code: </p>\n\n<ul>\n<li>Right off the bat, you can't have <code>SceneBase</code> as the name for both a trait and a struct. </li>\n<li>methods on traits that modify itself or return a property have to have <code>&amp;mut self</code> or <code>&amp;self</code> respectively.</li>\n<li>Your <code>SceneBase::new()</code> returns <code>Self</code>. That's not compatible with using trait objects i.e. <code>Box&lt;SceneBase&gt;</code> (<a href=\"https://doc.rust-lang.org/error-index.html#E0038\" rel=\"nofollow noreferrer\">see this</a> for more info). There are two ways to deal with it - move the <code>new</code> method to the <code>impl</code> and lose access to it via trait interface or make it a generic object.</li>\n<li>Your method <code>fn new(scene: SceneBase) -&gt; Self</code> also wants to construct new as if it was a trait object.</li>\n</ul>\n\n<p>With that in mind, let's go over your initial examples line by line. <code>struct SceneBase</code> is renamed to <code>struct SceneBasic</code>, to avoid conflict with the trait name, same was done for <code>SceneContainer</code>, etc.</p>\n\n<p><code>SceneBase</code> becomes:</p>\n\n<pre><code>trait SceneBase {\n    fn new() -&gt; Self;\n    fn is_active(&amp;self) -&gt; bool;\n    fn is_ready(&amp;self) -&gt; bool;\n    fn start(&amp;mut self);\n    fn update(&amp;mut self);\n    fn stop(&amp;mut self);\n}\n</code></pre>\n\n<p>The names in Rust are <code>snake_case</code>, not <code>pascalCase</code>. You also need to tell what methods modify or don't modify the struct.</p>\n\n<p>Next up, we implement <code>SceneBase</code> for <code>struct SceneBasic</code>, because our traits are useless unless something implements them.</p>\n\n<pre><code>impl SceneBase for SceneBasic {\n    fn new() -&gt; SceneBasic {\n        SceneBasic {\n            active: false,\n            is_ready: false,\n        }\n    }\n    fn is_active(&amp;self) -&gt; bool {\n        self.active\n    }\n    fn is_ready(&amp;self) -&gt; bool{\n        self.is_ready\n    }\n    fn start(&amp;mut self){\n        self.active = true;\n    }\n    fn update(&amp;mut self) {\n        // Some implementation\n    }\n    fn stop(&amp;mut self) {\n        self.active = false;\n    }\n}\n</code></pre>\n\n<p>Next up, let's rewrite <code>SceneContainer</code> so it no longer uses trait objects</p>\n\n<pre><code>#[derive(Debug)]\nstruct BasicSceneContainer&lt;T: SceneBase&gt; {\n    container: T, // or Box&lt;T&gt; if that's what's really needed\n}\n</code></pre>\n\n<p>Using generic <code>&lt;T: SceneBase&gt;</code> means that for every type that implements <code>SceneBase</code> there will be new kind of <code>BasicSceneContainer</code> created (for more detail see <a href=\"https://stackoverflow.com/questions/14189604/what-is-monomorphisation-with-context-to-c\">What is monomorphisation with context to C++?</a>).</p>\n\n<p>Finally, with all this given, we can rewrite <code>SceneContainer</code>:</p>\n\n<pre><code>trait SceneContainer&lt;T: SceneBase&gt; {\n    fn new(scene: T) -&gt; Self;\n    fn update_children(&amp;mut self);\n    fn pop(&amp;mut self);\n}\n\nimpl&lt;T: SceneBase&gt; SceneContainer&lt;T&gt; for BasicSceneContainer&lt;T&gt; {\n    fn new(scene: T) -&gt; BasicSceneContainer&lt;T&gt; {\n        BasicSceneContainer {\n            container: scene\n        }\n    }\n    fn update_children(&amp;mut self) {\n        self.container.update();\n    }\n    fn pop(&amp;mut self) {\n        // pop the container\n    }\n}\n</code></pre>\n\n<p>Let's say we want to \"extend\" <code>SceneBasic</code> with <code>SceneAdvanced</code>, how would we do it in Rust? We'd probably just use the delegate pattern using composition: </p>\n\n<pre><code>struct SceneAdvanced {\n    delegate: SceneBasic,\n}\n\nimpl SceneBase for SceneAdvanced {\n    fn new() -&gt; SceneAdvanced {\n        SceneAdvanced {\n            delegate: SceneBasic {\n                active: false,\n                is_ready: false,\n            }\n        }\n    }\n    fn is_active(&amp;self) -&gt; bool {\n        self.delegate.active\n    } \n   //etc.\n} \n</code></pre>\n\n<p>See <a href=\"https://play.rust-lang.org/?gist=8cdaf82a601f87106ba671b47486f56c&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a> for full code.</p>\n"}], "owner": {"reputation": 9945, "user_id": 1270259, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/f8493a9385dae9f438379050d76ac2bf?s=128&d=identicon&r=PG", "display_name": "TheWebs", "link": "https://stackoverflow.com/users/1270259/thewebs"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 154, "favorite_count": 0, "accepted_answer_id": 48302223, "answer_count": 3, "score": -2, "last_activity_date": 1516199528, "creation_date": 1516169864, "last_edit_date": 1516198890, "question_id": 48294707, "link": "https://stackoverflow.com/questions/48294707/how-can-i-re-organize-my-structures-and-traits-to-have-a-base-behavior-and-a-con", "title": "How can I re-organize my structures and traits to have a base behavior and a container of inherited behaviors?", "body": "<p>Continuing from <a href=\"https://stackoverflow.com/q/45581356/155423\">my previous question</a>, my goal is to create a scene which inherits the scene base and from there push new scenes into a container. You can pop scenes off the container to then show a window or transition to a new map or whatever you want to do in that particular scene:</p>\n\n<pre><code>#[derive(Debug)]\nstruct SceneBase {\n    active: bool,\n    isReady: bool,\n}\n\ntrait SceneBase {\n    fn new() -&gt; Self;\n    fn isActive() -&gt; bool;\n    fn isReady() -&gt; bool;\n    fn start();\n    fn update();\n    fn stop();\n}\n\n#[derive(Debug)]\nstruct SceneContainer {\n    container: Box&lt;SceneBase&gt;,\n}\n\ntrait SceneContainer {\n    fn new(scene: SceneBase) -&gt; Self;\n    fn updateChildren();\n    fn pop();\n}\n</code></pre>\n\n<p>I am approaching this in an object-oriented way and I know Rust isn't really OO. How can I re-organize my structures and traits such that I have some sort of base that other scenes inherit from and then can be pushed to a container for \"storage\" until needed?</p>\n\n<p>Any ideas on how to lose the OO and think more ... functional on this one?</p>\n"}, {"tags": ["tree", "rust", "stack"], "comments": [{"owner": {"reputation": 3212, "user_id": 2731452, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/xA89V.jpg?s=128&g=1", "display_name": "red75prime", "link": "https://stackoverflow.com/users/2731452/red75prime"}, "edited": false, "score": 3, "creation_date": 1516176785, "post_id": 48293875, "comment_id": 83577212, "body": "Why do you need different implementation? Use immutable <code>Cactus</code> with elements of type <code>RefCell&lt;T&gt;</code> or <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>."}, {"owner": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "edited": false, "score": 1, "creation_date": 1516181546, "post_id": 48293875, "comment_id": 83579908, "body": "Typo. You forgot <code>as_ref</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1516181575, "post_id": 48293875, "comment_id": 83579921, "body": "What are you using <code>Rc</code> for? Do you really want a single <i>value</i> to be shared between multiple nodes?"}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1516182918, "post_id": 48293875, "comment_id": 83580747, "body": "The code in the Playground link does not reproduce the error message in the question."}, {"owner": {"reputation": 39, "user_id": 2291772, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e8cd1f498297821f7b5f016e36388a3d?s=128&d=identicon&r=PG", "display_name": "June", "link": "https://stackoverflow.com/users/2291772/june"}, "reply_to_user": {"reputation": 3212, "user_id": 2731452, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/xA89V.jpg?s=128&g=1", "display_name": "red75prime", "link": "https://stackoverflow.com/users/2731452/red75prime"}, "edited": false, "score": 0, "creation_date": 1516217006, "post_id": 48293875, "comment_id": 83602434, "body": "@red75prime I will try that, I hadn&#39;t thought of that, thank you :)"}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516196700, "post_id": 48298865, "comment_id": 83589803, "body": "@Shepmaster: Much nicer indeed."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516196768, "post_id": 48298865, "comment_id": 83589844, "body": "@Shepmaster: It&#39;s still a pity that <code>Clone</code> cannot be auto-derived; or at least, that the auto-derive introduces a <code>T: Clone</code> requirement that is unnecessary since <code>T</code> is behind a <code>Rc</code>. A limitation of a syntax-based derive, I am afraid. A semantic-based one could realize that <code>impl Clone for Rc</code> does not require such bound."}, {"owner": {"reputation": 39, "user_id": 2291772, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e8cd1f498297821f7b5f016e36388a3d?s=128&d=identicon&r=PG", "display_name": "June", "link": "https://stackoverflow.com/users/2291772/june"}, "edited": false, "score": 0, "creation_date": 1516216614, "post_id": 48298865, "comment_id": 83602220, "body": "Thank you so much for answering so quickly and thoroughly! What a great answer, this definitely solved my problem."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 5, "last_activity_date": 1516210272, "last_edit_date": 1516210272, "creation_date": 1516184942, "answer_id": 48298865, "question_id": 48293875, "link": "https://stackoverflow.com/questions/48293875/how-to-implement-a-mutable-cactus-stack-in-rust/48298865#48298865", "title": "How to implement a mutable cactus stack in Rust?", "body": "<p>I am afraid that you lost yourself here by just trying to throw <code>Option</code>, <code>Rc</code> and <code>RefCell</code> at the issue.</p>\n\n<p>Those are not cure-all, you need to understand when they make sense, and when they don't.</p>\n\n<p>Here is the revised definitions I arrived at:</p>\n\n<pre><code>pub struct Cactus&lt;T&gt;(Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;);\n\nstruct Node&lt;T&gt; {\n    value: RefCell&lt;T&gt;,\n    parent: Cactus&lt;T&gt;,\n    len: usize,\n}\n</code></pre>\n\n<p><em>Disclaimer: I have tried to infer where you actually need mutability, and where you don't, since you never actually explained it. My inference may have been incorrect in places; for example I decided that switching parents was unnecessary.</em></p>\n\n<p>Let's analyze <code>Node</code>:</p>\n\n<ol>\n<li><code>Node</code> uniquely owns it value, it <em>never</em> shares it, therefore there is no point for <code>Rc</code> here.</li>\n<li><code>Node</code> may be aliased, and yet you still want to modify its value, this requires wrapping the value in a <code>RefCell</code>.</li>\n<li><code>Node</code> <em>always</em> has a parent, because <code>Cactus</code> already embeds a concept of nullity.</li>\n</ol>\n\n<p>and <code>Cactus</code>:</p>\n\n<ol>\n<li><code>Cactus</code> may be null, so it's an <code>Option</code>.</li>\n<li><code>Cactus</code> shares its node with others, so <code>Rc</code> is required.</li>\n<li><code>Cactus</code> never needs to switch to another <code>Node</code>, it can directly mutate the shared node instead, so <code>RefCell</code> is unnecessary.</li>\n</ol>\n\n<p>From there, we can implement <code>Clone</code> for <code>Cactus</code> (<a href=\"https://stackoverflow.com/q/39415052/155423\">the automatic derivation fails hard</a>):</p>\n\n<pre><code>impl&lt;T&gt; Clone for Cactus&lt;T&gt; {\n    fn clone(&amp;self) -&gt; Self { Cactus(self.0.clone()) }\n}\n</code></pre>\n\n<p>Note the use <code>as_ref</code> to obtain a <code>&amp;Rc</code> in the lambda; without it, the <code>map_or</code> call would try to move the <code>Rc</code> out of <code>self.0</code> which is forbidden because <code>self</code> is borrowed.</p>\n\n<p>The other functions follow as naturally:</p>\n\n<pre><code>impl&lt;T&gt; Cactus&lt;T&gt; {\n    pub fn new() -&gt; Cactus&lt;T&gt; { Cactus(None) }\n\n    pub fn is_empty(&amp;self) -&gt; bool { self.0.is_none() }\n\n    pub fn len(&amp;self) -&gt; usize { self.0.as_ref().map_or(0, |n| n.len) }\n\n    pub fn child(&amp;self, val: T) -&gt; Cactus&lt;T&gt; {\n        let node = Node {\n            value: RefCell::new(val),\n            parent: self.clone(),\n            len: self.len() + 1,\n        };\n        Cactus(Some(Rc::new(node)))\n    }\n\n    pub fn parent(&amp;self) -&gt; Cactus&lt;T&gt; {\n        self.0.as_ref().map_or(Cactus(None), |n| n.parent.clone())\n    }\n\n    pub fn value(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;T&gt;&gt; {\n        self.0.as_ref().map(|n| &amp;n.value)\n    }\n}\n</code></pre>\n\n<p>Note that I changed a few signatures:</p>\n\n<ol>\n<li><code>parent</code> returns <code>Cactus</code>, which may be null. I do not make the difference between having a null parent and being null; this is questionable, I just felt that having a possibly null <code>Cactus</code> wrapped in an <code>Option</code> was bizarre.</li>\n<li><code>value</code> returns a reference to <code>RefCell</code> (wrapped in <code>Option</code>), so that the caller can call <code>borrow_mut</code> and mutate the actual value.</li>\n</ol>\n\n<p>This required a few adaptations to the tests:</p>\n\n<pre><code>#[test]\nfn test_simple() {\n    let r = Cactus::new();\n    assert!(r.is_empty());\n    assert_eq!(r.len(), 0);\n    assert!(r.value().is_none());\n    assert!(r.parent().is_empty());\n\n    let r2 = r.child(2);\n    assert!(!r2.is_empty());\n    assert_eq!(r2.len(), 1);\n    assert_eq!(*r2.value().unwrap().borrow(), 2);\n\n    let r3 = r2.parent();\n    assert_eq!(r3.is_empty(), true);\n    assert_eq!(r3.len(), 0);\n\n    let r4 = r.child(3);\n    assert_eq!(r4.len(), 1);\n    assert_eq!(*r4.value().unwrap().borrow(), 3);\n\n    let r5 = r4.parent();\n    assert!(r5.is_empty());\n\n    let r6 = r4.child(4);\n    assert_eq!(r6.len(), 2);\n    assert_eq!(*r6.value().unwrap().borrow(), 4);\n    assert_eq!(*r6.parent().value().unwrap().borrow(), 3);\n}\n</code></pre>\n\n<p>Mostly, as you can see, calling <code>.borrow()</code> after <code>.unwrap()</code>.</p>\n\n<p>Of note, the latest line fails to compile: <code>r6.parent()</code> returns a temporary value out of which we attempt to obtain a reference; the compiler complains that this reference is used after the temporary is dropped, probably as a detail of how <code>assert_eq</code> is implemented.</p>\n\n<blockquote>\n<pre><code>   |\n74 |         assert_eq!(*r6.parent().value().unwrap().borrow(), 3);\n   |         ^^^^^^^^^^^^-----------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |           |\n   |         |           temporary value created here\n   |         temporary value dropped here while still borrowed\n   |\n   = note: values in a scope are dropped in the opposite order they are created\n   = note: consider using a `let` binding to increase its lifetime\n   = note: this error originates in a macro outside of the current crate\n</code></pre>\n</blockquote>\n\n<p>Simply replacing <code>r6.parent()</code> by <code>r4</code> fixes this issue.</p>\n"}], "owner": {"reputation": 39, "user_id": 2291772, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e8cd1f498297821f7b5f016e36388a3d?s=128&d=identicon&r=PG", "display_name": "June", "link": "https://stackoverflow.com/users/2291772/june"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 115, "favorite_count": 0, "accepted_answer_id": 48298865, "answer_count": 1, "score": 2, "last_activity_date": 1516210272, "creation_date": 1516165114, "last_edit_date": 1516196127, "question_id": 48293875, "link": "https://stackoverflow.com/questions/48293875/how-to-implement-a-mutable-cactus-stack-in-rust", "title": "How to implement a mutable cactus stack in Rust?", "body": "<p>A  <a href=\"https://en.wikipedia.org/wiki/Parent_pointer_tree\" rel=\"nofollow noreferrer\">Cactus Stack or Parent Pointer Tree</a> is a stack where nodes in the stack have pointers to their parent so the stack is climbable in multiple ways.</p>\n\n<p>I'm trying to implement a mutable Cactus Stack in Rust based off of <a href=\"https://github.com/softdevteam/cactus\" rel=\"nofollow noreferrer\">this immutable implementation</a> using the <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> pattern to pass around shared memory:</p>\n\n<pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Clone, Default)]\npub struct Cactus&lt;T&gt; {\n    node: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,\n}\n\n#[derive(Clone)]\npub struct Node&lt;T&gt; {\n    val: Rc&lt;RefCell&lt;T&gt;&gt;,\n    parent: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,\n    len: usize,\n}\n\nimpl&lt;T&gt; Cactus&lt;T&gt; {\n    pub fn new() -&gt; Cactus&lt;T&gt; {\n        Cactus { node: None }\n    }\n\n    pub fn is_empty(&amp;self) -&gt; bool {\n        self.node.is_none()\n    }\n\n    pub fn len(&amp;self) -&gt; usize {\n        self.node.as_ref().map_or(0, |x| x.borrow().len)\n    }\n\n    pub fn child(&amp;self, val: T) -&gt; Cactus&lt;T&gt; {\n        Cactus {\n            node: Some(Rc::new(RefCell::new(Node {\n                val: Rc::new(RefCell::new(val)),\n                parent: self.node.clone(),\n                len: self.node.as_ref().map_or(1, |x| x.borrow().len + 1),\n            }))),\n        }\n    }\n\n    pub fn parent(&amp;self) -&gt; Option&lt;Cactus&lt;T&gt;&gt; {\n        self.node.as_ref().map(|n| Cactus {\n            node: n.borrow().parent.clone(),\n        })\n    }\n\n    pub fn val(&amp;mut self) -&gt; Option&lt;Rc&lt;RefCell&lt;T&gt;&gt;&gt; {\n        self.node.map(|n| n.borrow_mut().val.clone())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple() {\n        let r = Cactus::new();\n        assert!(r.is_empty());\n        assert_eq!(r.len(), 0);\n        assert!(r.val().is_none());\n        assert!(r.parent().is_none());\n        let r2 = r.child(2);\n        assert!(!r2.is_empty());\n        assert_eq!(r2.len(), 1);\n        assert_eq!(*r2.val().unwrap(), 2);\n        let r3 = r2.parent().unwrap();\n        assert_eq!(r3.is_empty(), true);\n        assert_eq!(r3.len(), 0);\n        let r4 = r.child(3);\n        assert_eq!(r4.len(), 1);\n        assert_eq!(*r4.val().unwrap(), 3);\n        let r5 = r4.parent().unwrap();\n        assert!(r5.is_empty());\n        let r6 = r4.child(4);\n        assert_eq!(r6.len(), 2);\n        assert_eq!(*r6.val().unwrap(), 4);\n        assert_eq!(*r6.parent().unwrap().val().unwrap(), 3);\n    }    \n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=841bf9facae571d2030aa4a51ef8dc12&amp;version=undefined\" rel=\"nofollow noreferrer\">playground</a></p>\n\n<p>My issue is getting the <code>val</code> from nodes:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:64:9\n   |\n64 |         assert_eq!(*r2.val().unwrap(), 2);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::cell::RefCell`, found integral variable\n   |\n   = note: expected type `std::cell::RefCell&lt;{integer}&gt;`\n              found type `{integer}`\n   = note: this error originates in a macro outside of the current crate\n\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:70:9\n   |\n70 |         assert_eq!(*r4.val().unwrap(), 3);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::cell::RefCell`, found integral variable\n   |\n   = note: expected type `std::cell::RefCell&lt;{integer}&gt;`\n              found type `{integer}`\n   = note: this error originates in a macro outside of the current crate\n\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:75:9\n   |\n75 |         assert_eq!(*r6.val().unwrap(), 4);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::cell::RefCell`, found integral variable\n   |\n   = note: expected type `std::cell::RefCell&lt;{integer}&gt;`\n              found type `{integer}`\n   = note: this error originates in a macro outside of the current crate\n\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:76:9\n   |\n76 |         assert_eq!(*r6.parent().unwrap().val().unwrap(), 3);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::cell::RefCell`, found integral variable\n   |\n   = note: expected type `std::cell::RefCell&lt;{integer}&gt;`\n              found type `{integer}`\n   = note: this error originates in a macro outside of the current crate\n</code></pre>\n"}, {"tags": ["json", "serialization", "rust", "serde"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1516159768, "creation_date": 1516159768, "answer_id": 48293152, "question_id": 48288988, "link": "https://stackoverflow.com/questions/48288988/how-do-i-write-a-serde-visitor-to-convert-an-array-of-arrays-of-strings-to-a-vec/48293152#48293152", "title": "How do I write a Serde Visitor to convert an array of arrays of strings to a Vec&lt;Vec&lt;f64&gt;&gt;?", "body": "<p>As already described in <a href=\"https://stackoverflow.com/q/46753955/155423\">How to transform fields before deserialization using serde?</a>, the easiest solution is to introduce a <em>newtype</em> for your string-as-a-floating-point-value. You can then implement <code>Deserialize</code> for that, leveraging existing implementations of <code>Deserialize</code> and string parsing:</p>\n\n<pre><code>extern crate serde;\n#[macro_use]\nextern crate serde_derive;\nextern crate serde_json;\n\nuse serde::de::{Deserialize, Deserializer, Error, Unexpected};\n\n#[derive(Debug, Deserialize)]\nstruct Payload {\n    #[serde(default)]\n    values: Vec&lt;Vec&lt;Value&gt;&gt;,\n}\n\n#[derive(Debug)]\nstruct Value(f64);\n\nimpl&lt;'de&gt; Deserialize&lt;'de&gt; for Value {\n    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Value, D::Error&gt;\n        where D: Deserializer&lt;'de&gt;\n    {\n        let s: &amp;str = Deserialize::deserialize(deserializer)?;\n        s.parse()\n            .map(Value)\n            .map_err(|_| D::Error::invalid_value(Unexpected::Str(s), &amp;\"a floating point number as a string\"))\n    }\n}\n\nfn main() {\n    let input = r#\"\n{\n  \"values\": [[\"2\", \"1.4\"], [\"8.32\", \"1.5\"]]\n}\n\"#;\n\n    let out: Payload = serde_json::from_str(input).unwrap();\n\n    println!(\"{:?}\", out);\n}\n</code></pre>\n\n<p>I prefer this solution because in many cases I want that new type to play a role in my system.</p>\n\n<hr>\n\n<p>If you really, truly need to deserialize once and to exactly a <code>Vec&lt;Vec&lt;f64&gt;&gt;</code>, you have to implement two visitors. One will deserialize the outer <code>Vec</code>, one will deserialize the inner <code>Vec</code>. We will reuse the previous <code>Value</code> newtype, but the inner visitor will strip it away. The outer visitor will do the same thing for a newtype around the inner visitor:</p>\n\n<pre><code>extern crate serde;\n#[macro_use]\nextern crate serde_derive;\nextern crate serde_json;\n\nuse serde::de::{Deserialize, Deserializer, Error, SeqAccess, Unexpected, Visitor};\nuse std::fmt;\n\n#[derive(Debug, Deserialize)]\nstruct Payload {\n    #[serde(default, deserialize_with = \"from_array_of_arrays_of_strs\")]\n    values: Vec&lt;Vec&lt;f64&gt;&gt;,\n}\n\nfn from_array_of_arrays_of_strs&lt;'de, D&gt;(deserializer: D) -&gt; Result&lt;Vec&lt;Vec&lt;f64&gt;&gt;, D::Error&gt;\nwhere\n    D: Deserializer&lt;'de&gt;,\n{\n    struct OuterVisitor;\n\n    impl&lt;'de&gt; Visitor&lt;'de&gt; for OuterVisitor {\n        type Value = Vec&lt;Vec&lt;f64&gt;&gt;;\n\n        fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n            formatter.write_str(\"a nonempty sequence of a sequence of numbers\")\n        }\n\n        #[inline]\n        fn visit_seq&lt;V&gt;(self, mut visitor: V) -&gt; Result&lt;Self::Value, V::Error&gt;\n        where\n            V: SeqAccess&lt;'de&gt;,\n        {\n            let mut vec = Vec::new();\n\n            while let Some(Inner(elem)) = try!(visitor.next_element()) {\n                vec.push(elem);\n            }\n\n            Ok(vec)\n        }\n    }\n\n    deserializer.deserialize_seq(OuterVisitor)\n}\n\nstruct Inner(Vec&lt;f64&gt;);\n\nimpl&lt;'de&gt; Deserialize&lt;'de&gt; for Inner {\n    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Inner, D::Error&gt;\n    where\n        D: Deserializer&lt;'de&gt;,\n    {\n        struct InnerVisitor;\n\n        impl&lt;'de&gt; Visitor&lt;'de&gt; for InnerVisitor {\n            type Value = Inner;\n\n            fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n                formatter.write_str(\"a nonempty sequence of numbers\")\n            }\n\n            #[inline]\n            fn visit_seq&lt;V&gt;(self, mut visitor: V) -&gt; Result&lt;Inner, V::Error&gt;\n            where\n                V: SeqAccess&lt;'de&gt;,\n            {\n                let mut vec = Vec::new();\n\n                while let Some(Value(elem)) = try!(visitor.next_element()) {\n                    vec.push(elem);\n                }\n\n                Ok(Inner(vec))\n            }\n        }\n\n        deserializer.deserialize_seq(InnerVisitor)\n    }\n}\n\nstruct Value(f64);\n\nimpl&lt;'de&gt; Deserialize&lt;'de&gt; for Value {\n    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Value, D::Error&gt;\n    where\n        D: Deserializer&lt;'de&gt;,\n    {\n        let s: &amp;str = Deserialize::deserialize(deserializer)?;\n        s.parse().map(Value).map_err(|_| {\n            D::Error::invalid_value(Unexpected::Str(s), &amp;\"a floating point number as a string\")\n        })\n    }\n}\n\nfn main() {\n    let input = r#\"\n{\n  \"values\": [[\"2\", \"1.4\"], [\"8.32\", \"1.5\"]]\n}\n\"#;\n\n    let out: Payload = serde_json::from_str(input).unwrap();\n\n    println!(\"{:?}\", out);\n}\n</code></pre>\n"}], "owner": {"reputation": 1593, "user_id": 2287402, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/Q5Rvg.png?s=128&g=1", "display_name": "Elie G&#233;nard", "link": "https://stackoverflow.com/users/2287402/elie-g%c3%a9nard"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1591, "favorite_count": 2, "accepted_answer_id": 48293152, "answer_count": 1, "score": 5, "last_activity_date": 1516159768, "creation_date": 1516133052, "last_edit_date": 1516138319, "question_id": 48288988, "link": "https://stackoverflow.com/questions/48288988/how-do-i-write-a-serde-visitor-to-convert-an-array-of-arrays-of-strings-to-a-vec", "title": "How do I write a Serde Visitor to convert an array of arrays of strings to a Vec&lt;Vec&lt;f64&gt;&gt;?", "body": "<p>I need to deserialize a JSON into a struct that has a <code>Vec&lt;Vec&lt;f64&gt;&gt;</code> field. The JSON has strings for numbers so I need a custom deserializer to convert the strings to <code>f64</code> during the deserialization.</p>\n\n<p>A sample JSON that I'd like to deserialize:</p>\n\n<pre><code>{\n  \"values\": [[\"2\", \"1.4\"], [\"8.32\", \"1.5\"]]\n}\n</code></pre>\n\n<p>My struct is this:</p>\n\n<pre><code>#[derive(Deserialize)]\nstruct Payload {\n    #[serde(default, deserialize_with = \"from_array_of_arrays_of_strs\")]\n    values: Vec&lt;Vec&lt;f64&gt;&gt;,\n}\n</code></pre>\n\n<p>I saw you could probably do this with visitors <a href=\"https://serde.rs/stream-array.html\" rel=\"noreferrer\">in the examples of Serde</a>, so I've implemented this visitor:</p>\n\n<pre><code>fn from_array_of_arrays_of_strs&lt;'de, T, D&gt;(deserializer: D) -&gt; Result&lt;Vec&lt;Vec&lt;f64&gt;&gt;, D::Error&gt;\nwhere\n    T: Deserialize&lt;'de&gt;,\n    D: Deserializer&lt;'de&gt;,\n{\n    struct F64Visitor(PhantomData&lt;fn() -&gt; Vec&lt;Vec&lt;f64&gt;&gt;&gt;);\n\n    impl&lt;'de&gt; Visitor&lt;'de&gt; for F64Visitor {\n        type Value = Vec&lt;Vec&lt;f64&gt;&gt;;\n\n        fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n            formatter.write_str(\"a nonempty sequence of numbers\")\n        }\n\n        #[inline]\n        fn visit_str&lt;E&gt;(self, value: &amp;str) -&gt; Result&lt;f64, E&gt;\n        where\n            E: serde::de::Error,\n        {\n            self.visit_string(String::from(value))\n        }\n\n        #[inline]\n        fn visit_string&lt;E&gt;(self, value: String) -&gt; Result&lt;f64, E&gt; {\n            Ok(value.parse::&lt;f64&gt;().unwrap())\n        }\n\n        #[inline]\n        fn visit_seq&lt;V, T&gt;(self, mut visitor: V) -&gt; Result&lt;Vec&lt;T&gt;, V::Error&gt;\n        where\n            V: SeqAccess&lt;'de&gt;,\n        {\n            let mut vec = Vec::new();\n\n            while let Some(elem) = try!(visitor.next_element()) {\n                vec.push(elem);\n            }\n\n            Ok(vec)\n        }\n    }\n\n    let visitor = F64Visitor(PhantomData);\n    deserializer.deserialize_seq(visitor)\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=90d5e80118c9a7e799fcdaba3704bb02&amp;version=stable\" rel=\"noreferrer\">playground</a></p>\n\n<p>The compiler complains that <code>visit_str</code> and <code>visit_string</code> have an incompatible type for the trait:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0053]: method `visit_str` has an incompatible type for trait\n  --&gt; src/main.rs:32:9\n   |\n32 | /         fn visit_str&lt;E&gt;(self, value: &amp;str) -&gt; Result&lt;f64, E&gt;\n33 | |             where\n34 | |             E: serde::de::Error,\n35 | |         {\n36 | |             self.visit_string(String::from(value))\n37 | |         }\n   | |_________^ expected struct `std::vec::Vec`, found f64\n   |\n   = note: expected type `fn(from_array_of_arrays_of_strs::F64Visitor, &amp;str) -&gt; std::result::Result&lt;std::vec::Vec&lt;std::vec::Vec&lt;f64&gt;&gt;, E&gt;`\n              found type `fn(from_array_of_arrays_of_strs::F64Visitor, &amp;str) -&gt; std::result::Result&lt;f64, E&gt;`\n\nerror[E0053]: method `visit_string` has an incompatible type for trait\n  --&gt; src/main.rs:40:9\n   |\n40 | /         fn visit_string&lt;E&gt;(self, value: String) -&gt; Result&lt;f64, E&gt; {\n41 | |             Ok(value.parse::&lt;f64&gt;().unwrap())\n42 | |         }\n   | |_________^ expected struct `std::vec::Vec`, found f64\n   |\n   = note: expected type `fn(from_array_of_arrays_of_strs::F64Visitor, std::string::String) -&gt; std::result::Result&lt;std::vec::Vec&lt;std::vec::Vec&lt;f64&gt;&gt;, E&gt;`\n              found type `fn(from_array_of_arrays_of_strs::F64Visitor, std::string::String) -&gt; std::result::Result&lt;f64, E&gt;`\n\nerror[E0049]: method `visit_seq` has 2 type parameters but its trait declaration has 1 type parameter\n  --&gt; src/main.rs:45:21\n   |\n45 |         fn visit_seq&lt;V, T&gt;(self, mut visitor: V) -&gt; Result&lt;Vec&lt;T&gt;, V::Error&gt;\n   |                     ^^^^^^ found 2 type parameters, expected 1\n</code></pre>\n\n<p>I think I don't have the correct understanding of how visitors work. Can I have only one visitor for deserializing the array of arrays of strings, or do I need one visitor for deserializing the arrays and one visitor for deserializing the strings to <code>f64</code>?</p>\n\n<p>I've read:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/46753955/how-to-transform-fields-before-deserialization-using-serde\">How to transform fields before deserialization using serde?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/44836327/is-there-is-a-simpler-way-to-convert-a-type-upon-deserialization\">Is there is a simpler way to convert a type upon deserialization?</a></li>\n</ul>\n"}, {"tags": ["generics", "reference", "rust", "any"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516132372, "post_id": 48288640, "comment_id": 83562516, "body": "What are you going to do with <code>parent</code> that requires you to know its parent&#39;s type?"}, {"owner": {"reputation": 410, "user_id": 3797176, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/ysK5k.png?s=128&g=1", "display_name": "Axel Montini", "link": "https://stackoverflow.com/users/3797176/axel-montini"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516132770, "post_id": 48288640, "comment_id": 83562736, "body": "My intent is to be able to get the parent to use the DataRouters as a chain. Basically I just want to be able to return the <code>parent</code> with a getter method, so that I can use it from where I&#39;ll build the chain. There every DataRouter will process the data and return it; Then the data will be passed to the last router&#39;s parent and will be processed again; and so on, until the chain ends (None instead of <code>Some(parent)</code>)."}], "answers": [{"comments": [{"owner": {"reputation": 410, "user_id": 3797176, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/ysK5k.png?s=128&g=1", "display_name": "Axel Montini", "link": "https://stackoverflow.com/users/3797176/axel-montini"}, "edited": false, "score": 0, "creation_date": 1516133174, "post_id": 48288912, "comment_id": 83562928, "body": "Exactly what I wanted. I don&#39;t know how you managed to answer correctly in like 30 seconds, but it works. Now I know how to deal better with Rust trait system. Good job"}, {"owner": {"reputation": 1339, "user_id": 682485, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/ea1e106f2d083f0624c0c4f48ae1c18b?s=128&d=identicon&r=PG", "display_name": "Malice", "link": "https://stackoverflow.com/users/682485/malice"}, "edited": false, "score": 1, "creation_date": 1516438709, "post_id": 48288912, "comment_id": 83695048, "body": "Just curious as to why  we need the <code>Parent</code> trait here at all ? It would have worked even without it. Is it just to make sure that no other <code>type</code> go into the <code>parent</code>  field of <code>DataRouter</code> - other than a <code>DataRouter</code> or a <code>Nil</code> ?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1516132742, "creation_date": 1516132742, "answer_id": 48288912, "question_id": 48288640, "link": "https://stackoverflow.com/questions/48288640/generic-struct-with-a-reference-to-the-same-type-but-with-any-concrete-type/48288912#48288912", "title": "Generic struct with a reference to the same type but with any concrete type", "body": "<p>Since you don't (and indeed cannot) care about the type of the parent's parent, introduce abstraction through a trait:</p>\n\n<pre><code>trait Parent {}\n\nstruct Nil;\nimpl Parent for Nil {}\n\npub struct DataRouter&lt;'a, T, P&gt;\nwhere\n    P: 'a,\n{\n    parent: Option&lt;&amp;'a P&gt;,\n    data: Option&lt;T&gt;,\n}\n\nimpl&lt;'a, T, P&gt; Parent for DataRouter&lt;'a, T, P&gt; {}\n\nfn main() {\n    let a = DataRouter {\n        parent: None::&lt;&amp;'static Nil&gt;,\n        data: Some(true),\n    };\n    let b = DataRouter {\n        parent: Some(&amp;a),\n        data: Some(42),\n    };\n    let c = DataRouter {\n        parent: Some(&amp;b),\n        data: Some(\"moo\"),\n    };\n}\n</code></pre>\n"}], "owner": {"reputation": 410, "user_id": 3797176, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/ysK5k.png?s=128&g=1", "display_name": "Axel Montini", "link": "https://stackoverflow.com/users/3797176/axel-montini"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 123, "favorite_count": 0, "accepted_answer_id": 48288912, "answer_count": 1, "score": 2, "last_activity_date": 1516132742, "creation_date": 1516131540, "last_edit_date": 1516132177, "question_id": 48288640, "link": "https://stackoverflow.com/questions/48288640/generic-struct-with-a-reference-to-the-same-type-but-with-any-concrete-type", "title": "Generic struct with a reference to the same type but with any concrete type", "body": "<p>My intention is to create a struct that holds a reference to another one of a similar type, but with different generics to be used as a chain of linked objects.</p>\n\n<p>The problem is that writing this using the <code>_</code> placeholder is not allowed: </p>\n\n<blockquote>\n<pre><code>the type placeholder `_` is not allowed within types on item\nsignatures\n</code></pre>\n  \n  <p><a href=\"https://doc.rust-lang.org/error-index.html#E0121\" rel=\"nofollow noreferrer\">E0121</a></p>\n</blockquote>\n\n<p>I cannot simply give my struct another type parameter since the referenced object may reference another object too, and so on. This would lead to a very large number of type parameters, which is not practical.</p>\n\n<p>I would like to find a way to change this implementation to make it work:</p>\n\n<pre><code>// The type parameters are:\n// O: this Router's data type\n// B: The parent router's data type\npub struct DataRouter&lt;'a, O, B = O&gt;\nwhere\n    O: 'a,\n    B: 'a,\n{\n    parent: Option&lt;&amp;'a DataRouter&lt;'a, B, _&gt;&gt;, // Here the problem `_`\n    range: Option&lt;Range&lt;usize&gt;&gt;,\n    data: Option&lt;O&gt;,\n}\n</code></pre>\n\n<p>I can't simply put a parameter here as I would've to add it to the struct, which then would cause the same infinite loop of adding a type parameter.</p>\n\n<p>Is there a way to hold a reference to a <code>DataRouter</code> with <code>B</code> data type which itself holds a reference to a parent <code>DataRouter</code> with an unknown data type? The struct has to know only the direct parent data type, not the one of the second parent.</p>\n\n<p>If this cannot be fixed, can you suggest a different implementation that could work?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1516122177, "post_id": 48286114, "comment_id": 83557209, "body": "TL;DR the duplicates: You cannot hold a reference to a value of <code>v1</code> while you mutate it. Doing so would allow the reference to point to non-allocated memory. You need to split the creation of the vector with values and the creation of the vector of references: <code>let v1: Vec&lt;_&gt; = (1..10).collect(); let v2: Vec&lt;_&gt; = v1.iter().collect();</code>"}], "owner": {"reputation": 21, "user_id": 6640474, "user_type": "registered", "profile_image": "https://lh5.googleusercontent.com/-TCILcM1-YxE/AAAAAAAAAAI/AAAAAAAAxdI/VOzn4JrcBjM/photo.jpg?sz=128", "display_name": "D&#225;vid Fazekas", "link": "https://stackoverflow.com/users/6640474/d%c3%a1vid-fazekas"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 143, "favorite_count": 0, "closed_date": 1516122060, "answer_count": 0, "score": 1, "last_activity_date": 1516122088, "creation_date": 1516121383, "last_edit_date": 1516121548, "question_id": 48286114, "link": "https://stackoverflow.com/questions/48286114/how-to-store-values-in-a-vector-and-refer-to-them-from-another", "closed_reason": "Duplicate", "title": "How to store values in a vector and refer to them from another?", "body": "<p>I want to store a batch of data somewhere and refer to them from multiple spaces, and I have serious trouble with borrowing:</p>\n\n<pre><code>fn main() {\n    let mut v1: Vec&lt;i32&gt; = Vec::new();\n    let mut v2: Vec&lt;&amp;i32&gt; = Vec::new();\n    for i in 1..10 {\n        v1.push(i);\n        v2.push(v1.last().unwrap());\n    }\n    println!(\"{:?}\", v1);\n    println!(\"{:?}\", v2);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=0c5b396c2f98fa5bb4e55615076d7ad2&amp;version=undefined\" rel=\"nofollow noreferrer\">Playground</a></p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `v1` as mutable because it is also borrowed as immutable\n  --&gt; src/main.rs:6:9\n   |\n6  |         v1.push(i);\n   |         ^^ mutable borrow occurs here\n7  |         v2.push(v1.last().unwrap());\n   |                 -- immutable borrow occurs here\n...\n11 | }\n   | - immutable borrow ends here\n</code></pre>\n"}, {"tags": ["arrays", "rust", "indices", "mutability"], "comments": [{"owner": {"reputation": 13883, "user_id": 2883245, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/NPpPG.jpg?s=128&g=1", "display_name": "erip", "link": "https://stackoverflow.com/users/2883245/erip"}, "edited": false, "score": 0, "creation_date": 1516101123, "post_id": 48279852, "comment_id": 83543261, "body": "I don&#39;t think <code>Array</code>s are mutable by default; hence your error."}, {"owner": {"reputation": 13883, "user_id": 2883245, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/NPpPG.jpg?s=128&g=1", "display_name": "erip", "link": "https://stackoverflow.com/users/2883245/erip"}, "edited": false, "score": 0, "creation_date": 1516101280, "post_id": 48279852, "comment_id": 83543352, "body": "If you&#39;re familiar with C++... <code>value reads</code> maps to <code>return-by-value</code> semantics, <code>reference reads</code> maps to const-correct <code>return-by-reference</code> semantics, and <code>mutable reference reads</code> is a bad idea in most cases and simply refers to <code>return-by-reference</code> semantics."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516111651, "post_id": 48280035, "comment_id": 83550016, "body": "You didn&#39;t really answer OP&#39;s question(s): <i>How does Rust implement array read function?</i> and <i>What is the difference between &quot;value reads&quot;, &quot;reference reads&quot; and &quot;mutable reference reads&quot;?</i>"}, {"owner": {"reputation": 925, "user_id": 5866297, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/1a0a80aed2650a949dd7f3b322a525ef?s=128&d=identicon&r=PG&f=1", "display_name": "Coding_Rabbit", "link": "https://stackoverflow.com/users/5866297/coding-rabbit"}, "edited": false, "score": 0, "creation_date": 1516113201, "post_id": 48280035, "comment_id": 83551032, "body": "I&#39;ve changed the code and turned array <code>xs</code> into a mutable one but I still don&#39;t know what is the difference between those three ways of array reading. Could you please give me some explanation?"}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 925, "user_id": 5866297, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/1a0a80aed2650a949dd7f3b322a525ef?s=128&d=identicon&r=PG&f=1", "display_name": "Coding_Rabbit", "link": "https://stackoverflow.com/users/5866297/coding-rabbit"}, "edited": false, "score": 0, "creation_date": 1516115011, "post_id": 48280035, "comment_id": 83552301, "body": "@Coding_Rabbit I expanded the answer a little bit; I think it&#39;s clearer now."}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 6, "last_activity_date": 1516115399, "last_edit_date": 1516115399, "creation_date": 1516101550, "answer_id": 48280035, "question_id": 48279852, "link": "https://stackoverflow.com/questions/48279852/how-does-rust-implement-array-indexing/48280035#48280035", "title": "How does Rust implement array indexing?", "body": "<p><code>xs</code> is <strong>not</strong> mutable; in order to make it mutable its binding must contain the <code>mut</code> keyword:</p>\n\n<pre><code>let mut xs: [i32; 5] = [1, 2, 3, 4, 5];\n</code></pre>\n\n<p>When you add it, your code will work as expected. I recommend <a href=\"https://doc.rust-lang.org/stable/book/first-edition/variable-bindings.html#mutability\" rel=\"noreferrer\">the relevant section in The Rust Book</a>.</p>\n\n<p>Indexing in Rust is an operation provided by the <a href=\"https://doc.rust-lang.org/stable/std/ops/trait.Index.html\" rel=\"noreferrer\"><code>Index</code></a> and <a href=\"https://doc.rust-lang.org/stable/std/ops/trait.IndexMut.html\" rel=\"noreferrer\"><code>IndexMut</code></a> traits and, as stated in the docs, it's syntax sugar for <code>*container.index(index)</code> and <code>*container.index_mut(index)</code>, which means that it provides direct access (not just a reference) to the indexed element. The differences between the 3 operations you listed can be better seen with <code>assert_eq</code> comparisons:</p>\n\n<pre><code>fn main() {\n    let mut xs: [i32; 5] = [1, 2, 3, 4, 5];\n\n    assert_eq!(xs[1], 2); // directly access the element at index 1\n    assert_eq!(&amp;xs[1], &amp;2); // obtain a reference to the element at index 1\n    assert_eq!(&amp;mut xs[1], &amp;mut 2); // obtain a mutable reference to the element at index 1\n\n    let mut ys: [String; 2] = [String::from(\"abc\"), String::from(\"def\")];\n\n    assert_eq!(ys[1], String::from(\"def\"));\n    assert_eq!(&amp;ys[1], &amp;\"def\");\n    assert_eq!(&amp;mut ys[1], &amp;mut \"def\");\n}\n</code></pre>\n"}], "owner": {"reputation": 925, "user_id": 5866297, "user_type": "registered", "accept_rate": 25, "profile_image": "https://www.gravatar.com/avatar/1a0a80aed2650a949dd7f3b322a525ef?s=128&d=identicon&r=PG&f=1", "display_name": "Coding_Rabbit", "link": "https://stackoverflow.com/users/5866297/coding-rabbit"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2155, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1516115399, "creation_date": 1516100972, "last_edit_date": 1516115236, "question_id": 48279852, "link": "https://stackoverflow.com/questions/48279852/how-does-rust-implement-array-indexing", "title": "How does Rust implement array indexing?", "body": "<p>I'm learning about substructural type systems and Rust is a good example of that. </p>\n\n<p>An array is mutable in Rust and it can be accessed many times rather than only once. What is the difference between \"value reads\", \"reference reads\" and \"mutable reference reads\"? I wrote a program as below but I got some errors.</p>\n\n<pre><code>fn main() {\n    let xs: [i32; 5] = [1, 2, 3, 4, 5];\n    println!(\"first element of the array: {}\", xs[1]);\n    println!(\"first element of the array: {}\", &amp;xs[1]);\n    println!(\"first element of the array: {}\", &amp;mut xs[1]);\n}\n</code></pre>\n\n<p>Here is the error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0596]: cannot borrow immutable indexed content `xs[..]` as mutable\n --&gt; src/main.rs:5:53\n  |\n2 |     let xs: [i32; 5] = [1, 2, 3, 4, 5];\n  |         -- consider changing this to `mut xs`\n...\n5 |     println!(\"first element of the array: {}\", &amp;mut xs[1]);\n  |                                                     ^^^^^ cannot mutably borrow immutable field\n</code></pre>\n"}, {"tags": ["permissions", "rust", "webassembly"], "comments": [{"owner": {"reputation": 134258, "user_id": 785065, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/qAbxM.jpg?s=128&g=1", "display_name": "loganfsmyth", "link": "https://stackoverflow.com/users/785065/loganfsmyth"}, "edited": false, "score": 4, "creation_date": 1516038071, "post_id": 48268016, "comment_id": 83519364, "body": "Where are you expecting to load this file from? JS code can&#39;t load arbitrary files from a user&#39;s filesystem, so I wouldn&#39;t expect a WASM one to be able to either."}, {"owner": {"reputation": 89, "user_id": 3326762, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/ed9896105833a26bfb62c7cadf7c37b9?s=128&d=identicon&r=PG&f=1", "display_name": "compasses", "link": "https://stackoverflow.com/users/3326762/compasses"}, "reply_to_user": {"reputation": 134258, "user_id": 785065, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/qAbxM.jpg?s=128&g=1", "display_name": "loganfsmyth", "link": "https://stackoverflow.com/users/785065/loganfsmyth"}, "edited": false, "score": 0, "creation_date": 1516038450, "post_id": 48268016, "comment_id": 83519537, "body": "Oh. Here&#39;s how. I do not know JS, so it is suddenly for me. Can you tell me what I can do in my case?"}, {"owner": {"reputation": 134258, "user_id": 785065, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/qAbxM.jpg?s=128&g=1", "display_name": "loganfsmyth", "link": "https://stackoverflow.com/users/785065/loganfsmyth"}, "edited": false, "score": 1, "creation_date": 1516038823, "post_id": 48268016, "comment_id": 83519707, "body": "I&#39;m not quite confident enough to answer this for the Rust and WASM case, but assuming it is similar to JS, you&#39;ll want to take a look at <a href=\"http://kripken.github.io/emscripten-site/docs/porting/emscripten-runtime-environment.html#file-systems\" rel=\"nofollow noreferrer\">kripken.github.io/emscripten-site/docs/porting/&hellip;</a> The filesystem you&#39;re accessing now is likely entirely in-memory, and not the user&#39;s actual filesystem."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1516041494, "post_id": 48268016, "comment_id": 83520951, "body": "Probably a duplicate of <a href=\"https://stackoverflow.com/q/45535301/155423\">Can I read files from the disk by using Webassembly?</a>"}], "owner": {"reputation": 89, "user_id": 3326762, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/ed9896105833a26bfb62c7cadf7c37b9?s=128&d=identicon&r=PG&f=1", "display_name": "compasses", "link": "https://stackoverflow.com/users/3326762/compasses"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 753, "favorite_count": 0, "closed_date": 1516084310, "answer_count": 0, "score": 0, "last_activity_date": 1516041324, "creation_date": 1516037524, "last_edit_date": 1516041324, "question_id": 48268016, "link": "https://stackoverflow.com/questions/48268016/how-do-i-read-a-file-from-the-local-disk-from-webassembly", "closed_reason": "Duplicate", "title": "How do I read a file from the local disk from WebAssembly?", "body": "<p>My main.rs:</p>\n\n<pre><code>use std::fs::File;\nuse std::io::prelude::*;\n\nfn read_file(file_name: &amp;str, file_path: &amp;str) -&gt; Vec&lt;String&gt; {\n    let file_open_error = format!(\"File {} by path {} not found!\", file_name, file_path);\n    let file_read_error = format!(\n        \"Can't read the file {}\\\\{}, the error:{}\",\n        file_path, file_name\n    );\n\n    let mut file = File::open(format!(\"{}\\\\{}\", file_path, file_name)).expect(&amp;*file_open_error);\n\n    let mut content = String::new();\n    file.read_to_string(&amp;mut content).expect(&amp;*file_read_error);\n\n    content\n        .split_whitespace()\n        .map(|s| s.to_string())\n        .collect::&lt;Vec&lt;String&gt;&gt;()\n}\n\nfn get_random_value&lt;'a&gt;(vec: &amp;'a Vec&lt;String&gt;) -&gt; &amp;'a String {\n    let mut rng = rand::thread_rng();\n    rng.choose(&amp;vec).unwrap()\n}\n\nfn main() {\n    let names_file_name = \"names.txt\";\n    let adjectives_file_name = \"adjectives.txt\";\n    let file_path = \"D:\\\\nameadj\";\n\n    let names = read_file(names_file_name, file_path);\n    let adjectives = read_file(adjectives_file_name, file_path);\n\n    let name = get_random_value(&amp;names);\n    let adjective = get_random_value(&amp;adjectives);\n    println!(\"name={};adjective={}\", name, adjective);\n}\n</code></pre>\n\n<p>I've compiled it:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>cargo build --release --target wasm32-unknown-emscripten\n</code></pre>\n\n<p>I've created a simple HTML file where I call the JavaScript file, which I saved here:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>target\\wasm32-unknown-emscripten\\release\n</code></pre>\n\n<p>When I run it</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>emrun --browser firefox --port 8080 tryrustwebasm.html\n</code></pre>\n\n<p>There is an error in the console log of my browser:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>thread 'main' panicked at 'File names.txt by path D:\\nameadj not found!: Error { repr: Os { code: 2, message: \"No such file or directory\" } }', /checkout/src/libcore/result.rs:906:4\n</code></pre>\n\n<p>When I run the program without <code>emrun</code>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>cargo run\n</code></pre>\n\n<p>the program works fine.</p>\n\n<p>What am I doing wrong? Is this a permissions problem? How do I fix it?</p>\n"}, {"tags": ["asynchronous", "rust", "future", "amazon-kinesis"], "comments": [{"owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "edited": false, "score": 1, "creation_date": 1516035828, "post_id": 48267479, "comment_id": 83518288, "body": "Did you have a look at <a href=\"https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html#method.buffered\" rel=\"nofollow noreferrer\"><code>Stream::buffered</code></a> yet? Combine it with a (possibly <code>unsync</code>) channel, and maybe it does what you need.  You&#39;ll probably need to share the handle to the <code>mpsc::Sender</code> through (<code>Rc&lt;RefCell&lt;..&gt;&gt;</code> or <code>Arc&lt;Mutex&lt;..&gt;&gt;</code>) anyway."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "edited": false, "score": 1, "creation_date": 1516037285, "post_id": 48267479, "comment_id": 83518944, "body": "@Stefan why do you need the <code>Rc</code> / <code>Arc</code>? Shouldn&#39;t you be able to clone the <code>Sender</code>?"}, {"owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516037631, "post_id": 48267479, "comment_id": 83519127, "body": "@Shepmaster Right, it already does this itself, <code>clone</code> should be fine. I guess &quot;whenever I <code>clone</code> the tx it generates its own buffer&quot; confused me (that shouldn&#39;t be true, the buffer should get shared)."}, {"owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "edited": false, "score": 0, "creation_date": 1516037937, "post_id": 48267479, "comment_id": 83519297, "body": "Also <code>channel(1)</code> is a really small buffer considering you&#39;re building cyclic dependencies: if a request can trigger a new request, but has to wait to push a new one until it finishes, it will block forever. I&#39;d use <code>unbounded()</code> instead."}, {"owner": {"reputation": 1668, "user_id": 311358, "user_type": "registered", "accept_rate": 59, "profile_image": "https://www.gravatar.com/avatar/0b2b51e4cceb4a0c1609b81815001b69?s=128&d=identicon&r=PG", "display_name": "xrl", "link": "https://stackoverflow.com/users/311358/xrl"}, "edited": false, "score": 0, "creation_date": 1516038280, "post_id": 48267479, "comment_id": 83519460, "body": "Good point about the request triggering a new request causing a deadlock. For now I&#39;m just trying to get the core idea of a backpressure-pipeline of requests. I will take note of this as a future problem."}, {"owner": {"reputation": 1668, "user_id": 311358, "user_type": "registered", "accept_rate": 59, "profile_image": "https://www.gravatar.com/avatar/0b2b51e4cceb4a0c1609b81815001b69?s=128&d=identicon&r=PG", "display_name": "xrl", "link": "https://stackoverflow.com/users/311358/xrl"}, "reply_to_user": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "edited": false, "score": 0, "creation_date": 1516038334, "post_id": 48267479, "comment_id": 83519486, "body": "@Stefan @Shepmaster the generate its own buffer came from this bit of documentation: ` The channel capacity is equal to buffer + num-senders. In other words, each sender gets a guaranteed slot in the channel capacity, and on top of that there are buffer`."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516890236, "post_id": 48267479, "comment_id": 83881844, "body": "@xrl can you <a href=\"https://stackoverflow.com/posts/48267479/edit\">edit</a> your question to explain why using <code>Stream::buffered</code> doesn&#39;t work?"}], "answers": [{"tags": [], "owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "is_accepted": true, "score": 0, "last_activity_date": 1517307611, "last_edit_date": 1592644375, "creation_date": 1517307243, "answer_id": 48518874, "question_id": 48267479, "link": "https://stackoverflow.com/questions/48267479/controlling-the-number-of-spawned-futures-to-create-backpressure/48518874#48518874", "title": "Controlling the number of spawned futures to create backpressure", "body": "<p>As far as I can tell your problem with <a href=\"https://docs.rs/futures/0.1.18/futures/sync/mpsc/fn.channel.html\" rel=\"nofollow noreferrer\"><code>channel</code></a> is not that a single clone of the <a href=\"https://docs.rs/futures/0.1.18/futures/sync/mpsc/struct.Sender.html\" rel=\"nofollow noreferrer\"><code>Sender</code></a> increase the capacity by one, it is that you clone the <code>Sender</code> for every item you're trying to send.</p>\n<p>The error you're seeing without <code>clone</code> comes from your incorrect usage of the <code>Sink::send</code> interface.  With <code>clone</code> you actually should see the warning:</p>\n<pre class=\"lang-none prettyprint-override\"><code>warning: unused `futures::sink::Send` which must be used: futures do nothing unless polled\n</code></pre>\n<p>That is: your current code doesn't actually ever send anything!</p>\n<p>In order to apply backpressure you need to chain those <code>send</code> calls; each one should wait until the previous one finished (and you need to wait for the last one too!); on success you'll get the <code>Sender</code> back.  The best way to do this is to generate a <code>Stream</code> from your iterator by using <a href=\"https://docs.rs/futures/0.1.18/futures/stream/fn.iter_ok.html\" rel=\"nofollow noreferrer\"><code>iter_ok</code></a> and to pass it to <a href=\"https://docs.rs/futures/0.1.18/futures/sink/trait.Sink.html#method.send_all\" rel=\"nofollow noreferrer\"><code>send_all</code></a>.</p>\n<p>Now you got one future <code>SendAll</code> that you need to &quot;drive&quot;.  If you ignore the result and panic on error (<code>.then(|r| { r.unwrap(); Ok::&lt;(), ()&gt;(()) })</code>) you could spawn it as a separate task, but maybe you want to integrate it into your main application (i.e. return it in a <code>Box</code>).</p>\n<pre class=\"lang-rust prettyprint-override\"><code>// this returns a `Box&lt;Future&lt;Item = (), Error = ()&gt;&gt;`. you may\n// want to use a different error type\nBox::new(tx.send_all(iter_ok(data)).map(|_| ()).map_err(|_| ()))\n</code></pre>\n<h2><code>RusotoFuture::sync</code> and <code>Future::wait</code></h2>\n<p>Don't use <a href=\"https://docs.rs/futures/0.1.18/futures/future/trait.Future.html#method.wait\" rel=\"nofollow noreferrer\"><code>Future::wait</code></a>: it is already deprecated in a branch, and it usually won't do what you actually are looking for.  I doubt <code>RusotoFuture</code> is aware of the problems, so I recommend avoiding <code>RusotoFuture::sync</code>.</p>\n<h2>Cloning <code>Sender</code> increases channel capacity</h2>\n<p>As you correctly stated cloning <code>Sender</code> increases the capacity by one.</p>\n<p>This seems to be done to improve performance: A <code>Sender</code> starts in the unblocked (&quot;unparked&quot;) state; if a <code>Sender</code> isn't blocked it can send an item without blocking.  But if the number of items in the queue hits the configured limit when a <code>Sender</code> sends an item, the <code>Sender</code> becomes blocked (&quot;parked&quot;).  (Removing items from the queue will unblock the <code>Sender</code> at a certain time.)</p>\n<p>This means that after the inner queue hits the limit each <code>Sender</code> still can send one item, which leads to the documented effect of increased capacity, but only if actually all the <code>Sender</code>s are sending items - unused <code>Sender</code>s don't increase the observed capacity.</p>\n<p>The performance boost comes from the fact that as long as you don't hit the limit it doesn't need to park and notify tasks (which is quite heavy).</p>\n<p>The private documentation at the top of the <a href=\"https://docs.rs/futures/0.1.18/src/futures/sync/mpsc/mod.rs.html#30\" rel=\"nofollow noreferrer\"><code>mpsc</code></a> module describes more of the details.</p>\n"}], "owner": {"reputation": 1668, "user_id": 311358, "user_type": "registered", "accept_rate": 59, "profile_image": "https://www.gravatar.com/avatar/0b2b51e4cceb4a0c1609b81815001b69?s=128&d=identicon&r=PG", "display_name": "xrl", "link": "https://stackoverflow.com/users/311358/xrl"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 756, "favorite_count": 0, "accepted_answer_id": 48518874, "answer_count": 1, "score": 10, "last_activity_date": 1517307611, "creation_date": 1516035278, "last_edit_date": 1516037015, "question_id": 48267479, "link": "https://stackoverflow.com/questions/48267479/controlling-the-number-of-spawned-futures-to-create-backpressure", "title": "Controlling the number of spawned futures to create backpressure", "body": "<p>I am using a <a href=\"https://github.com/srijs/rusoto-async\" rel=\"noreferrer\">futures-rs powered version of the Rusoto AWS Kinesis library</a>. I need to spawn a deep pipeline of AWS Kinesis requests to achieve high-throughput because Kinesis has a limit of 500 records per HTTP request. Combined with the 50ms latency of sending a request, I need to start generating many concurrent requests. I am looking to create somewhere on the order of 100 in-flight requests.</p>\n\n<p>The Rusoto <code>put_records</code> function signature looks like this:</p>\n\n<pre><code>fn put_records(\n    &amp;self,\n    input: &amp;PutRecordsInput,\n) -&gt; RusotoFuture&lt;PutRecordsOutput, PutRecordsError&gt;\n</code></pre>\n\n<p>The <code>RusotoFuture</code> is a wrapper defined like this:</p>\n\n<pre><code>/// Future that is returned from all rusoto service APIs.\npub struct RusotoFuture&lt;T, E&gt; {\n    inner: Box&lt;Future&lt;Item = T, Error = E&gt; + 'static&gt;,\n}\n</code></pre>\n\n<p>The inner <code>Future</code> is wrapped but the <code>RusutoFuture</code> still implements <code>Future::poll()</code>, so I believe it is compatible with the <code>futures-rs</code>  ecosystem. The <code>RusotoFuture</code> provides a synchronization call:</p>\n\n<pre><code>impl&lt;T, E&gt; RusotoFuture&lt;T, E&gt; {\n    /// Blocks the current thread until the future has resolved.\n    ///\n    /// This is meant to provide a simple way for non-async consumers\n    /// to work with rusoto.\n    pub fn sync(self) -&gt; Result&lt;T, E&gt; {\n        self.wait()\n    }\n}\n</code></pre>\n\n<p>I can issue a request and <code>sync()</code> it, getting the result from AWS. I would like to create many requests, put them in some kind of queue/list, and gather finished requests. If the request errored I need to reissue the request (this is somewhat normal in Kinesis, especially when hitting limits on your shard throughput). If the request is completed successfully I should issue a request with new data. I could spawn a thread for each request and sync it but that seems inefficient when I have the async IO thread running.</p>\n\n<p>I have tried using <a href=\"https://docs.rs/futures/0.1.17/futures/sync/mpsc/fn.channel.html\" rel=\"noreferrer\"><code>futures::sync::mpsc::channel</code></a> from my application thread (not running from inside the Tokio reactor) but whenever I clone the <code>tx</code> it generates its own buffer, eliminating any kind of backpressure on <code>send</code>:</p>\n\n<pre><code>fn kinesis_pipeline(client: DefaultKinesisClient, stream_name: String, num_puts: usize, puts_size: usize) {\n    use futures::sync::mpsc::{ channel, spawn };\n    use futures::{ Sink, Future, Stream };\n    use futures::stream::Sender;\n    use rusoto_core::reactor::DEFAULT_REACTOR;\n\n    let client = Arc::new(KinesisClient::simple(Region::UsWest2));\n    let data = FauxData::new(); // a data generator for testing\n\n    let (mut tx, mut rx) = channel(1);\n\n    for rec in data {\n        tx.clone().send(rec);\n    }\n}\n</code></pre>\n\n<p>Without the clone, I have the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of moved value: `tx`\n   --&gt; src/main.rs:150:9\n    |\n150 |         tx.send(rec);\n    |         ^^ value moved here in previous iteration of loop\n    |\n    = note: move occurs because `tx` has type `futures::sync::mpsc::Sender&lt;rusoto_kinesis::PutRecordsRequestEntry&gt;`, which does not implement the `Copy` trait\n</code></pre>\n\n<p>I have also look at <a href=\"https://docs.rs/futures/0.1.17/futures/sync/mpsc/fn.spawn.html\" rel=\"noreferrer\"><code>futures::mpsc::sync::spawn</code></a> based on recommendations but it takes owner ship of the <code>rx</code> (as a <code>Stream</code>) and does not solve my problem with the <code>Copy</code> of <code>tx</code> causing unbounded behavior.</p>\n\n<p>I'm hoping if I can get the <code>channel</code>/<code>spawn</code> usage working, I will have a system which takes <code>RusotoFuture</code>s, waits for them to complete, and then provides me an easy way to grab completion results from my application thread.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1516035284, "post_id": 48267404, "comment_id": 83517996, "body": "<code>CString::new(&quot;OnAuthBegin&quot;).unwrap().as_ptr()</code> \u2014 <b>please</b> read the documentation for <code>as_ptr</code> to understand why that will crash your app (also <a href=\"https://stackoverflow.com/q/48235267/155423\">stackoverflow.com/q/48235267/155423</a>)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516035428, "post_id": 48267404, "comment_id": 83518071, "body": "<code>function: &amp;fn(size_t) -&gt; i32</code> \u2014 this is probably not what you want. This is a pointer to a function pointer. You probably just want <code>function: fn(size_t) -&gt; i32</code>. Also it seems like it should be <code>extern &quot;C&quot; fn ...</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516035735, "post_id": 48267404, "comment_id": 83518233, "body": "Your question is very unclear. What is the definition of <code>NowAuth_RegisterCallback</code>? Do you wish to pass both <code>OnAuthBegin</code> and <code>OnSuccess</code> as the <code>function</code> argument? That doesn&#39;t make sense. The library is going to call the callback with a fixed number of arguments and if your function doesn&#39;t accept them, then memory will be corrupted. Does <a href=\"https://stackoverflow.com/q/45514870/155423\">How do I call a C function which returns many types of different function pointers?</a> answer your question?"}, {"owner": {"reputation": 53, "user_id": 6499464, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cb05610859f3ada544979e05108e523f?s=128&d=identicon&r=PG&f=1", "display_name": "Seb", "link": "https://stackoverflow.com/users/6499464/seb"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516037952, "post_id": 48267404, "comment_id": 83519301, "body": "I&#39;m sorry my question is unclear. Its hard to describe it. Actually, I do want to pass both OnAuth an OnSuccess to my C function because it&#39;s a generic function who takes <i>void as parameter: Auth_RegisterCallback(Auth</i> ctx, const char* name, void* func, void* param). After that it register the callback with the name and associate the function (Onauth or OnSuccess) with it."}, {"owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "edited": false, "score": 1, "creation_date": 1516038135, "post_id": 48267404, "comment_id": 83519396, "body": "Either represent that &quot;generic&quot; pointer as <code>*c_void</code> and use <code>transmute</code> or import it with different names and types and <code>#[link_name = &quot;Auth_RegisterCallback&quot;]</code>."}], "answers": [{"comments": [{"owner": {"reputation": 53, "user_id": 6499464, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cb05610859f3ada544979e05108e523f?s=128&d=identicon&r=PG&f=1", "display_name": "Seb", "link": "https://stackoverflow.com/users/6499464/seb"}, "edited": false, "score": 0, "creation_date": 1516054325, "post_id": 48269006, "comment_id": 83526494, "body": "Also, after reading the Rust book <a href=\"https://doc.rust-lang.org/book/first-edition/ffi.html\" rel=\"nofollow noreferrer\">link</a> I&#39;ve realized that my callbacks are asynchronous and they are not triggered after being registered. I read that the async part of the callbacks with C is more complicated to implement because of the channels. I can&#39;t figure how to make this work with the channels and the threads. Can I use something like this: <a href=\"https://stackoverflow.com/questions/39216185/sending-channel-signal-from-a-closure\">link</a> ?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1516044423, "last_edit_date": 1516044423, "creation_date": 1516041973, "answer_id": 48269006, "question_id": 48267404, "link": "https://stackoverflow.com/questions/48267404/register-multiple-ffi-callbacks-with-different-function-signatures/48269006#48269006", "title": "Register multiple FFI callbacks with different function signatures", "body": "<p>If your FFI takes an arbitrary pointer, that's what you have to denote your function as taking. Use <code>libc::c_void</code> and cast the function pointers:</p>\n\n<pre><code>extern crate libc;\n\nuse libc::{c_char, size_t, c_void};\n\nuse std::ffi::CString;\n\nextern \"C\" {\n    fn Auth_RegisterCallback(\n        auth: size_t,\n        name: *const c_char,\n        function: *const c_void,\n        param: size_t,\n    );\n}\n\nfn authenticate() {\n    let auth = unimplemented!();\n    let param = unimplemented!();\n\n    unsafe {\n        Auth_RegisterCallback(\n            auth,\n            CString::new(\"OnAuthBegin\").unwrap().into_raw(), // Memory leak\n            on_auth_begin as *const _,\n            param,\n        );\n        Auth_RegisterCallback(\n            auth,\n            CString::new(\"OnSuccess\").unwrap().into_raw(), // Memory leak\n            on_success as *const _,\n            param,\n        )\n    };\n}\n\nfn on_auth_begin(auth: size_t) -&gt; i32 {\n    println!(\"Auth begin\");\n    return 1;\n}\n\nfn on_success(context: size_t, success: size_t) -&gt; i32 {\n    println!(\"Success\");\n    return 1;\n}\n</code></pre>\n\n<p>You may wish to add <em>some</em> type safety by creating multiple individual wrappers around the FFI function:</p>\n\n<pre><code>fn register_begin_callback(f: fn(ctx: size_t, arg1: u8)) {\n    let auth = unimplemented!();\n    let param = unimplemented!();\n\n    unsafe {\n        Auth_RegisterCallback(\n            auth,\n            CString::new(\"OnAuthBegin\").unwrap().into_raw(), // Memory leak\n            f as *const _,\n            param,\n        );\n    }\n}\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/45514870/155423\">How do I call a C function which returns many types of different function pointers?</a></li>\n</ul>\n"}], "owner": {"reputation": 53, "user_id": 6499464, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cb05610859f3ada544979e05108e523f?s=128&d=identicon&r=PG&f=1", "display_name": "Seb", "link": "https://stackoverflow.com/users/6499464/seb"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 161, "favorite_count": 0, "accepted_answer_id": 48269006, "answer_count": 1, "score": -1, "last_activity_date": 1516044423, "creation_date": 1516034973, "last_edit_date": 1516044180, "question_id": 48267404, "link": "https://stackoverflow.com/questions/48267404/register-multiple-ffi-callbacks-with-different-function-signatures", "title": "Register multiple FFI callbacks with different function signatures", "body": "<p>I'm trying to code some bindings between Rust and a C dynamic library. With help of the Rust book, I'm able to link the dynamic library and call foreign functions. </p>\n\n<p>My problem is that I have to register some callbacks to the C library but I'm not able to do it:</p>\n\n<pre><code>#[link(name = \"MyLibrary\")]\nextern \"C\" {\n    fn Auth_RegisterCallback(\n        auth: size_t,\n        name: *const c_char,\n        function: &amp;fn(size_t) -&gt; i32,\n        param: size_t,\n    );\n}\n\nfn Authenticate() {\n    unsafe {\n        Auth_RegisterCallback(\n            auth,\n            CString::new(\"OnAuthBegin\").unwrap().as_ptr(),\n            OnAuthBegin,\n            param,\n        )\n    };\n    unsafe {\n        NowAuth_RegisterCallback(\n            auth,\n            CString::new(\"OnSuccess\").unwrap().as_ptr(),\n            OnSuccess,\n            param,\n        )\n    };\n}\n\nfn OnAuthBegin(auth: size_t) -&gt; i32 {\n    println!(\"Auth begin\");\n    return 1;\n}\n</code></pre>\n\n<p>This code works fine because <code>Auth_RegisterCallback</code> in the extern block is expecting a function in parameter with one parameter of type <code>size_t</code>.</p>\n\n<p>My problem is that I have multiple callbacks to register with different signatures like: </p>\n\n<pre><code>fn OnSuccess(context: size_t, success: size_t) -&gt; i32 {\n    println!(\"Success\");\n    return 1;\n}\n</code></pre>\n\n<p>Is there a way to pass the functions in the parameters even though their signatures are different?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1516056552, "post_id": 48267112, "comment_id": 83527310, "body": "@mcarton the tricky thing is that it assumes there&#39;s One True Way to serialize a data structure. In addition, the specific serialization format is now part of the public API of the crate and can&#39;t be changed without a major version bump. I totally understand why many maintainers wouldn&#39;t want to take on that extra work."}, {"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1583451019, "post_id": 48267112, "comment_id": 107131495, "body": "To add, a note about <code>serialize_with</code> &amp; <code>deserialize_with</code>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 11, "last_activity_date": 1516056438, "last_edit_date": 1516056438, "creation_date": 1516034025, "answer_id": 48267112, "question_id": 48267016, "link": "https://stackoverflow.com/questions/48267016/is-there-a-way-for-me-to-use-derive-on-a-struct-or-enum-from-a-library-withou/48267112#48267112", "title": "Is there a way for me to use #[derive] on a struct or enum from a library without editing the actual library&#39;s source code?", "body": "<blockquote>\n  <p>Is there a way for me to use <code>#[derive]</code> on a struct or enum from a library without editing the actual library's source code?</p>\n</blockquote>\n\n<p>No, there is not.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/25413201/155423\">How do I implement a trait I don&#39;t own for a type I don&#39;t own?</a></li>\n</ul>\n\n<hr>\n\n<p>For the specific case of Serde, you can use <a href=\"https://serde.rs/remote-derive.html\" rel=\"noreferrer\">\"remote deriving\"</a>, but you have to provide a duplicate definition of the type, essentially rewriting the original structure.</p>\n\n<p>Many crates provide a feature flag to enable optional functionality, so you may want to look to see if your crate has one for Serde. If it doesn't, you could submit such to the library.</p>\n"}], "owner": {"reputation": 589, "user_id": 4352154, "user_type": "registered", "accept_rate": 69, "profile_image": "https://lh4.googleusercontent.com/-63Z0G5h6oFA/AAAAAAAAAAI/AAAAAAAAAHg/guAmotTzoqo/photo.jpg?sz=128", "display_name": "Kai Schmidt", "link": "https://stackoverflow.com/users/4352154/kai-schmidt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 512, "favorite_count": 0, "accepted_answer_id": 48267112, "answer_count": 1, "score": 3, "last_activity_date": 1516056438, "creation_date": 1516033683, "last_edit_date": 1516034044, "question_id": 48267016, "link": "https://stackoverflow.com/questions/48267016/is-there-a-way-for-me-to-use-derive-on-a-struct-or-enum-from-a-library-withou", "title": "Is there a way for me to use #[derive] on a struct or enum from a library without editing the actual library&#39;s source code?", "body": "<p>I am working on a Rust program that uses <a href=\"https://github.com/serde-rs/json\" rel=\"nofollow noreferrer\">serde-json</a>, and I really like the <code>#[derive(Serialize, Deserialize)]</code> macros that it gives for use with custom structs and enums. The macros work just fine with my own types. However, I would like to be able to call the macros on types from other libraries that I am using. </p>\n\n<p>I would implement the <code>Serialize</code> and <code>Deserialize</code> traits on those types myself, but the code for <code>Deserialize</code> is especially convoluted, and it would be a pain to write to for every single library type that I use in a struct.</p>\n"}, {"tags": ["reactjs", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 4, "creation_date": 1516028382, "post_id": 48265377, "comment_id": 83513843, "body": "Already done in <a href=\"https://github.com/DenisKolodin/yew\" rel=\"nofollow noreferrer\">yew</a>. Regardless, this question is far too broad for Stack Overflow."}, {"owner": {"reputation": 559, "user_id": 2358968, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/c924ddc496c7ec283fdbfb8f2c594539?s=128&d=identicon&r=PG", "display_name": "franleplant", "link": "https://stackoverflow.com/users/2358968/franleplant"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516110990, "post_id": 48265377, "comment_id": 83549522, "body": "Im rejecting the new tag &quot;webassembly&quot; because my original intent was to create a server side templating engine with this mechanism so Im not interested in cross compiling it to browser running code for now."}], "owner": {"reputation": 559, "user_id": 2358968, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/c924ddc496c7ec283fdbfb8f2c594539?s=128&d=identicon&r=PG", "display_name": "franleplant", "link": "https://stackoverflow.com/users/2358968/franleplant"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 331, "favorite_count": 0, "answer_count": 0, "score": 3, "last_activity_date": 1516027981, "creation_date": 1516027981, "question_id": 48265377, "link": "https://stackoverflow.com/questions/48265377/implementing-jsx-in-rust", "title": "Implementing JSX in Rust", "body": "<p>As an exercise I have been trying to implement something like <a href=\"https://facebook.github.io/jsx/\" rel=\"nofollow noreferrer\">JSX</a> in Rust with all the added benefits of static typing of props. The idea is to implement the data structures to support this feature and then add a simple syntactic layer with macros. JSX has the following important concepts:</p>\n\n<ul>\n<li>Very similar to XML/HTML, it's a data structure that represents a tree, and the nodes of a tree are Elements.</li>\n<li>Element: a simple data structure that represents a node in the tree, it's main attributes are: Type (Div, P or a Custom), Props (the arguments) and it's children (a vec of Elements)</li>\n<li>Custom Components: they provide the ability to encapsulate an Element subtree inside a \"function\" i.e. they are functions that return Elements. I worked with the assumption of supporting this custom render functionality through the Element.type attribute (see impl below)</li>\n<li>Custom Components are represented as Elements with a special type attribute. After they run their \"render\" function, they are replaced by the contents of it's render function in the final tree.</li>\n<li>Once the whole tree is resolved (each custom element is \"rendered\") the tree will only contain Native Elements (i.e. dom elements), this is the final tree\n\n<ul>\n<li>The final tree can be rendered to string by traversing it</li>\n</ul></li>\n</ul>\n\n<p>So, as a high level we could have:</p>\n\n<pre><code>create_element(\n  Div,\n  DivProps { id: \"myId\", class: \"one two three\", ..DivProps::default()}, \n  vec![   \n    create_element(P, PProps { ..PProps::default()}, vec![\n      \"Hello\" // Polymorphic\n    ])\n  ])\n</code></pre>\n\n<p>and then the idea is via macros provide the following syntax</p>\n\n<pre><code>&lt;div id=\"myId\" class=\"one two three\"&gt;\n  &lt;p&gt;Hello&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>One of the most problematic parts is that this naturally defines a data structure like this</p>\n\n<pre><code>struct Element&lt;T, P&gt;\n\nwhere\n T: String for native dom elements or a custom struct for custom components,\n P: Any data structure\n {\n  etype: T, \n  props: P,\n  children: vec![Element&lt;?, ?&gt;]\n}\n</code></pre>\n\n<p>I have been experimenting with several approaches but Im not super satisfied with the results and so this question is to find out if it is possible to do better or not. </p>\n\n<p>This is the current implementation that Im most satisfied with</p>\n\n<pre><code>type Children = Vec&lt;Rc&lt;Render&gt;&gt;;\n\ntrait ElementParts {\n    fn get_children(&amp;self) -&gt; Option&lt;&amp;Children&gt;;\n    fn get_tag(&amp;self) -&gt; String;\n}\n\n\n// Mostly for custom elements\ntrait Render: ElementParts + Debug + Display {\n    // Dom elements don't have to render anything\n    fn render(&amp;self) -&gt; Option&lt;Rc&lt;Render&gt;&gt; {\n        None\n    }\n\n    // Tell whether it's a custom component that will render more things or not.\n    fn should_render(&amp;self) -&gt; bool {\n        true\n    }\n\n    // TODO Ideally this should be outside this trait\n    // what bout if this is a standalong function\n    // that acepts a T: RenderToString where RenderToString: Render\n    // so, renderToString will have access to parts, render, should render, and anything else\n    fn render_to_string(&amp;self) -&gt; String {\n        if self.should_render() {\n            match self.render() {\n                Some(element) =&gt; element.render_to_string(),\n                None =&gt; String::new(),\n            }\n        } else {\n            format!(\"&lt;{tag}&gt;{}&lt;/{tag}&gt;\", self.render_children_to_string(), tag=self.get_tag())\n        }\n    }\n\n    fn render_children_to_string(&amp;self) -&gt; String {\n        if let Some(children) = self.get_children() {\n            children.iter()\n                .map(|child| child.render_to_string())\n                .collect::&lt;Vec&lt;String&gt;&gt;()\n                .join(\"\\n\")\n        } else {\n            String::new()\n        }\n    }\n}\n\n\n\n\n#[derive(Debug)]\nstruct Element&lt;T: Debug + Clone + 'static, P: Debug + Clone + 'static&gt; {\n    etype: T,\n    props: P,\n    children: Children,\n}\n\n\n\nimpl&lt;P: Debug + Clone + 'static, T: Debug + Clone + 'static&gt; Element&lt;T, P&gt; where Element&lt;T, P&gt;: Render {\n    fn new(etype: T, props: P, children: Children) -&gt; Rc&lt;Render&gt;\n    {\n\n\n\n        Rc::new(\n            Element {\n                etype: etype,\n                children: children,\n                props: props,\n            }\n        )\n    }\n}\n\n\nimpl&lt;P: Debug + Clone + 'static, T: Debug + Clone + 'static&gt; ElementParts for Element&lt;T, P&gt; {\n    fn get_children(&amp;self) -&gt; Option&lt;&amp;Children&gt; {\n        Some(&amp;self.children)\n    }\n\n    fn get_tag(&amp;self) -&gt; String {\n        format!(\"{:?}\", self.etype)\n    }\n}\n\n\nimpl&lt;P: Debug + Clone + 'static, T: Debug + Clone + 'static&gt; Display for Element&lt;T, P&gt; {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"- {:?},  {:?}\\n\", self.etype, self.props).unwrap();\n        for c in &amp;self.children {\n            write!(f, \"  {}\\n\", c).unwrap();\n        }\n\n        write!(f, \"\\n\")\n    }\n}\n\n\n// Text node\n\nimpl ElementParts for String {\n    fn get_children(&amp;self) -&gt; Option&lt;&amp;Children&gt; {\n        None\n    }\n\n    fn get_tag(&amp;self) -&gt; String {\n        \"TextNode\".to_string()\n    }\n\n}\n\nimpl Render for String {\n    fn should_render(&amp;self) -&gt; bool {\n        false\n    }\n\n    fn render_to_string(&amp;self) -&gt; String {\n        self.clone()\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct Div;\n\n#[derive(Debug, Clone)]\nstruct DivProps {\n    class: String,\n}\n\nimpl Render for Element&lt;Div, DivProps&gt; {\n    fn should_render(&amp;self) -&gt; bool {\n        false\n    }\n}\n\n\n#[derive(Debug, Clone)]\nstruct P;\n\n#[derive(Debug, Clone)]\nstruct PProps {\n    class: String,\n    text: Option&lt;String&gt;,\n}\n\nimpl Render for Element&lt;P, PProps&gt; {\n    fn should_render(&amp;self) -&gt; bool {\n        false\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct Name;\n\n#[derive(Debug, Clone)]\nstruct NameProps {\n    show: bool,\n    name: String,\n}\n\nimpl Render for Element&lt;Name, NameProps&gt; {\n    fn render(&amp;self) -&gt; Option&lt;Rc&lt;Render&gt;&gt; {\n        // In here custom logic will come\n        if !self.props.show {\n            return Some(Element::new(\n                    P,\n                    PProps{class: String::new(), text: None,},\n                    vec![\n                        Rc::new(\"NOT_SHOWING\".to_string()),\n                    ]\n                ))\n        }\n\n\n        Some(\n            Element::new(\n                Div,\n                DivProps { class: \"form-control\".to_string()},\n                vec![\n                    Rc::new(\"SHOWING\".to_string()),\n                    Rc::new(self.props.name.clone())\n                ]\n            )\n        )\n    }\n}\n\n// And this is how I would use it\n\n        let e = Element::new(Name, NameProps{ show: true, name: \"Fran\".to_string() }, vec![]);\n        println!(\"{:?}\", e);\n        println!(\"{}\", e.render_to_string());\n</code></pre>\n\n<p>Any ideas will be highly appreciated.</p>\n"}, {"tags": ["generics", "types", "casting", "rust", "traits"], "answers": [{"comments": [{"owner": {"reputation": 3212, "user_id": 2731452, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/xA89V.jpg?s=128&g=1", "display_name": "red75prime", "link": "https://stackoverflow.com/users/2731452/red75prime"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516025105, "post_id": 48263645, "comment_id": 83511935, "body": "@Shepmaster, it is not a case of ambiguous <code>Type</code>. It is a case of ambiguous <code>Trait</code>, fully qualified syntax thus is not required. <code>Trait::method()</code> is a shortened form of <code>&lt;Type as Trait&gt;::method()</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516025468, "post_id": 48263645, "comment_id": 83512158, "body": "I&#39;m not sure I&#39;m following you... UFCS was poorly named and was renamed to FQS. Your original answer stated that OP should use UFCS (thus FQS), but now your comment states that OP shouldn&#39;t use FQS."}, {"owner": {"reputation": 3212, "user_id": 2731452, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/xA89V.jpg?s=128&g=1", "display_name": "red75prime", "link": "https://stackoverflow.com/users/2731452/red75prime"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516026138, "post_id": 48263645, "comment_id": 83512563, "body": "Your first comment states that <code>Trait::method()</code> syntax is not FQS nor UFCS. I&#39;ve taken it for &quot;FQS is a specific name for <code>&lt;Type as Trait&gt;::method()</code> syntax and <code>Trait::method()</code> syntax has other name&quot; and answered accordingly."}, {"owner": {"reputation": 3212, "user_id": 2731452, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/xA89V.jpg?s=128&g=1", "display_name": "red75prime", "link": "https://stackoverflow.com/users/2731452/red75prime"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516026316, "post_id": 48263645, "comment_id": 83512673, "body": "In fact both <code>Trait::method()</code> (or <code>Trait::&lt;T1, T2, ... TN&gt;::method()</code>) and <code>&lt;Type as Trait&gt;::method()</code> (or <code>&lt;Type as Trait&lt;T1, T2, ... TN&gt;&gt;::method()</code>) are FQS. As stated in the book: &quot;However, we\u2019re allowed to leave out any part of this syntax that Rust is able to figure out from other information in the program.&quot;"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1516026754, "post_id": 48263645, "comment_id": 83512915, "body": "I&#39;m making the claim that <code>Trait::method()</code> is <i>not</i> FQS, I believe that only the forms with angle brackets are FQS (<code>&lt;Trait&gt;::method</code> / <code>&lt;Type as Trait&gt;::method</code>). The code in the answer is just using a turbofish to fill in type parameters. Likewise, <code>iterator.collect::&lt;Foo&gt;</code> isn&#39;t using FQS."}, {"owner": {"reputation": 3212, "user_id": 2731452, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/xA89V.jpg?s=128&g=1", "display_name": "red75prime", "link": "https://stackoverflow.com/users/2731452/red75prime"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516027733, "post_id": 48263645, "comment_id": 83513464, "body": "The fact is <code>Trait::&lt;T&gt;::method(receiver)</code> does exactly the same thing as <code>&lt;_ as Trait&lt;T&gt;&gt;::method(receiver)</code>, but I don&#39;t insist on calling it FQS."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516028268, "post_id": 48263645, "comment_id": 83513777, "body": "OK, I&#39;ve applied my pedantic changes. ;-)"}], "tags": [], "owner": {"reputation": 3212, "user_id": 2731452, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/xA89V.jpg?s=128&g=1", "display_name": "red75prime", "link": "https://stackoverflow.com/users/2731452/red75prime"}, "is_accepted": false, "score": 2, "last_activity_date": 1516028562, "last_edit_date": 1516028562, "creation_date": 1516021656, "answer_id": 48263645, "question_id": 48263001, "link": "https://stackoverflow.com/questions/48263001/what-is-a-concise-way-to-inform-the-compiler-of-the-specifc-type-with-multiple-i/48263645#48263645", "title": "What is a concise way to inform the compiler of the specifc type with multiple implementations of a generic trait?", "body": "<p>Pass the type parameter to the trait using a <em>turbofish</em> (<code>::&lt;&gt;</code>):</p>\n\n<pre><code>assert_eq!(\"asd\", Foo::&lt;&amp;str&gt;::foo(&amp;bar));\n</code></pre>\n\n<p>You could also use <a href=\"https://doc.rust-lang.org/book/second-edition/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation\" rel=\"nofollow noreferrer\">fully-qualified syntax</a> to disambiguate which trait the method belongs to:</p>\n\n<pre><code>// This is \"type-qualified\" and equivalent to `Foo::&lt;&amp;str&gt;::foo(&amp;bar)`\nassert_eq!(\"asd\", &lt;_ as Foo&lt;&amp;str&gt;&gt;::foo(&amp;bar));\n\n// This is \"fully qualified\"\nassert_eq!(\"asd\", &lt;Bar as Foo&lt;&amp;str&gt;&gt;::foo(&amp;bar));\n</code></pre>\n"}], "owner": {"reputation": 11, "user_id": 3545526, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/556f7ebf3425a7d233ad61767ea21805?s=128&d=identicon&r=PG&f=1", "display_name": "user210325", "link": "https://stackoverflow.com/users/3545526/user210325"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 210, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1516028562, "creation_date": 1516019119, "last_edit_date": 1516025533, "question_id": 48263001, "link": "https://stackoverflow.com/questions/48263001/what-is-a-concise-way-to-inform-the-compiler-of-the-specifc-type-with-multiple-i", "title": "What is a concise way to inform the compiler of the specifc type with multiple implementations of a generic trait?", "body": "<p>I've come across an odd type inference problem that has me scratching my head a bit.</p>\n\n<p>I'm implementing a generic trait on a struct for multiple types. I started with <code>&amp;str</code>:</p>\n\n<pre><code>struct Bar&lt;'a&gt; {\n    baz: &amp;'a str,\n}\n\ntrait Foo&lt;T&gt; {\n    fn foo(&amp;self) -&gt; T;\n}\n\nimpl&lt;'a&gt; Foo&lt;&amp;'a str&gt; for Bar&lt;'a&gt; {\n    fn foo(&amp;self) -&gt; &amp;'a str {\n        self.baz\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_str_a() {\n        let bar = Bar { baz: \"asd\" };\n        assert_eq!(\"asd\", bar.foo());\n    }\n}\n</code></pre>\n\n<p>This works \u2014 the problem comes when I add another implementation for the <code>u8</code> type:</p>\n\n<pre><code>struct Bar&lt;'a&gt; {\n    baz: &amp;'a str,\n}\n\ntrait Foo&lt;T&gt; {\n    fn foo(&amp;self) -&gt; T;\n}\n\nimpl&lt;'a&gt; Foo&lt;&amp;'a str&gt; for Bar&lt;'a&gt; {\n    fn foo(&amp;self) -&gt; &amp;'a str {\n        self.baz\n    }\n}\n\nimpl&lt;'a&gt; Foo&lt;u8&gt; for Bar&lt;'a&gt; {\n    fn foo(&amp;self) -&gt; u8 {\n        8\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_str_a() {\n        let bar = Bar { baz: \"asd\" };\n        assert_eq!(\"asd\", bar.foo());\n    }\n\n    #[test]\n    fn test_u8() {\n        let bar = Bar { baz: \"asd\" };\n        assert_eq!(8 as u8, bar.foo());\n    }\n}\n</code></pre>\n\n<p>In this case, I get the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0283]: type annotations required: cannot resolve `Bar&lt;'_&gt;: Foo&lt;_&gt;`\n  --&gt; src/main.rs:28:31\n   |\n28 |         assert_eq!(\"asd\", bar.foo());\n   |                               ^^^\n</code></pre>\n\n<p>If I store the value in a variable it works:</p>\n\n<pre><code>let foo: &amp;str = bar.foo();\n</code></pre>\n\n<p>In my production code, I do a lot of asserts and it would make things a bit messy. I've also tried <code>bar.foo() as &amp;str</code> but that also fails as the compiler doesn't know <code>bar.foo()</code>'s type either. I'm trying to find a concise way for the compiler to know the type.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "edited": false, "score": 1, "creation_date": 1516007335, "post_id": 48259716, "comment_id": 83502264, "body": "if you&#39;re interested in only one of the branches, you can use <code>if let</code>. <a href=\"https://play.rust-lang.org/?gist=a4c62e49861b30ec86dba28d594166a7&amp;version=stable\" rel=\"nofollow noreferrer\">Example</a>"}, {"owner": {"reputation": 22380, "user_id": 284111, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/7540f1aac4d78cc963f6551e8307b757?s=128&d=identicon&r=PG", "display_name": "Andrew Savinykh", "link": "https://stackoverflow.com/users/284111/andrew-savinykh"}, "reply_to_user": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "edited": false, "score": 0, "creation_date": 1516007376, "post_id": 48259716, "comment_id": 83502285, "body": "@PaoloFalabella yes, but then you need separately unwrap the result. Thanks you for the tip, though."}, {"owner": {"reputation": 838, "user_id": 3613212, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/NfaGR.png?s=128&g=1", "display_name": "Gr&#233;gory OBANOS", "link": "https://stackoverflow.com/users/3613212/gr%c3%a9gory-obanos"}, "edited": false, "score": 0, "creation_date": 1516007644, "post_id": 48259716, "comment_id": 83502422, "body": "@AndrewSavinykh no you don&#39;t, you can use pattern matching in <code>if let</code>. see <a href=\"https://doc.rust-lang.org/book/second-edition/ch06-03-if-let.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/book/second-edition/ch06-03-if-let.html</a>"}, {"owner": {"reputation": 3212, "user_id": 2731452, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/xA89V.jpg?s=128&g=1", "display_name": "red75prime", "link": "https://stackoverflow.com/users/2731452/red75prime"}, "edited": false, "score": 4, "creation_date": 1516008909, "post_id": 48259716, "comment_id": 83503020, "body": "You can write your own version of <code>try!</code> macro. <a href=\"https://play.rust-lang.org/?gist=c0a64b2b5d1e52b9a9193bc4f989e51a&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a>"}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "reply_to_user": {"reputation": 22380, "user_id": 284111, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/7540f1aac4d78cc963f6551e8307b757?s=128&d=identicon&r=PG", "display_name": "Andrew Savinykh", "link": "https://stackoverflow.com/users/284111/andrew-savinykh"}, "edited": false, "score": 0, "creation_date": 1516041290, "post_id": 48259716, "comment_id": 83520853, "body": "Let us <a href=\"http://chat.stackoverflow.com/rooms/163205/discussion-between-trentcl-and-andrew-savinykh\">continue this discussion in chat</a>."}, {"owner": {"reputation": 103, "user_id": 6846811, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-h8WAsUD7Vzo/AAAAAAAAAAI/AAAAAAAAA3U/iYDqiccHoLE/photo.jpg?sz=128", "display_name": "Mateus Costa", "link": "https://stackoverflow.com/users/6846811/mateus-costa"}, "edited": false, "score": 0, "creation_date": 1586067946, "post_id": 48259716, "comment_id": 107985489, "body": "You may want to take a look also in the answers here: <a href=\"https://stackoverflow.com/questions/49785136/is-there-a-shortcut-to-unwrap-or-continue-in-a-loop\" title=\"is there a shortcut to unwrap or continue in a loop\">stackoverflow.com/questions/49785136/&hellip;</a>"}], "answers": [{"tags": [], "owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "is_accepted": false, "score": 5, "last_activity_date": 1516021937, "creation_date": 1516021937, "answer_id": 48263709, "question_id": 48259716, "link": "https://stackoverflow.com/questions/48259716/is-there-a-compact-and-idiomatic-way-to-print-an-error-and-return-without-return/48263709#48263709", "title": "Is there a compact and idiomatic way to print an error and return without returning the error?", "body": "<p>As an alternative to a custom <code>macro_rule</code> you could also use <code>?</code> with <code>Option&lt;T&gt;</code> and a trait extension for <code>Result</code> to print errors and convert successful values.</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=6fa877ee6b209bdab36f18a117610f2a&amp;version=stable\" rel=\"noreferrer\">Playground</a></p>\n\n<pre><code>pub trait ResultOkPrintErrExt&lt;T&gt; {\n    fn ok_or_print_err(self, msg: &amp;str) -&gt; Option&lt;T&gt;;\n}\n\nimpl&lt;T, E&gt; ResultOkPrintErrExt&lt;T&gt; for Result&lt;T, E&gt;\nwhere\n    E: ::std::fmt::Debug,\n{\n    fn ok_or_print_err(self, msg: &amp;str) -&gt; Option&lt;T&gt; {\n        match self {\n            Ok(v) =&gt; Some(v),\n            Err(e) =&gt; {\n                eprintln!(\"{}: {:?}\", msg, e);\n                None\n            }\n        }\n    }\n}\n\nfn read_input() -&gt; Result&lt;u32, ()&gt; {\n    // Ok(5)\n    Err(())\n}\n\nfn run() -&gt; Option&lt;()&gt; {\n    let v: u32 = read_input().ok_or_print_err(\"invalid input\")?;\n    println!(\"got input: {}\", v);\n    Some(())\n}\n\nfn main() {\n    run();\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "is_accepted": true, "score": 4, "last_activity_date": 1516047732, "last_edit_date": 1516047732, "creation_date": 1516046292, "answer_id": 48269846, "question_id": 48259716, "link": "https://stackoverflow.com/questions/48259716/is-there-a-compact-and-idiomatic-way-to-print-an-error-and-return-without-return/48269846#48269846", "title": "Is there a compact and idiomatic way to print an error and return without returning the error?", "body": "<blockquote>\n  <p>I don't feel that propagation will help with the scenario when you need slightly different processing in case of the error like in the scenario described above. This is because the particular differences in handling belong right here, not up the stack.</p>\n</blockquote>\n\n<p>This is something a custom error type can help with. In this case you have a common behavior (\"log an error\") and you want to do that in slightly different ways for different values. It makes sense to move the \"log an error\" part up to the caller (let's call the function <code>try_poll</code>):</p>\n\n<pre><code>loop {\n    if let Err(e) = try_poll() {\n        println!(\"{}\", e);\n    }\n    sleep(100);\n}\n</code></pre>\n\n<p>And create a type that implements <code>Display</code>, and <code>From&lt;E&gt;</code> for each error type <code>E</code>:</p>\n\n<pre><code>enum PollError {\n    NetworkError(NetworkError),\n    JsonParseError(JsonParseError),\n}\n\nimpl fmt::Display for PollError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match *self {\n            PollError::NetworkError(ref e) =&gt; write!(f, \"Error downloading file: {:?}\", e),\n            PollError::JsonParseError(ref e) =&gt; write!(f, \"Error parsing JSON: {:?}\", e),\n        }\n    }\n}\n\nimpl From&lt;NetworkError&gt; for PollError {\n    fn from(e: NetworkError) -&gt; Self {\n        PollError::NetworkError(e)\n    }\n}\n\nimpl From&lt;JsonParseError&gt; for PollError {\n    fn from(e: JsonParseError) -&gt; Self {\n        PollError::JsonParseError(e)\n    }\n}\n</code></pre>\n\n<p>Now you can use <code>?</code> to propagate the error, but the caller still doesn't have to be concerned with which error specifically it is.</p>\n\n<pre><code>fn try_poll() -&gt; Result&lt;(), PollError&gt; {\n    let data = try_fetch_content()?;\n    let json = try_parse_json(data)?;\n    println!(\"Parsed {:?}\", json);\n    Ok(())\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=216f1583961b61e8e6fa72e1c25ab5ab&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a>)</p>\n\n<hr>\n\n<h3>Ok, I want that, but without all the <code>From</code> implementations.</h3>\n\n<p>The tedious part about this is all the <code>impl From</code>s, which are necessary because of the custom error type. If the only thing that will ever be done with an error is log and ignore it, a custom error type is not particularly useful -- the only thing that really needs to be returned is the error message itself.</p>\n\n<p>In that case, have <code>try_poll</code> instead return <code>Result&lt;(), String&gt;</code>, and use <code>Result::map_err</code> to turn each individual error immediately into an error message, before using <code>?</code> to propagate it:</p>\n\n<pre><code>fn try_poll() -&gt; Result&lt;(), String&gt; {\n    let data = try_fetch_content()\n        .map_err(|e| format!(\"Error downloading file: {:?}\", e))?;\n    let json = try_parse_json(data)\n        .map_err(|e| format!(\"Error parsing JSON: {:?}\", e))?;\n    println!(\"Parsed {:?}\", json);\n    Ok(())\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=76e1e818c2490b43a71588050e0b91c4&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a>)</p>\n\n<p>The <a href=\"https://doc.rust-lang.org/book/first-edition/error-handling.html#defining-your-own-error-type\" rel=\"nofollow noreferrer\">first edition of <em>The Rust Programming Language</em></a> has this to say about <code>String</code> as an error type:</p>\n\n<blockquote>\n  <p>A rule of thumb is to define your own error type, but a <code>String</code> error type will do in a pinch, particularly if you're writing an application. If you're writing a library, defining your own error type should be strongly preferred so that you don't remove choices from the caller unnecessarily.</p>\n</blockquote>\n"}], "owner": {"reputation": 22380, "user_id": 284111, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/7540f1aac4d78cc963f6551e8307b757?s=128&d=identicon&r=PG", "display_name": "Andrew Savinykh", "link": "https://stackoverflow.com/users/284111/andrew-savinykh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 659, "favorite_count": 0, "accepted_answer_id": 48269846, "answer_count": 2, "score": 6, "last_activity_date": 1614662318, "creation_date": 1516006905, "last_edit_date": 1614662318, "question_id": 48259716, "link": "https://stackoverflow.com/questions/48259716/is-there-a-compact-and-idiomatic-way-to-print-an-error-and-return-without-return", "title": "Is there a compact and idiomatic way to print an error and return without returning the error?", "body": "<p>I'm writing a function that will be called in an infinite loop and only execute something when getting well-formed data from a web-service. If the service is down, returns non-json, or returns json we do not understand, the function should just log the error and return (to be called again after a pause).</p>\n<p>I found myself copying and pasting something like this:</p>\n<pre><code>let v = match v {\n    Ok(data) =&gt; data,\n    Err(error) =&gt; {\n        println!(&quot;Error decoding json: {:?}&quot;, error);\n        return;\n    }\n};\n</code></pre>\n<p>The body of the error matcher would be different each time. Sometimes it's panic, sometimes it has different messages, and sometimes elements of <code>error</code> could be broken down further to form a better message, but the rest of the construct would be the same.</p>\n<p>Is there a shorthand for this? I'm aware of the <code>?</code> <a href=\"https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\" rel=\"nofollow noreferrer\">syntax</a>, but that's for propagation. I don't feel that propagation will help with the scenario when you need slightly different processing in case of the error like in the scenario described above. This is because the particular differences in handling belong right here, not up the stack.</p>\n<p>I have not written a lot of code in Rust yet so it is very likely that I'm missing something obvious.</p>\n<p>In C#, the above would look something like this:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>if (v == null)\n{\n  Console.WriteLine(&quot;Error decoding json!&quot;);\n  return;\n}\n</code></pre>\n<p>or</p>\n<pre><code>if (error != null)\n{\n  Console.WriteLine($&quot;Error decoding json: {error}&quot;);\n  return;\n}\n</code></pre>\n<p>both of which is much less verbose than in Rust.</p>\n<p>If I understood the comments below, one way of shortening would be something like this:</p>\n<pre><code>if let Err(error) = v {\n    println!(&quot;Error decoding json: {:?}&quot;, error);\n    return;\n}\nlet v = v.unwrap();\n</code></pre>\n<p>This looks more compact, thank you. Is this idiomatic? Would you write it this way?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "edited": false, "score": 1, "creation_date": 1516004381, "post_id": 48258550, "comment_id": 83500898, "body": "Please also add the compiler error."}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 2, "creation_date": 1516004554, "post_id": 48258550, "comment_id": 83500960, "body": "&quot;So could anyone enlighten me with the correct way to do this?&quot; What is &quot;this&quot;? What is it that you want to do?"}, {"owner": {"reputation": 5308, "user_id": 4038191, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/10ec10e81b5315fe2147c38bf3e15e9e?s=128&d=identicon&r=PG", "display_name": "EvilTak", "link": "https://stackoverflow.com/users/4038191/eviltak"}, "edited": false, "score": 1, "creation_date": 1516008178, "post_id": 48258550, "comment_id": 83502657, "body": "Why would you not make <code>S</code> generic to allow any type?"}, {"owner": {"reputation": 13, "user_id": 6302695, "user_type": "registered", "profile_image": "https://lh6.googleusercontent.com/-OMRtSF6RbkA/AAAAAAAAAAI/AAAAAAAAADI/Ax1BbYWJtOU/photo.jpg?sz=128", "display_name": "framlog", "link": "https://stackoverflow.com/users/6302695/framlog"}, "edited": false, "score": 0, "creation_date": 1516018573, "post_id": 48258550, "comment_id": 83508430, "body": "The compiler error is something like <code>expect </code>std::any::Any + &#39;static<code>, found </code>std::any::Any``. Thus, after I set lifetime properly, this error has been fixed. I think the problem&#39;s gone. However, I&#39;m still a little bewildered with the combination of lifetime and trait declaration in generic type declaration."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516023557, "post_id": 48258550, "comment_id": 83511090, "body": "<a href=\"https://doc.rust-lang.org/book/second-edition/\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i></a> has an <a href=\"https://doc.rust-lang.org/book/second-edition/ch10-00-generics.html\" rel=\"nofollow noreferrer\"><i>entire chapter</i></a> on generics."}], "answers": [{"comments": [{"owner": {"reputation": 13, "user_id": 6302695, "user_type": "registered", "profile_image": "https://lh6.googleusercontent.com/-OMRtSF6RbkA/AAAAAAAAAAI/AAAAAAAAADI/Ax1BbYWJtOU/photo.jpg?sz=128", "display_name": "framlog", "link": "https://stackoverflow.com/users/6302695/framlog"}, "edited": false, "score": 0, "creation_date": 1516018383, "post_id": 48259209, "comment_id": 83508358, "body": "Yeap, I know I can&#39;t use <code>_</code> in that place. I just wanna express the idea of <code>Any</code>. Thanks anyway."}], "tags": [], "owner": {"reputation": 1699, "user_id": 783825, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/cce2622c5ccd49a3cbf2007491ab1075?s=128&d=identicon&r=PG", "display_name": "Neikos", "link": "https://stackoverflow.com/users/783825/neikos"}, "is_accepted": false, "score": 3, "last_activity_date": 1516023397, "last_edit_date": 1516023397, "creation_date": 1516004710, "answer_id": 48259209, "question_id": 48258550, "link": "https://stackoverflow.com/questions/48258550/store-any-type-in-a-struct-field/48259209#48259209", "title": "Store any type in a struct field", "body": "<p>You cannot use <code>_</code> in a struct declaration; the compiler needs to know the struct's size at compile time.</p>\n\n<p>If you want the type to be generic you can add a type parameter to <code>S</code> just as you did to <code>CallbackWithArgs</code>:</p>\n\n<pre><code>struct CallbackWithArgs&lt;T&gt; {\n    callback: Box&lt;Fn(&amp;mut T) -&gt; ()&gt;,\n    arg: RefCell&lt;T&gt;,\n}\n\nstruct S&lt;T&gt; {\n    args: CallbackWithArgs&lt;T&gt;,\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=c87c1a3fb6908c01a8e3475a10869653&amp;version=stable\" rel=\"nofollow noreferrer\">Playground Link</a></p>\n\n<p>For an explanation of <code>_</code>, see <a href=\"https://stackoverflow.com/questions/34363984/what-is-vec\">What is Vec&lt;_&gt;?</a></p>\n"}], "owner": {"reputation": 13, "user_id": 6302695, "user_type": "registered", "profile_image": "https://lh6.googleusercontent.com/-OMRtSF6RbkA/AAAAAAAAAAI/AAAAAAAAADI/Ax1BbYWJtOU/photo.jpg?sz=128", "display_name": "framlog", "link": "https://stackoverflow.com/users/6302695/framlog"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 827, "favorite_count": 0, "answer_count": 1, "score": -1, "last_activity_date": 1516023500, "creation_date": 1516001194, "last_edit_date": 1516023500, "question_id": 48258550, "link": "https://stackoverflow.com/questions/48258550/store-any-type-in-a-struct-field", "title": "Store any type in a struct field", "body": "<p>I'm working on code like the following:</p>\n\n<pre><code>use std::cell::RefCell;\n\nstruct CallbackWithArgs&lt;T&gt; {\n    callback: Box&lt;Fn(&amp;mut T) -&gt; ()&gt;,\n    arg: RefCell&lt;T&gt;,\n}\n\nstruct S {\n    args: CallbackWithArgs&lt;_&gt;,\n}\n</code></pre>\n\n<p>The compiler has an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n --&gt; src/main.rs:9:28\n  |\n9 |     args: CallbackWithArgs&lt;_&gt;,\n  |                            ^ not allowed in type signatures\n</code></pre>\n\n<p>What is the correct way to do this?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 239, "user_id": 5228128, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-Bt_L37uIuhg/AAAAAAAAAAI/AAAAAAAAADo/an2RinFD9lE/photo.jpg?sz=128", "display_name": "moskalenco_a", "link": "https://stackoverflow.com/users/5228128/moskalenco-a"}, "is_accepted": true, "score": 4, "last_activity_date": 1515997875, "creation_date": 1515997875, "answer_id": 48257955, "question_id": 48257867, "link": "https://stackoverflow.com/questions/48257867/how-to-output-in-rust/48257955#48257955", "title": "How to output &quot;{}&quot; in Rust", "body": "<pre><code>println!(\"{{}}\"); // 1\nprintln!(\"{}\", \"{}\"); // 2\n</code></pre>\n"}], "owner": {"reputation": 455, "user_id": 9218031, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e130f1944fa76209ad76e225df9e4786?s=128&d=identicon&r=PG&f=1", "display_name": "Desert Digital", "link": "https://stackoverflow.com/users/9218031/desert-digital"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 287, "favorite_count": 0, "closed_date": 1515997903, "accepted_answer_id": 48257955, "answer_count": 1, "score": 1, "last_activity_date": 1515997875, "creation_date": 1515997276, "question_id": 48257867, "link": "https://stackoverflow.com/questions/48257867/how-to-output-in-rust", "closed_reason": "Duplicate", "title": "How to output &quot;{}&quot; in Rust", "body": "<p>I was wondering how to output closed brackets \"{}\" in Rust.</p>\n\n<p>I've tried the following</p>\n\n<ul>\n<li><code>println!(\"{}\");</code></li>\n<li><code>println!('{}');</code></li>\n<li><code>println!(</code>{}<code>);</code></li>\n</ul>\n"}, {"tags": ["rust"], "owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 679, "favorite_count": 0, "closed_date": 1515982125, "answer_count": 0, "score": 5, "last_activity_date": 1515983125, "creation_date": 1515979683, "last_edit_date": 1515983125, "question_id": 48255891, "link": "https://stackoverflow.com/questions/48255891/what-is-self-boxself-on-a-method", "closed_reason": "Duplicate", "title": "What is &#39;self: Box&lt;Self&gt;&#39; on a method?", "body": "<p>I've seen a few instances of this sort of pattern in Rust code:</p>\n\n<pre><code>trait Task {\n    fn run(self: Box&lt;Self&gt;) -&gt; i32;\n}\n\nstruct SomeTask {}\n\nimpl Task for SomeTask {\n    fn run(self: Box&lt;SomeTask&gt;) -&gt; i32 {\n        1\n    }\n}\n\nfn main() {\n    let task: Box&lt;Task&gt; = Box::new(SomeTask {});\n    task.run();\n}\n</code></pre>\n\n<p>Now... I understand the intent of this code, it's a trait that implements the self consuming pattern:</p>\n\n<pre><code>fn foo(self);\n</code></pre>\n\n<p>Ok... but what?</p>\n\n<p>You can qualify self as something other than <code>Self</code>? Are there other things self can be, other than <code>Self</code>, <code>&amp;Self</code>, <code>&amp;mut Self</code> and, apparently <code>Box&lt;Self&gt;</code>?</p>\n\n<p>Why does this feature exist, given you can already do this without it:</p>\n\n<pre><code>trait Runnable {\n    fn run(self) -&gt; i32;\n}\n\ntrait Task {\n    fn value(&amp;self) -&gt; i32;\n}\n\nstruct SomeTask {}\n\nimpl Runnable for Box&lt;Task&gt; {\n    fn run(self: Box&lt;Task&gt;) -&gt; i32 {\n        self.value()\n    }\n}\n\nimpl Task for SomeTask {\n    fn value(&amp;self) -&gt; i32 {\n        1\n    }\n}\n\nfn main() {\n    let s: Box&lt;Task&gt; = Box::new(SomeTask {});\n    s.run();\n}\n</code></pre>\n\n<p>It feels a little bit like this is left-over cruft from missing <code>box foo</code> syntax, where they really wanted to allow <code>fn foo(box self)</code>, but it was inconsistent without box syntax existing in the first place... but I still don't understand what the functional purpose of this receiver type is.</p>\n\n<p>(Edit, since the related question is ancient and doesn't specifically answer the question. See <a href=\"https://github.com/rust-lang/rust/issues/44874\" rel=\"nofollow noreferrer\">https://github.com/rust-lang/rust/issues/44874</a> for the ongoing discussion around this issue; tldr: Apparently arbitrary receiver types are a thing, and they're on the way but not stable yet)</p>\n"}, {"tags": ["rust", "thread-safety", "lifetime"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1515983092, "creation_date": 1515983092, "answer_id": 48256216, "question_id": 48255263, "link": "https://stackoverflow.com/questions/48255263/sharing-a-struct-with-trait-objects-as-properties-across-threads/48256216#48256216", "title": "Sharing a struct with trait objects as properties across threads", "body": "<p>I find the error message pretty straightforward:</p>\n\n<ul>\n<li>the trait <code>std::marker::Send</code> is not implemented for <code>Expr + 'static</code></li>\n<li>required because of the requirements on the impl of <code>std::marker::Send</code> for <code>std::sync::Arc&lt;Expr + 'static&gt;</code></li>\n<li>required because it appears within the type <code>Container</code></li>\n<li>required because of the requirements on the impl of <code>std::marker::Send</code> for <code>std::sync::Arc&lt;Container&gt;</code></li>\n<li>required because it appears within the type <code>[closure@src/main.rs:64:33: 67:6 container1:std::sync::Arc&lt;Container&gt;]</code></li>\n<li>required by <code>std::thread::spawn</code></li>\n</ul>\n\n<p>You are trying to move your <code>Arc&lt;Container&gt;</code> to another thread, but it contains an <code>Arc&lt;Expr + 'static&gt;</code>, which cannot be guaranteed to be safely sent (<code>Send</code>) or shared (<code>Sync</code>) across threads.</p>\n\n<p>Either add <code>Send</code> and <code>Sync</code> as supertraits to Expr:</p>\n\n<pre><code>pub trait Expr: Send + Sync { /* ... */ }\n</code></pre>\n\n<p>Or add them as trait bounds to your trait objects:</p>\n\n<pre><code>pub struct AddExpr {\n    expr1: Box&lt;Expr + Send + Sync&gt;,\n    expr2: Box&lt;Expr + Send + Sync&gt;,\n}\n\nimpl AddExpr {\n    pub fn new(expr1: Box&lt;Expr + Send + Sync&gt;, expr2: Box&lt;Expr + Send + Sync&gt;) -&gt; Self {\n        Self { expr1, expr2 }\n    }\n}\n\nstruct Container {\n    x: i32,\n    cached_expr: Arc&lt;Expr + Send + Sync&gt;,\n}\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/29540407/155423\">How can I share references across threads?</a></li>\n<li><a href=\"https://stackoverflow.com/q/46491293/155423\">Multithreaded application fails to compile with error-chain</a></li>\n<li><a href=\"https://stackoverflow.com/q/45690958/155423\">Is there any way to implement the Send trait for ZipFile?</a></li>\n<li><a href=\"https://stackoverflow.com/q/40035731/155423\">How do I share a generic struct between threads using Arc&lt;Mutex&lt;MyStruct&lt;T&gt;&gt;&gt;?</a></li>\n</ul>\n"}], "owner": {"reputation": 691, "user_id": 550496, "user_type": "registered", "accept_rate": 32, "profile_image": "https://www.gravatar.com/avatar/0c625b9f4b1a2e5fbf53ec87f30e8bd0?s=128&d=identicon&r=PG", "display_name": "Adriano dos Santos Fernandes", "link": "https://stackoverflow.com/users/550496/adriano-dos-santos-fernandes"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1206, "favorite_count": 1, "accepted_answer_id": 48256216, "answer_count": 1, "score": 1, "last_activity_date": 1515983240, "creation_date": 1515973014, "last_edit_date": 1515983240, "question_id": 48255263, "link": "https://stackoverflow.com/questions/48255263/sharing-a-struct-with-trait-objects-as-properties-across-threads", "title": "Sharing a struct with trait objects as properties across threads", "body": "<p>I have the code below. With the commented out parts, it's working. When I uncomment the parts it does not compile anymore.</p>\n\n<p>How can I adjust the commented parts to make them work, i.e., I want to make threads access the expression tree simultaneously.</p>\n\n<p>When I try it, the compiler starts with errors about thread safeness.</p>\n\n<p>I read the Rust book and know C/C++, but didn't understood everything about Rust type system and semantics yet.</p>\n\n<pre><code>use std::thread;\nuse std::sync::Arc;\n\npub trait Expr {\n    fn run(&amp;self) -&gt; i32;\n}\n\npub struct ConstantExpr {\n    n: i32,\n}\n\nimpl ConstantExpr {\n    pub fn new(n: i32) -&gt; Self {\n        Self { n }\n    }\n}\n\nimpl Expr for ConstantExpr {\n    fn run(&amp;self) -&gt; i32 {\n        self.n\n    }\n}\n\npub struct AddExpr {\n    expr1: Box&lt;Expr&gt;,\n    expr2: Box&lt;Expr&gt;,\n}\n\nimpl AddExpr {\n    pub fn new(expr1: Box&lt;Expr&gt;, expr2: Box&lt;Expr&gt;) -&gt; Self {\n        Self { expr1, expr2 }\n    }\n}\n\nimpl Expr for AddExpr {\n    fn run(&amp;self) -&gt; i32 {\n        self.expr1.run() + self.expr2.run()\n    }\n}\n\nstruct Container {\n    x: i32,\n    cached_expr: Arc&lt;Expr&gt;,\n}\n\nimpl Container {\n    fn new() -&gt; Self {\n        Self {\n            x: 0,\n            cached_expr: Arc::new(AddExpr::new(\n                Box::new(ConstantExpr::new(10)),\n                Box::new(ConstantExpr::new(1)),\n            )),\n        }\n    }\n}\n\nfn main() {\n    let container = Arc::new(Container::new());\n\n    let container1 = Arc::clone(&amp;container);\n\n    /*\n    let thread1 = thread::spawn(move || {\n        println!(\"thread1: {}\", container1.x);\n        println!(\"thread1: {}\", container1.cached_expr.run());\n    });\n    */\n\n    println!(\"main: {}\", container.x);\n    println!(\"main: {}\", container.cached_expr.run());\n\n    //thread1.join().unwrap();\n}\n</code></pre>\n\n<p>The error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `Expr + 'static: std::marker::Send` is not satisfied\n  --&gt; src/main.rs:64:19\n   |\n64 |     let thread1 = thread::spawn(move || {\n   |                   ^^^^^^^^^^^^^ `Expr + 'static` cannot be sent between threads safely\n   |\n   = help: the trait `std::marker::Send` is not implemented for `Expr + 'static`\n   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc&lt;Expr + 'static&gt;`\n   = note: required because it appears within the type `Container`\n   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc&lt;Container&gt;`\n   = note: required because it appears within the type `[closure@src/main.rs:64:33: 67:6 container1:std::sync::Arc&lt;Container&gt;]`\n   = note: required by `std::thread::spawn`\n\nerror[E0277]: the trait bound `Expr + 'static: std::marker::Sync` is not satisfied\n  --&gt; src/main.rs:64:19\n   |\n64 |     let thread1 = thread::spawn(move || {\n   |                   ^^^^^^^^^^^^^ `Expr + 'static` cannot be shared between threads safely\n   |\n   = help: the trait `std::marker::Sync` is not implemented for `Expr + 'static`\n   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc&lt;Expr + 'static&gt;`\n   = note: required because it appears within the type `Container`\n   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc&lt;Container&gt;`\n   = note: required because it appears within the type `[closure@src/main.rs:64:33: 67:6 container1:std::sync::Arc&lt;Container&gt;]`\n   = note: required by `std::thread::spawn`\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 99643, "user_id": 445517, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/57e2ba76e6290c4e9e19821a068bc8c1?s=128&d=identicon&r=PG", "display_name": "CodesInChaos", "link": "https://stackoverflow.com/users/445517/codesinchaos"}, "edited": false, "score": 8, "creation_date": 1515932747, "post_id": 48248330, "comment_id": 83481581, "body": "See <a href=\"https://en.wikipedia.org/wiki/Vacuous_truth\" rel=\"nofollow noreferrer\">Vacuous truth</a>"}], "answers": [{"comments": [{"owner": {"reputation": 1540, "user_id": 2606171, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/F4ncy.png?s=128&g=1", "display_name": "belst", "link": "https://stackoverflow.com/users/2606171/belst"}, "edited": false, "score": 2, "creation_date": 1515932829, "post_id": 48248462, "comment_id": 83481605, "body": "<code>all</code> is basically folding with <code>&amp;&amp;</code> and since the identity element for <code>&amp;&amp;</code> is <code>true</code> it is what gets returned by <code>all</code>. <code>any</code> on the other hand is a fold with <code>||</code> and the identity for <code>||</code> is <code>false</code>."}, {"owner": {"reputation": 2215, "user_id": 260560, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ffc8102716b5f50a80becb906f3cc69c?s=128&d=identicon&r=PG", "display_name": "ProdigySim", "link": "https://stackoverflow.com/users/260560/prodigysim"}, "edited": false, "score": 0, "creation_date": 1516217794, "post_id": 48248462, "comment_id": 83602843, "body": "Another example of the identity property being used: imagine writing <code>all</code> with <code>fold</code> or <code>reduce</code>. <code>self.fold(true, |acc, cur| acc &amp;&amp; f(cur))</code>"}], "tags": [], "owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "is_accepted": true, "score": 12, "last_activity_date": 1515944309, "last_edit_date": 1515944309, "creation_date": 1515924030, "answer_id": 48248462, "question_id": 48248330, "link": "https://stackoverflow.com/questions/48248330/why-does-iteratorall-return-true-for-an-empty-iterator/48248462#48248462", "title": "Why does Iterator::all return true for an empty iterator?", "body": "<p>This is the typical convention of the <code>all</code> function in pretty much all programming languages, except those that get it wrong. Conversely, <code>any</code> returns <code>false</code> for empty sequences.</p>\n\n<p>The reason is that it is more useful for typical scenarios. If you have a list of requirements and a value must fulfill <em>all</em> of these to pass through a filter. If your list is actually empty, should the value get through? The answer that usually makes the most sense is yes. Therefore, <code>conditions.all(|value| condition.fulfilled(value))</code> returns <code>true</code> for the empty list.</p>\n\n<p>It is also a natural consequence of the reformulation of the <code>all</code> definition as, \"no item is false\", and the default if you implement <code>all</code> in the intuitive way:</p>\n\n<pre><code>fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool\nwhere\n    F: FnMut(Self::Item) -&gt; bool,\n{\n    for v in self {\n        if !f(v) {\n            return false;\n        }\n    }\n    return true;\n}\n</code></pre>\n\n<p>There might even be a basis in mathematics for this, but I couldn't find something quickly.</p>\n"}, {"comments": [{"owner": {"reputation": 1721, "user_id": 5034140, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-H4LtHEu4ABU/AAAAAAAAAAI/AAAAAAAABfc/vgbjnSLypvo/photo.jpg?sz=128", "display_name": "Guillaume Gris", "link": "https://stackoverflow.com/users/5034140/guillaume-gris"}, "edited": false, "score": 0, "creation_date": 1516006637, "post_id": 48250934, "comment_id": 83501915, "body": "Someone proposed an edit <code>For each x: P(x) is</code> <b><i>true</i></b> <code>or x is not in X</code>. It might be confusing but there si no mistake. <code>A=&gt;(P(x) is true)</code> is equivalent to <code>not(P(x) is true) or A</code>. The <b><i>not</i></b> is important for this logic to be true"}, {"owner": {"reputation": 8877, "user_id": 5397009, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/7405bb106a62e8a3ea2d6d787b7261ee?s=128&d=identicon&r=PG&f=1", "display_name": "Jmb", "link": "https://stackoverflow.com/users/5397009/jmb"}, "edited": false, "score": 0, "creation_date": 1516014752, "post_id": 48250934, "comment_id": 83506327, "body": "That someone would be me, and I&#39;m afraid that the logic is <i>not</i> true. That&#39;s because the statement <code>A=&gt;B</code> is logically equivalent to <code>B|!A</code> and not <code>!B|A</code> as written in the answer. The <i>location</i> of the <code>not</code> is important."}, {"owner": {"reputation": 1721, "user_id": 5034140, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-H4LtHEu4ABU/AAAAAAAAAAI/AAAAAAAABfc/vgbjnSLypvo/photo.jpg?sz=128", "display_name": "Guillaume Gris", "link": "https://stackoverflow.com/users/5034140/guillaume-gris"}, "reply_to_user": {"reputation": 8877, "user_id": 5397009, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/7405bb106a62e8a3ea2d6d787b7261ee?s=128&d=identicon&r=PG&f=1", "display_name": "Jmb", "link": "https://stackoverflow.com/users/5397009/jmb"}, "edited": false, "score": 0, "creation_date": 1516014959, "post_id": 48250934, "comment_id": 83506437, "body": "Whooops, indeed, then I will also correct my first line of logic where I introduce the error"}], "tags": [], "owner": {"reputation": 1721, "user_id": 5034140, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-H4LtHEu4ABU/AAAAAAAAAAI/AAAAAAAABfc/vgbjnSLypvo/photo.jpg?sz=128", "display_name": "Guillaume Gris", "link": "https://stackoverflow.com/users/5034140/guillaume-gris"}, "is_accepted": false, "score": 3, "last_activity_date": 1516015027, "last_edit_date": 1516015027, "creation_date": 1515942454, "answer_id": 48250934, "question_id": 48248330, "link": "https://stackoverflow.com/questions/48248330/why-does-iteratorall-return-true-for-an-empty-iterator/48250934#48250934", "title": "Why does Iterator::all return true for an empty iterator?", "body": "<p>If you are interested in the mathematical basis, here is a short proof:</p>\n\n<p>The statement <code>A =&gt; B</code> (A implies B) is logically equivalent to <code>!A | B</code> (not A or B).</p>\n\n<p>The statement <code>S</code>: <code>for each x in X, P(x) is true</code> (where P is a predicate) is a shorthand for <code>for each x: x in X implies P(X) is true</code>.</p>\n\n<p>This statement is hence equivalent to: <code>For each x: P(x) is true or x is not in X</code></p>\n\n<p>If <code>X</code> is empty, the statement <code>x is not in X</code> is always true so the statement <code>S</code> is true.</p>\n"}], "owner": {"reputation": 1339, "user_id": 682485, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/ea1e106f2d083f0624c0c4f48ae1c18b?s=128&d=identicon&r=PG", "display_name": "Malice", "link": "https://stackoverflow.com/users/682485/malice"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 561, "favorite_count": 0, "accepted_answer_id": 48248462, "answer_count": 2, "score": 7, "last_activity_date": 1516015027, "creation_date": 1515923102, "last_edit_date": 1515944183, "question_id": 48248330, "link": "https://stackoverflow.com/questions/48248330/why-does-iteratorall-return-true-for-an-empty-iterator", "title": "Why does Iterator::all return true for an empty iterator?", "body": "<p>The following code</p>\n\n<pre><code>fn main() {\n    {\n        let a: Vec&lt;i32&gt; = vec![1, 2, 3, 4];\n        print!(\"{}\\n\", a.into_iter().all(|x| x &gt; 1));\n    }\n    {\n        let a: Vec&lt;i32&gt; = vec![];\n        print!(\"{}\\n\", a.into_iter().all(|x| x &gt; 1));\n    }\n}\n</code></pre>\n\n<p>gives me the output</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>false\ntrue\n</code></pre>\n\n<p>Surprisingly, <code>a.into_iter().all(|x| x &gt; 1)</code> returned <code>true</code> when <code>a</code> is empty.</p>\n\n<p>Looking at <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.all\" rel=\"noreferrer\">the docs for <code>Iterator::all</code></a>, I see that it is explicitly stated:</p>\n\n<blockquote>\n  <p>An empty iterator returns true.</p>\n</blockquote>\n\n<p>Why was it chosen to be this way?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1515903011, "post_id": 48246510, "comment_id": 83475907, "body": "<i>is it really impossible for nested patterns to match over recursive datatypes in Rust?</i> \u2014 no, that&#39;s completely possible and standard. <i>patterns in Rust cannot match upon the result of dereferencing an <code>Rc</code></i> \u2014 you have no dereferencing in this code at all."}, {"owner": {"reputation": 46453, "user_id": 13924, "user_type": "registered", "accept_rate": 45, "profile_image": "https://i.stack.imgur.com/rRkqv.jpg?s=128&g=1", "display_name": "J D", "link": "https://stackoverflow.com/users/13924/j-d"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515934779, "post_id": 48246510, "comment_id": 83482127, "body": "@Shepmaster: &quot;that&#39;s completely possible and standard&quot;. Great. What am I doing wrong and how do I do it right?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1515945716, "post_id": 48246510, "comment_id": 83485238, "body": "I copied a bit more than I meant to when quoting. I was going for just <i>is it really impossible for nested patterns to match</i>, which is possible and normal. Sorry for any false hope."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515947684, "post_id": 48246510, "comment_id": 83485885, "body": "See also <a href=\"https://stackoverflow.com/q/30004175/155423\">A simple formula interpreter</a>"}], "answers": [{"tags": [], "owner": {"reputation": 46453, "user_id": 13924, "user_type": "registered", "accept_rate": 45, "profile_image": "https://i.stack.imgur.com/rRkqv.jpg?s=128&g=1", "display_name": "J D", "link": "https://stackoverflow.com/users/13924/j-d"}, "is_accepted": true, "score": 3, "last_activity_date": 1584972063, "last_edit_date": 1584972063, "creation_date": 1515971397, "answer_id": 48255089, "question_id": 48246510, "link": "https://stackoverflow.com/questions/48246510/is-it-impossible-to-have-a-nested-match-on-a-recursive-datatype-that-uses-a-smar/48255089#48255089", "title": "Is it impossible to have a nested match on a recursive datatype that uses a smart pointer like a Box, Rc, or Arc?", "body": "<p>It appears that yes, it is currently impossible to do this. Recursive datatypes require indirection, e.g. <code>Rc</code>. Indirection requires dereferences when matching against nested patterns. There is no way to dereference inside a pattern match in Rust today.</p>\n\n<p>The workaround is to compile your patterns by hand, i.e. as if you only had C-style <code>switch</code>.</p>\n\n<p>A feature called \"box patterns\" has been <a href=\"https://github.com/rust-lang/rfcs/pull/469\" rel=\"nofollow noreferrer\">discussed since 2014</a> that may solve this problem in the future but it hasn't shipped.</p>\n"}], "owner": {"reputation": 46453, "user_id": 13924, "user_type": "registered", "accept_rate": 45, "profile_image": "https://i.stack.imgur.com/rRkqv.jpg?s=128&g=1", "display_name": "J D", "link": "https://stackoverflow.com/users/13924/j-d"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1219, "favorite_count": 0, "accepted_answer_id": 48255089, "answer_count": 1, "score": 5, "last_activity_date": 1584972063, "creation_date": 1515901417, "last_edit_date": 1515945782, "question_id": 48246510, "link": "https://stackoverflow.com/questions/48246510/is-it-impossible-to-have-a-nested-match-on-a-recursive-datatype-that-uses-a-smar", "title": "Is it impossible to have a nested match on a recursive datatype that uses a smart pointer like a Box, Rc, or Arc?", "body": "<p>I'm trying to port <a href=\"https://gist.github.com/jdh30/f3d90a65a7abc7c9faf5c0299b002db3\" rel=\"nofollow noreferrer\">this program</a> that computes the <code>n</code>th derivative of x^x symbolically to Rust. It seems to be mostly easy:</p>\n\n<pre><code>use std::rc::Rc;\n\ntype Expr = Rc&lt;Expr2&gt;;\n\nenum Expr2 {\n    Int(i32),\n    Var(String),\n    Add(Expr, Expr),\n    Mul(Expr, Expr),\n    Pow(Expr, Expr),\n    Ln(Expr),\n}\n\nuse Expr2::*;\n\nfn pown(a: i32, b: i32) -&gt; i32 {\n    match b {\n        0 =&gt; 1,\n        1 =&gt; a,\n        n =&gt; {\n            let b = pown(a, b / 2);\n            let b2 = b * b;\n            if n % 2 == 0 {\n                b2\n            } else {\n                b2 * a\n            }\n        }\n    }\n}\n\nfn add(f: Expr, g: Expr) -&gt; Expr {\n    match (f, g) {\n        (Int(m), Int(n)) =&gt; Int(m + n),\n        (Int(0), f) =&gt; f,\n        (f, Int(n)) =&gt; add(Int(n), f),\n        (f, Add(Int(n), g)) =&gt; add(Int(n), add(f, g)),\n        (Add(f, g), h) =&gt; add(f, add(g, h)),\n        (f, g) =&gt; Add(f, g),\n    }\n}\n\nfn mul(f: Expr, g: Expr) -&gt; Expr {\n    match (f, g) {\n        (Int(m), Int(n)) =&gt; Int(m * n),\n        (Int(0), f) =&gt; Int(0),\n        (Int(1), f) =&gt; f,\n        (f, Int(n)) =&gt; mul(Int(n), f),\n        (f, Mul(Int(n), g)) =&gt; mul(Int(n), mul(f, g)),\n        (Mul(f, g), h) =&gt; mul(f, mul(g, h)),\n        (f, g) =&gt; Mul(f, g),\n    }\n}\n\nfn pow(f: Expr, g: Expr) -&gt; Expr {\n    match (f, g) {\n        (Int(m), Int(n)) =&gt; Int(pown(m, n)),\n        (f, Int(0)) =&gt; Int(1),\n        (f, Int(1)) =&gt; f,\n        (Int(0), f) =&gt; Int(1),\n        (f, g) =&gt; Pow(f, g),\n    }\n}\n\nfn ln(f: Expr) -&gt; Expr {\n    match f {\n        Int(1) =&gt; Int(0),\n        f =&gt; Ln(f),\n    }\n}\n\nfn d(x: String, f: Expr) -&gt; Expr {\n    match f {\n        Int(_) =&gt; Int(0),\n        Var(y) =&gt; if x == y {\n            x\n        } else {\n            y\n        },\n        Add(f, g) =&gt; add(d(x, f), d(x, g)),\n        Mul(f, g) =&gt; add(mul(f, d(x, g)), mul(g, d(x, f))),\n        Pow(f, g) =&gt; mul(\n            pow(f, g),\n            add(mul(mul(g, d(x, f)), pow(f, Int(-1))), mul(ln(f), d(x, g))),\n        ),\n        Ln(f) =&gt; mul(d(x, f), pow(f, Int(-1))),\n    }\n}\n\nfn count(f: Expr) -&gt; i32 {\n    match f {\n        Int(_) | Var(_) =&gt; 1,\n        Add(f, g) | Mul(f, g) | Pow(f, g) =&gt; count(f) + count(g),\n        Ln(f) =&gt; count(f),\n    }\n}\n\nfn string_of_expr(f: Expr) -&gt; String {\n    count(f).to_string();\n}\n\nfn nest(n: i32, f: Expr, x: Expr) -&gt; Expr {\n    if n == 0 {\n        x\n    } else {\n        nest(n - 1, f, f(x))\n    }\n}\n\nfn deriv(f: Expr) -&gt; Expr {\n    let df = d(\"x\", f);\n    format!(\"D({}) = {}\", string_of_expr(f), string_of_expr(df));\n    df\n}\n\nfn main() {\n    let x = \"x\";\n    let f = pow(x, x);\n    // FIXME: Read command-line argument\n    let df = nest(9, deriv, f);\n    format!(\"{}\", count(df));\n}\n</code></pre>\n\n<p>The type needs to be converted into a reference counted <code>enum</code> in Rust and pattern matching makes for very similar code except... it doesn't work. From what I can gather, patterns in Rust cannot match upon the result of dereferencing an <code>Rc</code>. So, no matter what I do, it fails on nested patterns like <code>(f, Add(Int(n), g))</code>.</p>\n\n<p>Am I missing something or is it really impossible for nested patterns to match over recursive datatypes in Rust? Apparently there is something called \"box syntax\" to dereference inside a pattern (amongst other things) that has been on the drawing board for four years.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 1, "creation_date": 1515886771, "post_id": 48244892, "comment_id": 83473420, "body": "This simply isn&#39;t answerable in its current form; it depends on why the trait needs a type parameter in the first place. Do you mean specifically the <a href=\"https://doc.rust-lang.org/std/ops/\" rel=\"nofollow noreferrer\">operator traits</a> like <code>Add</code>, <code>Sub</code>, <code>BitAnd</code>, etc.?"}, {"owner": {"reputation": 679, "user_id": 1038984, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e8ccdd2690efb42463e1e6587e17fad2?s=128&d=identicon&r=PG", "display_name": "jcc333", "link": "https://stackoverflow.com/users/1038984/jcc333"}, "reply_to_user": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1515887953, "post_id": 48244892, "comment_id": 83473665, "body": "Edited to <i>try</i> to clarify, but I&#39;ll be honest, coming from a functional programming / c++ background some of this stuff is still fairly inscrutable so I&#39;m kind of shooting in the dark"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1515986293, "last_edit_date": 1515986293, "creation_date": 1515898443, "answer_id": 48246296, "question_id": 48244892, "link": "https://stackoverflow.com/questions/48244892/should-rust-implementations-of-from-tryfrom-target-references-or-values/48246296#48246296", "title": "Should Rust implementations of From/TryFrom target references or values?", "body": "<blockquote>\n  <p>Should Rust implementations of From/TryFrom target references or values?</p>\n</blockquote>\n\n<p>Yes, they should.</p>\n\n<p>There's no trickery here: implement the traits to convert whatever types you <em>have</em>. If you have a <code>String</code>, implement it to convert from <code>String</code>s. If you have a <code>&amp;str</code>, implement it to convert from <code>&amp;str</code>s. If you have both, implement it for both.</p>\n\n<blockquote>\n  <p>Is there an automatic derivation from <code>impl Trait&lt;Type&gt;</code> to <code>impl&lt;'a&gt; Trait&lt;&amp;'a Type&gt;</code>?</p>\n</blockquote>\n\n<p>No, and for good reason. For example, consider this conversion:</p>\n\n<pre><code>struct Filename(String);\n\nimpl From&lt;String&gt; for Filename {\n    fn from(value: String) -&gt; Filename {\n        Filename(value)\n    }\n}\n</code></pre>\n\n<p>There's no obviously correct way for the compiler to implement that for a reference to a <code>String</code>. However, you can implement it yourself:</p>\n\n<pre><code>impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Filename {\n    fn from(value: &amp;'a str) -&gt; Filename {\n        String::into(value.to_owned())\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>If you can't make use of the incoming allocation, then there's not much reason to accept the argument by value, so you might as well accept a reference. However, I'd say it's <em>less</em> common to use <code>From</code> for such conversions \u2014 not unheard of, though.</p>\n"}], "owner": {"reputation": 679, "user_id": 1038984, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e8ccdd2690efb42463e1e6587e17fad2?s=128&d=identicon&r=PG", "display_name": "jcc333", "link": "https://stackoverflow.com/users/1038984/jcc333"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 554, "favorite_count": 0, "accepted_answer_id": 48246296, "answer_count": 1, "score": 1, "last_activity_date": 1515986293, "creation_date": 1515882675, "last_edit_date": 1515897970, "question_id": 48244892, "link": "https://stackoverflow.com/questions/48244892/should-rust-implementations-of-from-tryfrom-target-references-or-values", "title": "Should Rust implementations of From/TryFrom target references or values?", "body": "<p>Should I be writing:</p>\n\n<pre><code>impl&lt;'a&gt; From&lt;&amp;'a Type&gt; for OtherType\n</code></pre>\n\n<p>Or should it be</p>\n\n<pre><code>impl From&lt;Type&gt; for OtherType\n</code></pre>\n\n<p>I'm having a difficult time finding the answer, perhaps due to a vocabulary failure on my part. I really don't particularly care about the reference-ness/value-ness of the argument.</p>\n\n<p>In C++, I would define the function over/method on values and calling it on const references.</p>\n\n<p>Is there an automatic derivation from <code>impl Trait&lt;Type&gt;</code> to <code>impl&lt;'a&gt; Trait&lt;&amp;'a Type&gt;</code>?</p>\n"}, {"tags": ["stream", "rust", "lifetime"], "comments": [{"owner": {"reputation": 9980, "user_id": 1944004, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/60f3cc97f94fa3690ba406f8c1a7fc4f?s=128&d=identicon&r=PG", "display_name": "Henri Menke", "link": "https://stackoverflow.com/users/1944004/henri-menke"}, "edited": false, "score": 0, "creation_date": 1515893775, "post_id": 48244647, "comment_id": 83474556, "body": "<a href=\"https://api.rocket.rs/rocket/struct.Data.html#method.open\" rel=\"nofollow noreferrer\"><code>fn open(self)</code></a> <i>The method consumes the <code>Data</code> instance.</i>  You could maybe use <code>peek</code> instead."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 0, "last_activity_date": 1515899199, "last_edit_date": 1592644375, "creation_date": 1515899199, "answer_id": 48246340, "question_id": 48244647, "link": "https://stackoverflow.com/questions/48244647/how-to-read-rocketdata-to-a-string-inside-a-fairing/48246340#48246340", "title": "How to read rocket::Data to a string inside a fairing?", "body": "<blockquote>\n<p>Is there any way to log the data without consuming it?</p>\n</blockquote>\n<p>No. Check out the documentation for <a href=\"https://api.rocket.rs/rocket/struct.Data.html#method.open\" rel=\"nofollow noreferrer\"><code>Data::open</code></a>:</p>\n<blockquote>\n<p>Returns the raw data stream.</p>\n<p>The stream contains all of the data in the body of the request, including that in the peek buffer. The method consumes the <code>Data</code> instance. This ensures that a <code>Data</code> type always represents all of the data in a request.</p>\n</blockquote>\n<p>HTTP request bodies are <em>streams</em> of data. These streams are read-once. If you were to log the body of the request, the data would then be gone and your actual handler would have nothing to work with.</p>\n<blockquote>\n<p>is there another way to implement a logging fairing like this?</p>\n</blockquote>\n<p>I don't know of any, but it seems like a brittle idea to start with. If someone were to POST a 1GB file, do you really want that entire thing logged?</p>\n<p>The closest alternative I can think of is to take the owned <code>Data</code> in the handler, open it up, then &quot;tee&quot; the output of it to both your real code and save it somewhere, log-wise.</p>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/36435372/155423\">How do I read an Iron Request in both middleware and the handler?</a></li>\n</ul>\n"}], "owner": {"reputation": 1047, "user_id": 1146183, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/d5152bd68f7c09d1c3172874b3ce2150?s=128&d=identicon&r=PG", "display_name": "Marcus Buffett", "link": "https://stackoverflow.com/users/1146183/marcus-buffett"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 298, "favorite_count": 1, "answer_count": 1, "score": 0, "last_activity_date": 1515899199, "creation_date": 1515880554, "question_id": 48244647, "link": "https://stackoverflow.com/questions/48244647/how-to-read-rocketdata-to-a-string-inside-a-fairing", "title": "How to read rocket::Data to a string inside a fairing?", "body": "<p>I'm trying to implement a fairing in Rocket that logs the bodies of requests coming in. Unfortunately, since the fairing <code>on_request</code> method only gets a reference to the <code>rocket::Data</code> in the request, I can't call <code>data.open()</code>.</p>\n\n<p>Here's the fairing I have so far:</p>\n\n<pre><code>#[derive(Default)]\nstruct Logger {\n}\n\nimpl Fairing for Logger {\n    fn info(&amp;self) -&gt; Info {\n        Info {\n            name: \"Request / response logger\",\n            kind: Kind::Request | Kind::Response\n        }\n    }\n\n    fn on_request(&amp;self, request: &amp;mut Request, data: &amp;Data) {\n        if request.method() == Method::Post {\n            println!(\"Request came in!\");\n            let mut dataStr = \"\".to_string();\n            data.open().read_to_string(&amp;mut dataStr);\n            println!(\"{:?}\", dataStr);\n        }\n    }\n\n    fn on_response(&amp;self, request: &amp;Request, response: &amp;mut Response) {\n    }\n}\n</code></pre>\n\n<p>Unsurprisingly, I get this error:</p>\n\n<pre><code>379 |        data.open().read_to_string(&amp;mut dataStr);\n    |        ^^^^ cannot move out of borrowed content\n</code></pre>\n\n<p>Is there any way to log the data without consuming it? If not, is there another way to implement a logging fairing like this?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 1, "creation_date": 1515861725, "post_id": 48241809, "comment_id": 83466296, "body": "Have you had a look at what an <a href=\"https://docs.serde.rs/serde_json/value/enum.Value.html\" rel=\"nofollow noreferrer\">idiomatic JSON type</a> would be in Rust? There is no need to use <code>Object</code> here, you would just use <code>Value</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515862970, "post_id": 48241809, "comment_id": 83466675, "body": "Related: <a href=\"https://stackoverflow.com/q/27957103/155423\">How do I create a heterogeneous collection of objects?</a>; <a href=\"https://stackoverflow.com/q/25339603/155423\">How to test for equality between trait objects?</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 2, "creation_date": 1516412391, "post_id": 48241809, "comment_id": 83690313, "body": "<i>It&#39;s pretty much what @mcarton referred to in the serde JSON library</i> \u2014 why not just <i>use</i> <code>serde_json::Value</code>? Why create your own?"}, {"owner": {"reputation": 41, "user_id": 9213082, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b57c6414c3842578d1a8cdcee1b57025?s=128&d=identicon&r=PG&f=1", "display_name": "blap_bleep", "link": "https://stackoverflow.com/users/9213082/blap-bleep"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516515560, "post_id": 48241809, "comment_id": 83715225, "body": "@Shepmaster two reasons. One, I needed to support less types than what was provided in <code>serde</code>. Second, I am trying out rust so I wanted to actually solve this on my own."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1516545558, "post_id": 48364179, "comment_id": 83722445, "body": "Normally, such a match would be <a href=\"https://play.rust-lang.org/?gist=5c2ee66415b0409a2fe19a0c6d887f8c&amp;version=stable\" rel=\"nofollow noreferrer\">written on the tuple of values</a>. In this specific case, you can <a href=\"https://play.rust-lang.org/?gist=e0fdfd70a0e1add5d55d984e55f5ebad&amp;version=stable\" rel=\"nofollow noreferrer\">just <code>#[derive(PartialEq)]</code> for your type</a>."}, {"owner": {"reputation": 41, "user_id": 9213082, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b57c6414c3842578d1a8cdcee1b57025?s=128&d=identicon&r=PG&f=1", "display_name": "blap_bleep", "link": "https://stackoverflow.com/users/9213082/blap-bleep"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1516560245, "post_id": 48364179, "comment_id": 83727438, "body": "@Shepmaster awesome! I didn&#39;t know you could <code>#[derive(PartialEq)]</code> on enums, looking at the code in the playground it seems to be doing the same thing (~20 lines difference between them), does<code>#[derive(PartialEq)]</code> on enums compile down to <code>match</code>es? Also, in pattern matching is the correct match arm statically linked in compilation or is it a runtime check?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1516560643, "post_id": 48364179, "comment_id": 83727588, "body": "In the general case, it <i>has</i> to be a runtime check. The variable could be coming from outside of the source code, after all. I&#39;m sure the optimizer eliminates certain constant cases though. There are <a href=\"https://stackoverflow.com/a/37639012/155423\">tools that let you see exactly what it would expand to</a>."}], "tags": [], "owner": {"reputation": 41, "user_id": 9213082, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b57c6414c3842578d1a8cdcee1b57025?s=128&d=identicon&r=PG&f=1", "display_name": "blap_bleep", "link": "https://stackoverflow.com/users/9213082/blap-bleep"}, "is_accepted": false, "score": 0, "last_activity_date": 1516545367, "last_edit_date": 1516545367, "creation_date": 1516515022, "answer_id": 48364179, "question_id": 48241809, "link": "https://stackoverflow.com/questions/48241809/how-can-i-create-a-hashmap-of-different-types-and-test-them-for-equality/48364179#48364179", "title": "How can I create a HashMap of different types and test them for equality?", "body": "<p>It's pretty much <a href=\"https://stackoverflow.com/questions/48241809/how-can-i-create-a-hashmap-of-different-types-and-test-them-for-equality#comment83466296_48241809\">what @mcarton referred to</a> in the Serde JSON library, only I used a enum match, which I'm not sure is better.</p>\n\n<pre><code>enum Value {\n    Str(String),\n    Int(i32),\n    // other value types\n}\n\nimpl PartialEq for Value {\n    fn eq(&amp;self, other: &amp;Value) -&gt; bool {\n        match *self {\n            Value::Str(ref s1) =&gt; match *other {\n                Value::Str(ref s2) =&gt; s1 == s2,\n                _ =&gt; false\n            },\n            Value::Int(i1) =&gt; match *other {\n                Value::Int(i2) =&gt; i1 == i2,\n                _ =&gt; false\n            },\n            // other implementations\n        }\n    }\n}\n</code></pre>\n\n<p>Since I needed to support less types than what was provided in Serde and I am trying out Rust, I created my own enum instead of using <code>serde_json::Value</code></p>\n"}], "owner": {"reputation": 41, "user_id": 9213082, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b57c6414c3842578d1a8cdcee1b57025?s=128&d=identicon&r=PG&f=1", "display_name": "blap_bleep", "link": "https://stackoverflow.com/users/9213082/blap-bleep"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 1077, "favorite_count": 0, "closed_date": 1516550301, "answer_count": 1, "score": 4, "last_activity_date": 1516550599, "creation_date": 1515860714, "last_edit_date": 1516514921, "question_id": 48241809, "link": "https://stackoverflow.com/questions/48241809/how-can-i-create-a-hashmap-of-different-types-and-test-them-for-equality", "closed_reason": "Duplicate", "title": "How can I create a HashMap of different types and test them for equality?", "body": "<p>I have a source JSON with several keys and values and I'd like to take several target JSONs and check if they are a subset of that JSON: all fields in target JSON are present in source JSON and hold the same values.</p>\n\n<p>To accomplish this, I'd like to place several values of different types in the value part of a <code>HashMap</code> and call <code>equals</code> on those values.</p>\n\n<p>There are several types of values in the map and I'd like to accept some key-value pair and check if </p>\n\n<ol>\n<li>the key is in the map </li>\n<li>the value is the same as the value in the map.</li>\n</ol>\n\n<p>This is an example of what I'd like to do in Java:</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>boolean isInMap(Map&lt;String, Object&gt; map, String key, Object value) {\n    return map.containsKey(key) &amp;&amp; map.get(key).equals(value);\n}\n</code></pre>\n\n<p>This might be an <a href=\"https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem\">XY question</a> but how can I do this in Rust?</p>\n"}, {"tags": ["datetime", "rust", "timestamp"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 5, "creation_date": 1515856282, "post_id": 48237707, "comment_id": 83464599, "body": "+1 for pointing out that using the database as the time source is the better idea, especially in cases where you have multiple machines (with different time sources) connecting to one database."}], "tags": [], "owner": {"reputation": 466742, "user_id": 224671, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c90de868a7e95d75bdfd6a906dfedac7?s=128&d=identicon&r=PG", "display_name": "kennytm", "link": "https://stackoverflow.com/users/224671/kennytm"}, "is_accepted": true, "score": 32, "last_activity_date": 1515827336, "creation_date": 1515827336, "answer_id": 48237707, "question_id": 48236838, "link": "https://stackoverflow.com/questions/48236838/how-to-convert-datetimenow-into-naivedatetime/48237707#48237707", "title": "How to convert DateTime::now() into NaiveDateTime?", "body": "<p><code>Utc::now()</code> returns a <code>DateTime&lt;Utc&gt;</code>. You could click into the <a href=\"https://docs.rs/chrono/*/chrono/struct.DateTime.html\" rel=\"noreferrer\">documentation of <code>DateTime&lt;T&gt;</code></a> and search for <code>NaiveDateTime</code>. You should find that there are two methods that will return a <code>NaiveDateTime</code>:</p>\n\n<blockquote>\n  <p><code>fn naive_utc(&amp;self) -&gt; NaiveDateTime</code></p>\n  \n  <p>&emsp; Returns a view to the naive UTC datetime.</p>\n</blockquote>\n\n\n\n<blockquote>\n  <p><code>fn naive_local(&amp;self) -&gt; NaiveDateTime</code></p>\n  \n  <p>&emsp; Returns a view to the naive local datetime.</p>\n</blockquote>\n\n<p>For instance, if you need the timestamp in UTC:</p>\n\n<pre><code>let naive_date_time = Utc::now().naive_utc();\n</code></pre>\n\n<hr>\n\n<p>Note that since you are using <code>diesel</code>, you could use <a href=\"http://docs.diesel.rs/diesel/dsl/struct.now.html\" rel=\"noreferrer\"><code>diesel::dsl::now</code></a> instead, which will evaluate to <code>CURRENT_TIMESTAMP</code> on the SQL side.</p>\n\n<pre><code>//! ```cargo\n//! [dependencies]\n//! diesel = { version = \"1\", features = [\"sqlite\"] }\n//! ```\n\n#[macro_use]\nextern crate diesel;\n\nuse diesel::prelude::*;\nuse diesel::dsl;\n\ntable! {\n    posts (id) {\n        id -&gt; Integer,\n        content -&gt; Text,\n        published -&gt; Timestamp,\n    }\n}\n\nfn main() {\n    let conn = SqliteConnection::establish(\"test.db\")\n        .expect(\"Cannot open database\");\n\n    diesel::insert_into(posts::table)\n        .values((\n            posts::content.eq(\"hello\"),\n            posts::published.eq(dsl::now),  // &lt;------------------\n        ))\n        .execute(&amp;conn)\n        .expect(\"Insertion failed\");\n}\n</code></pre>\n"}], "owner": {"reputation": 247, "user_id": 9202260, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b8b989ea2f27e2346f04a52d6573f88a?s=128&d=identicon&r=PG&f=1", "display_name": "Kurama", "link": "https://stackoverflow.com/users/9202260/kurama"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6077, "favorite_count": 2, "accepted_answer_id": 48237707, "answer_count": 1, "score": 21, "last_activity_date": 1515856051, "creation_date": 1515816549, "last_edit_date": 1515856051, "question_id": 48236838, "link": "https://stackoverflow.com/questions/48236838/how-to-convert-datetimenow-into-naivedatetime", "title": "How to convert DateTime::now() into NaiveDateTime?", "body": "<p>I'm using Diesel and chrono. In my model I have a field of type <code>NaiveDateTime</code> which contains the <code>now()</code>. However, <code>NaiveDateTime</code> doesn't have the function <code>now()</code> or a similar one whereas <code>DateTime</code> does:</p>\n\n<pre><code>Utc::now()\n</code></pre>\n\n<p>How can I convert <code>Utc::now()</code> into <code>NaiveDateTime</code>?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 3, "creation_date": 1515800727, "post_id": 48235267, "comment_id": 83453617, "body": "Did you read the big bold <b>WARNING</b> on <a href=\"https://doc.rust-lang.org/std/ffi/struct.CString.html#method.as_ptr\" rel=\"nofollow noreferrer\"><code>as_ptr</code></a>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515802068, "post_id": 48235267, "comment_id": 83453966, "body": "See also: <a href=\"https://stackoverflow.com/q/39218479/155423\">stackoverflow.com/q/39218479/155423</a>; <a href=\"https://stackoverflow.com/q/39169146/155423\">stackoverflow.com/q/39169146/155423</a>; <a href=\"https://stackoverflow.com/q/31083223/155423\">stackoverflow.com/q/31083223/155423</a>."}], "answers": [{"comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 1, "creation_date": 1515801021, "post_id": 48235570, "comment_id": 83453692, "body": "Simpler version: Just call <code>into_raw</code> instead of <code>as_ptr</code>."}, {"owner": {"reputation": 134258, "user_id": 785065, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/qAbxM.jpg?s=128&g=1", "display_name": "loganfsmyth", "link": "https://stackoverflow.com/users/785065/loganfsmyth"}, "reply_to_user": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 1, "creation_date": 1515801224, "post_id": 48235570, "comment_id": 83453745, "body": "@trentcl Woops, I actually had it in there then for some reason was thinking it wouldn&#39;t work."}, {"owner": {"reputation": 5005, "user_id": 573149, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/Wn0FW.jpg?s=128&g=1", "display_name": "Andrew Mackenzie", "link": "https://stackoverflow.com/users/573149/andrew-mackenzie"}, "edited": false, "score": 0, "creation_date": 1598723993, "post_id": 48235570, "comment_id": 112554667, "body": "Does the CString get automatically null terminated when created?"}, {"owner": {"reputation": 134258, "user_id": 785065, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/qAbxM.jpg?s=128&g=1", "display_name": "loganfsmyth", "link": "https://stackoverflow.com/users/785065/loganfsmyth"}, "reply_to_user": {"reputation": 5005, "user_id": 573149, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/Wn0FW.jpg?s=128&g=1", "display_name": "Andrew Mackenzie", "link": "https://stackoverflow.com/users/573149/andrew-mackenzie"}, "edited": false, "score": 0, "creation_date": 1598832391, "post_id": 48235570, "comment_id": 112577032, "body": "@AndrewMackenzie Always best to start with the docs: <a href=\"https://doc.rust-lang.org/std/ffi/struct.CString.html\" rel=\"nofollow noreferrer\">&quot;A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.&quot;</a>, so yep, it will always be null-terminated."}], "tags": [], "owner": {"reputation": 134258, "user_id": 785065, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/qAbxM.jpg?s=128&g=1", "display_name": "loganfsmyth", "link": "https://stackoverflow.com/users/785065/loganfsmyth"}, "is_accepted": true, "score": 4, "last_activity_date": 1515801768, "last_edit_date": 1515801768, "creation_date": 1515800953, "answer_id": 48235570, "question_id": 48235267, "link": "https://stackoverflow.com/questions/48235267/conversion-between-a-rust-str-and-fficstring-and-back-again-partially-corrupts/48235570#48235570", "title": "Conversion between a Rust str and ffi::CString and back again partially corrupts the string", "body": "<p>You've missed one crucial step. </p>\n\n<pre><code>fn to_c_str(&amp;self) -&gt; Result&lt;c_str_t, NulError&gt; {\n    let result = match CString::new(&amp;self[..]) {\n        Ok(result) =&gt; result,\n        Err(e) =&gt; {\n            return Err(e);\n        }\n    };\n    Ok(c_str_t { data: result.as_ptr() as *const u8, len: self.len() })\n}\n</code></pre>\n\n<p>allocates a new <code>CString</code> structure, and takes a pointer to its data, but that data will still be freed once the <code>to_c_str</code> function runs to completion. This means that later code can overwrite the string contents in-memory. In your example case, it just happens to be that only the first character is overwritten.</p>\n\n<p>I'd recommend reading over the documentation of <a href=\"https://doc.rust-lang.org/std/ffi/struct.CString.html#method.as_ptr\" rel=\"nofollow noreferrer\"><code>.as_ptr()</code></a> as it tries to cover some of this.</p>\n\n<p>You could manually <code>std::mem::forget</code>, e.g.</p>\n\n<pre><code>fn to_c_str(&amp;self) -&gt; Result&lt;c_str_t, NulError&gt; {\n    let result = match CString::new(&amp;self[..]) {\n        Ok(result) =&gt; result,\n        Err(e) =&gt; {\n            return Err(e);\n        }\n    };\n    let s = c_str_t { data: result.as_ptr() as *const u8, len: self.len() };\n    std::mem::forget(result);\n\n    Ok(s)\n}\n</code></pre>\n\n<p>but the best approach would be to use <a href=\"https://doc.rust-lang.org/std/ffi/struct.CString.html#method.into_raw\" rel=\"nofollow noreferrer\"><code>.into_raw()</code></a> to take ownership and return the pointer on its own.</p>\n\n<pre><code>fn to_c_str(&amp;self) -&gt; Result&lt;c_str_t, NulError&gt; {\n    let result = match CString::new(&amp;self[..]) {\n        Ok(result) =&gt; result,\n        Err(e) =&gt; {\n            return Err(e);\n        }\n    };\n    Ok(c_str_t { data: result.into_raw() as *const u8, len: self.len() })\n}\n</code></pre>\n"}], "owner": {"reputation": 6509, "user_id": 356011, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/d17ff41be1044be6fb5ef186b83efb20?s=128&d=identicon&r=PG", "display_name": "marathon", "link": "https://stackoverflow.com/users/356011/marathon"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1291, "favorite_count": 0, "accepted_answer_id": 48235570, "answer_count": 1, "score": 1, "last_activity_date": 1515802096, "creation_date": 1515798685, "last_edit_date": 1515802096, "question_id": 48235267, "link": "https://stackoverflow.com/questions/48235267/conversion-between-a-rust-str-and-fficstring-and-back-again-partially-corrupts", "title": "Conversion between a Rust str and ffi::CString and back again partially corrupts the string", "body": "<pre><code>#![allow(non_camel_case_types)]\n\nuse libc::{c_uchar, size_t};\nuse std::str::FromStr;\nuse std::ffi::{CString, NulError};\nuse std::slice;\n\n#[repr(C)]\npub struct c_str_t {\n    pub len: size_t,\n    pub data: *const c_uchar,\n}\n\npub trait MyCStrExt&lt;T&gt; {\n    fn to_c_str(&amp;self) -&gt; Result&lt;c_str_t, NulError&gt;;\n}\n\n\npub trait MyCStringExt {\n    fn from_c_str_ref(nstr: &amp;c_str_t) -&gt; Option&lt;String&gt;;\n}\n\nimpl&lt;'a&gt; MyCStrExt&lt;&amp;'a str&gt; for str {\n    fn to_c_str(&amp;self) -&gt; Result&lt;c_str_t, NulError&gt; {\n        let result = match CString::new(&amp;self[..]) {\n            Ok(result) =&gt; result,\n            Err(e) =&gt; {\n                return Err(e);\n            }\n        };\n        Ok(c_str_t { data: result.as_ptr() as *const u8, len: self.len() })\n    }\n}\n\n\nimpl MyCStringExt for String {\n    fn from_c_str_ref(nstr: &amp;c_str_t) -&gt; Option&lt;String&gt; {\n        unsafe {\n            if nstr.data.is_null() {\n                return None;\n            }\n            let value = slice::from_raw_parts(nstr.data, nstr.len);\n            match String::from_utf8(value.to_vec()) {\n                Ok(value) =&gt; Some(value),\n                Err(e) =&gt; None\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>With this test that first converts to a <code>CString</code> and then back again to a Rust string, passing in the given string</p>\n\n<pre><code>#[test]\nfn test_to_c_str() {\n    let s = \"What does the fox say?\";\n    let result = s.to_c_str();\n    let round_trip = String::from_c_str_ref(result.as_ref().ok().unwrap());\n    println!(\"{:?}\", round_trip);\n}\n</code></pre>\n\n<p>will result in a round trip with a Rust string at the end with a null in the first character position:</p>\n\n<p><code>Some(\"\\u{0}hat does the fox say?\")</code></p>\n\n<p>What am I doing wrong?</p>\n"}, {"tags": ["rust", "constants", "overloading", "const-correctness"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515769099, "post_id": 48228667, "comment_id": 83439390, "body": "Idiomatic Rust uses <code>snake_case</code>, not <code>camelCase</code>."}, {"owner": {"reputation": 862, "user_id": 1417883, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/56fe3a87ac4d39ab9b7a15f92b5fd7dc?s=128&d=identicon&r=PG", "display_name": "barsan-md", "link": "https://stackoverflow.com/users/1417883/barsan-md"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515770240, "post_id": 48228667, "comment_id": 83440108, "body": "also C++ is snake_case, just for information completeness (and types are lower case)."}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 2, "creation_date": 1515770530, "post_id": 48228667, "comment_id": 83440288, "body": "<a href=\"https://stackoverflow.com/a/42514762/3650362\">gnzlbg&#39;s answer</a> on the other question solves your problem directly. But I&#39;d recommend against it. The ability to dispatch methods on the const-ness of the reference was one of my first big WTF moments learning C++"}, {"owner": {"reputation": 2858, "user_id": 3358499, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/fa794782e1c5f1e6978843d286dc5ad9?s=128&d=identicon&r=PG&f=1", "display_name": "WBuck", "link": "https://stackoverflow.com/users/3358499/wbuck"}, "edited": false, "score": 0, "creation_date": 1597069369, "post_id": 48228667, "comment_id": 112005660, "body": "@barsan-md That&#39;s incorrect. There is no single style guideline for <code>C++</code>."}], "owner": {"reputation": 862, "user_id": 1417883, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/56fe3a87ac4d39ab9b7a15f92b5fd7dc?s=128&d=identicon&r=PG", "display_name": "barsan-md", "link": "https://stackoverflow.com/users/1417883/barsan-md"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 48, "favorite_count": 0, "closed_date": 1515769592, "answer_count": 0, "score": 1, "last_activity_date": 1515769052, "creation_date": 1515768723, "last_edit_date": 1515768825, "question_id": 48228667, "link": "https://stackoverflow.com/questions/48228667/overload-both-self-and-mut-self-method", "closed_reason": "Duplicate", "title": "Overload both &amp;self and &amp;mut self method", "body": "<p>Rust, unlike C++, does not have function overloading. Consider a linked list model that, in C++, would look like:</p>\n\n<pre class=\"lang-cpp prettyprint-override\"><code>template &lt;typename T&gt;\nclass Node {\nprivate:\n    T value;\n    std::unique_ptr&lt;Node&lt;T&gt;&gt; next;\n\npublic:\n    Node&lt;T&gt;&amp; getNext();\n    const Node&lt;T&gt;&amp; getNext() const;\n};\n</code></pre>\n\n<p>When you deal with a constant list, you cannot modify it because you can only have access to <code>const Node&lt;T&gt;&amp;</code>, at the same time you can modify a non constant list.</p>\n\n<p>What is the equivalent of this behaviour in Rust? Consider a more complex example with multiple methods. Only some of them must be overloaded with both <code>&amp;mut self</code> and <code>&amp;self</code>.</p>\n\n<pre><code>pub struct Node&lt;T&gt; {\n    value: T,\n    next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\nimpl&lt;T&gt; Node&lt;T&gt; {\n    pub fn getNext(&amp;self) -&gt; Option&lt;&amp;Self&gt; {}\n    pub fn getNext(&amp;mut self) -&gt; Option&lt;&amp;mut Self&gt; {}\n}\n</code></pre>\n"}, {"tags": ["memory-management", "rust"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 6, "creation_date": 1515764435, "post_id": 48227347, "comment_id": 83436612, "body": "1. Rust doesn&#39;t even have a GC. 2. That should be explained in the Book on <a href=\"https://doc.rust-lang.org/book/second-edition/ch03-01-variables-and-mutability.html#shadowing\" rel=\"nofollow noreferrer\">Shadowing</a>"}, {"owner": {"reputation": 4457, "user_id": 5281693, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/5fN4R.jpg?s=128&g=1", "display_name": "Alexander Luna", "link": "https://stackoverflow.com/users/5281693/alexander-luna"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1515765159, "post_id": 48227347, "comment_id": 83436997, "body": "I know Rust doesn&#39;t have GC but the fact that is cleans after itself without you telling it is in some way a GC. Is there a way of cleaning memory manually ? Or does the memory only get freed up after it falls out of scope as Shepmaster mentioned ?"}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1515765261, "post_id": 48227347, "comment_id": 83437057, "body": "That is not quite what you are asking in the question."}, {"owner": {"reputation": 852, "user_id": 6563468, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a4c2119cfc1ee9a6c5deeec2ead9a261?s=128&d=identicon&r=PG&f=1", "display_name": "Logan Reed", "link": "https://stackoverflow.com/users/6563468/logan-reed"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1515794885, "post_id": 48227347, "comment_id": 83451905, "body": "I don&#39;t understand why this question is being down-voted. The Rust Book doesn&#39;t explain at all what happens with the memory of shadowed variables. The answer from @Shepmaster explains it really well!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 852, "user_id": 6563468, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a4c2119cfc1ee9a6c5deeec2ead9a261?s=128&d=identicon&r=PG&f=1", "display_name": "Logan Reed", "link": "https://stackoverflow.com/users/6563468/logan-reed"}, "edited": false, "score": 2, "creation_date": 1515795164, "post_id": 48227347, "comment_id": 83452008, "body": "@LoganReed if you check the <a href=\"https://stackoverflow.com/posts/48227347/revisions\">revision history</a>, you&#39;ll see that OP originally asked if Rust&#39;s &quot;garbage collector&quot; did X or Y. The downvote arrow tooltip lists &quot;this question does not show any research effort&quot; as a reason to use it. Cursory searching would show that Rust does not have a GC, so my guess is that people downvoted for some combination of those reasons. You are encouraged to upvote if you think the question in its current form is good."}], "answers": [{"comments": [{"owner": {"reputation": 4457, "user_id": 5281693, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/5fN4R.jpg?s=128&g=1", "display_name": "Alexander Luna", "link": "https://stackoverflow.com/users/5281693/alexander-luna"}, "edited": false, "score": 0, "creation_date": 1515764762, "post_id": 48227487, "comment_id": 83436787, "body": "I know Rust doesn&#39;t have GC but the fact that is cleans after itself without you telling it is in some way a GC. Is there a way of cleaning memory manually ? What if I declare the variable in a global scope outside of the other functions ?"}, {"owner": {"reputation": 4457, "user_id": 5281693, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/5fN4R.jpg?s=128&g=1", "display_name": "Alexander Luna", "link": "https://stackoverflow.com/users/5281693/alexander-luna"}, "edited": false, "score": 0, "creation_date": 1515765472, "post_id": 48227487, "comment_id": 83437175, "body": "Ok, when it falls out of scope it will free up the memory again. Do you know if there is a manual way of doing it or does Rust decide that alone ?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 7, "creation_date": 1515765839, "post_id": 48227487, "comment_id": 83437393, "body": "You have a fundamental problem with freeing memory: Stacks can (by definition) only be modified at the top (or bottom, depending on your view). So you can&#39;t &quot;free&quot; memory in the middle. If you have 3 variables <code>a</code>, <code>b</code> and <code>c</code> in that order, you can&#39;t &quot;free&quot; <code>b</code>, you can just stop using it or reuse its memory, but not free it."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 20, "last_activity_date": 1608947396, "last_edit_date": 1608947396, "creation_date": 1515764530, "answer_id": 48227487, "question_id": 48227347, "link": "https://stackoverflow.com/questions/48227347/does-rust-free-up-the-memory-of-overwritten-variables/48227487#48227487", "title": "Does Rust free up the memory of overwritten variables?", "body": "<p><a href=\"https://prev.rust-lang.org/en-US/faq.html#is-rust-garbage-collected\" rel=\"nofollow noreferrer\"><strong>Rust does not have a garbage collector</strong></a>.</p>\n<blockquote>\n<p>Does Rust free up the memory of overwritten variables?</p>\n</blockquote>\n<p>Yes, otherwise it'd be a memory leak, which would be a pretty terrible design decision. The memory is freed when the variable is reassigned:</p>\n<pre><code>struct Noisy;\nimpl Drop for Noisy {\n    fn drop(&amp;mut self) {\n        eprintln!(&quot;Dropped&quot;)\n    }\n}\n\nfn main() {\n    eprintln!(&quot;0&quot;);\n    let mut thing = Noisy;\n    eprintln!(&quot;1&quot;);\n    thing = Noisy;\n    eprintln!(&quot;2&quot;);\n}\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>0\n1\nDropped\n2\nDropped\n</code></pre>\n<blockquote>\n<p>what happens with the first hello</p>\n</blockquote>\n<p>It is <a href=\"https://doc.rust-lang.org/book/second-edition/ch03-01-variables-and-mutability.html#shadowing\" rel=\"nofollow noreferrer\">shadowed</a>.</p>\n<p>Nothing &quot;special&quot; happens to the data referenced by the variable, other than the fact that you can no longer access it. It is still dropped when the variable goes out of scope:</p>\n<pre><code>struct Noisy;\nimpl Drop for Noisy {\n    fn drop(&amp;mut self) {\n        eprintln!(&quot;Dropped&quot;)\n    }\n}\n\nfn main() {\n    eprintln!(&quot;0&quot;);\n    let thing = Noisy;\n    eprintln!(&quot;1&quot;);\n    let thing = Noisy;\n    eprintln!(&quot;2&quot;);\n}\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>0\n1\n2\nDropped\nDropped\n</code></pre>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/30304145/155423\">Is the resource of a shadowed variable binding freed immediately?</a></li>\n</ul>\n<blockquote>\n<p>I know it would be bad to name two variables the same</p>\n</blockquote>\n<p>It's not &quot;bad&quot;, it's a design decision. I would say that using shadowing like this is a bad idea:</p>\n<pre><code>let x = &quot;Anna&quot;;\nprintln!(&quot;User's name is {}&quot;, x);\nlet x = 42;\nprintln!(&quot;The tax rate is {}&quot;, x);\n</code></pre>\n<p>Using shadowing like this is reasonable to me:</p>\n<pre><code>let name = String::from(&quot;  Vivian &quot;);\nlet name = name.trim();\nprintln!(&quot;User's name is {}&quot;, name);\n</code></pre>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/40621325/155423\">Why do I need rebinding/shadowing when I can have mutable variable binding?</a></li>\n</ul>\n<blockquote>\n<p>but if this happens by accident because I declare it 100 lines below it could be a real pain.</p>\n</blockquote>\n<p>Don't have functions that are so big that you &quot;accidentally&quot; do something. That's applicable in any programming language.</p>\n<blockquote>\n<p>Is there a way of cleaning memory manually?</p>\n</blockquote>\n<p>You can call <a href=\"https://doc.rust-lang.org/std/mem/fn.drop.html\" rel=\"nofollow noreferrer\"><code>drop</code></a>:</p>\n<pre><code>eprintln!(&quot;0&quot;);\nlet thing = Noisy;\ndrop(thing);\neprintln!(&quot;1&quot;);\nlet thing = Noisy;\neprintln!(&quot;2&quot;);\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>0\nDropped\n1\n2\nDropped\n</code></pre>\n<p>However, as <a href=\"https://stackoverflow.com/questions/48227347/does-rust-free-up-the-memory-of-overwritten-variables#comment83437393_48227487\">oli_obk - ker points out</a>, the stack memory taken by the variable will not be freed until the function exits, only the resources taken by the variable.</p>\n<p>All discussions of <code>drop</code> require showing its (very complicated) implementation:</p>\n<pre><code>fn drop&lt;T&gt;(_: T) {}\n</code></pre>\n<blockquote>\n<p>What if I declare the variable in a global scope outside of the other functions?</p>\n</blockquote>\n<p>Global variables are never freed, if you can even create them to start with.</p>\n"}, {"tags": [], "owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "is_accepted": false, "score": 8, "last_activity_date": 1574859908, "last_edit_date": 1574859908, "creation_date": 1518132076, "answer_id": 48696415, "question_id": 48227347, "link": "https://stackoverflow.com/questions/48227347/does-rust-free-up-the-memory-of-overwritten-variables/48696415#48696415", "title": "Does Rust free up the memory of overwritten variables?", "body": "<p>There is a difference between <em>shadowing</em> and <em>reassigning</em> (overwriting) a variable when it comes to drop order.</p>\n\n<p>All local variables are normally dropped when they go out of scope, in reverse order of declaration (see <em>The Rust Programming Language</em>'s <a href=\"https://doc.rust-lang.org/book/second-edition/ch15-03-drop.html\" rel=\"nofollow noreferrer\">chapter on <code>Drop</code></a>). This includes shadowed variables. It's easy to check this by wrapping the value in a simple wrapper struct that prints something when it (the wrapper) is dropped (just <em>before</em> the value itself is dropped):</p>\n\n<pre><code>use std::fmt::Debug;\n\nstruct NoisyDrop&lt;T: Debug&gt;(T);\n\nimpl&lt;T: Debug&gt; Drop for NoisyDrop&lt;T&gt; {\n    fn drop(&amp;mut self) {\n        println!(\"dropping {:?}\", self.0);\n    }\n}\n\nfn main() {\n    let hello = NoisyDrop(\"Hello\");\n    let hello = NoisyDrop(\"Goodbye\");\n\n    println!(\"My variable hello contains: {}\", hello.0);\n}\n</code></pre>\n\n<p>prints the following (<a href=\"https://play.rust-lang.org/?gist=3b768b4eb147062d82fcecb3c70e3a6c&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a>):</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>My variable hello contains: Goodbye\ndropping \"Goodbye\"\ndropping \"Hello\"\n</code></pre>\n\n<p>That's because a new <code>let</code> binding in a scope does not overwrite the previous binding, so it's just as if you had written</p>\n\n<pre><code>    let hello1 = NoisyDrop(\"Hello\");\n    let hello2 = NoisyDrop(\"Goodbye\");\n\n    println!(\"My variable hello contains: {}\", hello2.0);\n</code></pre>\n\n<hr>\n\n<p>Notice that this behavior is different from the following, superficially very similar, code (<a href=\"https://play.rust-lang.org/?gist=1d2138b1e40e8c062a99c23c77da762d&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a>):</p>\n\n<pre><code>fn main() {\n    let mut hello = NoisyDrop(\"Hello\");\n    hello = NoisyDrop(\"Goodbye\");\n\n    println!(\"My variable hello contains: {}\", hello.0);\n}\n</code></pre>\n\n<p>which not only drops them in the opposite order, but drops the first value before printing the message! That's because when you assign to a variable (instead of shadowing it with a new one), the original value gets dropped <em>first</em>, before the new value is moved in.</p>\n\n<p>I began by saying that local variables are \"normally\" dropped when they go out of scope. Because you can move values into and out of variables, the analysis of figuring out when variables <em>need</em> to be dropped can sometimes not be done until runtime. In such cases, the compiler actually <a href=\"https://doc.rust-lang.org/nomicon/drop-flags.html\" rel=\"nofollow noreferrer\">inserts code to track \"liveness\" and drop those values when necessary</a>, so you can't accidentally cause leaks by overwriting a value. (However, it's still possible to safely leak memory by calling <code>mem::forget</code>, or by creating an <code>Rc</code>-cycle with internal mutability.)</p>\n\n<h1>See also</h1>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/47648958/whats-the-semantic-of-assignment-in-rust\">What&#39;s the semantic of assignment in Rust?</a></li>\n</ul>\n"}], "owner": {"reputation": 4457, "user_id": 5281693, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/5fN4R.jpg?s=128&g=1", "display_name": "Alexander Luna", "link": "https://stackoverflow.com/users/5281693/alexander-luna"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3073, "favorite_count": 0, "accepted_answer_id": 48227487, "answer_count": 2, "score": 18, "last_activity_date": 1608947396, "creation_date": 1515763964, "last_edit_date": 1515795254, "question_id": 48227347, "link": "https://stackoverflow.com/questions/48227347/does-rust-free-up-the-memory-of-overwritten-variables", "title": "Does Rust free up the memory of overwritten variables?", "body": "<p>I saw in the Rust book that you can define two different variables with the same name:</p>\n\n<pre><code>let hello = \"Hello\";\nlet hello = \"Goodbye\";\n\nprintln!(\"My variable hello contains: {}\", hello);\n</code></pre>\n\n<p>This prints out:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>My variable hello contains: Goodbye\n</code></pre>\n\n<p>What happens with the first hello? Does it get freed up? How could I access it?</p>\n\n<p>I know it would be bad to name two variables the same, but if this happens by accident because I declare it 100 lines below it could be a real pain.</p>\n"}, {"tags": ["rust", "ownership"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515765365, "post_id": 48226014, "comment_id": 83437107, "body": "There&#39;s nothing special about <code>self</code> as compared to <i>any other variable of any type</i>."}], "answers": [{"comments": [{"owner": {"reputation": 13169, "user_id": 967945, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/47244a17f72cee237f57f4c4b9613ea1?s=128&d=identicon&r=PG", "display_name": "Dan Hulme", "link": "https://stackoverflow.com/users/967945/dan-hulme"}, "edited": false, "score": 0, "creation_date": 1515763972, "post_id": 48226085, "comment_id": 83436350, "body": "Obviously I&#39;m looking for a steer, not a guarantee. In a particular case I&#39;d profile; I&#39;m just trying to build an intuition of when it&#39;s worth worrying about."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 13169, "user_id": 967945, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/47244a17f72cee237f57f4c4b9613ea1?s=128&d=identicon&r=PG", "display_name": "Dan Hulme", "link": "https://stackoverflow.com/users/967945/dan-hulme"}, "edited": false, "score": 0, "creation_date": 1515764513, "post_id": 48226085, "comment_id": 83436651, "body": "@DanHulme: In that case, I would say that it depends on <code>size_of&lt;Self&gt;</code>. For a small size (a couple words), the cost of the copy is so small even if not optimized that it&#39;s not worrying. For a larger size, such as when an array is embedded, I&#39;d be conservative if performance is expected and go with references."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 13169, "user_id": 967945, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/47244a17f72cee237f57f4c4b9613ea1?s=128&d=identicon&r=PG", "display_name": "Dan Hulme", "link": "https://stackoverflow.com/users/967945/dan-hulme"}, "edited": false, "score": 0, "creation_date": 1515765340, "post_id": 48226085, "comment_id": 83437095, "body": "@DanHulme conversely, I advocate that <i>moving</i> is always acceptable. Rust&#39;s semantics hinge on the concept of moving \u2014 it&#39;s even on the front page of rust-lang.org! Thus any &quot;extra&quot; moves are a big deal and should be fixed at the root."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515767504, "post_id": 48226085, "comment_id": 83438404, "body": "@Shepmaster: If your API forces moves, and functions are not inlined, you will have moves in the final binary and that&#39;s not Rust&#39;s fault."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515767700, "post_id": 48226085, "comment_id": 83438527, "body": "@MatthieuM. the compiler is capable of converting functions taking moves into assembly that takes mutable references, inlining is orthogonal."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515768204, "post_id": 48226085, "comment_id": 83438845, "body": "@Shepmaster: Yes but... imagine a simple <code>fn move(t: T) -&gt; T { t }</code>, sure the compiler can (a) take the input per pointer and (b) take a pointer where to locate the output... but I doubt it can force the caller to use a single pointer for both, and thus there&#39;ll be a move of <code>T</code> from <code>*a</code> to <code>*b</code>."}, {"owner": {"reputation": 13169, "user_id": 967945, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/47244a17f72cee237f57f4c4b9613ea1?s=128&d=identicon&r=PG", "display_name": "Dan Hulme", "link": "https://stackoverflow.com/users/967945/dan-hulme"}, "edited": false, "score": 0, "creation_date": 1515769064, "post_id": 48226085, "comment_id": 83439376, "body": "This is what I was trying to get at with the question. I don&#39;t really understand yet when a &quot;move&quot; in Rust semantics is an actual (shallow) copy, and when it isn&#39;t. The C++ programmer in me wants to know, but C++ intuitions don&#39;t help here."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 13169, "user_id": 967945, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/47244a17f72cee237f57f4c4b9613ea1?s=128&d=identicon&r=PG", "display_name": "Dan Hulme", "link": "https://stackoverflow.com/users/967945/dan-hulme"}, "edited": false, "score": 0, "creation_date": 1515769722, "post_id": 48226085, "comment_id": 83439779, "body": "@DanHulme: It is <i>always</i> shallow, as it is a <code>memcpy</code> of the <code>struct</code> or <code>enum</code> bits... however, a shallow copy if <code>[i32; 2048]</code> still has to copy 8192 bytes (8KB)!"}, {"owner": {"reputation": 13169, "user_id": 967945, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/47244a17f72cee237f57f4c4b9613ea1?s=128&d=identicon&r=PG", "display_name": "Dan Hulme", "link": "https://stackoverflow.com/users/967945/dan-hulme"}, "edited": false, "score": 0, "creation_date": 1515769997, "post_id": 48226085, "comment_id": 83439929, "body": "@MatthieuM. Sorry, I was unclear; I meant to know whether it&#39;s a shallow copy, and when the copy can be elided completely. In the case I&#39;m working on right now, the object will be 4k, so the cost of copying is not trivial."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 13169, "user_id": 967945, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/47244a17f72cee237f57f4c4b9613ea1?s=128&d=identicon&r=PG", "display_name": "Dan Hulme", "link": "https://stackoverflow.com/users/967945/dan-hulme"}, "edited": false, "score": 1, "creation_date": 1515770258, "post_id": 48226085, "comment_id": 83440117, "body": "@DanHulme: If performance matters, I prefer starting from the assumption that the compiler will not be able to elide the move, since there&#39;s no guarantee."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 3, "last_activity_date": 1515759185, "creation_date": 1515759185, "answer_id": 48226085, "question_id": 48226014, "link": "https://stackoverflow.com/questions/48226014/what-are-the-performance-implications-of-consuming-self-and-returning-it/48226085#48226085", "title": "What are the performance implications of consuming self and returning it?", "body": "<p><strong>YMMV</strong></p>\n\n<p>Depending on the optimizer's whim, you may end up with:</p>\n\n<ul>\n<li>close to a no-op,</li>\n<li>a few register moves,</li>\n<li>a number of bit-copies.</li>\n</ul>\n\n<p>This will depend whether:</p>\n\n<ul>\n<li>the call is inlined, or not,</li>\n<li>the caller re-assigns to the original variable or creates a fresh variable (and how well LLVM handles reusing dead space),</li>\n<li>the <code>size_of::&lt;Self&gt;()</code>.</li>\n</ul>\n\n<p>The only guarantees you get is that no deep-copy will occur, as there is no <code>.clone()</code> call.</p>\n\n<p>For anything else, you need to check the LLVM IR or assembly.</p>\n"}], "owner": {"reputation": 13169, "user_id": 967945, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/47244a17f72cee237f57f4c4b9613ea1?s=128&d=identicon&r=PG", "display_name": "Dan Hulme", "link": "https://stackoverflow.com/users/967945/dan-hulme"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 265, "favorite_count": 0, "accepted_answer_id": 48226085, "answer_count": 1, "score": 0, "last_activity_date": 1515759185, "creation_date": 1515758842, "question_id": 48226014, "link": "https://stackoverflow.com/questions/48226014/what-are-the-performance-implications-of-consuming-self-and-returning-it", "title": "What are the performance implications of consuming self and returning it?", "body": "<p>I've been reading questions like <a href=\"https://stackoverflow.com/q/46606559/967945\">Why does a function that accepts a Box&lt;MyType&gt; complain of a value being moved when a function that accepts self works?</a>, <a href=\"https://stackoverflow.com/q/43684757/967945\">Preferable pattern for getting around the &quot;moving out of borrowed self&quot; checker</a>, and <a href=\"https://stackoverflow.com/q/39881365/967945\">How to capture self consuming variable in a struct?</a>, and now I'm curious about the performance characteristics of consuming self but possibly returning it to the caller.</p>\n\n<p>To make a simpler example, imagine I want to make a collection type that's guaranteed to be non-empty. To achieve this, the \"remove\" operation needs to consume the collection and optionally return itself.</p>\n\n<pre><code>struct NonEmptyCollection { ... }\n\nimpl NonEmptyCollection {\n    fn pop(mut self) -&gt; Option&lt;Self&gt; {\n        if self.len() == 1 {\n            None\n        } else {\n            // really remove the element here\n            Some(self)\n        }\n    }\n}\n</code></pre>\n\n<p>(I suppose it should return the value it removed from the list too, but it's just an example.) Now let's say I call this function:</p>\n\n<pre><code>let mut c = NonEmptyCollection::new(...);\nif let Some(new_c) = c.pop() {\n    c = new_c\n} else {\n    // never use c again\n}\n</code></pre>\n\n<p>What actually happens to the memory of the object? What if I have some code like:</p>\n\n<pre><code>let mut opt: Option&lt;NonEmptyCollection&gt; = Some(NonEmptyCollection::new(...));\nopt = opt.take().pop();\n</code></pre>\n\n<p>The function's signature can't guarantee that the returned object is actually the same one, so what optimizations are possible? Does something like the C++ <em>return value optimization</em> apply, allowing the returned object to be \"constructed\" in the same memory it was in before? If I have the choice between an interface like the above, and an interface where the caller has to deal with the lifetime:</p>\n\n<pre><code>enum PopResult {\n    StillValid,\n    Dead\n};\n\nimpl NonEmptyCollection {\n    fn pop(&amp;mut self) -&gt; PopResult {\n        // really remove the element\n        if self.len() == 0 { PopResult::Dead } else { PopResult::StillValid }\n    }\n}\n</code></pre>\n\n<p>is there ever a reason to choose this dirtier interface for performance reasons? In the <a href=\"https://stackoverflow.com/a/43695438/967945\">answer to the second example I linked</a>, trentcl recommends storing <code>Option</code>s in a data structure to allow the caller to do a change in-place instead of doing <code>remove</code> followed by <code>insert</code> every time. Would this dirty interface be a faster alternative?</p>\n"}, {"tags": ["rust", "comparison"], "comments": [{"owner": {"reputation": 1470, "user_id": 2075745, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/6f9a084d236381e1882c4e28edb5151f?s=128&d=identicon&r=PG", "display_name": "user25064", "link": "https://stackoverflow.com/users/2075745/user25064"}, "edited": false, "score": 0, "creation_date": 1515765899, "post_id": 48225587, "comment_id": 83437428, "body": "If you are keen on doing this, you could write functions and publish a crate with such logic. Looking at <code>PartialEq</code> it seems to me that you cannot implement that trait for differing types due to <code>RHS=Self</code>"}, {"owner": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "reply_to_user": {"reputation": 1470, "user_id": 2075745, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/6f9a084d236381e1882c4e28edb5151f?s=128&d=identicon&r=PG", "display_name": "user25064", "link": "https://stackoverflow.com/users/2075745/user25064"}, "edited": false, "score": 0, "creation_date": 1515765945, "post_id": 48225587, "comment_id": 83437461, "body": "@user25064 <code>RHS=Self</code> is not a trait bound, it is a default type."}, {"owner": {"reputation": 1470, "user_id": 2075745, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/6f9a084d236381e1882c4e28edb5151f?s=128&d=identicon&r=PG", "display_name": "user25064", "link": "https://stackoverflow.com/users/2075745/user25064"}, "edited": false, "score": 0, "creation_date": 1515766012, "post_id": 48225587, "comment_id": 83437489, "body": "I realized that shortly after I typed it, still, don&#39;t think that you can use a type that is not <code>Self</code>in <code>PartialEq</code>"}, {"owner": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "reply_to_user": {"reputation": 1470, "user_id": 2075745, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/6f9a084d236381e1882c4e28edb5151f?s=128&d=identicon&r=PG", "display_name": "user25064", "link": "https://stackoverflow.com/users/2075745/user25064"}, "edited": false, "score": 0, "creation_date": 1515766337, "post_id": 48225587, "comment_id": 83437667, "body": "@user25064 It&#39;s perfectly possible. <a href=\"https://play.rust-lang.org/?gist=8a740751f0c7a79144d2b6fd2ddc5167&amp;version=stable\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}], "answers": [{"comments": [{"owner": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "edited": false, "score": 0, "creation_date": 1515758116, "post_id": 48225712, "comment_id": 83433098, "body": "It makes sense, but I don&#39;t think there&#39;s an implicit cast here. We&#39;re just comparing two values as they are. I think using the <code>as</code> operator could be much worse. For example, <code>let a: u8 = 255;</code> and <code>let b: i8 = -1</code>. We could safely say that <code>a != b</code> and even that <code>a &gt; b</code> if <code>PartialEq</code> and <code>PartialOrd</code> were implemented between these types. However, <code>a == b as u8</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "edited": false, "score": 2, "creation_date": 1515758552, "post_id": 48225712, "comment_id": 83433374, "body": "@Milack27: In order to compare the value, the comparison implementation <i>will</i> have to perform a cast. At the CPU level, two integers can only be compared if they have the same bitwidth, and the comparison on the bits only make sense if both are signed or both are unsigned. It is less error-prone to implement it once, but it will occur."}, {"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "reply_to_user": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "edited": false, "score": 0, "creation_date": 1515758571, "post_id": 48225712, "comment_id": 83433386, "body": "@Milack27 if you wanted to compare <code>u8</code> with <code>i8</code> you would still need to have some common ground to do this; the difference might be obvious for a human, but this sort of operation is done on the binary level."}, {"owner": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "edited": false, "score": 0, "creation_date": 1515758896, "post_id": 48225712, "comment_id": 83433572, "body": "I understand. Nevertheless, the language itself could have a logic that checks if both <code>a</code> and <code>b</code> are within the overlapped range [0, 127]. If they are, the cast can be done safely, and the comparison follows naturally. Otherwise, it&#39;s assumed that <code>a &gt; b</code>."}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 5, "last_activity_date": 1515757738, "creation_date": 1515757738, "answer_id": 48225712, "question_id": 48225587, "link": "https://stackoverflow.com/questions/48225587/why-cant-i-compare-two-integers-of-different-types/48225712#48225712", "title": "Why can&#39;t I compare two integers of different types?", "body": "<p>It is expected behaviour - Rust is a strongly typed language and it doesn't perform implicit casts between integers of different types.</p>\n\n<p>I don't think this will ever change in the future, as it would be a potential source of bugs that are notoriously difficult to find.</p>\n\n<p>You need to be explicit and watch out for <a href=\"https://doc.rust-lang.org/book/first-edition/casting-between-types.html#numeric-casts\" rel=\"noreferrer\">potential caveats of numeric casts</a> (truncation etc.):</p>\n\n<pre><code>let x: i32 = 4;\nlet y: i16 = 4;\n\nprintln!(\"{}\", x == y as i32);\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "edited": false, "score": 0, "creation_date": 1515759654, "post_id": 48225906, "comment_id": 83433954, "body": "I guess overflows and underflows will never occur during a comparison, if it&#39;s properly implemented. Also, Rust already allows the use of mixed types by allowing the implementation of <code>PartialEq&lt;T&gt;</code> for <code>U</code>. I just think it could provide a standard implementation of it for integers, as I&#39;m forbid to implement existing traits for existing types."}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "reply_to_user": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "edited": false, "score": 0, "creation_date": 1515761987, "post_id": 48225906, "comment_id": 83435194, "body": "@Milack27 Although we can say that such implementations are possible, it is more important to understand whether we really want that. The last bullet point in the answer raises the culprit: <i>&quot;isn&#39;t using mixed types a sign of design issue?&quot;</i>"}, {"owner": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1515762623, "post_id": 48225906, "comment_id": 83435589, "body": "@E_net4 Oh sorry, now I got it! I thought <i>design issue</i> was refering to the language, not to an application. Yes, I think there&#39;s space for discussion, here. Still, my opinion remains. If the mixed types should be used or not, it&#39;s up to the programmer. In case they decide to use mixed types, the language should give full support."}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "reply_to_user": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "edited": false, "score": 3, "creation_date": 1515762992, "post_id": 48225906, "comment_id": 83435786, "body": "@Milack27 That also depends on what you call &quot;full support&quot;. How would you compare an <code>i64</code> with a <code>u64</code>? In C++, such a comparison, although not UB, could just yield an unexpected result in certain edge cases. And not everyone feels OK with the compiler introducing some complex logic for just an integer comparison."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1515764370, "post_id": 48225906, "comment_id": 83436576, "body": "I, for one, am definitely not okay in having complex logic in <code>==</code> between integers; I&#39;d rather have a compiler error pointing out I am doing something fishy than a tiny performance penalty here and there."}, {"owner": {"reputation": 99643, "user_id": 445517, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/57e2ba76e6290c4e9e19821a068bc8c1?s=128&d=identicon&r=PG", "display_name": "CodesInChaos", "link": "https://stackoverflow.com/users/445517/codesinchaos"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1515764397, "post_id": 48225906, "comment_id": 83436592, "body": "@E_net4 Check if the <code>i64</code> is smaller than zero. Otherwise convert it to <code>u64</code> and proceed with a normal comparison."}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "reply_to_user": {"reputation": 99643, "user_id": 445517, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/57e2ba76e6290c4e9e19821a068bc8c1?s=128&d=identicon&r=PG", "display_name": "CodesInChaos", "link": "https://stackoverflow.com/users/445517/codesinchaos"}, "edited": false, "score": 0, "creation_date": 1515764658, "post_id": 48225906, "comment_id": 83436724, "body": "@CodesInChaos IMO that is too much for an operation that would typically translate to one comparison machine instruction. This should be enough to understand that there is no clear cut on how Rust should behave."}, {"owner": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1515764773, "post_id": 48225906, "comment_id": 83436796, "body": "@E_net4 I think that providing a comparison logic between an <code>i64</code> and an <code>u64</code> is better than forcing the programmer to use a cast and have an unexpected result, just like it happens in C++. But if you are not OK with the overhead, you can use the cast, anyway."}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "reply_to_user": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "edited": false, "score": 0, "creation_date": 1515765050, "post_id": 48225906, "comment_id": 83436947, "body": "@Milack27 I disagree, but we have extended this discussion for too long here."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "edited": false, "score": 0, "creation_date": 1515767394, "post_id": 48225906, "comment_id": 83438343, "body": "@Milack27: Custom comparison logic makes vectorization more complicated. Rust has traditionally stood on the side of making costs explicit (even small costs) and throwing your mistakes in your face (rather than silently fixing them for you with magic). It may change, but it&#39;s the statu quo :)"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 6, "last_activity_date": 1515758445, "creation_date": 1515758445, "answer_id": 48225906, "question_id": 48225587, "link": "https://stackoverflow.com/questions/48225587/why-cant-i-compare-two-integers-of-different-types/48225906#48225906", "title": "Why can&#39;t I compare two integers of different types?", "body": "<p>There are many integral types, in Rust:</p>\n\n<ul>\n<li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code> and <code>i128</code>,</li>\n<li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code> and <code>u128</code>,</li>\n<li><code>isize</code>,</li>\n<li><code>usize</code>.</li>\n</ul>\n\n<p>In some cases, mixed arithmetic or comparisons would have an obvious implementation as a lossless conversion is possible in one direction:</p>\n\n<ul>\n<li><code>i&lt;x&gt;</code> can always be converted to <code>i&lt;y&gt;</code> if <code>x &lt; y</code>,</li>\n<li><code>u&lt;x&gt;</code> can always be converted to <code>u&lt;y&gt;</code> if <code>x &lt; y</code>,</li>\n<li><code>u&lt;x&gt;</code> can always be converted to <code>i&lt;y&gt;</code> if <code>x &lt; y</code>.</li>\n</ul>\n\n<p>Some conversions, however, are not obvious or not portable:</p>\n\n<ul>\n<li><code>i&lt;x&gt;</code> cannot be converted to <code>u&lt;y&gt;</code> no matter what the respective values of <code>x</code> and <code>y</code> are,</li>\n<li><code>isize</code> and <code>usize</code> have a platform specific size anywhere, as small as 16 bits but as large as 64 bits.</li>\n</ul>\n\n<p>Therefore, since Rust is not keen on overflows or underflows, it is unlikely that <em>arbitrary</em> mixed arithmetic or comparisons will ever be implemented.</p>\n\n<p>A restricted subset could be implemented, but then two questions are raised:</p>\n\n<ul>\n<li>isn't a restricted subset unergonomic?</li>\n<li>isn't using mixed types a sign of design issue? In the same vein that quantities should have units, quantities should probably have a <em>known magnitude</em>.</li>\n</ul>\n"}], "owner": {"reputation": 995, "user_id": 2679327, "user_type": "registered", "accept_rate": 71, "profile_image": "https://i.stack.imgur.com/9Gmc3.png?s=128&g=1", "display_name": "Milack27", "link": "https://stackoverflow.com/users/2679327/milack27"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4423, "favorite_count": 2, "accepted_answer_id": 48225906, "answer_count": 2, "score": 8, "last_activity_date": 1515764978, "creation_date": 1515757313, "last_edit_date": 1515764978, "question_id": 48225587, "link": "https://stackoverflow.com/questions/48225587/why-cant-i-compare-two-integers-of-different-types", "title": "Why can&#39;t I compare two integers of different types?", "body": "<pre><code>let x: i32 = 4;\nlet y: i16 = 4;\n\nprintln!(\"{}\", x == y);\n</code></pre>\n\n<p>When compiling the snippet above, the compiler prints the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; src/main.rs:5:25\n  |\n5 |     println!(\"{}\", x == y);\n  |                         ^ expected i32, found i16\n</code></pre>\n\n<p>It seems that <code>PartialEq</code> is not implemented for different types of integers. The same happens between <code>f32</code> and <code>f64</code>, and for <code>PartialOrd</code> as well. Is there a reason for that? Is it intended to be implemented in future versions of Rust?</p>\n"}, {"tags": ["types", "rust", "type-level-computation", "hlist"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 5, "last_activity_date": 1515741913, "last_edit_date": 1515741913, "creation_date": 1515740288, "answer_id": 48221091, "question_id": 48220203, "link": "https://stackoverflow.com/questions/48220203/type-level-map-in-rust/48221091#48221091", "title": "Type-level Map in Rust", "body": "<p>If I understand correctly, you are trying to have <code>TypeLevelMapCons&lt;K, V, Tl, TlK, TlV&gt;</code> implement <code>TypeLevelMap</code> twice with different combinations of generic type parameters. This is not possible (as of Rust 1.23.0), because there is the possibility that <code>K == TlK</code> or that <code>V == TlV</code>. With specialization, one of the impls must be strictly more specific than the \"default\" impl, i.e. it must apply to a subset of what the \"default\" impl applies to, and <em>nothing more</em>. However, here, <code>K</code> and <code>TlK</code> are unrelated (and likewise for <code>V</code> and <code>TlV</code>), so neither is more specific than the other. There is a proposed feature called <a href=\"https://internals.rust-lang.org/t/blog-post-intersection-impls/4129\" rel=\"nofollow noreferrer\"><em>intersection impls</em></a> that, as I understand it, should address this as it would allow you to write the impl that covers the intersection in order to fix the conflicting implementations error.</p>\n\n<p>However, there <em>is</em> a solution using specialization! The first step is to change <code>TypeLevelMap</code> to not be generic itself; instead, we'll make the <code>convert</code> method generic by moving the type parameters from the trait there. By doing this, we can remove the <code>TlK</code> and <code>TlV</code> type parameters on <code>TypeLevelMapCons</code>, which are of no use because they only represent <em>one</em> of the possibly many implementations of <code>TypeLevelMap</code> that the tail may have (in fact, I believe your current design is unworkable because of this).</p>\n\n<p>Implementing <code>TypeLevelMap</code> for <code>TypeLevelMapNil</code> is easy: we simply disregard the type parameters. <em>(Note: I've removed the type parameter on <code>TypeLevelMapNil</code> because it was unnecessary.)</em> Implementing <code>TypeLevelMap</code> for <code>TypeLevelMapCons</code> is a bit trickier because this is where we need to behave differently depending on the type of the key.</p>\n\n<p>Specialization doesn't let us specialize particular sets of type parameters on generic methods, only on impls, so how can we implement <code>TypeLevelMapCons</code>? By introducing an auxiliary generic trait! We can have a default implementation of that trait that handles the recursive case and a specialized implementation that handles the \"found\" case. <em>(Note: this is the same technique that the standard library uses to specialize <a href=\"https://github.com/rust-lang/rust/blob/73ac5d6a80f26c692f1e084b72d69637d7de2c8c/src/liballoc/vec.rs#L1782\" rel=\"nofollow noreferrer\"><code>&lt;Vec&lt;T&gt; as Extend&lt;T&gt;&gt;::extend&lt;I&gt;</code></a>.)</em></p>\n\n<pre><code>#![feature(specialization)]\n\nuse std::marker::PhantomData;\n\ntrait Key {\n    const KEY: usize;\n}\n\ntrait TypeLevelMap {\n    fn convert&lt;K: Key, V&gt;(K) -&gt; V;\n}\n\ntrait TypeLevelMapConvert&lt;LK, LV&gt; {\n    fn convert_impl(LK) -&gt; LV;\n}\n\nstruct TypeLevelMapNil;\n\nimpl TypeLevelMap for TypeLevelMapNil {\n    fn convert&lt;K: Key, V&gt;(_k: K) -&gt; V {\n        panic!(\"Unhandled case: {}\", K::KEY);\n    }\n}\n\nstruct TypeLevelMapCons&lt;K, V, Tl&gt;(PhantomData&lt;(K, V, Tl)&gt;);\n\nimpl&lt;K, V, Tl&gt; TypeLevelMap for TypeLevelMapCons&lt;K, V, Tl&gt;\nwhere\n    K: Key,\n    Tl: TypeLevelMap,\n{\n    fn convert&lt;LK: Key, LV&gt;(k: LK) -&gt; LV {\n        &lt;Self as TypeLevelMapConvert&lt;LK, LV&gt;&gt;::convert_impl(k)\n    }\n}\n\nimpl&lt;K, V, Tl, LK, LV&gt; TypeLevelMapConvert&lt;LK, LV&gt; for TypeLevelMapCons&lt;K, V, Tl&gt;\nwhere\n    K: Key,\n    Tl: TypeLevelMap,\n    LK: Key,\n{\n    default fn convert_impl(k: LK) -&gt; LV {\n        Tl::convert(k)\n    }\n}\n\nimpl&lt;K, V, Tl&gt; TypeLevelMapConvert&lt;K, V&gt; for TypeLevelMapCons&lt;K, V, Tl&gt;\nwhere\n    K: Key,\n    Tl: TypeLevelMap,\n{\n    fn convert_impl(_k: K) -&gt; V {\n        unimplemented!()\n    }\n}\n\n// Sample usage\n\nimpl Key for i16 {\n    const KEY: usize = 16;\n}\n\nimpl Key for i32 {\n    const KEY: usize = 32;\n}\n\nimpl Key for i64 {\n    const KEY: usize = 64;\n}\n\nfn main() {\n    TypeLevelMapCons::&lt;i16, i16, TypeLevelMapCons&lt;i32, i32, TypeLevelMapCons&lt;i64, i64, TypeLevelMapNil&gt;&gt;&gt;::convert::&lt;i64, i64&gt;(0);\n}\n</code></pre>\n\n<p>Why does the specialization work this time? First, let's look at the default impl:</p>\n\n<pre><code>impl&lt;K, V, Tl, LK, LV&gt; TypeLevelMapConvert&lt;LK, LV&gt; for TypeLevelMapCons&lt;K, V, Tl&gt;\n</code></pre>\n\n<p>Here, <code>LK</code> and <code>LV</code> are independent from <code>K</code> and <code>V</code>, respectively. This means that this impl will generate an infinite number of concrete trait implementations for a particular <code>TypeLevelMapCons&lt;K, V, Tl&gt;</code> type.</p>\n\n<p>Now, let's look at the specialized impl:</p>\n\n<pre><code>impl&lt;K, V, Tl&gt; TypeLevelMapConvert&lt;K, V&gt; for TypeLevelMapCons&lt;K, V, Tl&gt;\n</code></pre>\n\n<p>Here is that we're using <code>K</code> and <code>V</code> on both the trait and the implementer type. By doing this, we've introduced equality constraints on <code>K</code> and <code>V</code>. This means that this impl will only generate a single trait implementation for a particular <code>TypeLevelMapCons&lt;K, V, Tl&gt;</code> type. This is clearly more specific that the default impl!</p>\n"}], "owner": {"reputation": 813, "user_id": 1333945, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/5ba8a397763592097387117373dbb13a?s=128&d=identicon&r=PG", "display_name": "Nathan Ringo", "link": "https://stackoverflow.com/users/1333945/nathan-ringo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 608, "favorite_count": 0, "accepted_answer_id": 48221091, "answer_count": 1, "score": 3, "last_activity_date": 1515741913, "creation_date": 1515735595, "question_id": 48220203, "link": "https://stackoverflow.com/questions/48220203/type-level-map-in-rust", "title": "Type-level Map in Rust", "body": "<p>I'm trying to make a type-level map between two types, implemented as an association list, such that a valid map implements the trait:</p>\n\n<pre><code>trait Key {\n    const KEY: usize;\n}\n\ntrait TypeLevelMap&lt;K: Key, V&gt; {\n    fn convert(K) -&gt; V;\n}\n</code></pre>\n\n<p>The nil case is easy:</p>\n\n<pre><code>struct TypeLevelMapNil&lt;T&gt;(PhantomData&lt;T&gt;);\n\nimpl&lt;K: Key, V&gt; TypeLevelMap&lt;K, V&gt; for TypeLevelMapNil&lt;V&gt; {\n    fn convert(k: K) -&gt; V {\n        panic!(\"Unhandled case: {}\", K::KEY);\n    }\n}\n</code></pre>\n\n<p>However, I can't figure out the cons case:</p>\n\n<pre><code>struct TypeLevelMapCons&lt;K, V, Tl, TlK, TlV&gt;(PhantomData&lt;(K, V, Tl, TlK, TlV)&gt;);\n\nimpl&lt;K, V, Tl, TlK, TlV&gt; TypeLevelMap&lt;K,V&gt; for TypeLevelMapCons&lt;K, V, Tl, TlK, TlV&gt;\nwhere\n    K: Key,\n    Tl: TypeLevelMap&lt;TlK, TlV&gt;,\n    TlK: Key,\n{\n    fn convert(_k: K) -&gt; V {\n        unimplemented!()\n    }\n}\n\nimpl&lt;K, V, Tl, TlK, TlV&gt; TypeLevelMap&lt;TlK, TlV&gt; for TypeLevelMapCons&lt;K, V, Tl, TlK, TlV&gt;\nwhere\n    K: Key,\n    Tl: TypeLevelMap&lt;TlK, TlV&gt;,\n    TlK: Key,\n{\n    fn convert(k: TlK) -&gt; TlV {\n        Tl::convert(k)\n    }\n}\n</code></pre>\n\n<p>This of course gives an error, \"conflicting implementations of trait <code>TypeLevelMap&lt;_, _&gt;</code> for type <code>TypeLevelMapCons&lt;_, _, _, _, _&gt;</code>\". I can't figure out how to tell Rust to prefer the first one; specialization didn't help, and there's no <code>!=</code> in where bounds.</p>\n\n<p>Is there a way to disambiguate them, or is there another way to implement this, or is this impossible to implement in (current) Rust?</p>\n"}, {"tags": ["vector", "random", "rust"], "comments": [{"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 1, "creation_date": 1515722664, "post_id": 48218459, "comment_id": 83419057, "body": "Generate one and keep on going. /halfserious"}, {"owner": {"reputation": 3902, "user_id": 391399, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/61f56a38bf46f807b5ef431c46813c99?s=128&d=identicon&r=PG", "display_name": "mrsteve", "link": "https://stackoverflow.com/users/391399/mrsteve"}, "reply_to_user": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 0, "creation_date": 1515723748, "post_id": 48218459, "comment_id": 83419269, "body": "Like &#39; let secret_number = rand::thread_rng().gen_range(1, 101);&#39;? I could make a closure out of it and map it to a vector for 1..100?"}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 0, "creation_date": 1515723841, "post_id": 48218459, "comment_id": 83419291, "body": "Yeah, pretty much."}], "answers": [{"tags": [], "owner": {"reputation": 134258, "user_id": 785065, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/qAbxM.jpg?s=128&g=1", "display_name": "loganfsmyth", "link": "https://stackoverflow.com/users/785065/loganfsmyth"}, "is_accepted": true, "score": 14, "last_activity_date": 1552487604, "last_edit_date": 1552487604, "creation_date": 1515723829, "answer_id": 48218693, "question_id": 48218459, "link": "https://stackoverflow.com/questions/48218459/how-do-i-generate-a-vector-of-random-numbers-in-a-range/48218693#48218693", "title": "How do I generate a vector of random numbers in a range?", "body": "<p>There are a few main pieces that you need here. First, how to create a vector of 100 calculated items? The easiest way is to create a range of 100 and map over those items. For instance you could do:</p>\n\n<pre><code>let vals: Vec&lt;u64&gt; = (0..100).map(|v| v + 1000).collect();\n// [1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, ...\n</code></pre>\n\n<p>Splitting this up:</p>\n\n<ol>\n<li><a href=\"https://doc.rust-lang.org/std/ops/struct.Range.html\" rel=\"noreferrer\"><code>0..100</code></a> creates an iterator for 0 through 99</li>\n<li><a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map\" rel=\"noreferrer\"><code>.map</code></a> processes each item in the iterator when the iterator is processed.</li>\n<li><a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect\" rel=\"noreferrer\"><code>.collect()</code></a> takes an iterator and converts it into any type that implements <a href=\"https://doc.rust-lang.org/std/iter/trait.FromIterator.html\" rel=\"noreferrer\"><code>FromIterator</code></a> which in your case is <code>Vec</code>.</li>\n</ol>\n\n<p>Expanding on this for your random values, you can adjust the <code>.map</code> function to generate a random value from 0 to 20 using the <code>rand</code> crate's <code>gen_range</code> function to create a numeric value within a given range.</p>\n\n<pre><code>use rand::Rng; // 0.6.5\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    let vals: Vec&lt;u64&gt; = (0..100).map(|_| rng.gen_range(0, 20)).collect();\n\n    println!(\"{:?}\", vals);\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c10dc19e1be5986622a39ebce16e5b4b\" rel=\"noreferrer\">On the Playground</a>)</p>\n\n<p>You should also consider using the <a href=\"https://docs.rs/rand/0.6.5/rand/distributions/uniform/struct.Uniform.html\" rel=\"noreferrer\"><code>rand::distributions::Uniform</code></a> type to create the range up front, which is is more efficient than calling <code>gen_range</code> multiple times, then pull samples from it 100 times:</p>\n\n<pre><code>use rand::{distributions::Uniform, Rng}; // 0.6.5\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let range = Uniform::new(0, 20);\n\n    let vals: Vec&lt;u64&gt; = (0..100).map(|_| rng.sample(&amp;range)).collect();\n\n    println!(\"{:?}\", vals);\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d6fb38e5672e2a66fca0e9721046006d\" rel=\"noreferrer\">On the Playground</a>)</p>\n"}, {"comments": [{"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1515750771, "post_id": 48219147, "comment_id": 83428627, "body": "Could be <code>rng.gen_iter::&lt;u64&gt;().take(100).map(|n| n % 20 + 1).collect();</code> with only std."}, {"owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "reply_to_user": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 1, "creation_date": 1515751979, "post_id": 48219147, "comment_id": 83429396, "body": "@Stargateur You might at least note that <code>% 20</code> is not the same as <code>gen_range(0, 20)</code> - and I&#39;d really advise against &quot;cheating&quot; on this level, even if for specific use cases it might not matter."}, {"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "reply_to_user": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "edited": false, "score": 0, "creation_date": 1515753030, "post_id": 48219147, "comment_id": 83430103, "body": "@Stefan What do you mean, I&#39;m not cheating, this is how all ranges are implemented, <a href=\"https://doc.rust-lang.org/rand/src/rand/distributions/range.rs.html#127\" rel=\"nofollow noreferrer\">doc.rust-lang.org/rand/src/rand/distributions/range.rs.html#&zwnj;&#8203;127</a>. This is very classic."}, {"owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "reply_to_user": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1515753328, "post_id": 48219147, "comment_id": 83430302, "body": "@Stargateur Just read the comment and the <code>accept_zone</code> condition above the line you just linked to see the difference."}, {"owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "edited": false, "score": 2, "creation_date": 1515753589, "post_id": 48219147, "comment_id": 83430486, "body": "The <code>accept_zone</code> calculation is the reason why you should allocate <a href=\"https://doc.rust-lang.org/rand/rand/distributions/range/struct.Range.html\" rel=\"nofollow noreferrer\"><code>Range</code></a> once and reuse it, instead of calling <a href=\"https://doc.rust-lang.org/rand/rand/trait.Rng.html#method.gen_range\" rel=\"nofollow noreferrer\"><code>gen_range</code></a> in a loop."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 11, "last_activity_date": 1610133627, "last_edit_date": 1610133627, "creation_date": 1515727680, "answer_id": 48219147, "question_id": 48218459, "link": "https://stackoverflow.com/questions/48218459/how-do-i-generate-a-vector-of-random-numbers-in-a-range/48219147#48219147", "title": "How do I generate a vector of random numbers in a range?", "body": "<p>TL;DR:</p>\n<pre><code>use rand::{distributions::Uniform, Rng}; // 0.8.0\n\nfn main() {\n    let range = Uniform::from(0..20);\n    let values: Vec&lt;u64&gt; = rand::thread_rng().sample_iter(&amp;range).take(100).collect();\n    println!(&quot;{:?}&quot;, values);\n}\n</code></pre>\n<p>It's important to use <a href=\"https://docs.rs/rand/0.8.0/rand/distributions/uniform/struct.Uniform.html\" rel=\"nofollow noreferrer\"><code>rand::distributions::uniform::Uniform</code></a> instead of simply performing the modulo of a uniform random number. See <a href=\"https://stackoverflow.com/q/10984974/155423\">Why do people say there is modulo bias when using a random number generator?</a> for more details.</p>\n<p>Since we are generating multiple numbers from a range, it's more performant to create the <code>Uniform</code> once and reuse it. Creating the <code>Uniform</code> does some computation to avoid sampling bias.</p>\n<p>We can use <a href=\"https://docs.rs/rand/0.8.0/rand/trait.Rng.html#method.sample_iter\" rel=\"nofollow noreferrer\"><code>Rng::sample_iter</code></a> to create an iterator of random values and then <code>take</code> some number of them, collecting into a <code>Vec</code>. <code>collect</code> will even make use of <code>Iterator::size_hint</code> to allocate exactly the right number of elements.</p>\n<hr />\n<p>If you only needed a <em>single</em> random number in the range, you could use the shortcut <a href=\"https://docs.rs/rand/0.8.0/rand/trait.Rng.html#method.gen_range\" rel=\"nofollow noreferrer\"><code>Rng::gen_range</code></a>:</p>\n<pre><code>use rand::Rng; // 0.8.0\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let value: u64 = rng.gen_range(0..20);\n}\n</code></pre>\n<p>If you needed a vector of random values without limiting to a range, you can use the <code>Standard</code> distribution:</p>\n<pre><code>use rand::{distributions::Standard, Rng}; // 0.8.0\n\nfn main() {\n    let values: Vec&lt;u64&gt; = rand::thread_rng().sample_iter(Standard).take(100).collect();\n    println!(&quot;{:?}&quot;, values);\n}\n</code></pre>\n"}], "owner": {"reputation": 3902, "user_id": 391399, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/61f56a38bf46f807b5ef431c46813c99?s=128&d=identicon&r=PG", "display_name": "mrsteve", "link": "https://stackoverflow.com/users/391399/mrsteve"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4339, "favorite_count": 1, "accepted_answer_id": 48218693, "answer_count": 2, "score": 10, "last_activity_date": 1610133627, "creation_date": 1515721889, "last_edit_date": 1552486810, "question_id": 48218459, "link": "https://stackoverflow.com/questions/48218459/how-do-i-generate-a-vector-of-random-numbers-in-a-range", "title": "How do I generate a vector of random numbers in a range?", "body": "<p>How do I generate a vector of 100 64-bit integer values in the range from 1 to 20, allowing duplicates?</p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 134258, "user_id": 785065, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/qAbxM.jpg?s=128&g=1", "display_name": "loganfsmyth", "link": "https://stackoverflow.com/users/785065/loganfsmyth"}, "edited": false, "score": 1, "creation_date": 1515722262, "post_id": 48218390, "comment_id": 83418951, "body": "Is your case one where you could use a match guard? <a href=\"https://play.rust-lang.org/?gist=c0a7a49f5572c4bf441f1554b04e49b0&amp;version=stable\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}, {"owner": {"reputation": 1329, "user_id": 383958, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/JjIgB.jpg?s=128&g=1", "display_name": "Joel Burget", "link": "https://stackoverflow.com/users/383958/joel-burget"}, "reply_to_user": {"reputation": 134258, "user_id": 785065, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/qAbxM.jpg?s=128&g=1", "display_name": "loganfsmyth", "link": "https://stackoverflow.com/users/785065/loganfsmyth"}, "edited": false, "score": 0, "creation_date": 1515722878, "post_id": 48218390, "comment_id": 83419102, "body": "That&#39;s a great idea. My actual code has several branches, some of which use subfields, so it doesn&#39;t lend itself easily to that solution. Might be possible though."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515728350, "post_id": 48218642, "comment_id": 83420219, "body": "I&#39;d encourage you to move this answer to the duplicate, if you think it&#39;s a unique answer."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515730248, "post_id": 48218642, "comment_id": 83420570, "body": "You also <a href=\"https://play.rust-lang.org/?gist=e9dc6d0679789186069d44c8a08d0fc2&amp;version=stable\" rel=\"nofollow noreferrer\">don&#39;t need the <code>unwrap</code></a>. In the realm of nightly, I&#39;m excited for the <a href=\"https://play.rust-lang.org/?gist=e0627cbb49aa18665d2953727e2c1925&amp;version=nightly\" rel=\"nofollow noreferrer\"><code>match_default_bindings</code> feature</a>, which makes this even cleaner!"}, {"owner": {"reputation": 321, "user_id": 6193633, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/f642d3c45da4db031e2d41798d1801a5?s=128&d=identicon&r=PG&f=1", "display_name": "kdy", "link": "https://stackoverflow.com/users/6193633/kdy"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1515840564, "post_id": 48218642, "comment_id": 83460551, "body": "How can I do that? I didn&#39;t think it&#39;s unique. Seems like SO has a rule about duplicated answer?"}], "tags": [], "owner": {"reputation": 321, "user_id": 6193633, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/f642d3c45da4db031e2d41798d1801a5?s=128&d=identicon&r=PG&f=1", "display_name": "kdy", "link": "https://stackoverflow.com/users/6193633/kdy"}, "is_accepted": false, "score": 4, "last_activity_date": 1515728504, "last_edit_date": 1515728504, "creation_date": 1515723443, "answer_id": 48218642, "question_id": 48218390, "link": "https://stackoverflow.com/questions/48218390/in-place-updating-of-a-rust-enum-is-awkward/48218642#48218642", "title": "In-place updating of a Rust enum is awkward", "body": "<p>As of Rust 1.23.0, borrows are always lexical. The mutable reference to <code>x</code> created from this match block:</p>\n\n<pre><code>match x {\n    &amp;mut Str(ref mut s) =&gt; { s.push('k'); }\n    &amp;mut Fields { ref mut len, ref mut opt } =&gt; { \n        if *len &lt; 5 {\n            *x = Str(String::from(\"default\"));\n        } else {\n            *len += 1;\n        }\n    }\n}\n</code></pre>\n\n<p>lives until the last <code>}</code> in the code.</p>\n\n<p>Typically, another <code>{}</code> is used to avoid this issue, like:</p>\n\n<pre><code>let mut x = String::from(\"a\");\n{\n    let y = &amp;mut x;\n    *y = String::from(\"b\");\n}\n// &amp; to be explicit\nprintln!(\"borrows x: {}\", &amp;x);\n</code></pre>\n\n<p>This trick works because it limits the lexical scope. You can do</p>\n\n<pre><code>pub fn update(x: &amp;mut Enum) {\n    let s = match *x {\n        Str(ref mut s) =&gt; {\n            s.push('k');\n            return;\n        }\n        Fields {\n            ref mut len,\n            ref opt,\n        } if *len &gt;= 5 || opt.is_none() =&gt;\n        {\n            *len += 1;\n            return;\n        }\n        // opt is Some(str)\n        // Option.take() is used to get String out of\n        // &amp;mut Option&lt;String&gt;\n        Fields {\n            len: _,\n            ref mut opt,\n        } =&gt; opt.take().unwrap(),\n    };\n\n    *x = Str(s);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=39d03a6ceb0e1ef74cb11fd4e3dc8122&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a></p>\n\n<hr>\n\n<p>If you use the nightly toolchain and <code>#![feature(nll)]</code>, your code almost works. The only difference is that <code>Option::take()</code> must be used.</p>\n\n<pre><code>match *x {\n    Str(ref mut s) =&gt; {\n        s.push('k');\n    }\n    Fields {\n        ref mut len,\n        ref mut opt,\n    } =&gt; {\n        if *len &lt; 5 {\n            // Use Option::take() if you want to move owned value\n            // out of &amp;mut Option&lt;String&gt;\n            match opt.take() {\n                Some(s) =&gt; *x = Str(s),\n                None =&gt; *len += 1,\n            }\n        } else {\n            *len += 1;\n        }\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=235580d4be1242fc9dd3a7e4ee5fe186&amp;version=nightly\" rel=\"nofollow noreferrer\">https://play.rust-lang.org/?gist=235580d4be1242fc9dd3a7e4ee5fe186&amp;version=nightly</a></p>\n"}], "owner": {"reputation": 1329, "user_id": 383958, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/JjIgB.jpg?s=128&g=1", "display_name": "Joel Burget", "link": "https://stackoverflow.com/users/383958/joel-burget"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 411, "favorite_count": 0, "closed_date": 1515728276, "answer_count": 1, "score": 1, "last_activity_date": 1515728504, "creation_date": 1515721244, "last_edit_date": 1515728255, "question_id": 48218390, "link": "https://stackoverflow.com/questions/48218390/in-place-updating-of-a-rust-enum-is-awkward", "closed_reason": "Duplicate", "title": "In-place updating of a Rust enum is awkward", "body": "<p>I have a two-case enum:</p>\n\n<pre><code>#[derive(Debug)]\npub enum Enum {\n    Str(String),\n    Fields { len: u32, opt: Option&lt;String&gt; },\n}\n\nuse Enum::*;\n</code></pre>\n\n<p>I want to update my enum in-place, depending on its value. This works at first:</p>\n\n<pre><code>pub fn update(x: &amp;mut Enum) {\n    match x {\n        &amp;mut Str(ref mut s) =&gt; { s.push('k'); }\n        &amp;mut Fields { ref mut len, ref mut opt } =&gt; { *len += 1; }\n    }\n}\n</code></pre>\n\n<p>I would like to switch the enum type in some cases:</p>\n\n<pre><code>pub fn update(x: &amp;mut Enum) {\n    match x {\n        &amp;mut Str(ref mut s) =&gt; { s.push('k'); }\n        &amp;mut Fields { ref mut len, ref mut opt } =&gt; { \n            if *len &lt; 5 {\n                *x = Str(String::from(\"default\"));\n            } else {\n                *len += 1;\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>Now the borrow checker is unhappy:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0506]: cannot assign to `*x` because it is borrowed\n  --&gt; src/main.rs:14:15\n   |\n12 |         &amp;mut Fields { ref mut len, ref mut opt } =&gt; { \n   |                       ----------- borrow of `*x` occurs here\n13 |           if *len &lt; 5 {\n14 |               *x = Str(String::from(\"default\"));\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to borrowed `*x` occurs here\n</code></pre>\n\n<p>In this case, we can work around the problem by assigning to a temporary variable:</p>\n\n<pre><code>pub fn update(x: &amp;mut Enum) {\n    let mut update_hack: Option&lt;Enum&gt; = None;\n\n    match x {\n        &amp;mut Str(ref mut s) =&gt; { s.push('k'); }\n        &amp;mut Fields { ref mut len, ref mut opt } =&gt; { \n            if *len &lt; 5 {\n                update_hack = Some(Str(String::from(\"default\")));\n            } else {\n                *len += 1;\n            }\n        }\n    }\n\n    match update_hack {\n        None =&gt; {},\n        Some(to_return) =&gt; { *x = to_return; },\n    }\n}\n</code></pre>\n\n<p>But I want to use some of my data in <code>update_hack</code>.</p>\n\n<pre><code>match x {\n    &amp;mut Str(ref mut s) =&gt; { s.push('k'); }\n    &amp;mut Fields { ref mut len, ref mut opt } =&gt; { \n        match opt {\n            &amp;mut Some(ref s) =&gt; { update_hack = Some(Str(*s)) },\n            &amp;mut None =&gt; { *len += 1 },\n        }\n    }\n}\n</code></pre>\n\n<p>And now we're in more serious trouble:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n  --&gt; src/main.rs:16:62\n   |\n16 |                 &amp;mut Some(ref s) =&gt; { update_hack = Some(Str(*s)) },\n   |                                                              ^^ cannot move out of borrowed content\n</code></pre>\n\n<p>This time I'm not sure how to fix the problem. It feels like we're piling on hacks when there should be a clean way. What's the idiomatic solution?</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=49232ee41944d0347ab5b275ebbda5c2&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 1, "creation_date": 1515721413, "post_id": 48218224, "comment_id": 83418774, "body": "Possible duplicate of <a href=\"https://stackoverflow.com/questions/41889727/why-does-rust-not-allow-coercion-to-trait-objects-inside-containers\">Why does Rust not allow coercion to trait objects inside containers?</a> Although that question does not have an answer that explains how to fix it (add <code>as Box&lt;Iterator&lt;Item = f64&gt;&gt;</code>)."}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1515721674, "post_id": 48218224, "comment_id": 83418832, "body": "<a href=\"https://play.rust-lang.org/?gist=803a4c732b7ad34363d60907960834da&amp;version=stable\" rel=\"nofollow noreferrer\">Demonstration</a>."}], "answers": [{"comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1529504779, "post_id": 48218306, "comment_id": 88898803, "body": "<code>Box&lt;Iterator&lt;Item=f64&gt;&gt;</code> is the type of a boxed object of unknown size that implements <code>Iterator</code> via dynamic dispatch. In Rust 1.27 and later, <a href=\"https://stackoverflow.com/questions/50650070/what-does-dyn-mean-in-a-type\">this can be written <code>Box&lt;dyn Iterator&lt;Item=f64&gt;&gt;</code></a>, which is more explicit about the difference between the type and the trait."}], "tags": [], "owner": {"reputation": 9980, "user_id": 1944004, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/60f3cc97f94fa3690ba406f8c1a7fc4f?s=128&d=identicon&r=PG", "display_name": "Henri Menke", "link": "https://stackoverflow.com/users/1944004/henri-menke"}, "is_accepted": false, "score": 2, "last_activity_date": 1515727311, "last_edit_date": 1515727311, "creation_date": 1515720561, "answer_id": 48218306, "question_id": 48218224, "link": "https://stackoverflow.com/questions/48218224/trait-mismatch-for-function-argument/48218306#48218306", "title": "Trait mismatch for function argument", "body": "<p>To be honest, I'm no expert in Rust at all, but my expectation would have been that both of the snippets you show do not compile.  That is because, as you pointed out, <code>Iterator</code> is a trait and not a type and basically you want <code>do_something</code> to receive <em>any</em> type which implements <code>Iterator</code>.  Maybe there exists a shortcut such that the compiler can transform the signature into a generic if one of the types is a trait which could be why is sometimes works, but then I'm also not familiar with the Rust language specification enough.</p>\n\n<p>Instead of having <code>do_something</code> take something of type <code>Iterator</code> (?) make it a generic of type <code>T</code> where <code>T</code> is trait bound.</p>\n\n<pre><code>pub fn do_something&lt;T&gt;(_: Box&lt;Box&lt;T&gt;&gt;) \n    where T: Iterator&lt;Item = f64&gt; + Send {}\n\nfn main() {\n    let iter = Box::new(Box::new(vec![1.0].into_iter()));\n    do_something(iter);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=310b87f3cdecb364ae3ee46f0a3f2770&amp;version=stable\" rel=\"nofollow noreferrer\">Playground</a></p>\n\n<p>Alternatively, you constrain <code>do_something</code> entirely to <code>std::vec::IntoIter</code> and only take parameters of that type.</p>\n\n<pre><code>pub fn do_something(_: Box&lt;Box&lt;std::vec::IntoIter&lt;f64&gt;&gt;&gt;) {}\n\nfn main() {\n    let iter = Box::new(Box::new(vec![1.0].into_iter()));\n    do_something(iter);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=f6e0ecc64dc42e199287f314686cc28f&amp;version=stable\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}, {"comments": [{"owner": {"reputation": 478030, "user_id": 279627, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/2dceea858ad8f1577bec6ddaa0485d15?s=128&d=identicon&r=PG", "display_name": "Sven Marnach", "link": "https://stackoverflow.com/users/279627/sven-marnach"}, "edited": false, "score": 0, "creation_date": 1515756852, "post_id": 48218539, "comment_id": 83432415, "body": "I don&#39;t think the explanation is given in the question you linked.  You need a coercion in both code snippets given in the question.  However, in the first case the coercion needs to happen at a coercion site, so it happens implicitly (function arguments are coercion sites).  In the second case, the coercion needs to happen inside the call to <code>Box::new()</code>, and there is no reason for Rust to implicitly apply the coercion in that place.  See the <a href=\"https://doc.rust-lang.org/nomicon/coercions.html\" rel=\"nofollow noreferrer\">chapter on coercions in the nomicon</a> for more details."}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "reply_to_user": {"reputation": 478030, "user_id": 279627, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/2dceea858ad8f1577bec6ddaa0485d15?s=128&d=identicon&r=PG", "display_name": "Sven Marnach", "link": "https://stackoverflow.com/users/279627/sven-marnach"}, "edited": false, "score": 0, "creation_date": 1515767989, "post_id": 48218539, "comment_id": 83438714, "body": "@SvenMarnach I&#39;m not sure I understand your objection. The argument given in the other question is that you can&#39;t coerce a <code>Vec&lt;Box&lt;T&gt;&gt;</code> to a <code>Vec&lt;Box&lt;Trait&gt;&gt;</code>: the outer layer would have to be reallocated. The logic applies equally well to <code>Box</code>. As for coercion sites -- well, that&#39;s why I put the cast there."}, {"owner": {"reputation": 478030, "user_id": 279627, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/2dceea858ad8f1577bec6ddaa0485d15?s=128&d=identicon&r=PG", "display_name": "Sven Marnach", "link": "https://stackoverflow.com/users/279627/sven-marnach"}, "edited": false, "score": 0, "creation_date": 1515769112, "post_id": 48218539, "comment_id": 83439395, "body": "I see where you are coming from.  There is definitely some overlap between the questions.  I just think the focus is different here; the question is more or less why the first version works while the second version doesn&#39;t.  The answer to that question in my opinion is to explain what coercions happen explicitly and what coercions happen implicitly.  The other question deals with why you can&#39;t do an explicit cast on the outer level, and explains why the language has been designed that way.  So yeah, I was looking at it from a different angle, but what you say makes sense, too."}], "tags": [], "owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "is_accepted": true, "score": 2, "last_activity_date": 1515768713, "last_edit_date": 1515768713, "creation_date": 1515722597, "answer_id": 48218539, "question_id": 48218224, "link": "https://stackoverflow.com/questions/48218224/trait-mismatch-for-function-argument/48218539#48218539", "title": "Trait mismatch for function argument", "body": "<p>You can't coerce a <code>Box&lt;Box&lt;I&gt;&gt;</code> into a <code>Box&lt;Box&lt;Iterator&lt;Item = f64&gt;&gt;&gt;</code>, for reasons discussed in <a href=\"https://stackoverflow.com/q/41889727/3650362\">this question</a>, but you can coerce the inner <code>Box</code>:</p>\n\n<pre><code>pub fn do_something(_: Box&lt;Box&lt;Iterator&lt;Item = f64&gt;&gt;&gt;) {}\n\nfn main() {\n    let iter = Box::new(Box::new(vec![1.0].into_iter()) as Box&lt;Iterator&lt;Item = f64&gt;&gt;);\n    //                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    do_something(iter);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=803a4c732b7ad34363d60907960834da&amp;version=stable\" rel=\"nofollow noreferrer\">Playground</a>.</p>\n\n<p>This works because a cast is a <a href=\"https://doc.rust-lang.org/nomicon/coercions.html\" rel=\"nofollow noreferrer\">coercion site</a>. By writing <code>as Box&lt;Iterator&lt;Item = f64&gt;&gt;</code>, you're hinting to the compiler that it should attempt to make the expression to the left fit that type instead of inferring <code>Box&lt;IntoIter&lt;f64&gt;&gt;</code>, because once it's wrapped up in the \"outer\" <code>Box</code>, you can't change it anymore.</p>\n\n<p>Alternatively (but less clearly), you could make <code>Box::new(...)</code> a coercion site by explicitly parameterizing <code>Box</code>:</p>\n\n<pre><code>    let iter = Box::&lt;Box&lt;Iterator&lt;Item = f64&gt;&gt;&gt;::new(Box::new(vec![1.0].into_iter()));\n</code></pre>\n\n<p>Which effectively does the same thing.</p>\n"}], "owner": {"reputation": 1681, "user_id": 1394731, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/18e7f1db4c9cd9109baef63567e26f51?s=128&d=identicon&r=PG", "display_name": "theicfire", "link": "https://stackoverflow.com/users/1394731/theicfire"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 148, "favorite_count": 0, "accepted_answer_id": 48218539, "answer_count": 2, "score": 2, "last_activity_date": 1515768713, "creation_date": 1515719887, "last_edit_date": 1515767487, "question_id": 48218224, "link": "https://stackoverflow.com/questions/48218224/trait-mismatch-for-function-argument", "title": "Trait mismatch for function argument", "body": "<p>I've got one piece of Rust code that compiles and one that's very similar that does not.</p>\n\n<p>The one that works:</p>\n\n<pre><code>pub fn do_something(_: Box&lt;Iterator&lt;Item = f64&gt;&gt;) {}\n\nfn main() {\n    let iter = Box::new(vec![1.0].into_iter());\n    do_something(iter);\n}\n</code></pre>\n\n<p>The one that fails:</p>\n\n<pre><code>pub fn do_something(_: Box&lt;Box&lt;Iterator&lt;Item = f64&gt;&gt;&gt;) {}\n\nfn main() {\n    let iter = Box::new(Box::new(vec![1.0].into_iter()));\n    do_something(iter);\n}\n</code></pre>\n\n<p>The difference is I have a <code>Box&lt;Box&lt;..&gt;&gt;</code> instead of a <code>Box&lt;..&gt;</code></p>\n\n<p>I get the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; src/main.rs:5:18\n  |\n5 |     do_something(iter);\n  |                  ^^^^ expected trait std::iter::Iterator, found struct `std::vec::IntoIter`\n  |\n  = note: expected type `std::boxed::Box&lt;std::boxed::Box&lt;std::iter::Iterator&lt;Item=f64&gt; + 'static&gt;&gt;`\n             found type `std::boxed::Box&lt;std::boxed::Box&lt;std::vec::IntoIter&lt;{float}&gt;&gt;&gt;`\n</code></pre>\n\n<p>I'm interpreting this error to say \"<code>IntoIter</code> does not have the trait <code>Iterator</code>\" .. but it does. What's the issue?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 9980, "user_id": 1944004, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/60f3cc97f94fa3690ba406f8c1a7fc4f?s=128&d=identicon&r=PG", "display_name": "Henri Menke", "link": "https://stackoverflow.com/users/1944004/henri-menke"}, "edited": false, "score": 0, "creation_date": 1515719409, "post_id": 48218041, "comment_id": 83418324, "body": "<code>fn new(database: &amp;&#39;a mut Database&lt;&#39;a&gt;)</code> (<a href=\"https://play.rust-lang.org/?gist=6730b7904bbaa119765d6ae1f8c01422&amp;version=stable\" rel=\"nofollow noreferrer\">Playground</a>)"}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 1, "creation_date": 1515720822, "post_id": 48218041, "comment_id": 83418656, "body": "Consider updating your rustc version: Stable and nightly both report &quot;explicit lifetime required in the type of <code>database</code>&quot; and even suggest adding the <code>&#39;a</code> lifetime. (<a href=\"https://play.rust-lang.org/?gist=9eea1f8ee97a74d42f03a5542f089d1e&amp;version=stable\" rel=\"nofollow noreferrer\">playground</a>)"}], "answers": [{"comments": [{"owner": {"reputation": 2991, "user_id": 3877787, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/DPxhf.jpg?s=128&g=1", "display_name": "Zalman Stern", "link": "https://stackoverflow.com/users/3877787/zalman-stern"}, "edited": false, "score": 0, "creation_date": 1515719673, "post_id": 48218192, "comment_id": 83418376, "body": "It is perhaps helpful to think of the difference between the lifetime of the reference and the lifetime of the object. In this context it seems they are the same and the compiler should be able to figure that out, but as I understand it, lifetimes are more an annotation the compiler proves are true rather than a thing the compiler &quot;figures out.&quot; There are inference rules for providing default lifetimes, but they are fairly simple and designed to be always safe."}], "tags": [], "owner": {"reputation": 9980, "user_id": 1944004, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/60f3cc97f94fa3690ba406f8c1a7fc4f?s=128&d=identicon&r=PG", "display_name": "Henri Menke", "link": "https://stackoverflow.com/users/1944004/henri-menke"}, "is_accepted": true, "score": 2, "last_activity_date": 1515719674, "last_edit_date": 1515719674, "creation_date": 1515719552, "answer_id": 48218192, "question_id": 48218041, "link": "https://stackoverflow.com/questions/48218041/create-a-struct-pointing-to-another/48218192#48218192", "title": "Create a struct pointing to another", "body": "<p>You defined <code>Database</code> to require a lifetime parameter.  That means you also have to give it one.  The error message is really helpful here and your problem is fixed by simply doing what it says:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>expected type `&amp;'a mut Database&lt;'a&gt;`\n   found type `&amp;'a mut Database&lt;'_&gt;`\n</code></pre>\n\n<p>It suffices to simply add <code>&lt;'a&gt;</code> to <code>Database</code> in the signature of <code>new</code>.</p>\n\n<p>N.B.: Always read error messages from top to bottom.  Usually by resolving the first error all the successive ones disappear.</p>\n\n<pre><code>struct Something {}\n\nstruct Database&lt;'a&gt; {\n    something: &amp;'a Something\n}\n\n\nstruct Item&lt;'a&gt; {\n    database: &amp;'a mut Database&lt;'a&gt;\n}\n\nimpl&lt;'a&gt; Item&lt;'a&gt; {\n    fn new(database: &amp;'a mut Database&lt;'a&gt;) -&gt; Self {\n        let mut obj = Self {\n            database\n        };\n\n        obj\n    }\n}\n\nfn main() {\n    let something = &amp;Something {};\n    let mut database = Database { something };\n    let item = Item::new(&amp;mut database);\n}\n</code></pre>\n\n<p><kbd><a href=\"https://play.rust-lang.org/?gist=6730b7904bbaa119765d6ae1f8c01422&amp;version=stable\" rel=\"nofollow noreferrer\">Playground</a></kbd></p>\n"}], "owner": {"reputation": 691, "user_id": 550496, "user_type": "registered", "accept_rate": 32, "profile_image": "https://www.gravatar.com/avatar/0c625b9f4b1a2e5fbf53ec87f30e8bd0?s=128&d=identicon&r=PG", "display_name": "Adriano dos Santos Fernandes", "link": "https://stackoverflow.com/users/550496/adriano-dos-santos-fernandes"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 52, "favorite_count": 0, "accepted_answer_id": 48218192, "answer_count": 1, "score": 1, "last_activity_date": 1515726909, "creation_date": 1515718152, "last_edit_date": 1515726909, "question_id": 48218041, "link": "https://stackoverflow.com/questions/48218041/create-a-struct-pointing-to-another", "title": "Create a struct pointing to another", "body": "<p>How can I create the <code>Item</code> instance pointing to the database received as parameter?</p>\n\n<pre><code>struct Something {}\n\nstruct Database&lt;'a&gt; {\n    something: &amp;'a Something,\n}\n\nstruct Item&lt;'a&gt; {\n    database: &amp;'a mut Database&lt;'a&gt;,\n}\n\nimpl&lt;'a&gt; Item&lt;'a&gt; {\n    fn new(database: &amp;'a mut Database) -&gt; Self {\n        let mut obj = Self { database };\n\n        obj\n    }\n}\n</code></pre>\n\n<p>This produces the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:16:13\n   |\n16 |             database\n   |             ^^^^^^^^ lifetime mismatch\n   |\n   = note: expected type `&amp;'a mut Database&lt;'a&gt;`\n              found type `&amp;'a mut Database&lt;'_&gt;`\nnote: the lifetime 'a as defined on the impl at 13:1...\n  --&gt; src/main.rs:13:1\n   |\n13 | / impl&lt;'a&gt; Item&lt;'a&gt; {\n14 | |     fn new(database: &amp;'a mut Database) -&gt; Self {\n15 | |         let mut obj = Self {\n16 | |             database\n...  |\n20 | |     }\n21 | | }\n   | |_^\nnote: ...does not necessarily outlive the anonymous lifetime #1 defined on the method body at 14:5\n  --&gt; src/main.rs:14:5\n   |\n14 | /     fn new(database: &amp;'a mut Database) -&gt; Self {\n15 | |         let mut obj = Self {\n16 | |             database\n17 | |         };\n18 | |\n19 | |         obj\n20 | |     }\n   | |_____^\n</code></pre>\n\n<p>I do not understand if the error is in the return type (Self) or another thing.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 9980, "user_id": 1944004, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/60f3cc97f94fa3690ba406f8c1a7fc4f?s=128&d=identicon&r=PG", "display_name": "Henri Menke", "link": "https://stackoverflow.com/users/1944004/henri-menke"}, "edited": false, "score": 2, "creation_date": 1515710994, "post_id": 48217002, "comment_id": 83416088, "body": "Why are you trying to that?  Just move the return value and ditch the reference semantics."}, {"owner": {"reputation": 4888, "user_id": 1374563, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/puhlO.gif?s=128&g=1", "display_name": "ole", "link": "https://stackoverflow.com/users/1374563/ole"}, "reply_to_user": {"reputation": 9980, "user_id": 1944004, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/60f3cc97f94fa3690ba406f8c1a7fc4f?s=128&d=identicon&r=PG", "display_name": "Henri Menke", "link": "https://stackoverflow.com/users/1944004/henri-menke"}, "edited": false, "score": 0, "creation_date": 1515713179, "post_id": 48217002, "comment_id": 83416794, "body": "@HenriMenke I agree that this is not good example, but I&#39;m just playing with Rust I was curious is it possible to do or not."}], "answers": [{"comments": [{"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 1, "creation_date": 1515712423, "post_id": 48217199, "comment_id": 83416553, "body": "<a href=\"https://stackoverflow.com/q/40006219/3650362\">Why is it discouraged to accept a reference to a String (&amp;String), Vec (&amp;Vec) or Box (&amp;Box) as a function argument?</a> (yes, it was in the original, but I think it would be in keeping with your other changes to make this improvement as well.)"}, {"owner": {"reputation": 9980, "user_id": 1944004, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/60f3cc97f94fa3690ba406f8c1a7fc4f?s=128&d=identicon&r=PG", "display_name": "Henri Menke", "link": "https://stackoverflow.com/users/1944004/henri-menke"}, "reply_to_user": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1515712565, "post_id": 48217199, "comment_id": 83416606, "body": "@trentcl Of course, thank you!"}, {"owner": {"reputation": 4888, "user_id": 1374563, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/puhlO.gif?s=128&g=1", "display_name": "ole", "link": "https://stackoverflow.com/users/1374563/ole"}, "edited": false, "score": 0, "creation_date": 1515712781, "post_id": 48217199, "comment_id": 83416673, "body": "thanks for the advice"}], "tags": [], "owner": {"reputation": 9980, "user_id": 1944004, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/60f3cc97f94fa3690ba406f8c1a7fc4f?s=128&d=identicon&r=PG", "display_name": "Henri Menke", "link": "https://stackoverflow.com/users/1944004/henri-menke"}, "is_accepted": true, "score": 5, "last_activity_date": 1515726817, "last_edit_date": 1515726817, "creation_date": 1515711717, "answer_id": 48217199, "question_id": 48217002, "link": "https://stackoverflow.com/questions/48217002/how-to-create-mutable-string-with-specific-lifetime/48217199#48217199", "title": "How to create mutable String with specific lifetime?", "body": "<p>In my opinion, you have a logical error in your code.  You are trying to bound the lifetime of the file's contents to the lifetime of the filename, for which there is absolutely no reason.  The reason why your code cannot compile is that the line</p>\n\n<pre><code>let mut content: &amp;'a String = &amp;String::new();\n</code></pre>\n\n<p>effectively reads</p>\n\n<pre><code>let mut anonymous = String::new();\nlet mut content: &amp;'a String = &amp;anonymous;\n</code></pre>\n\n<p>The variable which I called <code>anonymous</code> does not live longer than the function.  The only way to make it live longer than the function is to use a reference-counted type to wrap the string, so that it is not dropped when it goes out of scope but only when the reference count decreases to 0.</p>\n\n<hr>\n\n<p>I suggest you simply ditch the reference semantics and use values instead.  Also calling <code>unwrap</code> in a function other than <code>main</code> is not good practice, so I topped up your code with some error handling.</p>\n\n<p>In case you worry about performance, the return value will be moved (not copied) so there is absolutely no performance penalty in this simplification.</p>\n\n<pre><code>use std::io::prelude::*;\nuse std::fs::File;\n\nfn main() {\n    let filename = String::new();\n    let content = read_file_content(&amp;filename).unwrap();\n    println!(\"{:?}\", content);\n}\n\nfn read_file_content(filename: &amp;str) -&gt; std::io::Result&lt;String&gt; {\n    //....read file content.....\n    let mut content = String::new();\n    let mut file = File::open(filename)?;\n    file.read_to_string(&amp;mut content)?;\n    Ok(content)\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=2ba5443e3b22984179bc691f1996c063&amp;version=stable\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}], "owner": {"reputation": 4888, "user_id": 1374563, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/puhlO.gif?s=128&g=1", "display_name": "ole", "link": "https://stackoverflow.com/users/1374563/ole"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 380, "favorite_count": 0, "closed_date": 1515726674, "accepted_answer_id": 48217199, "answer_count": 1, "score": 2, "last_activity_date": 1515727961, "creation_date": 1515710630, "last_edit_date": 1515726737, "question_id": 48217002, "link": "https://stackoverflow.com/questions/48217002/how-to-create-mutable-string-with-specific-lifetime", "closed_reason": "Duplicate", "title": "How to create mutable String with specific lifetime?", "body": "<p>I have a function to read file content. I need to return the content from this function by reference and I just can't figure out how to create mutable <code>String</code> with certain lifetime inside the function.</p>\n\n<pre><code>fn main() {\n    let filename = String::new();\n    let content: &amp;String = read_file_content(&amp;filename);\n    println!(\"{:?}\", content);\n}\n\nfn read_file_content&lt;'a&gt;(_filename: &amp;'a String) -&gt; &amp;'a String {\n    let mut content: &amp;'a String = &amp;String::new();\n\n    //....read file content.....\n    //File::open(filename).unwrap().read_to_string(&amp;mut content).unwrap();\n\n    return &amp;content;\n}\n</code></pre>\n\n<p>Output:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0597]: borrowed value does not live long enough\n  --&gt; src/main.rs:8:36\n   |\n8  |     let mut content: &amp;'a String = &amp;String::new();\n   |                                    ^^^^^^^^^^^^^ does not live long enough\n...\n14 | }\n   | - temporary value only lives until here\n   |\nnote: borrowed value must be valid for the lifetime 'a as defined on the function body at 7:1...\n  --&gt; src/main.rs:7:1\n   |\n7  | / fn read_file_content&lt;'a&gt;(_filename: &amp;'a String) -&gt; &amp;'a String {\n8  | |     let mut content: &amp;'a String = &amp;String::new();\n9  | |\n10 | |     //....read file content.....\n...  |\n13 | |     return &amp;content;\n14 | | }\n   | |_^\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=6fc23106ab3636f44d7cf1d3006a2ba4&amp;version=stable\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}, {"tags": ["struct", "rust", "compiler-optimization"], "comments": [{"owner": {"reputation": 2966, "user_id": 3022310, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/7f10ec2b45320ee843e539d705c31d08?s=128&d=identicon&r=PG", "display_name": "turbulencetoo", "link": "https://stackoverflow.com/users/3022310/turbulencetoo"}, "edited": false, "score": 2, "creation_date": 1515692188, "post_id": 48212841, "comment_id": 83407151, "body": "second example is supposed to read <code>.. origin</code> ?"}, {"owner": {"reputation": 3212, "user_id": 2731452, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/xA89V.jpg?s=128&g=1", "display_name": "red75prime", "link": "https://stackoverflow.com/users/2731452/red75prime"}, "edited": false, "score": 1, "creation_date": 1515693488, "post_id": 48212841, "comment_id": 83407899, "body": "The Rust compiler delegates code optimization to LLVM. You probably need to add LLVM tag to get an answer faster."}, {"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 0, "creation_date": 1515694172, "post_id": 48212841, "comment_id": 83408225, "body": "I see no reason why this should not be optimized when possible. But your second case, I don&#39;t see what optimization you want."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 3, "last_activity_date": 1515697595, "last_edit_date": 1515697595, "creation_date": 1515696493, "answer_id": 48213969, "question_id": 48212841, "link": "https://stackoverflow.com/questions/48212841/runtime-cost-of-creating-new-struct-with-update-syntax-in-rust/48213969#48213969", "title": "Runtime cost of creating new struct with update syntax in Rust", "body": "<p>Please note that you are linking to the <em>first</em> edition of the Rust book, specifically a version of it that is almost <em>2 years old</em> at this point. Your link is to the docs for version 1.6.0 but 1.23.0 is the current version. The <a href=\"https://doc.rust-lang.org/book/second-edition/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax\" rel=\"nofollow noreferrer\">second edition of the book has different phrasing</a>.</p>\n\n<blockquote>\n  <p>The Rust book explains how the struct update syntax can be used to create a copy of a struct </p>\n</blockquote>\n\n<p>There's nothing special about the update syntax. This example code only creates a copy because the struct members (<code>i32</code>, in this case) all implement <code>Copy</code>.</p>\n\n<blockquote>\n  <p>If the origin point never would be used again, will the compiler still make a [...] copy of [...] the fields</p>\n</blockquote>\n\n<p>It all depends on whether the values of the struct implement <code>Copy</code>:</p>\n\n<pre><code>#[derive(Debug)]\nstruct Coord;\n\n#[derive(Debug)]\nstruct Point3d { x: Coord, y: Coord, z: Coord }\n\nfn main() {\n    let origin = Point3d { x: Coord, y: Coord, z: Coord };\n    let point = Point3d { y: Coord, ..origin };\n\n    println!(\"{:?}\", origin);\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of partially moved value: `origin`\n  --&gt; src/main.rs:15:22\n   |\n13 |     let point = Point3d { y: Coord, ..origin };\n   |                                       ------ value moved here\n14 |     \n15 |     println!(\"{:?}\", origin);\n   |                      ^^^^^^ value used here after move\n   |\n   = note: move occurs because `origin.x` has type `Coord`, which does not implement the `Copy` trait\n</code></pre>\n\n<p>Values will be moved unless they implement <code>Copy</code>. <code>Copy</code> indicates that the compiler should feel free to copy the bits of a type around as frequently as it likes: there are no side effects, it's efficient to do so, and it's semantically correct.</p>\n\n<p>If a value is moved (i.e. doesn't implement <code>Copy</code>), then you will not be able to use it afterwards.</p>\n\n<blockquote>\n  <p>It doesn't have to be the same struct either, one can use this syntax when making new ones.</p>\n</blockquote>\n\n<p>You <em>are</em> making a new struct in both cases. It just so happens that in the first case you happen to have a mutable binding that you are putting it back into. It's effectively equivalent to:</p>\n\n<pre><code>let point = Point3d { x: 0, y: 0, z: 0 };\nlet point = Point3d { y: 1, ..point };\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 1721, "user_id": 5034140, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-H4LtHEu4ABU/AAAAAAAAAAI/AAAAAAAABfc/vgbjnSLypvo/photo.jpg?sz=128", "display_name": "Guillaume Gris", "link": "https://stackoverflow.com/users/5034140/guillaume-gris"}, "is_accepted": false, "score": 10, "last_activity_date": 1515701862, "last_edit_date": 1515701862, "creation_date": 1515701584, "answer_id": 48215107, "question_id": 48212841, "link": "https://stackoverflow.com/questions/48212841/runtime-cost-of-creating-new-struct-with-update-syntax-in-rust/48215107#48215107", "title": "Runtime cost of creating new struct with update syntax in Rust", "body": "<p>To answer questions such as \u201cDoes the compiler optimize this?\u201d, I recommend looking at the disassembly. If I compile on compiler explorer with optimization on (<code>-O</code>) the following:</p>\n\n<pre><code>pub struct P {\n    x: i32,\n    y: i32,\n}\n\npub fn f() -&gt; P {\n    let mut point = P { x: 43, y: 12 };\n    point = P { y: 1, ..point };\n    point\n}\n</code></pre>\n\n<p>I get:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>push rbp\nmov rbp, rsp\nmovabs rax, 4294967339\npop rbp\nret\n</code></pre>\n\n<p>If you know a little bit of assembly, you can see that there is no intermediate variable created or copy made. You can add extra steps to the initialization of the return value and the output assembly shouldn't change.</p>\n\n<p>If you remove optimization (I won't show assembly here), you can see in the assembly that the compiler generates a first <code>Point { x: 43, y: 12 }</code> then creates a new one by copying <code>x</code> and initializing <code>y</code> to 1.</p>\n\n<p>To sum up:</p>\n\n<ul>\n<li>The compiler generates the logic you write: Create a point then create another one by moving (i.e. copying for simple types such as <code>i32</code>) some of the data from the first one.</li>\n<li>The optimizer detects that the first point is not needed and optimizes it away.</li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 1, "last_activity_date": 1515747132, "creation_date": 1515747132, "answer_id": 48222594, "question_id": 48212841, "link": "https://stackoverflow.com/questions/48212841/runtime-cost-of-creating-new-struct-with-update-syntax-in-rust/48222594#48222594", "title": "Runtime cost of creating new struct with update syntax in Rust", "body": "<p><strong>YMMV</strong><sup>1</sup></p>\n\n<p>There is, in general, no <em>certainty</em> about the result of the optimizer. The semantics of the language may place some algorithmic bounds, however whether no copy, a single copy or three copies occur very much depends on the particular of the situation.</p>\n\n<p><strong>Semantics</strong></p>\n\n<p>Rust <em>moves</em> by default, therefore no deep-copy of the data will ever take place without a <code>.clone()</code> in the source code.</p>\n\n<p>On the other hand, the number of bitwise copies is unspecified, and may vary.</p>\n\n<p><strong>Optimization</strong></p>\n\n<p>Optimizing compilers (from then on, optimizers) operate under the as-if rule. Each language specifies a set of <em>observable behaviors</em> and the compiler must produce code which will have the same observable behavior as a naive program. Observable behavior typically include I/O, but disregards CPU cycles and memory accesses.</p>\n\n<p>The optimizer has various tricks up its sleeve:</p>\n\n<ul>\n<li>it does not need to materialize a struct, it can just manipulate the fields,</li>\n<li>it does not need to <em>copy</em> a struct or field, if two variables refer to the same value then a single value need exist,</li>\n<li>it does not need to materialize a value that is never read again,</li>\n<li>it does not need to put into memory what can be kept into a register,</li>\n<li>...</li>\n</ul>\n\n<p>So, what happen in your cases? <strong>Nothing</strong>.</p>\n\n<p>Since you are not <em>using</em> the <code>Point</code>, they need not exist.</p>\n\n<p><sup>1</sup> <em>Your Mileage May Vary, a colloquial expression meaning that your experience may vary from that of others, in general because your situation is slightly different.</em></p>\n"}], "owner": {"reputation": 113, "user_id": 8902004, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/be9571b276c5e211f7aab9987cde5ed8?s=128&d=identicon&r=PG&f=1", "display_name": "tyr.bentsen", "link": "https://stackoverflow.com/users/8902004/tyr-bentsen"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1597, "favorite_count": 0, "answer_count": 3, "score": 5, "last_activity_date": 1515754358, "creation_date": 1515691916, "last_edit_date": 1515754358, "question_id": 48212841, "link": "https://stackoverflow.com/questions/48212841/runtime-cost-of-creating-new-struct-with-update-syntax-in-rust", "title": "Runtime cost of creating new struct with update syntax in Rust", "body": "<p>The Rust book explains how the <a href=\"https://doc.rust-lang.org/1.6.0/book/structs.html#update-syntax\" rel=\"nofollow noreferrer\">struct update syntax</a> can be used to create a copy of a struct with just a few fields updated. </p>\n\n<pre><code>let mut point = Point3d { x: 0, y: 0, z: 0 };\npoint = Point3d { y: 1, .. point };\n</code></pre>\n\n<p>It doesn't have to be the same struct either, one can use this syntax when making new ones.</p>\n\n<pre><code>let origin = Point3d { x: 0, y: 0, z: 0 };\nlet point = Point3d { y: 1, .. origin };\n</code></pre>\n\n<p>My question is regarding the second example.</p>\n\n<ol>\n<li><p>If the <code>origin</code> point never would be used again, will the  compiler still make an expensive (if the fields are large) copy of (almost) all the fields, or will it only update the updated fields in place and be equivalent to the first example?</p></li>\n<li><p>In case it updates in place: how does the compiler can find out whether it can overwrite <code>origin</code> value?</p></li>\n</ol>\n"}]