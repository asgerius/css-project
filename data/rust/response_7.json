[{"tags": ["io", "rust"], "answers": [{"comments": [{"owner": {"reputation": 3226, "user_id": 2940272, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/d5925ec150904ac3fd87e7f54b21fe5c?s=128&d=identicon&r=PG", "display_name": "mkrakhin", "link": "https://stackoverflow.com/users/2940272/mkrakhin"}, "edited": false, "score": 0, "creation_date": 1424782413, "post_id": 28695964, "comment_id": 45682938, "body": "Sorry, didn&#39;t understand how it&#39;s related to File. But it pointed me to check Writer implementation again. I updated a question."}], "tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": false, "score": 0, "last_activity_date": 1424782860, "last_edit_date": 1424782860, "creation_date": 1424781366, "answer_id": 28695964, "question_id": 28695607, "link": "https://stackoverflow.com/questions/28695607/how-is-a-file-handle-closed-when-it-goes-out-of-scope/28695964#28695964", "title": "How is a file handle closed when it goes out of scope?", "body": "<p>See for example <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/io/mod.rs#L112\" rel=\"nofollow\">https://github.com/rust-lang/rust/blob/master/src/libstd/io/mod.rs#L112</a> which specifies a \"drop guard\".</p>\n\n<p><strong>Update</strong> (to your update): The stdio handles are STDIN, STDOUT and STDERR, which make no sense to close (except for daemonizing), so this is not done during normal IO operations.</p>\n"}, {"comments": [{"owner": {"reputation": 3226, "user_id": 2940272, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/d5925ec150904ac3fd87e7f54b21fe5c?s=128&d=identicon&r=PG", "display_name": "mkrakhin", "link": "https://stackoverflow.com/users/2940272/mkrakhin"}, "edited": false, "score": 0, "creation_date": 1424783044, "post_id": 28696370, "comment_id": 45683334, "body": "This seems like valid answer. Thank you :)"}], "tags": [], "owner": {"reputation": 22726, "user_id": 544621, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f0be786869c99d345f60209f98dd7b64?s=128&d=identicon&r=PG", "display_name": "hamstergene", "link": "https://stackoverflow.com/users/544621/hamstergene"}, "is_accepted": true, "score": 7, "last_activity_date": 1424782448, "creation_date": 1424782448, "answer_id": 28696370, "question_id": 28695607, "link": "https://stackoverflow.com/questions/28695607/how-is-a-file-handle-closed-when-it-goes-out-of-scope/28696370#28696370", "title": "How is a file handle closed when it goes out of scope?", "body": "<p>For POSIX platforms, <code>File</code> is defined as <code>struct File(FileDesc)</code> in mod <code>sys::fs2</code>, where <code>FileDesc</code> is a wrapper around file descriptor number. The <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/sys/unix/fd.rs#L61\">destructor of <code>FileDesc</code></a> closes the file:</p>\n\n<pre><code>impl Drop for FileDesc {\n    fn drop(&amp;mut self) {\n        // closing stdio file handles makes no sense, so never do it. Also, note\n        // that errors are ignored when closing a file descriptor. The reason\n        // for this is that if an error occurs we don't actually know if the\n        // file descriptor was closed or not, and if we retried (for something\n        // like EINTR), we might close another valid file descriptor (opened\n        // after we closed ours.\n        if self.fd &gt; libc::STDERR_FILENO {\n            let _ = unsafe { libc::close(self.fd) };\n        }\n    }\n}\n</code></pre>\n\n<p>The implementation for Windows platform defines <code>File</code> as wrapper for <code>Handle</code> value, the destructor of which <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/sys/windows/handle.rs#L40\">calls <code>CloseHandle()</code></a>.</p>\n"}], "owner": {"reputation": 3226, "user_id": 2940272, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/d5925ec150904ac3fd87e7f54b21fe5c?s=128&d=identicon&r=PG", "display_name": "mkrakhin", "link": "https://stackoverflow.com/users/2940272/mkrakhin"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 595, "favorite_count": 1, "accepted_answer_id": 28696370, "answer_count": 2, "score": 4, "last_activity_date": 1424788970, "creation_date": 1424780271, "last_edit_date": 1424788970, "question_id": 28695607, "link": "https://stackoverflow.com/questions/28695607/how-is-a-file-handle-closed-when-it-goes-out-of-scope", "title": "How is a file handle closed when it goes out of scope?", "body": "<p>I don't understand what Rust does with a file handle when it goes out of scope. For example, I create a file and write several words into it:</p>\n\n<pre><code>let wd = os::getcwd().unwrap_or(Path::new(\"/\"));\nlet mut file = File::create(&amp;Path::new(\"daemon_log.txt\"));\nfile.write_all(format!(\"DAEMON CWD: {}\", wd.as_str().unwrap_or(\"some problems\")).as_bytes());\n</code></pre>\n\n<p>At the point where file goes out of scope, the compiler should insert instructions to free memory. If my understanding of how blocking IO is usually implemented is correct, then, apart from releasing memory, the process should also release some lock.</p>\n\n<p>What I'm worried about is that in the source for <code>File</code>, I cannot find any tip for compiler to do it. <a href=\"https://blog.safaribooksonline.com/2014/01/23/file-io-rust/\" rel=\"nofollow\">This old article</a> says that all the magic goes into implementation of the <code>Drop</code> trait for <code>File</code>, but it seems that it's not true for now, because I cannot find <code>Drop</code> trait implementation in either <code>std::ops.rs</code> nor in <code>std::old_io::fs.rs</code>.</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>I checked <code>File</code>s implementation of <code>write_all</code> again and found that the <code>write</code> method works with some descriptor (<code>FileDesc</code>). I haven't found any related info about it in docs, so went to GitHub and found <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/sys/unix/fs.rs#L137\" rel=\"nofollow\">this</a>. It looks like the answer to my question, but I am confused by one line in the comment: </p>\n\n<blockquote>\n  <p>// closing stdio file handles makes no sense, so never do it</p>\n</blockquote>\n\n<p>What does this mean? I should never invoke <code>libc::close</code> on my fd myself? Or they are themselves not sure how it should be implemented?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424827231, "post_id": 28690625, "comment_id": 45707991, "body": "If I still wished to expose <code>Child</code> as <code>child::Child</code>, is my best bet to rename <code>mod child</code> as <code>mod child_impl</code> and then <code>pub mod child { pub use super::child_impl::Child }</code>?"}, {"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424850307, "post_id": 28690625, "comment_id": 45715203, "body": "@Shepmaster I can&#39;t think of a better way. But it somehow is quite similar to the <code>Foo</code> vs <code>FooInternal</code> pattern we can see all over the libstd."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424873872, "post_id": 28690625, "comment_id": 45729336, "body": "I did a quick grep for structs with <code>Internal</code> but didn&#39;t really see what you meant. Do you have a pointer handy for me to review?"}, {"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424874787, "post_id": 28690625, "comment_id": 45729962, "body": "@Shepmaster Oh, sorry, I mixed up. The term was <code>inner</code>. There are many structs that consist of a single field named <code>inner</code>. For example: <a href=\"https://github.com/rust-lang/rust/blob/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src/libstd/env.rs#L76\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/blob/&hellip;</a>"}], "tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": true, "score": 5, "last_activity_date": 1424764366, "creation_date": 1424764366, "answer_id": 28690625, "question_id": 28687122, "link": "https://stackoverflow.com/questions/28687122/how-can-i-hide-a-method-in-a-child-module-but-still-use-it-from-a-parent-module/28690625#28690625", "title": "How can I hide a method in a child module but still use it from a parent module?", "body": "<p>\nFirst of all, your <code>Child</code> struct must be public, if it is returned by a method of the <code>Parent</code>. Thus you need a</p>\n\n<pre><code>pub use child::Child;\n</code></pre>\n\n<p>Also, this will imply that the implementation of <code>Child</code> will be public as well, including the <code>new()</code> method. To prevent this, you can move it to an external helper method, that you will <strong>not</strong> reexport.</p>\n\n<p>Also, the <code>Child</code> struct should have at least one private field, if you don't want it to be buildable with the <code>Child(42)</code> syntax.</p>\n\n<p>In the end, you have something like that:</p>\n\n<pre><code>pub use child::Child;\n\nmod child {\n    pub struct Child {\n        v: u8\n    }\n\n    pub fn build_child(v: u8) -&gt; Child {\n        Child { v: v }\n    }\n\n    impl Child {\n        fn val(&amp;self) -&gt; u8 {\n            self.v\n        }\n    }\n}\n\nstruct Parent;\n\nimpl Parent {\n    fn child(&amp;self) -&gt; Child {\n        child::build_child(42)\n    }\n}\n</code></pre>\n\n<p>Here, <code>child::build_child(..)</code> is the only method able of creating a <code>Child</code> instance, and it is not visible outside of the module containing the definition of <code>Parent</code>.</p>\n"}], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 409, "favorite_count": 0, "accepted_answer_id": 28690625, "answer_count": 1, "score": 1, "last_activity_date": 1424764366, "creation_date": 1424744161, "question_id": 28687122, "link": "https://stackoverflow.com/questions/28687122/how-can-i-hide-a-method-in-a-child-module-but-still-use-it-from-a-parent-module", "title": "How can I hide a method in a child module but still use it from a parent module?", "body": "<p>I have a parent structure defined at my crate root that returns a structure that is defined in a module. I would like my parent structure to be the only thing that is capable of constructing the child structure, but I quickly run into understandable privacy and visibility issues with my na\u00efve attempt:</p>\n\n<pre><code>#![feature(unsafe_destructor)]\n\nmod child {\n    pub struct Child(u8);\n\n    impl Child {\n        fn new(v: u8) -&gt; Child { Child(v) }\n    }\n}\n\nstruct Parent;\n\nimpl Parent {\n    fn child(&amp;self) -&gt; child::Child {\n        child::Child::new(42)\n    }\n}\n\nfn main() {}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 974, "user_id": 810286, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8c3bee0764c781e1b0b8c2e53f0f11fe?s=128&d=identicon&r=PG", "display_name": "Thaddee Tyl", "link": "https://stackoverflow.com/users/810286/thaddee-tyl"}, "edited": false, "score": 0, "creation_date": 1539443316, "post_id": 28678615, "comment_id": 92508718, "body": "<code>split_off</code> is O(n) however, just like <code>insert</code>. AFAIK, with Vec, all methods of adding elements at a random position are O(n). A more efficient solution to the \u201cset index i to this item and j+1 to items at j \u2265 i\u201d relies on BTreeMap, in O(log n)."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424749202, "post_id": 28687253, "comment_id": 45667826, "body": "For the 3rd solution, instead of using <code>skip</code>, you could use <code>split_at</code>."}, {"owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1424750192, "post_id": 28687253, "comment_id": 45668067, "body": "yes, but it will require an extra &quot;offset &lt; len()&quot; check in order to prevent runtime panic."}], "tags": [], "owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "is_accepted": false, "score": 9, "last_activity_date": 1424745310, "creation_date": 1424745310, "answer_id": 28687253, "question_id": 28678615, "link": "https://stackoverflow.com/questions/28678615/efficiently-insert-or-replace-multiple-elements-in-the-middle-or-at-the-beginnin/28687253#28687253", "title": "Efficiently insert or replace multiple elements in the middle or at the beginning of a Vec?", "body": "<p>Okay, there is no appropriate method in <em>Vec</em> interface (as I can see). But we can always implement the same thing ourselves.</p>\n\n<h3>memmove</h3>\n\n<p>When <strong>T</strong> is <strong>Copy</strong>, probably the most obvious way is to move the memory, like this:</p>\n\n<pre><code>fn push_all_at&lt;T&gt;(v: &amp;mut Vec&lt;T&gt;, offset: usize, s: &amp;[T]) where T: Copy {\n    match (v.len(), s.len()) {\n        (_, 0) =&gt; (),\n        (current_len, _) =&gt; {\n            v.reserve_exact(s.len());\n            unsafe {\n                v.set_len(current_len + s.len());\n                let to_move = current_len - offset;\n                let src = v.as_mut_ptr().offset(offset as isize);\n                if to_move &gt; 0 {\n                    let dst = src.offset(s.len() as isize);\n                    std::ptr::copy_memory(dst, src, to_move);\n                }\n                std::ptr::copy_nonoverlapping_memory(src, s.as_ptr(), s.len());\n            }\n        },\n    }\n}\n</code></pre>\n\n<h3>shuffle</h3>\n\n<p>If <strong>T</strong> is not copy, but it implements <strong>Clone</strong>, we can append given slice to the end of the <em>Vec</em>, and move it to the required position using <em>swap</em>s in linear time:</p>\n\n<pre><code>fn push_all_at&lt;T&gt;(v: &amp;mut Vec&lt;T&gt;, mut offset: usize, s: &amp;[T]) where T: Clone + Default {\n    match (v.len(), s.len()) {\n        (_, 0) =&gt; (),\n        (0, _) =&gt; { v.push_all(s); },\n        (_, _) =&gt; {\n            assert!(offset &lt;= v.len());\n            let pad = s.len() - ((v.len() - offset) % s.len());\n            v.extend(repeat(Default::default()).take(pad));\n            v.push_all(s);\n            let total = v.len();\n            while total - offset &gt;= s.len() {\n                for i in 0 .. s.len() { v.swap(offset + i, total - s.len() + i); }\n                offset += s.len();\n            }\n            v.truncate(total - pad);\n        },\n    }\n}\n</code></pre>\n\n<h3>iterators concat</h3>\n\n<p>Maybe the best choice will be to not modify <em>Vec</em> at all. For example, if you are going to access the result via iterator, we can just build iterators chain from our chunks:</p>\n\n<pre><code>let v: &amp;[usize] = &amp;[0, 1, 2];\nlet s: &amp;[usize] = &amp;[3, 4, 5, 6];\nlet offset = 2;\nlet chain = v.iter().take(offset).chain(s.iter()).chain(v.iter().skip(offset));\n\nlet result: Vec&lt;_&gt; = chain.collect();\nprintln!(\"Result: {:?}\", result);\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 27, "last_activity_date": 1510580539, "last_edit_date": 1510580539, "creation_date": 1509465048, "answer_id": 47039490, "question_id": 28678615, "link": "https://stackoverflow.com/questions/28678615/efficiently-insert-or-replace-multiple-elements-in-the-middle-or-at-the-beginnin/47039490#47039490", "title": "Efficiently insert or replace multiple elements in the middle or at the beginning of a Vec?", "body": "<p>As of Rust 1.21.0, <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.splice\" rel=\"noreferrer\"><code>Vec::splice</code></a> is available and allows inserting at any point, including fully prepending:</p>\n\n<pre><code>let mut vec = vec![1, 5];\nlet slice = &amp;[2, 3, 4];\n\nvec.splice(1..1, slice.iter().cloned());\n\nprintln!(\"{:?}\", vec); // [1, 2, 3, 4, 5]\n</code></pre>\n\n<p>The docs state:</p>\n\n<blockquote>\n  <p>Note 4: This is optimal if:</p>\n  \n  <ul>\n  <li>The tail (elements in the vector after range) is empty</li>\n  <li>or <code>replace_with</code> yields fewer elements than range\u2019s length</li>\n  <li>or the lower bound of its <code>size_hint()</code> is exact.</li>\n  </ul>\n</blockquote>\n\n<p>In this case, the lower bound of the slice's iterator should be exact, so it should perform one memory move.</p>\n\n<hr>\n\n<p><code>splice</code> is a bit more powerful in that it allows you to remove a range of  values (the first argument), insert new values (the second argument), and optionally get the old values (the result of the call).</p>\n\n<p><strong>Replacing a set of items</strong></p>\n\n<pre><code>let mut vec = vec![0, 1, 5];\nlet slice = &amp;[2, 3, 4];\n\nvec.splice(..2, slice.iter().cloned());\n\nprintln!(\"{:?}\", vec); // [2, 3, 4, 5]\n</code></pre>\n\n<p><strong>Getting the previous values</strong></p>\n\n<pre><code>let mut vec = vec![0, 1, 2, 3, 4];\nlet slice = &amp;[9, 8, 7];\n\nlet old: Vec&lt;_&gt; = vec.splice(3.., slice.iter().cloned()).collect();\n\nprintln!(\"{:?}\", vec); // [0, 1, 2, 9, 8, 7]\nprintln!(\"{:?}\", old); // [3, 4]\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 4878, "user_id": 568260, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a3ff029f1f543279612e6b89b71e58e3?s=128&d=identicon&r=PG", "display_name": "Raph Levien", "link": "https://stackoverflow.com/users/568260/raph-levien"}, "edited": false, "score": 0, "creation_date": 1599882282, "post_id": 63842440, "comment_id": 112919998, "body": "In your <code>unshift</code>, I think you&#39;ll do better with <code>s.iter().cloned()</code>, as that avoids allocating the intermediate vector."}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1599913279, "post_id": 63842440, "comment_id": 112925925, "body": "Most of these seem like unnecessarily renamed versions of <code>splice</code>, which is already mentioned in the accepted answer, so what&#39;s the point of this answer? Do you really need to write <code>.unshift_vec(v)</code> when you can already write <code>.splice(..0, v)</code>?"}, {"owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 1, "creation_date": 1599915568, "post_id": 63842440, "comment_id": 112926492, "body": "I had a bunch more thoughts on this code so I compiled them into a <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=291245c605b56275d8e9aa335ed358f0\" rel=\"nofollow noreferrer\">playground</a>."}, {"owner": {"reputation": 2654, "user_id": 1153645, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/adb60cb2ea576eeb47fc2f3ff5a3081b?s=128&d=identicon&r=PG", "display_name": "Alexx Roche", "link": "https://stackoverflow.com/users/1153645/alexx-roche"}, "edited": false, "score": 0, "creation_date": 1600284463, "post_id": 63842440, "comment_id": 113042614, "body": "As someone with decades of habituation to push/pop being mirrored by unshift/shift, this is how I learnt the idiomatic Rust way. Maybe it will help someone else that is always open to learning."}, {"owner": {"reputation": 2654, "user_id": 1153645, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/adb60cb2ea576eeb47fc2f3ff5a3081b?s=128&d=identicon&r=PG", "display_name": "Alexx Roche", "link": "https://stackoverflow.com/users/1153645/alexx-roche"}, "reply_to_user": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "edited": false, "score": 0, "creation_date": 1600284590, "post_id": 63842440, "comment_id": 113042661, "body": "@trentcl I found your playground very helpful. Thank you."}], "tags": [], "owner": {"reputation": 2654, "user_id": 1153645, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/adb60cb2ea576eeb47fc2f3ff5a3081b?s=128&d=identicon&r=PG", "display_name": "Alexx Roche", "link": "https://stackoverflow.com/users/1153645/alexx-roche"}, "is_accepted": false, "score": -1, "last_activity_date": 1599808683, "creation_date": 1599808683, "answer_id": 63842440, "question_id": 28678615, "link": "https://stackoverflow.com/questions/28678615/efficiently-insert-or-replace-multiple-elements-in-the-middle-or-at-the-beginnin/63842440#63842440", "title": "Efficiently insert or replace multiple elements in the middle or at the beginning of a Vec?", "body": "<p>I was trying to prepend to a vector in rust and found <a href=\"https://stackoverflow.com/questions/47037573/how-to-prepend-a-slice-to-a-vec\">this closed question</a> that was linked here, (despite this question being <strong>both</strong> prepend and insert AND efficiency. I think my answer would be better as an answer for that other, more precises question because I can't attest to the efficiency), but the following code helped me prepend, (and the opposite.) [I'm sure that the other two answers are more efficient, but the way that I learn, I like having answers that can be cut-n-pasted with examples that demonstrate an application of the answer.]</p>\n<pre class=\"lang-rust prettyprint-override\"><code>pub trait Unshift&lt;T&gt; { fn unshift(&amp;mut self, s: &amp;[T]) -&gt; (); }\npub trait UnshiftVec&lt;T&gt; { fn unshift_vec(&amp;mut self, s: Vec&lt;T&gt;) -&gt; (); }\npub trait UnshiftMemoryHog&lt;T&gt; { fn unshift_memory_hog(&amp;mut self, s: Vec&lt;T&gt;) -&gt; (); }\npub trait Shift&lt;T&gt; { fn shift(&amp;mut self) -&gt; (); }\npub trait ShiftN&lt;T&gt; { fn shift_n(&amp;mut self, s: usize) -&gt; (); }\n\nimpl&lt;T: std::clone::Clone&gt; ShiftN&lt;T&gt; for Vec&lt;T&gt; {\n    fn shift_n(&amp;mut self, s: usize) -&gt; ()\n    // where\n    //    T: std::clone::Clone,\n    {   \n        self.drain(0..s);\n    }\n}\n\nimpl&lt;T: std::clone::Clone&gt; Shift&lt;T&gt; for Vec&lt;T&gt; {\n    fn shift(&amp;mut self) -&gt; ()\n    // where\n    //    T: std::clone::Clone,\n    {   \n        self.drain(0..1);\n    }\n}\n\nimpl&lt;T: std::clone::Clone&gt; Unshift&lt;T&gt; for Vec&lt;T&gt; {\n    fn unshift(&amp;mut self, s: &amp;[T]) -&gt; ()\n    // where\n    //    T: std::clone::Clone,\n    {   \n        self.splice(0..0, s.to_vec());\n    }\n}\nimpl&lt;T: std::clone::Clone&gt; UnshiftVec&lt;T&gt; for Vec&lt;T&gt; {\n    fn unshift_vec(&amp;mut self, s: Vec&lt;T&gt;) -&gt; ()\n    where\n        T: std::clone::Clone,\n    {   \n        self.splice(0..0, s);\n    }\n}\n\nimpl&lt;T: std::clone::Clone&gt; UnshiftMemoryHog&lt;T&gt; for Vec&lt;T&gt; {\n    fn unshift_memory_hog(&amp;mut self, s: Vec&lt;T&gt;) -&gt; ()\n    where\n        T: std::clone::Clone,\n    {\n        let mut tmp: Vec&lt;_&gt; = s.to_owned();\n        //let mut tmp: Vec&lt;_&gt; = s.clone(); // this also works for some data types\n        /*\n        let local_s: Vec&lt;_&gt; = self.clone(); // explicit clone()\n        tmp.extend(local_s);                // to vec is possible\n        */\n        tmp.extend(self.clone());\n        *self = tmp;\n        //*self = (*tmp).to_vec(); // Just because it compiles, doesn't make it right.\n    }\n}\n\n// this works for: v = unshift(v, &amp;vec![8]);\n// (If you don't want to impl Unshift for Vec&lt;T&gt;)\n\n#[allow(dead_code)]\nfn unshift_fn&lt;T&gt;(v: Vec&lt;T&gt;, s: &amp;[T]) -&gt; Vec&lt;T&gt;\nwhere\n    T: Clone,\n{\n    // create a mutable vec and fill it\n    // with a clone of the array that we want\n    // at the start of the vec.\n    let mut tmp: Vec&lt;_&gt; = s.to_owned();\n    // then we add the existing vector to the end\n    // of the temporary vector.\n    tmp.extend(v);\n    // return the tmp vec that is identitcal\n    // to unshift-ing the original vec.\n    tmp\n}\n\n/*\n    N.B. It is sometimes (often?) more memory efficient to reverse\n    the vector and use push/pop, rather than splice/drain;\n    Especially if you create your vectors in &quot;stack order&quot; to begin with.\n*/\n\nfn main() {\n    let mut v: Vec&lt;usize&gt; = vec![1, 2, 3];\n    println!(&quot;Before push:\\t {:?}&quot;, v);\n    v.push(0);\n    println!(&quot;After push:\\t {:?}&quot;, v);\n    v.pop();\n    println!(&quot;popped:\\t\\t {:?}&quot;, v);\n    v.drain(0..1);\n    println!(&quot;drain(0..1)\\t {:?}&quot;, v);\n    /*\n        // We could use a function\n    let c = v.clone();\n    v = unshift_fn(c, &amp;vec![0]);\n    */\n    v.splice(0..0, vec![0]);\n    println!(&quot;splice(0..0, vec![0]) {:?}&quot;, v);\n    v.shift_n(1);\n    println!(&quot;shift\\t\\t {:?}&quot;, v);\n    v.unshift_memory_hog(vec![8, 16, 31, 1]);\n    println!(&quot;MEMORY guzzler unshift {:?}&quot;, v);\n    //v.drain(0..3);\n    v.drain(0..=2);\n    println!(&quot;back to the start: {:?}&quot;, v);\n    v.unshift_vec(vec![0]);\n    println!(&quot;zerothed with unshift: {:?}&quot;, v);\n\n    let mut w = vec![4, 5, 6];\n    /*\n    let prepend_this = &amp;[1, 2, 3];\n    w.unshift_vec(prepend_this.to_vec());\n    */\n    w.unshift(&amp;[1, 2, 3]);\n\n    assert_eq!(&amp;w, &amp;[1, 2, 3, 4, 5, 6]);\n    println!(&quot;{:?} == {:?}&quot;, &amp;w, &amp;[1, 2, 3, 4, 5, 6]);\n}\n</code></pre>\n"}], "owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 10924, "favorite_count": 7, "accepted_answer_id": 47039490, "answer_count": 3, "score": 38, "last_activity_date": 1599882252, "creation_date": 1424709450, "last_edit_date": 1510580273, "question_id": 28678615, "link": "https://stackoverflow.com/questions/28678615/efficiently-insert-or-replace-multiple-elements-in-the-middle-or-at-the-beginnin", "title": "Efficiently insert or replace multiple elements in the middle or at the beginning of a Vec?", "body": "<p>Is there any straightforward way to insert or replace multiple elements from <code>&amp;[T]</code> and/or <code>Vec&lt;T&gt;</code> in the middle or at the beginning of a <code>Vec</code> in linear time?</p>\n\n<p>I could only find <a href=\"http://doc.rust-lang.org/nightly/std/vec/struct.Vec.html#method.insert\" rel=\"noreferrer\"><code>std::vec::Vec::insert</code></a>, but that's only for inserting a single element in <code>O(n)</code> time, so I obviously cannot call that in a loop.</p>\n\n<p>I <em>could</em> do a <code>split_off</code> at that index, <code>extend</code> the new elements into the left half of the split, and then <code>extend</code> the second half into the first, but is there a better way?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 0, "creation_date": 1424708559, "post_id": 28677561, "comment_id": 45649694, "body": "fyi, there are more lifetime problems in the code too - try to compile without the 2 <code>pair_transformer</code> calls. The trait problem may be related to it."}, {"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "reply_to_user": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 0, "creation_date": 1424777581, "post_id": 28677561, "comment_id": 45680116, "body": "By the way: The answer to this question effectively helped me to figure out the problem I actually had: <a href=\"https://github.com/servo/rust-url/pull/82\" rel=\"nofollow noreferrer\">github.com/servo/rust-url/pull/82</a>"}], "answers": [{"comments": [{"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 1, "creation_date": 1424764621, "post_id": 28681297, "comment_id": 45672791, "body": "Thank you, I am still digesting this ! It&#39;s interesting that <code>?Sized</code> cannot be in a <code>where</code> clause yet ! It&#39;s also quite special, such as I have seen no official documentation about it."}, {"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1424772955, "post_id": 28681297, "comment_id": 45677134, "body": "Thanks to your blog-post, I might have understood more of what&#39;s going on. However, I am still unable to understand why the compiler is unable to know the size of the types at compile time, which makes <code>?Sized</code> (unsized?) necessary in the first place. This basically makes the trait calls &#39;virtual&#39; (?), counteracting what a generic would usually do for you (?)."}], "tags": [], "owner": {"reputation": 1479, "user_id": 4450817, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/566922fb80a38c57d6a0db0be0f42f3b?s=128&d=identicon&r=PG&f=1", "display_name": "Vaelden", "link": "https://stackoverflow.com/users/4450817/vaelden"}, "is_accepted": true, "score": 2, "last_activity_date": 1424717921, "creation_date": 1424717921, "answer_id": 28681297, "question_id": 28677561, "link": "https://stackoverflow.com/questions/28677561/why-does-my-trait-implementation-not-match/28681297#28681297", "title": "Why does my Trait implementation not match?", "body": "<p>There are a couple of mistakes in your code:</p>\n\n<ul>\n<li>You probably want to implement your trait directly for your type, as the methods defined by the trait take the trait <em>by reference</em> (which is not the case of the <code>Add</code> trait in the other post you linked)</li>\n<li>Your use of <code>OwnedPair { first: \"a\", second: \"b\"}</code> isn't actually owned: your type will be <code>OwnedPair&lt;&amp;'static str, &amp;'static str&gt;</code> so I included examples with <code>String</code> (which are owned) as I assume that is what you wanted</li>\n<li>The items returned by your iterator are actually references, so you probably want to bind I to <code>Iterator&lt;Item=&amp;'a T&gt;</code></li>\n</ul>\n\n<p>As I tried to be as generic as possible (and for the example to compile with both <code>OwnedPair&lt;&amp;str,&amp;str&gt;</code> and <code>OwnedPair&lt;String,String&gt;</code>) I used the trait std::borrow::Borrow, which basically means that it is possible to borrow a reference to the type T from the type by which this trait is implemented.</p>\n\n<p>I also needed to use <code>?Sized</code> as a bound for most type parameters. This allows to use types which size is not known at compile time, and will be used behind a \"fat pointer\". More information in <a href=\"http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/\" rel=\"nofollow\">this blog post</a> (a little bit old)</p>\n\n<p>Here is the full corrected code (runnable in <a href=\"http://is.gd/oFpUCO\" rel=\"nofollow\">playpen</a>)</p>\n\n<pre><code>use std::borrow::Borrow;\n\ntrait Pair&lt;'a, A: ?Sized, B: ?Sized&gt; {\n    fn first_ref(&amp;'a self) -&gt; &amp;'a A;\n    fn second_ref(&amp;'a self) -&gt; &amp;'a B;\n}\n\nstruct PairOwned&lt;A, B&gt; {\n    first: A,\n    second: B,\n}\n\n// Only implemented for the cases we are interested in ...\nimpl&lt;'a, ARef: ?Sized, BRef: ?Sized, A: Borrow&lt;ARef&gt;, B: Borrow&lt;BRef&gt;&gt; Pair&lt;'a, ARef, BRef&gt; for PairOwned&lt;A,B&gt; {\n    fn first_ref(&amp;'a self) -&gt; &amp;'a ARef {\n        self.first.borrow()\n    }\n    fn second_ref(&amp;'a self) -&gt; &amp;'a BRef {\n        self.second.borrow()\n    }\n}\n\n// It should also be possible to be more generic here with Borrow\n// But I wanted to leave your original implementation\nimpl&lt;'a, A: ?Sized, B: ?Sized&gt; Pair&lt;'a, A, B&gt; for (&amp;'a A, &amp;'a B) {\n    fn first_ref(&amp;'a self) -&gt; &amp;'a A {\n        self.0\n    }\n    fn second_ref(&amp;'a self) -&gt; &amp;'a B {\n        self.1\n    }\n}\n\nfn pair_transformer&lt;'a, I, T&gt;(pairs: I) -&gt; String\n    where   T: Pair&lt;'a, str, str&gt; + 'a,\n            I: Iterator&lt;Item=&amp;'a T&gt; {\n    let mut s = String::new();\n    for pair in pairs {\n        s = s\n            + pair.first_ref().as_slice()\n            + pair.second_ref().as_slice();\n    }\n    s\n}\n\nfn main() {\n    pair_transformer([PairOwned { first: \"a\".to_string(), second: \"b\".to_string() }].iter());\n    pair_transformer([PairOwned { first: \"a\".to_string(), second: \"b\" }].iter()); // It is even possible to mix String and &amp;str\n    pair_transformer([PairOwned { first: \"a\", second: \"b\" }].iter());\n    pair_transformer([(\"a\", \"b\")].iter());\n}\n</code></pre>\n"}], "owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 233, "favorite_count": 0, "accepted_answer_id": 28681297, "answer_count": 1, "score": 1, "last_activity_date": 1424717921, "creation_date": 1424706326, "last_edit_date": 1424706882, "question_id": 28677561, "link": "https://stackoverflow.com/questions/28677561/why-does-my-trait-implementation-not-match", "title": "Why does my Trait implementation not match?", "body": "<p><strong>How can I make this code compile ?</strong></p>\n\n<pre><code>trait Pair&lt;'a, A, B&gt; {\n    fn first_ref(&amp;'a self) -&gt; &amp;'a A;\n    fn second_ref(&amp;'a self) -&gt; &amp;'a B;\n};\n\nstruct PairOwned&lt;A, B&gt; {\n    first: A,\n    second: B,\n}\n\n// Only implemented for the cases we are interested in ...\nimpl&lt;'a, A, B&gt; Pair&lt;'a, A, B&gt; for &amp;'a PairOwned&lt;&amp;'a A,&amp;'a B&gt; {\n    fn first_ref(&amp;'a self) -&gt; &amp;'a A {\n        self.first\n    }\n    fn second_ref(&amp;'a self) -&gt; &amp;'a B {\n        self.second\n    }\n}\n\nimpl&lt;'a, A, B&gt; Pair&lt;'a, A, B&gt; for &amp;'a(&amp;'a A, &amp;'a B) {\n    fn first_ref(&amp;'a self) -&gt; &amp;'a A {\n        self.0\n    }\n    fn second_ref(&amp;'a self) -&gt; &amp;'a B {\n        self.1\n    }\n}\n\nfn pair_transformer&lt;'a, I, T&gt;(pairs: I) -&gt; String\n    where   T: Pair&lt;'a, &amp;'a Str, &amp;'a Str&gt; + 'a,\n            I: Iterator&lt;Item=T&gt; {\n    let mut s = String::new();\n    for pair in pairs {\n        s = s\n            + pair.first_ref().as_slice()\n            + pair.second_ref().as_slice();\n    }\n    s\n}\n\npair_transformer([PairOwned { first: \"a\", second: \"b\" }].iter());\npair_transformer([(\"a\", \"b\")].iter());\n</code></pre>\n\n<p>The compiler says:</p>\n\n<pre><code>tests/lang.rs:902:5: 902:21 error: the trait `pair_trait_for_iteration::Pair&lt;'_, &amp;core::str::Str, &amp;core::str::Str&gt;` is not implemented for the type `&amp;pair_trait_for_iteration::PairOwned&lt;&amp;str, &amp;str&gt;` [E0277]\n tests/lang.rs:902     pair_transformer([PairOwned { first: \"a\", second: \"b\" }].iter());\n                      ^~~~~~~~~~~~~~~~\ntests/lang.rs:903:5: 903:21 error: the trait `pair_trait_for_iteration::Pair&lt;'_, &amp;core::str::Str, &amp;core::str::Str&gt;` is not implemented for the type `&amp;(&amp;str, &amp;str)` [E0277]\ntests/lang.rs:903     pair_transformer([(\"a\", \"b\")].iter());\n</code></pre>\n\n<h3>Notes</h3>\n\n<p>I have the feeling it is somehow related to the various ways to specify what a trait should be implemented for, something I have not fully understood yet.</p>\n\n<pre><code>// As stated in the answer at \n// http://stackoverflow.com/questions/28283641/what-is-the-preferred-way-to-implement-the-add-trait-efficiently-for-vector-type\nimpl Add&lt;YourType&gt; for YourType { ... }\nimpl&lt;'r&gt; Add&lt;YourType&gt; for &amp;'r YourType { ... }\nimpl&lt;'a&gt; Add&lt;&amp;'a YourType&gt; for YourType { ... }\nimpl&lt;'r, 'a&gt; Add&lt;&amp;'a YourType&gt; for &amp;'r YourType { ... }\n</code></pre>\n\n<p>Using <code>rustc 1.0.0-nightly (522d09dfe 2015-02-19) (built 2015-02-19)</code></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 0, "creation_date": 1424691636, "post_id": 28672884, "comment_id": 45639288, "body": "Shouldn&#39;t this be posted on the rust bug tracker instead ?"}, {"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "reply_to_user": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 0, "creation_date": 1424691725, "post_id": 28672884, "comment_id": 45639337, "body": "I am not sure if it is intentional or not, as I always have to assume complete err on my side. If we conclude it is more like an API design issue, it should move on to the bug tracker indeed."}, {"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "reply_to_user": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "edited": false, "score": 0, "creation_date": 1424693256, "post_id": 28672884, "comment_id": 45640203, "body": "By the way, if anyone is indeed creating an issue on github about this, please CC me using @Byron. Thank you"}, {"owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "edited": false, "score": 0, "creation_date": 1424694071, "post_id": 28672884, "comment_id": 45640640, "body": "Seems like it would be implementable for <code>IntoIterator</code>, yes. Maybe less efficiently, but implementable. I would encourage you to search the bug tracker for an issue on this, or open a new one"}, {"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1424761617, "post_id": 28672884, "comment_id": 45671520, "body": "I have created a new issue: <a href=\"https://github.com/rust-lang/rust/issues/22754\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/22754</a>"}], "answers": [{"comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1424702778, "post_id": 28675934, "comment_id": 45645996, "body": "ah you got it working. Good to see where I got stuck."}, {"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1424704363, "post_id": 28675934, "comment_id": 45646951, "body": "That will do ! Thank you. I still think it&#39;s a usability issue, either solved by improving the docs, or ... just making the common string case easier (or more obvious) to use."}, {"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1424709910, "post_id": 28675934, "comment_id": 45650587, "body": "And also, isn&#39;t the livetime magic happening at <code>I: IntoIterator&lt;Item=&amp;&#39;a S&gt;</code> unnecessary for inputs like &#39;static strings ? If I remove it, and pass in a static str, it says it doesn&#39;t live long enough. Also I&#39;d think that <code>S: Str + &#39;a</code> is the same, but more general, but it&#39;s not the case. Maybe something for another question though."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1424701395, "creation_date": 1424701395, "answer_id": 28675934, "question_id": 28672884, "link": "https://stackoverflow.com/questions/28672884/is-there-a-connect-implementation-for-iteratoritem-str/28675934#28675934", "title": "Is there a `connect()` implementation for `Iterator&lt;Item=Str&gt;`?", "body": "<p>The closest solution I know of would be to use <a href=\"http://bluss.github.io/rust-itertools/doc/itertools/trait.Itertools.html#method.intersperse\" rel=\"nofollow\"><code>Itertools::intersperse</code></a>:</p>\n\n<pre><code>#![feature(core)]\n\nextern crate itertools;\n\nuse std::iter::IntoIterator;\nuse itertools::Itertools;\n\nfn connected&lt;'a, S, I&gt;(s: I) -&gt; String //'\n    where S: Str,\n          I: IntoIterator&lt;Item=&amp;'a S&gt; //'\n{\n    s.into_iter().map(|s| s.as_slice()).intersperse(\", \").collect()\n}\n\nfn main() {\n    println!(\"{}\", connected(&amp;[\"foo\", \"bar\"]));\n}\n</code></pre>\n"}], "owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 329, "favorite_count": 0, "closed_date": 1505698898, "accepted_answer_id": 28675934, "answer_count": 1, "score": 5, "last_activity_date": 1424701395, "creation_date": 1424691387, "question_id": 28672884, "link": "https://stackoverflow.com/questions/28672884/is-there-a-connect-implementation-for-iteratoritem-str", "closed_reason": "Duplicate", "title": "Is there a `connect()` implementation for `Iterator&lt;Item=Str&gt;`?", "body": "<p>Currently the <a href=\"http://doc.rust-lang.org/std/slice/trait.SliceConcatExt.html\" rel=\"noreferrer\">SliceConcatExt</a> seems to be very specifically crafted for slices or vectors of Strings, even though it arbitrarily constrains its use. That particular use-case is reflected in the trait name as well, after all, it is called <code>SliceConcatExt</code> for a reason.</p>\n\n<p><strong>Is there a more general <code>connect()</code> implementation which would take any Iterator over items supporting the Str trait ?</strong>. \nIf not, are there any plans to remedy this ?</p>\n\n<h2>Example</h2>\n\n<pre><code>use std::iter::IntoIterator;\n\nfn connected&lt;S, I&gt;(s: I) -&gt; String\nwhere S: Str,\n      I: IntoIterator&lt;Item=S&gt; {\n    // have\n    s.into_iter().collect::&lt;Vec&lt;S&gt;&gt;().connect(\", \")\n\n    // want\n    // s.into_iter().connect(\", \")\n    // error: type `&lt;I as core::iter::IntoIterator&gt;::IntoIter` does not implement any method in scope named `connect`\n    // tests/lang.rs:790         s.into_iter().connect(\", \")\n}\n\nconnected(&amp;[\"foo\", \"bar\"]);\n</code></pre>\n\n<p>One could possibly implement <code>SliceConcatExt</code> for any iterator with item type Str, but I have the suspicion that <code>connect()</code> currently is just unnecessarily specialized, which might be fixable until Rust beta.</p>\n\n<p>Using <code>rustc 1.0.0-nightly (522d09dfe 2015-02-19) (built 2015-02-19)</code></p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 543, "user_id": 4472139, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/045dec65d2e67a4fb029469d483f3ebd?s=128&d=identicon&r=PG&f=1", "display_name": "sgldiv", "link": "https://stackoverflow.com/users/4472139/sgldiv"}, "edited": false, "score": 1, "creation_date": 1424690811, "post_id": 28672411, "comment_id": 45638760, "body": "Is there no way to &quot;move&quot; args out of sys, e.g. like std:move or copy elision. The following works, but there too I am assigning to a local variable, but somehow I think the compiler knows how to move it out:    pub fn contents(source:&amp;String) -&gt; Vec&lt;String&gt; {      let mut reader = BufferedReader::new(File::open( &amp;Path::new(source)));     reader.lines().map(|l| l.unwrap()).collect()   }"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 543, "user_id": 4472139, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/045dec65d2e67a4fb029469d483f3ebd?s=128&d=identicon&r=PG&f=1", "display_name": "sgldiv", "link": "https://stackoverflow.com/users/4472139/sgldiv"}, "edited": false, "score": 1, "creation_date": 1424691786, "post_id": 28672411, "comment_id": 45639371, "body": "@sgldiv <code>Reader::lines</code> is an <code>Iterator&lt;Item=String&gt;</code>, not an <code>Iterator&lt;Item=&amp;&#39;a str&gt;</code>. You return a <code>Vec&lt;String&gt;</code> which has full ownership of all data that&#39;s returned. There is nothing from which the return value is borrowed and which the compiler magically silently moves around."}, {"owner": {"reputation": 543, "user_id": 4472139, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/045dec65d2e67a4fb029469d483f3ebd?s=128&d=identicon&r=PG&f=1", "display_name": "sgldiv", "link": "https://stackoverflow.com/users/4472139/sgldiv"}, "edited": false, "score": 1, "creation_date": 1424692696, "post_id": 28672411, "comment_id": 45639903, "body": "That makes sense. Thanks!"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 8, "last_activity_date": 1424689966, "creation_date": 1424689966, "answer_id": 28672411, "question_id": 28672190, "link": "https://stackoverflow.com/questions/28672190/how-do-i-set-the-lifetime-of-a-return-value-as-the-lifetime-of-the-variable-i-mo/28672411#28672411", "title": "How do I set the lifetime of a return value as the lifetime of the variable I move into it?", "body": "<blockquote>\n  <p>I think the error is because there's no way for compiler to infer that I want the lifetime of this newly created struct to be the lifetime of the variable I want to move this into.</p>\n</blockquote>\n\n<p>Actually, no.</p>\n\n<p>The error is because you are trying to create references into the variable <code>args</code> which will no longer be valid after you return from <code>sys</code> since <code>args</code> is a local variable and thus is dropped at the end of <code>sys</code>.</p>\n\n<p>If you wish to use references, you could supply <code>sys</code> with a <code>&amp;'a mut Vec&lt;String&gt;</code> (empty), fill it in <code>sys</code>, and return references to it:</p>\n\n<pre><code>pub fn sys&lt;'a&gt;(args: &amp;'a mut Vec&lt;String&gt;) -&gt; Parsed&lt;'a&gt; {\n    *args = env::args().collect();\n    parsed(args.as_slice())\n}\n</code></pre>\n\n<p>which guarantees that <code>args</code> outlive the <code>sys</code> call. This will borrow <code>args</code> for the lifetime of the result.</p>\n\n<p>Another solution is to do away with <code>'a</code> and simply have <code>Parsed</code> own its elements rather than have references to them; however without the definition of <code>Parsed</code> I cannot advise how best to do so.</p>\n"}], "owner": {"reputation": 543, "user_id": 4472139, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/045dec65d2e67a4fb029469d483f3ebd?s=128&d=identicon&r=PG&f=1", "display_name": "sgldiv", "link": "https://stackoverflow.com/users/4472139/sgldiv"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4457, "favorite_count": 1, "accepted_answer_id": 28672411, "answer_count": 1, "score": 11, "last_activity_date": 1424700315, "creation_date": 1424689152, "last_edit_date": 1424700315, "question_id": 28672190, "link": "https://stackoverflow.com/questions/28672190/how-do-i-set-the-lifetime-of-a-return-value-as-the-lifetime-of-the-variable-i-mo", "title": "How do I set the lifetime of a return value as the lifetime of the variable I move into it?", "body": "<p>I am trying to teach myself some rust, and have written something that looks like:</p>\n\n<pre><code>let args:Vec&lt;String&gt; = env::args().collect();\nlet parsed = parser::sys(args.as_slice());\n</code></pre>\n\n<p>...</p>\n\n<pre><code>pub fn sys&lt;'a&gt;(args:&amp;'a [String]) -&gt; Parsed&lt;'a&gt; {\n  parsed(args)\n}\n</code></pre>\n\n<p>where <code>parsed</code> is a function that parses and loads configs.</p>\n\n<p>This works fine. Now I am trying to abstract away explicitly calling <code>env::args()</code> and hide it in the call to <code>sys</code> , so I write a new version of <code>sys</code></p>\n\n<pre><code>pub fn sys&lt;'a&gt;() -&gt; Parsed&lt;'a&gt; {\n  let args:Vec&lt;String&gt; = env::args().collect();\n  parsed(args.as_slice())\n}\n</code></pre>\n\n<p>And this fails with: </p>\n\n<pre><code>error: `args` does not live long enough\nsrc/test.rs:66      parsed(args.as_slice())\n</code></pre>\n\n<p>I think the error is because there's no way for compiler to infer that I want the lifetime of this newly created struct to be the lifetime of the variable I want to move this into. Is this correct? How would I annotate the lifetime on this return value/fix this? </p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 2, "creation_date": 1424685348, "post_id": 28670683, "comment_id": 45635764, "body": "<code>File::metadata()</code> returns a <code>Metadata</code>, <code>Metadata::permissions()</code> returns a <code>Permission</code>, and that <code>set_mode</code> is just setting the mode in that copy of the permissions, it&#39;s not actually applying it to the file. (And I can&#39;t seem to find any way to do that.)"}], "answers": [{"tags": [], "owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "is_accepted": true, "score": 8, "last_activity_date": 1424694477, "creation_date": 1424694477, "answer_id": 28673836, "question_id": 28670683, "link": "https://stackoverflow.com/questions/28670683/how-are-permissions-applied-to-a-file-using-set-mode/28673836#28673836", "title": "How are permissions applied to a file using set_mode?", "body": "<p>Use <a href=\"http://doc.rust-lang.org/std/fs/struct.OpenOptions.html\" rel=\"noreferrer\"><code>OpenOptions</code></a>:</p>\n\n<pre><code>use std::fs;\nuse std::os::unix::OpenOptionsExt;\n\nfn main() {\n    fs::OpenOptions::new()\n        .create(true)\n        .write(true)\n        .mode(0o770)\n        .open(\"somefile\")\n        .unwrap();\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 238, "user_id": 12466360, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/34upu.jpg?s=128&g=1", "display_name": "Karthik Nedunchezhiyan", "link": "https://stackoverflow.com/users/12466360/karthik-nedunchezhiyan"}, "is_accepted": false, "score": 4, "last_activity_date": 1595689988, "last_edit_date": 1595689988, "creation_date": 1595686607, "answer_id": 63089421, "question_id": 28670683, "link": "https://stackoverflow.com/questions/28670683/how-are-permissions-applied-to-a-file-using-set-mode/63089421#63089421", "title": "How are permissions applied to a file using set_mode?", "body": "<p>You can also use <a href=\"http://std::fs::set_permissions\" rel=\"nofollow noreferrer\">set_permissions</a> for existing path</p>\n<pre><code>use std::fs;\nuse std::os::unix::fs::PermissionsExt;\n\nfn main(){\n     fs::set_permissions(&quot;/path&quot;, fs::Permissions::from_mode(0o655)).unwrap();\n}\n</code></pre>\n"}], "owner": {"reputation": 647, "user_id": 4523058, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/a975dc9f5de333ddaf78b50c048548ec?s=128&d=identicon&r=PG", "display_name": "urubi", "link": "https://stackoverflow.com/users/4523058/urubi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1639, "favorite_count": 0, "accepted_answer_id": 28673836, "answer_count": 2, "score": 3, "last_activity_date": 1595689988, "creation_date": 1424684331, "question_id": 28670683, "link": "https://stackoverflow.com/questions/28670683/how-are-permissions-applied-to-a-file-using-set-mode", "title": "How are permissions applied to a file using set_mode?", "body": "<p>If my understanding is correct, the following code should produce an executable file. However it doesn't; it gets created, but the permissions specified aren't applied. What am I doing wrong?</p>\n\n<pre><code>use std::fs;\nuse std::os::unix::PermissionsExt;\n\n\nfn main() {\n    fs::File::create(\"somefile\").unwrap()\n        .metadata().unwrap()\n        .permissions()\n        .set_mode(0o770);\n}\n</code></pre>\n"}, {"tags": ["loops", "rust"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1424688579, "post_id": 28669672, "comment_id": 45637527, "body": "Note: @ker presented the alternative using <code>itertools</code> to implement on top of the range notation."}], "tags": [], "owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "is_accepted": true, "score": 4, "last_activity_date": 1424680710, "creation_date": 1424680710, "answer_id": 28669672, "question_id": 28669607, "link": "https://stackoverflow.com/questions/28669607/how-to-iterate-over-every-second-number/28669672#28669672", "title": "How to iterate over every second number", "body": "<p>There's <a href=\"http://doc.rust-lang.org/nightly/std/iter/fn.range_step.html\" rel=\"nofollow\"><code>std::iter::range_step</code></a> right now, but it's marked as unstable with the message \"likely to be replaced by range notation and adapters\".</p>\n\n<pre><code>fn main() {\n    for i in std::iter::range_step(0, 10, 2) {\n        println!(\"{:?}\", i);\n    }\n}\n</code></pre>\n\n<p>prints</p>\n\n<pre><code>0\n2\n4\n6\n8\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 3, "last_activity_date": 1424681417, "creation_date": 1424681417, "answer_id": 28669854, "question_id": 28669607, "link": "https://stackoverflow.com/questions/28669607/how-to-iterate-over-every-second-number/28669854#28669854", "title": "How to iterate over every second number", "body": "<p>the <a href=\"https://crates.io/crates/itertools\" rel=\"nofollow\">itertools crate</a> offers what you want for abitrary iterators. The <a href=\"http://bluss.github.io/rust-itertools/doc/itertools/trait.Itertools.html#method.step\" rel=\"nofollow\">step function</a> creates an iterator that skips <code>n-1</code> elements after each iteration.</p>\n\n<pre><code>use itertools::Itertools;\n\nlet mut it = (0..10).step(2);\nassert_eq!(it.next(), Some(0));\nassert_eq!(it.next(), Some(2));\nassert_eq!(it.next(), Some(4));\nassert_eq!(it.next(), Some(6));\nassert_eq!(it.next(), Some(8));\nassert_eq!(it.next(), None);\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 81, "user_id": 11006412, "user_type": "registered", "profile_image": "https://lh5.googleusercontent.com/-R2zMO3bMOnA/AAAAAAAAAAI/AAAAAAAALUU/HLaQU9AibMA/photo.jpg?sz=128", "display_name": "Hyp-X", "link": "https://stackoverflow.com/users/11006412/hyp-x"}, "is_accepted": false, "score": 8, "last_activity_date": 1549651234, "creation_date": 1549651234, "answer_id": 54598432, "question_id": 28669607, "link": "https://stackoverflow.com/questions/28669607/how-to-iterate-over-every-second-number/54598432#54598432", "title": "How to iterate over every second number", "body": "<p>This is now implemented in std with the <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by\" rel=\"noreferrer\">step_by function</a></p>\n\n<pre><code>for i in (0..10).step_by(2) {\n    // Do stuff\n}\n</code></pre>\n"}], "owner": {"reputation": 179, "user_id": 3212948, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/iylAi.png?s=128&g=1", "display_name": "someonewithpc", "link": "https://stackoverflow.com/users/3212948/someonewithpc"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2564, "favorite_count": 0, "accepted_answer_id": 28669672, "answer_count": 3, "score": 6, "last_activity_date": 1549651234, "creation_date": 1424680440, "last_edit_date": 1424683536, "question_id": 28669607, "link": "https://stackoverflow.com/questions/28669607/how-to-iterate-over-every-second-number", "title": "How to iterate over every second number", "body": "<p>Reading the docs, I noticed a sentence saying: \"Rust doesn't have a <em>C style</em> for loop.\". So, I wonder, how can I make a loop equivalent to <code>for(i = 0; i &lt; 10; i += 2) { }</code>? </p>\n\n<p>The ways I can think of are something like:</p>\n\n<pre><code>for i in 0..10 {\n    if i % 2 == 0 {\n        //Do stuff\n    }\n}\n</code></pre>\n\n<p>Or even:</p>\n\n<pre><code>let i = 0;\nloop {\n    if i &lt; 10 {\n        //Do stuff\n        i += 2;\n    } else {\n        break;\n    }\n}\n</code></pre>\n\n<p>But I'm not sure this is the best way, especially since it's really verbose. Is there a <em>better way</em>? I'm guessing it would be with <em>iterators</em>, but I'm not sure how I'd do that. </p>\n"}, {"tags": ["image", "image-processing", "types", "rust", "associated-types"], "comments": [{"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 1, "creation_date": 1424738483, "post_id": 28669417, "comment_id": 45665176, "body": "A type implementing <code>GenericImage</code> specifies a particular type for <code>Pixel</code> which I presume the <code>put_pixel</code> method takes; you, however, have given it an <code>Rgba</code>, which is not necessarily the correct type."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 0, "last_activity_date": 1424740984, "last_edit_date": 1424740984, "creation_date": 1424740659, "answer_id": 28686681, "question_id": 28669417, "link": "https://stackoverflow.com/questions/28669417/rust-rust-image-private-associated-type/28686681#28686681", "title": "Rust + Rust Image - Private &#39;Associated Type&#39;?", "body": "<p>Chris Morgan is spot on - when you are accepting a <code>GenericImage</code>, you have to handle a generic <code>Pixel</code>. However, you are trying to use a specific one - <code>Rgba</code>. Even more than that, you have to specify the type of the channels of the <code>Rgba</code>.</p>\n\n<p>A notable issue with your original code is: what do you do when the GenericImage is composed of pixels that <em>don't support transparency</em>?</p>\n\n<p>Here's a version that picks some concrete types and compiles:</p>\n\n<pre><code>fn remove_background&lt;T&gt;(img: &amp;mut T)\n    where T: image::GenericImage&lt;Pixel=image::Rgba&lt;u8&gt;&gt;\n{\n    let background_color = img.get_pixel(0, 0).to_rgba();\n\n    if background_color[3].to_uint().unwrap() &gt; 0 {\n        for (_, _, color) in img.pixels_mut() {\n\n            let rgba = color.to_rgba();\n\n            let (dr,dg,db) = (rgba[0] - background_color[0],\n                              rgba[1] - background_color[1],\n                              rgba[2] - background_color[2]);\n\n            // Remove the background colour.\n            if (dr*dr + dg*dg + db*db).to_uint().unwrap() &lt; 16384 {\n                for c in color.channels_mut().iter_mut() { *c = 0 }\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>Beyond specifying the specific pixel type in the <code>where</code> clause, you'll also run into mutability issues. I changed it to <code>pixels_mut</code>, <code>channels_mut</code>, and <code>iter_mut</code> to get the mutability to the right place.</p>\n\n<p>Note that the Rust style is 4-space indents, so I've done that as well.</p>\n"}], "owner": {"reputation": 390, "user_id": 3747942, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/081ec3ff7ebbd8cf4812f90a16c963af?s=128&d=identicon&r=PG", "display_name": "quadrupleslap", "link": "https://stackoverflow.com/users/3747942/quadrupleslap"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 146, "favorite_count": 0, "accepted_answer_id": 28686681, "answer_count": 1, "score": 0, "last_activity_date": 1424740984, "creation_date": 1424679480, "question_id": 28669417, "link": "https://stackoverflow.com/questions/28669417/rust-rust-image-private-associated-type", "title": "Rust + Rust Image - Private &#39;Associated Type&#39;?", "body": "<p>The goal is simple - get the colour at (0, 0) and remove any pixels in the image that are similar to it within the specified threshold (16384 in this case). However, the code below doesn't compile:</p>\n\n<pre><code>#![feature(env, old_path, core, old_io)]\n\nextern crate image;\n\nuse std::env;\nuse std::num::ToPrimitive;\nuse std::old_io::File;\nuse image::color::FromColor;\n\nuse image::Pixel;\n\nfn get_arguments() -&gt; Vec&lt;String&gt; {\n  let mut argv: Vec&lt;String&gt; = env::args().collect();\n  argv.remove(0);\n  return argv;\n}\n\nfn remove_background&lt;T:image::GenericImage&gt;(img: &amp;mut T) {\n  let background_color = img.get_pixel(0, 0).to_rgba();\n\n  let transparent_pixel = image::Rgba([0, 0, 0, 0]);\n\n  if background_color[3].to_uint().unwrap() &gt; 0 {\n    for (x, y, color) in img.pixels() {\n\n      let rgba = color.to_rgba();\n\n      let (dr,dg,db) = (rgba[0] - background_color[0],\n                        rgba[1] - background_color[1],\n                        rgba[2] - background_color[2]);\n\n      if (dr*dr + dg*dg + db*db).to_uint().unwrap() &lt; 16384 { img.put_pixel(x, y, transparent_pixel); } // Remove the background colour.\n\n    }\n  }\n}\n\nfn main() {\n  for filepath in get_arguments() {\n    let img = image::open( &amp;Path::new(filepath) ).unwrap();\n\n    remove_background( &amp;mut img );\n\n\n    let ref mut fout = File::create(&amp;Path::new(\"output.png\")).unwrap();\n    img.save(fout, image::PNG);\n  }\n}\n</code></pre>\n\n<p>It gives the following error:</p>\n\n<pre><code>src/main.rs:32:83: 32:100 error: mismatched types:\n expected `&lt;T as image::image::GenericImage&gt;::Pixel`,\n    found `image::color::Rgba&lt;_&gt;`\n(expected associated type,\n    found struct `image::color::Rgba`) [E0308]\nsrc/main.rs:32       if (dr*dr + dg*dg + db*db).to_uint().unwrap() &lt; 16384 { img.put_pixel(x, y, transparent_pixel); } // Remove the background colour.\n</code></pre>\n\n<p>This is presumably because the GenericImage struct defines its own internal \"Pixel\", which I don't think I can access, but is exactly the same as the normal Pixel struct. How would I get code with this functionality to compile? Every other use of <code>put_pixel</code> I've seen has used <code>get_pixel</code> on the image object and manipulated that, but I need to use a transparent pixel, so that won't work.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1425345521, "post_id": 28666042, "comment_id": 45916429, "body": "Please make sure to upvote useful answers and mark an answer as accepted if it solved your problem! If no answer is acceptable, consider leaving comments explaining why, or edit your question to phrase the problem differently."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 3, "last_activity_date": 1424658441, "creation_date": 1424658441, "answer_id": 28666096, "question_id": 28666042, "link": "https://stackoverflow.com/questions/28666042/panicked-at-assertion-failed-begin-end-when-using-map/28666096#28666096", "title": "&quot;panicked at &#39;assertion failed: begin &lt;= end&quot; when using map", "body": "<p>You are going outside the bounds of your string. Here's an example:</p>\n\n<pre><code>fn main() {\n    let s = \"a\";\n    let s2 = s.slice_chars(3, s.len());\n}\n</code></pre>\n\n<p>I don't really know why you are doing this slicing, so it's hard to recommend a better solution.</p>\n"}, {"comments": [{"owner": {"reputation": 2836, "user_id": 225291, "user_type": "registered", "accept_rate": 29, "profile_image": "https://www.gravatar.com/avatar/d9511b3f1579c63dcfa680a8c945592b?s=128&d=identicon&r=PG", "display_name": "banyan", "link": "https://stackoverflow.com/users/225291/banyan"}, "edited": false, "score": 0, "creation_date": 1424666078, "post_id": 28666101, "comment_id": 45628519, "body": "Thanks for let me know about domain mismatch as well!"}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": false, "score": 3, "last_activity_date": 1424658485, "creation_date": 1424658485, "answer_id": 28666101, "question_id": 28666042, "link": "https://stackoverflow.com/questions/28666042/panicked-at-assertion-failed-begin-end-when-using-map/28666101#28666101", "title": "&quot;panicked at &#39;assertion failed: begin &lt;= end&quot; when using map", "body": "<p>I guess this is because the output of <code>git</code> doesn't have the form you expect: it is probably because there is a line that has <code>len()</code> less than 3 in <code>s.slice_chars(3, s.len())</code>, and that is invalid for that function. So, you'll need to ensure you're understanding the format correctly, and/or e.g. bracket the call in an <code>if</code>, e.g. <code>if ... { s.slice_chars(3, s.len()) } else { \"\" }</code>.</p>\n\n<p>Also, there's a domain mismatch here: <code>slice_chars</code> operates on codepoints, but <code>s.len()</code> returns the number of bytes in the string. Bytes and codepoints aren't necessarily equivalent (in fact, they are only equivalent in UTF-8 when the string is purely ASCII), so you should either use <code>char_len</code> (to use codepoints everywhere), or use <code>s[3..]</code> (to use bytes everywhere).</p>\n"}, {"tags": [], "owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "is_accepted": false, "score": 2, "last_activity_date": 1424658513, "creation_date": 1424658513, "answer_id": 28666105, "question_id": 28666042, "link": "https://stackoverflow.com/questions/28666042/panicked-at-assertion-failed-begin-end-when-using-map/28666105#28666105", "title": "&quot;panicked at &#39;assertion failed: begin &lt;= end&quot; when using map", "body": "<p>Your code will fail if the program's output contains lines that are less than 3 characters long (for example, lines that contain only newlines).</p>\n\n<p>You haven't described what you're trying to do, but one possible solution is to filter out lines that have less than 3 characters:</p>\n\n<pre><code>#![feature(process, collections)]\nuse std::process::Command;\n\nfn main() {\n    let output = Command::new(\"git\").args(&amp;[\"status\", \"--porcelain\"]).output().unwrap_or_else(|e| {\n      panic!(\"failed to execute process: {}\", e)\n    });\n\n    let s = String::from_utf8_lossy(output.stdout.as_slice()).to_string();\n    let a: Vec&lt;&amp;str&gt; = s.split('\\n')\n        .filter(|s| s.len() &gt;= 3)\n        .map(|s| s.slice_chars(3, s.len()))\n        .collect();\n}\n</code></pre>\n"}], "owner": {"reputation": 2836, "user_id": 225291, "user_type": "registered", "accept_rate": 29, "profile_image": "https://www.gravatar.com/avatar/d9511b3f1579c63dcfa680a8c945592b?s=128&d=identicon&r=PG", "display_name": "banyan", "link": "https://stackoverflow.com/users/225291/banyan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 842, "favorite_count": 0, "answer_count": 3, "score": 2, "last_activity_date": 1424658513, "creation_date": 1424657993, "question_id": 28666042, "link": "https://stackoverflow.com/questions/28666042/panicked-at-assertion-failed-begin-end-when-using-map", "title": "&quot;panicked at &#39;assertion failed: begin &lt;= end&quot; when using map", "body": "<p>I've just started to touch Rust.</p>\n\n<pre><code>fn main() {\n    let s = \"aaabbb\\naaaccc\".to_string();\n    let a: Vec&lt;&amp;str&gt; = s.split('\\n').map(|s| s.slice_chars(3, s.len())).collect();\n    assert_eq!(a, vec![\"bbb\", \"ccc\"]);\n}\n</code></pre>\n\n<p>While above code works, this doesn't. It dies at <code>map</code>. </p>\n\n<pre><code>#![feature(process, collections)]\nuse std::process::Command;\n\nfn main() {\n    let output = Command::new(\"git\").args(&amp;[\"status\", \"--porcelain\"]).output().unwrap_or_else(|e| {\n      panic!(\"failed to execute process: {}\", e)\n    });\n    let s = String::from_utf8_lossy(output.stdout.as_slice()).to_string();\n    let a: Vec&lt;&amp;str&gt; = s.split('\\n').map(|s| s.slice_chars(3, s.len())).collect();\n}\n</code></pre>\n\n<p>These are backtraces.</p>\n\n<pre><code>$ RUST_BACKTRACE=1 cargo run\n     Running `target/hello_world`\nthread '&lt;main&gt;' panicked at 'assertion failed: begin &lt;= end', /Users/rustbuild/src/rust-buildbot/slave/nightly-dist-rustc-mac/build/src/libcore/str/mod.rs:1478\nstack backtrace:\n   1:        0x1091266b3 - sys::backtrace::write::hc8e3cee73e646c590nC\n   2:        0x10912ba0e - panicking::on_panic::h00b47941f5bc8a02HOL\n   3:        0x109110de8 - rt::unwind::begin_unwind_inner::h539538ef7f909326UvL\n   4:        0x1091115fe - rt::unwind::begin_unwind_fmt::h7ee8242816be0431quL\n   5:        0x10912b29e - rust_begin_unwind\n   6:        0x10914a487 - panicking::panic_fmt::hbdb6961ecc952cf7cSv\n   7:        0x10914a35a - panicking::panic::h2860b801a6212420fQv\n   8:        0x10914bfd1 - str::str.StrExt::slice_chars::hb48fc0a9452c1b98PGD\n   9:        0x109110791 - str::StrExt::slice_chars::h13298185343564271120\n  10:        0x10910fe14 - main::closure.2239\n  11:        0x10910fd13 - iter::Map&lt;I, F&gt;::do_map::h17245677587133977247\n  12:        0x10910e7dd - iter::Map&lt;I, F&gt;.Iterator::next::h11146527951811133470\n  13:        0x10910dc39 - vec::Vec&lt;T&gt;.FromIterator&lt;T&gt;::from_iter::h11956274897938765189\n  14:        0x10910d8bf - iter::IteratorExt::collect::h15101737251385262689\n  15:        0x109106f22 - main::h2fa2dff98d35cbb8faa\n  16:        0x10912d279 - rust_try_inner\n  17:        0x10912d266 - rust_try\n  18:        0x10912c1f2 - rt::lang_start::h660a0b4ce4c9ac40HIL\n  19:        0x109106f9f - main\n</code></pre>\n\n<p>Thanks for the help!</p>\n\n<pre><code>$ rustc --version\nrustc 1.0.0-nightly (522d09dfe 2015-02-19) (built 2015-02-20)\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1424623636, "post_id": 28660362, "comment_id": 45616308, "body": "Welcome to Stack Overflow!  To get the best quality of answers, please review <a href=\"http://stackoverflow.com/help/how-to-ask\">How do I ask a good question?</a>. In this particular case, you should include your code inline, not just a link to it (links may die, and then future programmers can&#39;t benefit!). Don&#39;t just post all of your code though! Instead, construct a <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a> to narrow down the problem and make it easier on answerers. You should only have one question, and be cautious about opinion questions (&quot;best practice&quot;), as they are out-of-scope for this site."}], "answers": [{"comments": [{"owner": {"reputation": 1114, "user_id": 10111567, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=128", "display_name": "Miguel", "link": "https://stackoverflow.com/users/10111567/miguel"}, "edited": false, "score": 0, "creation_date": 1576168951, "post_id": 28660828, "comment_id": 104820622, "body": "I&#39;m having the same problem, with slightly different code. In your example reproduction I do not understand when the list is being dropped. Are you not just adding a sequence of chained nodes? why would it overflow the stack?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1114, "user_id": 10111567, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=128", "display_name": "Miguel", "link": "https://stackoverflow.com/users/10111567/miguel"}, "edited": false, "score": 1, "creation_date": 1576175434, "post_id": 28660828, "comment_id": 104823654, "body": "@Miguel the <code>list</code> variable is dropped at the end of its scope (the end of <code>main</code>). The stack overflows because the default <code>Drop</code> implementation of <code>A</code> calls the <code>Drop</code> implementation of <code>Option&lt;Box&lt;A&gt;&gt;</code> which calls the <code>Drop</code> implementation of <code>Box&lt;A&gt;</code> which calls the <code>Drop</code> implementation of <code>A</code> (and so on). Each function call adds to the stack depth."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 8, "last_activity_date": 1578411360, "last_edit_date": 1578411360, "creation_date": 1424625777, "answer_id": 28660828, "question_id": 28660362, "link": "https://stackoverflow.com/questions/28660362/thread-main-has-overflowed-its-stack-when-constructing-a-large-tree/28660828#28660828", "title": "&quot;thread &#39;&lt;main&gt;&#39; has overflowed its stack&quot; when constructing a large tree", "body": "<p>The problem that you are experiencing is because you have a giant linked-list of nodes. When that list is dropped, the first element tries to free all the members of the struct first. That means that the second element does the same, and so on, until the end of the list. This means that you will have a call stack that is proportional to the number of elements in your list!</p>\n\n<p>Here's a small reproduction:</p>\n\n<pre><code>struct A {\n    children: Option&lt;Box&lt;A&gt;&gt;\n}\n\nfn main() {\n    let mut list = A { children: None };\n\n    for _ in 0..1_000_000 {\n        list = A { children: Some(Box::new(list)) };\n    }\n}\n</code></pre>\n\n<p>And here's how you would fix it:</p>\n\n<pre><code>impl Drop for A {\n    fn drop(&amp;mut self) {\n        if let Some(mut child) = self.children.take() {\n            while let Some(next) = child.children.take() {\n                child = next;\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>This code overrides the default recursive drop implementation with an iterative one. It rips the <code>children</code> out of the node, replacing it with a terminal item (<code>None</code>). It then allows the node to drop normally, but there will be no recursive calls.</p>\n\n<p>The code is complicated a bit because we can't drop ourselves, so we need to do a little two-step dance to ignore the first item and then eat up all the children.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/27098694/155423\">How can I swap in a new value for a field in a mutable reference to a structure?</a></li>\n<li><a href=\"https://stackoverflow.com/q/52031002/155423\">How do I move out of a struct field that is an Option?</a></li>\n</ul>\n"}], "owner": {"reputation": 385, "user_id": 518479, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/57e72fee919179ad2fd6ef55a3adca8d?s=128&d=identicon&r=PG", "display_name": "qdwang", "link": "https://stackoverflow.com/users/518479/qdwang"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1404, "favorite_count": 1, "accepted_answer_id": 28660828, "answer_count": 1, "score": 5, "last_activity_date": 1578411360, "creation_date": 1424623227, "last_edit_date": 1424625991, "question_id": 28660362, "link": "https://stackoverflow.com/questions/28660362/thread-main-has-overflowed-its-stack-when-constructing-a-large-tree", "title": "&quot;thread &#39;&lt;main&gt;&#39; has overflowed its stack&quot; when constructing a large tree", "body": "<p>I implemented a tree struct:</p>\n\n<pre><code>use std::collections::VecDeque;\nuse std::rc::{Rc, Weak};\nuse std::cell::RefCell;\n\nstruct A {\n    children: Option&lt;VecDeque&lt;Rc&lt;RefCell&lt;A&gt;&gt;&gt;&gt;\n}\n\n// I got thread '&lt;main&gt;' has overflowed its stack\nfn main(){\n    let mut tree_stack: VecDeque&lt;Rc&lt;RefCell&lt;A&gt;&gt;&gt; = VecDeque::new();\n\n    // when num is 1000, everything works\n    for i in 0..100000 {\n        tree_stack.push_back(Rc::new(RefCell::new(A {children: None})));\n    }\n\n    println!(\"{:?}\", \"reach here means we are not out of mem\");\n    loop {\n        if tree_stack.len() == 1 {break;}\n\n        let mut new_tree_node = Rc::new(RefCell::new(A {children: None}));\n        let mut tree_node_children: VecDeque&lt;Rc&lt;RefCell&lt;A&gt;&gt;&gt; = VecDeque::new();\n\n        // combine last two nodes to one new node\n        match tree_stack.pop_back() {\n            Some(x) =&gt; {\n                tree_node_children.push_front(x);\n            },\n            None =&gt; {}\n        } \n        match tree_stack.pop_back() {\n            Some(x) =&gt; {\n                tree_node_children.push_front(x);\n            },\n            None =&gt; {}\n        } \n\n        new_tree_node.borrow_mut().children = Some(tree_node_children);\n        tree_stack.push_back(new_tree_node);\n    }\n}\n</code></pre>\n\n<p><a href=\"http://is.gd/0RF6SR\" rel=\"noreferrer\">Playpen link</a></p>\n\n<p>But it crashes with</p>\n\n<pre><code>thread '&lt;main&gt;' has overflowed its stack\n</code></pre>\n\n<p>How do I fix that?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1424608295, "post_id": 28656387, "comment_id": 45611527, "body": "specifically for <code>[Option&lt;Box&lt;T&gt;&gt;; N]</code> you can use transmute from a <code>[0; N]</code>: <a href=\"http://is.gd/CC31YQ\" rel=\"nofollow noreferrer\">is.gd/CC31YQ</a>"}, {"owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "edited": false, "score": 0, "creation_date": 1461954771, "post_id": 28656387, "comment_id": 61449101, "body": "I wrote an answer to a similar question <a href=\"http://stackoverflow.com/questions/36925673/how-can-i-initialize-an-array-using-a-function\" title=\"how can i initialize an array using a function\">stackoverflow.com/questions/36925673/&hellip;</a>"}], "answers": [{"comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1616660025, "post_id": 28666474, "comment_id": 118073515, "body": "Note that this solution doesn&#39;t allow initializing static (global) arrays. The question didn&#39;t specify if that&#39;s actually needed, but it might be relevant to future readers."}], "tags": [], "owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "is_accepted": false, "score": 5, "last_activity_date": 1511112270, "last_edit_date": 1511112270, "creation_date": 1424661862, "answer_id": 28666474, "question_id": 28656387, "link": "https://stackoverflow.com/questions/28656387/initialize-a-large-fixed-size-array-with-non-copy-types/28666474#28666474", "title": "Initialize a large, fixed-size array with non-Copy types", "body": "<p>I'm copying <a href=\"https://www.reddit.com/r/rust/comments/29ymbx/a_macro_to_fill_a_fixed_length_array/cipruax\" rel=\"nofollow noreferrer\">the answer by chris-morgan</a> and adapting it to match the question better, to follow the recommendation by dbaupp downthread, and to match recent syntax changes:</p>\n\n<pre><code>use std::mem;\nuse std::ptr;\n\n#[derive(Debug)]\nstruct Thing {\n    number: usize,\n}\n\nmacro_rules! make_array {\n    ($n:expr, $constructor:expr) =&gt; {{\n        let mut items: [_; $n] = mem::uninitialized();\n        for (i, place) in items.iter_mut().enumerate() {\n            ptr::write(place, $constructor(i));\n        }\n        items\n    }}\n}\n\nconst SIZE: usize = 50;\n\nfn main() {\n    let items = unsafe { make_array!(SIZE, |i| Box::new(Some(Thing { number: i }))) };\n    println!(\"{:?}\", &amp;items[..]);\n}\n</code></pre>\n\n<p>Note the need to use <code>unsafe</code> here: The problem is that if the constructor function <code>panic!</code>s, this would lead to undefined behavior.</p>\n"}, {"tags": [], "owner": {"reputation": 1056, "user_id": 3497181, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0e384ad3cea4b2ccaf03271303a94f1f?s=128&d=identicon&r=PG&f=1", "display_name": "rnstlr", "link": "https://stackoverflow.com/users/3497181/rnstlr"}, "is_accepted": false, "score": 16, "last_activity_date": 1585533567, "last_edit_date": 1585533567, "creation_date": 1481029244, "answer_id": 40996035, "question_id": 28656387, "link": "https://stackoverflow.com/questions/28656387/initialize-a-large-fixed-size-array-with-non-copy-types/40996035#40996035", "title": "Initialize a large, fixed-size array with non-Copy types", "body": "<p>You could use the <a href=\"https://doc.rust-lang.org/std/default/trait.Default.html\" rel=\"nofollow noreferrer\"><code>Default</code></a> trait to initialize the array with default values:</p>\n\n<pre><code>let array: [Option&lt;Box&lt;Thing&gt;&gt;; SIZE] = Default::default();\n</code></pre>\n\n<p>See <a href=\"https://play.rust-lang.org/?gist=49b45bded3aac40cded25ea17b6b9d4f&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">this playground</a> for a working example.</p>\n\n<p>Note that this will only work for arrays with up to 32 elements, because <code>Default::default</code> is only implemented for up to <code>[T; 32]</code>. See <a href=\"https://doc.rust-lang.org/std/default/trait.Default.html#impl-Default-98\" rel=\"nofollow noreferrer\">https://doc.rust-lang.org/std/default/trait.Default.html#impl-Default-98</a></p>\n"}, {"comments": [{"owner": {"reputation": 1715, "user_id": 721809, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/TzkxT.png?s=128&g=1", "display_name": "Matej Kormuth", "link": "https://stackoverflow.com/users/721809/matej-kormuth"}, "edited": false, "score": 3, "creation_date": 1607699699, "post_id": 54410952, "comment_id": 115362314, "body": "If n = 256 should I really just copy &amp; paste None 256 times?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1715, "user_id": 721809, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/TzkxT.png?s=128&g=1", "display_name": "Matej Kormuth", "link": "https://stackoverflow.com/users/721809/matej-kormuth"}, "edited": false, "score": 1, "creation_date": 1607712871, "post_id": 54410952, "comment_id": 115368360, "body": "@MatejKormuth depends on a lot of factors, but I don&#39;t see anything inherently <i>wrong</i> with it. It&#39;s annoying, yes, but simple."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1548713012, "creation_date": 1548713012, "answer_id": 54410952, "question_id": 28656387, "link": "https://stackoverflow.com/questions/28656387/initialize-a-large-fixed-size-array-with-non-copy-types/54410952#54410952", "title": "Initialize a large, fixed-size array with non-Copy types", "body": "<p>This is the \"keep it simple\" answer: just type out all the values:</p>\n\n<pre><code>struct Thing;\nconst SIZE: usize = 5;\n\nfn main() {\n    let array: [Option&lt;Box&lt;Thing&gt;&gt;; SIZE] = [None, None, None, None, None];\n}\n</code></pre>\n\n<p>You could also use <a href=\"https://doc.rust-lang.org/cargo/reference/build-scripts.html\" rel=\"nofollow noreferrer\">a build script</a> to generate this code for you. For an example of this, see:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/32956050/155423\">How to create a static string at compile time</a></li>\n</ul>\n"}, {"tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": false, "score": 2, "last_activity_date": 1616701219, "last_edit_date": 1616701219, "creation_date": 1616571128, "answer_id": 66776497, "question_id": 28656387, "link": "https://stackoverflow.com/questions/28656387/initialize-a-large-fixed-size-array-with-non-copy-types/66776497#66776497", "title": "Initialize a large, fixed-size array with non-Copy types", "body": "<p>As of this writing (checked with Rust 1.50.0) a cleaner alternative to existing answers is possible using an intermediate <code>const</code> initializer. This approach works for arrays of any size:</p>\n<pre><code>const SIZE: usize = 100;\nconst INIT: Option&lt;Box&lt;Thing&gt;&gt; = None;\nlet array: [Option&lt;Box&lt;Thing&gt;&gt;; SIZE] = [INIT; SIZE];\n</code></pre>\n<p>(It works with or without the <code>Box</code>; the example uses <code>Box</code> because it was used in the question.)</p>\n"}], "owner": {"reputation": 389, "user_id": 627303, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c1d80cf5fc097b20250baa26d06c5331?s=128&d=identicon&r=PG", "display_name": "rieux", "link": "https://stackoverflow.com/users/627303/rieux"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4567, "favorite_count": 1, "answer_count": 4, "score": 24, "last_activity_date": 1616701219, "creation_date": 1424597593, "last_edit_date": 1481033137, "question_id": 28656387, "link": "https://stackoverflow.com/questions/28656387/initialize-a-large-fixed-size-array-with-non-copy-types", "title": "Initialize a large, fixed-size array with non-Copy types", "body": "<p>I\u2019m trying to initialize a fixed-size array of some nullable, non-copyable type, like an <code>Option&lt;Box&lt;Thing&gt;&gt;</code> for some kind of <code>Thing</code>. I\u2019d like to pack two of them into a struct without any extra indirection. I\u2019d like to write something like this:</p>\n\n<pre><code>let array: [Option&lt;Box&lt;Thing&gt;&gt;; SIZE] = [None; SIZE];\n</code></pre>\n\n<p>But it doesn\u2019t work because the <code>[e; n]</code> syntax requires that <code>e</code> implements <code>Copy</code>. Of course, I could expand it into <code>SIZE</code> <code>None</code>s, but that can be unwieldy when <code>SIZE</code> is large. I don\u2019t believe this can be done with a macro without an unnatural encoding of <code>SIZE</code>. Is there a good way to do it?</p>\n\n<p>Yes, this is easy with <code>unsafe</code>; is there a way to do it without <code>unsafe</code>?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 327, "user_id": 6662425, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c3e6664d0619a92cc63d9e42c2fafb7c?s=128&d=identicon&r=PG&f=1", "display_name": "Felix B.", "link": "https://stackoverflow.com/users/6662425/felix-b"}, "edited": false, "score": 2, "creation_date": 1588870405, "post_id": 28656825, "comment_id": 109073578, "body": "I wonder why there is no parameter for that in <code>.round()</code> - I guess because rust does not have defaults/overloaded functions?"}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 78, "last_activity_date": 1501591426, "last_edit_date": 1501591426, "creation_date": 1424601072, "answer_id": 28656825, "question_id": 28655362, "link": "https://stackoverflow.com/questions/28655362/how-does-one-round-a-floating-point-number-to-a-specified-number-of-digits/28656825#28656825", "title": "How does one round a floating point number to a specified number of digits?", "body": "<p>If you want this just for display purposes, use the <a href=\"https://doc.rust-lang.org/stable/std/fmt/\" rel=\"noreferrer\">formatting syntax built into <code>println!()</code></a>. For example, to print a number rounded to 2 decimal places use the <code>{:.2}</code> format specifier:</p>\n\n<pre><code>fn main() {\n    let x = 12.34567;\n    println!(\"{:.2}\", x);\n}\n</code></pre>\n\n<p>If you want to put the rounded number in a string, use the <a href=\"https://doc.rust-lang.org/std/macro.format.html\" rel=\"noreferrer\"><code>format!()</code> macro</a>.</p>\n\n<p>If you want to round a number and get the result back as another number, then multiply the number by the given power of 10, call <a href=\"https://doc.rust-lang.org/std/primitive.f64.html#method.round\" rel=\"noreferrer\"><code>round</code></a>, and divide by the same power, e.g. to round to 2 decimal places, use 10<sup>2</sup> = 100.</p>\n\n<pre><code>fn main() {\n    let x = 12.34567_f64;\n    let y = (x * 100.0).round() / 100.0;\n\n    println!(\"{:.5} {:.5}\", x, y);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=b94d0644ccc62a008ad87110b66da5d9&amp;version=stable\" rel=\"noreferrer\">playground</a></p>\n\n<p>This prints <code>12.34567 12.35000</code>. </p>\n\n<p>If the number of decimal places isn't known at compile time, one could use <a href=\"https://doc.rust-lang.org/stable/std/primitive.f64.html#method.powi\" rel=\"noreferrer\"><code>powi</code></a> to efficiently compute the relevant power. </p>\n\n<p>Note that this will breakdown for very large numbers; specifically, numbers larger than <code>std::f64::MAX / power</code> (where <code>power</code> is the power of ten, e.g. 100 in the example above) will become infinity in the multiplication, and remain infinity after. However, <code>f64</code> cannot represent any fractional places for numbers larger than 2<sup>53</sup> (i.e. they're always integers), so one can special case such large numbers to just return themselves.</p>\n"}, {"tags": [], "owner": {"reputation": 4499, "user_id": 3120525, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9Aaks.jpg?s=128&g=1", "display_name": "iulian", "link": "https://stackoverflow.com/users/3120525/iulian"}, "is_accepted": false, "score": 19, "last_activity_date": 1586351507, "creation_date": 1586351507, "answer_id": 61101531, "question_id": 28655362, "link": "https://stackoverflow.com/questions/28655362/how-does-one-round-a-floating-point-number-to-a-specified-number-of-digits/61101531#61101531", "title": "How does one round a floating point number to a specified number of digits?", "body": "<p>To add to @huon's great answer, if you want to round a floating point number for display purposes, <em>but you don't know the precision at compile time,</em> you can use the precision formatting syntax as follows:</p>\n\n<pre><code>fn main() {\n    let precision = 3;\n    let x = 12.34567;\n    println!(\"{:.1$}\", x, precision); // prints 12.346 and works with `format!` as well\n}\n</code></pre>\n\n<p>The documentation of <a href=\"https://doc.rust-lang.org/stable/std/fmt/index.html#precision\" rel=\"noreferrer\">std::fmt</a> has more examples on the syntax.</p>\n"}], "owner": {"reputation": 1743, "user_id": 1056805, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/4db27c7d2549e64d21216f812ce84a4f?s=128&d=identicon&r=PG", "display_name": "user1056805", "link": "https://stackoverflow.com/users/1056805/user1056805"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 23263, "favorite_count": 5, "accepted_answer_id": 28656825, "answer_count": 2, "score": 49, "last_activity_date": 1586351507, "creation_date": 1424588155, "last_edit_date": 1424611501, "question_id": 28655362, "link": "https://stackoverflow.com/questions/28655362/how-does-one-round-a-floating-point-number-to-a-specified-number-of-digits", "title": "How does one round a floating point number to a specified number of digits?", "body": "<p>How does one round a f64 floating point number in Rust to a specified number of digits?</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 2628, "user_id": 1366913, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/bcd760432e7ba71d5f0c71350886456f?s=128&d=identicon&r=PG", "display_name": "nathansizemore", "link": "https://stackoverflow.com/users/1366913/nathansizemore"}, "edited": false, "score": 4, "creation_date": 1424638151, "post_id": 28661524, "comment_id": 45621162, "body": "Whoa, I had no idea I could slap <code>unimplemented()!</code> in there and make examples cleaner.  Thank you so much for the help!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 28, "last_activity_date": 1523846624, "last_edit_date": 1523846624, "creation_date": 1424629482, "answer_id": 28661524, "question_id": 28654978, "link": "https://stackoverflow.com/questions/28654978/lifetime-troubles-sharing-references-between-threads/28661524#28661524", "title": "Lifetime troubles sharing references between threads", "body": "<p>A great thing about Rust is that the type-checking across functions is done solely by the function signature. That means you can replace most of the bodies of functions with <code>unimplemented!()</code> and preserve type-checking errors.</p>\n\n<p>Repeat that process a few times, and you end up not calling a lot of functions - remove those. Inlining modules and reducing structs / enums can also help.</p>\n\n<p>At some point your error will disappear - the first clue towards the problem! Keep at it, and you get a tiny reproduction:</p>\n\n<pre><code>use std::sync::{Arc, Mutex};\nuse std::thread;\n\npub enum MasterSocketList&lt;'a&gt; {\n    One(&amp;'a u8),\n}\n\npub struct Slot;\n\nimpl Slot {\n    pub fn new&lt;'a&gt;(master_socket_list: Arc&lt;Mutex&lt;MasterSocketList&lt;'a&gt;&gt;&gt;) -&gt; Slot {\n        thread::spawn(move || {\n            master_socket_list;\n        });\n        unimplemented!();\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>Checking out the error, it still matches:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0477]: the type `[closure@src/main.rs:12:23: 14:10 master_socket_list:std::sync::Arc&lt;std::sync::Mutex&lt;MasterSocketList&lt;'a&gt;&gt;&gt;]` does not fulfill the required lifetime\n  --&gt; src/main.rs:12:9\n   |\n12 |         thread::spawn(move || {\n   |         ^^^^^^^^^^^^^\n   |\n   = note: type must satisfy the static lifetime\n</code></pre>\n\n<p>Let's check the docs for the signature of <a href=\"https://doc.rust-lang.org/std/thread/fn.spawn.html\" rel=\"nofollow noreferrer\"><code>thread::spawn</code></a>:</p>\n\n<pre><code>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;\nwhere\n    F: FnOnce() -&gt; T,\n    F: Send + 'static,\n    T: Send + 'static, \n</code></pre>\n\n<p>The key point here is <code>F: Send + 'static</code> - the closure you give to <code>spawn</code> <strong>must only contain references that last the entire life of the program</strong>. This is because <code>spawn</code> can create threads that become <em>detached</em>. Once detached, the thread could live forever, so all references must live at least that long, otherwise you'd get <em>dangling references</em>, a bad thing! Rust saves the day, once again!</p>\n\n<p>If you want to guarantee that the threads will terminate at a known point, you can use <em>scoped threads</em>, such as those provided by <a href=\"https://crates.io/crates/scoped_threadpool\" rel=\"nofollow noreferrer\">scoped-threadpool</a> or <a href=\"https://crates.io/crates/crossbeam\" rel=\"nofollow noreferrer\">crossbeam</a>.</p>\n\n<p>If your code didn't have a variable with a lifetime inside of it, using some type of shared ownership like <a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html\" rel=\"nofollow noreferrer\"><code>Arc</code></a> paired with something that will ensure only one thread can mutate the variable, like <a href=\"https://doc.rust-lang.org/std/sync/struct.Mutex.html\" rel=\"nofollow noreferrer\"><code>Mutex</code></a> would have been sufficient. This allows each thread to own the shared value, finally dropping it whenever the last thread exits. See <a href=\"https://stackoverflow.com/q/31373255/155423\">How do I share a mutable object between threads?</a> for details.</p>\n"}], "owner": {"reputation": 2628, "user_id": 1366913, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/bcd760432e7ba71d5f0c71350886456f?s=128&d=identicon&r=PG", "display_name": "nathansizemore", "link": "https://stackoverflow.com/users/1366913/nathansizemore"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4001, "favorite_count": 2, "accepted_answer_id": 28661524, "answer_count": 1, "score": 10, "last_activity_date": 1523846624, "creation_date": 1424584063, "last_edit_date": 1489195111, "question_id": 28654978, "link": "https://stackoverflow.com/questions/28654978/lifetime-troubles-sharing-references-between-threads", "title": "Lifetime troubles sharing references between threads", "body": "<p>I've got a thread that launches worker threads, all are expected to live forever. Each worker thread maintains it's own list of <code>Socket</code>s.</p>\n\n<p>Some operations require that I traverse all sockets currently alive, but I'm having trouble with lifetimes trying to create a master list of sockets containing a pointer to a socket owned by another list.</p>\n\n<pre><code>use std::{str, thread};\nuse std::thread::JoinHandle;\nuse std::io::{Read, Write};\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::{Arc, Mutex};\nuse std::ops::DerefMut;\nuse std::sync::mpsc::{channel, Sender, Receiver, TryRecvError};\nuse self::socketlist::SocketList;\nuse self::mastersocketlist::MasterSocketList;\n\npub struct Socket {\n    user: String,\n    stream: TcpStream,\n}\n\nmod socketlist {\n    use self::SocketList::{Node, End};\n    use super::Socket;\n\n    pub enum SocketList {\n        Node(Socket, Box&lt;SocketList&gt;),\n        End,\n    }\n\n    impl SocketList {\n        pub fn new() -&gt; SocketList {\n            End\n        }\n\n        pub fn add(self, socket: Socket) -&gt; SocketList {\n            Node(socket, Box::new(self))\n        }\n\n        pub fn newest&lt;'a&gt;(&amp;'a mut self) -&gt; Result&lt;&amp;'a Socket, String&gt; {\n            match *self {\n                Node(ref mut socket, ref mut next) =&gt; Ok(socket),\n                End =&gt; Err(\"No socket available\".to_string()),\n            }\n        }\n    }\n}\n\nmod mastersocketlist {\n    use self::MasterSocketList::{Node, End};\n    use super::Socket;\n\n    pub enum MasterSocketList&lt;'a&gt; {\n        Node(Box&lt;&amp;'a Socket&gt;, Box&lt;MasterSocketList&lt;'a&gt;&gt;),\n        End,\n    }\n\n    impl&lt;'a&gt; MasterSocketList&lt;'a&gt; {\n        pub fn new() -&gt; MasterSocketList&lt;'a&gt; {\n            End\n        }\n\n        pub fn add(self, socket: &amp;'a Socket) -&gt; MasterSocketList&lt;'a&gt; {\n            MasterSocketList::Node(Box::new(&amp;socket), Box::new(self))\n        }\n    }\n}\n\npub struct SlotManager {\n    prox: JoinHandle&lt;()&gt;,\n    prox_tx: Sender&lt;TcpStream&gt;,\n}\n\nimpl SlotManager {\n    pub fn new() -&gt; SlotManager {\n        let (tx, rx): (Sender&lt;TcpStream&gt;, Receiver&lt;TcpStream&gt;) = channel();\n\n        let tx_clone = tx.clone();\n        let prox = thread::spawn(move || SlotManager::event_loop(tx, rx));\n\n        SlotManager {\n            prox: prox,\n            prox_tx: tx_clone,\n        }\n    }\n\n    pub fn sender(&amp;self) -&gt; Sender&lt;TcpStream&gt; {\n        self.prox_tx.clone()\n    }\n\n    fn event_loop(tx: Sender&lt;TcpStream&gt;, rx: Receiver&lt;TcpStream&gt;) {\n        let socket_list = Arc::new(Mutex::new(MasterSocketList::new()));\n        let mut slot = Slot::new(socket_list.clone());\n        loop {\n            match rx.try_recv() {\n                Ok(stream) =&gt; slot.new_connection(stream),\n                Err(e) =&gt; {}\n            }\n        }\n    }\n}\n\npub struct Slot {\n    prox: JoinHandle&lt;()&gt;,\n    prox_tx: Sender&lt;TcpStream&gt;,\n}\n\nimpl Slot {\n    pub fn new(master_socket_list: Arc&lt;Mutex&lt;MasterSocketList&gt;&gt;) -&gt; Slot {\n        let (tx, rx): (Sender&lt;TcpStream&gt;, Receiver&lt;TcpStream&gt;) = channel();\n\n        let tx_clone = tx.clone();\n        let prox = thread::spawn(move || Slot::event_loop(tx, rx, master_socket_list));\n\n        Slot {\n            prox: prox,\n            prox_tx: tx_clone,\n        }\n    }\n\n    pub fn new_connection(&amp;self, stream: TcpStream) {\n        self.prox_tx.send(stream);\n    }\n\n    fn event_loop(tx: Sender&lt;TcpStream&gt;,\n                  rx: Receiver&lt;TcpStream&gt;,\n                  master_socket_list: Arc&lt;Mutex&lt;MasterSocketList&gt;&gt;) {\n\n        let mut sockets = SocketList::new();\n        loop {\n            // Check for new connections\n            match rx.try_recv() {\n                Ok(stream) =&gt; {\n                    let mut socket = Socket {\n                        user: \"default\".to_string(),\n                        stream: stream,\n                    };\n                    sockets = sockets.add(socket);\n\n                    let mut msl_guard = match master_socket_list.lock() {\n                        Ok(guard) =&gt; guard,\n                        Err(poisoned) =&gt; poisoned.into_inner(),\n                    };\n                    let mut msl_handle = msl_guard.deref_mut();\n                    *msl_handle = msl_handle.add(sockets.newest().unwrap());\n                }\n                Err(e) =&gt; {}\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut slot_manager = SlotManager::new();\n    let listener = TcpListener::bind(\"127.0.0.1:1234\").unwrap();\n    for stream in listener.incoming() {\n        match stream {\n            Ok(stream) =&gt; {\n                let sender = slot_manager.sender();\n                thread::spawn(move || {\n                    sender.send(stream);\n                    //process_new_connection(stream, sender)\n                });\n            }\n            Err(e) =&gt; println!(\"Connection error: {}\", e),\n        }\n    }\n    drop(listener);\n}\n</code></pre>\n\n<p>The errors that I receive...</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0477]: the type `[closure@src/main.rs:107:34: 107:86 tx:std::sync::mpsc::Sender&lt;std::net::TcpStream&gt;, rx:std::sync::mpsc::Receiver&lt;std::net::TcpStream&gt;, master_socket_list:std::sync::Arc&lt;std::sync::Mutex&lt;mastersocketlist::MasterSocketList&lt;'_&gt;&gt;&gt;]` does not fulfill the required lifetime\n   --&gt; src/main.rs:107:20\n    |\n107 |         let prox = thread::spawn(move || Slot::event_loop(tx, rx, master_socket_list));\n    |                    ^^^^^^^^^^^^^\n    |\n    = note: type must outlive the static lifetime\n</code></pre>\n\n<p>I don't even know if what I am trying to is possible as safe code.</p>\n\n<p>I wanting the <code>mastersocketlist</code> to contain a pointer to a socket where the socket's lifetime is defined by the thread that created it. I believe that's what all those errors mean, but I have no idea how to provide the proper lifetime annotations to fix it.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 521, "user_id": 963252, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/cf53173bc0968c9cfba3f1911d77fa56?s=128&d=identicon&r=PG", "display_name": "Ant Manelope", "link": "https://stackoverflow.com/users/963252/ant-manelope"}, "edited": false, "score": 0, "creation_date": 1424576292, "post_id": 28654053, "comment_id": 45605394, "body": "I considered that.  However, other functions in the impl of VertexBuffer use the type parameter as well, and I would hope the type system would catch mismatches when a VertexBuffer was created with one Vertex type, and used with another. I&#39;m trying your 2nd suggestion..."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 521, "user_id": 963252, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/cf53173bc0968c9cfba3f1911d77fa56?s=128&d=identicon&r=PG", "display_name": "Ant Manelope", "link": "https://stackoverflow.com/users/963252/ant-manelope"}, "edited": false, "score": 0, "creation_date": 1424576452, "post_id": 28654053, "comment_id": 45605424, "body": "@AntManelope Sounds like you need the <code>PhantomData</code> then. Is your struct responsible for freeing the buffer when it&#39;s done? Can you ever return one of the <code>Vertex</code>es?"}, {"owner": {"reputation": 521, "user_id": 963252, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/cf53173bc0968c9cfba3f1911d77fa56?s=128&d=identicon&r=PG", "display_name": "Ant Manelope", "link": "https://stackoverflow.com/users/963252/ant-manelope"}, "edited": false, "score": 1, "creation_date": 1424577195, "post_id": 28654053, "comment_id": 45605560, "body": "Yes it implements the Drop trait to free the buffer.  A Vertex is never returned, but functions on the specific V type are called (modified original question to show)."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1424577251, "last_edit_date": 1424577251, "creation_date": 1424574584, "answer_id": 28654053, "question_id": 28653996, "link": "https://stackoverflow.com/questions/28653996/how-can-i-type-parameterize-a-struct-that-doesnt-use-that-type-directly/28654053#28654053", "title": "How can I type parameterize a struct that doesn&#39;t use that type directly?", "body": "<p>You haven't shown enough code to rule this out, so I'd suggest moving your type to the function(s):</p>\n\n<pre><code>impl VertexBuffer {\n    pub fn new&lt;V: Vertex&gt;(data: &amp;Vec&lt;V&gt;) -&gt; VertexBuffer&lt;V&gt; {\n        let buffer_id = unsafe {\n            let mut id: GLuint = 0;\n            gl::GenBuffers(1, &amp;mut id);\n            gl::BindBuffer(gl::ARRAY_BUFFER, id);\n            gl::BufferData(gl::ARRAY_BUFFER,\n                (mem::size_of::&lt;V&gt;() * data.len()) as GLsizeiptr,\n                 mem::transmute(&amp;data[0]),\n                 gl::STATIC_DRAW);\n            id\n        };\n\n        VertexBuffer {\n            buffer_id: buffer_id,\n            num_vertices: data.len(),\n        }\n    }\n    ....\n}\n</code></pre>\n\n<p>If you do need to use <a href=\"http://doc.rust-lang.org/std/marker/struct.PhantomData.html\" rel=\"nofollow\">PhantomData</a>, try something like:</p>\n\n<pre><code>struct VertexBuffer&lt;V&gt; {\n    buffer_id: u32, // or whatever\n    num_vertices: u32, // or whatever\n    marker: std::marker::PhantomData&lt;V&gt;,\n}\n\nimpl&lt;V: Vertex&gt; VertexBuffer&lt;V&gt; {\n    pub fn new(data: &amp;Vec&lt;V&gt;) -&gt; VertexBuffer&lt;V&gt; {\n        let buffer_id = unsafe {\n            let mut id: GLuint = 0;\n            gl::GenBuffers(1, &amp;mut id);\n            gl::BindBuffer(gl::ARRAY_BUFFER, id);\n            gl::BufferData(gl::ARRAY_BUFFER,\n                (mem::size_of::&lt;V&gt;() * data.len()) as GLsizeiptr,\n                 mem::transmute(&amp;data[0]),\n                 gl::STATIC_DRAW);\n            id\n        };\n\n        VertexBuffer {\n            buffer_id: buffer_id,\n            num_vertices: data.len(),\n            marker: std::marker::PhantomData,\n        }\n    }\n    ....\n}\n</code></pre>\n"}], "owner": {"reputation": 521, "user_id": 963252, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/cf53173bc0968c9cfba3f1911d77fa56?s=128&d=identicon&r=PG", "display_name": "Ant Manelope", "link": "https://stackoverflow.com/users/963252/ant-manelope"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 277, "favorite_count": 0, "accepted_answer_id": 28654053, "answer_count": 1, "score": 1, "last_activity_date": 1424577251, "creation_date": 1424573897, "last_edit_date": 1424577071, "question_id": 28653996, "link": "https://stackoverflow.com/questions/28653996/how-can-i-type-parameterize-a-struct-that-doesnt-use-that-type-directly", "title": "How can I type parameterize a struct that doesn&#39;t use that type directly?", "body": "<p>In the past this code compiled, but recently it no longer is accepted (I believe since <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\" rel=\"nofollow\">RFC 738</a>). I want to type-parameterize the <code>VertexBuffer</code>, but it doesn't actually hold any vertices, rather the GPU holds the vertices, and the struct only holds an OpenGL <code>buffer_id</code>:</p>\n\n<pre><code>pub struct VertexBuffer&lt;V: Vertex&gt; {\n    buffer_id: GLuint,\n    num_vertices: usize,\n}\n</code></pre>\n\n<p>The <code>new</code> function fills the buffer:</p>\n\n<pre><code>impl&lt;V: Vertex&gt; VertexBuffer&lt;V&gt; {\n    pub fn new(data: &amp;Vec&lt;V&gt;) -&gt; VertexBuffer&lt;V&gt;\n    {\n        let buffer_id = unsafe {\n            let mut id: GLuint = 0;\n            gl::GenBuffers(1, &amp;mut id);\n            gl::BindBuffer(gl::ARRAY_BUFFER, id);\n            gl::BufferData(gl::ARRAY_BUFFER,\n                (mem::size_of::&lt;V&gt;() * data.len()) as GLsizeiptr,\n                 mem::transmute(&amp;data[0]),\n                 gl::STATIC_DRAW);\n            id\n        };\n\n        VertexBuffer {\n            buffer_id: buffer_id,\n            num_vertices: data.len(),\n        }\n    }\n    ....\n}\n</code></pre>\n\n<p>I now get these errors:</p>\n\n<pre><code>src/vertex_buffer.rs:10:25: 10:26 error: parameter `V` is never used\nsrc/vertex_buffer.rs:10 pub struct VertexBuffer&lt;V: Vertex&gt; {\n\nsrc/vertex_buffer.rs:10:25: 10:26 help: consider removing `V` or using a marker such as `core::marker::PhantomData`\nsrc/vertex_buffer.rs:10 pub struct VertexBuffer&lt;V: Vertex&gt; {\n</code></pre>\n\n<p>FYI, other functions in the impl such as pre_render() and post_render() use the V type to do their work, calling things like</p>\n\n<pre><code>let attribute_data = Vertex::attribute_data(None::&lt;V&gt;);\n</code></pre>\n"}, {"tags": ["windows", "dll", "rust", "ffi"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424557198, "post_id": 28652031, "comment_id": 45601312, "body": "Does compiling with optimizations (<code>rustc -O</code>, <code>cargo build --release</code>) have any effect? Note that cargo puts release / non-release binaries in different directories."}, {"owner": {"reputation": 133, "user_id": 4371382, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-EeUqRBaOle0/AAAAAAAAAAI/AAAAAAAAABE/ew3kplPVCuM/photo.jpg?sz=128", "display_name": "dbeinder", "link": "https://stackoverflow.com/users/4371382/dbeinder"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1424558358, "post_id": 28652031, "comment_id": 45601638, "body": "Compiling with optimizations only shrinks the library by a few kiB, but has no other effect, the same happens with the cargo release build. But compiling with <code>-C prefer-dynamic</code> has an effect, please see my updated post."}, {"owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "edited": false, "score": 0, "creation_date": 1424564639, "post_id": 28652031, "comment_id": 45603147, "body": "Do <code>-C lto</code> or <code>-C link-args=--gc-sections</code> do anything? I&#39;ve got no idea myself, just chucking it out there."}, {"owner": {"reputation": 133, "user_id": 4371382, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-EeUqRBaOle0/AAAAAAAAAAI/AAAAAAAAABE/ew3kplPVCuM/photo.jpg?sz=128", "display_name": "dbeinder", "link": "https://stackoverflow.com/users/4371382/dbeinder"}, "edited": false, "score": 0, "creation_date": 1424598025, "post_id": 28652031, "comment_id": 45609171, "body": "Link-Time-Optimization only works on static libraries, but I could get it to compile with <code>rustc -C link-args=-Wl,--gc-sections ldbg.rs</code>. Unfortunately, no effect here either."}], "answers": [{"tags": [], "owner": {"reputation": 2387, "user_id": 511016, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/d17e1ed4019d13456dae5386555c8e50?s=128&d=identicon&r=PG", "display_name": "blerontin", "link": "https://stackoverflow.com/users/511016/blerontin"}, "is_accepted": true, "score": 3, "last_activity_date": 1562919313, "last_edit_date": 1562919313, "creation_date": 1489157629, "answer_id": 42721286, "question_id": 28652031, "link": "https://stackoverflow.com/questions/28652031/why-does-rust-export-its-whole-standard-library-when-building-a-dll/42721286#42721286", "title": "Why does Rust export its whole standard library when building a DLL?", "body": "<p>Recently the new crate type \"cdylib\" has been added that likely better fits your use-case. Replace the first line of your source file with:</p>\n\n<pre><code>#![crate_type = \"cdylib\"]\n</code></pre>\n\n<p>When using the Cargo package manager instead of directly calling <code>rustc</code> update <code>Cargo.toml</code> to contain the following lines:</p>\n\n<pre><code>[lib]\ncrate-type = [\"cdylib\"]\n</code></pre>\n\n<p>For more details have a look at <a href=\"https://github.com/rust-lang/rust/pull/33553\" rel=\"nofollow noreferrer\">Rust pull request #33553</a>.</p>\n\n<p>In my test it decreased the size of the following simple <a href=\"https://doc.rust-lang.org/1.30.0/book/first-edition/ffi.html#calling-rust-code-from-c\" rel=\"nofollow noreferrer\">\"Hello World\"</a> DLL from 650k (dylib) down to 8k (cdylib). Also the number of exported symbols is decreased massively.</p>\n\n<pre><code>#[no_mangle]\npub extern fn hello_rust() -&gt; *const u8 {\n    \"Hello, world!\\0\".as_ptr()\n}\n</code></pre>\n"}], "owner": {"reputation": 133, "user_id": 4371382, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-EeUqRBaOle0/AAAAAAAAAAI/AAAAAAAAABE/ew3kplPVCuM/photo.jpg?sz=128", "display_name": "dbeinder", "link": "https://stackoverflow.com/users/4371382/dbeinder"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1965, "favorite_count": 1, "accepted_answer_id": 42721286, "answer_count": 1, "score": 13, "last_activity_date": 1562919313, "creation_date": 1424556990, "last_edit_date": 1424557459, "question_id": 28652031, "link": "https://stackoverflow.com/questions/28652031/why-does-rust-export-its-whole-standard-library-when-building-a-dll", "title": "Why does Rust export its whole standard library when building a DLL?", "body": "<p>I'm currently trying to write a dynamic library with Rust which will be loaded from a existing program. I need to export a few functions with specific names and calling conventions. Everything works, but as soon as I <code>use</code> anything from the standard library:</p>\n\n<ul>\n<li>The DLL size balloons to over 3MiB (Not exactly pretty, but I could live with that)</li>\n<li>The whole standard library gets exported from the DLL. Here is a lists with all exports: <a href=\"http://pastebin.com/LsG1u96C\" rel=\"noreferrer\">http://pastebin.com/LsG1u96C</a> (5100 functions)</li>\n</ul>\n\n<p>Am I missing some compiler switch?\nI compile the following code with <code>rustc</code> without any options:</p>\n\n<pre><code>#![crate_type = \"dylib\"]\n#![feature(std_misc)]\n\nuse std::ffi::CString;\n\n#[link(name = \"user32\")]\n#[allow(non_snake_case)]\nextern \"stdcall\" {\n    fn MessageBoxA(hWnd: u32, lpText: *const i8, lpCaption: *const i8, uType: u32) -&gt; u32;\n}\n\n#[no_mangle]\n#[allow(non_snake_case)]\npub unsafe extern \"stdcall\" fn _AddLuaState(lua_state_ptr: u32)\n{\n    let info_str = format!(\"Lua State Created: {}!\", lua_state_ptr);\n    let info_cstring = CString::new(info_str).unwrap();\n    let caption = CString::new(\"Hello from my Rust Library!\").unwrap();\n    MessageBoxA(0, info_cstring.as_ptr(), caption.as_ptr(), 0);\n}\n</code></pre>\n\n<p><code>_AddLuaState@4</code> is the only function that should be exported.</p>\n\n<p>This is on a Windows 8.1 machine with <code>rustc 1.0.0-nightly (522d09dfe 2015-02-19)</code> (x86)</p>\n\n<p>Update: It looks like when compiling a dynamically linked file with <code>rustc -C prefer-dynamic</code>, the DLL size shrinks to 60kiB and there are only 3 extra exports (<a href=\"http://pastebin.com/G0AYZrpF\" rel=\"noreferrer\">http://pastebin.com/G0AYZrpF</a>) which all look quite reasonable. But I'd still prefer a statically linked library.</p>\n"}, {"tags": ["iterator", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 4, "creation_date": 1424552805, "post_id": 28651259, "comment_id": 45600062, "body": "&quot;mutable&quot; and &quot;functional&quot; are two words that I don&#39;t see together very often. Mutating a variable is a side-effect, something that a lot of functional programming strives to minimize."}, {"owner": {"reputation": 198293, "user_id": 707111, "user_type": "moderator", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/oXZkh.jpg?s=128&g=1", "display_name": "Ry-", "link": "https://stackoverflow.com/users/707111/ry"}, "edited": false, "score": 4, "creation_date": 1424552985, "post_id": 28651259, "comment_id": 45600111, "body": "<code>.map()</code> doesn\u2019t modify things in place; it returns a new iterator. There isn\u2019t any mutable version of it. You can still convert that to a one-line operation, though: <code>for i in a.iter_mut() { *i += 1; }</code>"}], "answers": [{"comments": [{"owner": {"reputation": 2590, "user_id": 1479360, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/f3ddfbe76c5687a5ead4d06dfbb12dc2?s=128&d=identicon&r=PG", "display_name": "abject_error", "link": "https://stackoverflow.com/users/1479360/abject-error"}, "edited": false, "score": 0, "creation_date": 1424554029, "post_id": 28651397, "comment_id": 45600419, "body": "Thanks for clarifying some of the details.  Is there a way to pass a closure to <code>iter_mut</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2590, "user_id": 1479360, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/f3ddfbe76c5687a5ead4d06dfbb12dc2?s=128&d=identicon&r=PG", "display_name": "abject_error", "link": "https://stackoverflow.com/users/1479360/abject-error"}, "edited": false, "score": 1, "creation_date": 1424554037, "post_id": 28651397, "comment_id": 45600425, "body": "Instead of comparing it to <code>map!</code>, which only exists for Ruby&#39;s Array and Set classes, <code>map</code> is more like <code>Enumerable#map</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2590, "user_id": 1479360, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/f3ddfbe76c5687a5ead4d06dfbb12dc2?s=128&d=identicon&r=PG", "display_name": "abject_error", "link": "https://stackoverflow.com/users/1479360/abject-error"}, "edited": false, "score": 1, "creation_date": 1424554189, "post_id": 28651397, "comment_id": 45600466, "body": "There is no way to pass a closure directly to <code>iter_mut</code>; Rust&#39;s iterator adapters are more orthoganally factored than that. However, the compiler&#39;s optimizations generally make up for performance losses you might be worried about."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1424696896, "post_id": 28651397, "comment_id": 45642251, "body": "You should use <code>.count()</code> to &quot;run&quot; the iterator chain, and then it&#39;s not a ridiculously bad idea any more, just weird style."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 11, "last_activity_date": 1591618387, "last_edit_date": 1591618387, "creation_date": 1424553201, "answer_id": 28651397, "question_id": 28651259, "link": "https://stackoverflow.com/questions/28651259/modifying-self-in-iter-mut-map-aka-mutable-functional-collection-operat/28651397#28651397", "title": "Modifying self in `iter_mut().map(..)`, aka mutable functional collection operations", "body": "<p>Your code dereferences the variable (<code>*i</code>) then adds one to it. Nowhere in there does the <em>original value</em> get changed. </p>\n\n<p>The best way to do what you asked is to use <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.for_each\" rel=\"noreferrer\"><code>Iterator::for_each</code></a>:</p>\n\n<pre><code>a.iter_mut().for_each(|i| *i += 1);\n</code></pre>\n\n<p>This gets an iterator of mutable references to the numbers in your vector. For each item, it dereferences the reference and then increments it.</p>\n\n<p>You could use <code>map</code> and <code>collect</code>, but doing so is non-idiomatic and potentially wasteful. This uses <code>map</code> for the side-effect of mutating the <em>original value</em>. The \"return value\" of assignment is the unit type <code>()</code> - an empty tuple. We use <code>collect::&lt;Vec&lt;()&gt;&gt;</code> to force the Iterator adapter to iterate. This last bit <code>::&lt;...&gt;</code> is called the <em>turbofish</em> and allows us to provide a <em>type parameter</em> to the <code>collect</code> call, informing it what type to use, as nothing else would constrain the return type.:</p>\n\n<pre><code>let _ = a.iter_mut().map(|i| *i += 1).collect::&lt;Vec&lt;()&gt;&gt;();\n</code></pre>\n\n<p>You could also use something like <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.count\" rel=\"noreferrer\"><code>Iterator::count</code></a>, which is lighter than creating a <code>Vec</code>, but still ultimately unneeded:</p>\n\n<pre><code>a.iter_mut().map(|i| *i += 1).count();\n</code></pre>\n\n<p>As <a href=\"https://stackoverflow.com/questions/28651259/modifying-self-in-iter-mut-map-aka-mutable-functional-collection-operat#comment45600111_28651259\">Ry- says</a>, using a <code>for</code> loop is more idiomatic:</p>\n\n<pre><code>for i in &amp;mut a {\n    *i += 1;\n}\n</code></pre>\n"}], "owner": {"reputation": 2590, "user_id": 1479360, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/f3ddfbe76c5687a5ead4d06dfbb12dc2?s=128&d=identicon&r=PG", "display_name": "abject_error", "link": "https://stackoverflow.com/users/1479360/abject-error"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3176, "favorite_count": 2, "accepted_answer_id": 28651397, "answer_count": 1, "score": 10, "last_activity_date": 1591618387, "creation_date": 1424552323, "last_edit_date": 1591617958, "question_id": 28651259, "link": "https://stackoverflow.com/questions/28651259/modifying-self-in-iter-mut-map-aka-mutable-functional-collection-operat", "title": "Modifying self in `iter_mut().map(..)`, aka mutable functional collection operations", "body": "<p>How do I convert something like this: </p>\n\n<pre><code>let mut a = vec![1, 2, 3, 4i32];\nfor i in a.iter_mut() {\n    *i += 1;\n}\n</code></pre>\n\n<p>to a one line operation using <code>map</code> and a closure?</p>\n\n<p>I tried:</p>\n\n<pre><code>a.iter_mut().map(|i| *i + 1).collect::&lt;Vec&lt;i32&gt;&gt;();\n</code></pre>\n\n<p>The above only works if I reassign it to <code>a</code>. Why is this? Is <code>map</code> getting a copy of <code>a</code> instead of a mutable reference? If so, how can I get a mutable reference?</p>\n"}, {"tags": ["binding", "rust"], "answers": [{"comments": [{"owner": {"reputation": 417, "user_id": 1916860, "user_type": "registered", "accept_rate": 32, "profile_image": "https://www.gravatar.com/avatar/0a017c30909f570c60315c17b282b08d?s=128&d=identicon&r=PG", "display_name": "PablodeAcero", "link": "https://stackoverflow.com/users/1916860/pablodeacero"}, "edited": false, "score": 0, "creation_date": 1424550756, "post_id": 28650863, "comment_id": 45599329, "body": "Just another question: If I wanted this function not to return anything, could I still be able to change the variable passed as a parameter (declared as mut)?"}, {"owner": {"reputation": 417, "user_id": 1916860, "user_type": "registered", "accept_rate": 32, "profile_image": "https://www.gravatar.com/avatar/0a017c30909f570c60315c17b282b08d?s=128&d=identicon&r=PG", "display_name": "PablodeAcero", "link": "https://stackoverflow.com/users/1916860/pablodeacero"}, "edited": false, "score": 0, "creation_date": 1424550978, "post_id": 28650863, "comment_id": 45599413, "body": "Yes. Like the function only purpose is to add 1 to every element of the tuple, which is declared outside add_one"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1424551111, "last_edit_date": 1424551111, "creation_date": 1424550051, "answer_id": 28650863, "question_id": 28650782, "link": "https://stackoverflow.com/questions/28650782/expected-identifier-found-when-trying-to-bind-a-tuple-variable/28650863#28650863", "title": "&quot;expected identifier, found (&quot; when trying to bind a tuple variable", "body": "<p>The <code>mut</code> qualifier applies per-variable. When you are destructuring a variable, each variable can be mutable or not:</p>\n\n<pre><code>fn add_one(h: (i32, i32, i32)) -&gt; (i32, i32, i32) {\n    let (mut x, mut y, mut z) = h;\n    (x+1, y+1, z+1)\n}\n</code></pre>\n\n<p>Of course, you don't need mutability here at all:</p>\n\n<pre><code>fn add_one(h: (i32, i32, i32)) -&gt; (i32, i32, i32) {\n    let (x, y, z) = h;\n    (x+1, y+1, z+1)\n}\n</code></pre>\n\n<p>You could also choose to destructure in the function signature:</p>\n\n<pre><code>fn add_one((x, y, z): (i32, i32, i32)) -&gt; (i32, i32, i32) {\n    (x+1, y+1, z+1)\n}\n</code></pre>\n\n<p>Or use the default tuple accessor methods:</p>\n\n<pre><code>fn add_one(h: (i32, i32, i32)) -&gt; (i32, i32, i32) {\n    (h.0 + 1, h.1 + 1, h.2 + 1)\n}\n</code></pre>\n\n<p>If you want to mutate the tuple in place, you are going to need to provide a <em>mutable reference</em> to the tuple. Without knowing more about the problem you are trying to solve, I would actively discourage you from choosing this path, at least until you've profiled and determined you need it:</p>\n\n<pre><code>fn add_one(h: &amp;mut (i32, i32, i32)) {\n    h.0 += 1;\n    h.1 += 1;\n    h.2 += 1;\n}\n\nfn main() {\n    let mut a = (1, 2, 3);\n    add_one(&amp;mut a);\n    println!(\"{:?}\", a)\n}\n</code></pre>\n\n<p>There are lots of ways to write code that is meaningful to you!</p>\n"}], "owner": {"reputation": 417, "user_id": 1916860, "user_type": "registered", "accept_rate": 32, "profile_image": "https://www.gravatar.com/avatar/0a017c30909f570c60315c17b282b08d?s=128&d=identicon&r=PG", "display_name": "PablodeAcero", "link": "https://stackoverflow.com/users/1916860/pablodeacero"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1327, "favorite_count": 0, "accepted_answer_id": 28650863, "answer_count": 1, "score": 2, "last_activity_date": 1424612611, "creation_date": 1424549555, "last_edit_date": 1424612611, "question_id": 28650782, "link": "https://stackoverflow.com/questions/28650782/expected-identifier-found-when-trying-to-bind-a-tuple-variable", "title": "&quot;expected identifier, found (&quot; when trying to bind a tuple variable", "body": "<p>I'm playing with Rust a little bit, and got stuck. I've the following function:</p>\n\n<pre><code>fn addOne(h: (i32, i32, i32)){\n\n    let mut (x, y, z) = h;\n\n    (x+1, y+1, z+1)\n}\n</code></pre>\n\n<p>This gives me the following error on compile:</p>\n\n<pre><code>example.rs:2:10: 2:11 error: expected identifier, found `(`\nexample.rs:2    let mut (x, y, z) = h;\n</code></pre>\n\n<p>Is there something wrong with the binding? Sorry if it is such a simple question.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1424544230, "post_id": 28649719, "comment_id": 45596902, "body": "Why do the items differ ? Shouldn&#39;t iterators work similar for types which are the same semantically ? After all, a vec! is a bunch of strings on the heap, whereas an array allocates space for them on the stack. Why would iteration be different ?"}, {"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1424544391, "post_id": 28649719, "comment_id": 45596967, "body": "Also, is there a way that allows me to most generically iterate anything that looks like a string ? Maybe &#39;String&#39; should be &#39;T&#39; with the right traits."}, {"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 1, "creation_date": 1424546521, "post_id": 28649719, "comment_id": 45597827, "body": "Thank you so much ! Now I get it ! I should be able to debug this myself, and I am grateful that you pointed this out, hopefully allowing me to answer such questions myself in the future. Rust, as any good thing, doesn&#39;t come easily."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 8, "last_activity_date": 1471727888, "last_edit_date": 1471727888, "creation_date": 1424543904, "answer_id": 28649719, "question_id": 28649466, "link": "https://stackoverflow.com/questions/28649466/how-to-most-generically-iterate-a-sequence-of-items-with-a-given-type/28649719#28649719", "title": "How to most generically iterate a sequence of items with a given type?", "body": "<p>Let's look at what the types are for your first case:</p>\n\n<pre><code>for i in &amp;[\"foo\".to_string()] {\n    let () = i;\n    // expected `&amp;collections::string::String`,\n    // found `()`\n}\n</code></pre>\n\n<p>That is, the type of your iteration variable is <code>&amp;String</code>, <strong>not</strong> on <code>String</code>, as your function wants. The same thing happens for your second case. The third case works:</p>\n\n<pre><code>for i in vec![\"foo\".to_string()] {\n    let () = i;\n    // expected `collections::string::String`,\n    // found `()`\n}\n</code></pre>\n\n<p>We can look at the implementation for <code>IntoIter</code> for <a href=\"https://github.com/rust-lang/rust/blob/1.11.0/src/libcore/array.rs#L150-L158\" rel=\"nofollow\">arrays</a> and for <a href=\"https://github.com/rust-lang/rust/blob/1.10.0/src/libcollections/vec.rs#L1330-L1388\" rel=\"nofollow\">all 3 forms of Vec</a>. Note that the implementation for <code>Vec&lt;T&gt;</code> <em>consumes</em> the vector, whereas the one for <code>&amp;Vec&lt;T&gt;</code> must return an iterator over references to the elements.</p>\n\n<p>You can't consume an array, so that iterator must always return references.</p>\n\n<p>Here's an example that uses the <a href=\"https://doc.rust-lang.org/std/convert/trait.AsRef.html\" rel=\"nofollow\"><code>AsRef</code></a> trait that should do what you want:</p>\n\n<pre><code>use std::iter::IntoIterator;\n\nfn iterate&lt;I, S&gt;(v: I)\n    where I: IntoIterator&lt;Item=S&gt;,\n          S: AsRef&lt;str&gt;\n{}\n\nfn main() {\n    iterate(&amp;[\"foo\"]);\n    iterate(&amp;[\"foo\".to_string()]);\n    iterate([\"foo\".to_string()].iter());\n    iterate(vec![\"foo\".to_string()]);\n    iterate(&amp;vec![\"foo\".to_string()]);\n}\n</code></pre>\n\n<p>This says that we expect any concrete type that implements the trait <code>Iterator</code>. That iterator must yield a type that implements the trait <code>AsRef&lt;str&gt;</code>, allowing us to pass in {arrays,vectors,slices} of {<code>String</code>,<code>&amp;str</code>}.</p>\n"}], "owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 685, "favorite_count": 2, "accepted_answer_id": 28649719, "answer_count": 1, "score": 5, "last_activity_date": 1471727888, "creation_date": 1424542647, "last_edit_date": 1424560007, "question_id": 28649466, "link": "https://stackoverflow.com/questions/28649466/how-to-most-generically-iterate-a-sequence-of-items-with-a-given-type", "title": "How to most generically iterate a sequence of items with a given type?", "body": "<p>The code below best describes the issue.</p>\n\n<pre><code>use std::iter::IntoIterator;\n\nfn iterate&lt;I: IntoIterator&lt;Item=String&gt;&gt;(v: I) {\n}\n\n// iterate(&amp;[\"foo\".to_string()])\n// error: type mismatch resolving `&lt;&amp;[collections::string::String; 1] as core::iter::IntoIterator&gt;::Item == collections::string::String`:\n// expected &amp;-ptr,\n// found struct `collections::string::String` [E0271]\n\n// iterate([\"foo\".to_string()].iter())\n// type mismatch resolving `&lt;core::slice::Iter&lt;'_, collections::string::String&gt; as core::iter::IntoIterator&gt;::Item == collections::string::String`:\n// expected &amp;-ptr,\n// found struct `collections::string::String` [E0271]\n\n// This works !\niterate(vec![\"foo\".to_string()])\n</code></pre>\n\n<p><strong>How can I iterate anything (with a given item type) generically?</strong></p>\n\n<h3>Additional Notes</h3>\n\n<p>The intention is to allow users of such a function to pass in anything that can be iterated, or converted into an iterator.</p>\n\n<p>Also I have the feeling that the actual issue is not really described in the compiler error - as the type it sees seems to be different from what it shows.</p>\n\n<p>I am using <code>rustc 1.0.0-nightly (522d09dfe 2015-02-19) (built 2015-02-19)</code></p>\n"}, {"tags": ["rust", "ffi"], "comments": [{"owner": {"reputation": 1217, "user_id": 881195, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/n74Mq.jpg?s=128&g=1", "display_name": "Tupshin Harper", "link": "https://stackoverflow.com/users/881195/tupshin-harper"}, "edited": false, "score": 0, "creation_date": 1424562721, "post_id": 28649311, "comment_id": 45602669, "body": "Shep, once again, you help is greatly appreciated. :) I think I&#39;m almost done with the unsafe parts of the full driver api.  What am I still missing, though? (see edit)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1424613888, "post_id": 28649311, "comment_id": 45613128, "body": "I&#39;ve updated my answer. In the future, make sure to use the @-mention in comments, otherwise people won&#39;t see that you are talking to them. I just happened to re-read this one. :-)"}, {"owner": {"reputation": 1217, "user_id": 881195, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/n74Mq.jpg?s=128&g=1", "display_name": "Tupshin Harper", "link": "https://stackoverflow.com/users/881195/tupshin-harper"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1424615821, "post_id": 28649311, "comment_id": 45613688, "body": "You are a god among Rustaceans."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1580140699, "last_edit_date": 1592644375, "creation_date": 1424543183, "answer_id": 28649572, "question_id": 28649311, "link": "https://stackoverflow.com/questions/28649311/what-is-the-proper-way-to-go-from-a-string-to-a-const-i8/28649572#28649572", "title": "What is the proper way to go from a String to a *const i8?", "body": "<p>The Cassandra <a href=\"https://github.com/datastax/cpp-driver/blob/011769c8053f14c1484c13358ce6403c1449bb72/include/cassandra.h#L3141-L3154\" rel=\"nofollow noreferrer\">C API for cass_string_init2</a> looks like:</p>\n<blockquote>\n<p>Note: This <strong>does not allocate memory</strong>. The object wraps the pointer passed into this function.</p>\n<pre class=\"lang-c prettyprint-override\"><code>CASS_EXPORT CassString\ncass_string_init2(const char* data, cass_size_t length);\n</code></pre>\n</blockquote>\n<p>That is, it takes a string, <em>and returns an alternate representation of a string</em>. That <a href=\"https://github.com/datastax/cpp-driver/blob/011769c8053f14c1484c13358ce6403c1449bb72/include/cassandra.h#L118-L121\" rel=\"nofollow noreferrer\">representation looks like</a>:</p>\n<pre class=\"lang-c prettyprint-override\"><code>typedef struct CassString_ {\n    const char* data;\n    cass_size_t length;\n} CassString;\n</code></pre>\n<p>This is where you want to use <code>#[repr(C)]</code> in the Rust code:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>#[repr(C)]\nstruct CassStr {\n    data: *const c_char,\n    length: size_t,\n}\n</code></pre>\n<p>The nicest thing you could do is make strings automatically convert to this struct:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>trait AsCassStr {\n    fn as_cass_str(&amp;self) -&gt; CassStr;\n}\n\nimpl AsCassStr for str {\n    fn as_cass_str(&amp;self) -&gt; CassStr {\n        CassStr {\n            data: self.as_bytes(),\n            length: self.len(),\n        }\n    }\n}\n</code></pre>\n<p>And then have your API accept anything that implements <code>AsCassStr</code>. This allows you to have owned variants as well. You may also want to look into <code>PhantomData</code> to allow enforcing lifetimes of the <code>CassStr</code> object.</p>\n<p><strong>Note</strong> Normally you want to use <code>CString</code> to avoid strings with <em>interior NUL bytes</em>. However, since the API accepts a length parameter, it's possible that it natively supports them. You'll need to experiment to find out. If not, then you'll need to use <code>CString</code> as shown below.</p>\n<h3>Second half of question</h3>\n<p>Lets take a look at your function, line-by-line:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>impl AsContactPoints for str {\n    fn as_contact_points(&amp;self) -&gt; ContactPoints {\n        let cstr = CString::new(self).unwrap(); // 1\n        let bytes = cstr.as_bytes_with_nul();   // 2\n        let ptr = bytes.as_ptr();               // 3\n        ContactPoints(ptr as *const i8)         // 4\n    }                                           // 5\n}\n</code></pre>\n<ol>\n<li>We create a new <code>CString</code>. This allocates a bit of memory somewhere, verifies that the string has no <em>internal NUL bytes</em>, then copies our string in, byte-for-byte, and adds a trailing zero.</li>\n<li>We get a slice that refers to the bytes that we have copied and verified in step 1. Recall that slices are a pointer to data plus a length.</li>\n<li>We convert the slice to a pointer, ignoring the length.</li>\n<li>We store the pointer in a structure, using that as our return value</li>\n<li>The function exits, and <strong>all local variables are freed</strong>. Note that <code>cstr</code> is a local variable, and so the bytes it is holding are likewise freed. You now have a <em>dangling pointer</em>. Not good!</li>\n</ol>\n<p>You need to ensure that the <code>CString</code> lives for as long as it needs to. Hopefully the function you are calling doesn't keep a reference to it, but there's no easy way to tell from the function signature. You probably want code that looks like:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>fn my_cass_call(s: &amp;str) {\n    let s = CString::new(s).unwrap();\n    cass_call(s.as_ptr()) // `s` is still alive here\n}\n</code></pre>\n<p>The benefit here is that you never store the pointer in a variable of your own. Remember that raw pointers do not have lifetimes, so you have to be very careful with them!</p>\n"}], "owner": {"reputation": 1217, "user_id": 881195, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/n74Mq.jpg?s=128&g=1", "display_name": "Tupshin Harper", "link": "https://stackoverflow.com/users/881195/tupshin-harper"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5372, "favorite_count": 2, "accepted_answer_id": 28649572, "answer_count": 1, "score": 9, "last_activity_date": 1580140699, "creation_date": 1424541914, "last_edit_date": 1424562133, "question_id": 28649311, "link": "https://stackoverflow.com/questions/28649311/what-is-the-proper-way-to-go-from-a-string-to-a-const-i8", "title": "What is the proper way to go from a String to a *const i8?", "body": "<p>In my ongoing saga of writing a <a href=\"https://github.com/tupshin/cql-ffi/\" rel=\"noreferrer\">safe wrapper</a> for the <a href=\"https://github.com/datastax/cpp-driver/\" rel=\"noreferrer\">Cassandra C++ driver</a>, my eye now turns towards avoiding memory leaks when calling C functions with signatures like:</p>\n\n<pre><code>cass_string_init2(const char* data, cass_size_t length);\n</code></pre>\n\n<p>or</p>\n\n<pre><code>cass_string_init(const char* null_terminated);\n</code></pre>\n\n<p>I have tried a few different approaches that nominally work, and produce a correct result, but I haven't found a way to manage the lifetime of this data properly. Two example approaches are below. </p>\n\n<pre><code>pub fn str_to_ref(mystr:&amp;str) -&gt; *const i8 {unsafe{\n    let cstr = CString::from_slice(mystr.as_bytes());\n    cstr.as_slice().as_ptr()\n}}\n</code></pre>\n\n<p>and</p>\n\n<pre><code>pub fn str_to_ref(mystr: &amp;str) -&gt; *const i8 {\n    let l = mystr.as_bytes();\n    unsafe {\n        let b = alloc::heap::allocate(mystr.len()+1, 8);\n        let s = slice::from_raw_parts_mut(b, mystr.len()+1);\n        slice::bytes::copy_memory(s, l);\n        s[mystr.len()] = 0;\n        return b as *const i8;\n    }\n}\n</code></pre>\n\n<p>The first does invalid memory accesses like</p>\n\n<pre><code>==26355==  Address 0x782d140 is 0 bytes inside a block of size 320 free'd\n==26355==    at 0x1361A8: je_valgrind_freelike_block (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==26355==    by 0x11272D: heap::imp::deallocate::h7b540039fbffea4dPha (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==26355==    by 0x112679: heap::deallocate::h3897fed87b942253tba (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==26355==    by 0x112627: vec::dealloc::h7978768019700822177 (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==26355==    by 0x112074: vec::Vec$LT$T$GT$.Drop::drop::h239007174869221309 (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==26355==    by 0x111F9D: collections..vec..Vec$LT$i8$GT$::glue_drop.5732::h978a83960ecb86a4 (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==26355==    by 0x111F6D: std..ffi..c_str..CString::glue_drop.5729::h953a595760f34a9d (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==26355==    by 0x112903: cql_ffi::helpers::str_to_ref::hef3994fa55168b90bqd (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n=\n</code></pre>\n\n<p>while the second doesn't know when to deallocate its memory, resulting in:</p>\n\n<pre><code>==29782== 8 bytes in 1 blocks are definitely lost in loss record 1 of 115\n==29782==    at 0x12A5B2: je_mallocx (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==29782==    by 0x1142D5: heap::imp::allocate::h3fa8a1c097e9ea53Tfa (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==29782==    by 0x114221: heap::allocate::h18d191ce51ab2236gaa (in /home/tupshin/workspaces/rust/cql-ffi/target/basic)\n==29782==    by 0x112874: cql_ffi::helpers::str_to_ref::h5b60f207d1e31841bqd (helpers.rs:25)\n</code></pre>\n\n<p>Using either of those two approaches as a starting point, or something completely different, I would really appreciate some guidance on a proper way to accomplish this.</p>\n\n<p>Edit: </p>\n\n<p>Shep's answer <em>perfectly</em> solved my issues using cass_string_init and cass_string_init2. Thank you so much. However, I'm still not clear on passing *const i8 params to other functions such as:</p>\n\n<pre><code>CASS_EXPORT CassError\ncass_cluster_set_contact_points(CassCluster* cluster,\nconst char* contact_points);\n</code></pre>\n\n<p>which expect to be passed a reference to a null-terminated string.</p>\n\n<p>Based on the previous approach that worked for CassStrings, along with the CString docs, I came up with the following:</p>\n\n<pre><code>pub struct ContactPoints(*const c_char);\n\npub trait AsContactPoints {\n    fn as_contact_points(&amp;self) -&gt; ContactPoints;\n}\n\nimpl AsContactPoints for str {\n    fn as_contact_points(&amp;self) -&gt; ContactPoints {\n        let cstr = CString::new(self).unwrap();\n        let bytes = cstr.as_bytes_with_nul();\n        let ptr = bytes.as_ptr();\n        ContactPoints(ptr as *const i8)\n    }\n}\n</code></pre>\n\n<p>(the excessive let bindings there are just to make sure I wasn't missing any subtlety)</p>\n\n<p>and that runs correctly, but valgrind complains:</p>\n\n<pre><code>==22043== Invalid read of size 1\n==22043==    at 0x4C2E0E2: strlen (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==22043==    by 0x4F8AED8: cass_cluster_set_contact_points (in /usr/local/lib/libcassandra.so.1.0.0)\n==22043==    by 0x11367A: cql_ffi::cluster::CassCluster::set_contact_points::h575496cbf7644b9e6oa (cluster.rs:76)\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1424541608, "post_id": 28649120, "comment_id": 45595890, "body": "Just a wild guess (couldn&#39;t compile your code at all): try to make these traits <code>unsafe</code>: <code>pub unsafe trait Copy {}</code>."}, {"owner": {"reputation": 687, "user_id": 985909, "user_type": "registered", "accept_rate": 44, "profile_image": "https://www.gravatar.com/avatar/acff378135c21d72608c028716cc7da0?s=128&d=identicon&r=PG", "display_name": "RyanB", "link": "https://stackoverflow.com/users/985909/ryanb"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1424541881, "post_id": 28649120, "comment_id": 45596000, "body": "Still complains that <code>parameter &#39;Self&#39; is never used</code>.  Sorry - the complete code is in the repo above, it just appears to not be working with the latest Rust."}, {"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 0, "creation_date": 1424545890, "post_id": 28649120, "comment_id": 45597589, "body": "You might try using <code>trait Blah : ::std::marker::MarkerTrait</code>. See: <a href=\"http://doc.rust-lang.org/std/marker/trait.MarkerTrait.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/marker/trait.MarkerTrait.html</a>"}, {"owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "reply_to_user": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 1, "creation_date": 1424558872, "post_id": 28649120, "comment_id": 45601760, "body": "@BurntSushi5 That would be a bit difficult, as OP can&#39;t use <code>std</code> ;)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424561360, "post_id": 28649120, "comment_id": 45602331, "body": "I would suggest copying <a href=\"https://github.com/rust-lang/rust/blob/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src/libcore/marker.rs#L287-L288\" rel=\"nofollow noreferrer\">MarkerTrait</a> and <a href=\"https://github.com/rust-lang/rust/blob/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src/libcore/marker.rs#L347-L352\" rel=\"nofollow noreferrer\">PhantomFn</a>, but that seems to cause an LLVM assertion."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424561408, "post_id": 28652649, "comment_id": 45602348, "body": "Were you able to get this to compile? I got: <code>Assertion failed: (isa&lt;X&gt;(Val) &amp;&amp; &quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;), function cast, file &#47;Users&#47;shep&#47;Projects&#47;rust&#47;src&#47;llvm&#47;include&#47;llvm&#47;Support&#47;Cast&zwnj;&#8203;ing.h, line 237.</code>"}, {"owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424563764, "post_id": 28652649, "comment_id": 45602921, "body": "I did get a minimal example (without the Arduino stuff) to compile -- but having neither Homebrew nor an Arduino, I didn&#39;t find it worth the effort to set up the whole toolchain. Besides, I think the assertion is orthogonal and would fit a separate question."}, {"owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1424564727, "post_id": 28652649, "comment_id": 45603169, "body": "It works if you compile it as a library (<code>--crate-type lib</code>) like the build script does, instead of an executable."}], "tags": [], "owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "is_accepted": false, "score": 3, "last_activity_date": 1424563824, "last_edit_date": 1424563824, "creation_date": 1424561352, "answer_id": 28652649, "question_id": 28649120, "link": "https://stackoverflow.com/questions/28649120/unable-to-compile-rust-with-no-std-lang-items/28652649#28652649", "title": "Unable to compile Rust with no_std/lang_items", "body": "<p>A few days ago, Rust added the rule that all type parameters must appear in the methods of the trait (<a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\" rel=\"nofollow\">RFC 738</a>). But since <code>Sized</code> (and <code>Copy</code> and <code>Sync</code>) doesn't have any methods of its own, it breaks this rule by default.</p>\n\n<p>The official workaround is to mark the trait as <code>PhantomFn</code>, which silences the error:</p>\n\n<pre><code>#![feature(asm)]\n#![feature(lang_items)]\n#![feature(no_std)]\n\n#![no_std]\n\nuse arduino::{init, delay, pinMode, digitalWrite, analogWrite, LOW, HIGH, OUTPUT};\nmod arduino;\n\n// Copied from &lt;http://doc.rust-lang.org/core/marker/trait.PhantomFn.html&gt;\n#[lang=\"phantom_fn\"]\ntrait PhantomFn&lt;A: ?Sized, R: ?Sized = ()&gt; {}\n\n#[lang=\"sized\"]\ntrait Sized: PhantomFn&lt;Self&gt; {}\n\n#[lang=\"copy\"]\ntrait Copy: PhantomFn&lt;Self&gt; {}\n\n#[lang=\"sync\"]\ntrait Sync: PhantomFn&lt;Self&gt; {}\n\nstatic PWM:u32 = 2;\nstatic LED:u32 = 11;\n\n#[no_mangle]\npub fn main() {\n  // ...\n}\n</code></pre>\n\n<p>This change should make the code compile again.</p>\n\n<h2>Addendum: What are lang items?</h2>\n\n<p>A <em>lang item</em> is a symbol that's marked as \"special\" to the compiler. Some examples are:</p>\n\n<ul>\n<li><p>The heap allocator</p></li>\n<li><p>Procedures for unwinding on <code>panic</code></p></li>\n<li><p>Types and traits that ensure type safety, like <code>Send</code> and <code>Drop</code> and <code>PhantomData</code></p></li>\n<li><p>Traits for operator overloading, like <code>Add</code> and <code>Eq</code> and <code>Deref</code></p></li>\n</ul>\n\n<p>You can find a list of them in <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc/middle/lang_items.rs\" rel=\"nofollow\"><code>lang_items.rs</code></a>.</p>\n\n<p>These items are critical to the semantics of the language, but are impractical to implement in the compiler itself. So we put them in the standard library instead, with special annotations that tell the compiler where they are.</p>\n\n<p>Now, while you can define these items itself, it's recommended to link to <a href=\"http://doc.rust-lang.org/core/\" rel=\"nofollow\"><code>core</code></a> instead, which declares these lang items for you. But I'm not sure how well that would work with your setup.</p>\n"}], "owner": {"reputation": 687, "user_id": 985909, "user_type": "registered", "accept_rate": 44, "profile_image": "https://www.gravatar.com/avatar/acff378135c21d72608c028716cc7da0?s=128&d=identicon&r=PG", "display_name": "RyanB", "link": "https://stackoverflow.com/users/985909/ryanb"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1744, "favorite_count": 0, "answer_count": 1, "score": 3, "last_activity_date": 1424563824, "creation_date": 1424541077, "question_id": 28649120, "link": "https://stackoverflow.com/questions/28649120/unable-to-compile-rust-with-no-std-lang-items", "title": "Unable to compile Rust with no_std/lang_items", "body": "<p>I am attempting to set up a project very similar to <a href=\"https://github.com/jensnockert/dueboot\" rel=\"nofollow\">dueboot</a>.  That is, Rust on embedded ARM.  Right now, I'm only up to the point of compiling the Rust code, but I can't get it to compile.</p>\n\n<p>I've basically copied the rust code exactly from that project, but I don't fully understand the <code>lang_items</code> feature.</p>\n\n<pre><code>#![feature(asm)]\n#![feature(lang_items)]\n#![feature(no_std)]\n\n#![no_std]\n\nuse arduino::{init, delay, pinMode, digitalWrite, analogWrite, LOW, HIGH, OUTPUT};\nmod arduino;\n\n#[lang=\"sized\"]\ntrait Sized {}\n\n#[lang=\"copy\"]\ntrait Copy {}\n\n#[lang=\"sync\"]\ntrait Sync {}\n\nstatic PWM:u32 = 2;\nstatic LED:u32 = 11;\n\n#[no_mangle]\npub fn main() {\n  // ...\n}\n</code></pre>\n\n<p>Attempting to compile the code as above, results in this error:</p>\n\n<pre><code>main.rs:11:1: 11:15 error: parameter `Self` is never used\nmain.rs:11 trait Sized {}\n           ^~~~~~~~~~~~~~\nmain.rs:14:1: 14:14 error: parameter `Self` is never used\nmain.rs:14 trait Copy {}\n           ^~~~~~~~~~~~~\nmain.rs:17:1: 17:14 error: parameter `Self` is never used\nmain.rs:17 trait Sync {}\n           ^~~~~~~~~~~~~\nerror: aborting due to 3 previous errors\n</code></pre>\n\n<p>I also attempted to comment out all of the lines relating to the <code>lang_items</code>, including the feature line at the top.  This is the resulting error message:</p>\n\n<pre><code>// more lines of the same message\nerror: requires `sized` lang_item\nerror: requires `sized` lang_item\nerror: requires `sized` lang_item\nerror: requires `sized` lang_item\nerror: requires `sized` lang_item\nerror: aborting due to 54 previous errors\n</code></pre>\n\n<p>I'm using rust built from master, as of yesterday.</p>\n\n<p>Any suggestions?</p>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 1, "last_activity_date": 1424539860, "creation_date": 1424539860, "answer_id": 28648839, "question_id": 28648543, "link": "https://stackoverflow.com/questions/28648543/is-this-kind-of-borrowing-the-rust-way/28648839#28648839", "title": "Is this kind of borrowing the &quot;Rust way&quot;?", "body": "<p>I'm not sure why you decided that you need an explicit borrow here. The following works perfectly:</p>\n\n<pre><code>use std::old_io::process::Command;\n\nfn main() {\n    let mut process = Command::new(\"tr\")\n        .arg(\"a-z\").arg(\"A-Z\")\n        .spawn()\n        .ok().expect(\"Failed.\");\n\n    let input_example = \"hello world\".as_bytes();\n\n    process.stdin.as_mut().unwrap().write_all(input_example);\n\n    let output = process.wait_with_output().ok().expect(\"Failed.\");\n    println!(\"Output:\");\n    println!(\"{}\", String::from_utf8(output.output).unwrap());\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1424540801, "creation_date": 1424540801, "answer_id": 28649054, "question_id": 28648543, "link": "https://stackoverflow.com/questions/28648543/is-this-kind-of-borrowing-the-rust-way/28649054#28649054", "title": "Is this kind of borrowing the &quot;Rust way&quot;?", "body": "<blockquote>\n  <p>Why does it need to borrow \"process\" at all?\"</p>\n</blockquote>\n\n<p>Because you are using <a href=\"http://doc.rust-lang.org/core/option/enum.Option.html#method.as_mut\" rel=\"nofollow\"><code>Option::as_mut</code></a>. The signature looks like:</p>\n\n<pre><code>fn as_mut&lt;'r&gt;(&amp;'r mut self) -&gt; Option&lt;&amp;'r mut T&gt;\n</code></pre>\n\n<p>This says that the lifetime of the return value is tied to the input. Additionally, it's a mutable reference, which you are only allowed to have one of at a particular time (to prevent <em>aliasing</em>).</p>\n\n<p>The reason you need to add a new scope is because <a href=\"https://github.com/rust-lang/rust/issues/6393\" rel=\"nofollow\">borrow scopes are lexically-scoped</a>. This is considered an annoying but work-aroundable issue. Right now, the mutable borrow lasts until the end of the block, which prevents borrowing <code>process</code> a second time.</p>\n\n<p>In Vladimir's example:</p>\n\n<pre><code>process.stdin.as_mut().unwrap().write_all(input_example);\n</code></pre>\n\n<p>The borrow from <code>as_mut</code> is never stored in a variable, so it \"goes out of scope\" immediately after that line ends. This allows you to borrow it again without the need for a new scope.</p>\n"}], "owner": {"reputation": 1073, "user_id": 2277915, "user_type": "registered", "accept_rate": 39, "profile_image": "https://www.gravatar.com/avatar/e9dba1201139b216bbe3136b06fa2793?s=128&d=identicon&r=PG", "display_name": "Reignbeaux", "link": "https://stackoverflow.com/users/2277915/reignbeaux"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 110, "favorite_count": 0, "accepted_answer_id": 28649054, "answer_count": 2, "score": 1, "last_activity_date": 1424540927, "creation_date": 1424538380, "last_edit_date": 1424540927, "question_id": 28648543, "link": "https://stackoverflow.com/questions/28648543/is-this-kind-of-borrowing-the-rust-way", "title": "Is this kind of borrowing the &quot;Rust way&quot;?", "body": "<p>When I try to start another application, write some stuff on it's stdin and then wait for it so finish, my code looks something like this (old_io):</p>\n\n<pre><code>let mut process = Command::new(\"example_app\")\n.arg(\"test\").spawn().ok().expect(\"Failed.\");\n\n{\n    let mut std = &amp;mut process.stdin.as_mut().unwrap();\n    std.write_all(input_example);\n}\n\nlet output = process.wait_with_output().ok().expect(\"Failed.\");\n</code></pre>\n\n<p>That's working, but I don't feel like that's the way to go. Since \"&amp;mut process.stdin.as_mut().unwrap()\" seems to borrow \"process\", I need to make sure that it goes out of scope before accessing it again, don't I? And another question is: Why does it need to borrow \"process\" at all?\"</p>\n"}, {"tags": ["process", "stdout", "rust"], "answers": [{"comments": [{"owner": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1424677383, "post_id": 28649217, "comment_id": 45631991, "body": "Is it idiomatic to place <code>process.stdout.as_mut().unwrap()</code> into the while loop, and thus execute it on each iteration ?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 3183, "user_id": 651368, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/2b8a70f5cb38a9e7565e128e6243ac20?s=128&d=identicon&r=PG", "display_name": "Byron", "link": "https://stackoverflow.com/users/651368/byron"}, "edited": false, "score": 0, "creation_date": 1425345703, "post_id": 28649217, "comment_id": 45916498, "body": "I don&#39;t know about <i>idiomatic</i>, it was simply the easiest thing to show the general shape of the solution. All of the &quot;error handling&quot; here is simply to <code>panic!()</code> whenever something&#39;s not right. If you can avoid calling that multiple times, it&#39;s probably worth it!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1424541490, "creation_date": 1424541490, "answer_id": 28649217, "question_id": 28648391, "link": "https://stackoverflow.com/questions/28648391/piping-stdout-of-process-to-another-stdout/28649217#28649217", "title": "Piping stdout of Process to another stdout", "body": "<p>Instead of using <code>wait_with_output</code>, just read from the pipes that are part of <code>process</code>. When you can't read anymore, then you can wait for the process. Here's an example with no error handling:</p>\n\n<pre><code>#![feature(old_io)]\n\nuse std::old_io::process::Command;\nuse std::old_io::stdio;\n\nfn main() {\n    let mut process = Command::new(\"bash\")\n        .arg(\"-c\")\n        .arg(\"for i in 1 2 3 4 5; do echo start-$i; sleep 1; echo stop-$i; done\")\n        .spawn()\n        .ok()\n        .expect(\"Command failed\");\n\n    let buf = &amp;mut [0; 256];\n    while let Ok(bytes) = process.stdout.as_mut().unwrap().read(buf) {\n        stdio::stdout_raw().write_all(&amp;buf[..bytes]).unwrap();\n    }\n\n    let _ = process.wait_with_output().ok().expect(\"Download failed.\");\n}\n</code></pre>\n"}], "owner": {"reputation": 1073, "user_id": 2277915, "user_type": "registered", "accept_rate": 39, "profile_image": "https://www.gravatar.com/avatar/e9dba1201139b216bbe3136b06fa2793?s=128&d=identicon&r=PG", "display_name": "Reignbeaux", "link": "https://stackoverflow.com/users/2277915/reignbeaux"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 86, "favorite_count": 0, "accepted_answer_id": 28649217, "answer_count": 1, "score": 2, "last_activity_date": 1424541490, "creation_date": 1424537639, "question_id": 28648391, "link": "https://stackoverflow.com/questions/28648391/piping-stdout-of-process-to-another-stdout", "title": "Piping stdout of Process to another stdout", "body": "<p>I'm trying to start a curl download and then pipe it's stdout to the stdout of my program. Here's what I got (still using old_io):</p>\n\n<pre><code>let process = Command::new(\"curl\")\n    .arg(\"-o \").arg(&amp;self.filename).arg(&amp;self.url)\n    .spawn().ok().expect(\"Download failed.\");\n\nlet output = process.wait_with_output().ok().expect(\"Download failed.\");\n</code></pre>\n\n<p>That works perfectly fine, but the curl download takes quite a long time. So it would be neat to display curl's stdout (=> the progress of the download) while it's still downloading and not just at the end. I tried lot's of things, but can't get this thing working. Any ideas?</p>\n"}, {"tags": ["closures", "rust"], "comments": [{"owner": {"reputation": 4594, "user_id": 1478356, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/996ee463b8f6b17a738f2e23f7ecfe9f?s=128&d=identicon&r=PG", "display_name": "Stefan", "link": "https://stackoverflow.com/users/1478356/stefan"}, "edited": false, "score": 0, "creation_date": 1486991871, "post_id": 28645624, "comment_id": 71571143, "body": "See related question <a href=\"http://stackoverflow.com/questions/30411594/moving-a-boxed-function\" title=\"moving a boxed function\">stackoverflow.com/questions/30411594/moving-a-boxed-function</a>"}], "answers": [{"comments": [{"owner": {"reputation": 28979, "user_id": 266720, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/7c9333e1816aefc7fc97f64b09afe05c?s=128&d=identicon&r=PG", "display_name": "Vi.", "link": "https://stackoverflow.com/users/266720/vi"}, "edited": false, "score": 1, "creation_date": 1473647291, "post_id": 28645697, "comment_id": 66207425, "body": "Note that that answer is probably about legacy Rust. In current Rust it may fail to work."}], "tags": [], "owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "is_accepted": true, "score": 3, "last_activity_date": 1558702358, "last_edit_date": 1558702358, "creation_date": 1424521030, "answer_id": 28645697, "question_id": 28645624, "link": "https://stackoverflow.com/questions/28645624/is-there-any-way-to-have-boxed-and-by-move-closures/28645697#28645697", "title": "Is there any way to have boxed and by-move closures?", "body": "<p>It is possible, but for now you have to do it through the unstable <a href=\"https://doc.rust-lang.org/1.0.0/std/thunk/type.Thunk.html\" rel=\"nofollow noreferrer\"><code>std::thunk::Thunk</code></a>:</p>\n\n<pre><code>use std::thunk::{Invoke, Thunk};\n\nfn closure_user(closure: Thunk&lt;usize, bool&gt;) -&gt; bool {\n    closure.invoke(3)\n}\n\nfn main() {\n    let big_data = vec![1, 2, 3, 4];\n    closure_user(Thunk::with_arg(|x| {\n        let _ = big_data.into_iter();\n        false\n    }));\n}\n</code></pre>\n\n<p>This is due to limitations on the current type system - it's not possible to move out from a trait object - and should be addressed soon. For more information, see the blog post <a href=\"http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/\" rel=\"nofollow noreferrer\">Purging Proc</a>.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1558702285, "creation_date": 1558702285, "answer_id": 56293079, "question_id": 28645624, "link": "https://stackoverflow.com/questions/28645624/is-there-any-way-to-have-boxed-and-by-move-closures/56293079#56293079", "title": "Is there any way to have boxed and by-move closures?", "body": "<p>As of Rust 1.35, this is now possible using your original syntax:</p>\n\n<pre><code>fn closure_user(closure: Box&lt;dyn FnOnce(usize) -&gt; bool&gt;) -&gt; bool {\n    closure(3)\n}\n\nfn main() {\n    let big_data = vec![1, 2, 3, 4];\n    closure_user(Box::new(|x| {\n        let _ = big_data.into_iter();\n        false\n    }));\n}\n</code></pre>\n"}], "owner": {"reputation": 1026, "user_id": 1488940, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/Y8mDh.png?s=128&g=1", "display_name": "Jan \u0160pa\u010dek", "link": "https://stackoverflow.com/users/1488940/jan-%c5%a0pa%c4%8dek"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 509, "favorite_count": 0, "accepted_answer_id": 28645697, "answer_count": 2, "score": 1, "last_activity_date": 1558702358, "creation_date": 1424520575, "last_edit_date": 1558702243, "question_id": 28645624, "link": "https://stackoverflow.com/questions/28645624/is-there-any-way-to-have-boxed-and-by-move-closures", "title": "Is there any way to have boxed and by-move closures?", "body": "<p>I need a closure that captures by-value and is called at most once, but I cannot have the function using the closure monomorphise on every passed closure, because the closures and functions are mutually recursive and the monomorphisation phase fails. I tried something like:</p>\n\n<pre><code>fn closure_user(closure: Box&lt;FnOnce(usize) -&gt; bool&gt;) -&gt; bool {\n    closure(3)\n}\n\nfn main() {\n    let big_data = vec![1, 2, 3, 4];\n    closure_user(Box::new(|x| {\n        let _ = big_data.into_iter();\n        false\n    }));\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0161]: cannot move a value of type dyn std::ops::FnOnce(usize) -&gt; bool: the size of dyn std::ops::FnOnce(usize) -&gt; bool cannot be statically determined\n --&gt; src/main.rs:2:5\n  |\n2 |     closure(3)\n  |     ^^^^^^^\n</code></pre>\n\n<p>The unboxed version is:</p>\n\n<pre><code>fn closure_user&lt;F&gt;(closure: F) -&gt; bool\nwhere\n    F: FnOnce(usize) -&gt; bool,\n{\n    closure(42)\n}\n\nfn main() {\n    let big_data = vec![1, 2, 3, 4];\n    closure_user(|x| {\n        let _ = big_data.into_iter();\n        false\n    });\n}\n</code></pre>\n\n<p>It seems that it is impossible to box and unbox the closure as a <code>FnOnce</code> trait object. Is there any way to have boxed (no type parameter) and by-move (one call only) closures?</p>\n"}, {"tags": ["rust", "hashcode"], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 3, "last_activity_date": 1424513048, "creation_date": 1424513048, "answer_id": 28644507, "question_id": 28644070, "link": "https://stackoverflow.com/questions/28644070/how-can-i-use-a-custom-hash-function-in-a-hashset-or-hashmap/28644507#28644507", "title": "How can I use a custom hash function in a HashSet or HashMap?", "body": "<p>Take a look at the definition of <code>DefaultState</code>:</p>\n\n<pre><code>pub struct DefaultState&lt;H&gt;(marker::PhantomData&lt;H&gt;);\n</code></pre>\n\n<p>You are treating it as though it were as it used to be:</p>\n\n<pre><code>pub struct DefaultState&lt;H&gt;;\n</code></pre>\n\n<p>This change is recent; generic parameters must now be expressly used.</p>\n\n<p>For this you must now use <code>Default::default()</code>, for that field is private, preventing literal expressions from being written. Thus, <code>DefaultState::&lt;FnvHasher&gt;</code> becomes <code>Default::default()</code>.</p>\n\n<p>And once you\u2019re using <code>Default::default()</code> for that, you might as well go the whole hog and replace <code>HashSet::with_hash_state(Default::default())</code> with <code>Default::default()</code>:</p>\n\n<pre><code>let mut set: HashSet&lt;i64, DefaultState&lt;FnvHasher&gt;&gt; = Default::default();\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "is_accepted": false, "score": 4, "last_activity_date": 1462481015, "creation_date": 1462481015, "answer_id": 37059918, "question_id": 28644070, "link": "https://stackoverflow.com/questions/28644070/how-can-i-use-a-custom-hash-function-in-a-hashset-or-hashmap/37059918#37059918", "title": "How can I use a custom hash function in a HashSet or HashMap?", "body": "<p><a href=\"http://blog.rust-lang.org/2016/03/02/Rust-1.7.html\" rel=\"nofollow\">Rust 1.7</a> stabilized the use of custom hashers. For example, you can use <code>FnvHasher</code> from the <a href=\"https://crates.io/crates/fnv\" rel=\"nofollow\">fnv</a> crate</p>\n\n<pre><code>extern crate fnv;\n\nuse std::collections::HashMap;\nuse std::hash::BuildHasherDefault;\nuse fnv::FnvHasher;\n\ntype HashMapFnv&lt;K, V&gt; = HashMap&lt;K, V, BuildHasherDefault&lt;FnvHasher&gt;&gt;;\n\nfn main() {\n    let mut map = HashMapFnv::default();\n    map.insert(1, \"Hello\");\n    map.insert(2, \", world!\");\n    println!(\"{:?}\", map);\n}\n</code></pre>\n"}], "owner": {"reputation": 53, "user_id": 4590785, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ef98f684cd836efde228e22129949737?s=128&d=identicon&r=PG&f=1", "display_name": "KeyZer", "link": "https://stackoverflow.com/users/4590785/keyzer"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2251, "favorite_count": 0, "accepted_answer_id": 28644507, "answer_count": 2, "score": 3, "last_activity_date": 1462481015, "creation_date": 1424510034, "last_edit_date": 1424532738, "question_id": 28644070, "link": "https://stackoverflow.com/questions/28644070/how-can-i-use-a-custom-hash-function-in-a-hashset-or-hashmap", "title": "How can I use a custom hash function in a HashSet or HashMap?", "body": "<p>Since SipHasher is too slow for my use case, I'm trying to implement a custom hash function. I found <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc/util/nodemap.rs\" rel=\"nofollow\">an example</a> which I used as base to get everything compiling.</p>\n\n<p>My current code looks like this:</p>\n\n<pre><code>use std::collections::hash_state::{DefaultState};\nuse std::collections::{HashMap, HashSet};\nuse std::default::Default;\nuse std::hash::{Hash, Hasher, SipHasher};\nuse std::marker;\n\npub struct FnvHasher(u64);\n\nimpl Default for FnvHasher {\n    fn default() -&gt; FnvHasher { FnvHasher(0xcbf29ce484222325) }\n}\n\nimpl Hasher for FnvHasher {\n    fn write(&amp;mut self, bytes: &amp;[u8]) {\n        let FnvHasher(mut hash) = *self;\n        for byte in bytes {\n            hash = hash ^ (*byte as u64);\n            hash = hash * 0x100000001b3;\n        }\n        *self = FnvHasher(hash);\n    }\n    fn finish(&amp;self) -&gt; u64 { self.0 }\n}\n\nfn main() {\n    let mut set:HashSet&lt;i64, DefaultState&lt;FnvHasher&gt;&gt; = HashSet::with_hash_state(DefaultState::&lt;FnvHasher&gt;);\n}\n</code></pre>\n\n<p>When I compile I get the following error message:</p>\n\n<pre><code>$ rustc -V\nrustc 1.0.0-nightly (522d09dfe 2015-02-19) (built 2015-02-19)\n\n$ rustc hash.rs\nhash.rs:26:86: 26:111 error: mismatched types:\n expected `std::collections::hash::state::DefaultState&lt;FnvHasher&gt;`,\n    found `fn(core::marker::PhantomData&lt;FnvHasher&gt;) -&gt; std::collections::hash::state::DefaultState&lt;FnvHasher&gt; {std::collections::hash::state::DefaultState}`\n(expected struct `std::collections::hash::state::DefaultState`,\n    found fn item) [E0308]\nhash.rs:26         let mut set:HashSet&lt;i64, DefaultState&lt;FnvHasher&gt;&gt; = HashSet::with_hash_state(DefaultState::&lt;FnvHasher&gt;);\n                                                                                                ^~~~~~~~~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\n</code></pre>\n\n<p>How can I get the above example to compile or use a custom hash function in a HashSet/HashMap?</p>\n"}, {"tags": ["git", "rust", "zlib"], "answers": [{"comments": [{"owner": {"reputation": 9666, "user_id": 506962, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/72d17716d70c471dead0bd8c6c8e15f8?s=128&d=identicon&r=PG&f=1", "display_name": "J V", "link": "https://stackoverflow.com/users/506962/j-v"}, "edited": false, "score": 0, "creation_date": 1424514524, "post_id": 28641354, "comment_id": 45587397, "body": "A terrible nasty hack is just what the doctor ordered!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1424490420, "last_edit_date": 1424490420, "creation_date": 1424485462, "answer_id": 28641354, "question_id": 28640738, "link": "https://stackoverflow.com/questions/28640738/how-can-i-deflate-zlib-data-and-find-out-how-many-input-bytes-there-were/28641354#28641354", "title": "How can I deflate zlib data and find out how many input bytes there were?", "body": "<p>Normally, you can pass a reference to a Reader / Writer (via <a href=\"http://doc.rust-lang.org/std/old_io/trait.ByRefReader.html\" rel=\"nofollow\"><code>ByRefReader</code></a> or <a href=\"http://doc.rust-lang.org/std/old_io/trait.ByRefWriter.html\" rel=\"nofollow\"><code>ByRefWriter</code></a>)  to allow adding adapters to the stream without losing control of it. Something like this <em>should</em> work:</p>\n\n<pre><code>#![feature(io,path,env)]\n\nextern crate flate2;\n\nuse flate2::CompressionLevel;\nuse flate2::writer::ZlibEncoder;\nuse flate2::reader::ZlibDecoder;\n\nuse std::env;\nuse std::old_io::File;\nuse std::old_io::{ByRefReader,ByRefWriter};\nuse std::old_path::Path;\n\nfn main() {\n    let path = \"./data\";\n    let write = env::var(\"WRITE\").is_ok();\n\n    if write {\n        println!(\"Writing to {}\", path);\n        let mut f = File::create(&amp;Path::new(path)).unwrap();\n\n        fn write_it&lt;W&gt;(w: &amp;mut W, s: &amp;str) where W: Writer {\n            let mut z = ZlibEncoder::new(ByRefWriter::by_ref(w), CompressionLevel::Default);\n            z.write_all(s.as_bytes()).unwrap();\n        }\n\n        write_it(&amp;mut f, \"hello world\");\n        write_it(&amp;mut f, \"goodbye world\");\n    } else {\n        println!(\"Reading from {}\", path);\n        let mut f = File::open(&amp;Path::new(path)).unwrap();\n\n        fn read_it&lt;R&gt;(r: &amp;mut R) -&gt; String where R: Reader {\n            let mut z = ZlibDecoder::new(ByRefReader::by_ref(r));\n            z.read_to_string().unwrap()\n\n        }\n\n        println!(\"{}\", read_it(&amp;mut f));\n        println!(\"{}\", read_it(&amp;mut f));\n    }\n}\n</code></pre>\n\n<p>This <em>does</em> work for writing - I see the Zlib header get repeated twice in the output file. However, it <strong>does not</strong> work when reading. It looks like <code>reader::ZlibDecoder</code> might consume all the way to the end of the underlying <code>Reader</code>. This could potentially be a bug or an oversight in the <code>flate2</code> library. A few minutes of staring at <a href=\"https://github.com/alexcrichton/flate2-rs/blob/6430b38674655039cbe63e5b64320ff9afec45b8/src/raw.rs#L184-L235\" rel=\"nofollow\">the source</a> hasn't shown anything obvious though.</p>\n\n<p><strong>Edit</strong></p>\n\n<p>Here's a terrible hack that \"works\" though:</p>\n\n<pre><code>fn read_it&lt;R&gt;(r: &amp;mut R) -&gt; String where R: Reader {\n    let mut z = ZlibDecoder::new_with_buf(ByRefReader::by_ref(r), Vec::with_capacity(1));\n    z.read_to_string().unwrap()\n}\n\nprintln!(\"{}\", read_it(&amp;mut f));\nf.seek(-1, std::old_io::SeekStyle::SeekCur);\nprintln!(\"{}\", read_it(&amp;mut f));\n</code></pre>\n\n<p>The problem arises because flate2 is <a href=\"https://github.com/alexcrichton/flate2-rs/blob/6430b38674655039cbe63e5b64320ff9afec45b8/src/raw.rs#L196\" rel=\"nofollow\">a bit greedy in how it reads from the reader</a>. It always tries to fill its own internal buffer as much as it can, even if some of that data isn't going to be read. This <em>terrible, nasty</em> hack causes it to only ever read a single byte at a time. Thus, you can rewind one byte at the end and start again.</p>\n\n<p>A longer-term solution is probably to add an accessor for <a href=\"https://github.com/alexcrichton/flate2-rs/blob/6430b38674655039cbe63e5b64320ff9afec45b8/miniz-sys/lib.rs#L28\" rel=\"nofollow\"><code>total_in</code></a> up to <a href=\"https://github.com/alexcrichton/flate2-rs/blob/6430b38674655039cbe63e5b64320ff9afec45b8/src/raw.rs#L155\" rel=\"nofollow\"><code>Stream</code></a> and then up until you get to <code>ZlibDecoder</code>.</p>\n"}], "owner": {"reputation": 9666, "user_id": 506962, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/72d17716d70c471dead0bd8c6c8e15f8?s=128&d=identicon&r=PG&f=1", "display_name": "J V", "link": "https://stackoverflow.com/users/506962/j-v"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 555, "favorite_count": 0, "accepted_answer_id": 28641354, "answer_count": 1, "score": 4, "last_activity_date": 1424532820, "creation_date": 1424479837, "last_edit_date": 1424532820, "question_id": 28640738, "link": "https://stackoverflow.com/questions/28640738/how-can-i-deflate-zlib-data-and-find-out-how-many-input-bytes-there-were", "title": "How can I deflate zlib data and find out how many input bytes there were?", "body": "<p>I'm building a git clone implementation in Rust. I've gotten to the part where I need to parse the packfile to create the index, and I'm almost done parsing it.</p>\n\n<p>Each object in the packfile consists of a header (Which I'm already parsing correctly) followed by the contents which are zlib compressed.</p>\n\n<p>Notably the size stored in the header is the <em>decompressed</em> size, and is therefore larger than the actual data we have to skip to get to the next header.</p>\n\n<p>Crates.io shows 2 crates that do zlib decompression and have more than a few downloads:</p>\n\n<ul>\n<li><code>libz-sys</code>: Is practically a hello world and has been like that for months</li>\n<li><p><code>flate2</code>: This correctly deflates the data with ease:</p>\n\n<pre><code>print!(\"Object type {} size {}\", obj_type as u8, obj_size);\n\nprintln!(\" data:\\n{}\",\n    String::from_utf8(\n        ZlibDecoder::new(data).read_exact(obj_size as usize).unwrap()\n    ).unwrap()\n);\n</code></pre></li>\n</ul>\n\n<p>Here's the problem. After this I need to start reading the next object's header, but <code>ZlibDecoder</code> doesn't give any way to detect how large the <em>input</em> was.</p>\n\n<p>It takes ownership of a reader as it's input, rather than a reference.</p>\n\n<p>Because of this, even though I have the output size of the object (and indeed <em>all</em> the object's data) since I don't know the input size I can't start reading the next object header.</p>\n\n<p>How do I get the amount of compressed input bytes needed to reach the expected output size? If possible, I'd like to avoid using FFI to call native zlib.</p>\n\n<p>PS: the <code>flate2</code> docs suggest a <a href=\"http://alexcrichton.com/flate2-rs/flate2/trait.FlateReader.html\" rel=\"nofollow\">helper trait</a> but I have no idea how or if this would help me</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "edited": false, "score": 0, "creation_date": 1424480994, "post_id": 28640619, "comment_id": 45580734, "body": "Your code at the end of the answer is pretty much what I currently have and what I&#39;m trying to get away from. The reason I want to do this is a bit convoluted, but comes down to the fact that I need to be able to get slices that outlive the <code>Foo</code> that they come from (but not the underlying buffer)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "edited": false, "score": 1, "creation_date": 1424488746, "post_id": 28640619, "comment_id": 45582197, "body": "@fjh I think the key point here is that in the trait, the lifetime has to always have the same &quot;shape&quot; - it can be either the lifetime that the implementor is parameterized on, or it can be the object itself, but it can&#39;t be both. In your example, when <code>Bar</code> dies <i>so does the buffer</i> - the buffer cannot possibly life longer."}, {"owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424519540, "post_id": 28640619, "comment_id": 45588683, "body": "@Shepmaster Yeah, I realise that the reference into <code>Bar</code> can&#39;t outlive the <code>Bar</code> itself, but I was hoping there was a way to get this to work with <code>Foo</code> without making an impl for <code>Bar</code> impossible. I&#39;m sufficiently convinced that this can&#39;t be done now. Bummer, though."}], "tags": [], "owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "is_accepted": true, "score": 4, "last_activity_date": 1424479879, "last_edit_date": 1424479879, "creation_date": 1424479014, "answer_id": 28640619, "question_id": 28640286, "link": "https://stackoverflow.com/questions/28640286/tying-a-trait-lifetime-variable-to-self-lifetime/28640619#28640619", "title": "Tying a trait lifetime variable to &amp;self lifetime", "body": "<blockquote>\n  <p>Tying a trait lifetime variable to &amp;self lifetime</p>\n</blockquote>\n\n<p>Not possible.</p>\n\n<blockquote>\n  <p>Is there any there any reason that this fundamentally cannot be done?</p>\n</blockquote>\n\n<p>Yes. An owning vector is something different than a borrowed slice. Your trait <code>GetRef</code> only makes sense for things that already represent a \u201cloan\u201d and don't own the slice. For an owning type like <code>Bar</code> you can't safely return a borrowed slice that outlives <code>Self</code>. That's what the borrow checker prevents to avoid dangling pointers.</p>\n\n<p>What you tried to do is to link the lifetime parameter to the lifetime of <code>Self</code>. But the lifetime of <code>Self</code> is not a property of its <em>type</em>. It just depends on the scope this value was defined in. And that's why your approach cannot work.</p>\n\n<p>Another way of looking at it is: In a trait you have to be explicit about whether <code>Self</code> is borrowed by a method and its result or not. You defined the <code>GetRef</code> trait to return something that is <em>not</em> linked to <code>Self</code> w.r.t. lifetimes. So, no borrowing. So, it's not implementable for types that own the data. You can't create a borrowed slice referring to a <code>Vec</code>'s elements without borrowing the <code>Vec</code>.</p>\n\n<blockquote>\n  <p>If not, how can I do this?</p>\n</blockquote>\n\n<p>Depends on what exactly you mean by \u201cthis\u201d. If you want to write a \u201ccommon denominator\u201d trait that can be implemented for both borrowed <em>and</em> owning slices, you have to do it like this:</p>\n\n<pre><code>trait GetRef {\n    fn get_ref(&amp;self) -&gt; &amp;[u8];\n}\n</code></pre>\n\n<p>The meaning of this trait is that <code>get_ref</code> <em>borrows</em> <code>Self</code> and returns a kind of \u201cloan\u201d because of the current lifetime elision rules. It's equivalent to the more explicit form</p>\n\n<pre><code>trait GetRef {\n    fn get_ref&lt;'s&gt;(&amp;self) -&gt; &amp;'s [u8];\n}\n</code></pre>\n\n<p>It can be implemented for both types now:</p>\n\n<pre><code>impl&lt;'a&gt; GetRef for Foo&lt;'a&gt; {\n    fn get_ref(&amp;self) -&gt; &amp;[u8] { &amp;self.buf[1..] }\n}\n\nimpl GetRef for Bar {\n    fn get_ref(&amp;self) -&gt; &amp;[u8] { &amp;self.buf[1..] }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 499, "user_id": 4867446, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh3.googleusercontent.com/-sp2oLGjecIA/AAAAAAAAAAI/AAAAAAAAAIA/41wEvRe4avs/photo.jpg?sz=128", "display_name": "Slava Baginov", "link": "https://stackoverflow.com/users/4867446/slava-baginov"}, "is_accepted": false, "score": 0, "last_activity_date": 1432135971, "creation_date": 1432135971, "answer_id": 30354173, "question_id": 28640286, "link": "https://stackoverflow.com/questions/28640286/tying-a-trait-lifetime-variable-to-self-lifetime/30354173#30354173", "title": "Tying a trait lifetime variable to &amp;self lifetime", "body": "<p>You could make different lifetimes for &amp;self and result in your trait like that:</p>\n\n<pre><code>trait GetRef&lt;'a, 'b&gt; {\n    fn get_ref(&amp;'b self) -&gt; &amp;'a [u8];\n}\n\nstruct Foo&lt;'a&gt; {\n    buf: &amp;'a [u8]\n}\n\nimpl &lt;'a, 'b&gt; GetRef&lt;'a, 'b&gt; for Foo&lt;'a&gt; {\n    fn get_ref(&amp;'b self) -&gt; &amp;'a [u8] {\n        &amp;self.buf[1..]\n    }\n}\n\nstruct Bar {\n    buf: Vec&lt;u8&gt;\n}\n\n// Bar, however, cannot contain anything that outlives itself\nimpl&lt;'a&gt; GetRef&lt;'a, 'a&gt; for Bar {\n    fn get_ref(&amp;'a self) -&gt; &amp;'a [u8] {\n        &amp;self.buf[1..]\n    }\n}\n\n\nfn main() {\n    let a = vec!(1 as u8, 2, 3);\n    let b = a.clone();\n    let tmp;\n    {\n        let x = Foo{buf: &amp;a};\n        tmp = x.get_ref();\n    }\n    {\n        let y = Bar{buf: b};\n        // Bar's buf cannot outlive Bar\n        // tmp = y.get_ref();\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 109, "favorite_count": 0, "accepted_answer_id": 28640619, "answer_count": 2, "score": 2, "last_activity_date": 1432135971, "creation_date": 1424476878, "question_id": 28640286, "link": "https://stackoverflow.com/questions/28640286/tying-a-trait-lifetime-variable-to-self-lifetime", "title": "Tying a trait lifetime variable to &amp;self lifetime", "body": "<p>I'd like to do something along the following lines:</p>\n\n<pre><code>trait GetRef&lt;'a&gt; {\n    fn get_ref(&amp;self) -&gt; &amp;'a [u8];\n}\n\nstruct Foo&lt;'a&gt; {\n    buf: &amp;'a [u8]\n}\n\nimpl &lt;'a&gt; GetRef&lt;'a&gt; for Foo&lt;'a&gt; {\n    fn get_ref(&amp;self) -&gt; &amp;'a [u8] {\n        &amp;self.buf[1..]\n    }\n}\n\nstruct Bar {\n    buf: Vec&lt;u8&gt;\n}\n\n// this is the part I'm struggling with:\nimpl &lt;'a&gt; GetRef&lt;'a&gt; for Bar {\n    fn get_ref(&amp;'a self) -&gt; &amp;'a [u8] {\n        &amp;self.buf[1..]\n}\n</code></pre>\n\n<p>The point of the explicit lifetime variable in the <code>GetRef</code> trait is to allow the return value of <code>get_ref()</code> on a <code>Foo</code> object to outlive the <code>Foo</code> itself, tying the return value's lifetime to that of the lifetime of <code>Foo</code>'s buffer.</p>\n\n<p>However, I haven't found a way to implement <code>GetRef</code> for <code>Bar</code> in a way that the compiler accepts. I've tried several variations of the above, but can't seem to find one that works. Is there any there any reason that this fundamentally cannot be done? If not, how can I do this?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1424470290, "post_id": 28639012, "comment_id": 45577640, "body": "Casting isn&#39;t allowed to fail, but this has an inherent failure mode - what happens when the number isn&#39;t one of your enum values?"}, {"owner": {"reputation": 9666, "user_id": 506962, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/72d17716d70c471dead0bd8c6c8e15f8?s=128&d=identicon&r=PG&f=1", "display_name": "J V", "link": "https://stackoverflow.com/users/506962/j-v"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424470399, "post_id": 28639012, "comment_id": 45577678, "body": "Your duplicate link was exactly right"}], "owner": {"reputation": 9666, "user_id": 506962, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/72d17716d70c471dead0bd8c6c8e15f8?s=128&d=identicon&r=PG&f=1", "display_name": "J V", "link": "https://stackoverflow.com/users/506962/j-v"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 376, "favorite_count": 0, "closed_date": 1424490331, "answer_count": 0, "score": 0, "last_activity_date": 1424469792, "creation_date": 1424469792, "question_id": 28639012, "link": "https://stackoverflow.com/questions/28639012/cast-integer-to-c-like-enum-in-rust", "closed_reason": "Duplicate", "title": "Cast integer to C-like enum in rust", "body": "<p>Is it possible to cast an int to a C-like enum in rust? It's possible to cast from the enum to the int but I'd like to do it the other way too.</p>\n\n<pre><code>enum Type {\n    FIRST = 1,\n    SECOND = 2,\n    THIRD = 3,\n}\n\nfn main() {\n    let x = 3u8 as Type;\n    println!(\"{}\", x as u8);\n}\n</code></pre>\n\n<p>Results in an error trying to cast to <code>Type</code>:</p>\n\n<pre><code>main.rs:8:13: 8:24 error: non-scalar cast: `u8` as `Type`\nmain.rs:8     let x = 3u8 as Type;\n                      ^~~~~~~~~~~\nerror: aborting due to previous error\n</code></pre>\n"}, {"tags": ["recursion", "enums", "rust"], "answers": [{"comments": [{"owner": {"reputation": 257, "user_id": 2941479, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/dd46f4098ac6f84161a5c9e1f8b03754?s=128&d=identicon&r=PG", "display_name": "MicroJoe", "link": "https://stackoverflow.com/users/2941479/microjoe"}, "edited": false, "score": 0, "creation_date": 1424471111, "post_id": 28639004, "comment_id": 45577963, "body": "The Item::Nil case may not be matched alot since this value will just do nothing to the list and so may not be passed to the function. However we still have to create two new items instead of modifying the first one in order to avoid some alloc/free."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1529949998, "last_edit_date": 1529949998, "creation_date": 1424469763, "answer_id": 28639004, "question_id": 28638757, "link": "https://stackoverflow.com/questions/28638757/use-of-collaterally-moved-value-error-on-a-recursive-enum/28639004#28639004", "title": "Use of collaterally moved value error on a recursive enum", "body": "<p>You may be suffering from <a href=\"https://github.com/rust-lang/rust/issues/16223\" rel=\"nofollow noreferrer\">issue 16223</a> (see also <a href=\"https://github.com/rust-lang/rust/issues/22205\" rel=\"nofollow noreferrer\">22205</a> which has a closer reproduction), although today's non-lexical lifetimes don't solve this problem. This seems to preclude destructuring multiple things through a <code>Box</code>. </p>\n\n<p>Here's one way to work around it, although it's not the <em>most</em> efficient way as it deallocates and reallocates unnecessarily:</p>\n\n<pre><code>#[derive(Debug)]\npub enum Item&lt;T&gt; {\n    Cons(T, Box&lt;Item&lt;T&gt;&gt;),\n    Nil,\n}\n\npub fn add_after&lt;T&gt;(it: Box&lt;Item&lt;T&gt;&gt;, val: T) -&gt; Box&lt;Item&lt;T&gt;&gt; {\n    match { *it } {\n        Item::Nil =&gt; Box::new(Item::Nil),\n        Item::Cons(a, b) =&gt; {\n            let itm = Box::new(Item::Cons(val, b));\n            Box::new(Item::Cons(a, itm))\n        }\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>A more verbose way pulls the value out of the <code>Box</code>, manipulates <em>that</em>, and then puts the manipulated value back into the <code>Box</code>. This should have a reduced amount of allocations:</p>\n\n<pre><code>use std::mem;\n\npub fn add_after&lt;T&gt;(mut item: Box&lt;Item&lt;T&gt;&gt;, val: T) -&gt; Box&lt;Item&lt;T&gt;&gt; {\n    let unboxed_value = mem::replace(&amp;mut *item, Item::Nil);\n\n    match unboxed_value {\n        Item::Nil =&gt; item,\n        Item::Cons(a, b) =&gt; {\n            let itm = Box::new(Item::Cons(val, b));\n            *item = Item::Cons(a, itm);\n            item\n        }\n    }\n}\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/28466809/155423\">Collaterally moved error when deconstructing a Box of pairs</a></li>\n</ul>\n"}], "owner": {"reputation": 257, "user_id": 2941479, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/dd46f4098ac6f84161a5c9e1f8b03754?s=128&d=identicon&r=PG", "display_name": "MicroJoe", "link": "https://stackoverflow.com/users/2941479/microjoe"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 266, "favorite_count": 0, "accepted_answer_id": 28639004, "answer_count": 1, "score": 2, "last_activity_date": 1529949998, "creation_date": 1424468683, "last_edit_date": 1529530976, "question_id": 28638757, "link": "https://stackoverflow.com/questions/28638757/use-of-collaterally-moved-value-error-on-a-recursive-enum", "title": "Use of collaterally moved value error on a recursive enum", "body": "<p>I have a recursive <code>Item</code> structure that I am using to implement lists:</p>\n\n<pre><code>#[derive(Debug)]\npub enum Item&lt;T&gt; {\n    Cons(T, Box&lt;Item&lt;T&gt;&gt;),\n    Nil,\n}\n</code></pre>\n\n<p>When implementing a function that inserts an element after another one, I found out that the Rust compiler wasn't that happy about my code:</p>\n\n<pre><code>pub fn add_after&lt;T&gt;(it: Box&lt;Item&lt;T&gt;&gt;, val: T) -&gt; Box&lt;Item&lt;T&gt;&gt; {\n    match *it {\n        Item::Nil =&gt; return it,\n        Item::Cons(a, b) =&gt; {\n            let itm = Box::new(Item::Cons(val, b));\n            return Box::new(Item::Cons(a, itm));\n        }\n    }\n}\n</code></pre>\n\n<p>The errors that I get are pretty obscure for a newbie:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of collaterally moved value: `(it as Item::Cons).1`\n  --&gt; src/main.rs:12:23\n   |\n12 |         Item::Cons(a, b) =&gt; {\n   |                    -  ^ value used here after move\n   |                    |\n   |                    value moved here\n   |\n   = note: move occurs because the value has type `T`, which does not implement the `Copy` trait\n</code></pre>\n\n<p><a href=\"https://stackoverflow.com/questions/28466809/collaterally-moved-error-on-deconstructing-box-of-pairs\">Another similar question</a> suggested to do the unwrapping phase in two steps but it cannot be used here because we need to directly unwrap a two-fields <code>Cons(..)</code> item and not nested items like <code>Option&lt;Box&lt;Whatever&gt;&gt;</code> where the two-phase trick can be applied. Example of what I tried:</p>\n\n<pre><code>pub fn add_after&lt;T&gt;(it: Box&lt;Item&lt;T&gt;&gt;, val: T) -&gt; Box&lt;Item&lt;T&gt;&gt; {\n    match *it {\n        Item::Nil =&gt; return it,\n        Item::Cons(..) =&gt; {\n            let Item::Cons(a, b) = *it;\n            let itm = Box::new(Item::Cons(val, b));\n            return Box::new(Item::Cons(a, itm));\n        }\n    }\n}\n</code></pre>\n\n<p>But I get another error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0005]: refutable pattern in local binding: `Nil` not covered\n  --&gt; src/main.rs:13:17\n   |\n13 |             let Item::Cons(a, b) = *it;\n   |                 ^^^^^^^^^^^^^^^^ pattern `Nil` not covered\n</code></pre>\n\n<p>Though I am pretty sure here that this is exhaustive at this point because we matched a <code>Cons</code> before.</p>\n"}, {"tags": ["oop", "rust", "language-design", "liskov-substitution-principle"], "comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 15, "creation_date": 1424449424, "post_id": 28632968, "comment_id": 45567134, "body": "As a side note: Rust is not object-oriented language. Traits are not interfaces, they are more like type classes from Haskell. Rust also does not have subtyping, so LSP is somewhat inapplicable to it because its definition is tied to the subtyping relationship."}, {"owner": {"reputation": 3943, "user_id": 403742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a75da0019ec1c94350b0c334d2269823?s=128&d=identicon&r=PG", "display_name": "kFYatek", "link": "https://stackoverflow.com/users/403742/kfyatek"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 8, "creation_date": 1424450234, "post_id": 28632968, "comment_id": 45567622, "body": "Still, as I said, Rust supports a lot of OO-style abstractions, and traits are allowed to inherit, forming something akin to a type hierarchy. For me, it would seem natural to support LSP for trait objects, even if OO isn&#39;t the main paradigm of the language."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1425345739, "post_id": 28632968, "comment_id": 45916506, "body": "Please make sure to upvote useful answers and mark an answer as accepted if it solved your problem! If no answer is acceptable, consider leaving comments explaining why, or edit your question to phrase the problem differently."}, {"owner": {"reputation": 1436, "user_id": 406309, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/25f8ea5948e459788767ca9b08aee824?s=128&d=identicon&r=PG", "display_name": "Jim Blandy", "link": "https://stackoverflow.com/users/406309/jim-blandy"}, "edited": false, "score": 1, "creation_date": 1425661661, "post_id": 28632968, "comment_id": 46067172, "body": "There&#39;s a Rust issue for this question: <a href=\"https://github.com/rust-lang/rust/issues/5665\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/5665</a> (which I see you&#39;ve already found; just placing a link to it here.)"}], "answers": [{"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 20, "last_activity_date": 1525174122, "last_edit_date": 1525174122, "creation_date": 1424450348, "answer_id": 28633889, "question_id": 28632968, "link": "https://stackoverflow.com/questions/28632968/why-doesnt-rust-support-trait-object-upcasting/28633889#28633889", "title": "Why doesn&#39;t Rust support trait object upcasting?", "body": "<p>I ran into the same wall when I started with Rust.\nNow, when I think about traits, I have a different image in mind than when I think about classes.</p>\n\n<p><code>trait X: Y {}</code> means when you implement trait <code>X</code> for struct <code>S</code> you also <strong>need</strong> to implement trait <code>Y</code> for <code>S</code>.</p>\n\n<p>Of course this means that a <code>&amp;X</code> knows it also is a <code>&amp;Y</code>, and therefore offers the appropriate functions.\nIt would require some runtime-effort (more pointer dereferences) if you needed to traverse pointers to <code>Y</code>'s vtable first.</p>\n\n<p>Then again, the current design + additional pointers to other vtables probably wouldn't hurt much, and would allow easy casting to be implemented. So maybe we need both? This is something to be discussed on <a href=\"http://internals.rust-lang.org\" rel=\"nofollow noreferrer\">internals.rust-lang.org</a></p>\n"}, {"comments": [{"owner": {"reputation": 944, "user_id": 817019, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/xhltk.jpg?s=128&g=1", "display_name": "snuk182", "link": "https://stackoverflow.com/users/817019/snuk182"}, "edited": false, "score": 0, "creation_date": 1516095785, "post_id": 28664881, "comment_id": 83539737, "body": "Unfortunately the usage area of this <code>impl Trait</code> approach is somewhat narrow, if a complex trait architecture is used. <a href=\"http://play.integer32.com/?gist=bbe93906ddab1beaa34eb33e11eda41a&amp;version=nightly\" rel=\"nofollow noreferrer\">play.integer32.com/&hellip;</a>   Without the possibility of elimination of the intersecting implementations (i.e. <code>impl &lt;T: AsBranchOne + !AsBranchTwo&gt;</code>) it is required to install the <code>as_*()</code> methods directly into the nesting trait to prevent conflicts."}, {"owner": {"reputation": 507143, "user_id": 1048572, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/7f2c4de95e8f4f8f5a71c3aaf0ed312a?s=128&d=identicon&r=PG", "display_name": "Bergi", "link": "https://stackoverflow.com/users/1048572/bergi"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1531228366, "post_id": 28664881, "comment_id": 89510349, "body": "@Shepmaster Should this be <code>AsRef&lt;Base&gt;</code> in today&#39;s Rust?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 507143, "user_id": 1048572, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/7f2c4de95e8f4f8f5a71c3aaf0ed312a?s=128&d=identicon&r=PG", "display_name": "Bergi", "link": "https://stackoverflow.com/users/1048572/bergi"}, "edited": false, "score": 1, "creation_date": 1531275885, "post_id": 28664881, "comment_id": 89530545, "body": "@Bergi <code>AsRef</code> has been available since Rust 1.0, but I&#39;m not sure if you can use it here or not. Some <a href=\"https://play.rust-lang.org/?gist=286334f687256c767cee13088f93f305&amp;version=stable&amp;mode=debug&amp;edition=2015\" rel=\"nofollow noreferrer\">quick attempts</a> show various errors."}, {"owner": {"reputation": 2787, "user_id": 116931, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3b066d41a244c1b25bed1f53d0e2b122?s=128&d=identicon&r=PG", "display_name": "Chris Suter", "link": "https://stackoverflow.com/users/116931/chris-suter"}, "edited": false, "score": 2, "creation_date": 1584154745, "post_id": 28664881, "comment_id": 107357306, "body": "&quot;One may add additional methods for casting a &amp;mut pointer or a Box&quot; \u2014 could you provide an example for the Box case? It&#39;s not clear to me how you make it work in that case without using unsafe."}, {"owner": {"reputation": 30359, "user_id": 255688, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/74b63650ed07d745fd9accf52e4d286b?s=128&d=identicon&r=PG", "display_name": "phimuemue", "link": "https://stackoverflow.com/users/255688/phimuemue"}, "edited": false, "score": 1, "creation_date": 1585416004, "post_id": 28664881, "comment_id": 107752610, "body": "@kFYatek I have a similar approach in my codebase, but I struggle to get it working with <code>Box</code>. Have you been successfully doing it already?"}, {"owner": {"reputation": 5195, "user_id": 1407170, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/5f68a1372394960905ad730bab83bc06?s=128&d=identicon&r=PG", "display_name": "sffc", "link": "https://stackoverflow.com/users/1407170/sffc"}, "edited": false, "score": 0, "creation_date": 1588748775, "post_id": 28664881, "comment_id": 109014168, "body": "The crate <code>downcast-rs</code> implements the above pattern for upcasting to Any, which then allows for downcasting to a concrete type. It also supports <code>Box</code>. <a href=\"https://crates.io/crates/downcast-rs\" rel=\"nofollow noreferrer\">crates.io/crates/downcast-rs</a>"}], "tags": [], "owner": {"reputation": 3943, "user_id": 403742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a75da0019ec1c94350b0c334d2269823?s=128&d=identicon&r=PG", "display_name": "kFYatek", "link": "https://stackoverflow.com/users/403742/kfyatek"}, "is_accepted": false, "score": 54, "last_activity_date": 1524581915, "last_edit_date": 1524581915, "creation_date": 1424648968, "answer_id": 28664881, "question_id": 28632968, "link": "https://stackoverflow.com/questions/28632968/why-doesnt-rust-support-trait-object-upcasting/28664881#28664881", "title": "Why doesn&#39;t Rust support trait object upcasting?", "body": "<p>Actually, I think I got the reason. I found an elegant way to add upcasting support to any trait that desires it, and that way the programmer is able to choose whether to add that additional vtable entry to the trait, or prefer not to, which is a similar trade-off as in C++'s virtual vs. non-virtual methods: elegance and model correctness vs. performance.</p>\n\n<p>The code can be implemented as follows:</p>\n\n<pre><code>trait Base: AsBase {\n    // ...\n}\n\ntrait AsBase {\n    fn as_base(&amp;self) -&gt; &amp;Base;\n}\n\nimpl&lt;T: Base&gt; AsBase for T {\n    fn as_base(&amp;self) -&gt; &amp;Base {\n        self\n    }\n}\n</code></pre>\n\n<p>One may add additional methods for casting a <code>&amp;mut</code> pointer or a <code>Box</code> (that adds a requirement that <code>T</code> must be a <code>'static</code> type), but this is a general idea. This allows for safe and simple (although not implicit) upcasting of every derived type without boilerplate for every derived type.</p>\n"}, {"tags": [], "owner": {"reputation": 2645, "user_id": 5254193, "user_type": "registered", "profile_image": "https://lh5.googleusercontent.com/-PTHapBqhSQM/AAAAAAAAAAI/AAAAAAAABA4/r5mrExVuDgU/photo.jpg?sz=128", "display_name": "Masaki Hara", "link": "https://stackoverflow.com/users/5254193/masaki-hara"}, "is_accepted": false, "score": 25, "last_activity_date": 1497430410, "creation_date": 1497430410, "answer_id": 44539994, "question_id": 28632968, "link": "https://stackoverflow.com/questions/28632968/why-doesnt-rust-support-trait-object-upcasting/44539994#44539994", "title": "Why doesn&#39;t Rust support trait object upcasting?", "body": "<p>As of Jun 2017, the status of this \"sub-trait coercion\" (or \"super-trait coercion\") is as follows:</p>\n\n<ul>\n<li>An accepted RFC <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\" rel=\"noreferrer\">#0401</a> mentions this as a part of coercion. So this conversion should be done implicitly.\n\n<blockquote>\n  <p>coerce_inner(<code>T</code>) = <code>U</code> where <code>T</code> is a sub-trait of <code>U</code>;</p>\n</blockquote></li>\n<li>However, this is not yet implemented. There is a corresponding issue <a href=\"https://github.com/rust-lang/rust/issues/18600\" rel=\"noreferrer\">#18600</a>.</li>\n</ul>\n\n<p>There is also a duplicate issue <a href=\"https://github.com/rust-lang/rust/issues/5665\" rel=\"noreferrer\">#5665</a>. Comments there explain what prevent this from being implemented.</p>\n\n<ul>\n<li>Basically, the problem is how to derive vtables for super-traits. Current layout of vtables is as follows (in x86-64 case):\n\n<pre>+-----+-------------------------------+\n| 0- 7|pointer to \"drop glue\" function|\n+-----+-------------------------------+\n| 8-15|size of the data               |\n+-----+-------------------------------+\n|16-23|alignment of the data          |\n+-----+-------------------------------+\n|24-  |methods of Self and supertraits|\n+-----+-------------------------------+\n</pre>\n\nIt doesn't contain a vtable for a super-trait as a subsequence. We have at least to have some tweaks with vtables.</li>\n<li>Of course there are ways to mitigate this problem, but many with differing advantages/disadvantages! One has a benefit for the vtable size when there is a diamond inheritance. Another is supposed to be faster.</li>\n</ul>\n\n<p>There <a href=\"https://github.com/typelist\" rel=\"noreferrer\">@typelist</a> says they prepared <a href=\"https://github.com/typelist/rfcs/blob/upcast/text/0000-trait-upcasting.md\" rel=\"noreferrer\">a draft RFC</a> which looks well-organized, but they look like disappeared after that (Nov 2016).</p>\n"}], "owner": {"reputation": 3943, "user_id": 403742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a75da0019ec1c94350b0c334d2269823?s=128&d=identicon&r=PG", "display_name": "kFYatek", "link": "https://stackoverflow.com/users/403742/kfyatek"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 10712, "favorite_count": 9, "answer_count": 3, "score": 52, "last_activity_date": 1525174122, "creation_date": 1424447389, "last_edit_date": 1524581847, "question_id": 28632968, "link": "https://stackoverflow.com/questions/28632968/why-doesnt-rust-support-trait-object-upcasting", "title": "Why doesn&#39;t Rust support trait object upcasting?", "body": "<p>Given this code:</p>\n\n<pre><code>trait Base {\n    fn a(&amp;self);\n    fn b(&amp;self);\n    fn c(&amp;self);\n    fn d(&amp;self);\n}\n\ntrait Derived : Base {\n    fn e(&amp;self);\n    fn f(&amp;self);\n    fn g(&amp;self);\n}\n\nstruct S;\n\nimpl Derived for S {\n    fn e(&amp;self) {}\n    fn f(&amp;self) {}\n    fn g(&amp;self) {}\n}\n\nimpl Base for S {\n    fn a(&amp;self) {}\n    fn b(&amp;self) {}\n    fn c(&amp;self) {}\n    fn d(&amp;self) {}\n}\n</code></pre>\n\n<p>Unfortunately, I cannot cast <code>&amp;Derived</code> to <code>&amp;Base</code>:</p>\n\n<pre><code>fn example(v: &amp;Derived) {\n    v as &amp;Base;\n}\n</code></pre>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0605]: non-primitive cast: `&amp;Derived` as `&amp;Base`\n  --&gt; src/main.rs:30:5\n   |\n30 |     v as &amp;Base;\n   |     ^^^^^^^^^^\n   |\n   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n</code></pre>\n\n<p>Why is that? The <code>Derived</code> vtable has to reference the <code>Base</code> methods in one way or another.</p>\n\n<hr>\n\n<p>Inspecting the LLVM IR reveals the following:</p>\n\n<pre><code>@vtable4 = internal unnamed_addr constant {\n    void (i8*)*,\n    i64,\n    i64,\n    void (%struct.S*)*,\n    void (%struct.S*)*,\n    void (%struct.S*)*,\n    void (%struct.S*)*\n} {\n    void (i8*)* @_ZN2i813glue_drop.98717h857b3af62872ffacE,\n    i64 0,\n    i64 1,\n    void (%struct.S*)* @_ZN6S.Base1a20h57ba36716de00921jbaE,\n    void (%struct.S*)* @_ZN6S.Base1b20h3d50ba92e362d050pbaE,\n    void (%struct.S*)* @_ZN6S.Base1c20h794e6e72e0a45cc2vbaE,\n    void (%struct.S*)* @_ZN6S.Base1d20hda31e564669a8cdaBbaE\n}\n\n@vtable26 = internal unnamed_addr constant {\n    void (i8*)*,\n    i64,\n    i64,\n    void (%struct.S*)*,\n    void (%struct.S*)*,\n    void (%struct.S*)*,\n    void (%struct.S*)*,\n    void (%struct.S*)*,\n    void (%struct.S*)*,\n    void (%struct.S*)*\n} {\n    void (i8*)* @_ZN2i813glue_drop.98717h857b3af62872ffacE,\n    i64 0,\n    i64 1,\n    void (%struct.S*)* @_ZN9S.Derived1e20h9992ddd0854253d1WaaE,\n    void (%struct.S*)* @_ZN9S.Derived1f20h849d0c78b0615f092aaE,\n    void (%struct.S*)* @_ZN9S.Derived1g20hae95d0f1a38ed23b8aaE,\n    void (%struct.S*)* @_ZN6S.Base1a20h57ba36716de00921jbaE,\n    void (%struct.S*)* @_ZN6S.Base1b20h3d50ba92e362d050pbaE,\n    void (%struct.S*)* @_ZN6S.Base1c20h794e6e72e0a45cc2vbaE,\n    void (%struct.S*)* @_ZN6S.Base1d20hda31e564669a8cdaBbaE\n}\n</code></pre>\n\n<p>All Rust vtables contain a pointer to the destructor, size and alignment in the first fields, and the subtrait vtables don't duplicate them when referencing supertrait methods, nor use indirect reference to supertrait vtables. They just have copies of the method pointers verbatim and nothing else.</p>\n\n<p>Given that design, it's easy to understand why this does not work. A new vtable would need to be constructed at runtime, which would likely reside on the stack, and that isn't exactly an elegant (or optimal) solution.</p>\n\n<p>There are some workarounds, of course, like adding explicit upcast methods to the interface, but that requires quite a bit of boilerplate (or macro frenzy) to work properly.</p>\n\n<p>Now, the question is - why isn't it implemented in some way that would enable trait object upcasting? Like, adding a pointer to the supertrait's vtable in the subtrait's vtable. For now, Rust's dynamic dispatch doesn't seem to satisfy the <a href=\"http://en.wikipedia.org/wiki/Liskov_substitution_principle\" rel=\"noreferrer\">Liskov substitution principle</a>, which is a very basic principle for object-oriented design.</p>\n\n<p>Of course you can use static dispatch, which is indeed very elegant to use in Rust, but it easily leads to code bloat which is sometimes more important than computational performance - like on embedded systems, and Rust developers claim to support such use cases of the language. Also, in many cases you can successfully use a model which is not purely Object-Oriented, which seems to be encouraged by Rust's functional design. Still, Rust supports many of the useful OO patterns... so why not the LSP?</p>\n\n<p>Does anyone know the rationale for such design?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1424446964, "creation_date": 1424446964, "answer_id": 28632823, "question_id": 28632698, "link": "https://stackoverflow.com/questions/28632698/using-functions-defined-in-primitive-modules/28632823#28632823", "title": "Using functions defined in primitive modules", "body": "<p>The trick here is that <code>from_str</code> is actually part of the trait <a href=\"http://doc.rust-lang.org/std/str/trait.FromStr.html\"><code>FromStr</code></a>. You need to use that trait, then specify which implementation you want to use:</p>\n\n<pre><code>use std::str::FromStr;\n\nfn main() {\n    match &lt;u8 as FromStr&gt;::from_str(\"89\") {\n        // Stuff...\n    }\n}\n</code></pre>\n\n<p>However, this particular concept has a more ergonomic option: <a href=\"http://doc.rust-lang.org/std/str/trait.StrExt.html#tymethod.parse\"><code>parse</code></a>:</p>\n\n<pre><code>fn main() {\n    match \"89\".parse::&lt;u8&gt;() {\n        // Stuff...\n    }\n}\n</code></pre>\n\n<p>And you might be able to remove the <code>::&lt;u8&gt;</code> if something else constrains the type enough for it to be inferred.</p>\n"}], "owner": {"reputation": 2628, "user_id": 1366913, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/bcd760432e7ba71d5f0c71350886456f?s=128&d=identicon&r=PG", "display_name": "nathansizemore", "link": "https://stackoverflow.com/users/1366913/nathansizemore"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 150, "favorite_count": 0, "accepted_answer_id": 28632823, "answer_count": 1, "score": 0, "last_activity_date": 1424446964, "creation_date": 1424446652, "question_id": 28632698, "link": "https://stackoverflow.com/questions/28632698/using-functions-defined-in-primitive-modules", "title": "Using functions defined in primitive modules", "body": "<p>I'd like to make use of this function: </p>\n\n<p><a href=\"http://doc.rust-lang.org/std/primitive.u8.html#method.from_str\" rel=\"nofollow\"><code>u8::from_str(src: &amp;str) -&gt; Result&lt;u8, ParseIntError&gt;</code></a></p>\n\n<p>I can't seem to figure out the syntax to use it.  This is what I am currently trying</p>\n\n<pre><code>use std::u8;\n\nmatch u8::from_str(\"89\") {\n    // Stuff...\n}\n</code></pre>\n\n<p>I receive the following error:</p>\n\n<pre><code>error: unresolved name `u8::from_str`\n</code></pre>\n\n<p>What is the proper way to use functions that are defined in primitive modules?</p>\n\n<p>Thanks in advance for any help!</p>\n"}, {"tags": ["closures", "rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 4208, "user_id": 2343847, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/cf8c5e3c346c7734cb1ff728264f6cfb?s=128&d=identicon&r=PG", "display_name": "aij", "link": "https://stackoverflow.com/users/2343847/aij"}, "edited": false, "score": 0, "creation_date": 1435889072, "post_id": 28628078, "comment_id": 50398907, "body": "Would you mind explaining the meaning of the error in more detail? I&#39;m seeing a similar error (except without using any closures/lambdas), and it&#39;s not making a whole lot of sense to me. What makes it so that the lifetime cannot outlive an expression?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 4208, "user_id": 2343847, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/cf8c5e3c346c7734cb1ff728264f6cfb?s=128&d=identicon&r=PG", "display_name": "aij", "link": "https://stackoverflow.com/users/2343847/aij"}, "edited": false, "score": 0, "creation_date": 1435906001, "post_id": 28628078, "comment_id": 50403671, "body": "usually that is because the object you are referencing would go out of scope before your reference does, which would allow use-after-free which is undefined behavior"}, {"owner": {"reputation": 4208, "user_id": 2343847, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/cf8c5e3c346c7734cb1ff728264f6cfb?s=128&d=identicon&r=PG", "display_name": "aij", "link": "https://stackoverflow.com/users/2343847/aij"}, "edited": false, "score": 0, "creation_date": 1436021417, "post_id": 28628078, "comment_id": 50443727, "body": "It&#39;s the &quot;first, the lifetime cannot outlive&quot; part that I find more perplexing."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 3, "last_activity_date": 1424432306, "creation_date": 1424432306, "answer_id": 28628078, "question_id": 28627673, "link": "https://stackoverflow.com/questions/28627673/closure-as-function-parameter-cannot-infer-an-appropriate-lifetime-due-to-confl/28628078#28628078", "title": "Closure as function parameter &quot;cannot infer an appropriate lifetime due to conflicting requirements&quot;", "body": "<p>if you want to use a boxed closure you need to use <code>move || {}</code>.</p>\n\n<pre><code>fn foo(f: Box&lt;Fn() -&gt; bool&gt;)\n       -&gt; bool {\n    f()\n}\n\nfn main() {\n    let bar = 42;\n    let blub = foo(Box::new(move || bar != 42));\n}\n</code></pre>\n\n<p>On the other hand, you cannot use an unboxed closure directly, as it may contain any number of captured elements, and is therefor unsized. By using generics you can easily circumvent this limitation:</p>\n\n<pre><code>fn foo&lt;T&gt;(f: T)\n          -&gt; bool\n          where T : Fn() -&gt; bool {\n    f()\n}\n\nfn main() {\n    let bar = 42;\n    let blub = foo(|| bar != 42);\n}\n</code></pre>\n"}], "owner": {"reputation": 880, "user_id": 936452, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/e638ec650e482fae0777c837cb4fed75?s=128&d=identicon&r=PG", "display_name": "Co_42", "link": "https://stackoverflow.com/users/936452/co-42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 733, "favorite_count": 0, "accepted_answer_id": 28628078, "answer_count": 1, "score": 0, "last_activity_date": 1424442672, "creation_date": 1424430944, "last_edit_date": 1424442672, "question_id": 28627673, "link": "https://stackoverflow.com/questions/28627673/closure-as-function-parameter-cannot-infer-an-appropriate-lifetime-due-to-confl", "title": "Closure as function parameter &quot;cannot infer an appropriate lifetime due to conflicting requirements&quot;", "body": "<p>I am trying to use a closure as function parameter:</p>\n\n<pre><code>fn foo(f: Box&lt;Fn() -&gt; bool&gt;) -&gt; bool {\n    f()\n}\n\nfn main() {\n    let bar = 42;\n    foo(Box::new(|| bar != 42));\n}\n</code></pre>\n\n<p>but I get this lifetime error:</p>\n\n<pre><code>src/main.rs:7:24: 7:36 error: cannot infer an appropriate lifetime due to conflicting requirements\nsrc/main.rs:7   let n = foo(Box::new(|| bar != 42));\n                                     ^~~~~~~~~~~~\nsrc/main.rs:7:15: 7:23 note: first, the lifetime cannot outlive the     expression at 7:14...\nsrc/main.rs:7   let n = foo(Box::new(|| bar != 42));\n                            ^~~~~~~~\nsrc/main.rs:7:15: 7:23 note: ...so that the type `[closure src/main.rs:7:24: 7:36]` will meet its required lifetime bounds\nsrc/main.rs:7   let n = foo(Box::new(|| bar != 42));\n                            ^~~~~~~~\nsrc/main.rs:7:15: 7:37 note: but, the lifetime must be valid for the call at 7:14...\nsrc/main.rs:7   let n = foo(Box::new(|| bar != 42));\n                            ^~~~~~~~~~~~~~~~~~~~~~\nsrc/main.rs:7:24: 7:36 note: ...so that argument is valid for the call\nsrc/main.rs:7   let n = foo(Box::new(|| bar != 42));\n                                     ^~~~~~~~~~~~\nerror: aborting due to previous error\n</code></pre>\n\n<p>I don't understand why the lifetime is not properly infered. What can I do to fix that ?</p>\n\n<pre><code>$ rustc --version\nrustc 1.0.0-nightly (6c065fc8c 2015-02-17) (built 2015-02-18)\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 3, "creation_date": 1424420560, "post_id": 28623802, "comment_id": 45550014, "body": "you are aware that BufReader already buffers? You can simply set the capacity to some megabytes and then work on your 512 byte + 8 byte read cycle."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1424420618, "post_id": 28623802, "comment_id": 45550044, "body": "also, you cannot read an unsized array, as rust doesn&#39;t know how many bytes you want. I&#39;m not sure if you can do <code>&amp;mut [u8, BUF_SIZE]</code> but you&#39;d need sth like that."}, {"owner": {"reputation": 1776, "user_id": 410406, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/K18M7.jpg?s=128&g=1", "display_name": "antonone", "link": "https://stackoverflow.com/users/410406/antonone"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1424424003, "post_id": 28623802, "comment_id": 45551719, "body": "@ker: Actually this should be exactly what I need: changing the design ;). I&#39;ve deeply over-thought the problem and now I&#39;m having problems because of this. Please copy it as an answer, I&#39;ll accept it."}], "answers": [{"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 3, "last_activity_date": 1424425411, "last_edit_date": 1592644375, "creation_date": 1424425411, "answer_id": 28625839, "question_id": 28623802, "link": "https://stackoverflow.com/questions/28623802/directly-reading-from-a-file-to-bufreaders-or-cursors-underlying-buffer/28625839#28625839", "title": "Directly reading from a file to BufReader&#39;s or Cursor&#39;s underlying buffer", "body": "<p><code>BufReader</code> already buffers reads. To quote the docs:</p>\n<blockquote>\n<p>Wraps a Read and buffers input from it</p>\n<p>It can be excessively inefficient to work directly with a Read instance. For example, every call to read on TcpStream results in a system call. A BufReader performs large, infrequent reads on the underlying Read and maintains an in-memory buffer of the results.</p>\n</blockquote>\n<p>You could simply set the capacity to some megabytes and then work on your 512 + 8 byte read cycle. The <code>BufReader</code> will only do an actual system call when you used up the buffer.</p>\n<hr />\n<p>The following error</p>\n<blockquote>\n<p>error: the trait <code>std::io::Read</code> is not implemented for the type <code>[u8]</code> [E0277]</p>\n</blockquote>\n<p>is due to the fact, that rust doesn't know how many bytes you want. <code>[u8]</code> is an unsized array.  I'm not sure if you can do <code>&amp;mut [u8, BUF_SIZE]</code> but you'd need something along those lines</p>\n"}], "owner": {"reputation": 1776, "user_id": 410406, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/K18M7.jpg?s=128&g=1", "display_name": "antonone", "link": "https://stackoverflow.com/users/410406/antonone"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3200, "favorite_count": 1, "accepted_answer_id": 28625839, "answer_count": 1, "score": 1, "last_activity_date": 1424442976, "creation_date": 1424417888, "last_edit_date": 1424442976, "question_id": 28623802, "link": "https://stackoverflow.com/questions/28623802/directly-reading-from-a-file-to-bufreaders-or-cursors-underlying-buffer", "title": "Directly reading from a file to BufReader&#39;s or Cursor&#39;s underlying buffer", "body": "<p>I'm trying to figure out some basic stuff in Rust.</p>\n\n<p>I would like to create a tool that will read 512 bytes from a file, and copy those bytes to another file. Then take next 8 bytes from input file and skip them. Then take next 512 bytes from input file, and copy them to output file, then skip 8 bytes, etc...</p>\n\n<p>I need this tool to be fast, so I can't just perform an I/O call every 512 bytes. I've figured I would need to read a few megabytes of the input file first, then remove unneeded 8-byte blocks in memory by selectively copying it to another memory block, and then call I/O write to dump the bigger memory block at once.</p>\n\n<p>So, I would like to do something like this (pseudo-code):</p>\n\n<pre><code>let buffer = buffer of 'u8' of size 4MB;\nlet buffer_out = buffer of 'u8' of size 4MB;\n\n// both buffers above take 8MB of memory\n\nlet input_stream = InputStream(buffer);\nlet output_stream = OutputStream(buffer_out);\n\nfor(every 4MB block in the input file) {\n    input.read(buffer); // read the 4MB block into 'buffer'\n    input_stream.seek(0); // reset the input stream's cursor to offset 0\n\n    for(every 520 byte inside the 4MB block in 'buffer') {\n        output_stream.write(input_stream.read(512)); // copy important 512 bytes\n        input_stream.read(8);                        // skip superfluous 8 bytes\n    }\n\n    output.write(buffer_out);\n}\n</code></pre>\n\n<p>The problem in Rust I have is that I'm trying to use <code>Cursor</code> object to implement streaming access to both buffers. For example, I'm allocating the buffer on the heap like this:</p>\n\n<pre><code>let mut buf: Box&lt;[u8; BUF_SIZE]&gt; = Box::new([0; BUF_SIZE]);\n</code></pre>\n\n<p>And then I'm creating a Cursor to access this array in a streaming mode:</p>\n\n<pre><code>let mut rd_cursor: Cursor&lt;&amp;[u8]&gt; = Cursor::new(buf.as_slice());\n</code></pre>\n\n<p>However, I have no idea how to read the data from the input file now. <code>buf</code> is used by the <code>Cursor</code>, so I can't access it. In C++ I would just read the data to <code>buf</code> and be done with it. And <code>Cursor</code> doesn't seem to implement anything that can be used directly by <code>BufReader.read()</code>, which I use to read data from the input file.</p>\n\n<p>Perhaps I could make it work by creating another buffer, read data from 'input' to the temporary buffer, from temporary buffer to 'buf' through the Cursor, but that would result in constant recopying of memory, which I would like to avoid.</p>\n\n<p>I can see there is a <code>fill_buf</code> function in <code>Cursor</code>, but it seems that it returns only a readonly reference to underlying buffer, so I can't modify the buffer, thus it's useless for my case.</p>\n\n<p>I have also tried using <code>BufReader</code> instead of <code>Cursor</code>. Here is my second try:</p>\n\n<pre><code>let mut rd_cursor: BufReader&lt;&amp;[u8]&gt; = BufReader::new(&amp;*buf);\n</code></pre>\n\n<p><code>BufReader&lt;R&gt;</code> contains <code>get_mut</code> returning <code>R</code>, so I think it should return <code>&amp;[u8]</code> in my case, which sounds like a good thing. But by using <code>&amp;[u8]</code>, <code>get_mut</code> complains that I need to pass a mutable thing as <code>R</code>. So I'm changing it like this:</p>\n\n<pre><code>let mut rd_cursor: BufReader&lt;&amp;mut [u8]&gt; = BufReader::new(&amp;mut *buf);\n</code></pre>\n\n<p>But Rust won't let me:</p>\n\n<pre><code>src\\main.rs|88 col 47| 88:61 error: the trait `std::io::Read` is not implemented for the type `[u8]` [E0277]\n|| src\\main.rs:88     let mut rd_cursor: BufReader&lt;&amp;mut [u8]&gt; = BufReader::new(&amp;mut *buf);\n</code></pre>\n\n<p>Could anyone please hit me in the head to fix my understanding of what is happening here?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1424425603, "post_id": 28621980, "comment_id": 45552617, "body": "invoking any method on a struct reference will be static dispatch, not dynamic dispatch, as you already know the type and therefor the exact function to call."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424443355, "post_id": 28621980, "comment_id": 45563131, "body": "The dereferencing rules are applied at compile time."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 31, "last_activity_date": 1562372600, "last_edit_date": 1562372600, "creation_date": 1424424351, "answer_id": 28625528, "question_id": 28621980, "link": "https://stackoverflow.com/questions/28621980/what-are-the-actual-runtime-performance-costs-of-dynamic-dispatch/28625528#28625528", "title": "What are the actual runtime performance costs of dynamic dispatch?", "body": "<p><em>Disclaimer: the question is fairly open-ended, therefore this answer might be incomplete. Treat it with an even bigger grain of salt than you would normally.</em></p>\n\n<p>Rust uses a simple \"virtual table\" to implement dynamic dispatch. This strategy is also used in C++ for which <a href=\"http://www.cs.ucsb.edu/~urs/oocsb/papers/oopsla96.pdf\" rel=\"noreferrer\">you can see a study here</a>. The study is a bit dated though.</p>\n\n<h1>The cost of indirection</h1>\n\n<p>Virtual dispatch induces indirection, this has a cost for multiple reasons:</p>\n\n<ul>\n<li>indirection is opaque: this inhibits inlining and constant propagation which are key enablers for many compiler optimizations</li>\n<li>indirection has a runtime cost: if incorrectly predicted, you are looking at pipeline stalls and expensive memory fetches</li>\n</ul>\n\n<h2>Optimizing indirection</h2>\n\n<p>Compilers, however, muddies the water by trying their best at optimizing indirection away.</p>\n\n<ul>\n<li>devirtualization: sometimes the compiler can resolve the virtual table look-up at compile time (usually, because it knows the concrete type of the object); if so, it can therefore use a regular function call rather than an indirect one, and optimize away the indirection</li>\n<li>probabilistic devirtualization: last year <a href=\"http://hubicka.blogspot.fr/2014/01/devirtualization-in-c-part-1.html\" rel=\"noreferrer\">Honza Hubi\u010dka introduced a new optimization in gcc</a> (read the 5-part series as it is very instructive). The gist of the strategy is to build the inheritance graph to make an educated guess at the potential type(s), and then use a pattern like <code>if v.hasType(A) { v.A::call() } elif v.hasType(B) { v.B::call() } else { v.virtual-call() }</code>; special-casing the most likely types means <em>regular</em> calls in this case, and therefore inlined/constant-propagated/full-goodies calls.</li>\n</ul>\n\n<p>This latter strategy could be fairly interesting in Rust due to the coherence rules and privacy rules, as it should have more cases where the full \"inheritance\" graph is provably known.</p>\n\n<h1>The cost of monomorphization</h1>\n\n<p>In Rust, you can use compile-time polymorphism instead of run-time polymorphism; the compiler will emit one version of the function for each unique combination of compile-time parameters it takes. This, itself, has a cost:</p>\n\n<ul>\n<li>compilation time cost: more code to be produced, more code to be optimized</li>\n<li>binary size cost: the produced binary will end-up being larger, a typical size/speed trade-off</li>\n<li>run-time cost: possibly, the larger code size might lead to cache misses at CPU level</li>\n</ul>\n\n<p>The compiler might be able to merge together specialized functions that end up having the same implementation (because of phantom types, for example), however it is still more than likely than the produced binaries (executables and libraries) will end up larger.</p>\n\n<p>As usual with performance, you have to measure in your case what is more beneficial.</p>\n"}], "owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4397, "favorite_count": 4, "accepted_answer_id": 28625528, "answer_count": 1, "score": 15, "last_activity_date": 1562372600, "creation_date": 1424408856, "last_edit_date": 1562372490, "question_id": 28621980, "link": "https://stackoverflow.com/questions/28621980/what-are-the-actual-runtime-performance-costs-of-dynamic-dispatch", "title": "What are the actual runtime performance costs of dynamic dispatch?", "body": "<p>There's some background on this topic in the Rust book section on <a href=\"https://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html\" rel=\"noreferrer\">static and dynamic dispatch</a>, but the tl;dr is that calling a method on a trait reference and a few other various situation (function pointers, etc) results in dynamic instead of static dispatch.</p>\n\n<p>What is actual runtime cost of this, after optimizations have been applied?</p>\n\n<p>For example, imagine this set of structs &amp; traits:</p>\n\n<pre><code>struct Buffer;\nstruct TmpBuffer;\nstruct TmpMutBuffer;\n\nimpl BufferType for Buffer { ... }\nimpl BufferType for BufferTmp { ... }\nimpl BufferType for BufferTmpMut { ... }\n\nimpl Buffer2D for BufferType { ... }\n\nimpl Buffer2DExt for Buffer2D { ... }\n</code></pre>\n\n<p>Notice that the traits here are implemented on traits themselves.</p>\n\n<p>What is the calling cost of dynamic dispatch to invoke a method from <code>Buffer2DExt</code> on a struct reference?</p>\n\n<p>The recent question <a href=\"https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules\">What are Rust&#39;s exact auto-dereferencing rules?</a> regards the dereferencing rules; are these rules applied at compile time, or runtime?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 3856, "user_id": 92937, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/p4biZ.jpg?s=128&g=1", "display_name": "TwentyMiles", "link": "https://stackoverflow.com/users/92937/twentymiles"}, "edited": false, "score": 0, "creation_date": 1424376882, "post_id": 28615920, "comment_id": 45535019, "body": "Awesome, this turned out to be a pretty simple solution. Do you have any idea what changed in Rust recently that makes this necessary?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 3856, "user_id": 92937, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/p4biZ.jpg?s=128&g=1", "display_name": "TwentyMiles", "link": "https://stackoverflow.com/users/92937/twentymiles"}, "edited": false, "score": 0, "creation_date": 1424377739, "post_id": 28615920, "comment_id": 45535539, "body": "@TwentyMiles Updated with that info."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1530277120, "last_edit_date": 1530277120, "creation_date": 1424376477, "answer_id": 28615920, "question_id": 28615756, "link": "https://stackoverflow.com/questions/28615756/how-do-i-borrow-an-iterator/28615920#28615920", "title": "How do I borrow an Iterator?", "body": "<p>You don't need to clone the underlying data (<code>bytes</code>), but you do need to clone the iterator:</p>\n\n<pre><code>fn is_palindromic(num: i64) -&gt; bool {\n    let string = num.to_string();\n    let bytes = string.as_bytes();\n    let iter = bytes.iter();\n    let n = bytes.len() / 2;\n    equals(iter.clone().take(n), iter.rev().take(n))\n}\n</code></pre>\n\n<p>The iterator isn't implicitly <a href=\"http://doc.rust-lang.org/std/marker/trait.Copy.html\" rel=\"nofollow noreferrer\"><code>Copy</code></a>-able, so you need to explicitly <a href=\"http://doc.rust-lang.org/std/clone/trait.Clone.html\" rel=\"nofollow noreferrer\"><code>Clone</code></a> it.</p>\n\n<p>This changed in <a href=\"https://github.com/rust-lang/rust/commit/ed82b5a70e0ddeea284addef7762375ae5880672\" rel=\"nofollow noreferrer\">this commit</a>, when <a href=\"https://github.com/rust-lang/rust/pull/20790\" rel=\"nofollow noreferrer\"><code>IntoIterator</code> was introduced</a>:</p>\n\n<blockquote>\n  <p>This PR also makes iterator non-implicitly copyable, as this was source of subtle bugs in the libraries. You can still use clone() to explictly copy the iterator.</p>\n</blockquote>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/33348032/155423\">How do I compare a vector against a reversed version of itself?</a></li>\n</ul>\n"}], "owner": {"reputation": 3856, "user_id": 92937, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/p4biZ.jpg?s=128&g=1", "display_name": "TwentyMiles", "link": "https://stackoverflow.com/users/92937/twentymiles"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1633, "favorite_count": 0, "accepted_answer_id": 28615920, "answer_count": 1, "score": 2, "last_activity_date": 1530277120, "creation_date": 1424375947, "last_edit_date": 1495540702, "question_id": 28615756, "link": "https://stackoverflow.com/questions/28615756/how-do-i-borrow-an-iterator", "title": "How do I borrow an Iterator?", "body": "<p>I have a piece of code that I'm using that I found <a href=\"https://stackoverflow.com/questions/24542115/how-to-index-a-string-in-rust\">in another Stack Overflow question</a> </p>\n\n<pre><code>fn is_palindromic(num: i64) -&gt; bool {\n    let string = num.to_string();\n    let bytes = string.as_bytes();\n    let iter = bytes.iter();\n    let n = bytes.len() / 2;\n    equals(iter.take(n), iter.rev().take(n))\n}\n</code></pre>\n\n<p>This worked fine when I originally found it, but something changed in the Rust nightlies between 1/30/15 and 2/17/12 that caused this new error to pop up:</p>\n\n<pre><code>src/program.rs:8:26: 8:30 error: use of moved value: `iter`\nsrc/program.rs:8     equals(iter.take(n), iter.rev().take(n))\n                                          ^~~~\nsrc/program.rs:8:12: 8:16 note: `iter` moved here because it has type `core::slice::Iter&lt;'_, u8&gt;`, which is non-copyable\nsrc/program.rs:8     equals(iter.take(n), iter.rev().take(n))\n                            ^~~~\n</code></pre>\n\n<p>I've looked through the documentation, but I can't seem to find anything that indicates what might have changed. It seems like maybe the <code>take</code> method now behaves differently, but I'm not really sure how to solve the situation short of cloning <code>bytes</code> and using two separate iterators.</p>\n\n<p>This seems like a really inefficient way of solving what seems like a pretty common problem, so I'm thinking I may be missing something.</p>\n\n<p><strong>What is the correct method of borrowing an iterator for use with methods like <code>std::iter::order::equals</code>?</strong></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1424356154, "post_id": 28608823, "comment_id": 45521573, "body": "That&#39;s a graph. Graphs are unfortunately a bit tricky (simple borrowed pointers generally don&#39;t work very well, and all the alternatives have complicated trade offs). Trees and such are easy, but graphs..."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1424357464, "post_id": 28608823, "comment_id": 45522536, "body": "Have you had a look at <a href=\"https://github.com/bluss/petulant-avenger-graphlibrary\" rel=\"nofollow noreferrer\">github.com/bluss/petulant-avenger-graphlibrary</a> ?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1425345780, "post_id": 28608823, "comment_id": 45916516, "body": "Please make sure to upvote useful answers and mark an answer as accepted if it solved your problem! If no answer is acceptable, consider leaving comments explaining why, or edit your question to phrase the problem differently."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 4, "creation_date": 1424416479, "post_id": 28622326, "comment_id": 45548411, "body": "<i>it breaks all the safety rules by just manually implementing raw pointers</i> =&gt; No, it does not. This pattern is 100% safe because array access is bounds-checked in Rust. Whether it&#39;s a good idea or not, however, is much more subjective."}, {"owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1424419347, "post_id": 28622326, "comment_id": 45549498, "body": "@MatthieuM. If your application halts early because of a panic, or because of a segmentation fault, is it really 100% safe? I suppose so, technically, but pragmatically, it&#39;s not really any better than the latter; it still crashes."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1424419496, "post_id": 28622326, "comment_id": 45549565, "body": "It is safe in that you have no memory corruption or random bug. It is of course undesirable behavior, but any bug is undesirable."}, {"owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1424419776, "post_id": 28622326, "comment_id": 45549680, "body": "@MatthieuM. No, you can very easily have a random bug, because you are ignoring all the safety rust offers with borrowing when you create a index reference; you just can&#39;t have arbitrary memory corruption. I mean, totally. You&#39;re 100% correct. It&#39;s also 100% a bad idea to use this pattern, ever (unless say, you&#39;re writing a scripting language with it&#39;s own stack, etc I suppose)."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1424420884, "post_id": 28622326, "comment_id": 45550166, "body": "I don&#39;t understand what you meant by <i>ignoring all the safety rust offers with borrowing</i>. To get to the node behind the index you will borrow it, and therefore be prevented to access other nodes from the vector, unless you use <code>split</code> and/or cells."}, {"owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1424422373, "post_id": 28622326, "comment_id": 45550818, "body": "@MatthieuM. this isn&#39;t really the place for this discussion. Have a look at <a href=\"http://users.rust-lang.org/t/manually-implementing-a-heap-to-overcome-safety-rules-considered-harmful/398\" rel=\"nofollow noreferrer\">users.rust-lang.org/t/&hellip;</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1424444055, "post_id": 28622326, "comment_id": 45563589, "body": "Rust has very specific meaning to the word <i>safe</i>. Here&#39;s <a href=\"http://doc.rust-lang.org/reference.html#behaviour-not-considered-unsafe\" rel=\"nofollow noreferrer\">a list of things not considered unsafe</a>. You may not want to do these things in your program, but they are safe. <code>panic!</code> on an out-of-bounds reference <b>is safe</b> because you do not get memory corruption."}, {"owner": {"reputation": 6608, "user_id": 4497253, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dc929d11ae26463d18e337d295c86fcc?s=128&d=identicon&r=PG&f=1", "display_name": "CoronA", "link": "https://stackoverflow.com/users/4497253/corona"}, "edited": false, "score": 0, "creation_date": 1590642268, "post_id": 28622326, "comment_id": 109757495, "body": "Modelling a graph with <code>Rc&lt;Node&gt;</code>s or <code>Arc&lt;Node&gt;</code>s with interior mutability feels like a safe solution even without indexing into a global list. So the statement that there is no way in safe rust seems to me unjustified."}], "tags": [], "owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "is_accepted": true, "score": 10, "last_activity_date": 1424410707, "creation_date": 1424410707, "answer_id": 28622326, "question_id": 28608823, "link": "https://stackoverflow.com/questions/28608823/how-to-model-complex-recursive-data-structures-graphs/28622326#28622326", "title": "How to model complex recursive data structures (graphs)?", "body": "<p>You can't represent an arbitrary graph structure in safe rust.</p>\n\n<p>The best way to implement this pattern is to use unsafe code and raw pointers, or an existing abstraction that wraps this functionality in a safe api, for example <a href=\"http://static.rust-lang.org/doc/master/std/cell/struct.RefCell.html\" rel=\"noreferrer\">http://static.rust-lang.org/doc/master/std/cell/struct.RefCell.html</a></p>\n\n<p>For example, the typical bi directional linked list would be:</p>\n\n<pre><code>struct Node {\n  next: Option&lt;Node&gt;, // Each node 'owns' the next one\n  prev: *mut Node     // Backrefs are unsafe\n}\n</code></pre>\n\n<p>There have been a number of 'safe' implementations floating around, where you have something like:</p>\n\n<pre><code>struct Node {\n    id: u32,\n    next: u32,\n    prev: u32\n}\nstruct Nodes {\n  all:Vec&lt;Node&gt;,\n  root:Option&lt;Node&gt;\n}\n</code></pre>\n\n<p>This is 'technically' safe, but it's a terrible pattern; it breaks all the safety rules by just manually implementing raw pointers. I strongly advise against it.</p>\n\n<p>You could try using references, eg:</p>\n\n<pre><code>struct Container&lt;'a&gt; {\n  edges:Vec&lt;Edge&lt;'a&gt;&gt;,\n  pub root: Node\n}\n\nstruct Node {\n  children:Vec&lt;Node&gt;  \n}\n\nstruct Edge&lt;'a&gt; {\n  n1: &amp;'a Node,\n  n2: &amp;'a Node\n}\n</code></pre>\n\n<p>...but you'll stumble almost immediately into borrow checker hell. For example, when you remove a node, how does the borrow checker know that the associated links in 'edges' are no longer valid? </p>\n\n<p>Although you might be able to define the structures, populating them will be extremely troublesome.</p>\n\n<p>I know that's probably a quite unsatisfying answer; you may find it useful to search github for 'rust graph' and 'rust tree' and look at the implementations other people have done.</p>\n\n<p>Typically they enforce single-ownership of a sub-tree to a parent object. </p>\n"}], "owner": {"reputation": 537, "user_id": 525493, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/995981dd7460a137d2f25a2fcf62af11?s=128&d=identicon&r=PG", "display_name": "Nicolas Bonnefon", "link": "https://stackoverflow.com/users/525493/nicolas-bonnefon"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3218, "favorite_count": 6, "accepted_answer_id": 28622326, "answer_count": 1, "score": 21, "last_activity_date": 1424448614, "creation_date": 1424355891, "last_edit_date": 1424448614, "question_id": 28608823, "link": "https://stackoverflow.com/questions/28608823/how-to-model-complex-recursive-data-structures-graphs", "title": "How to model complex recursive data structures (graphs)?", "body": "<p>I am very interested in Rust and am now starting my first non-trivial project in the language. I am still having a bit of trouble fully understanding the concepts of borrowing and lifetime.</p>\n\n<p>The application is a logic gate simulator in which components are defined recursively (in terms of other components and their interconnections).</p>\n\n<p>My current plan is to implement this similarly as I would in C++ by having a Component structure owning a vector of Components (its sub-components) and a vector of Nets describing the inter-connections between those components:</p>\n\n<pre><code>pub struct Pin {\n    name: String\n}\n\npub struct Net&lt;'a&gt; {\n    nodes: Vec&lt;(&amp;'a Component&lt;'a&gt;,&amp;'a Pin)&gt;\n}\n\npub struct Component&lt;'a&gt; {\n    sub_components: Vec&lt;Box&lt;Component&lt;'a&gt;&gt;&gt;,\n    in_pins: Vec&lt;Pin&gt;,\n    out_pins: Vec&lt;Pin&gt;,\n    netlist: Vec&lt;Net&lt;'a&gt;&gt;\n}\n\nimpl&lt;'a&gt; Component&lt;'a&gt; {\n    pub fn new() -&gt; Component&lt;'a&gt; {\n        ...\n    }\n\n    pub fn add_subcomponent( &amp; mut self, comp: Component&lt;'a&gt; ) {\n        // -&gt; &amp;Box&lt;Component&lt;'a&gt;&gt; ??\n        ....\n    }\n}\n</code></pre>\n\n<p>In C++, Net would be easy to implement as an array of pointers to Components but I am not sure of the best way to do this in Rust, I suppose I should use borrowed pointers? Or is there a better way?</p>\n\n<p>Consider the following main:</p>\n\n<pre><code>fn main() {\n    let sub1 = Component::new();\n    let sub2 = Component::new();\n    let circuit = Component::new();\n\n    circuit.add_subcomponent( sub1 );\n    circuit.add_subcomponent( sub2 );\n    // sub1 and sub2 are now empty...\n}\n</code></pre>\n\n<p>How can I configure circuit to create a net between sub1 and sub2? Shall I have add_subcomponent returns a borrowed pointer to the added Component? or the Box?</p>\n\n<p>It would be great if someone could point me in the right direction.</p>\n\n<p>Thanks a lot.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 1, "creation_date": 1424347448, "post_id": 28601334, "comment_id": 45516123, "body": "FYI: The <code>Vec</code> struct (which consists of tree pointers/<code>usize</code>s) will be on the stack, but the <code>n * sizeof::&lt;T&gt;</code> buffer will always be on the heap."}], "answers": [{"comments": [{"owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "edited": false, "score": 0, "creation_date": 1424333953, "post_id": 28601386, "comment_id": 45508362, "body": "That worked, thanks. Is this approach considered canonical in this situation?"}, {"owner": {"reputation": 6067, "user_id": 918124, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/7dca4113cc56449a8bc144e82a8a916e?s=128&d=identicon&r=PG", "display_name": "DrYap", "link": "https://stackoverflow.com/users/918124/dryap"}, "reply_to_user": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "edited": false, "score": 2, "creation_date": 1424334375, "post_id": 28601386, "comment_id": 45508556, "body": "The best approach would to be refactor the &#39;i32&#39; into &#39;usize&#39; if that is possible. Otherwise, I think this is your only option. Casting in Rust is unsafe so <code>-4</code> in <code>i32</code> will become a large positive <code>usize</code>  so you might want to do some testing on the values but that overhead could be unnecessary depending on your situation."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1424334452, "post_id": 28601386, "comment_id": 45508592, "body": "You can always use Numcast: <a href=\"http://doc.rust-lang.org/std/num/trait.NumCast.html#tymethod.from\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/num/trait.NumCast.html#tymethod.from</a>"}, {"owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "edited": false, "score": 0, "creation_date": 1424334473, "post_id": 28601386, "comment_id": 45508601, "body": "At the very least I can make it a <code>u32</code> which should resolve most issues."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 3, "creation_date": 1424335095, "post_id": 28601386, "comment_id": 45508889, "body": "@DrYap, I believe that refactoring <code>i32</code> to <code>usize</code> is not the idiomatic approach. As far as I know, it is suggested that pointer-sized integers should be used as sparingly as possible, so the conversion to <code>usize</code> <i>is</i> the idiomatic approach. If you&#39;re converting from a sized type, you need to add a check that the number is indeed positive, though."}, {"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 3, "creation_date": 1424348437, "post_id": 28601386, "comment_id": 45516697, "body": "@DrYap A small niggle: casting in Rust is <i>safe</i>. It&#39;s true that casting <code>-4 as usize</code> will give you a large positive number, but this does not meet the very specific criteria that Rust uses to define &quot;unsafe.&quot; (Which is a statement about memory safety.)"}], "tags": [], "owner": {"reputation": 6067, "user_id": 918124, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/7dca4113cc56449a8bc144e82a8a916e?s=128&d=identicon&r=PG", "display_name": "DrYap", "link": "https://stackoverflow.com/users/918124/dryap"}, "is_accepted": true, "score": 7, "last_activity_date": 1424334437, "last_edit_date": 1424334437, "creation_date": 1424333651, "answer_id": 28601386, "question_id": 28601334, "link": "https://stackoverflow.com/questions/28601334/how-should-i-call-vecwith-capacity-with-an-i32/28601386#28601386", "title": "How should I call Vec::with_capacity with an i32?", "body": "<p><a href=\"http://doc.rust-lang.org/reference.html#type-cast-expressions\" rel=\"noreferrer\">Cast</a> to usize.</p>\n\n<pre><code>let n: i32 = 4;\nlet v = Vec::&lt;i16&gt;::with_capacity(n as usize);\n</code></pre>\n"}], "owner": {"reputation": 6086, "user_id": 943814, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/e8b4b9fc52a3084be9a2de004e0bb6dc?s=128&d=identicon&r=PG", "display_name": "anderspitman", "link": "https://stackoverflow.com/users/943814/anderspitman"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3040, "favorite_count": 1, "accepted_answer_id": 28601386, "answer_count": 1, "score": 5, "last_activity_date": 1424357505, "creation_date": 1424333467, "last_edit_date": 1424357505, "question_id": 28601334, "link": "https://stackoverflow.com/questions/28601334/how-should-i-call-vecwith-capacity-with-an-i32", "title": "How should I call Vec::with_capacity with an i32?", "body": "<p>I have a function which allocates a vector on the stack. This code doesn't work:</p>\n\n<pre><code>fn my_func(n: i32) {\n    let mut v = Vec::with_capacity(n);\n}\n</code></pre>\n\n<p>The compiler says <code>n</code> needs to be a <code>usize</code>. I suppose that makes sense from a type safety point of view, but I need to use <code>n</code> in other calculations where an <code>i32</code> is called for. What's the proper way to handle this?</p>\n"}, {"tags": ["multithreading", "random", "synchronization", "rust"], "comments": [{"owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "edited": false, "score": 0, "creation_date": 1424329660, "post_id": 28599334, "comment_id": 45506610, "body": "Can you describe the algorithm you&#39;re trying to implement? What is the expected result?"}, {"owner": {"reputation": 67, "user_id": 4582420, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/YifVV.jpg?s=128&g=1", "display_name": "Scoshe Rosh", "link": "https://stackoverflow.com/users/4582420/scoshe-rosh"}, "reply_to_user": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "edited": false, "score": 0, "creation_date": 1424330524, "post_id": 28599334, "comment_id": 45506946, "body": "I&#39;m trying to distribute the array across the threads and have the threads sum up portions of the array in parallel. I want thread 0 to sum elements 0 1 2 and Thread 1 sum elements 3 4 5. Thread 2 to sum 6 and 7. and Thread 3 to sum 8 and 9"}, {"owner": {"reputation": 67, "user_id": 4582420, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/YifVV.jpg?s=128&g=1", "display_name": "Scoshe Rosh", "link": "https://stackoverflow.com/users/4582420/scoshe-rosh"}, "edited": false, "score": 0, "creation_date": 1424339241, "post_id": 28599334, "comment_id": 45511259, "body": "i managed to get it to work with even numbers like 20 and 100"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1424340488, "post_id": 28599334, "comment_id": 45511990, "body": "your &quot;question&quot; now doesn&#39;t contain a question anymore."}, {"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 1, "creation_date": 1424350034, "post_id": 28599334, "comment_id": 45517616, "body": "Just noticed that your <code>check_sum</code> takes a <code>&amp;mut [i32]</code>. Why <code>mut</code>? You don&#39;t want to mutate anything in that slice."}], "answers": [{"comments": [{"owner": {"reputation": 67, "user_id": 4582420, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/YifVV.jpg?s=128&g=1", "display_name": "Scoshe Rosh", "link": "https://stackoverflow.com/users/4582420/scoshe-rosh"}, "edited": false, "score": 0, "creation_date": 1424339426, "post_id": 28601893, "comment_id": 45511367, "body": "Yeah at first I didn&#39;t realize each thread gets it&#39;s own copy of scale"}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 3, "last_activity_date": 1424335603, "creation_date": 1424335603, "answer_id": 28601893, "question_id": 28599334, "link": "https://stackoverflow.com/questions/28599334/how-do-i-run-parallel-threads-of-computation-on-a-partitioned-array/28601893#28601893", "title": "How do I run parallel threads of computation on a partitioned array?", "body": "<p>All your tasks get a copy of the <code>scale</code> variable. Thread 1 and 2 both do the same thing since each has <code>scale</code> with a value of <code>0</code> and modifies it in the same manner as the other thread.\nThe same goes for Thread 3 and 4.</p>\n\n<p>Rust prevents you from breaking thread safety. If <code>scale</code> were shared by the threads, you would have race conditions when accessing the variable.</p>\n\n<p>Please read about <a href=\"http://doc.rust-lang.org/book/closures.html\" rel=\"nofollow\">closures</a>, they explain the variable copying part, and about <a href=\"http://doc.rust-lang.org/book/concurrency.html\" rel=\"nofollow\">threading</a> which explains when and how you can share variables between threads.</p>\n"}, {"comments": [{"owner": {"reputation": 67, "user_id": 4582420, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/YifVV.jpg?s=128&g=1", "display_name": "Scoshe Rosh", "link": "https://stackoverflow.com/users/4582420/scoshe-rosh"}, "edited": false, "score": 0, "creation_date": 1424464332, "post_id": 28606076, "comment_id": 45574953, "body": "Thank you, I wanted to input the size of the array, and the amount of threads from the user...is the io still buggy?"}, {"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "reply_to_user": {"reputation": 67, "user_id": 4582420, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/YifVV.jpg?s=128&g=1", "display_name": "Scoshe Rosh", "link": "https://stackoverflow.com/users/4582420/scoshe-rosh"}, "edited": false, "score": 0, "creation_date": 1424474674, "post_id": 28606076, "comment_id": 45579037, "body": "What do you mean exactly by &quot;is the io still buggy?&quot; in this context?"}], "tags": [], "owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "is_accepted": true, "score": 10, "last_activity_date": 1501022885, "last_edit_date": 1501022885, "creation_date": 1424347872, "answer_id": 28606076, "question_id": 28599334, "link": "https://stackoverflow.com/questions/28599334/how-do-i-run-parallel-threads-of-computation-on-a-partitioned-array/28606076#28606076", "title": "How do I run parallel threads of computation on a partitioned array?", "body": "<p>Welcome to Rust! :)</p>\n\n<blockquote>\n  <p>Yeah at first I didn't realize each thread gets it's own copy of scale</p>\n</blockquote>\n\n<p>Not only that! It also gets its own copy of <code>a</code>!</p>\n\n<p>What you are trying to do could look like the following code. I guess it's easier for you to see a complete working example since you seem to be a Rust beginner and asked for guidance. I deliberately replaced <code>[i32; 10]</code> with a <code>Vec</code> since a <code>Vec</code> is <em>not</em> implicitly <code>Copy</code>able. It requires an explicit <code>clone()</code>; we cannot copy it by accident. Please note all the larger and smaller differences. The code also got a little more functional (less <code>mut</code>). I commented most of the noteworthy things:</p>\n\n<pre><code>extern crate rand;\n\nuse std::sync::Arc;\nuse std::sync::mpsc;\nuse std::thread;\n\nconst NTHREADS: usize = 4; // I replaced `static` by `const`\n\n// gets used for *all* the summing :)\nfn sum&lt;I: Iterator&lt;Item=i32&gt;&gt;(iter: I) -&gt; i32 {\n    let mut s = 0;\n    for x in iter {\n        s += x;\n    }\n    s\n}\n\nfn main() {\n    // We don't want to clone the whole vector into every closure.\n    // So we wrap it in an `Arc`. This allows sharing it.\n    // I also got rid of `mut` here by moving the computations into\n    // the initialization.\n    let a: Arc&lt;Vec&lt;_&gt;&gt; =\n        Arc::new(\n            (0..10)\n                .map(|_| {\n                    (rand::random::&lt;i32&gt;() % 100) + 1\n                })\n                .collect()\n        );\n\n    let (tx, rx) = mpsc::channel(); // types will be inferred\n\n    { // local scope, we don't need the following variables outside\n        let num_tasks_per_thread = a.len() / NTHREADS; // same here\n        let num_tougher_threads = a.len() % NTHREADS; // same here\n        let mut offset = 0;\n        for id in 0..NTHREADS {\n            let chunksize =\n                if id &lt; num_tougher_threads {\n                    num_tasks_per_thread + 1\n                } else {\n                    num_tasks_per_thread\n                };\n            let my_a = a.clone();  // refers to the *same* `Vec`\n            let my_tx = tx.clone();\n            thread::spawn(move || {\n                let end = offset + chunksize;\n                let partial_sum =\n                    sum( (&amp;my_a[offset..end]).iter().cloned() );\n                my_tx.send(partial_sum).unwrap();\n            });\n            offset += chunksize;\n        }\n    }\n\n    // We can close this Sender\n    drop(tx);\n\n    // Iterator magic! Yay! global_sum does not need to be mutable\n    let global_sum = sum(rx.iter());\n    println!(\"global sum via threads    : {}\", global_sum);\n    println!(\"global sum single-threaded: {}\", sum(a.iter().cloned()));\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 1, "creation_date": 1424362024, "post_id": 28609719, "comment_id": 45525873, "body": "You&#39;re launching actually 5 threads instead of 4. But other than that: thread::scoped is cool! Didn&#39;t know that it already works like it&#39;s supposed to."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 1, "creation_date": 1424363465, "post_id": 28609719, "comment_id": 45526950, "body": "@sellibitze haha, good catch! But what&#39;s one extra thread among friends? ^_^. I suppose it could be fixed it by doing a floating-point division then rounding up. Or perhaps doing some <a href=\"http://stackoverflow.com/a/503201/155423\">trickery with integer division</a>?"}, {"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 1, "creation_date": 1424381867, "post_id": 28609719, "comment_id": 45537849, "body": "Hold on. I just noticed that <code>threads</code> is an iterator! This is not doing what you want. It lazily launches the threads just before you ask to join it. So, they don&#39;t work concurrently."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 1, "creation_date": 1424382283, "post_id": 28609719, "comment_id": 45538091, "body": "@sellibitze Double good catch! I&#39;ve added a <code>collect</code> to force the threads to start right away."}, {"owner": {"reputation": 67, "user_id": 4582420, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/YifVV.jpg?s=128&g=1", "display_name": "Scoshe Rosh", "link": "https://stackoverflow.com/users/4582420/scoshe-rosh"}, "edited": false, "score": 0, "creation_date": 1424464193, "post_id": 28609719, "comment_id": 45574895, "body": "how would i install the latest bleeding-edge for ubuntu? and thanks for the response and code. The uniform distribution and timing is what I wanted to do eventually."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 67, "user_id": 4582420, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/YifVV.jpg?s=128&g=1", "display_name": "Scoshe Rosh", "link": "https://stackoverflow.com/users/4582420/scoshe-rosh"}, "edited": false, "score": 0, "creation_date": 1424465991, "post_id": 28609719, "comment_id": 45575737, "body": "@ScosheRosh just <a href=\"http://www.rust-lang.org/install.html\" rel=\"nofollow noreferrer\">download the appropriate installer</a> for your platform."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 6, "last_activity_date": 1579637501, "last_edit_date": 1579637501, "creation_date": 1424358475, "answer_id": 28609719, "question_id": 28599334, "link": "https://stackoverflow.com/questions/28599334/how-do-i-run-parallel-threads-of-computation-on-a-partitioned-array/28609719#28609719", "title": "How do I run parallel threads of computation on a partitioned array?", "body": "<p>Using a crate like <a href=\"https://crates.io/crates/crossbeam\" rel=\"nofollow noreferrer\">crossbeam</a> you can write this code:</p>\n\n<pre><code>use crossbeam; // 0.7.3\nuse rand::distributions::{Distribution, Uniform}; // 0.7.3\n\nconst NTHREADS: usize = 4;\n\nfn random_vec(length: usize) -&gt; Vec&lt;i32&gt; {\n    let step = Uniform::new_inclusive(1, 100);\n    let mut rng = rand::thread_rng();\n    step.sample_iter(&amp;mut rng).take(length).collect()\n}\n\nfn main() {\n    let numbers = random_vec(10);\n    let num_tasks_per_thread = numbers.len() / NTHREADS;\n\n    crossbeam::scope(|scope| {\n        // The `collect` is important to eagerly start the threads!\n        let threads: Vec&lt;_&gt; = numbers\n            .chunks(num_tasks_per_thread)\n            .map(|chunk| scope.spawn(move |_| chunk.iter().cloned().sum::&lt;i32&gt;()))\n            .collect();\n\n        let thread_sum: i32 = threads.into_iter().map(|t| t.join().unwrap()).sum();\n        let no_thread_sum: i32 = numbers.iter().cloned().sum();\n\n        println!(\"global sum via threads    : {}\", thread_sum);\n        println!(\"global sum single-threaded: {}\", no_thread_sum);\n    })\n    .unwrap();\n}\n</code></pre>\n\n<p><em>Scoped threads</em> allow you to pass in a reference that is guaranteed to outlive the thread. You can then use the return value of the thread directly, skipping channels (which are great, just not needed here!).</p>\n\n<p>I followed <a href=\"https://stackoverflow.com/q/19671845/155423\">How can I generate a random number within a range in Rust?</a> to generate the random numbers. I also changed it to be the range [1,100], as I <em>think</em> that's what you meant. However, your original code is actually [-98,100], which you could also do.</p>\n\n<p><a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum\" rel=\"nofollow noreferrer\"><code>Iterator::sum</code></a> is used to sum up an iterator of numbers.</p>\n\n<p>I threw in some rough performance numbers of the thread work, ignoring the vector construction, working on 100,000,000 numbers, using Rust 1.34 and compiling in release mode:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>| threads | time (ns) | relative time (%) |\n|---------+-----------+-------------------|\n|       1 |  33824667 |            100.00 |\n|       2 |  16246549 |             48.03 |\n|       3 |  16709280 |             49.40 |\n|       4 |  14263326 |             42.17 |\n|       5 |  14977901 |             44.28 |\n|       6 |  12974001 |             38.36 |\n|       7 |  13321743 |             39.38 |\n|       8 |  13370793 |             39.53 |\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/32750829/155423\">How can I pass a reference to a stack variable to a thread?</a></li>\n</ul>\n"}], "owner": {"reputation": 67, "user_id": 4582420, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/YifVV.jpg?s=128&g=1", "display_name": "Scoshe Rosh", "link": "https://stackoverflow.com/users/4582420/scoshe-rosh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3806, "favorite_count": 5, "accepted_answer_id": 28606076, "answer_count": 3, "score": 5, "last_activity_date": 1579637501, "creation_date": 1424324399, "last_edit_date": 1501023582, "question_id": 28599334, "link": "https://stackoverflow.com/questions/28599334/how-do-i-run-parallel-threads-of-computation-on-a-partitioned-array", "title": "How do I run parallel threads of computation on a partitioned array?", "body": "<p>I'm trying to distribute an array across threads and have the threads sum up portions of the array in parallel. I want thread 0 to sum elements 0 1 2 and Thread 1 sum elements 3 4 5. Thread 2 to sum 6 and 7. and Thread 3 to sum 8 and 9.</p>\n\n<p>I'm new to Rust but have coded with C/C++/Java before. I've literally thrown everything and the garbage sink at this program and I was hoping I could receive some guidance.</p>\n\n<p>Sorry my code is sloppy but I will clean it up when it is a finished product. Please ignore all poorly named variables/inconsistent spacing/etc.</p>\n\n<pre><code>use std::io;\nuse std::rand;\nuse std::sync::mpsc::{Sender, Receiver};\nuse std::sync::mpsc;\nuse std::thread::Thread;\n\nstatic NTHREADS: usize = 4;\nstatic NPROCS: usize = 10;\n\nfn main() {\n    let mut a = [0; 10]; // a: [i32; 10]\n    let mut endpoint = a.len() / NTHREADS;\n    let mut remElements = a.len() % NTHREADS;\n\n    for x in 0..a.len() {\n        let secret_number = (rand::random::&lt;i32&gt;() % 100) + 1;\n        a[x] = secret_number;\n        println!(\"{}\", a[x]);\n    }\n    let mut b = a;\n    let mut x = 0;\n\n    check_sum(&amp;mut a);\n    // serial_sum(&amp;mut b);\n\n    // Channels have two endpoints: the `Sender&lt;T&gt;` and the `Receiver&lt;T&gt;`,\n    // where `T` is the type of the message to be transferred\n    // (type annotation is superfluous)\n    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();\n    let mut scale: usize = 0;\n\n    for id in 0..NTHREADS {\n        // The sender endpoint can be copied\n        let thread_tx = tx.clone();\n        // Each thread will send its id via the channel\n\n        Thread::spawn(move || {\n            // The thread takes ownership over `thread_tx`\n            // Each thread queues a message in the channel\n            let numTougherThreads: usize = NPROCS % NTHREADS;\n            let numTasksPerThread: usize = NPROCS / NTHREADS;\n            let mut lsum = 0;\n\n            if id &lt; numTougherThreads {\n                let mut q = numTasksPerThread+1;\n                lsum = 0;\n\n                while q &gt; 0 {\n                    lsum = lsum + a[scale];\n                    scale+=1;\n                    q = q-1;\n                }\n                println!(\"Less than numToughThreads lsum: {}\", lsum);\n            }\n            if id &gt;= numTougherThreads {\n                let mut z = numTasksPerThread;\n                lsum = 0;\n\n                while z &gt; 0 {\n                    lsum = lsum + a[scale];\n                    scale +=1;\n                    z = z-1;\n                }    \n                println!(\"Greater than numToughthreads lsum: {}\", lsum);\n            }\n            // Sending is a non-blocking operation, the thread will continue\n            // immediately after sending its message\n            println!(\"thread {} finished\", id);\n            thread_tx.send(lsum).unwrap();\n        });\n    }\n\n    // Here, all the messages are collected\n    let mut globalSum = 0;\n    let mut ids = Vec::with_capacity(NTHREADS);\n    for _ in 0..NTHREADS {\n        // The `recv` method picks a message from the channel\n        // `recv` will block the current thread if there no messages      available\n        ids.push(rx.recv());\n    }\n    println!(\"Global Sum: {}\", globalSum);\n    // Show the order in which the messages were sent\n\n    println!(\"ids: {:?}\", ids);\n}\n\nfn check_sum (arr: &amp;mut [i32]) {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut size = arr.len();\n    loop {\n        sum += arr[i];\n        i+=1;\n        if i == size { break; }\n    }\n    println!(\"CheckSum is {}\", sum);\n}\n</code></pre>\n\n<p>So far I've gotten it to do this much. Can't figure out why threads 0 and 1 have the same sum as well as 2 and 3 doing the same thing:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code> -5\n -49\n -32\n 99\n 45\n -65\n -64\n -29\n -56\n 65\n CheckSum is -91\n Greater than numTough lsum: -54\n thread 2 finished\n Less than numTough lsum: -86\n thread 1 finished\n Less than numTough lsum: -86\n thread 0 finished\n Greater than numTough lsum: -54\n thread 3 finished\n Global Sum: 0\n ids: [Ok(-86), Ok(-86), Ok(-54), Ok(-54)]\n</code></pre>\n\n<p>I managed to rewrite it to work with even numbers by using the below code.</p>\n\n<pre><code>    while q &gt; 0 {\n        if id*s+scale == a.len() { break; }\n        lsum = lsum + a[id*s+scale];\n        scale +=1;\n        q = q-1;\n    }\n    println!(\"Less than numToughThreads lsum: {}\", lsum);\n}\nif id &gt;= numTougherThreads {\n    let mut z = numTasksPerThread;\n    lsum = 0;\n    let mut scale = 0;\n\n    while z &gt; 0 {\n        if id*numTasksPerThread+scale == a.len() { break; }\n        lsum = lsum + a[id*numTasksPerThread+scale];\n        scale = scale + 1;\n        z = z-1;\n    }\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 14720, "user_id": 2074608, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/WzNwl.png?s=128&g=1", "display_name": "Qantas 94 Heavy", "link": "https://stackoverflow.com/users/2074608/qantas-94-heavy"}, "edited": false, "score": 2, "creation_date": 1424320575, "post_id": 28598592, "comment_id": 45503576, "body": "That isn&#39;t the official documentation, that&#39;s at <a href=\"http://doc.rust-lang.org/1.0.0-alpha/std/\" rel=\"nofollow noreferrer\">doc.rust-lang.org/1.0.0-alpha/std</a>. Anyway, you should take a look at the <a href=\"https://github.com/rust-lang/rust/blob/master/RELEASES.md\" rel=\"nofollow noreferrer\">release notes</a> and see if it mentioned there."}, {"owner": {"reputation": 23981, "user_id": 2813589, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/9axBj.jpg?s=128&g=1", "display_name": "\u30a2\u30ec\u30c3\u30af\u30b9", "link": "https://stackoverflow.com/users/2813589/%e3%82%a2%e3%83%ac%e3%83%83%e3%82%af%e3%82%b9"}, "reply_to_user": {"reputation": 14720, "user_id": 2074608, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/WzNwl.png?s=128&g=1", "display_name": "Qantas 94 Heavy", "link": "https://stackoverflow.com/users/2074608/qantas-94-heavy"}, "edited": false, "score": 0, "creation_date": 1424320661, "post_id": 28598592, "comment_id": 45503598, "body": "@Qantas94Heavy, where is it then? In the release notes it doesn&#39;t say it&#39;s been moved somewhere."}, {"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 1, "creation_date": 1424427797, "post_id": 28598592, "comment_id": 45553932, "body": "No stability promises were made. Rust is still a moving target in its 1.0-alpha phase. See <a href=\"http://blog.rust-lang.org/2015/02/13/Final-1.0-timeline.html\" rel=\"nofollow noreferrer\">blog.rust-lang.org/2015/02/13/Final-1.0-timeline.html</a>"}], "answers": [{"tags": [], "owner": {"reputation": 11676, "user_id": 2536143, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/689fac88d8019eabd3421e6c740be7ae?s=128&d=identicon&r=PG", "display_name": "Levans", "link": "https://stackoverflow.com/users/2536143/levans"}, "is_accepted": true, "score": 4, "last_activity_date": 1424328634, "creation_date": 1424328634, "answer_id": 28600236, "question_id": 28598592, "link": "https://stackoverflow.com/questions/28598592/rust-alpha-1-base64-not-found/28600236#28600236", "title": "Rust alpha 1 - base64 not found", "body": "<p>You are using the nightlies, and so should refer to the <a href=\"http://doc.rust-lang.org/std/index.html\" rel=\"nofollow\">nightlies documentation</a>.</p>\n\n<p>The <code>serialize</code> crate as been moved to <a href=\"https://crates.io/crates/rustc-serialize\" rel=\"nofollow\">an external repository on crates.io</a> to use it, simply insert</p>\n\n<pre><code>[dependencies]\nrustc-serialize = \"0.2\"\n</code></pre>\n\n<p>in you <code>Cargo.toml</code> and import the crate in your rust code with:</p>\n\n<pre><code>extern crate \"rustc-serialize\" as rustc_serialize;\nuse rustc_serialize::base64;\n</code></pre>\n\n<p>You should also change your <code>#[derive(Encodable)]</code> and <code>#[derive(Decodable)]</code> to <code>#[derive(RustcEncodable)]</code> and <code>#[derive(RustcDecodable)]</code></p>\n"}], "owner": {"reputation": 23981, "user_id": 2813589, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/9axBj.jpg?s=128&g=1", "display_name": "\u30a2\u30ec\u30c3\u30af\u30b9", "link": "https://stackoverflow.com/users/2813589/%e3%82%a2%e3%83%ac%e3%83%83%e3%82%af%e3%82%b9"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 128, "favorite_count": 0, "accepted_answer_id": 28600236, "answer_count": 1, "score": -2, "last_activity_date": 1608767530, "creation_date": 1424320037, "last_edit_date": 1608767530, "question_id": 28598592, "link": "https://stackoverflow.com/questions/28598592/rust-alpha-1-base64-not-found", "title": "Rust alpha 1 - base64 not found", "body": "<p>A newest version of Rust:</p>\n<pre><code>$ rustc --version\nrustc 1.0.0-nightly (6c065fc8c 2015-02-17) (built 2015-02-18)\n</code></pre>\n<p>According to <a href=\"http://web.mit.edu/rust-lang_v1.0al/arch/amd64_ubuntu1404/share/doc/rust/html/serialize/base64/trait.ToBase64.html\" rel=\"nofollow noreferrer\">the documentation</a> this should compile (and it compiled before):</p>\n<pre><code>use serialize::base64;\nuse serialize::base64::{ToBase64, FromBase64};\n</code></pre>\n<p>But it says</p>\n<pre><code>src/lib.rs:6:5: 6:22 error: unresolved import `serialize::base64`. There is no `base64` in `serialize`\nsrc/lib.rs:6 use serialize::base64;\n                 ^~~~~~~~~~~~~~~~~\nsrc/lib.rs:7:25: 7:33 error: unresolved import `serialize::base64::ToBase64`. Could not find `base64` in `serialize`\nsrc/lib.rs:7 use serialize::base64::{ToBase64, FromBase64};\n                                     ^~~~~~~~\nsrc/lib.rs:7:35: 7:45 error: unresolved import `serialize::base64::FromBase64`. Could not find `base64` in `serialize`\nsrc/lib.rs:7 use serialize::base64::{ToBase64, FromBase64};\n                                               ^~~~~~~~~~\nerror: aborting due to 3 previous errors\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user35288"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424315929, "post_id": 28597751, "comment_id": 45502450, "body": "No, I have looked in the project dir, as well as my <code>~&#47;.cargo</code>, and there is no <code>.a</code> lib"}, {"owner": {"user_type": "does_not_exist", "display_name": "user35288"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1424353078, "post_id": 28597751, "comment_id": 45519586, "body": "I changed that, and also realized that I was copying the <code>.a</code> for no reason...I ended up passing <code>foo_dir</code> to <code>-L</code> instead of <code>out_dir</code>. So, if you want to throw your 2 suggestions in an answer, I will mark it as the accepted one :)"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": -1, "last_activity_date": 1424367020, "creation_date": 1424367020, "answer_id": 28612965, "question_id": 28597751, "link": "https://stackoverflow.com/questions/28597751/depending-on-sys-wrapper-library/28612965#28612965", "title": "Depending on -sys wrapper library?", "body": "<p>Instead of using <code>PWD</code>, try <code>CARGO_MANIFEST_DIR</code>. The docs say:</p>\n\n<blockquote>\n  <p><code>CARGO_MANIFEST_DIR</code> - The directory containing the manifest for the package being built (the package containing the build script). Also note that this is the value of the current working directory of the build script when it starts.</p>\n</blockquote>\n\n<p>I think there's a fine distinction here - the program is probably <em>running</em> in the correct directory, but the <code>PWD</code> variable is not updated to match it. This might be a Cargo bug, if it's true.</p>\n\n<p>However, there's no reason to copy libfoo.a around. Instead, use <code>foo_dir</code> with -L instead of <code>out_dir</code>, simply linking to where ever the library is.</p>\n"}], "owner": {"user_type": "does_not_exist", "display_name": "user35288"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 118, "favorite_count": 0, "answer_count": 1, "score": 2, "last_activity_date": 1424367020, "creation_date": 1424313151, "question_id": 28597751, "link": "https://stackoverflow.com/questions/28597751/depending-on-sys-wrapper-library", "title": "Depending on -sys wrapper library?", "body": "<p>I have a Rust library that is basically some C source, and a bindgen wrapper for it. It has a <code>build.rs</code> script that goes into the C source directory, runs <code>make</code>, and copies the <code>.a</code> static lib to the <code>$OUT_DIR</code>. When I run <code>cargo build</code>, it all works fine.</p>\n\n<p>However, when I add that library as a dependency in another project, <code>foo-rs</code>, it seems that <code>make</code> is never getting run. The error I end up with is </p>\n\n<pre><code>   Compiling foo-sys v0.1.6\n     Running `rustc &lt;LOTS OF STUFF&gt; -L /home/paul/projects/foo-rs/target/build/foo-sys-936b7a25940b4bf0/out -l foo:static`\nerror: could not find native static library `foo`, perhaps an -L flag is missing?\nCould not compile `foo-sys`.\n</code></pre>\n\n<p>Here is the <code>build.rs</code> from my <code>foo-sys</code> package:</p>\n\n<pre><code>use std::old_io::{fs, Command};\nuse std::os;\nuse std::old_io::process::InheritFd;\n\nfn main() {\n    let manifest_dir = Path::new(os::getenv(\"PWD\").unwrap());\n    let out_dir = Path::new(os::getenv(\"OUT_DIR\").unwrap());\n    let src_dir = manifest_dir.join(\"src\");\n    let foo_dir = src_dir.join(\"foo\");\n    let foo_lib = foo_dir.join(\"libfoo.a\");\n\n    let mut make = Command::new(\"make\");\n\n    assert!(make.cwd(&amp;foo_dir)\n                .arg(\"release\")\n                .stdout(InheritFd(1))\n                .stderr(InheritFd(2))\n                .status()\n                .unwrap()\n                .success());\n\n    if let Err(_) = fs::copy(&amp;foo_lib, &amp;out_dir.join(\"libfoo.a\")) {\n        println!(\"ERROR COPYING libfoo.a\");\n    }\n\n    println!(\"cargo:rustc-flags=-L {} -l foo:static\", out_dir.display());\n}\n</code></pre>\n\n<p>What confuses me is, if you look at the <code>rustc</code> line above, it has the <code>-L</code> and <code>-l foo:static</code> lines from the end of the <code>build.rs</code>, but <code>libfoo.a</code> is nowhere to be found.</p>\n\n<p>So somehow, the <code>make</code> command isn't being run, but the <code>build.rs</code> script is still running?</p>\n"}, {"tags": ["rust", "closures", "borrow-checker", "mutability"], "comments": [{"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 1, "creation_date": 1424351630, "post_id": 28597380, "comment_id": 45518630, "body": "Another suggestion: Clone the state locally to make the move. This is how I implemented something similar"}, {"owner": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 0, "creation_date": 1424351879, "post_id": 28597380, "comment_id": 45518772, "body": "Also, I don&#39;t really know why this was downvoted. This behaviour starts to annoy me here in [rust] and on reddit."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 25688, "user_id": 172531, "user_type": "registered", "accept_rate": 54, "profile_image": "https://www.gravatar.com/avatar/16b8a9971551c67422fea478a6e73bae?s=128&d=identicon&r=PG", "display_name": "sellibitze", "link": "https://stackoverflow.com/users/172531/sellibitze"}, "edited": false, "score": 0, "creation_date": 1424442843, "post_id": 28597380, "comment_id": 45562768, "body": "@sellibitze The best response is to vote up questions that you think are well-researched, phrased, and on-point (all of the stuff that meets <a href=\"http://stackoverflow.com/help/how-to-ask\">how to ask a question</a>). People who don&#39;t believe the question is good will downvote. Over time, the wisdom of the crowds will decide ^_^."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1516634759, "last_edit_date": 1516634759, "creation_date": 1424312455, "answer_id": 28597666, "question_id": 28597380, "link": "https://stackoverflow.com/questions/28597380/how-can-i-modify-self-in-a-closure-called-from-a-member-function/28597666#28597666", "title": "How can I modify self in a closure called from a member function?", "body": "<p>The simplest change you can make is to pass the reference to the closure:</p>\n\n<pre><code>struct Tester {\n    x: i8,\n}\n\nimpl Tester {\n    fn traverse&lt;F&gt;(&amp;mut self, mut f: F)\n    where\n        F: FnMut(&amp;mut Tester),\n    {\n        f(self);\n    }\n}\n\nfn main() {\n    let mut tester = Tester { x: 8 };\n    tester.traverse(|z| z.x += 1);\n    println!(\"{}\", tester.x);\n}\n</code></pre>\n\n<p>This prevents having multiple mutable references (also known as <em>aliasing</em>), which are disallowed in Rust.</p>\n"}], "owner": {"reputation": 520, "user_id": 884498, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/88109a4658cfee0b9d680f48f073d9d4?s=128&d=identicon&r=PG", "display_name": "Nathan Fox", "link": "https://stackoverflow.com/users/884498/nathan-fox"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3219, "favorite_count": 1, "accepted_answer_id": 28597666, "answer_count": 1, "score": 10, "last_activity_date": 1555856070, "creation_date": 1424310423, "last_edit_date": 1555856070, "question_id": 28597380, "link": "https://stackoverflow.com/questions/28597380/how-can-i-modify-self-in-a-closure-called-from-a-member-function", "title": "How can I modify self in a closure called from a member function?", "body": "<p>I am trying to calculate legal chess moves and am having problems satisfying the borrow checker. I have a struct <code>Chess</code> that implements these methods (non-important code replaced by <code>...</code>):</p>\n\n<pre><code>// internal iterator over (possibly not legal) moves\nfn get_moves&lt;F&gt;(&amp;self, func: F)\nwhere\n    F: Fn(/* ... */),\n{\n    func(/* ... */); // move 1\n    func(/* ... */); // move 2\n    func(/* ... */); // etc...\n}\n\nfn is_legal_move(&amp;mut self) -&gt; bool {\n    // notice this takes a mutable self. For performance\n    // reasons, the move is made, legality is checked, then I\n    // undo the move, so it must be mutable to be able to move pieces\n    make_move(/* ... */);\n    // check if legal\n    undo_move(/* ... */);\n    //return true if legal\n}\n\nfn get_legal_moves(&amp;self) /* -&gt; ... */ {\n    self.get_moves(|/* ... */| {\n        if self.is_legal_move(/* ... */) { // &lt;-- error here\n            // do something with legal move\n        }\n    })\n}\n</code></pre>\n\n<p>I get a compilation error in <code>get_legal_moves</code> because I am modifying <code>self</code> inside the closure while <code>get_moves</code> is still borrowing <code>self</code>. </p>\n\n<p>I created a simplified example showing the problem I am trying to solve:</p>\n\n<pre><code>struct Tester {\n    x: i8,\n}\n\nimpl Tester {\n    fn traverse&lt;Func&gt;(&amp;mut self, mut f: Func)\n    where\n        Func: FnMut(),\n    {\n        //in real-world, this would probably iterate over something\n        f();\n    }\n}\n\nfn main() {\n    let mut tester = Tester { x: 8 };\n    tester.traverse(|| {\n        tester.x += 1; //I want to be able to modify tester here\n    });\n    println!(\"{}\", tester.x);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=c92bc889cc59146ad4083188f08ff3cd&amp;version=stable\" rel=\"nofollow noreferrer\">Playground</a></p>\n\n<p>The error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0499]: cannot borrow `tester` as mutable more than once at a time\n  --&gt; src/main.rs:17:5\n   |\n17 |       tester.traverse(|| {\n   |       ^      -------- -- first mutable borrow occurs here\n   |       |      |\n   |  _____|      first borrow later used by call\n   | |\n18 | |         tester.x += 1; //I want to be able to modify tester here\n   | |         ------ first borrow occurs due to use of `tester` in closure\n19 | |     });\n   | |______^ second mutable borrow occurs here\n\nerror[E0499]: cannot borrow `tester` as mutable more than once at a time\n  --&gt; src/main.rs:17:21\n   |\n17 |     tester.traverse(|| {\n   |     ------ -------- ^^ second mutable borrow occurs here\n   |     |      |\n   |     |      first borrow later used by call\n   |     first mutable borrow occurs here\n18 |         tester.x += 1; //I want to be able to modify tester here\n   |         ------ second borrow occurs due to use of `tester` in closure\n</code></pre>\n\n<p>How can I satisfy the borrow checker so the code can compile?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1424311616, "creation_date": 1424311616, "answer_id": 28597527, "question_id": 28596548, "link": "https://stackoverflow.com/questions/28596548/how-do-i-tell-rust-that-my-options-value-actually-does-outlive-the-closure-pass/28597527#28597527", "title": "How do I tell Rust that my Option&#39;s value actually does outlive the closure passed to and_then?", "body": "<p>Unfortunately for you, the compiler is correct here. <code>and_then</code> <em>consumes</em> the Option and the value inside the option along with it. The value is provided to the closure. You can see this by using the trick of assigning a variable to the unit-type (<code>()</code>):</p>\n\n<pre><code>let a = Some(vec![1]);\na.and_then(|z| { let () = z; });\n// error: expected `collections::vec::Vec&lt;_&gt;`,\n</code></pre>\n\n<p>When you call <code>get</code>, it returns a reference to an item in the slice, but the <code>Vec</code> now only lives inside the closure. Once the closure exits, it's gone! Instead, you can change the Option into a reference, then get the value that way. This leaves the original <code>Vec</code> in place:</p>\n\n<pre><code>let a = Some(vec![1]);\na.as_ref().and_then(|z| z.get(0));\n</code></pre>\n"}], "owner": {"reputation": 5549, "user_id": 775982, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/87058ec6a2d1628e392fc444e8c159df?s=128&d=identicon&r=PG", "display_name": "Caspar", "link": "https://stackoverflow.com/users/775982/caspar"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 217, "favorite_count": 0, "accepted_answer_id": 28597527, "answer_count": 1, "score": 3, "last_activity_date": 1424311654, "creation_date": 1424305215, "last_edit_date": 1424311654, "question_id": 28596548, "link": "https://stackoverflow.com/questions/28596548/how-do-i-tell-rust-that-my-options-value-actually-does-outlive-the-closure-pass", "title": "How do I tell Rust that my Option&#39;s value actually does outlive the closure passed to and_then?", "body": "<p>Here's a common pattern I find myself running into:</p>\n\n<pre><code>let maybe_vec = Some(vec![\"val\"]); // I have an option with something in it\nmaybe_vec.and_then(|vec| vec.get(0)); // then I want to transform the something\n</code></pre>\n\n<p>This gives me</p>\n\n<pre><code>src/lib.rs:317:34: 317:37 error: `vec` does not live long enough\nsrc/lib.rs:317         maybe_vec.and_then(|vec| vec.get(0));\n                                                ^~~\nsrc/lib.rs:317:9: 317:45 note: reference must be valid for the method call at 317:8...\nsrc/lib.rs:317         maybe_vec.and_then(|vec| vec.get(0));\n                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/lib.rs:317:34: 317:44 note: ...but borrowed value is only valid for the block at 317:33\nsrc/lib.rs:317         maybe_vec.and_then(|vec| vec.get(0));\n                                                ^~~~~~~~~~\n</code></pre>\n\n<p>To me this error seems overly pedantic - <code>vec</code> might not live long enough, but in this particular case <code>vec</code> is the thing inside <code>maybe_vec</code>, which clearly <strong>is</strong> going to live long enough. Do I need to provide some sort of lifetime annotations here, or am I just going about this wrong?</p>\n"}]