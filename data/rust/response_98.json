[{"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 0, "creation_date": 1479956318, "post_id": 40776087, "comment_id": 68778384, "body": "Yes, but that does not allow me to do everything I could do with an u16, u32 or u64 - e.g. I could not use a value to retrieve an element of an array, compare two values, etc."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 3, "creation_date": 1479973682, "post_id": 40776087, "comment_id": 68784398, "body": "@HenningKoehler: You can, you just have to declare it at trait level. That is <code>pub trait MyNewTrait: Add&lt;Output = Self&gt; + Mul&lt;Output = Self&gt; + ... {}</code>"}, {"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 0, "creation_date": 1479980030, "post_id": 40776087, "comment_id": 68787974, "body": "I suppose, but that also becomes tedious pretty quickly.. and for referencing into a vector I&#39;d need a conversion into usize, which doesn&#39;t seem very safe for arbitrary types that can be added, multiplied etc..."}, {"owner": {"reputation": 17388, "user_id": 921321, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3f4c4737cb30134f58cc76f06ef5113a?s=128&d=identicon&r=PG", "display_name": "Lukazoid", "link": "https://stackoverflow.com/users/921321/lukazoid"}, "reply_to_user": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 1, "creation_date": 1479984392, "post_id": 40776087, "comment_id": 68791222, "body": "@HenningKoehler You could add another trait restriction on your struct or trait for <code>Into&lt;usize&gt;</code>. Either <code>T: MyNewTrait + Into&lt;usize&gt;</code> or <code>trait MyNewTrait : Into&lt;usize&gt;</code>"}], "tags": [], "owner": {"reputation": 17388, "user_id": 921321, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3f4c4737cb30134f58cc76f06ef5113a?s=128&d=identicon&r=PG", "display_name": "Lukazoid", "link": "https://stackoverflow.com/users/921321/lukazoid"}, "is_accepted": true, "score": 19, "last_activity_date": 1479945397, "creation_date": 1479945397, "answer_id": 40776087, "question_id": 40776020, "link": "https://stackoverflow.com/questions/40776020/is-there-any-way-to-restrict-a-generic-type-to-one-of-several-types/40776087#40776087", "title": "Is there any way to restrict a generic type to one of several types?", "body": "<p>For references into an array usually you'd just use a <code>usize</code> rather than different integer types.</p>\n\n<p>However, to do what you are after you can create a new trait, implement that trait for <code>u16</code>, <code>u32</code> and <code>u64</code> and then restrict T to your new trait.</p>\n\n<pre><code>pub trait MyNewTrait {}\n\nimpl MyNewTrait for u16 {}\nimpl MyNewTrait for u32 {}\nimpl MyNewTrait for u64 {}\n\nstruct Foo&lt;T: MyNewTrait&gt; { ... }\n</code></pre>\n\n<p>You may then also add methods onto <code>MyNewTrait</code> and the <code>impl</code>s to encapsulate the logic specific to <code>u16</code>, <code>u32</code> and <code>u64</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "is_accepted": false, "score": 8, "last_activity_date": 1538343798, "creation_date": 1538343798, "answer_id": 52582432, "question_id": 40776020, "link": "https://stackoverflow.com/questions/40776020/is-there-any-way-to-restrict-a-generic-type-to-one-of-several-types/52582432#52582432", "title": "Is there any way to restrict a generic type to one of several types?", "body": "<p>Sometimes you may want to use an <code>enum</code> rather than a generic type with a trait bound. For example:</p>\n\n<pre><code>enum Unsigned {\n    U16(u16),\n    U32(u32),\n    U64(u64),\n}\n\nstruct Foo { x: Unsigned, ... };\n</code></pre>\n\n<p>One advantage of making a new type over implementing a new trait for existing types is that you can add foreign traits and inherent behavior to the new type. You can implement any traits you like for <code>Unsigned</code>, like <code>Add</code>, <code>Mul</code>, etc. and even <code>SliceIndex&lt;[T]&gt;</code> so that it can be used to index into a slice. When <code>Foo</code> contains an <code>Unsigned</code>, implementing traits  on <code>Unsigned</code> doesn't affect the signature of <code>Foo</code> like it would to add them as bounds on <code>Foo</code>'s parameter (e.g. <code>Foo&lt;T: Add&lt;Output=Self&gt; + PartialCmp + ...&gt;</code>). On the other hand, you do still have to implement each trait.</p>\n\n<p>Another thing to note: while you can generally always make a new type and implement a trait for it, an enum is \"closed\": you can't add new types to <code>Unsigned</code> without touching the rest of its implementation, like you could if you used a trait. This may be a good thing or a bad thing depending on what your design calls for.</p>\n\n<hr>\n\n<p>\"Performance reasons\" is a bit ambiguous, but if you're thinking of storing a lot of <code>Unsigned</code>s that will all be the same internal type, and this:</p>\n\n<pre><code>struct Foo([Unsigned; 1_000_000]);\n</code></pre>\n\n<p>would waste a ton of space over storing a million <code>u16</code>s, you can still make <code>Foo</code> generic! Just implement <code>From&lt;u16&gt;</code>, <code>From&lt;u32&gt;</code>, and <code>From&lt;u64&gt;</code> for <code>Unsigned</code> and write this instead:</p>\n\n<pre><code>struct Foo&lt;T: Into&lt;Unsigned&gt;&gt;([T; 1_000_000]);\n</code></pre>\n\n<p>Now you only have one simple trait bound on <code>T</code>, you're not wasting space for tags and padding, and functions that deal with <code>T</code> can always convert it to <code>Unsigned</code> to do calculations with. The cost of the conversion may even be optimized away entirely.</p>\n\n<h3>See Also</h3>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/52240099/should-i-use-enum-to-emulate-the-polymorphism-or-use-trait-with-boxtrait-inste\">Should I use enum to emulate the polymorphism or use trait with Box&lt;trait> instead?</a></li>\n</ul>\n"}], "owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3600, "favorite_count": 1, "accepted_answer_id": 40776087, "answer_count": 2, "score": 20, "last_activity_date": 1538343798, "creation_date": 1479944879, "last_edit_date": 1538338200, "question_id": 40776020, "link": "https://stackoverflow.com/questions/40776020/is-there-any-way-to-restrict-a-generic-type-to-one-of-several-types", "title": "Is there any way to restrict a generic type to one of several types?", "body": "<p>I'm trying to create a generic struct which uses an \"integer type\" for references into an array. For performance reasons I'd like to be able to specify easily whether to use <code>u16</code>, <code>u32</code> or <code>u64</code>. Something like this (which obviously isn't valid Rust code):</p>\n\n<pre><code>struct Foo&lt;T: u16 or u32 or u64&gt; { ... }\n</code></pre>\n\n<p>Is there any way to express this?</p>\n"}, {"tags": ["c", "rust"], "comments": [{"owner": {"reputation": 11381, "user_id": 4774918, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/kQQAl.jpg?s=128&g=1", "display_name": "too honest for this site", "link": "https://stackoverflow.com/users/4774918/too-honest-for-this-site"}, "edited": false, "score": 7, "creation_date": 1479924234, "post_id": 40771335, "comment_id": 68766622, "body": "That&#39;s not a constant, but a preprocessor macro. C does not have symbolic constants other than <i>enum-constants</i>."}, {"owner": {"reputation": 507143, "user_id": 1048572, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/7f2c4de95e8f4f8f5a71c3aaf0ed312a?s=128&d=identicon&r=PG", "display_name": "Bergi", "link": "https://stackoverflow.com/users/1048572/bergi"}, "edited": false, "score": 0, "creation_date": 1523907979, "post_id": 40771335, "comment_id": 86745574, "body": "See also <a href=\"https://stackoverflow.com/q/33529030/1048572\">Convert simple C #define&#39;s into Rust constants</a>"}], "answers": [{"comments": [{"owner": {"reputation": 16513, "user_id": 95642, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/36cf75fa7751ef674df65ab65cecd255?s=128&d=identicon&r=PG", "display_name": "Drew LeSueur", "link": "https://stackoverflow.com/users/95642/drew-lesueur"}, "edited": false, "score": 0, "creation_date": 1479927163, "post_id": 40771725, "comment_id": 68768208, "body": "Thank you for the answer. &quot;The best and simplest option is copy the value into your program.&quot; That&#39;s what I was thinking, I wanted to make sure I wasn&#39;t missing anything."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1479925426, "last_edit_date": 1495542270, "creation_date": 1479925426, "answer_id": 40771725, "question_id": 40771335, "link": "https://stackoverflow.com/questions/40771335/how-do-i-access-a-c-constant-in-rust/40771725#40771725", "title": "How do I access a C constant in Rust?", "body": "<p>I'm no Gopher, but <strong>Go</strong> doesn't understand C <code>#define</code>s either. Instead, <a href=\"https://dave.cheney.net/2016/01/18/cgo-is-not-go\" rel=\"nofollow noreferrer\"><strong>cgo</strong> does</a> (at least <a href=\"https://stackoverflow.com/q/28442524/155423\">some subsets of them</a>).</p>\n\n<p>The best and simplest option is copy the value into your program. Note that you <em>have to define a size</em>:</p>\n\n<pre><code>const INT_CANCEL: u8 = 2;\n</code></pre>\n\n<p>You could also create a macro if you really needed to be able to wait for the type to be decided at runtime, but that's not common.</p>\n\n<p>You could also create <a href=\"http://doc.crates.io/build-script.html\" rel=\"nofollow noreferrer\">a build script</a> that <a href=\"https://crates.io/crates/gcc\" rel=\"nofollow noreferrer\">compiles some C code</a> that includes the header and prints out the appropriate Rust code:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n#include \"myheader.h\"\n\nint main(int argc, char *argv[]) {\n  printf(\"const INT_CANCEL: u8 = %d;\\n\", INT_CANCEL);\n\n  return 0;\n}\n</code></pre>\n\n<p>That Rust code can then be included back into your project.</p>\n\n<hr>\n\n<p>You may also try to modify <a href=\"https://github.com/Yamakaky/rust-bindgen\" rel=\"nofollow noreferrer\">rust-bindgen</a> so that does something similar to cgo and attempts to automatically create these constants.</p>\n"}], "owner": {"reputation": 16513, "user_id": 95642, "user_type": "registered", "accept_rate": 79, "profile_image": "https://www.gravatar.com/avatar/36cf75fa7751ef674df65ab65cecd255?s=128&d=identicon&r=PG", "display_name": "Drew LeSueur", "link": "https://stackoverflow.com/users/95642/drew-lesueur"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 265, "favorite_count": 0, "accepted_answer_id": 40771725, "answer_count": 1, "score": -1, "last_activity_date": 1479925426, "creation_date": 1479923955, "last_edit_date": 1479924358, "question_id": 40771335, "link": "https://stackoverflow.com/questions/40771335/how-do-i-access-a-c-constant-in-rust", "title": "How do I access a C constant in Rust?", "body": "<p>I am trying to use a C constant in Rust. Here is a portion of the C code:</p>\n\n<pre><code>#define INT_CANCEL 2\n</code></pre>\n\n<p>In Go, I can do something like this:</p>\n\n<pre class=\"lang-golang prettyprint-override\"><code>return C.INT_CANCEL\n</code></pre>\n\n<p>How would I do something similar in Rust?</p>\n\n<p>I've tried something like</p>\n\n<pre><code>#[link(name = \"name_of_lib\")]\nextern {\n    int INT_CANCEL\n}\n</code></pre>\n\n<p>But that doesn't compile.</p>\n"}, {"tags": ["struct", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1479913656, "post_id": 40767894, "comment_id": 68759847, "body": "Did you mean <code>&amp;mut self</code>, because as it is you are taking the node by value... (which you would have noticed if your <code>Node</code> was not <code>Copy</code>)."}, {"owner": {"reputation": 877, "user_id": 3666903, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/1i0Z6.jpg?s=128&g=1", "display_name": "bl4ckb0ne", "link": "https://stackoverflow.com/users/3666903/bl4ckb0ne"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1479913763, "post_id": 40767894, "comment_id": 68759919, "body": "@MatthieuM. using <code>&amp;mut self</code> gives me an error about borrowed content when I try to copy the value in <code>self.data.unwrap()</code> into <code>tmp</code>"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1479913921, "post_id": 40767894, "comment_id": 68760039, "body": "That&#39;s a separate issue; taking <code>&amp;mut self</code> is the only way to modify the receptor of the method. Another solution is to take <code>mut self</code> and return <code>Node&lt;T&gt;</code>, then change the call site to <code>root = root.insert(...);</code>. We can help solve either situation, so just pick whichever you prefer."}, {"owner": {"reputation": 877, "user_id": 3666903, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/1i0Z6.jpg?s=128&g=1", "display_name": "bl4ckb0ne", "link": "https://stackoverflow.com/users/3666903/bl4ckb0ne"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1479914012, "post_id": 40767894, "comment_id": 68760096, "body": "I know that returning <code>Node&lt;T&gt;</code> is a way to solve the problem, but I want to know if there&#39;s a way to do it more OOP-like"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1479914163, "post_id": 40767894, "comment_id": 68760202, "body": "@MatthieuM. this is going to be a sticky question to answer. Note that OP has planted a giant landmine for <b>memory unsafety</b> via <code>self.left = &amp;mut Node::new(data)</code>. As soon as those values are dereferenced.... <b>BOOOOOM</b>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1479914409, "post_id": 40767894, "comment_id": 68760363, "body": "@Bl4ckb0ne: OOP is a very ill-defined term... may I take it that what you mean is that you&#39;d like <code>root.insert(...)</code> to modify <code>root</code>, which <b>requires</b> taking <code>&amp;mut self</code> and you are willing to change the code to make it compile and run correctly?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479914430, "post_id": 40767894, "comment_id": 68760375, "body": "@Shepmaster: It&#39;s not unsafe, he never dereferences the pointers :D"}], "answers": [{"comments": [{"owner": {"reputation": 877, "user_id": 3666903, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/1i0Z6.jpg?s=128&g=1", "display_name": "bl4ckb0ne", "link": "https://stackoverflow.com/users/3666903/bl4ckb0ne"}, "edited": false, "score": 0, "creation_date": 1479916164, "post_id": 40768633, "comment_id": 68761543, "body": "Yes, I am sure that <code>data</code> needs to be an option for the insertion. Otherwise, do you know why it works with <code>Box</code> and not with raw pointers? And thanks for the working answer"}, {"owner": {"reputation": 877, "user_id": 3666903, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/1i0Z6.jpg?s=128&g=1", "display_name": "bl4ckb0ne", "link": "https://stackoverflow.com/users/3666903/bl4ckb0ne"}, "edited": false, "score": 0, "creation_date": 1479916492, "post_id": 40768633, "comment_id": 68761760, "body": "I modified a little bit your code for what I want to do, and <a href=\"https://play.rust-lang.org/?gist=d4243b01ef87637a73aa79cc3fe87ec6&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">it works</a> like a charm, thanks!"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 877, "user_id": 3666903, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/1i0Z6.jpg?s=128&g=1", "display_name": "bl4ckb0ne", "link": "https://stackoverflow.com/users/3666903/bl4ckb0ne"}, "edited": false, "score": 3, "creation_date": 1479916670, "post_id": 40768633, "comment_id": 68761900, "body": "@Bl4ckb0ne: assigning <code>None</code> to <code>self.data</code> after <code>take</code> is unnecessary; <code>take</code> is already taking the content of the <code>Option</code> and replacing it by <code>None</code>. As for raw pointers: you were inadvertently creating a pointer to a variable on the stack, which would have crashed when you tried to dereference it. Raw pointers are powerful, and unsafe (dereferencing them requires the <code>unsafe</code> keyword). <code>Box</code> instead will put the content on the heap and manage the lifetime for you."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 3, "last_activity_date": 1479915789, "creation_date": 1479915789, "answer_id": 40768633, "question_id": 40767894, "link": "https://stackoverflow.com/questions/40767894/data-structure-is-not-modified-when-calling-a-method-that-takes-self/40768633#40768633", "title": "Data structure is not modified when calling a method that takes `self`", "body": "<p>Since you appear to be quite confused, let's get you started!</p>\n\n<p>First of all, there is no reason to use raw pointers. Furthermore, I advise AGAINST using <code>Copy</code> as it just hides ownership issues. Finally, it's much easier to derive <code>Debug</code> than implement the formatting manually (and it allows experimenting with the layout of the struct in a more automated fashion).</p>\n\n<pre><code>#[derive(Debug)]\nstruct Node&lt;T&gt; {\n    data: Option&lt;T&gt;, // are you sure about using Option here?\n    left: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n    right: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\n</code></pre>\n\n<p>So, instead of raw pointers, we use a <code>Box</code> pointer which we place into an <code>Option</code> to handle the null case.</p>\n\n<p>The construction is now:</p>\n\n<pre><code>impl&lt;T&gt; Node&lt;T&gt; {\n    fn new(data: T) -&gt; Node&lt;T&gt; {\n        Node {\n            data: Some(data),\n            left: None,\n            right: None,\n        }\n    }\n}\n</code></pre>\n\n<p>Nothing outstanding, let's move on to <code>insert</code>:</p>\n\n<pre><code>impl&lt;T&gt; Node&lt;T&gt; {\n    fn insert(&amp;mut self, data: T) {\n        let current = self.data.take().expect(\"Cannot insert in empty node!\");\n\n        self.left = Some(Box::new(Node::new(current)));\n        self.right = Some(Box::new(Node::new(data)));\n    }\n}\n</code></pre>\n\n<p>And we can move on to the display (using <code>Debug</code> with <code>\"{:?}\"</code>):</p>\n\n<pre><code>fn main() {\n    let mut root: Node&lt;i32&gt; = Node::new(32);\n    println!(\"Root before insert : {:?}\", root);\n    root.insert(42);\n    println!(\"Root after insert: {:?}\", root);\n}\n</code></pre>\n\n<p>And <a href=\"https://play.rust-lang.org/?gist=06dad4332e7ce48365464f792f2ebb83&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">it works</a>!</p>\n"}], "owner": {"reputation": 877, "user_id": 3666903, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/1i0Z6.jpg?s=128&g=1", "display_name": "bl4ckb0ne", "link": "https://stackoverflow.com/users/3666903/bl4ckb0ne"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 69, "favorite_count": 0, "accepted_answer_id": 40768633, "answer_count": 1, "score": 0, "last_activity_date": 1479916014, "creation_date": 1479913551, "last_edit_date": 1479916014, "question_id": 40767894, "link": "https://stackoverflow.com/questions/40767894/data-structure-is-not-modified-when-calling-a-method-that-takes-self", "title": "Data structure is not modified when calling a method that takes `self`", "body": "<p>I am writing a binary tree structure, and I have problems at the <code>insert</code> function. After calling the function to insert data in my node, the node is not modified.</p>\n\n<pre><code>use std::ptr;\n\n#[derive(Clone, Copy)]\nstruct Node&lt;T&gt; {\n    data: Option&lt;T&gt;,\n    left: *mut Node&lt;T&gt;,\n    right: *mut Node&lt;T&gt;,\n}\n\nimpl&lt;T&gt; Node&lt;T&gt; {\n    pub fn new(data: T) -&gt; Node&lt;T&gt; {\n        Node {\n            data: Some(data),\n            left: ptr::null_mut(),\n            right: ptr::null_mut(),\n        }\n    }\n\n    pub fn insert(mut self, data: T) {\n        let tmp = self.data.unwrap();\n        self.data = None;\n\n        self.left = &amp;mut Node::new(data);\n        self.right = &amp;mut Node::new(tmp);\n    }\n}\n\nimpl&lt;T: std::fmt::Display&gt; std::fmt::Display for Node&lt;T&gt;\n    where T: std::fmt::Debug\n{\n    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {\n        match self.data {\n            Some(ref x) =&gt; {\n                write!(f, \"Node data: {}, left: {}, right: {}\", x, \n                        if self.left.is_null() {\"null\"} else {\"not null\"}, \n                        if self.right.is_null() {\"null\"} else {\"not null\"}, \n                    )\n            }\n            None =&gt; {\n                write!(f, \"Node data: None, left: {}, right: {}\",  \n                        if self.left.is_null() {\"null\"} else {\"not null\"}, \n                        if self.right.is_null() {\"null\"} else {\"not null\"}, \n                    )\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut root: Node&lt;i32&gt; = Node::new(32);\n    println!(\"Root before insert : {}\", root);\n    root.insert(42);\n    println!(\"Root after insert: {}\", root);\n}\n</code></pre>\n\n<p>And a trace of execution</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Root before insert : Node data: 32, left: null, right: null\nRoot after insert : Node data: 32, left: null, right: null\n</code></pre>\n\n<p>My node is not modified after the function insert. What can I do to solve this?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1479913483, "post_id": 40767815, "comment_id": 68759718, "body": "What do you want the result to be if there are NaN/inf?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1479914070, "post_id": 40767815, "comment_id": 68760139, "body": "FYI, there&#39;s a <a href=\"https://doc.rust-lang.org/std/f64/constant.NAN.html\" rel=\"nofollow noreferrer\"><code>NAN</code> constant</a>; you don&#39;t need to involve parsing."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479915367, "post_id": 40767815, "comment_id": 68761005, "body": "Potentially relevant information is available in <a href=\"http://stackoverflow.com/q/39638363/155423\">stackoverflow.com/q/39638363/155423</a>; <a href=\"http://stackoverflow.com/q/26489701/155423\">stackoverflow.com/q/26489701/155423</a>; <a href=\"http://stackoverflow.com/q/28247990/155423\">stackoverflow.com/q/28247990/155423</a>."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 6, "last_activity_date": 1479913803, "creation_date": 1479913803, "answer_id": 40767977, "question_id": 40767815, "link": "https://stackoverflow.com/questions/40767815/how-do-i-check-whether-a-vector-is-equal-to-another-vector-that-contains-nan-and/40767977#40767977", "title": "How do I check whether a vector is equal to another vector that contains NaN and inf?", "body": "<p>You might be interested in the <a href=\"https://doc.rust-lang.org/std/primitive.f64.html#method.is_nan\" rel=\"noreferrer\"><code>is_nan</code></a> method.</p>\n\n<pre><code>assert!(nan.is_nan());\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 10, "last_activity_date": 1479915753, "last_edit_date": 1479915753, "creation_date": 1479914215, "answer_id": 40768104, "question_id": 40767815, "link": "https://stackoverflow.com/questions/40767815/how-do-i-check-whether-a-vector-is-equal-to-another-vector-that-contains-nan-and/40768104#40768104", "title": "How do I check whether a vector is equal to another vector that contains NaN and inf?", "body": "<p><code>NaN</code>s by definition compare unequal.  If you want to do something different you've got to define the comparison by yourself.  It's not too difficult; the iterator methods do most of the work for you:</p>\n\n<pre><code>fn eq_with_nan_eq(a: f64, b: f64) -&gt; bool {\n    (a.is_nan() &amp;&amp; b.is_nan()) || (a == b)\n}\n\nfn vec_compare(va: &amp;[f64], vb: &amp;[f64]) -&gt; bool {\n    (va.len() == vb.len()) &amp;&amp;  // zip stops at the shortest\n     va.iter()\n       .zip(vb)\n       .all(|(a,b)| eq_with_nan_eq(*a,*b))\n}\n\nfn main() {\n    use std::f64::NAN;\n    let a = vec![0f64, 1.0, NAN];\n    let b = vec![0f64, 2.0, NAN];\n    let c = vec![0f64, 1.0, NAN, 4.0];\n    let d = vec![0f64, 1.0, 3.0];\n\n    assert_eq!(vec_compare(&amp;a, &amp;b), false);\n    assert_eq!(vec_compare(&amp;a, &amp;a), true);\n    assert_eq!(vec_compare(&amp;a, &amp;d), false);\n    assert_eq!(vec_compare(&amp;a, &amp;c), false);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=7a0a0e0b102a9bf0b494d21b9729babb&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Playground</a></p>\n"}], "owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5857, "favorite_count": 0, "accepted_answer_id": 40768104, "answer_count": 2, "score": 8, "last_activity_date": 1479915753, "creation_date": 1479913262, "last_edit_date": 1479913558, "question_id": 40767815, "link": "https://stackoverflow.com/questions/40767815/how-do-i-check-whether-a-vector-is-equal-to-another-vector-that-contains-nan-and", "title": "How do I check whether a vector is equal to another vector that contains NaN and inf?", "body": "<p>I have a test of division, where I sometimes need to check that my results are either <code>NaN</code> or <code>inf</code>, but it seems like Rust does not consider NaN to be equal to NaN:</p>\n\n<pre><code>fn main() {\n    let nan = \"NaN\".parse::&lt;f64&gt;().unwrap();\n    println!(\"{:?}\", nan);\n    println!(\"{:?}\", nan == nan);\n} // NaN false\n</code></pre>\n\n<p>How do I compare two vectors that contain NaN and infinity to see whether they are equal?</p>\n"}, {"tags": ["vector", "reference", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1479905366, "post_id": 40764938, "comment_id": 68754138, "body": "Do you understand the difference between a value and a reference to a value?"}, {"owner": {"reputation": 493, "user_id": 6502802, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/c8105f9fd1eac6dc7a532a0a65a7fb62?s=128&d=identicon&r=PG&f=1", "display_name": "plailopo", "link": "https://stackoverflow.com/users/6502802/plailopo"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1479906447, "post_id": 40764938, "comment_id": 68754862, "body": "@MatthieuM. Ok, but how do I return the element by value? Can I clone/copy it?"}, {"owner": {"reputation": 493, "user_id": 6502802, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/c8105f9fd1eac6dc7a532a0a65a7fb62?s=128&d=identicon&r=PG&f=1", "display_name": "plailopo", "link": "https://stackoverflow.com/users/6502802/plailopo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479908392, "post_id": 40764938, "comment_id": 68756223, "body": "@Shepmaster I already tried, but not work <code>pub fn findOne(&amp;self) -&gt; Option&lt;EntryOne&gt; {self.findAll().first().cloned()}</code> no method named <code>cloned</code> found"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 11, "last_activity_date": 1517164750, "last_edit_date": 1517164750, "creation_date": 1479909307, "answer_id": 40766384, "question_id": 40764938, "link": "https://stackoverflow.com/questions/40764938/how-do-i-return-a-vector-element-from-a-rust-function/40766384#40766384", "title": "How do I return a vector element from a Rust function?", "body": "<p>Look at the signature for <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.first\" rel=\"nofollow noreferrer\"><code>Vec::first</code></a>:</p>\n\n<pre><code>fn first(&amp;self) -&gt; Option&lt;&amp;T&gt;\n</code></pre>\n\n<p>Given a reference to a vector, it will return a reference to the first item if there is one, and <code>None</code> otherwise. That means that the vector containing the values must outlive the return value, otherwise the reference would point to undefined memory.</p>\n\n<p>There are two main avenues:</p>\n\n<ol>\n<li><p>If you cannot change the vector, then you will need to make a copy of your data structure. The easiest way to do this is to annotate the structure with <code>#[derive(Clone)]</code>. Then you can call <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.cloned\" rel=\"nofollow noreferrer\"><code>Option::cloned</code></a> on the result of <code>first</code>.</p></li>\n<li><p>If you can change the vector, then you can remove the first value from it and return it. There are many ways of doing this, but the shortest code-wise is to use the <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.drain\" rel=\"nofollow noreferrer\"><code>drain</code></a> iterator.</p></li>\n</ol>\n\n\n\n<pre><code>#[derive(Debug, Clone)]\nstruct EntryOne {\n    name: String,\n    value: Option&lt;String&gt;,\n}\n\nfn find_all() -&gt; Vec&lt;EntryOne&gt; {\n    vec![\n        EntryOne {\n            name: \"foo\".to_string(),\n            value: Some(\"FooVal\".to_string()),\n        },\n        EntryOne {\n            name: \"foo2\".to_string(),\n            value: Some(\"FooVal2\".to_string()),\n        },\n        EntryOne {\n            name: \"foo3\".to_string(),\n            value: None,\n        },\n        EntryOne {\n            name: \"foo4\".to_string(),\n            value: Some(\"FooVal4\".to_string()),\n        },\n    ]\n}\n\nfn find_one_by_clone() -&gt; Option&lt;EntryOne&gt; {\n    find_all().first().cloned()\n}\n\nfn find_one_by_drain() -&gt; Option&lt;EntryOne&gt; {\n    let mut all = find_all();\n    let mut i = all.drain(0..1);\n    i.next()\n}\n\nfn main() {\n    println!(\"{:?}\", find_one_by_clone());\n    println!(\"{:?}\", find_one_by_drain());\n}\n</code></pre>\n\n<p>Additional changes:</p>\n\n<ol>\n<li>There's no need for <code>TestVec</code> if there's no state; just make functions.</li>\n<li>Rust style is <code>snake_case</code> for method and variable names.</li>\n<li>Use <code>vec!</code> to construct a vector when providing all the elements.</li>\n<li>Derive <code>Debug</code> so you can print the value.</li>\n</ol>\n\n<hr>\n\n<p>If you wanted to always get the <em>last</em> element, you can use <code>pop</code>:</p>\n\n<pre><code>fn find_one_by_pop() -&gt; Option&lt;EntryOne&gt; {\n    find_all().pop()\n}\n</code></pre>\n"}], "owner": {"reputation": 493, "user_id": 6502802, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/c8105f9fd1eac6dc7a532a0a65a7fb62?s=128&d=identicon&r=PG&f=1", "display_name": "plailopo", "link": "https://stackoverflow.com/users/6502802/plailopo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6334, "favorite_count": 0, "accepted_answer_id": 40766384, "answer_count": 1, "score": 11, "last_activity_date": 1517164750, "creation_date": 1479905059, "last_edit_date": 1517163168, "question_id": 40764938, "link": "https://stackoverflow.com/questions/40764938/how-do-i-return-a-vector-element-from-a-rust-function", "title": "How do I return a vector element from a Rust function?", "body": "<p>I would like to return an element of a vector:</p>\n\n<pre><code>struct EntryOne {\n    pub name: String,\n    pub value: Option&lt;String&gt;,\n}\n\nstruct TestVec {}\n\nimpl TestVec {\n    pub fn new() -&gt; TestVec {\n        TestVec {}\n    }\n\n    pub fn findAll(&amp;self) -&gt; Vec&lt;EntryOne&gt; {\n        let mut ret = Vec::new();\n        ret.push(EntryOne {\n            name: \"foo\".to_string(),\n            value: Some(\"FooVal\".to_string()),\n        });\n        ret.push(EntryOne {\n            name: \"foo2\".to_string(),\n            value: Some(\"FooVal2\".to_string()),\n        });\n        ret.push(EntryOne {\n            name: \"foo3\".to_string(),\n            value: None,\n        });\n        ret.push(EntryOne {\n            name: \"foo4\".to_string(),\n            value: Some(\"FooVal4\".to_string()),\n        });\n\n        ret\n    }\n\n    pub fn findOne(&amp;self) -&gt; Option&lt;EntryOne&gt; {\n        let mut list = &amp;self.findAll();\n\n        if list.len() &gt; 0 {\n            println!(\"{} elements found\", list.len());\n            list.first()\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    let test = TestVec::new();\n    test.findAll();\n    test.findOne();\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=5eba731d9b15d177b5a6b2a35e4f2a47&amp;version=stable\" rel=\"noreferrer\">playground</a>)</p>\n\n<p>I always get this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:40:13\n   |\n35 |     pub fn findOne(&amp;self) -&gt; Option&lt;EntryOne&gt; {\n   |                              ---------------- expected `std::option::Option&lt;EntryOne&gt;` because of return type\n...\n40 |             list.first()\n   |             ^^^^^^^^^^^^ expected struct `EntryOne`, found &amp;EntryOne\n   |\n   = note: expected type `std::option::Option&lt;EntryOne&gt;`\n              found type `std::option::Option&lt;&amp;EntryOne&gt;`\n</code></pre>\n\n<p>How do I return an element?</p>\n"}, {"tags": ["error-handling", "rust"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 1, "creation_date": 1479892680, "post_id": 40760168, "comment_id": 68745321, "body": "Try <code>.expect(&quot;File doesn&#39;t exist&quot;)</code> instead of <code>.unwrap()</code>."}, {"owner": {"reputation": 402, "user_id": 3809903, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/9e1c36e71e453b8ecea77f2e8127942b?s=128&d=identicon&r=PG&f=1", "display_name": "kai", "link": "https://stackoverflow.com/users/3809903/kai"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1479893990, "post_id": 40760168, "comment_id": 68746198, "body": "@ljedrz Thx, but it also <code>thread &#39;main&#39; panicked at &#39; File doesn&#39;t exist: Error { repr: Os { code: 2, message: &quot;No such file or directory&quot; } }&#39;, ..&#47;src&#47;libcore&#47;result.rs:799</code>, I wanna print only <code>File Doesn&#39;t exist</code>, is it not possible?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479908198, "post_id": 40760168, "comment_id": 68756097, "body": "Read <a href=\"https://doc.rust-lang.org/stable/book/error-handling.html\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i> chapter on error handling</a>. There&#39;s nothing special about this error."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479908356, "post_id": 40761379, "comment_id": 68756201, "body": "There&#39;s a lot of non-idiomatic Rust in this answer. The <code>match</code> should be an <code>if let</code> if you only care about one branch. There&#39;s no need to specify the type for <code>v</code>. <code>map</code> and <code>map_err</code> shouldn&#39;t be used for side effects like printing values."}, {"owner": {"reputation": 3181, "user_id": 4998184, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/29c803cb4341d0ff630cb3ca04ab7251?s=128&d=identicon&r=PG", "display_name": "eulerdisk", "link": "https://stackoverflow.com/users/4998184/eulerdisk"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479913830, "post_id": 40761379, "comment_id": 68759963, "body": "@Shepmaster When I said idiomatic, I was only talking about propagating the error, not the rest of the code whch I left almost untouched from the OP. Then it seemed to me that the OP was searching for a oneliner to get the job done, so I proposed the second solution (which is a bit ugly I know)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479913999, "post_id": 40761379, "comment_id": 68760088, "body": "Remember that answers are not for <b>only</b> the OP. They are for <i>every person that finds this Q&amp;A</i>. That&#39;s why I strive to make my answers as idiomatic as possible (or clearly indicate when they are not for whatever reason)."}, {"owner": {"reputation": 3181, "user_id": 4998184, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/29c803cb4341d0ff630cb3ca04ab7251?s=128&d=identicon&r=PG", "display_name": "eulerdisk", "link": "https://stackoverflow.com/users/4998184/eulerdisk"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479914604, "post_id": 40761379, "comment_id": 68760473, "body": "@Shepmaster Maybe you are right,but I prefer to not alienate posters rewriting half of their code, and give them a tons of answers to questions they didn&#39;t ask. I prefer to give a direct answer to only what OP asks. [There&#39;s another website for code view BTW] I will keep in mind your observations though."}], "tags": [], "owner": {"reputation": 3181, "user_id": 4998184, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/29c803cb4341d0ff630cb3ca04ab7251?s=128&d=identicon&r=PG", "display_name": "eulerdisk", "link": "https://stackoverflow.com/users/4998184/eulerdisk"}, "is_accepted": false, "score": 1, "last_activity_date": 1479908294, "last_edit_date": 1479908294, "creation_date": 1479895707, "answer_id": 40761379, "question_id": 40760168, "link": "https://stackoverflow.com/questions/40760168/how-to-handle-errors-from-the-readread-to-end-method/40761379#40761379", "title": "How to handle errors from the Read::read_to_end method?", "body": "<p>Probably the most idiomatic approach would be propagating the result outside <code>parse_file</code>, printing the error in <code>main</code>.</p>\n\n<pre><code>use std::fs::File;\nuse std::io::{Read, Error as IoError};\nuse std::path::Path;\n\nfn main() {\n    match parse_file(\"ubuntu-16.04.1-server-amd64.torrent\") {\n        Err(e) =&gt; println!(\"{}\", e),\n        _ =&gt; {}\n    }\n}\n\nfn parse_file(filename: &amp;'static str) -&gt; Result&lt;(), IoError&gt; {\n    let mut f = File::open(&amp;Path::new(filename))?;\n    let mut v: Vec&lt;u8&gt; = Vec::new();\n    let file_content = f.read_to_end(&amp;mut v);\n    println!(\"{:?}\", file_content);\n\n    Ok(())\n}\n</code></pre>\n\n<p>If you want to print the error in one line and then propagating it, you could do something like this instead:</p>\n\n<pre><code>fn main() {\n    parse_file(\"ubuntu-16.04.1-server-amd64.torrent\");\n}\n\nfn parse_file(filename: &amp;'static str) -&gt; Result&lt;(), IoError&gt; {\n    let mut f = File::open(&amp;Path::new(filename)).map_err(|e| {\n            println!(\"{}\", e);\n            e\n        })?;\n\n    let mut v: Vec&lt;u8&gt; = Vec::new();\n    let file_content = f.read_to_end(&amp;mut v);\n    println!(\"{:?}\", file_content);\n\n    Ok(())\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479908401, "post_id": 40761436, "comment_id": 68756230, "body": "There&#39;s no need to specify the type of <code>v</code>."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479908845, "post_id": 40761436, "comment_id": 68756545, "body": "No, but I don&#39;t see a problem with being explicit (it came from the question)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479914005, "post_id": 40761436, "comment_id": 68760091, "body": "Remember that answers are not for <b>only</b> the OP. They are for <i>every person that finds this Q&amp;A</i>. That&#39;s why I strive to make my answers as idiomatic as possible (or clearly indicate when they are not for whatever reason)."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 1, "last_activity_date": 1479908229, "last_edit_date": 1479908229, "creation_date": 1479895861, "answer_id": 40761436, "question_id": 40760168, "link": "https://stackoverflow.com/questions/40760168/how-to-handle-errors-from-the-readread-to-end-method/40761436#40761436", "title": "How to handle errors from the Read::read_to_end method?", "body": "<p>You should be matching on the <code>Result</code> instead of calling <code>unwrap()</code> or <code>expect()</code>.  Once you've got the error, you can either print it out or look at the <code>ErrorKind</code> if you want to handle different errors differently.</p>\n\n<pre><code>use std::fs::File;\nuse std::path::Path;\nuse std::io::Read;\n\nfn main() {\n    parse_file(\"doesnt_exist.txt\");\n}\n\nfn parse_file(filename: &amp;'static str) {\n    let mut f = match File::open(&amp;Path::new(filename)) {\n        Ok(f) =&gt; f,\n        Err(e) =&gt; {\n            use std::io::ErrorKind::*;\n            println!(\"Got error: {}\", e);\n            match e.kind() {\n                NotFound =&gt; {\n                    println!(\"File not found\");\n                }\n                k =&gt; {\n                    println!(\"Error: {:?}\", k);\n                }\n            }\n            return;\n        }\n    };\n    let mut v: Vec&lt;u8&gt; = Vec::new();\n    let file_content = f.read_to_end(&amp;mut v);\n\n    println!(\"{:?}\", file_content);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=e9862b7105a9a02e2b40ac6c33030089&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}], "owner": {"reputation": 402, "user_id": 3809903, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/9e1c36e71e453b8ecea77f2e8127942b?s=128&d=identicon&r=PG&f=1", "display_name": "kai", "link": "https://stackoverflow.com/users/3809903/kai"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 347, "favorite_count": 0, "accepted_answer_id": 40761436, "answer_count": 2, "score": -2, "last_activity_date": 1479908294, "creation_date": 1479892377, "last_edit_date": 1479908146, "question_id": 40760168, "link": "https://stackoverflow.com/questions/40760168/how-to-handle-errors-from-the-readread-to-end-method", "title": "How to handle errors from the Read::read_to_end method?", "body": "<p>I am reading a file and parsing the data:</p>\n\n<pre><code>fn main() {\n    parse_torrentfile(\"ubuntu-16.04.1-server-amd64.torrent\");\n}\n\nfn parse_file(filename: &amp;'static str) {\n    let mut f = File::open(&amp;Path::new(filename)).unwrap();\n    let mut v: Vec&lt;u8&gt; = Vec::new();\n    let file_content = f.read_to_end(&amp;mut v);\n    println!(\"{:?}\", file_content);\n}\n</code></pre>\n\n<p>If <code>ubuntu-16.04.1-server-amd64.torrent</code> is present, this works well, but if it isn't present, this error occurs: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code> thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error { repr: Os { code: 2, message: \"No such file or directory\" } }'\n</code></pre>\n\n<p>How can I print \"Not Exist File\" or \"process file parsing\"?</p>\n"}, {"tags": ["dependencies", "rust", "traits"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1479850069, "last_edit_date": 1479850069, "creation_date": 1479839809, "answer_id": 40749243, "question_id": 40749058, "link": "https://stackoverflow.com/questions/40749058/what-is-the-recommended-way-to-specify-or-import-the-signed-trait-in-rust/40749243#40749243", "title": "What is the recommended way to specify or import the Signed trait in Rust?", "body": "<p>Use the crate. The compiler will ensure that an efficient binary is created. You probably won't notice any interesting change in your file size. Cargo will ensure that actually using the crate is easy.</p>\n\n<p>The \"stability\" of the trait isn't an inherent property of the trait. Mostly, the <em>usefulness</em> of the trait is questionable. The standard library has to be conservative \u2014 anything present there has to be supported for the <strong>entire life of Rust 1.x</strong> (and there are no plans for a Rust 2.x). Adding stuff to the standard library is thus very constrained.</p>\n\n<p>This is why crates are such first-class citizens. The decision is now up to the maintainers of the num crate for how long to support the trait. If they follow semver (and they should), it should be very obvious if they ever drop support for it. Also, once you have chosen a version of the crate to compile against, it will never change until you do a <code>cargo update</code>, so you are safe to use it.</p>\n\n<p>In the worst of the worst cases, say the num crate decides to drop the trait. In that case, <em>you</em> can simply copy the implementation and produce your own crate.</p>\n"}], "owner": {"reputation": 5006, "user_id": 2023432, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/89ZPT.png?s=128&g=1", "display_name": "bright-star", "link": "https://stackoverflow.com/users/2023432/bright-star"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 81, "favorite_count": 0, "accepted_answer_id": 40749243, "answer_count": 1, "score": 1, "last_activity_date": 1479850069, "creation_date": 1479839177, "question_id": 40749058, "link": "https://stackoverflow.com/questions/40749058/what-is-the-recommended-way-to-specify-or-import-the-signed-trait-in-rust", "title": "What is the recommended way to specify or import the Signed trait in Rust?", "body": "<p>The <code>Signed</code> trait <a href=\"https://github.com/rust-lang/rust/pull/6041\" rel=\"nofollow noreferrer\">used to exist in the standard library</a>, but it's gone now. A year ago, <a href=\"https://www.reddit.com/r/rust/comments/3mcwf7/adding_unsigned_and_signed_integers/\" rel=\"nofollow noreferrer\">someone asked about implementing signed traits on reddit</a>, but the thread didn't come to a conclusion, and the author moved on to ask again on the Rust language Discourse site <a href=\"https://users.rust-lang.org/t/adding-signed-and-unsigned-integers-is-verbose-and-error-prone/6054\" rel=\"nofollow noreferrer\">with similar results</a>.</p>\n\n<p>Now there's a <code>Signed</code> trait in the <a href=\"http://rust-num.github.io/num/num/index.html\" rel=\"nofollow noreferrer\">num crate</a>, but I have two concerns:</p>\n\n<p>1) I don't really understand if importing a crate into my project has more overhead in the resulting file size, especially if I only use one trait from it.</p>\n\n<p>2) Given the apparent instability of this kind of trait, I'm now leery of adding another dependency in my project if it's not going to stay stable and compatible.</p>\n\n<p>What's the right course to chart here?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479830706, "post_id": 40746393, "comment_id": 68718763, "body": "It is a <b>very</b> bad idea to ignore the <code>Result</code> returned from <code>read_line</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479830834, "post_id": 40746393, "comment_id": 68718855, "body": "@Shepmaster: &quot;very&quot; is relative, in a one-off script it may not matter :)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1479830984, "post_id": 40746393, "comment_id": 68718938, "body": "@MatthieuM. nah, I&#39;ll be an extremist in this case: it&#39;s <b>never</b> acceptable to ignore errors. It&#39;s a simple thing to <i>handle</i> the error (<code>.expect(&quot;Could not read input&quot;)</code>). For a one-off script, I agree that <b>aborting</b> is a reasonable way to handle the error, as opposed to something more user-friendly."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479831675, "post_id": 40746393, "comment_id": 68719375, "body": "I agree with @Shepmaster - <code>unwrap()</code> is trivial to write even in a one-off script, and it can save you serious pain in cases where the error would have otherwise gone undetected."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1479832108, "post_id": 40746393, "comment_id": 68719657, "body": "@user4815162342 and I&#39;ll always advocate for <code>expect</code> over <code>unwrap</code>, just so when the failure occurs it&#39;s much easier to find it."}], "answers": [{"comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 2, "creation_date": 1479846699, "post_id": 40746497, "comment_id": 68728204, "body": "The inference in those <code>if let</code> bindings is quite extraordinary. I mean that in a good way - I learned something from this. Thanks!"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 7, "last_activity_date": 1479832665, "last_edit_date": 1479832665, "creation_date": 1479830729, "answer_id": 40746497, "question_id": 40746393, "link": "https://stackoverflow.com/questions/40746393/how-can-i-check-a-variable-entered-by-user-is-a-number-int-float/40746497#40746497", "title": "How can I check a variable entered by user is a number (int, float)?", "body": "<p>If you want to match against something then you need something to destructure on.  You can match against string slices, but only a finite set, so that doesn't help here.</p>\n\n<p>So let's have an enum to match on:</p>\n\n<pre><code>enum Value {\n    Int(isize),\n    Float(f64),\n}\nuse Value::*;  // Make the variants available without Value::\n</code></pre>\n\n<p>Then you need to parse the string into the appropriate type.  You can use the <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.parse\" rel=\"nofollow noreferrer\"><code>parse</code></a> method for each type (if you're happy with Rust's syntax for those; otherwise you might need a fancier parser):</p>\n\n<pre><code>fn parse_string(s: &amp;str) -&gt; Option&lt;Value&gt; {\n    if let Ok(i) = s.parse() {  // inferred as isize from next line\n        Some(Int(i))\n    } else if let Ok(f) = s.parse() {\n        Some(Float(f))\n    } else {\n        None\n    }\n}\n</code></pre>\n\n<p>Note that when trying parses in sequence like this the order matters; <code>\"123\"</code> would parse as an <code>f64</code> too.</p>\n\n<p>I'm turning any parse errors into <code>None</code> and using <code>Option</code> rather than <code>Result</code> because it's not clear what the error would be (since each parse can return its own); in a real application I might have a <code>ParseError</code> type.</p>\n\n<p>Now we can match on the result:</p>\n\n<pre><code>fn main() {\n    let x = \"123\";\n    match parse_string(x) {\n        Some(Int(i)) =&gt; println!(\"int {}\", i),\n        Some(Float(f)) =&gt; println!(\"float {}\", f),\n        None =&gt; println!(\"Didn't parse\"),\n    }\n    let x = \"123.5\";\n    match parse_string(x) {\n        Some(Int(i)) =&gt; println!(\"int {}\", i),\n        Some(Float(f)) =&gt; println!(\"float {}\", f),\n        None =&gt; println!(\"Didn't parse\"),\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=20f6e93a5223ef748c24f8e583699589&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Runnable playground link</a></p>\n"}], "owner": {"reputation": 1929, "user_id": 1103397, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/90a1f2332b047409597c5f61b90d5d67?s=128&d=identicon&r=PG", "display_name": "Saeed M.", "link": "https://stackoverflow.com/users/1103397/saeed-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 506, "favorite_count": 0, "accepted_answer_id": 40746497, "answer_count": 1, "score": 3, "last_activity_date": 1479832665, "creation_date": 1479830397, "last_edit_date": 1479830632, "question_id": 40746393, "link": "https://stackoverflow.com/questions/40746393/how-can-i-check-a-variable-entered-by-user-is-a-number-int-float", "title": "How can I check a variable entered by user is a number (int, float)?", "body": "<p>How can I check a variable (entered by user) is a number such as an int, float, or something else?</p>\n\n<p>I want to do this with a <code>match</code> expression:</p>\n\n<pre><code>let mut input = String::new();\nio::stdin().read_line(&amp;mut input);\nlet result = match input {\n    // !!??     \n}\n</code></pre>\n\n<p>is it possible by <code>match</code>? </p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 2, "creation_date": 1479822661, "post_id": 40743009, "comment_id": 68712764, "body": "This <a href=\"http://smallcultfollowing.com/babysteps/blog/2016/09/24/intersection-impls/\" rel=\"nofollow noreferrer\">blog post</a> and the <a href=\"https://internals.rust-lang.org/t/blog-post-intersection-impls/4129\" rel=\"nofollow noreferrer\">internals thread about it</a> have a lot of discussion about it.  The summary in general is &quot;not yet&quot;, but there might be some ideas in there that might help."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1479886173, "post_id": 40743009, "comment_id": 68741632, "body": "@ChrisEmerson: Maybe it would be worth making this an answer?"}], "answers": [{"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 3, "last_activity_date": 1479894967, "creation_date": 1479894967, "answer_id": 40761087, "question_id": 40743009, "link": "https://stackoverflow.com/questions/40743009/how-can-i-implement-trait-b-for-all-types-that-implement-trait-a-if-both-traits/40761087#40761087", "title": "How can I implement trait B for all types that implement trait A if both traits are implemented for references?", "body": "<p>There has been some <a href=\"https://internals.rust-lang.org/t/blog-post-intersection-impls/4129\" rel=\"nofollow noreferrer\">discussion on the Rust internals forum</a> on this topic, starting with <a href=\"http://smallcultfollowing.com/babysteps/blog/2016/09/24/intersection-impls/\" rel=\"nofollow noreferrer\">a blog post by Nicholas Matsakis</a> about how to handle the issue of overlapping trait implementations.</p>\n\n<p>Today, (unstable) Rust has <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md\" rel=\"nofollow noreferrer\">some impl specialisation</a>, but that only works for strictly more specific impls of a more generic one.</p>\n\n<p>So I think the answer is that there isn't a good way to do it today, but at some point in the future there's a good chance that Rust will evolve to allow expressing overlapping trait impls.</p>\n"}], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 625, "favorite_count": 0, "accepted_answer_id": 40761087, "answer_count": 1, "score": 5, "last_activity_date": 1479894967, "creation_date": 1479820973, "last_edit_date": 1479822702, "question_id": 40743009, "link": "https://stackoverflow.com/questions/40743009/how-can-i-implement-trait-b-for-all-types-that-implement-trait-a-if-both-traits", "title": "How can I implement trait B for all types that implement trait A if both traits are implemented for references?", "body": "<p>We have two traits <code>A</code> and <code>B</code> for which</p>\n\n<ol>\n<li>I can trivially implement <code>B</code> for all types that implement <code>A</code>.</li>\n<li>I can trivially implement <code>A</code> for references to any type implementing <code>A</code>.</li>\n<li>I can trivially implement <code>B</code> for references to any type implementing <code>B</code>.</li>\n</ol>\n\n<p>Actually doing all three leads to a conflict, because now references to types that implement <code>A</code> would have two implementations of <code>B</code> for them. One due to the <code>impl&lt;T: A&gt; A for &amp;T</code> and one transitively due to the <code>impl&lt;T: A&gt; B for T</code> (and then the <code>impl&lt;T: B&gt; B for &amp;T</code>.</p>\n\n<p>I can't remove the <code>impl&lt;T: B&gt; B for &amp;T</code>, because there might be types that implement <code>B</code> but not <code>A</code></p>\n\n<p>Here's an example code exhibiting the behaviour.</p>\n\n<pre><code>trait A {}\ntrait B {}\n\nimpl&lt;'a, T: A&gt; A for &amp;'a T {}\nimpl&lt;T: A&gt; B for T {}\n\nimpl&lt;'a, T: B&gt; B for &amp;'a T {}\n</code></pre>\n\n<p>which results in the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0119]: conflicting implementations of trait `B` for type `&amp;_`:\n  |\n  | impl&lt;T: A&gt; B for T {}\n  | --------------------- first implementation here\n  | impl&lt;'a, T: B&gt; B for &amp;'a T {}\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&amp;_`\n</code></pre>\n\n<p>Is it possible to use the Rust typesystem in a way to ensure that when there is an <code>impl B for &amp;A</code>, we don't create one for <code>&amp;B</code>?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 4, "creation_date": 1479818462, "post_id": 40741931, "comment_id": 68709972, "body": "See <a href=\"https://doc.rust-lang.org/book/deref-coercions.html#deref-and-method-calls\" rel=\"nofollow noreferrer\">The Rust Reference</a>."}, {"owner": {"reputation": 231, "user_id": 2490538, "user_type": "registered", "accept_rate": 67, "profile_image": "https://i.stack.imgur.com/i6A7T.png?s=128&g=1", "display_name": "uetoyo", "link": "https://stackoverflow.com/users/2490538/uetoyo"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1479820494, "post_id": 40741931, "comment_id": 68711310, "body": "Exactly what I need!"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 3, "creation_date": 1479821914, "post_id": 40741931, "comment_id": 68712241, "body": "@ljedrz: The pun is not lost on me."}], "owner": {"reputation": 231, "user_id": 2490538, "user_type": "registered", "accept_rate": 67, "profile_image": "https://i.stack.imgur.com/i6A7T.png?s=128&g=1", "display_name": "uetoyo", "link": "https://stackoverflow.com/users/2490538/uetoyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 69, "favorite_count": 0, "closed_date": 1479822642, "answer_count": 0, "score": 2, "last_activity_date": 1479822611, "creation_date": 1479817866, "last_edit_date": 1479822611, "question_id": 40741931, "link": "https://stackoverflow.com/questions/40741931/why-is-it-allowed-to-pass-the-parameter-value-by-reference-with-the-duplicated-s", "closed_reason": "Duplicate", "title": "Why is it allowed to pass the parameter value by reference with the duplicated sign &amp;?", "body": "<p>Why is it allowed to pass the parameter value by reference with the duplicated sign <code>&amp;</code> ?</p>\n\n<pre><code>fn by_ref(v: &amp;u64) -&gt; u64 {\n    v + 1\n}\n\nfn main() {\n    println!(\"{}\", by_ref(&amp;&amp;&amp;1));\n}\n</code></pre>\n"}, {"tags": ["rust", "traits"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1479813157, "post_id": 40740060, "comment_id": 68706533, "body": "Your example doesn&#39;t quite stand on its own as a minimal example, but I think the answer would be that you haven&#39;t constrained <code>T</code> to implement <code>Entity</code> in <code>DbQuery</code> and/or <code>DbMapper::find</code>."}, {"owner": {"reputation": 493, "user_id": 6502802, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/c8105f9fd1eac6dc7a532a0a65a7fb62?s=128&d=identicon&r=PG&f=1", "display_name": "plailopo", "link": "https://stackoverflow.com/users/6502802/plailopo"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1479814112, "post_id": 40740060, "comment_id": 68707169, "body": "Sorry, I&#39;ve use the minimal code to explain it. Unfortunately I&#39;ve already tried with Entity instead of T but I receive the same error"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1479814248, "post_id": 40740060, "comment_id": 68707249, "body": "Hi - it&#39;s somewhat minimal but it&#39;s not complete enough to put into play.rust-lang.org and try to compile it and get the same error, so it&#39;s a bit hard to be sure."}], "answers": [{"comments": [{"owner": {"reputation": 493, "user_id": 6502802, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/c8105f9fd1eac6dc7a532a0a65a7fb62?s=128&d=identicon&r=PG&f=1", "display_name": "plailopo", "link": "https://stackoverflow.com/users/6502802/plailopo"}, "edited": false, "score": 0, "creation_date": 1479817860, "post_id": 40741348, "comment_id": 68709537, "body": "Yeah!!! ThankU very mutch. I&#39;m a new bie on Rust. But why not work with Entity instead of T?"}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 493, "user_id": 6502802, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/c8105f9fd1eac6dc7a532a0a65a7fb62?s=128&d=identicon&r=PG&f=1", "display_name": "plailopo", "link": "https://stackoverflow.com/users/6502802/plailopo"}, "edited": false, "score": 0, "creation_date": 1479846392, "post_id": 40741348, "comment_id": 68728014, "body": "Because <code>T</code> has no context in that method until you give it some explicitly. From the compilers perspective, you have said &quot;Here is a type T... it could be any type&quot;. The compiler cannot know that the type implements a map method. By giving it a hint that it is an Entity type, the compiler knows that it can call map."}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": true, "score": 3, "last_activity_date": 1479816166, "creation_date": 1479816166, "answer_id": 40741348, "question_id": 40740060, "link": "https://stackoverflow.com/questions/40740060/use-trait-as-interface-for-database-entity/40741348#40741348", "title": "Use trait as interface for database entity", "body": "<p><a href=\"https://play.rust-lang.org/?gist=2edb1c01c9564ad8db00af04d848f2c7&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Here is a version of your code that runs on the playground</a> and replicates your issue:</p>\n\n<pre><code>pub struct QueryResult;\npub struct Value;\npub struct Pagination;\npub struct DbMapper;\n\npub trait Entity {\n    fn map(&amp;self, Result&lt;QueryResult, ()&gt;) -&gt; Self;\n}\n\npub struct DbQuery&lt;T&gt; {\n    pub sql: String,\n    pub params: Vec&lt;Value&gt;,\n    pub limit: i32,\n    pub paged: Option&lt;Pagination&gt;,\n    pub entity: T,\n}\n\npub struct Settings {\n    pub name: String,\n    pub value: Option&lt;String&gt;,\n}\n\nimpl Entity for Settings {\n    fn map(&amp;self, result: Result&lt;QueryResult, ()&gt;) -&gt; Settings {\n        // ...\n        Settings {\n            name: \"hello\".to_string(),\n            value: None,\n        }\n    }\n}\n\nimpl DbMapper {\n    // ...\n\n    pub fn find&lt;T&gt;(&amp;self, query: DbQuery&lt;T&gt;) -&gt; Option&lt;Vec&lt;T&gt;&gt; {\n        println!(\"query find SQL: {}\", query.sql);\n\n        // ########## attempt to call map()\n        let _ = query.entity.map(Ok(QueryResult {}));\n\n        let ret = Vec::new();\n        Some(ret)\n\n    }\n}\n\nfn main() {}\n</code></pre>\n\n<p>The problem is that <code>T</code> in the <code>DbQuery&lt;T&gt;</code> argument in the <code>find</code> method has no idea that <code>T</code> is an <code>Entity</code> type. So we need to tell it:</p>\n\n<pre><code>pub fn find&lt;T&gt;(&amp;self, query: DbQuery&lt;T&gt;) -&gt; Option&lt;Vec&lt;T&gt;&gt;\n    where T: Entity\n{\n    // ... code here ...\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=7777c626c71589b4cadc8cb099473b1a&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">This now compiles and runs</a>.</p>\n\n<p>The compiler now knows that <code>T</code> is an <code>Entity</code> of some description, and it can call the <code>map</code> method on it.</p>\n"}], "owner": {"reputation": 493, "user_id": 6502802, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/c8105f9fd1eac6dc7a532a0a65a7fb62?s=128&d=identicon&r=PG&f=1", "display_name": "plailopo", "link": "https://stackoverflow.com/users/6502802/plailopo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 299, "favorite_count": 0, "accepted_answer_id": 40741348, "answer_count": 1, "score": 1, "last_activity_date": 1479840141, "creation_date": 1479812267, "last_edit_date": 1479840141, "question_id": 40740060, "link": "https://stackoverflow.com/questions/40740060/use-trait-as-interface-for-database-entity", "title": "Use trait as interface for database entity", "body": "<p>I am trying to make an <code>Entity</code> interface for dynamically mapping a database result into a Rust struct:</p>\n\n<pre><code>pub trait Entity {\n    fn map(&amp;self, Result&lt;QueryResult&gt;) -&gt; Self;\n}\n\npub struct DbQuery&lt;T&gt; {\n    pub sql: String,\n    pub params: Vec&lt;Value&gt;,\n    pub limit: i32,\n    pub paged: Option&lt;Pagination&gt;,\n    pub entity: T,\n}\n\npub struct Settings {\n    pub name: String,\n    pub value: Option&lt;String&gt;,\n}\n\nimpl Entity for Settings {\n    fn map(&amp;self, result: Result&lt;QueryResult&gt;) -&gt; Settings {\n        // ...\n        Settings {\n            name: \"hello\".to_string(),\n            value: None,\n        }\n    }\n}\n\nimpl DbMapper {\n    // ...\n\n    pub fn find&lt;T&gt;(&amp;self, query: DbQuery&lt;T&gt;) -&gt; Option&lt;Vec&lt;T&gt;&gt; {\n        println!(\"query find SQL: {}\", query.sql);\n        let mut stmt = &amp;self.pool.prepare(query.sql).unwrap();\n        let ret = Vec::new();\n        for row in stmt.execute(query.params).unwrap() {\n            ret.push(query.entity.map(row.unwrap()));\n\n        }\n\n        Some(ret)\n    }\n}\n</code></pre>\n\n<p>But I get an error:</p>\n\n<blockquote>\n  <p>error: no method named <code>map</code> found for type <code>T</code> in the current scope<br>\n  ret.push(query.entity.map(row.unwrap()));    |<br>\n  note: the method <code>map</code> exists but the following trait\n  bounds were not satisfied: <code>T : std::iter::Iterator</code>    = help: items\n  from traits can only be used if the trait is implemented and in scope;\n  the following traits define an item <code>map</code>, perhaps you need to\n  implement one of them:    = help: candidate #1:\n  <code>models::holders::database::Entity</code>    = help: candidate #2:\n  <code>std::iter::Iterator</code></p>\n</blockquote>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 3, "creation_date": 1479763360, "post_id": 40728768, "comment_id": 68686554, "body": "Maybe <a href=\"https://doc.rust-lang.org/std/borrow/enum.Cow.html\" rel=\"nofollow noreferrer\"><code>Cow</code></a>? Feel free to write an answer about this, if it helps..."}], "answers": [{"comments": [{"owner": {"reputation": 359, "user_id": 3443041, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/54e85dd5f242a00e34839ae6bb34c5cf?s=128&d=identicon&r=PG&f=1", "display_name": "TheBusyTypist", "link": "https://stackoverflow.com/users/3443041/thebusytypist"}, "edited": false, "score": 0, "creation_date": 1479763285, "post_id": 40729212, "comment_id": 68686516, "body": "Thank you for your reply. But I thought we still dynamically allocate a copy of <code>&quot;a&quot;</code> for <code>name</code>, which I think is not necessary. Is it possible to eliminate  this copy?"}, {"owner": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "reply_to_user": {"reputation": 359, "user_id": 3443041, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/54e85dd5f242a00e34839ae6bb34c5cf?s=128&d=identicon&r=PG&f=1", "display_name": "TheBusyTypist", "link": "https://stackoverflow.com/users/3443041/thebusytypist"}, "edited": false, "score": 0, "creation_date": 1479763976, "post_id": 40729212, "comment_id": 68686878, "body": "Ah, I didn&#39;t know that this was a requirement. It sounds like <code>Cow</code> is your best bet after all."}], "tags": [], "owner": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "is_accepted": false, "score": 0, "last_activity_date": 1479761764, "creation_date": 1479761764, "answer_id": 40729212, "question_id": 40728768, "link": "https://stackoverflow.com/questions/40728768/how-can-i-own-a-string-through-reference-if-its-lifetime-is-static/40729212#40729212", "title": "How can I own a string through reference if its lifetime is static?", "body": "<p>What you can do to allow for a mix of types is use the <a href=\"https://doc.rust-lang.org/std/convert/trait.Into.html\" rel=\"nofollow noreferrer\"><code>Into</code></a> trait. This is versatile in that it makes sure a safe conversion happens between the types.</p>\n\n<p>A <code>str</code> slice can be converted \"into\" an owned <code>String</code> as such.</p>\n\n<p>Some test code to demonstrate it:</p>\n\n<pre><code>#[derive(Debug)]\nstruct Test {\n    name: String,\n}\n\nimpl Test {\n    pub fn new&lt;T: Into&lt;String&gt;&gt;(t: T) -&gt; Test {\n        Test { name: t.into() }\n    }\n}\n\nfn main() {\n    let t = Test::new(\"a\");\n    println!(\"{:?}\", t);\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 359, "user_id": 3443041, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/54e85dd5f242a00e34839ae6bb34c5cf?s=128&d=identicon&r=PG&f=1", "display_name": "TheBusyTypist", "link": "https://stackoverflow.com/users/3443041/thebusytypist"}, "edited": false, "score": 0, "creation_date": 1479763740, "post_id": 40729658, "comment_id": 68686755, "body": "Could you also give more information on the size of <code>enum Name</code>?"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 359, "user_id": 3443041, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/54e85dd5f242a00e34839ae6bb34c5cf?s=128&d=identicon&r=PG&f=1", "display_name": "TheBusyTypist", "link": "https://stackoverflow.com/users/3443041/thebusytypist"}, "edited": false, "score": 1, "creation_date": 1479764089, "post_id": 40729658, "comment_id": 68686945, "body": "@TheBusyTypist As always in Rust, the size of an enum equals the size of its largest member, plus the size of the discriminator. In this case, the larger member would be <code>String</code>, which amounts to three pointer-sized machine words. (Here size refers to the size of the struct, which does <i>not</i> include the contents.) Due to alignment, the whole <code>Name</code> enum amounts to the size of four pointers."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 359, "user_id": 3443041, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/54e85dd5f242a00e34839ae6bb34c5cf?s=128&d=identicon&r=PG&f=1", "display_name": "TheBusyTypist", "link": "https://stackoverflow.com/users/3443041/thebusytypist"}, "edited": false, "score": 1, "creation_date": 1479764763, "post_id": 40729658, "comment_id": 68687293, "body": "@TheBusyTypist I&#39;ve updated the answer to include the option of boxing the name, which cuts down the size to three pointers. Given that <code>&amp;str</code> is a slice represented with pointer and <code>usize</code>, I don&#39;t think you can make it smaller than that, except using <code>unsafe</code> trickery with pointer masking."}, {"owner": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "edited": false, "score": 0, "creation_date": 1479766394, "post_id": 40729658, "comment_id": 68688011, "body": "That&#39;s a great example of using <code>Cow</code>. I was just about to edit my code but saw you used <code>Into</code> as well :)"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 28990, "user_id": 1114966, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/af8712b05e5cfb862323a07c83749054?s=128&d=identicon&r=PG", "display_name": "squiguy", "link": "https://stackoverflow.com/users/1114966/squiguy"}, "edited": false, "score": 0, "creation_date": 1479766602, "post_id": 40729658, "comment_id": 68688106, "body": "@squiguy Yeah, I&#39;ve just about reinvented <code>Cow</code>. I would have deleted the <code>enum</code> code, except it might be interesting for learning about <code>enum</code>s (which <code>Cow</code> uses internally anyway) and, more importantly, it allows the additional boxing size optimization."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1479799327, "post_id": 40729658, "comment_id": 68697747, "body": "If you really care about the one word you could save by boxing the <code>String</code>, maybe rather use <a href=\"https://doc.rust-lang.org/std/string/struct.String.html#method.into_boxed_str\" rel=\"nofollow noreferrer\"><code>into_boxed_str()</code></a>. It avoids additional allocation and indirection. You just can&#39;t edit the string contents anymore, which might be fine... Also: this conversion can be reversed with <a href=\"https://doc.rust-lang.org/std/string/struct.String.html#method.into_string\" rel=\"nofollow noreferrer\"><code>into_string()</code></a>"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1479817568, "post_id": 40729658, "comment_id": 68709317, "body": "@LukasKalbertodt That&#39;s actually a very nice improvement on that approach, thanks. It&#39;s a shame that the answer has grown so long already that I&#39;m wary of adding new stuff in."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 4, "last_activity_date": 1479766464, "last_edit_date": 1479766464, "creation_date": 1479763480, "answer_id": 40729658, "question_id": 40728768, "link": "https://stackoverflow.com/questions/40728768/how-can-i-own-a-string-through-reference-if-its-lifetime-is-static/40729658#40729658", "title": "How can I own a string through reference if its lifetime is static?", "body": "<p>One option is to declare the name member as an enum that can either contain a <code>String</code> or an <code>&amp;'static str</code>:</p>\n\n<pre><code>enum Name {\n    Static(&amp;'static str),\n    Owned(String),\n}\n\nstruct Class {\n    name: Name,\n    // ...\n}\n</code></pre>\n\n<p>The class can then provide appropriate constructors (there will have to be two) and a <code>get_name()</code> method for accessing the name as string slice:</p>\n\n<pre><code>impl Class {\n    pub fn new_from_str(name: &amp;'static str) -&gt; Class {\n        Class { name: Name::Static(name) }\n    }\n    pub fn new_from_owned(name: String) -&gt; Class {\n        Class { name: Name::Owned(name) }\n    }\n\n    pub fn get_name(&amp;self) -&gt; &amp;str {\n        match self.name {\n            Name::Owned(ref s) =&gt; s.as_str(),\n            Name::Static(s) =&gt; s,\n        }\n    }\n}\n\nfn main() {\n    let c1 = Class::new_from_str(\"foo\");\n    let c2 = Class::new_from_owned(\"foo\".to_string());\n    println!(\"{} {}\", c1.get_name(), c2.get_name());\n}\n</code></pre>\n\n<p>The other option is to use the <a href=\"https://doc.rust-lang.org/std/borrow/enum.Cow.html\" rel=\"nofollow noreferrer\"><code>Cow</code> type</a> provided by the standard library for this purpose:</p>\n\n<pre><code>use std::borrow::Cow;\n\nstruct Class {\n    name: Cow&lt;'static, str&gt;,\n}\n</code></pre>\n\n<p>Since <code>Cow</code> implements the <code>Into</code> trait, the constructor can now be written as a single generic function:</p>\n\n<pre><code>pub fn new&lt;T&gt;(name: T) -&gt; Class\n    where T: Into&lt;Cow&lt;'static, str&gt;&gt; {\n    Class { name: name.into() }\n}\n</code></pre>\n\n<p><code>Cow</code> also implements the <code>Deref</code> trait, allowing <code>get_name()</code> to be written as:</p>\n\n<pre><code>pub fn get_name(&amp;self) -&gt; &amp;str {\n    return &amp;self.name;\n}\n</code></pre>\n\n<p>In both cases the <code>name</code> member will equal the size of the larger variant plus the space taken by the discriminator. As <code>String</code> is the larger type here, and it takes up three pointer sizes (the string contents is allocated separately and doesn't count), <code>Name</code> will take four pointer sizes in total. In case of explicit <code>enum</code>, the member can be made smaller still by boxing the string:</p>\n\n<pre><code>enum Name {\n    Static(&amp;'static str),\n    Owned(Box&lt;String&gt;),\n}\n</code></pre>\n\n<p>This will cut down the size of <code>Name</code> to three pointer sizes, of which one slot is used for the discriminator and the remaining two for the string slice. The downside is that it requires an additional allocation and indirection for the owned-string case - but it might still pay off if the majority of your class names come from static string slices.</p>\n"}], "owner": {"reputation": 359, "user_id": 3443041, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/54e85dd5f242a00e34839ae6bb34c5cf?s=128&d=identicon&r=PG&f=1", "display_name": "TheBusyTypist", "link": "https://stackoverflow.com/users/3443041/thebusytypist"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 241, "favorite_count": 0, "accepted_answer_id": 40729658, "answer_count": 2, "score": 1, "last_activity_date": 1479766464, "creation_date": 1479760096, "last_edit_date": 1479764243, "question_id": 40728768, "link": "https://stackoverflow.com/questions/40728768/how-can-i-own-a-string-through-reference-if-its-lifetime-is-static", "title": "How can I own a string through reference if its lifetime is static?", "body": "<p>In Rust I would like to give a name to a class, and this class owns this name.</p>\n\n<p>Sometimes the name is passed by an <code>String</code>. For this case I can just simply move the ownership.</p>\n\n<p>But sometimes this name is given by a static string(<code>&amp;str</code>).\nFor this case I want to refer to that string, rather than making a <code>String</code> from it.</p>\n\n<p>My question is: how can I declare this name field in my class?\nWhat type should it be?</p>\n\n<hr>\n\n<p>Some updates/background on the requirements:</p>\n\n<ul>\n<li>The name will be immutable.</li>\n<li>The reason why I want to distinguish a <code>String</code> and a <code>&amp;str</code> is that I want to reduce the dynamic allocation to the minimum.</li>\n</ul>\n"}, {"tags": ["multithreading", "rust"], "comments": [{"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 2, "creation_date": 1479750669, "post_id": 40726128, "comment_id": 68679951, "body": "That issue is two years old and the information there is completely outdated."}, {"owner": {"reputation": 7560, "user_id": 1034749, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2022f0caae119ed6232cf370bb9d9d3a?s=128&d=identicon&r=PG", "display_name": "fghj", "link": "https://stackoverflow.com/users/1034749/fghj"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1479750784, "post_id": 40726128, "comment_id": 68680016, "body": "@Shepmaster <code>There is no &quot;Rust runtime&quot;</code> and no thread-local-variables, that std objects like <code>mutexes</code> are expected to be initialized?"}, {"owner": {"reputation": 7560, "user_id": 1034749, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2022f0caae119ed6232cf370bb9d9d3a?s=128&d=identicon&r=PG", "display_name": "fghj", "link": "https://stackoverflow.com/users/1034749/fghj"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479751260, "post_id": 40726128, "comment_id": 68680263, "body": "@Shepmaster look at bug report that I pointed, the problem was that when <code>rust thread</code> spawns it init some thread-local-variable, while thread spawns for example with raw <code>pthread_create</code>  it doesn&#39;t init <code>some thread-local-variable</code>, so when you use std from raw pthread, you use not initialized thread-local-variable"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1479753969, "post_id": 40726128, "comment_id": 68681597, "body": "Do you disagree with <a href=\"http://stackoverflow.com/questions/40726128/rust-and-foreign-threads#comment68679951_40726128\">delnan&#39;s statement regarding that issue</a>, which suggests that data is out of date? If so, perhaps you can provide further details as to why you disagree. For your queue example, <i>where is the item and where is the queue</i>? The functions take no arguments, so there cannot be any value added and it cannot be added to anything."}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1479754002, "post_id": 40726128, "comment_id": 68681608, "body": "This question could seriously use an MCVE."}, {"owner": {"reputation": 7560, "user_id": 1034749, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2022f0caae119ed6232cf370bb9d9d3a?s=128&d=identicon&r=PG", "display_name": "fghj", "link": "https://stackoverflow.com/users/1034749/fghj"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479754510, "post_id": 40726128, "comment_id": 68681839, "body": "@Shepmaster I not agree and disagree (because of information how at now works runtime is part of answer to my question and I don&#39;t know answer), I just explains to you why <code>rust thread</code> can be different from <code>os thread</code> and why the way how work <code>rust runstime</code> is important."}, {"owner": {"reputation": 7560, "user_id": 1034749, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2022f0caae119ed6232cf370bb9d9d3a?s=128&d=identicon&r=PG", "display_name": "fghj", "link": "https://stackoverflow.com/users/1034749/fghj"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479754890, "post_id": 40726128, "comment_id": 68682013, "body": "@Shepmaster I mean runtime, like <code>C runtime</code> not like <code>java runtime</code>, and see <a href=\"https://www.rust-lang.org/en-US/faq.html\" rel=\"nofollow noreferrer\">rust-lang.org/en-US/faq.html</a> : ` There is a small amount of initialization code that runs before the user\u2019s main function`"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1479801270, "post_id": 40726128, "comment_id": 68698721, "body": "@Shepmaster: I have removed the secondary question about <code>Box::into_raw</code>/<code>Box::from_raw</code> which should get this question back into the fold. I would consider asking for design documentation akin to asking for citations of the standard/specifications in other languages: a way to ask for more than gut feeling or anecdotes."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1479813927, "post_id": 40726128, "comment_id": 68707046, "body": "@delnan: My main worry today would be how thread local storage is handled by those foreign threads. There seems to be a number of limitations particularly around the invocation of destructors."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1479822859, "post_id": 40726128, "comment_id": 68712886, "body": "@MatthieuM. how so? When would destructors even run for thread-local storage?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479823253, "post_id": 40726128, "comment_id": 68713183, "body": "@Shepmaster: Apparently, for TLS, destructors run at the termination of the thread (note: apparently there is limitation that this holds true except for the main thread). That&#39;s what I got from reading <code>local.rs</code> at least."}], "owner": {"reputation": 7560, "user_id": 1034749, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/2022f0caae119ed6232cf370bb9d9d3a?s=128&d=identicon&r=PG", "display_name": "fghj", "link": "https://stackoverflow.com/users/1034749/fghj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 637, "favorite_count": 0, "answer_count": 0, "score": 15, "last_activity_date": 1479822365, "creation_date": 1479749836, "last_edit_date": 1479822365, "question_id": 40726128, "link": "https://stackoverflow.com/questions/40726128/is-it-safe-to-modify-an-arcmutext-from-both-a-rust-thread-and-a-foreign-thre", "title": "Is it safe to modify an Arc&lt;Mutex&lt;T&gt;&gt; from both a Rust thread and a foreign thread?", "body": "<p>Are there any general rules, design documentation or something similar that explains how the Rust standard library deals with threads that were not spawned by <code>std::thread</code>?</p>\n\n<p>I have a <code>cdylib</code> crate and want to use it from another language in a threaded manner:</p>\n\n<pre><code>use std::mem;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\ntype jlong = usize;\ntype SharedData = Arc&lt;Mutex&lt;u32&gt;&gt;;\n\nstruct Foo {\n    data: SharedData,\n}\n\n#[no_mangle]\npub fn Java_com_example_Foo_init(shared_data: &amp;SharedData) -&gt; jlong {\n    let this = Box::into_raw(Box::new(Foo { data: shared_data.clone() }));\n    this as jlong\n}\n\n#[cfg(target_pointer_width = \"32\")]\nunsafe fn jlong_to_pointer&lt;T&gt;(val: jlong) -&gt; *mut T {\n    mem::transmute::&lt;u32, *mut T&gt;(val as u32)\n}\n\n#[cfg(target_pointer_width = \"64\")]\nunsafe fn jlong_to_pointer&lt;T&gt;(val: jlong) -&gt; *mut T {\n    mem::transmute::&lt;jlong, *mut T&gt;(val)\n}\n\n#[no_mangle]\npub fn Java_com_example_Foo_f(this: jlong) {\n    let mut this = unsafe { jlong_to_pointer::&lt;Foo&gt;(this).as_mut().unwrap() };\n    let data = this.data.clone();\n    let mut data = data.lock().unwrap();\n    *data = *data + 5;\n}\n</code></pre>\n\n<p>specifically in</p>\n\n<pre><code>let shared_data = Arc::new(Mutex::new(5));\nlet foo = Java_com_example_Foo_init(&amp;shared_data);\n</code></pre>\n\n<p>is it safe to modify <code>shared_data</code> from a thread spawned by <code>thread::spawn</code> if <code>Java_com_example_Foo_f</code> will be called from an unknown JVM thread? </p>\n\n<p><em><a href=\"https://github.com/rust-lang/rust/issues/17485\" rel=\"noreferrer\">Possible reason why it can be bad.</a></em></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1479747948, "post_id": 40725292, "comment_id": 68678347, "body": "I am a bit confused on what you&#39;re trying to achieve here. Do you want to change the compiler&#39;s error message under that situation? Also note that you should preferably impl <a href=\"https://doc.rust-lang.org/std/convert/trait.From.html\" rel=\"nofollow noreferrer\"><code>From</code></a> instead of <code>Into</code>."}, {"owner": {"reputation": 13772, "user_id": 944430, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/4d2b181af01c96927ac05eb864d6b7b6?s=128&d=identicon&r=PG", "display_name": "Maik Klein", "link": "https://stackoverflow.com/users/944430/maik-klein"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1479748025, "post_id": 40725292, "comment_id": 68678398, "body": "@E_net4 A clearer error message."}], "answers": [{"tags": [], "owner": {"reputation": 852, "user_id": 13854774, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9f9566e304de531d0d35d6b68c623d9b?s=128&d=identicon&r=PG&f=1", "display_name": "Deadbeef", "link": "https://stackoverflow.com/users/13854774/deadbeef"}, "is_accepted": false, "score": 0, "last_activity_date": 1618833532, "creation_date": 1618833532, "answer_id": 67161592, "question_id": 40725292, "link": "https://stackoverflow.com/questions/40725292/forcing-a-borrow-with-the-into-trait/67161592#67161592", "title": "Forcing a borrow with the `Into` trait", "body": "<p>A <code>where</code>-clause works here by specifying the lifetime:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>fn test&lt;'a, I&gt;(i: &amp;'a I) where &amp;'a I: Into&lt;i32&gt; {\n    let n: i32 = i.into();\n    println!(&quot;{}&quot;, n);\n}\n</code></pre>\n<p>Now when you attempt to build with <code>test(f);</code>, the message is clearer:</p>\n<pre><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:16:10\n   |\n16 |     test(f);\n   |          ^\n   |          |\n   |          expected `&amp;Foo`, found struct `Foo`\n   |          help: consider borrowing here: `&amp;f`\n</code></pre>\n"}], "owner": {"reputation": 13772, "user_id": 944430, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/4d2b181af01c96927ac05eb864d6b7b6?s=128&d=identicon&r=PG", "display_name": "Maik Klein", "link": "https://stackoverflow.com/users/944430/maik-klein"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 113, "favorite_count": 0, "answer_count": 1, "score": 3, "last_activity_date": 1618833532, "creation_date": 1479746991, "last_edit_date": 1479747321, "question_id": 40725292, "link": "https://stackoverflow.com/questions/40725292/forcing-a-borrow-with-the-into-trait", "title": "Forcing a borrow with the `Into` trait", "body": "<pre><code>struct Foo(i32);\n\nimpl&lt;'a&gt; Into&lt;i32&gt; for &amp;'a Foo {\n    fn into(self) -&gt; i32 {\n        self.0\n    }\n}\n\nfn test&lt;I: Into&lt;i32&gt;&gt;(i: I) {\n    let n: i32 = i.into();\n    println!(\"{}\", n);\n}\n\nfn main() {\n    let f = Foo(42);\n    test(&amp;f);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=f830df84955fb029f4d90e96b6a60e51&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">playground</a></p>\n\n<p>This works but just looking at <code>test</code></p>\n\n<pre><code>fn test&lt;I: Into&lt;i32&gt;&gt;(i: I) {\n    let n: i32 = i.into();\n    println!(\"{}\", n);\n}\n</code></pre>\n\n<p>The function can access both a borrow and a move/copy depending on how the <code>Into</code> trait is implemented. </p>\n\n<pre><code>impl&lt;'a&gt; Into&lt;i32&gt; for &amp;'a Foo\n// vs\nimpl Into&lt;i32&gt; for Foo\n</code></pre>\n\n<p>Now the user could try to call test like <code>test(f);</code> instead of <code>test(&amp;f);</code> and would receive the following error message.</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `i32: std::convert::From&lt;Foo&gt;` is not satisfied\n  --&gt; &lt;anon&gt;:16:5\n   |\n16 |     test(f);\n   |     ^^^^ trait `i32: std::convert::From&lt;Foo&gt;` not satisfied\n   |\n</code></pre>\n\n<p>Would it be possible to always force a borrow? Something similar to this</p>\n\n<pre><code>fn test&lt;I: Into&lt;i32&gt;&gt;(i: &amp;I) {\n    let n: i32 = i.into();\n    println!(\"{}\", n);\n}\n</code></pre>\n\n<p>So that the user would get an error message similar to, \"Expected &amp;XX but found YY\".</p>\n"}, {"tags": ["rust", "ffi"], "comments": [{"owner": {"reputation": 26723, "user_id": 995714, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/w1393.jpg?s=128&g=1", "display_name": "phuclv", "link": "https://stackoverflow.com/users/995714/phuclv"}, "edited": false, "score": 1, "creation_date": 1479739300, "post_id": 40722714, "comment_id": 68672467, "body": "<code>double</code>? <a href=\"http://en.cppreference.com/w/cpp/language/types\" rel=\"nofollow noreferrer\">en.cppreference.com/w/cpp/language/types</a> a simple search for C data types would give the answer"}, {"owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "reply_to_user": {"reputation": 26723, "user_id": 995714, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/w1393.jpg?s=128&g=1", "display_name": "phuclv", "link": "https://stackoverflow.com/users/995714/phuclv"}, "edited": false, "score": 0, "creation_date": 1479739669, "post_id": 40722714, "comment_id": 68672743, "body": "When I tried double clever cargo asked if I did not mean <code>c_double</code> from libc. I&#39;m guessing that is it."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1479740972, "post_id": 40722714, "comment_id": 68673665, "body": "@TheUnfunCat: Actually, it&#39;s probably clever rustc (invoked under the hood by cargo), and yes the suggestion looks correct to me. For a <code>f32</code> you would want <code>c_float</code>."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1479743918, "creation_date": 1479743918, "answer_id": 40724281, "question_id": 40722714, "link": "https://stackoverflow.com/questions/40722714/what-c-type-should-i-use-for-f64-in-my-c-ffis/40724281#40724281", "title": "What C type should I use for f64 in my C FFIs?", "body": "<p>Use <a href=\"https://doc.rust-lang.org/libc/x86_64-unknown-linux-gnu/libc/type.c_double.html\" rel=\"noreferrer\"><code>libc::c_double</code></a>.</p>\n\n<p>Other direct mappings:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>f32 | c_float   \nf64 | c_double  \ni8  | int8_t    \ni16 | int16_t   \ni32 | int32_t   \ni64 | int64_t   \nu8  | uint8_t\nu16 | uint16_t  \nu32 | uint32_t  \nu64 | uint64_t  \n</code></pre>\n"}], "owner": {"reputation": 22825, "user_id": 992687, "user_type": "registered", "accept_rate": 96, "profile_image": "https://i.stack.imgur.com/0Da71.png?s=128&g=1", "display_name": "The Unfun Cat", "link": "https://stackoverflow.com/users/992687/the-unfun-cat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 447, "favorite_count": 0, "accepted_answer_id": 40724281, "answer_count": 1, "score": 3, "last_activity_date": 1479743918, "creation_date": 1479739136, "question_id": 40722714, "link": "https://stackoverflow.com/questions/40722714/what-c-type-should-i-use-for-f64-in-my-c-ffis", "title": "What C type should I use for f64 in my C FFIs?", "body": "<p>When I return <code>i32</code> data from my C FFI functions, I use the datatype <code>int32_t</code> and it works like a charm. What is the equivalent of Rust's <code>f64</code> datatype in C? </p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1479729156, "post_id": 40719103, "comment_id": 68665736, "body": "I think you could avoid the <code>Clone</code> bound by returning a <code>Vec&lt;Vec&lt;&amp;T&gt;&gt;</code> instead."}, {"owner": {"reputation": 13883, "user_id": 2883245, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/NPpPG.jpg?s=128&g=1", "display_name": "erip", "link": "https://stackoverflow.com/users/2883245/erip"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1479729446, "post_id": 40719103, "comment_id": 68665909, "body": "@MatthieuM. Indeed! Good catch and thanks for the tip. :)"}], "tags": [], "owner": {"reputation": 13883, "user_id": 2883245, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/NPpPG.jpg?s=128&g=1", "display_name": "erip", "link": "https://stackoverflow.com/users/2883245/erip"}, "is_accepted": true, "score": 12, "last_activity_date": 1479729367, "last_edit_date": 1479729367, "creation_date": 1479727846, "answer_id": 40719103, "question_id": 40718975, "link": "https://stackoverflow.com/questions/40718975/how-to-get-every-subset-of-a-vector-in-rust/40719103#40719103", "title": "How to get every subset of a vector in Rust?", "body": "<p>What you're searching for is called the <a href=\"https://en.wikipedia.org/wiki/Power_set\" rel=\"noreferrer\">powerset</a> of a vector.</p>\n\n<p>Here's the code to generate the powerset of a slice of a vector.</p>\n\n<pre><code>fn powerset&lt;T&gt;(s: &amp;[T]) -&gt; Vec&lt;Vec&lt;T&gt;&gt; where T: Clone {\n    (0..2usize.pow(s.len() as u32)).map(|i| {\n         s.iter().enumerate().filter(|&amp;(t, _)| (i &gt;&gt; t) % 2 == 1)\n                             .map(|(_, element)| element.clone())\n                             .collect()\n     }).collect()\n}   \n\nfn main() {\n    let v = vec![1,2,3];\n    println!(\"{:?}\", v);\n    let pset = powerset(&amp;v);\n    println!(\"{:?}\", pset);\n}\n</code></pre>\n\n<p>See it in action <a href=\"https://play.rust-lang.org/?gist=74ca28d761fcdd997626cbab96d69408&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">here</a>.</p>\n\n<p>If you'd like a vector of references in order to prevent copies, you could make a simple change:</p>\n\n<pre><code>fn powerset&lt;T&gt;(s: &amp;[T]) -&gt; Vec&lt;Vec&lt;&amp;T&gt;&gt; {\n    (0..2usize.pow(s.len() as u32)).map(|i| {\n         s.iter().enumerate().filter(|&amp;(t, _)| (i &gt;&gt; t) % 2 == 1)\n                             .map(|(_, element)| element)\n                             .collect()\n     }).collect()\n} \n</code></pre>\n\n<p>See <a href=\"https://play.rust-lang.org/?gist=2e02d1a96d1e04e014b7b88c456e8d5c&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">here</a> for gist.</p>\n"}, {"tags": [], "owner": {"reputation": 67160, "user_id": 1078084, "user_type": "registered", "accept_rate": 81, "profile_image": "https://i.stack.imgur.com/wApmM.jpg?s=128&g=1", "display_name": "Akavall", "link": "https://stackoverflow.com/users/1078084/akavall"}, "is_accepted": false, "score": 2, "last_activity_date": 1480657754, "last_edit_date": 1480657754, "creation_date": 1480135304, "answer_id": 40814977, "question_id": 40718975, "link": "https://stackoverflow.com/questions/40718975/how-to-get-every-subset-of-a-vector-in-rust/40814977#40814977", "title": "How to get every subset of a vector in Rust?", "body": "<p>If order of elements of output is not crucial, and output like this: <code>[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]</code> is acceptable, you can do something like this:</p>\n\n<p>The underlying idea is very simple:</p>\n\n<ol>\n<li><p>Start with an empty set: <code>[[]]</code></p></li>\n<li><p>Copy all your elements to a temporary variable that will be updated by adding the first element (<code>1</code>) to every subset -> <code>[[1]]</code> and add that to the original vector: <code>[[], [1]]</code></p></li>\n<li><p>Do step 2 for the second element (<code>2</code>): <code>[[], [1], [2], [1,2]]</code></p></li>\n<li><p>Do step 2 for the third element (<code>3</code>): <code>[[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]</code></p></li>\n</ol>\n\n<p>For example:</p>\n\n<pre><code>fn powerset(s: &amp;[i32]) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let mut subsets: Vec&lt;Vec&lt;i32&gt;&gt; = vec![];\n    let empty: Vec&lt;i32&gt; = vec![];\n    subsets.push(empty);\n\n    let mut updated: Vec&lt;Vec&lt;i32&gt;&gt; = vec![]; \n\n    for ele in s {\n        for mut sub in subsets.clone() {\n            sub.push(*ele);\n            updated.push(sub);\n        }\n        subsets.append(&amp;mut updated);\n    }\n    subsets\n}\n\nfn main() {\n    let my_vec: Vec&lt;i32&gt; = vec![1,2,3];\n\n    let subs = powerset(&amp;my_vec);\n    println!(\"{:?}\", subs);\n\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "edited": false, "score": 0, "creation_date": 1602491559, "post_id": 64300659, "comment_id": 113726680, "body": "More idiomatic rust would remove the return state in subsets so it&#39;s implicit. That looks pretty nice though. I like the use of <code>combinations</code> in there, it keeps the actual logic simple."}, {"owner": {"reputation": 2279, "user_id": 7028216, "user_type": "registered", "accept_rate": 93, "profile_image": "https://i.stack.imgur.com/ggYcQ.jpg?s=128&g=1", "display_name": "tcelferact", "link": "https://stackoverflow.com/users/7028216/tcelferact"}, "reply_to_user": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "edited": false, "score": 0, "creation_date": 1603722724, "post_id": 64300659, "comment_id": 114118398, "body": "@timlyo thanks, what do you mean by &#39;remove the return state in subsets&#39;?"}, {"owner": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "edited": false, "score": 1, "creation_date": 1603725213, "post_id": 64300659, "comment_id": 114119727, "body": "Sorry typo&#39;d that. I meant remove the <code>return</code> statement. If you remove the <code>return</code> and the semi colon then it&#39;ll be converted to an implicit return so it&#39;ll look like this <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=280506eaca8ad2a4f21b768e803b2592\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}], "tags": [], "owner": {"reputation": 2279, "user_id": 7028216, "user_type": "registered", "accept_rate": 93, "profile_image": "https://i.stack.imgur.com/ggYcQ.jpg?s=128&g=1", "display_name": "tcelferact", "link": "https://stackoverflow.com/users/7028216/tcelferact"}, "is_accepted": false, "score": 1, "last_activity_date": 1607584558, "last_edit_date": 1607584558, "creation_date": 1602391312, "answer_id": 64300659, "question_id": 40718975, "link": "https://stackoverflow.com/questions/40718975/how-to-get-every-subset-of-a-vector-in-rust/64300659#64300659", "title": "How to get every subset of a vector in Rust?", "body": "<p>Here is a more functional flavoured solution that uses the <code>itertools</code> crate.</p>\n<p>I am new to Rust so FYI my decisions around cloning/borrowing/ownership/etc may not be the best, but hopefully the gist of the implementation is helpful.</p>\n<pre><code>use itertools::Itertools;\n\nfn subsets&lt;T: Clone&gt;(items: Vec&lt;T&gt;) -&gt; Vec&lt;Vec&lt;T&gt;&gt; {\n    (0..=items.len())\n        .map(|count| items.clone().into_iter().combinations(count))\n        .flatten()\n        .collect()\n}\n\nfn main() {\n    // for example ...\n    let it = subsets(vec![12, 24, 36]);\n    println!(&quot;{:?}&quot;, it);\n}\n</code></pre>\n"}], "owner": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1517, "favorite_count": 1, "accepted_answer_id": 40719103, "answer_count": 3, "score": 8, "last_activity_date": 1607584558, "creation_date": 1479727461, "last_edit_date": 1479746167, "question_id": 40718975, "link": "https://stackoverflow.com/questions/40718975/how-to-get-every-subset-of-a-vector-in-rust", "title": "How to get every subset of a vector in Rust?", "body": "<p>What's the easiest/most idiomatic way to get every subset of a vector in Rust?</p>\n\n<pre><code>let v = vec![1,2,3];\nassert_eq!(subsets(v), [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]);\n</code></pre>\n"}, {"tags": ["macos", "rust"], "answers": [{"tags": [], "owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "is_accepted": true, "score": 1, "last_activity_date": 1479746042, "last_edit_date": 1479746042, "creation_date": 1479726362, "answer_id": 40718632, "question_id": 40714739, "link": "https://stackoverflow.com/questions/40714739/cannot-build-the-sciter-rs-example-lsciter-osx-64-not-found/40718632#40718632", "title": "Cannot build the sciter-rs example, -lsciter-osx-64 not found", "body": "<p>I assume you are referring to <a href=\"https://github.com/pravic/rust-sciter\" rel=\"nofollow noreferrer\">rust-sciter</a>. The getting started instructions start with:</p>\n\n<ol>\n<li>Download <a href=\"http://sciter.com/download/\" rel=\"nofollow noreferrer\">Sciter SDK</a> and extract it somewhere.</li>\n<li>Add target platform binaries to <code>PATH</code> (<code>bin</code>, <code>bin.osx</code> or <code>bin.gtk</code>) and install Sciter shared library to your <code>LIBRARY_PATH</code>.</li>\n<li>Build library and run the minimal sciter sample: cargo run --example minimal.</li>\n</ol>\n\n<p>It looks like you didn't install the Sciter shared library (<code>sciter-osx-64.dylib</code>) to your <a href=\"https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/UsingDynamicLibraries.html\" rel=\"nofollow noreferrer\"><code>LIBRARY_PATH</code></a>. </p>\n"}], "owner": {"reputation": 402, "user_id": 3809903, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/9e1c36e71e453b8ecea77f2e8127942b?s=128&d=identicon&r=PG&f=1", "display_name": "kai", "link": "https://stackoverflow.com/users/3809903/kai"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 155, "favorite_count": 0, "accepted_answer_id": 40718632, "answer_count": 1, "score": 0, "last_activity_date": 1479746042, "creation_date": 1479712756, "last_edit_date": 1479745999, "question_id": 40714739, "link": "https://stackoverflow.com/questions/40714739/cannot-build-the-sciter-rs-example-lsciter-osx-64-not-found", "title": "Cannot build the sciter-rs example, -lsciter-osx-64 not found", "body": "<p>I downloaded the sciter SDK, extracted it, and added it to my <code>PATH</code> (<code>PATH = $PATH:DOWNLOAD_PATH/bin.osx</code>). I then tried to run the example:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ cargo run --example minimal\n\nCompiling sciter-rs v0.4.1 (file:///Users/username/rust/rust-sciter)\nerror: linking with `cc` failed: exit code: 1\n|\n= note: \"cc\" \"-m64\" \"-L\" \"/usr/local/lib/rustlib/x86_64-apple-darwin/lib\" \"/Users/username/rust/rust-sciter/target/debug/deps/sciter.0.o\" \"-o\" \"/Users/username/rust/rust-sciter/target/debug/deps/libsciter.dylib\" \"/Users/username/rust/rust-sciter/target/debug/deps/sciter.metadata.o\" \"-Wl,-dead_strip\" \"-nodefaultlibs\" \"-L\" \"/Users/username/rust/rust-sciter/target/debug/deps\" \"-L\" \"/usr/local/lib/rustlib/x86_64-apple-darwin/lib\" \"-l\" \"sciter-osx-64\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/liblazy_static-7f1b96a3a3eb529d.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libobjc_foundation-01845fbb083d910e.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libblock-498e22772f250b8c.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libobjc_id-1b90e6745bca1976.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libobjc-9578ff0dad145ffa.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libmalloc_buf-7aa64dffd2b03b4f.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/liblibc-ad32fde1bd850538.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libstd-a4729905.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libpanic_unwind-a4729905.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libunwind-a4729905.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/librand-a4729905.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libcollections-a4729905.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/librustc_unicode-a4729905.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/liballoc-a4729905.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/liballoc_system-a4729905.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/liblibc-a4729905.rlib\" \"-Wl,-force_load,/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libcore-a4729905.rlib\" \"/var/folders/sk/76ww7m4n1j5210m9vxc88hy40000gn/T/rustc.SOetAnbslBvu/libcompiler_builtins-a4729905.rlib\" \"-framework\" \"Foundation\" \"-l\" \"System\" \"-l\" \"objc\" \"-l\" \"objc\" \"-l\" \"objc\" \"-l\" \"System\" \"-l\" \"pthread\" \"-l\" \"c\" \"-l\" \"m\" \"-dynamiclib\" \"-Wl,-dylib\"\n= note: ld: library not found for -lsciter-osx-64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre>\n\n<p>I don't understand why sciter-osx-64 library not found.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 0, "creation_date": 1479719496, "post_id": 40712733, "comment_id": 68660023, "body": "Thanks, good explanation, you guessed my intend correctly. However, in your case Nodes can be anything, which means any function operating on DiGraphs isn&#39;t going to be able to do much since it can&#39;t make any assumptions about Nodes. So what I&#39;d like to do is restrict Nodes to get an iterator over N (usize in my example, but defined by the caller). I&#39;m happy for SimpleDiGraph to always return a Range&lt;N&gt; object, but other structs implementing DiGraph should be able to return other Iterators over N. Any way to achieve that?"}, {"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 0, "creation_date": 1479720742, "post_id": 40712733, "comment_id": 68660698, "body": "Think I figured it out, seem you can actually restrict trait types, such as <i>type NodeIterator: Iterator&lt;Item=&amp;&#39;a Self::Node&gt;;</i> which should do the trick. Now just to figure out lifetime issues."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 7, "last_activity_date": 1479702258, "creation_date": 1479702258, "answer_id": 40712733, "question_id": 40712614, "link": "https://stackoverflow.com/questions/40712614/expected-type-parameter-found-struct-when-implementing-trait/40712733#40712733", "title": "&quot;expected type parameter, found struct&quot; when implementing trait", "body": "<p><code>&lt;T=std::ops::Range&lt;usize&gt;&gt;</code> doesn't force <code>T</code> to be <code>std::ops::Range&lt;usize&gt;</code>, it just causes it to default to that if it doesn't know what else to use.</p>\n\n<p>If you only ever want to return a <code>Range&lt;usize&gt;</code>, then use <code>Range&lt;usize&gt;</code> as the return type; there's no reason to have a generic parameter at all.  What your code is effectively saying now is something like this:</p>\n\n<ul>\n<li>\"You can pick any return type you want!  If you don't care, I'll return a <code>range&lt;usize&gt;</code>.\"</li>\n<li>\"I'd like you to return a <code>String</code>, please.\"</li>\n<li>\"<strong>TOUGH</strong> you're getting a <code>range&lt;usize&gt;</code>!\"</li>\n<li>\"... but you said...\"</li>\n<li>\"<em>I lied!  MUAHAHAHAHAHA!</em>\"</li>\n</ul>\n\n<p>If you <em>actually</em> want the caller to choose the return type, then you need to be prepared to return <em>any</em> <code>T</code>... which is almost impossible, since it could be anything from <code>()</code> to <code>String</code> to an OpenGL render context.</p>\n\n<p>In that case, what you <em>actually</em> want to do is constrain <code>T</code> to some trait that requires types implement some sort of construction function.  <code>Default</code> is an example of one.</p>\n\n<p><strong>Edit</strong>: Just to doubly clarify: <em>you</em> don't get to pick the types used in generic parameters, your <em>caller</em> does.</p>\n\n<p>I didn't notice until just now that you're using different definitions in the trait and the implementation (don't do that).  I assume that what you're <em>really</em> trying to do is say \"this method returns <em>something</em> that's usable as an <code>Iterator</code>, but each <code>impl</code> can pick a different type.\"  You <em>cannot</em> do this with generics.</p>\n\n<p>What you <em>want</em> is an associated type on the trait, like so:</p>\n\n<pre><code>pub trait DiGraph&lt;'a&gt; {\n    type Nodes;\n    fn nodes(&amp;'a self) -&gt; Self::Nodes;\n}\n\npub struct SimpleNode {\n    pre: Vec&lt;usize&gt;,\n    succ: Vec&lt;usize&gt;,\n}\n\npub struct SimpleDiGraph {\n    pub nodes: Vec&lt;SimpleNode&gt;\n}\n\nimpl&lt;'a&gt; DiGraph&lt;'a&gt; for SimpleDiGraph {\n    type Nodes = std::ops::Range&lt;usize&gt;;\n\n    fn nodes(&amp;'a self) -&gt; Self::Nodes {\n        return std::ops::Range { start: 0, end: self.nodes.len() };\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2132, "favorite_count": 0, "accepted_answer_id": 40712733, "answer_count": 1, "score": 1, "last_activity_date": 1479746342, "creation_date": 1479701432, "last_edit_date": 1479746342, "question_id": 40712614, "link": "https://stackoverflow.com/questions/40712614/expected-type-parameter-found-struct-when-implementing-trait", "title": "&quot;expected type parameter, found struct&quot; when implementing trait", "body": "<p>I am trying to create a trait for a directed graph structure and provide one very basic implementatio, but am running into compiler errors:</p>\n\n<pre><code>pub trait DiGraph&lt;'a&gt; {\n    type N;\n    fn nodes&lt;T&gt;(&amp;'a self) -&gt; T where T: Iterator&lt;Item=&amp;'a Self::N&gt;;\n    fn pre&lt;T&gt;(&amp;'a self, node: Self::N) -&gt; T where T: Iterator&lt;Item=&amp;'a Self::N&gt;;\n    fn succ&lt;T&gt;(&amp;'a self, node: Self::N) -&gt; T where T: Iterator&lt;Item=&amp;'a Self::N&gt;;\n}\n\nstruct SimpleNode {\n    pre: Vec&lt;usize&gt;,\n    succ: Vec&lt;usize&gt;,\n}\n\npub struct SimpleDiGraph {\n    pub nodes: Vec&lt;SimpleNode&gt;\n}\n\nimpl&lt;'a&gt; DiGraph&lt;'a&gt; for SimpleDiGraph {\n    type N = usize;\n\n    fn nodes&lt;T=std::ops::Range&lt;usize&gt;&gt;(&amp;'a self) -&gt; T {\n        return std::ops::Range { start: 0, end: self.nodes.len() };\n    }\n    fn pre&lt;T=std::slice::Iter&lt;'a,usize&gt;&gt;(&amp;'a self, node: usize) -&gt; T {\n        return self.nodes[node].pre.iter();\n    }\n    fn succ&lt;T=std::slice::Iter&lt;'a,usize&gt;&gt;(&amp;'a self, node: usize) -&gt; T {\n        return self.nodes[node].succ.iter();\n    }\n}\n</code></pre>\n\n<p>The error messages are:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n--&gt; digraph.rs:21:16\n|\n21 |         return std::ops::Range { start: 0, end: self.nodes.len() };\n|                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter, found struct `std::ops::Range`\n|\n= note: expected type `T`\n= note:    found type `std::ops::Range&lt;usize&gt;`\n\nerror[E0308]: mismatched types\n--&gt; digraph.rs:24:16\n|\n24 |         return self.nodes[node].pre.iter();\n|                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter, found struct `std::slice::Iter`\n|\n= note: expected type `T`\n= note:    found type `std::slice::Iter&lt;'_, usize&gt;`\n\nerror[E0308]: mismatched types\n--&gt; digraph.rs:27:16\n|\n27 |         return self.nodes[node].succ.iter();\n|                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter, found struct `std::slice::Iter`\n|\n= note: expected type `T`\n= note:    found type `std::slice::Iter&lt;'_, usize&gt;`\n</code></pre>\n\n<p>The error message is somewhat confusing to me - why would a type parameter be expected as return value? Is this simply a type mismatch (e.g. due to lifetimes) with a misleading error message?</p>\n"}, {"tags": ["rust", "operator-overloading", "lifetime", "traits"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1479745574, "post_id": 40711139, "comment_id": 68676736, "body": "At the risk of missing something obvious, there is already a <a href=\"https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html\" rel=\"nofollow noreferrer\"><code>Ipv4Addr</code></a> that wraps the appropriate underlying type."}, {"owner": {"reputation": 1326, "user_id": 1836144, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/e250d748ff6c2ff23bc4550e0f0971f5?s=128&d=identicon&r=PG", "display_name": "little-dude", "link": "https://stackoverflow.com/users/1836144/little-dude"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479746277, "post_id": 40711139, "comment_id": 68677244, "body": "@Shepmaster, yes but I&#39;d like to use this in a traffic generation tool, so I want (at least) the <code>+</code>, <code>&amp;</code>, <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators implemented. Afaik I cannot implement this easily on <code>Ipv4Addr</code> because I don&#39;t have a direct access to the underlying type."}], "answers": [{"comments": [{"owner": {"reputation": 1326, "user_id": 1836144, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/e250d748ff6c2ff23bc4550e0f0971f5?s=128&d=identicon&r=PG", "display_name": "little-dude", "link": "https://stackoverflow.com/users/1836144/little-dude"}, "edited": false, "score": 0, "creation_date": 1479745412, "post_id": 40711539, "comment_id": 68676636, "body": "Thanks a lot for explaining <i>why</i> it&#39;s a wrong thing to do, and answering the question anyway. I&#39;m not implementing <code>Index</code>, I promise!"}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 7, "last_activity_date": 1479691679, "creation_date": 1479691679, "answer_id": 40711539, "question_id": 40711139, "link": "https://stackoverflow.com/questions/40711139/how-to-implement-stdopsindex-when-the-output-value-is-not-part-of-the-type/40711539#40711539", "title": "How to implement std::ops::Index when the output value is not part of the type", "body": "<p>Well, the simplest and most idiomatic way to solve this is to <em>not</em> implement <code>Index</code>, and instead just use a method called <code>octet</code> or something.  <code>Index</code> is for indexing into containers; it simply isn't compatible with generating new values on the fly.</p>\n\n<p>So.  There's your answer.</p>\n\n<hr>\n\n<p>You absolutely should <em>not</em> do anything I'm <em>about</em> to describe, because there is no good reason to do it, and I'm only writing it out because you <em>technically</em> asked if there was any way at all...</p>\n\n<p>You've been warned.</p>\n\n<p>... The octets are <em>right there</em>!  Unless you're compiling for a machine with bytes that <em>aren't</em> 8 bits, or has more granular addressing than 8 bits, there's no reason you can't just do this:</p>\n\n<pre><code>use std::ops;\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Address(u32);\n\nenum Byte {\n    A,\n    B,\n    C,\n    D\n}\n\nimpl ops::Index&lt;Byte&gt; for Address {\n    type Output = u8;\n\n    #[cfg(target_endian=\"big\")]\n    fn index&lt;'a&gt;(&amp;'a self, byte: Byte) -&gt; &amp;'a u8 {\n        use std::mem;\n        let bytes = unsafe { mem::transmute::&lt;_, &amp;[u8; 4]&gt;(&amp;self.0) };\n        match byte {\n            Byte::A =&gt; &amp;bytes[0],\n            Byte::B =&gt; &amp;bytes[1],\n            Byte::C =&gt; &amp;bytes[2],\n            Byte::D =&gt; &amp;bytes[3],\n        }\n    }\n\n    #[cfg(target_endian=\"little\")]\n    fn index&lt;'a&gt;(&amp;'a self, byte: Byte) -&gt; &amp;'a u8 {\n        use std::mem;\n        let bytes = unsafe { mem::transmute::&lt;_, &amp;[u8; 4]&gt;(&amp;self.0) };\n        match byte {\n            Byte::A =&gt; &amp;bytes[3],\n            Byte::B =&gt; &amp;bytes[2],\n            Byte::C =&gt; &amp;bytes[1],\n            Byte::D =&gt; &amp;bytes[0],\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(Address(0x12345678)[Byte::A], 0x12);\n}\n</code></pre>\n\n<p>I mean, aside from this being a needless use of <code>unsafe</code> for the sake of confusing syntax; indexing an <em>address</em> makes about as much sense as indexing an integer: very little.</p>\n"}], "owner": {"reputation": 1326, "user_id": 1836144, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/e250d748ff6c2ff23bc4550e0f0971f5?s=128&d=identicon&r=PG", "display_name": "little-dude", "link": "https://stackoverflow.com/users/1836144/little-dude"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 833, "favorite_count": 0, "accepted_answer_id": 40711539, "answer_count": 1, "score": 3, "last_activity_date": 1479691679, "creation_date": 1479688362, "last_edit_date": 1479688697, "question_id": 40711139, "link": "https://stackoverflow.com/questions/40711139/how-to-implement-stdopsindex-when-the-output-value-is-not-part-of-the-type", "title": "How to implement std::ops::Index when the output value is not part of the type", "body": "<p>I am trying to implement an ip address type that basically wraps <code>u32</code>:</p>\n\n<pre><code>#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Address(u32);\n</code></pre>\n\n<p>I'm implementing the <code>std::ops</code> operators that makes sense for an IP address (<code>&amp;</code>, <code>|</code>, <code>+</code>, <code>-</code>, etc.). The only one that is causing trouble is <code>std::ops::Index</code>:</p>\n\n<pre><code>#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Address(u32);\n\nenum Byte {\n    A,\n    B,\n    C,\n    D\n}\n\nimpl ops::Index&lt;Byte&gt; for Address {\n    type Output = u8;\n\n    fn index&lt;'a&gt;(&amp;'a self, byte: Byte) -&gt; &amp;'a Self::Output {\n        match byte {\n            Byte::A =&gt; ((self.0 &amp; 0xFF000000) &gt;&gt; 24) as u8,\n            Byte::B =&gt; ((self.0 &amp; 0x00FF0000) &gt;&gt; 16) as u8,\n            Byte::C =&gt; ((self.0 &amp; 0x0000FF00) &gt;&gt; 8) as u8,\n            Byte::D =&gt; (self.0 &amp; 0x000000FF) as u8,\n        }\n    }\n}\n</code></pre>\n\n<p>This obviously does not compile because I cannot return an <code>u8</code> when <code>&amp;u8</code> is expected. The naive attempt to fix it would be:</p>\n\n<pre><code>impl ops::Index&lt;Byte&gt; for Address {\n    type Output = u8;\n\n    fn index&lt;'a&gt;(&amp;'a self, byte: Byte) -&gt; &amp;'a Self::Output {\n        match byte {\n            Byte::A =&gt; &amp;(((self.0 &amp; 0xFF000000) &gt;&gt; 24) as u8),\n            Byte::B =&gt; &amp;(((self.0 &amp; 0x00FF0000) &gt;&gt; 16) as u8),\n            Byte::C =&gt; &amp;(((self.0 &amp; 0x0000FF00) &gt;&gt; 8) as u8),\n            Byte::D =&gt; &amp;((self.0 &amp; 0x000000FF) as u8),\n        }\n    }\n}\n</code></pre>\n\n<p>But of course, I cannot return a reference to a value that does not exist anymore once the function returns.</p>\n\n<p>I there a way to implement <code>std::ops::Index</code> in this case? It does not seem so to me, but I hope someone can prove me wrong.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1479734168, "post_id": 40720007, "comment_id": 68668992, "body": "Thanks for the effort, although I still hope it&#39;s possible to avoid calling <code>strerror</code> through FFI. It&#39;s not the <code>unsafe</code> part that worries me, but stuff that looks inherently non-portable, such as Linux-specific <code>link_name = &quot;__xpg_strerror_r&quot;</code>."}], "tags": [], "owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "is_accepted": false, "score": 1, "last_activity_date": 1528939692, "last_edit_date": 1528939692, "creation_date": 1479730638, "answer_id": 40720007, "question_id": 40710115, "link": "https://stackoverflow.com/questions/40710115/how-does-one-get-the-error-message-as-provided-by-the-system-without-the-os-err/40720007#40720007", "title": "How does one get the error message as provided by the system without the &quot;os error n&quot; suffix?", "body": "<p>This is the <a href=\"https://github.com/rust-lang/rust/blob/1.26.2/src/libstd/io/error.rs#L531-L543\" rel=\"nofollow noreferrer\">code</a> adding \"os error 2\":</p>\n\n<pre><code>impl fmt::Display for Error {\n    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match self.repr {\n            Repr::Os(code) =&gt; {\n                let detail = sys::os::error_string(code);\n                write!(fmt, \"{} (os error {})\", detail, code)\n            }\n            Repr::Custom(ref c) =&gt; c.error.fmt(fmt),\n            Repr::Simple(kind) =&gt; write!(fmt, \"{}\", kind.as_str()),\n        }\n    }\n}\n</code></pre>\n\n<p>Unfortunately, <code>sys::os::error_string</code> does not seem accessible, so you would have to copy the code into your program.</p>\n\n<pre><code>extern crate libc;\n\nuse std::ffi::CStr;\nuse std::fs;\nuse std::os::raw::{c_char, c_int};\nuse std::str;\n\nconst TMPBUF_SZ: usize = 128;\n\n// from https://github.com/rust-lang/rust/blob/1.26.2/src/libstd/sys/unix/os.rs#L87-L107\npub fn error_string(errno: i32) -&gt; String {\n    extern \"C\" {\n        #[cfg_attr(any(target_os = \"linux\", target_env = \"newlib\"), link_name = \"__xpg_strerror_r\")]\n        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t) -&gt; c_int;\n    }\n\n    let mut buf = [0 as c_char; TMPBUF_SZ];\n\n    let p = buf.as_mut_ptr();\n    unsafe {\n        if strerror_r(errno as c_int, p, buf.len()) &lt; 0 {\n            panic!(\"strerror_r failure\");\n        }\n\n        let p = p as *const _;\n        str::from_utf8(CStr::from_ptr(p).to_bytes())\n            .unwrap()\n            .to_owned()\n    }\n}\n\nfn main() {\n    let fl = \"no such file\";\n    if let Err(e) = fs::metadata(fl) {\n        eprintln!(\"{}: {}\", fl, e);\n        eprintln!(\"{}\", error_string(e.raw_os_error().unwrap()));\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=e6049f9e48c2ffc49a2f149e53cc8951&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">Output</a>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>no such file: No such file or directory (os error 2)\nNo such file or directory\n</code></pre>\n"}], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 827, "favorite_count": 2, "answer_count": 1, "score": 8, "last_activity_date": 1528939692, "creation_date": 1479680609, "last_edit_date": 1528939293, "question_id": 40710115, "link": "https://stackoverflow.com/questions/40710115/how-does-one-get-the-error-message-as-provided-by-the-system-without-the-os-err", "title": "How does one get the error message as provided by the system without the &quot;os error n&quot; suffix?", "body": "<p>Error messages displayed by <code>std::io::Error</code> come with an \"(os error n)\" suffix, easily reproduced by running a program such as:</p>\n\n<pre><code>use std::fs;\nuse std::io::Write;\n\nfn main() {\n    let fl = \"no such file\";\n    if let Err(e) = fs::metadata(fl) {\n        writeln!(std::io::stderr(), \"{}: {}\", fl, e).unwrap();\n    }\n}\n</code></pre>\n\n<p>Output:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>no such file: No such file or directory (os error 2)\n</code></pre>\n\n<p>How does one get the system error message as provided by the system, i.e. without the \"os error 2\" part?</p>\n\n<p>I tried:</p>\n\n<ul>\n<li><p>calling <code>e.description()</code>, which returns a different error message (\"entity not found\"), which is useful, but not what I'm looking for;</p></li>\n<li><p>inspecting the structure of the <code>Error</code> object, e.g. using the <code>{:?}</code> debug display, which reveals that the object does contain the undecorated error string, but it seems to be hidden in an internal field.</p></li>\n</ul>\n\n<p>Please note that I'm aiming for a portable and not a Linux-only solution.</p>\n"}, {"tags": ["while-loop", "return", "rust"], "comments": [{"owner": {"reputation": 2898, "user_id": 1971187, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/3IO4T.png?s=128&g=1", "display_name": "Ryan Walker", "link": "https://stackoverflow.com/users/1971187/ryan-walker"}, "edited": false, "score": 1, "creation_date": 1479674488, "post_id": 40708939, "comment_id": 68646204, "body": "Strange, I cannot reproduce your error.  The code you posted compiles and runs fine for me with <code>rustc</code> version 1.12."}, {"owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "reply_to_user": {"reputation": 2898, "user_id": 1971187, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/3IO4T.png?s=128&g=1", "display_name": "Ryan Walker", "link": "https://stackoverflow.com/users/1971187/ryan-walker"}, "edited": false, "score": 0, "creation_date": 1479676179, "post_id": 40708939, "comment_id": 68646818, "body": "Thanks for notifying me. I have revised the code.    I realized the error that I found is b/c I put return None inside the while loop. But the program should actually return Some(123) inside the for loop, before it can reach the return None."}], "answers": [{"comments": [{"owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "edited": false, "score": 0, "creation_date": 1479680412, "post_id": 40709512, "comment_id": 68648190, "body": "Thanks again for your help. I want to make sure I really understand the problem here: Inside the while loop of my code, if nothing return a Some Type, the final &quot;return None&quot; would capture all other other possibility. So the while loop would surely return either a Some or a None. How can there would be still a path with no return value?"}, {"owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "edited": false, "score": 0, "creation_date": 1479684296, "post_id": 40709512, "comment_id": 68649295, "body": "That makes tons of senses! So the difference between a loop {...} and while {...} is: loop not always return ()?"}, {"owner": {"reputation": 2898, "user_id": 1971187, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/3IO4T.png?s=128&g=1", "display_name": "Ryan Walker", "link": "https://stackoverflow.com/users/1971187/ryan-walker"}, "reply_to_user": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "edited": false, "score": 1, "creation_date": 1479687010, "post_id": 40709512, "comment_id": 68649957, "body": "Right.  However this is a relatively recent addition.  See here: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1624-loop-break-value.md\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/blob/master/text/&hellip;</a>"}], "tags": [], "owner": {"reputation": 2898, "user_id": 1971187, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/3IO4T.png?s=128&g=1", "display_name": "Ryan Walker", "link": "https://stackoverflow.com/users/1971187/ryan-walker"}, "is_accepted": true, "score": 4, "last_activity_date": 1479745688, "last_edit_date": 1479745688, "creation_date": 1479676791, "answer_id": 40709512, "question_id": 40708939, "link": "https://stackoverflow.com/questions/40708939/return-option-inside-loop/40709512#40709512", "title": "Return Option inside Loop", "body": "<p>The value of any <code>while true { ... }</code> expression is always <code>()</code>. So the compiler expects your <code>foo</code> to return an <code>Option&lt;i32&gt;</code> but finds the last value in your <code>foo</code> body is <code>()</code>.</p>\n\n<p>To fix this, you can add a <code>return None</code> outside the original <code>while</code> loop. You can also use the <code>loop</code> construct like this:</p>\n\n<pre><code>fn main() {\n\n    // run the code\n    foo();\n\n    fn foo() -&gt; Option&lt;i32&gt; {\n        let mut x = 5;\n\n        loop {\n            x += x - 3;\n\n            for (index, value) in (5..10).enumerate() {\n                println!(\"index = {} and value = {}\", index, value);\n\n                if index == 3 {\n                    return Some(123);\n                }\n            }\n            if x % 5 == 0 {\n                return None;\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>The behaviour of <code>while true { ... }</code> statements is maybe a bit quirky and there have been a few requests to <a href=\"https://internals.rust-lang.org/t/allow-loops-to-return-values-other-than/567/8\" rel=\"nofollow noreferrer\">change it.</a></p>\n"}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 651, "favorite_count": 0, "accepted_answer_id": 40709512, "answer_count": 1, "score": 2, "last_activity_date": 1479745688, "creation_date": 1479673233, "last_edit_date": 1479744787, "question_id": 40708939, "link": "https://stackoverflow.com/questions/40708939/return-option-inside-loop", "title": "Return Option inside Loop", "body": "<p>The program aims to use a loop to check if the index of a iterator variable meets certain criteria (i.g., index == 3). If find the desired index, return <code>Some(123)</code>, else return <code>None</code>.  </p>\n\n<pre><code>fn main() {\n    fn foo() -&gt; Option&lt;i32&gt; {\n        let mut x = 5;\n        let mut done = false;\n\n        while !done {\n            x += x - 3;\n\n            if x % 5 == 0 {\n                done = true;\n            }\n\n            for (index, value) in (5..10).enumerate() {\n                println!(\"index = {} and value = {}\", index, value);\n\n                if index == 3 {\n                    return Some(123);\n                }\n            }\n            return None; //capture all other other possibility. So the while loop would surely return either a Some or a None\n        }\n    }\n}\n</code></pre>\n\n<p>The compiler gives this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; &lt;anon&gt;:7:9\n   |\n7  |         while !done {\n   |         ^ expected enum `std::option::Option`, found ()\n   |\n   = note: expected type `std::option::Option&lt;i32&gt;`\n   = note:    found type `()`\n</code></pre>\n\n<p>I think the error source might be that a while loop evaluates to a <code>()</code>, thus it would return a <code>()</code> instead of <code>Some(123)</code>. I don't know how to return a valid <code>Some</code> type inside a loop.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 13883, "user_id": 6815131, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2c38385f9eb57b70176498fa5c3b4c99?s=128&d=identicon&r=PG&f=1", "display_name": "Joe C", "link": "https://stackoverflow.com/users/6815131/joe-c"}, "edited": false, "score": 0, "creation_date": 1479669026, "post_id": 40708166, "comment_id": 68644303, "body": "Yours looks correct, but that one statement is a bit too wordy for my liking."}], "answers": [{"comments": [{"owner": {"reputation": 3, "user_id": 1685387, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/bc2e1470ef14017ba04454f2be0e83ef?s=128&d=identicon&r=PG", "display_name": "Bambou", "link": "https://stackoverflow.com/users/1685387/bambou"}, "edited": false, "score": 0, "creation_date": 1479670093, "post_id": 40708386, "comment_id": 68644705, "body": "Thanks that was exactly what I was asking for. I know that they will do the same thing I was only wondering about the benefit of their syntax."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 4, "last_activity_date": 1479669785, "creation_date": 1479669785, "answer_id": 40708386, "question_id": 40708166, "link": "https://stackoverflow.com/questions/40708166/is-it-better-to-destructure-a-value-to-access-attributes-or-use-their-names/40708386#40708386", "title": "Is it better to destructure a value to access attributes or use their names?", "body": "<p>I am afraid that you are completely missing the point.</p>\n\n<p>The example is <em>just</em> about demonstrating a particular syntax; it does not attempt to claim that this syntax is the best way to achieve <em>this particular task</em>.</p>\n\n<p>Examples of syntax are always limited, especially when self-contained, to snippet where their benefits are not immediately evident. This does not mean the syntax is necessarily superfluous.</p>\n\n<hr>\n\n<p>The syntax under scrutiny can be useful in two situations:</p>\n\n<ul>\n<li>it can reduce noise, by allowing naming quickly the few pertinent elements for a computation</li>\n<li>it also allows <em>destructuring</em>, consuming the left-hand side (if not <code>Copy</code>) and naming its constituents in one fell swoop; indeed, this is nothing more than one instance (among others) of pattern matching</li>\n</ul>\n"}], "owner": {"reputation": 3, "user_id": 1685387, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/bc2e1470ef14017ba04454f2be0e83ef?s=128&d=identicon&r=PG", "display_name": "Bambou", "link": "https://stackoverflow.com/users/1685387/bambou"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 56, "favorite_count": 0, "accepted_answer_id": 40708386, "answer_count": 1, "score": 0, "last_activity_date": 1479744545, "creation_date": 1479668628, "last_edit_date": 1479744545, "question_id": 40708166, "link": "https://stackoverflow.com/questions/40708166/is-it-better-to-destructure-a-value-to-access-attributes-or-use-their-names", "title": "Is it better to destructure a value to access attributes or use their names?", "body": "<p>In the <a href=\"http://rustbyexample.com/fn/methods.html\" rel=\"nofollow noreferrer\">Rust by Example chapter about methods</a>, I saw the following code to calculate the area of a <code>Rectangle</code>:</p>\n\n<pre><code>struct Rectangle {\n    p1: Point,\n    p2: Point,\n}\n\nimpl Rectangle {\n    fn area(&amp;self) -&gt; f64 {\n        let Point { x: x1, y: y1 } = self.p1;\n        let Point { x: x2, y: y2 } = self.p2;\n        ((x1 - x2) * (y1 - y2)).abs()\n    }\n}\n</code></pre>\n\n<p>Personally, I would have done something like:</p>\n\n<pre><code>fn area(&amp;self) -&gt; f64 {\n    ((self.p1.x - self.p2.x) * (self.p1.y - self.p2.y)).abs()\n}\n</code></pre>\n\n<p>Is the tutorial code better than mine and if so, why?</p>\n"}, {"tags": ["hashmap", "rust", "ownership"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1479667114, "post_id": 40707750, "comment_id": 68643668, "body": "Have you tried <a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry\" rel=\"nofollow noreferrer\">entry</a>?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1479667156, "post_id": 40707750, "comment_id": 68643679, "body": "@E_net4: Or high-level methods such as <code>insert_or</code>, ..."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1479667286, "post_id": 40707750, "comment_id": 68643729, "body": "<code>terms.entry(term).or_insert_with(Vec::new).push(posting_id)</code>"}, {"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479667344, "post_id": 40707750, "comment_id": 68643746, "body": "@Shepmaster The point is I&#39;m trying to append to an already existing vector, not create a new one. I wonder whether copying the original vector, appending, and then inserting would be much less efficient than directly mutating."}, {"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479667411, "post_id": 40707750, "comment_id": 68643781, "body": "@Shepmaster I don&#39;t think your code does exactly what I did with my code. You created a new vector."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479667431, "post_id": 40707750, "comment_id": 68643787, "body": "@JIXiang No, I did not; only when there wasn&#39;t previously a value."}, {"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479667533, "post_id": 40707750, "comment_id": 68643812, "body": "@Shepmaster OK. it seems I shall learn a bit more about <code>entry</code> then. Thanks for the quick answer."}], "owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 44, "favorite_count": 0, "closed_date": 1479667211, "answer_count": 0, "score": 0, "last_activity_date": 1479667405, "creation_date": 1479666339, "last_edit_date": 1479667405, "question_id": 40707750, "link": "https://stackoverflow.com/questions/40707750/avoiding-calling-both-contains-key-and-get-mut-on-hashmap", "closed_reason": "Duplicate", "title": "Avoiding calling both contains_key and get_mut on HashMap", "body": "<p>I'm new to Rust and I met this situation which I think can be solved with more concise code, which is however rejected by the borrow checker. I'd like to know whether there's an alternative approach to it.</p>\n\n<p>I'm trying to construct an inverted index. If the key is not previously in the <code>HashMap</code>, I have to create a new <code>postings_list</code> and insert it. If the key was already there, I will presumably have to only <strong>update</strong> the originally existing <code>postings_list</code>, instead of replacing it.</p>\n\n<p>The code that is working (very long-winded):</p>\n\n<pre><code>if !terms.contains_key(term) {\n    let mut postings_list = Vec::new();\n    postings_list.push(posting_id);\n    terms.insert(term.to_string(), postings_list);\n} else {\n    // try! can't even be used with Option... So I'm forced to write another match!\n    // let postings_list = try!(terms.get_mut(term));\n\n    match terms.get_mut(term) {\n        Some(postings_list) =&gt; {\n            postings_list.push(posting_id);\n        },\n\n        // It's impossible for this to happen...\n        None =&gt; process::exit(999)\n    }\n}\n</code></pre>\n\n<p>However, I feel one call to <code>get_mut</code> should suffice:</p>\n\n<pre><code>match terms.get_mut(term) {\n    None =&gt; {\n        let mut postings_list = Vec::new();\n        postings_list.push(posting_id);\n        terms.insert(term.to_string(), postings_list);\n    },\n    Some(postings_list) =&gt; {\n        postings_list.push(posting_id);\n    }\n}\n</code></pre>\n\n<p>The borrow checker says I borrowed a mutable reference twice, at <code>terms.get_mut(term)</code> and <code>terms.insert(term.to_string(), postings_list);</code>.</p>\n\n<p>The problem for me is that apparently calling <code>contains_key</code> and also <code>get_mut</code> both would be much less efficient than just performing one check. Or did I get it wrong? Also, the above code is much uglier.</p>\n\n<p>Am I doing this wrong? Or should I just not use <code>get_mut</code>, and should instead use <code>get</code> and then <code>insert</code> an updated <code>postings_list</code> again? Again, I'd think that would be much less efficient than simply operating on the original list stored in the <code>HashMap</code> itself. Or am I wrong?</p>\n"}, {"tags": ["rust", "traits", "borrow-checker"], "comments": [{"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 1, "creation_date": 1479676985, "post_id": 40707275, "comment_id": 68647100, "body": "Might be related: <a href=\"http://stackoverflow.com/questions/39397157/overflow-evaluating-the-requirement-but-that-kind-of-recursion-should-not-happ\" title=\"overflow evaluating the requirement but that kind of recursion should not happ\">stackoverflow.com/questions/39397157/&hellip;</a>"}, {"owner": {"reputation": 799, "user_id": 3096774, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/1dd1ee89121ffeb86343b5e70b20beb1?s=128&d=identicon&r=PG&f=1", "display_name": "apt1002", "link": "https://stackoverflow.com/users/3096774/apt1002"}, "reply_to_user": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1479691576, "post_id": 40707275, "comment_id": 68650941, "body": "Looks plausible. I still don&#39;t understand my case, though."}, {"owner": {"reputation": 799, "user_id": 3096774, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/1dd1ee89121ffeb86343b5e70b20beb1?s=128&d=identicon&r=PG&f=1", "display_name": "apt1002", "link": "https://stackoverflow.com/users/3096774/apt1002"}, "reply_to_user": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1479778461, "post_id": 40707275, "comment_id": 68691668, "body": "At least two people think some similar behaviour is a compiler bug: <a href=\"https://github.com/rust-lang/rust/issues/34137\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/34137</a>"}], "answers": [{"tags": [], "owner": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "is_accepted": false, "score": 0, "last_activity_date": 1563964463, "creation_date": 1563964463, "answer_id": 57180869, "question_id": 40707275, "link": "https://stackoverflow.com/questions/40707275/how-can-i-implement-stdconvertfrom-such-that-it-does-not-consume-its-input/57180869#57180869", "title": "How can I implement std::convert::From such that it does not consume its input?", "body": "<p>You can't avoid consuming the input in the standard <code>From</code>/<code>Into</code> traits. </p>\n\n<p>They are defined to always consume the input. Their definition specifies both input and output as owned types, with unrelated lifetimes, so you can't even \"cheat\" by trying to consume a reference.</p>\n\n<ul>\n<li><p>If you're returning a reference, you can implement <code>AsRef&lt;T&gt;</code> instead. Or if your type is a thin wrapper/smart pointer, <code>Deref&lt;T&gt;</code>. You can provide methods <code>as_foo()</code></p></li>\n<li><p>If you're returning a new (owned) object, the convention is to provide <code>to_foo()</code> methods.</p></li>\n</ul>\n"}], "owner": {"reputation": 799, "user_id": 3096774, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/1dd1ee89121ffeb86343b5e70b20beb1?s=128&d=identicon&r=PG&f=1", "display_name": "apt1002", "link": "https://stackoverflow.com/users/3096774/apt1002"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 416, "favorite_count": 1, "answer_count": 1, "score": 5, "last_activity_date": 1563964463, "creation_date": 1479663998, "last_edit_date": 1479664699, "question_id": 40707275, "link": "https://stackoverflow.com/questions/40707275/how-can-i-implement-stdconvertfrom-such-that-it-does-not-consume-its-input", "title": "How can I implement std::convert::From such that it does not consume its input?", "body": "<p>I have managed to make the Rust type checker go into an infinite loop. A very similar program compiles with no trouble. Why does the program I want not compile?</p>\n\n<p>To save your time and effort, I have made minimal versions of the two programs that isolate the problem. Of course, the minimal version is a pointless program. You'll have to use your imagination to see my motivation.</p>\n\n<h1>Success</h1>\n\n<p>Let me start with the version that works. The struct <code>F&lt;T&gt;</code> wraps a <code>T</code>. The type <code>Target</code> can be converted from an <code>F&lt;T&gt;</code> provided <code>T</code> can.</p>\n\n<pre><code>struct F&lt;T&gt;(T);\n\nimpl&lt;T&gt; From&lt;F&lt;T&gt;&gt; for Target where Target: From&lt;T&gt; {\n    fn from(a: F&lt;T&gt;) -&gt; Target {\n        let b = Target::from(a.0);\n        f(&amp;b)\n    }\n}\n</code></pre>\n\n<p>Here's an example caller:</p>\n\n<pre><code>fn main() {\n    let x = Target;\n    let y = F(F(F(x)));\n    let z = Target::from(y);\n    println!(\"{:?}\", z);\n}\n</code></pre>\n\n<p>This <a href=\"https://play.rust-lang.org/?code=%23%5Bderive(Clone%2C%20Debug)%5D%0Astruct%20Target%3B%0A%0Afn%20f(t%3A%20%26Target)%20-%3E%20Target%20%7B%0A%20%20%20%20%2F%2F%20Pretend%20this%20is%20a%20difficult%20calculation.%0A%20%20%20%20t.clone()%0A%7D%0A%0Astruct%20F%3CT%3E(T)%3B%0A%0Aimpl%3CT%3E%20From%3CF%3CT%3E%3E%20for%20Target%20where%20Target%3A%20From%3CT%3E%20%7B%0A%20%20%20%20fn%20from(a%3A%20F%3CT%3E)%20-%3E%20Target%20%7B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%20Target%3A%3Afrom(a.0)%3B%0A%20%20%20%20%20%20%20%20f(%26b)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%20Target%3B%0A%20%20%20%20let%20y%20%3D%20F(F(F(x)))%3B%0A%20%20%20%20let%20z%20%3D%20Target%3A%3Afrom(y)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20z)%3B%0A%7D&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">runs</a> and prints <code>\"Target\"</code>.</p>\n\n<h1>Failure</h1>\n\n<p>The function <code>f</code> does not consume its argument. I would prefer it if the <code>From</code> conversion also did not consume its argument, because the type <code>F&lt;T&gt;</code> could be expensive or impossible to clone. I can write a custom trait <code>FromRef</code> that differs from <a href=\"https://doc.rust-lang.org/std/convert/trait.From.html\" rel=\"nofollow noreferrer\"><code>std::convert::From</code></a> by accepting an immutable borrow instead of an owned value:</p>\n\n<pre><code>trait FromRef&lt;T&gt; {\n    fn from_ref(a: &amp;T) -&gt; Self;\n}\n</code></pre>\n\n<p>Of course, I ultimately want to use <code>From&lt;&amp;'a T&gt;</code>, but by defining my own trait I can ask my question more clearly, without messing around with lifetime parameters. (The behaviour of the type-checker is the same using <code>From&lt;&amp;'a T&gt;</code>).</p>\n\n<p>Here's my implementation:</p>\n\n<pre><code>impl&lt;T&gt; FromRef&lt;F&lt;T&gt;&gt; for Target where Target: FromRef&lt;T&gt; {\n    fn from_ref(a: &amp;F&lt;T&gt;) -&gt; Target {\n        let b = Target::from_ref(&amp;a.0);\n        f(&amp;b)\n    }\n}\n</code></pre>\n\n<p>This compiles. However, the <code>main()</code> function doesn't:</p>\n\n<pre><code>fn main() {\n    let x = Target;\n    let y = F(F(F(x)));\n    let z = Target::from_ref(y);\n    println!(\"{:?}\", z);\n}\n</code></pre>\n\n<p>It <a href=\"https://play.rust-lang.org/?code=%23%5Bderive(Clone%2C%20Debug)%5D%0Astruct%20Target%3B%0A%0Afn%20f(t%3A%20%26Target)%20-%3E%20Target%20%7B%0A%20%20%20%20%2F%2F%20Pretend%20this%20is%20a%20difficult%20calculation.%0A%20%20%20%20t.clone()%0A%7D%0A%0Astruct%20F%3CT%3E(T)%3B%0A%0Atrait%20FromRef%3CT%3E%20%7B%0A%20%20%20%20fn%20from_ref(a%3A%20%26T)%20-%3E%20Self%3B%0A%7D%0A%0Aimpl%20FromRef%3CTarget%3E%20for%20Target%20%7B%0A%20%20%20%20fn%20from_ref(a%3A%20%26Target)%20-%3E%20Target%20%7B%0A%20%20%20%20%20%20%20%20a.clone()%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20FromRef%3CF%3CT%3E%3E%20for%20Target%20where%20Target%3A%20FromRef%3CT%3E%20%7B%0A%20%20%20%20fn%20from_ref(a%3A%20%26F%3CT%3E)%20-%3E%20Target%20%7B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%20Target%3A%3Afrom_ref(%26a.0)%3B%0A%20%20%20%20%20%20%20%20f(%26b)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%20Target%3B%0A%20%20%20%20let%20y%20%3D%20F(F(F(x)))%3B%0A%20%20%20%20let%20z%20%3D%20Target%3A%3Afrom_ref(%26y)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20z)%3B%0A%7D&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">gives a huge error message</a> beginning:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0275]: overflow evaluating the requirement `_: std::marker::Sized`\n  --&gt; &lt;anon&gt;:26:13\n   |\n26 |     let z = Target::from_ref(y);\n   |             ^^^^^^^^^^^^^^^^\n   |\n   = note: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n   = note: required because of the requirements on the impl of `FromRef&lt;F&lt;_&gt;&gt;` for `Target`\n   = note: required because of the requirements on the impl of `FromRef&lt;F&lt;F&lt;_&gt;&gt;&gt;` for `Target`\n   = note: required because of the requirements on the impl of `FromRef&lt;F&lt;F&lt;F&lt;_&gt;&gt;&gt;&gt;` for `Target`\netc...\n</code></pre>\n\n<p>What am I doing wrong?</p>\n\n<h1>Update</h1>\n\n<p>I've <a href=\"https://play.rust-lang.org/?code=%23%5Bderive(Clone%2C%20Debug)%5D%0Astruct%20Target%3B%0A%0Afn%20f(t%3A%20%26Target)%20-%3E%20Target%20%7B%0A%20%20%20%20%2F%2F%20Pretend%20this%20is%20a%20difficult%20calculation.%0A%20%20%20%20t.clone()%0A%7D%0A%0Astruct%20F%3CT%3E(T)%3B%0A%0Atrait%20FromRef%3CT%3E%20%7B%0A%20%20%20%20fn%20from_ref(a%3A%20%26T)%20-%3E%20Self%3B%0A%7D%0A%0Aimpl%20FromRef%3CTarget%3E%20for%20Target%20%7B%0A%20%20%20%20fn%20from_ref(a%3A%20%26Target)%20-%3E%20Target%20%7B%0A%20%20%20%20%20%20%20%20a.clone()%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%3CT%3E%20FromRef%3CF%3CT%3E%3E%20for%20Target%20where%20Target%3A%20FromRef%3CT%3E%20%7B%0A%20%20%20%20fn%20from_ref(a%3A%20%26F%3CT%3E)%20-%3E%20Target%20%7B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%20Target%3A%3Afrom_ref(%26a.0)%3B%0A%20%20%20%20%20%20%20%20f(%26b)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%20Target%3B%0A%20%20%20%20let%20y%20%3D%20F(F(F(x)))%3B%0A%20%20%20%20let%20z%20%3D%20Target%3A%3Afrom_ref(%26y)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20z)%3B%0A%7D&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">randomly fixed it</a>!</p>\n\n<p>The problem was that I forgot to implement <code>FromRef&lt;Target&gt;</code> for <code>Target</code>.</p>\n\n<p>So I would now like to know: what was the compiler thinking? I still can't relate the problem to the error message.</p>\n"}, {"tags": ["rust", "static-linking", "rust-cargo", "musl"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479572174, "post_id": 40695010, "comment_id": 68619472, "body": "I&#39;m pretty sure the answer is: &quot;you don&#39;t, easily&quot;. You will need to rebuild libpq and OpenSSL as static libraries (and linked to MUSL?). You then have to figure out how to change the corresponding Rust libraries to link to the static versions. I&#39;m like 70% sure, but not completely."}, {"owner": {"reputation": 2481, "user_id": 1106456, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/60b23f3de35058180807f35b623fcf83?s=128&d=identicon&r=PG", "display_name": "GolDDranks", "link": "https://stackoverflow.com/users/1106456/golddranks"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479573120, "post_id": 40695010, "comment_id": 68619766, "body": "The thing is, I did rebuild them against MUSL, in the prefix <code>&#47;usr&#47;local&#47;musl</code>. And I&#39;m trying to get the corresponding libs to link to the static versions by trying to set the environment right, but apparently I&#39;m failing. The way you put it sounds like I&#39;d have to modify the libraries themselves, is that what you meant?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479573456, "post_id": 40695010, "comment_id": 68619892, "body": "I mean, once you have compiled the MUSL versions of the C libraries (nicely done!), you will have to poke at each of the Rust bindings to figure out how to change how they link and to what. For example, <a href=\"https://github.com/sfackler/rust-openssl#manual-configuration\" rel=\"nofollow noreferrer\">openssl has environment variables</a>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479588283, "post_id": 40695010, "comment_id": 68624718, "body": "This was <a href=\"https://www.reddit.com/r/rust/comments/5ds9fb/help_with_static_linking/?ref=share&amp;ref_source=link\" rel=\"nofollow noreferrer\">cross posted to Reddit</a>."}, {"owner": {"reputation": 2481, "user_id": 1106456, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/60b23f3de35058180807f35b623fcf83?s=128&d=identicon&r=PG", "display_name": "GolDDranks", "link": "https://stackoverflow.com/users/1106456/golddranks"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479626836, "post_id": 40695010, "comment_id": 68631802, "body": "Thanks for the pointer about the environment variables! That was a crucial clue."}], "answers": [{"comments": [{"owner": {"reputation": 4684, "user_id": 1655478, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/5424ecc7236cd16441fafd0d584eb7c5?s=128&d=identicon&r=PG", "display_name": "thouliha", "link": "https://stackoverflow.com/users/1655478/thouliha"}, "edited": false, "score": 0, "creation_date": 1571899229, "post_id": 40701664, "comment_id": 103393831, "body": "Could you please repost this docker file, that link is dead"}, {"owner": {"reputation": 2481, "user_id": 1106456, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/60b23f3de35058180807f35b623fcf83?s=128&d=identicon&r=PG", "display_name": "GolDDranks", "link": "https://stackoverflow.com/users/1106456/golddranks"}, "reply_to_user": {"reputation": 4684, "user_id": 1655478, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/5424ecc7236cd16441fafd0d584eb7c5?s=128&d=identicon&r=PG", "display_name": "thouliha", "link": "https://stackoverflow.com/users/1655478/thouliha"}, "edited": false, "score": 0, "creation_date": 1571986966, "post_id": 40701664, "comment_id": 103427063, "body": "Ah, sorry, the project moved over to GitLab. I&#39;ll update the link."}], "tags": [], "owner": {"reputation": 2481, "user_id": 1106456, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/60b23f3de35058180807f35b623fcf83?s=128&d=identicon&r=PG", "display_name": "GolDDranks", "link": "https://stackoverflow.com/users/1106456/golddranks"}, "is_accepted": true, "score": 12, "last_activity_date": 1592278420, "last_edit_date": 1592278420, "creation_date": 1479626772, "answer_id": 40701664, "question_id": 40695010, "link": "https://stackoverflow.com/questions/40695010/how-to-compile-a-static-musl-binary-of-a-rust-project-with-native-dependencies/40701664#40701664", "title": "How to compile a static musl binary of a Rust project with native dependencies?", "body": "<p>The problem was that for each crate providing a native dependency \u2013 say OpenSSL \u2013 there is the <code>build.rs</code> build script that is in charge of communicating the build and linking options to Cargo and to <code>rustc</code>. (For example: they print out something like <code>cargo:rustc-link-lib=static=ssl</code> which Cargo then reads and acts accordingly.)</p>\n\n<p>So just setting the \"standard\" GCC environmental variables is hardly going to have any effect. You must check each and every <code>build.rs</code> separately to know how to coerce that exact crate to convey cargo its options. For OpenSSL, its env vars like <code>OPENSSL_DIR</code>, <code>OPENSSL_STATIC</code> etc.</p>\n\n<p>Another hurdle is that if you use compiler plugins, they might be compiled with the target triplet too (at least docker_codegen). On the other hand, they are linked dynamically during the compiling process. This mean that not only must static libraries be linked correctly, you must also have dynamic libraries of the <s>target</s> host variety, like Musl <code>libc.so</code> in place, and correctly set (<code>LD_LIBRARY_PATH</code> etc.).</p>\n\n<p>I made a thoroughly commented Dockerfile that builds my project statically with some native dependencies. It might be of help for others too. </p>\n\n<p><a href=\"https://gitlab.com/rust_musl_docker/image\" rel=\"nofollow noreferrer\">https://gitlab.com/rust_musl_docker/image</a></p>\n"}, {"comments": [{"owner": {"reputation": 2384, "user_id": 3553432, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/fb2106952e54afdb0d370799f988ba25?s=128&d=identicon&r=PG", "display_name": "nikoss", "link": "https://stackoverflow.com/users/3553432/nikoss"}, "edited": false, "score": 1, "creation_date": 1583100068, "post_id": 53315626, "comment_id": 106993189, "body": "this cannot find openssl and does not build anything"}], "tags": [], "owner": {"reputation": 5956, "user_id": 354132, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/1ac5fd6aa3d8027e6f022d789e92cddd?s=128&d=identicon&r=PG", "display_name": "Arnout Engelen", "link": "https://stackoverflow.com/users/354132/arnout-engelen"}, "is_accepted": false, "score": -3, "last_activity_date": 1542297669, "last_edit_date": 1542297669, "creation_date": 1542272162, "answer_id": 53315626, "question_id": 40695010, "link": "https://stackoverflow.com/questions/40695010/how-to-compile-a-static-musl-binary-of-a-rust-project-with-native-dependencies/53315626#53315626", "title": "How to compile a static musl binary of a Rust project with native dependencies?", "body": "<p>If you want to statically link a Rust program without native dependencies, that is much easier:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ rustup target add x86_64-unknown-linux-musl\n$ cargo build --release --target=x86_64-unknown-linux-musl\n</code></pre>\n"}], "owner": {"reputation": 2481, "user_id": 1106456, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/60b23f3de35058180807f35b623fcf83?s=128&d=identicon&r=PG", "display_name": "GolDDranks", "link": "https://stackoverflow.com/users/1106456/golddranks"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5615, "favorite_count": 3, "accepted_answer_id": 40701664, "answer_count": 2, "score": 7, "last_activity_date": 1592278420, "creation_date": 1479571565, "last_edit_date": 1479572018, "question_id": 40695010, "link": "https://stackoverflow.com/questions/40695010/how-to-compile-a-static-musl-binary-of-a-rust-project-with-native-dependencies", "title": "How to compile a static musl binary of a Rust project with native dependencies?", "body": "<p>I have a project with dependencies on Hyper and Diesel, and because of that, on native libraries OpenSSL and libpq. The project builds on nightly Rust because it uses compiler plugins.</p>\n\n<p>My current attempt is to build on a Docker container. I have the MUSL libc and the libraries <code>make</code>'d and installed with prefix <code>/usr/local/musl</code>. I run <code>cargo</code> with the following command: (Not sure if some of the options are redundant, I'm not too well-versed with the compiler chain, and not even sure if they end up to the linker, but I have to try, right.)</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>LDFLAGS=\"-static -L/usr/local/musl/lib\" \\\nLD_LIBRARY_PATH=/usr/local/musl/lib:$LD_LIBRARY_PATH \\\nCFLAGS=\"-I/usr/local/musl/include\" \\\nPKG_CONFIG_PATH=/usr/local/musl/lib/pkgconfig \\\ncargo build --release --target=x86_64-unknown-linux-musl\n</code></pre>\n\n<p>When I <code>ldd</code> the resulting file, it reveals this:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ ldd server\nlinux-vdso.so.1 (0x00007fffb878e000)\nlibpq.so.5 =&gt; /usr/local/musl/lib/libpq.so.5 (0x00007f4d730e7000)\nlibssl.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libssl.so.1.0.0 (0x00007f4d72e82000)\nlibcrypto.so.1.0.0 =&gt; /usr/lib/x86_64-linux-gnu/libcrypto.so.1.0.0 (0x00007f4d72a85000)\nlibc.so =&gt; /usr/local/musl/lib/libc.so (0x00007f4d727f6000)\nlibdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4d725f2000)\nlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4d72246000)\n/lib/ld64.so.1 =&gt; /lib64/ld-linux-x86-64.so.2 (0x000055e2124a2000)\n</code></pre>\n\n<p>There's all that dynamically linked stuff, and some even with the \"x86_64-linux-gnu\" chain! What went wrong?</p>\n\n<p>I can make statically linked, simple pure-Rust projects without problems. <code>ldd</code> says that they are statically linked, and they run without problems, unlike the executable I have problems with.</p>\n\n<p>When I used <code>--verbose</code> with Cargo, I got the following <code>rustc</code> command that actually builds the executable: <a href=\"http://pastebin.com/ywv0zNBK\" rel=\"noreferrer\">http://pastebin.com/ywv0zNBK</a> (Oops, that one had a custom <code>outdir</code> and <code>-Z print-link-args</code>, added by me)\nAdding the <code>print-link-args</code> flag, I got the following linker command: <a href=\"http://pastebin.com/Aw43qd7h\" rel=\"noreferrer\">http://pastebin.com/Aw43qd7h</a></p>\n\n<p>How do I get <code>cargo</code> or <code>rustc</code> to believe that I want a static binary?</p>\n"}, {"tags": ["javascript", "rust", "emscripten", "asm.js", "webassembly"], "comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 2, "creation_date": 1479554124, "post_id": 40691711, "comment_id": 68613936, "body": "Have you had a look at the Emscripten output? That might give you a hint as to why the function won&#39;t run."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479565288, "post_id": 40691711, "comment_id": 68617202, "body": "Why did you decide to ignore the <b>next</b> tutorial that <a href=\"http://www.hellorust.com/emscripten/demos/06-wasm-in-html/\" rel=\"nofollow noreferrer\">explains how to Embed Wasm in HTML</a>?"}, {"owner": {"reputation": 2060, "user_id": 2561805, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/ad2d8c097cfaa8fdc3ac87bfa9b8d277?s=128&d=identicon&r=PG", "display_name": "goo", "link": "https://stackoverflow.com/users/2561805/goo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479569836, "post_id": 40691711, "comment_id": 68618701, "body": "@Shepmaster I want to <i>call</i> Rust from the web browser. The tutorial you linked to only demostrates how to <i>run</i> Rust in a web browser (if that makes sense)."}, {"owner": {"reputation": 2060, "user_id": 2561805, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/ad2d8c097cfaa8fdc3ac87bfa9b8d277?s=128&d=identicon&r=PG", "display_name": "goo", "link": "https://stackoverflow.com/users/2561805/goo"}, "reply_to_user": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 1, "creation_date": 1479570019, "post_id": 40691711, "comment_id": 68618753, "body": "@Aurora0001 I will as soon as I get back home, but the function is clearly there (right?) since printing the function (without calling it) works fine, which is odd to me."}, {"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 0, "creation_date": 1479570117, "post_id": 40691711, "comment_id": 68618787, "body": "@goo, my guess is that the function contains some invalid code for some reason (or is perhaps being invoked incorrectly) leading to this error."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1479570847, "post_id": 40691711, "comment_id": 68619031, "body": "The posted code works perfectly in Chrome Canary (<code>56.0.2920.0</code>), Safari (<code>10.0.1</code>), and Firefox (<code>50.0</code>). You probably aren&#39;t compiling something correctly. I&#39;m using Rust nightly (<code>ba872f270 2016-11-17</code>) and Emscripten <code>1.36.14</code>."}, {"owner": {"reputation": 2060, "user_id": 2561805, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/ad2d8c097cfaa8fdc3ac87bfa9b8d277?s=128&d=identicon&r=PG", "display_name": "goo", "link": "https://stackoverflow.com/users/2561805/goo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479573119, "post_id": 40691711, "comment_id": 68619765, "body": "@Shepmaster Thank you. I&#39;m now using Rust nightly-2016-11-17 and it works."}, {"owner": {"reputation": 2060, "user_id": 2561805, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/ad2d8c097cfaa8fdc3ac87bfa9b8d277?s=128&d=identicon&r=PG", "display_name": "goo", "link": "https://stackoverflow.com/users/2561805/goo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479573276, "post_id": 40691711, "comment_id": 68619815, "body": "@Shepmaster Should I accept your answer (after you post your response as an answer) as the correct one, delete the question, or leave it?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479573603, "post_id": 40691711, "comment_id": 68619944, "body": "Can you tell me what version of Rust you had before updating? I&#39;d prefer to link to a specific git commit that fixes the problem, and that would help narrowing it down."}, {"owner": {"reputation": 2060, "user_id": 2561805, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/ad2d8c097cfaa8fdc3ac87bfa9b8d277?s=128&d=identicon&r=PG", "display_name": "goo", "link": "https://stackoverflow.com/users/2561805/goo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479576401, "post_id": 40691711, "comment_id": 68620956, "body": "@Shepmaster Sure. Rust nightly-2016-11-04"}], "owner": {"reputation": 2060, "user_id": 2561805, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/ad2d8c097cfaa8fdc3ac87bfa9b8d277?s=128&d=identicon&r=PG", "display_name": "goo", "link": "https://stackoverflow.com/users/2561805/goo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 472, "favorite_count": 1, "answer_count": 0, "score": 5, "last_activity_date": 1479567219, "creation_date": 1479550887, "last_edit_date": 1479567219, "question_id": 40691711, "link": "https://stackoverflow.com/questions/40691711/calling-rust-compiled-to-emscripten-produces-the-error-module-dyncall-ii-is-not", "title": "Calling Rust compiled to Emscripten produces the error Module.dynCall_ii is not a function", "body": "<p>I'm following along with the <a href=\"http://www.hellorust.com/emscripten/demos/04-call-into-lib/\" rel=\"nofollow noreferrer\">call from JavaScript</a> tutorial. Instead of using node, I'm calling directly from a web browser:</p>\n\n<p><strong>hello_world/index.html</strong></p>\n\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;&lt;/head&gt;\n  &lt;body&gt;\n\n    &lt;script src=\"hello_world.js\"&gt;&lt;/script&gt;\n\n    &lt;script type='text/javascript'&gt;\n      var hello_world = cwrap('hello_world', 'number', []);\n      var result = hello_world();\n      console.log(\"result: \", result);\n    &lt;/script&gt;\n\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p><strong>hello_world/src/main.rs</strong></p>\n\n<pre><code>#![feature(link_args)]\n\n#[link_args = \"-s EXPORTED_FUNCTIONS=['_hello_world']\"]\nextern {}\n\n#[no_mangle]\npub fn hello_world() -&gt; isize {\n    println!(\"Hello World!\");\n\n    41 + 1\n}\n\nfn main() {\n    // Intentionally left blank\n}\n</code></pre>\n\n<p>Command:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>cargo build --target asmjs-unknown-emscripten\n</code></pre>\n\n<p>Error message in Safari:</p>\n\n<blockquote>\n  <p>TypeError: Module[\"dynCall_ii\"] is not a function. (In\n  'Module\"dynCall_ii\"', 'Module[\"dynCall_ii\"]' is undefined)</p>\n</blockquote>\n\n<p>Error message in Firefox Nightly:</p>\n\n<blockquote>\n  <p>TypeError: Module.dynCall_ii is not a function <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Not_a_function\" rel=\"nofollow noreferrer\">Learn More</a></p>\n</blockquote>\n\n<p>If I just print the function:</p>\n\n<pre><code>var hello_world = cwrap('hello_world', 'number', []);\nconsole.log(\"function: \", hello_world);\n</code></pre>\n\n<p>I get (on Firefox Nightly):</p>\n\n<blockquote>\n  <p>function:  function asm._hello_world()</p>\n</blockquote>\n"}, {"tags": ["iterator", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1479518269, "post_id": 40688205, "comment_id": 68606812, "body": "<i>with possible future changes to the standard library</i> \u2014 not just the standard library, but any library that your code may link (or be linked to) in the future."}], "answers": [{"comments": [{"owner": {"reputation": 799, "user_id": 3096774, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/1dd1ee89121ffeb86343b5e70b20beb1?s=128&d=identicon&r=PG&f=1", "display_name": "apt1002", "link": "https://stackoverflow.com/users/3096774/apt1002"}, "edited": false, "score": 0, "creation_date": 1479580072, "post_id": 40689315, "comment_id": 68622218, "body": "Better still, your <code>buffer_from_iter</code> can be <code>Buffer::from_iter</code>, so as to remove a type variable and lots of &quot;as Buffer&quot; clauses. I worked this much out by myself. :-( The idea of using a macro is good; I wouldn&#39;t mind writing &quot;buffer_from_iter!(MyType)&quot; occasionally. I will accept an answer that shows how to do that."}, {"owner": {"reputation": 799, "user_id": 3096774, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/1dd1ee89121ffeb86343b5e70b20beb1?s=128&d=identicon&r=PG&f=1", "display_name": "apt1002", "link": "https://stackoverflow.com/users/3096774/apt1002"}, "edited": false, "score": 0, "creation_date": 1479587152, "post_id": 40689315, "comment_id": 68624396, "body": "How about this? (Learning as I go along!) <a href=\"https://gist.github.com/apt1002/1b5139f0e0d4e700b5732e0ae44fe3fb\" rel=\"nofollow noreferrer\">gist.github.com/apt1002/1b5139f0e0d4e700b5732e0ae44fe3fb</a>"}], "tags": [], "owner": {"reputation": 35314, "user_id": 344347, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/1d83837bce9d9a2656c4f5704d40c430?s=128&d=identicon&r=PG", "display_name": "Pavel Strakhov", "link": "https://stackoverflow.com/users/344347/pavel-strakhov"}, "is_accepted": false, "score": 0, "last_activity_date": 1479530852, "creation_date": 1479530852, "answer_id": 40689315, "question_id": 40688205, "link": "https://stackoverflow.com/questions/40688205/how-can-i-automatically-implement-fromiterator/40689315#40689315", "title": "How can I automatically implement FromIterator?", "body": "<p>You can't implement a trait from another crate for an arbitrary type, only for a type from your crate. However, you can move the implementation to a function and reduce amount of duplicated code:</p>\n\n<pre><code>fn buffer_from_iter&lt;I, B&gt;(iter: I) -&gt; B\n    where I: IntoIterator&lt;Item = B::Item&gt;, \n          B: Buffer\n{\n    let mut iter = iter.into_iter();\n    let (lower, _) = iter.size_hint();\n    let mut ans = B::with_capacity(lower);\n    while let Some(x) = iter.next() {\n        ans.push(x);\n    }\n    ans\n}\n\nstruct S1;\nimpl Buffer for S1 {\n    type Item = i32;\n    fn with_capacity(c: usize) -&gt; Self { unimplemented!() }\n    fn push(&amp;mut self, item: Self::Item) { unimplemented!() }\n}\n\nimpl std::iter::FromIterator&lt;&lt;S1 as Buffer&gt;::Item&gt; for S1 {\n    fn from_iter&lt;I&gt;(iter: I) -&gt; Self\n        where I: IntoIterator&lt;Item = &lt;S1 as Buffer&gt;::Item&gt;\n    {\n        buffer_from_iter(iter)\n    }\n}\n</code></pre>\n\n<p>This implementation of <code>FromIterator</code> can be wrapped into a macro to further reduce code duplication.</p>\n"}], "owner": {"reputation": 799, "user_id": 3096774, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/1dd1ee89121ffeb86343b5e70b20beb1?s=128&d=identicon&r=PG&f=1", "display_name": "apt1002", "link": "https://stackoverflow.com/users/3096774/apt1002"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 534, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1479530852, "creation_date": 1479518127, "last_edit_date": 1479518180, "question_id": 40688205, "link": "https://stackoverflow.com/questions/40688205/how-can-i-automatically-implement-fromiterator", "title": "How can I automatically implement FromIterator?", "body": "<p>I have written a trait that specifies some methods similar to those of <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html\" rel=\"nofollow noreferrer\"><code>Vec</code></a>:</p>\n\n<pre><code>pub trait Buffer {\n    type Item;\n    fn with_capacity(c: usize) -&gt; Self;\n    fn push(&amp;mut self, item: Self::Item);\n}\n</code></pre>\n\n<p>I would like to implement <a href=\"https://doc.rust-lang.org/std/iter/trait.FromIterator.html\" rel=\"nofollow noreferrer\"><code>FromIterator</code></a> for all types that implement <code>Buffer</code>, as follows:</p>\n\n<pre><code>impl&lt;T&gt; iter::FromIterator&lt;T::Item&gt; for T\n    where T: Buffer\n{\n    fn from_iter&lt;I&gt;(iter: I) -&gt; Self\n        where I: IntoIterator&lt;Item = T&gt;\n    {\n        let mut iter = iter.into_iter();\n        let (lower, _) = iter.size_hint();\n        let ans = Self::with_capacity(lower);\n        while let Some(x) = iter.next() {\n            ans.push(x);\n        }\n        ans\n    }\n}\n</code></pre>\n\n<p>The compiler won't let me:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0210]: type parameter `T` must be used as the type parameter\nfor some local type (e.g. `MyStruct&lt;T&gt;`); only traits defined in the\ncurrent crate can be implemented for a type parameter\n</code></pre>\n\n<p>I think I understand the error message; it is preventing me from writing code that is incompatible with possible future changes to the standard library.</p>\n\n<p>The only way around this error appears to be to implement <code>FromIterator</code> separately for every type for which I implement <code>Buffer</code>. This will involve copying out exactly the same code many times. Is there a a way to share the same implementation between all <code>Buffer</code> types?</p>\n"}, {"tags": ["rust", "lifetime", "borrow-checker", "borrowing", "lifetime-scoping"], "answers": [{"comments": [{"owner": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "edited": false, "score": 0, "creation_date": 1479520464, "post_id": 40688169, "comment_id": 68607214, "body": "Brilliant, it seems so easy and obvious once you see it, but it likely would have taken me a very long time to stumble onto it by myself.  Thanks so much."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1479517661, "creation_date": 1479517661, "answer_id": 40688169, "question_id": 40687955, "link": "https://stackoverflow.com/questions/40687955/am-i-incorrectly-implementing-intoiterator-for-a-reference-to-a-lazylist-impleme/40688169#40688169", "title": "Am I incorrectly implementing IntoIterator for a reference to a LazyList implementation or is this a Rust bug?", "body": "<p>When you implemented <code>IntoIterator</code>, you unified the lifetimes between the reference to the list and the items that the list contains:</p>\n\n<pre><code>impl&lt;'a&gt; IntoIterator for &amp;'a LazyList&lt;'a&gt;\n</code></pre>\n\n<p>That requires that <code>'a</code> must be the shorter of the lifetimes. That's not useful in this case. Instead, you need to have two distinct lifetimes:</p>\n\n<pre><code>impl&lt;'l, 'i&gt; IntoIterator for &amp;'l LazyList&lt;'i&gt; {\n    type Item = &amp;'i i32;\n    type IntoIter = Iter&lt;'i&gt;;\n\n    fn into_iter(self) -&gt; Self::IntoIter {\n        self.iter()\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "is_accepted": false, "score": 0, "last_activity_date": 1480067835, "last_edit_date": 1480067835, "creation_date": 1479537962, "answer_id": 40690020, "question_id": 40687955, "link": "https://stackoverflow.com/questions/40687955/am-i-incorrectly-implementing-intoiterator-for-a-reference-to-a-lazylist-impleme/40690020#40690020", "title": "Am I incorrectly implementing IntoIterator for a reference to a LazyList implementation or is this a Rust bug?", "body": "<p>For those who find this question by searches for Rust, Lazy, and LazyList, I here post the final generic working code for Lazy and LazyList with both non and thread-safe versions working with current stable Rust version 1.13.</p>\n\n<p>The code contains some methods not actually used by the included test code, and especially the <code>unwrap()</code> methods are useless here as we can't consume a type embedded in another type (unless we replace an interior mutable value); a few more tests would need to be devised for the <code>singleton()</code> method, the <code>unwrap()</code> methods, and the <code>tail()</code>method.</p>\n\n<p>Because we can't generally unwrap, the embedded type must be Clone; this costs some performance in the copy operations involved, so when types are large (copy-wise), one may want to wrap them in an Rc for faster reference--counted cloning.</p>\n\n<p>The code is as follows:</p>\n\n<pre><code>// only necessary because Box&lt;FnOnce() -&gt; R&gt; doesn't work...\nmod thunk {\n    pub trait Invoke&lt;R = ()&gt; {\n        fn invoke(self: Box&lt;Self&gt;) -&gt; R;\n    }\n\n    impl&lt;R, F: FnOnce() -&gt; R&gt; Invoke&lt;R&gt; for F {\n        #[inline(always)]\n        fn invoke(self: Box&lt;F&gt;) -&gt; R { (*self)() }\n    }\n}\n\n// Lazy is lazily evaluated contained value using the above Invoke trait\n// instead of the desire Box&lt;FnOnce() -&gt; T&gt; or a stable FnBox (currently not)...\nmod lazy {\n    use thunk::Invoke;\n    use std::cell::UnsafeCell;\n    use std::mem::replace;\n    use std::ops::Deref;\n\n    // Lazy is lazily evaluated contained value using the above Invoke trait\n    // instead of the desire Box&lt;FnOnce() -&gt; T&gt; or a stable FnBox (currently not)...\n    pub struct Lazy&lt;'a, T: 'a&gt;(UnsafeCell&lt;LazyState&lt;'a, T&gt;&gt;);\n\n    enum LazyState&lt;'a, T: 'a&gt; {\n        Unevaluated(Box&lt;Invoke&lt;T&gt; + 'a&gt;),\n        EvaluationInProgress,\n        Evaluated(T),\n    }\n\n    use self::LazyState::*;\n\n//  impl&lt;'a, T:'a&gt; !Sync for Lazy&lt;'a, T&gt; {}\n\n    impl&lt;'a, T: 'a&gt; Lazy&lt;'a, T&gt; {\n        #[inline]\n        pub fn new&lt;F: 'a + FnOnce() -&gt; T&gt;(func: F) -&gt; Lazy&lt;'a, T&gt; {\n            Lazy(UnsafeCell::new(Unevaluated(Box::new(func))))\n        }\n        #[inline]\n        pub fn evaluated(val: T) -&gt; Lazy&lt;'a, T&gt; {\n            Lazy(UnsafeCell::new(Evaluated(val)))\n        }\n        #[inline(always)]\n        fn force&lt;'b&gt;(&amp;'b self) {\n            unsafe {\n                match *self.0.get() {\n                    Evaluated(_) =&gt; return, // nothing required; already Evaluated\n                    EvaluationInProgress =&gt; panic!(\"Lazy::force called recursively!!!\"),\n                    _ =&gt; {\n                        let ue = replace(&amp;mut *self.0.get(), EvaluationInProgress);\n                        if let Unevaluated(thnk) = ue {\n                            *self.0.get() = Evaluated(thnk.invoke());\n                        } // no other possiblity!\n                    }\n                }\n            }\n        }\n        #[inline]\n        pub fn unwrap&lt;'b&gt;(self) -&gt; T where T: 'b { // consumes the object to produce the value\n            self.force(); // evaluatate if not evealutated\n            match unsafe { self.0.into_inner() } {\n                Evaluated(v) =&gt; v,\n                _ =&gt; unreachable!() // previous code guarantees never not Evaluated\n            }\n        }\n    }\n\n    impl&lt;'a, T: 'a&gt; Deref for Lazy&lt;'a, T&gt; {\n        type Target = T;\n        #[inline]\n        fn deref&lt;'b&gt;(&amp;'b self) -&gt; &amp;'b T {\n            self.force(); // evaluatate if not evalutated\n            match unsafe { &amp;*self.0.get() } {\n                &amp;Evaluated(ref v) =&gt; return v,\n                _ =&gt; unreachable!(),\n            }\n        }\n    }\n}\n\nmod lazy_sync {\n    use thunk::Invoke;\n    use std::cell::UnsafeCell;\n    use std::mem::replace;\n    use std::sync::Mutex;\n    use std::sync::atomic::AtomicBool;\n    use std::sync::atomic::Ordering::Relaxed;\n    use std::ops::Deref;\n\n    pub struct Lazy&lt;'a, T: 'a + Send + Sync&gt;(\n        UnsafeCell&lt;LazyState&lt;'a, T&gt;&gt;, AtomicBool, Mutex&lt;()&gt;);\n\n    enum LazyState&lt;'a, T: 'a + Send + Sync&gt; {\n        Unevaluated(Box&lt;Invoke&lt;T&gt; + 'a&gt;),\n        EvaluationInProgress,\n        Evaluated(T),\n    }\n\n    use self::LazyState::*;\n\n    unsafe impl&lt;'a, T: 'a + Send + Sync&gt; Send for Lazy&lt;'a, T&gt; {}\n    unsafe impl&lt;'a, T: 'a + Send + Sync&gt; Sync for Lazy&lt;'a, T&gt; {}\n\n    impl&lt;'a, T: 'a + Send + Sync&gt; Lazy&lt;'a, T&gt; {\n        #[inline]\n        pub fn new&lt;F: 'a + FnOnce() -&gt; T&gt;(func: F) -&gt; Lazy&lt;'a, T&gt; {\n            Lazy(UnsafeCell::new(Unevaluated(Box::new(func))),\n               AtomicBool::new(false), Mutex::new(()))\n        }\n        #[inline]\n        pub fn evaluated(val: T) -&gt; Lazy&lt;'a, T&gt; {\n            Lazy(UnsafeCell::new(Evaluated(val)),\n               AtomicBool::new(true), Mutex::new(()))\n        }\n        #[inline(always)]\n        fn force&lt;'b&gt;(&amp;'b self) {\n            unsafe {\n            if !self.1.load(Relaxed) {\n              let _ = self.2.lock();\n              // if we don't get the false below, means\n              // another thread already handled the thunk,\n              // including setting to true, still processing when checked\n              if !self.1.load(Relaxed) {\n                    match *self.0.get() {\n                        Evaluated(_) =&gt; return, // nothing required; already Evaluated\n                        EvaluationInProgress =&gt; unreachable!(), // because lock race recursive evals...\n                        _ =&gt; {\n                            if let Unevaluated(thnk) = replace(&amp;mut *self.0.get(), EvaluationInProgress) {\n                                *self.0.get() = Evaluated(thnk.invoke());\n                            } // no other possiblity!\n                        }\n                    }\n                  self.1.store(true, Relaxed);\n                }\n            }\n          }\n        }\n\n        #[inline]\n        pub fn unwrap&lt;'b&gt;(self) -&gt; T where T: 'b { // consumes the object to produce the value\n            self.force(); // evaluatate if not evealutated\n            match unsafe { self.0.into_inner() } {\n                Evaluated(v) =&gt; v,\n                _ =&gt; unreachable!() // previous code guarantees never not Evaluated\n            }\n        }\n    }\n\n    impl&lt;'a, T: 'a + Send + Sync&gt; Deref for Lazy&lt;'a, T&gt; {\n        type Target = T;\n        #[inline]\n        fn deref&lt;'b&gt;(&amp;'b self) -&gt; &amp;'b T {\n          self.force(); // evaluatate if not evalutated\n              match unsafe { &amp;*self.0.get() } {\n                  &amp;Evaluated(ref v) =&gt; return v,\n                  _ =&gt; unreachable!(),\n              }\n        }\n    }\n}\n\n// LazyList is an immutable lazily-evaluated persistent (memoized) singly-linked list\n// similar to lists in Haskell, although here only tails are lazy...\n//   depends on the contained type being Clone so that the LazyList can be\n//   extracted from the reference-counted Rc heap objects in which embedded.\nmod lazylist {\n    use lazy::Lazy;\n    use std::rc::Rc;\n    use std::iter::FromIterator;\n    use std::mem::{replace, swap};\n\n    #[derive(Clone)]\n    pub enum LazyList&lt;'a, T: 'a + Clone&gt; {\n        Empty,\n        Cons(T, RcLazyListNode&lt;'a, T&gt;),\n    }\n\n    pub use self::LazyList::Empty;\n    use self::LazyList::Cons;\n\n    type RcLazyListNode&lt;'a, T: 'a&gt; = Rc&lt;Lazy&lt;'a, LazyList&lt;'a, T&gt;&gt;&gt;;\n\n//  impl&lt;'a, T:'a&gt; !Sync for LazyList&lt;'a, T&gt; {}\n\n    impl&lt;'a, T: 'a + Clone&gt; LazyList&lt;'a, T&gt; {\n        #[inline]\n        pub fn singleton(v: T) -&gt; LazyList&lt;'a, T&gt; {\n            Cons(v, Rc::new(Lazy::evaluated(Empty)))\n        }\n        #[inline]\n        pub fn cons&lt;F&gt;(v: T, cntf: F) -&gt; LazyList&lt;'a, T&gt;\n            where F: 'a + FnOnce() -&gt; LazyList&lt;'a, T&gt;\n        {\n            Cons(v, Rc::new(Lazy::new(cntf)))\n        }\n        #[inline]\n        pub fn head&lt;'b&gt;(&amp;'b self) -&gt; &amp;'b T {\n            if let Cons(ref hd, _) = *self {\n                return hd;\n            }\n            panic!(\"LazyList::head called on an Empty LazyList!!!\")\n        }\n        #[inline]\n        pub fn tail&lt;'b&gt;(&amp;'b self) -&gt; &amp;'b Lazy&lt;'a, LazyList&lt;'a, T&gt;&gt; {\n            if let Cons(_, ref rlln) = *self {\n                return &amp;*rlln;\n            }\n            panic!(\"LazyList::tail called on an Empty LazyList!!!\")\n        }\n        #[inline]\n        pub fn unwrap(self) -&gt; (T, RcLazyListNode&lt;'a, T&gt;) {\n            // consumes the object\n            if let Cons(hd, rlln) = self {\n                return (hd, rlln);\n            }\n            panic!(\"LazyList::unwrap called on an Empty LazyList!!!\")\n        }\n        #[inline]\n        fn iter(&amp;self) -&gt; Iter&lt;'a, T&gt; {\n            Iter(self)\n        }\n    }\n\n    impl&lt;'a, T: 'a + Clone&gt; Iterator for LazyList&lt;'a, T&gt; {\n        type Item = T;\n\n        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n            match replace(self, Empty) {\n                Cons(hd, rlln) =&gt; {\n                    let mut newll = (*rlln).clone();\n                    swap(self, &amp;mut newll); // self now contains tail, newll contains the Empty\n                    Some(hd)\n                }\n                _ =&gt; None,\n            }\n        }\n    }\n\n    pub struct Iter&lt;'a, T: 'a + Clone&gt;(*const LazyList&lt;'a, T&gt;);\n\n    impl&lt;'a, T: 'a + Clone&gt; Iterator for Iter&lt;'a, T&gt; {\n        type Item = &amp;'a T;\n\n        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n            unsafe {\n                if let LazyList::Cons(ref v, ref r) = *self.0 {\n                    self.0 = &amp;***r;\n                    Some(v)\n                } else {\n                    None\n                }\n            }\n        }\n    }\n\n    impl&lt;'i, 'l, T: 'i + Clone&gt; IntoIterator for &amp;'l LazyList&lt;'i, T&gt; {\n        type Item = &amp;'i T;\n        type IntoIter = Iter&lt;'i, T&gt;;\n\n        fn into_iter(self) -&gt; Self::IntoIter {\n            self.iter()\n        }\n    }\n\n    impl&lt;'a, T: 'a + Clone&gt; FromIterator&lt;T&gt; for LazyList&lt;'a, T&gt; {\n        fn from_iter&lt;I: IntoIterator&lt;Item = T&gt; + 'a&gt;(itrbl: I) -&gt; LazyList&lt;'a, T&gt; {\n            let itr = itrbl.into_iter();\n            #[inline(always)]\n            fn next_iter&lt;'b, R, Itr&gt;(mut iter: Itr) -&gt; LazyList&lt;'b, R&gt;\n                where R: 'b + Clone,\n                      Itr: 'b + Iterator&lt;Item = R&gt;\n            {\n                match iter.next() {\n                    Some(val) =&gt; LazyList::cons(val, move || next_iter(iter)),\n                    None =&gt; Empty,\n                }\n            }\n            next_iter(itr)\n        }\n    }\n\n}\n\nmod lazylist_sync {\n    use lazy_sync::Lazy;\n    use std::sync::Arc as Rc;\n    use std::iter::FromIterator;\n    use std::mem::{replace, swap};\n\n    #[derive(Clone)]\n    pub enum LazyList&lt;'a, T: 'a + Send + Sync + Clone&gt; {\n        Empty,\n        Cons(T, RcLazyListNode&lt;'a, T&gt;),\n    }\n\n    pub use self::LazyList::Empty;\n    use self::LazyList::Cons;\n\n    type RcLazyListNode&lt;'a, T: 'a&gt; = Rc&lt;Lazy&lt;'a, LazyList&lt;'a, T&gt;&gt;&gt;;\n\n    unsafe impl&lt;'a, T: 'a + Send + Sync + Clone&gt; Send for LazyList&lt;'a, T&gt; {}\n    unsafe impl&lt;'a, T: 'a + Send + Sync + Clone&gt; Sync for LazyList&lt;'a, T&gt; {}\n\n    impl&lt;'a, T: 'a + Send + Sync + Clone&gt; LazyList&lt;'a, T&gt; {\n        #[inline]\n        pub fn singleton(v: T) -&gt; LazyList&lt;'a, T&gt; {\n            Cons(v, Rc::new(Lazy::evaluated(Empty)))\n        }\n        #[inline]\n        pub fn cons&lt;F&gt;(v: T, cntf: F) -&gt; LazyList&lt;'a, T&gt;\n            where F: 'a + FnOnce() -&gt; LazyList&lt;'a, T&gt;\n        {\n            Cons(v, Rc::new(Lazy::new(cntf)))\n        }\n        #[inline]\n        pub fn head&lt;'b&gt;(&amp;'b self) -&gt; &amp;'b T {\n            if let Cons(ref hd, _) = *self {\n                return hd;\n            }\n            panic!(\"LazyList::head called on an Empty LazyList!!!\")\n        }\n        #[inline]\n        pub fn tail&lt;'b&gt;(&amp;'b self) -&gt; &amp;'b Lazy&lt;'a, LazyList&lt;'a, T&gt;&gt; {\n            if let Cons(_, ref rlln) = *self {\n                return &amp;*rlln;\n            }\n            panic!(\"LazyList::tail called on an Empty LazyList!!!\")\n        }\n        #[inline]\n        pub fn unwrap(self) -&gt; (T, RcLazyListNode&lt;'a, T&gt;) {\n            // consumes the object\n            if let Cons(hd, rlln) = self {\n                return (hd, rlln);\n            }\n            panic!(\"LazyList::unwrap called on an Empty LazyList!!!\")\n        }\n        #[inline]\n        fn iter(&amp;self) -&gt; Iter&lt;'a, T&gt; {\n            Iter(self)\n        }\n    }\n\n    impl&lt;'a, T: 'a + Send + Sync + Clone&gt; Iterator for LazyList&lt;'a, T&gt; {\n        type Item = T;\n\n        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n            match replace(self, Empty) {\n                Cons(hd, rlln) =&gt; {\n                    let mut newll = (*rlln).clone();\n                    swap(self, &amp;mut newll); // self now contains tail, newll contains the Empty\n                    Some(hd)\n                }\n                _ =&gt; None,\n            }\n        }\n    }\n\n    pub struct Iter&lt;'a, T: 'a + Send + Sync + Clone&gt;(*const LazyList&lt;'a, T&gt;);\n\n    impl&lt;'a, T: 'a + Send + Sync + Clone&gt; Iterator for Iter&lt;'a, T&gt; {\n        type Item = &amp;'a T;\n\n        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n            unsafe {\n                if let LazyList::Cons(ref v, ref r) = *self.0 {\n                    self.0 = &amp;***r;\n                    Some(v)\n                } else {\n                    None\n                }\n            }\n        }\n    }\n\n    impl&lt;'i, 'l, T: 'i + Send + Sync + Clone&gt; IntoIterator for &amp;'l LazyList&lt;'i, T&gt; {\n        type Item = &amp;'i T;\n        type IntoIter = Iter&lt;'i, T&gt;;\n\n        fn into_iter(self) -&gt; Self::IntoIter {\n            self.iter()\n        }\n    }\n\n    impl&lt;'a, T: 'a + Send + Sync + Clone&gt; FromIterator&lt;T&gt; for LazyList&lt;'a, T&gt; {\n        fn from_iter&lt;I: IntoIterator&lt;Item = T&gt; + 'a&gt;(itrbl: I) -&gt; LazyList&lt;'a, T&gt; {\n            let itr = itrbl.into_iter();\n            #[inline(always)]\n            fn next_iter&lt;'b, R: 'b + Send + Sync, Itr&gt;(mut iter: Itr) -&gt; LazyList&lt;'b, R&gt;\n                where R: 'b + Clone,\n                      Itr: 'b + Iterator&lt;Item = R&gt;\n            {\n                match iter.next() {\n                    Some(val) =&gt; LazyList::cons(val, move || next_iter(iter)),\n                    None =&gt; Empty,\n                }\n            }\n            next_iter(itr)\n        }\n    }\n}\n\nuse self::lazylist::LazyList;\n//use self::lazylist_sync::LazyList; // for slower thread-safe version\n\nfn main() {\n    fn fib&lt;'a&gt;() -&gt; LazyList&lt;'a, u64&gt; {\n        fn fibi&lt;'b&gt;(f: u64, s: u64) -&gt; LazyList&lt;'b, u64&gt; {\n            LazyList::cons(f, move || { let n = &amp;f + &amp;s; fibi(s, n) })\n        }\n        fibi(0, 1)\n    }\n    let test1 = fib();\n    for v in test1.take(20) {\n        print!(\"{} \", v);\n    }\n    println!(\"\");\n    let test2 = (0..).collect::&lt;LazyList&lt;_&gt;&gt;();\n    for i in (&amp;test2).into_iter().take(15) {\n        print!(\"{} \", i)\n    } // and from_iter() works\n}\n</code></pre>\n\n<p>with the output as follows:</p>\n\n<pre><code>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 \n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14\n</code></pre>\n\n<p>Note that although this shows that functional programming style with LazyList is possible in Rust, it doesn't mean that it should be the preferred style for all use cases, especially if high performance is desired.  For instance, if the above <code>fib()</code> function were written to output an iterator directly rather than a <code>LazyList</code>, then it would only take a very few CPU clock cycles per iteration (other than if infinite precision <code>BigUint</code> were used, which are slower) rather than the hundreds of cycles needed per iteration for the LazyList (and many more for the \"sync\" version).</p>\n\n<p>In general, more imperative implementations, perhaps using <code>Vec&lt;T&gt;</code> if memoization is required, are much more performant than this due to the high overhead of reference counting, the many small allocations/deallocations and the clone/copying required for functional style programming.</p>\n"}], "owner": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 593, "favorite_count": 0, "accepted_answer_id": 40688169, "answer_count": 2, "score": 3, "last_activity_date": 1480067835, "creation_date": 1479515835, "last_edit_date": 1479516781, "question_id": 40687955, "link": "https://stackoverflow.com/questions/40687955/am-i-incorrectly-implementing-intoiterator-for-a-reference-to-a-lazylist-impleme", "title": "Am I incorrectly implementing IntoIterator for a reference to a LazyList implementation or is this a Rust bug?", "body": "<p>In implementing a version of a LazyList (an immutable lazily-computed memoized singly-linked list, much as Haskell lists), I have run into a problem of implementing <code>IntoIterator</code> in that the code does not drop the reference when I think it should.  The following code has been simplified so as just to show the problem; thus, is not generic and does not include all of the methods not related to implementing <code>IntoIterator</code>:</p>\n\n<pre><code>use std::cell::UnsafeCell;\nuse std::mem::replace;\nuse std::rc::Rc;\n\n// only necessary because Box&lt;FnOnce() -&gt; R&gt; doesn't yet work...\ntrait Invoke&lt;R = ()&gt; {\n    fn invoke(self: Box&lt;Self&gt;) -&gt; R;\n}\n\nimpl&lt;'a, R, F: 'a + FnOnce() -&gt; R&gt; Invoke&lt;R&gt; for F {\n    #[inline(always)]\n    fn invoke(self: Box&lt;F&gt;) -&gt; R {\n        (*self)()\n    }\n}\n\n// not thread safe\nstruct Lazy&lt;'a, T: 'a&gt;(UnsafeCell&lt;LazyState&lt;'a, T&gt;&gt;);\n\nenum LazyState&lt;'a, T: 'a&gt; {\n    Unevaluated(Box&lt;Invoke&lt;T&gt; + 'a&gt;),\n    EvaluationInProgress,\n    Evaluated(T),\n}\n\nuse self::LazyState::*;\n\nimpl&lt;'a, T: 'a&gt; Lazy&lt;'a, T&gt; {\n    #[inline]\n    fn new&lt;F: 'a + FnOnce() -&gt; T&gt;(func: F) -&gt; Lazy&lt;'a, T&gt; {\n        Lazy(UnsafeCell::new(Unevaluated(Box::new(func))))\n    }\n    #[inline]\n    pub fn evaluated(val: T) -&gt; Lazy&lt;'a, T&gt; {\n        Lazy(UnsafeCell::new(Evaluated(val)))\n    }\n    #[inline]\n    fn value(&amp;'a self) -&gt; &amp;'a T {\n        unsafe {\n            match *self.0.get() {\n                Evaluated(_) =&gt; (), // nothing required; already Evaluated\n                EvaluationInProgress =&gt; panic!(\"Lazy::force called recursively!!!\"),\n                _ =&gt; {\n                    let ue = replace(&amp;mut *self.0.get(), EvaluationInProgress);\n                    if let Unevaluated(thnk) = ue {\n                        *self.0.get() = Evaluated(thnk.invoke());\n                    } // no other possiblity!\n                }\n            } // following just gets evaluated, no other state possible\n            if let Evaluated(ref v) = *self.0.get() {\n                return v;\n            } else {\n                unreachable!();\n            }\n        }\n    }\n}\n\nenum LazyList&lt;'a&gt; {\n    Empty,\n    Cons(i32, RcLazyListNode&lt;'a&gt;),\n}\n\ntype RcLazyListNode&lt;'a&gt; = Rc&lt;Lazy&lt;'a, LazyList&lt;'a&gt;&gt;&gt;;\n\nimpl&lt;'a&gt; LazyList&lt;'a&gt; {\n    fn iter(&amp;self) -&gt; Iter&lt;'a&gt; {\n        Iter(self)\n    }\n}\n\nstruct Iter&lt;'a&gt;(*const LazyList&lt;'a&gt;);\n\nimpl&lt;'a&gt; Iterator for Iter&lt;'a&gt; {\n    type Item = &amp;'a i32;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        unsafe {\n            if let LazyList::Cons(ref v, ref r) = *self.0 {\n                self.0 = r.value();\n                Some(v)\n            } else {\n                None\n            }\n        }\n    }\n}\n\nimpl&lt;'a&gt; IntoIterator for &amp;'a LazyList&lt;'a&gt; {\n    type Item = &amp;'a i32;\n    type IntoIter = Iter&lt;'a&gt;;\n\n    fn into_iter(self) -&gt; Self::IntoIter {\n        self.iter()\n    }\n}\n\nfn main() {\n    let test2 = LazyList::Cons(2, Rc::new(Lazy::evaluated(LazyList::Empty)));\n    let test = LazyList::Cons(1, Rc::new(Lazy::new(move || test2)));\n    // let itr = Iter(&amp;test); // works\n    // let itr = (&amp;test).iter(); // works\n    let itr = IntoIterator::into_iter(&amp;test); // not working\n    for v in itr {\n        println!(\"{}\", v);\n    }\n}\n</code></pre>\n\n<p>The above code fails with:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>rustc 1.13.0 (2c6933acc 2016-11-07)\nerror: `test` does not live long enough\n   --&gt; &lt;anon&gt;:103:40\n    |\n103 |     let itr = IntoIterator::into_iter(&amp;test); // not working\n    |                                        ^^^^ does not live long enough\n...\n107 | }\n    | - borrowed value dropped before borrower\n    |\n    = note: values in a scope are dropped in the opposite order they are created\n</code></pre>\n\n<p>As noted in the comments in <code>main()</code>, the code is usable <strong>except when called as a reference through the IntoIterator trait</strong>.  This may be a bug in implementing traits for references where the ownership of the returned iterator containing a pointer is not transferred to the same scope as the call to <code>IntoIterator::into_iter</code>but rather to the <code>'static</code> lifetime, thus, it is not dropped when expected. </p>\n\n<p>How do I implement this, if possible? I've tried adding a <code>std::marker::PhantomData&lt;&gt;</code> marker field to the <code>Iter</code> struct but it seems that, too, is assigned a <code>'static</code> lifetime.</p>\n"}, {"tags": ["python", "rust", "ctypes"], "comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 4, "creation_date": 1479498151, "post_id": 40684287, "comment_id": 68600150, "body": "My guess is that some of the overhead is caused by Python having to convert values to and from <code>ctypes</code> compatible types, and <a href=\"https://docs.scipy.org/doc/numpy-dev/user/c-info.python-as-glue.html#index-3\" rel=\"nofollow noreferrer\">this</a> seems to agree with that. Might be worth comparing a function in Rust that just returns the input with the Python equivalent to see if that may be the case."}, {"owner": {"reputation": 1683, "user_id": 2926992, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2w3LT.jpg?s=128&g=1", "display_name": "Erdin Eray", "link": "https://stackoverflow.com/users/2926992/erdin-eray"}, "reply_to_user": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 1, "creation_date": 1479498793, "post_id": 40684287, "comment_id": 68600494, "body": "Thanks for answer... :) | As I understood correctly, I should return a Python compatible data (probably with cpython) in Rust. Unfortunately, I do not know how to use cpython, so it might take some time to learn, test and finally update this question."}, {"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 1, "creation_date": 1479498916, "post_id": 40684287, "comment_id": 68600558, "body": "Well, I&#39;m not certain, which is why I suggest you test to see if my guess is correct. There probably isn&#39;t a lot you can do to avoid the overhead with the <code>ctypes</code> module - there will naturally be <i>some</i> cost when you convert from one type to another, though I am surprised it&#39;s about 0.05s in some cases."}, {"owner": {"reputation": 1683, "user_id": 2926992, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2w3LT.jpg?s=128&g=1", "display_name": "Erdin Eray", "link": "https://stackoverflow.com/users/2926992/erdin-eray"}, "reply_to_user": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 1, "creation_date": 1479498985, "post_id": 40684287, "comment_id": 68600587, "body": "Thanks again. :) I will go and read some documentations right away."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479504974, "post_id": 40684287, "comment_id": 68603221, "body": "Why are you <code>chmod +x</code>? The produced binary is already executable."}, {"owner": {"reputation": 1683, "user_id": 2926992, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2w3LT.jpg?s=128&g=1", "display_name": "Erdin Eray", "link": "https://stackoverflow.com/users/2926992/erdin-eray"}, "edited": false, "score": 0, "creation_date": 1479505124, "post_id": 40684287, "comment_id": 68603288, "body": "Just habits... There were a friend here, and suddenly vanished. Where is he? (Deleted his comments.)"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1479505177, "post_id": 40684287, "comment_id": 68603307, "body": "Yep, comments aren&#39;t for long discussion. After you updated the question, I deleted them because they were just noise. Just like I&#39;ll delete these after a while."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479506128, "post_id": 40684287, "comment_id": 68603681, "body": "Are you on a very slow computer, or one that is otherwise resource-limited? Running the pure Rust code for me takes 12ms, not &gt;150ms like your results."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479506192, "post_id": 40684287, "comment_id": 68603705, "body": "Note that you have linked to the documentation for Rust <b>1.2.0</b> and that the current version is <b>1.13.0</b>. Performance improvements and improved APIS happen all the time, so it&#39;s worth keeping up-to-date."}, {"owner": {"reputation": 1683, "user_id": 2926992, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2w3LT.jpg?s=128&g=1", "display_name": "Erdin Eray", "link": "https://stackoverflow.com/users/2926992/erdin-eray"}, "edited": false, "score": 0, "creation_date": 1479506204, "post_id": 40684287, "comment_id": 68603708, "body": "Yeah, I am on a slow computer. | Yeah, updates might be the issue, too. It was just curiosity came this far."}], "owner": {"reputation": 1683, "user_id": 2926992, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/2w3LT.jpg?s=128&g=1", "display_name": "Erdin Eray", "link": "https://stackoverflow.com/users/2926992/erdin-eray"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 416, "favorite_count": 0, "answer_count": 0, "score": 1, "last_activity_date": 1479504942, "creation_date": 1479495759, "last_edit_date": 1479504942, "question_id": 40684287, "link": "https://stackoverflow.com/questions/40684287/why-does-a-shared-object-library-compiled-with-rust-run-slower-with-ctypes", "title": "Why does a shared object library compiled with Rust run slower with ctypes?", "body": "<p>Taking this <a href=\"https://doc.rust-lang.org/1.2.0/book/rust-inside-other-languages.html#python\" rel=\"nofollow noreferrer\">documentation</a>, I improperly wrote a function that calculates the power of a number in Rust, compiled it to a shared object and used it in Python. Then I have written the same algorithm with Python. I tested both and Python seems to be much faster.</p>\n\n<h3>sum.rs (it was supposed to sum, I changed my mind later)</h3>\n\n<pre><code>#[no_mangle]\npub extern fn powerof(a: i32, b: i32) -&gt; i32 {\n    let mut c: i32 = a;\n    for x in 0..b {\n        c = c*a;\n    }\n    return c;\n}\n</code></pre>\n\n<h3>trial.py</h3>\n\n<pre class=\"lang-py prettyprint-override\"><code>from ctypes import cdll\nimport time\n\n_powerof = cdll.LoadLibrary(\"./libsum.so\")\n\ndef timing(f):\n    # http://stackoverflow.com/a/5478448\n    def wrap(*args):\n        time1 = time.time()\n        ret = f(*args)\n        time2 = time.time()\n        print('{} function took {:0.4f} ms'.format(f.__name__, (time2-time1)*1000.0))\n        return ret\n    return wrap\n\n@timing\ndef powerof(a, b):\n    global _powerof\n    result = _powerof.powerof(a, b)\n    return int(result)\n\n@timing\ndef powerof_python(a, b):\n    c = a\n    for i in range(b):\n        c=c*a\n    return c\n\n\nif __name__ == \"__main__\":\n    print(powerof(4,5))\n    print(powerof(2,3))\n    print(powerof(6,4))\n\n    print(powerof_python(4,5))\n    print(powerof_python(2,3))\n    print(powerof_python(6,4))\n</code></pre>\n\n<p>I have written and compiled Rust in <em>the most primitive way</em> (which means, without <code>cargo</code>).This is how I compiled Rust code above:</p>\n\n<pre><code>rustc sum.rs --crate-type dylib\n</code></pre>\n\n<p>The results are as below:</p>\n\n<h3>1st Test</h3>\n\n<pre class=\"lang-none prettyprint-override\"><code>powerof function took 0.0780 ms\n4096\npowerof function took 0.0136 ms\n16\npowerof function took 0.0064 ms\n7776\npowerof_python function took 0.0110 ms\n4096\npowerof_python function took 0.0041 ms\n16\npowerof_python function took 0.0050 ms\n7776\n</code></pre>\n\n<h1>2nd Test</h1>\n\n<pre class=\"lang-none prettyprint-override\"><code>powerof function took 0.0820 ms\n4096\npowerof function took 0.0083 ms\n16\npowerof function took 0.0057 ms\n7776\npowerof_python function took 0.0110 ms\n4096\npowerof_python function took 0.0041 ms\n16\npowerof_python function took 0.0041 ms\n7776\n</code></pre>\n\n<h1>3rd Test</h1>\n\n<pre class=\"lang-none prettyprint-override\"><code>powerof function took 0.0772 ms\n4096\npowerof function took 0.0098 ms\n16\npowerof function took 0.0069 ms\n7776\npowerof_python function took 0.0129 ms\n4096\npowerof_python function took 0.0036 ms\n16\npowerof_python function took 0.0043 ms\n7776\n</code></pre>\n\n<p>It seems that the same method runs much faster in Python. Why is that?</p>\n\n<hr>\n\n<h2>Update: Timing within Rust</h2>\n\n<p>I edited content of <code>sum.rs</code> as below (added main function):</p>\n\n<pre><code>#[no_mangle]\npub extern fn powerof(a: i32, b: i32) -&gt; i32 {\n    let mut c: i32 = a;\n    for x in 0..b {\n        c = c*a;\n    }\n    return c;\n}\n\nfn main() {\n    let a = powerof(4,5);\n    let b = powerof(2,3);\n    let c = powerof(6,4);\n\n    println!(\"{}\",a);\n    println!(\"{}\",b);\n    println!(\"{}\",c);\n}\n</code></pre>\n\n<p>Compiled it with:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>rustc sum.rs\n</code></pre>\n\n<p>Then run it with <code>time</code> in Linux, as below (after <code>chmod +x ./sum</code>):</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>time -v ./sum\n</code></pre>\n\n<h3>Test 1</h3>\n\n<pre class=\"lang-none prettyprint-override\"><code>real    0m2.035s\nuser    0m0.140s\nsys     0m0.072s\n</code></pre>\n\n<h3>Test 2</h3>\n\n<pre class=\"lang-none prettyprint-override\"><code>real    0m0.176s\nuser    0m0.128s\nsys     0m0.040s\n</code></pre>\n\n<h3>Test 3</h3>\n\n<pre class=\"lang-none prettyprint-override\"><code>real    0m0.184s\nuser    0m0.136s\nsys     0m0.044s\n</code></pre>\n\n<h2>With <code>rustc -O</code> option</h2>\n\n<p>Compiled as below and given executable permission:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>rustc -O sum.rs\n</code></pre>\n\n<h3>Test 1</h3>\n\n<pre class=\"lang-none prettyprint-override\"><code>real    0m0.169s\nuser    0m0.132s\nsys     0m0.032s\n</code></pre>\n\n<h3>Test 2</h3>\n\n<pre class=\"lang-none prettyprint-override\"><code>real    0m0.207s\nuser    0m0.148s\nsys     0m0.048s\n</code></pre>\n\n<h3>Test 3</h3>\n\n<pre class=\"lang-none prettyprint-override\"><code>real    0m0.170s\nuser    0m0.124s\nsys     0m0.040s\n</code></pre>\n\n<hr>\n\n<h2>Environment</h2>\n\n<ul>\n<li>Python 3.5.2</li>\n<li>Rust 1.7.0</li>\n</ul>\n"}, {"tags": ["rust", "rust-cargo"], "comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 0, "creation_date": 1479490114, "post_id": 40682303, "comment_id": 68596017, "body": "I don&#39;t think there&#39;s an easy solution to this; the official Rust documentation <a href=\"https://github.com/rust-lang/rust/issues/24658\" rel=\"nofollow noreferrer\">doesn&#39;t even have the <code>std::os::windows</code> module documented</a> because of this very issue. The thread on GitHub hints at <code>docs.rs</code> having a solution, but I couldn&#39;t find the details."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 3, "creation_date": 1479492781, "post_id": 40682303, "comment_id": 68597420, "body": "docs.rs has a platform selector in the upper right hand corner, for every crate&#39;s docs."}, {"owner": {"reputation": 819, "user_id": 2353008, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/pb5nr.jpg?s=128&g=1", "display_name": "Valarauca", "link": "https://stackoverflow.com/users/2353008/valarauca"}, "edited": false, "score": 1, "creation_date": 1479565311, "post_id": 40682303, "comment_id": 68617210, "body": "<code>doc.rs</code> is manually generating the docs for each platform using a build script. According to <a href=\"https://github.com/rust-lang/rust/issues/1998\" rel=\"nofollow noreferrer\">the cargo issue tracker</a>. There is no fix."}], "answers": [{"tags": [], "owner": {"reputation": 819, "user_id": 2353008, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/pb5nr.jpg?s=128&g=1", "display_name": "Valarauca", "link": "https://stackoverflow.com/users/2353008/valarauca"}, "is_accepted": true, "score": 2, "last_activity_date": 1479565339, "last_edit_date": 1479565339, "creation_date": 1479565246, "answer_id": 40693928, "question_id": 40682303, "link": "https://stackoverflow.com/questions/40682303/how-do-i-generate-cargo-docs-for-all-platforms/40693928#40693928", "title": "How do I generate cargo docs for all platforms?", "body": "<p>This is <a href=\"https://github.com/rust-lang/rust/issues/1998\" rel=\"nofollow noreferrer\">a known bug, there is no current fix</a>.</p>\n"}], "owner": {"reputation": 819, "user_id": 2353008, "user_type": "registered", "accept_rate": 52, "profile_image": "https://i.stack.imgur.com/pb5nr.jpg?s=128&g=1", "display_name": "Valarauca", "link": "https://stackoverflow.com/users/2353008/valarauca"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 382, "favorite_count": 0, "accepted_answer_id": 40693928, "answer_count": 1, "score": 8, "last_activity_date": 1479565339, "creation_date": 1479488068, "last_edit_date": 1479488475, "question_id": 40682303, "link": "https://stackoverflow.com/questions/40682303/how-do-i-generate-cargo-docs-for-all-platforms", "title": "How do I generate cargo docs for all platforms?", "body": "<p>The <code>cargo</code> command line tool allows me to generate documentation for my crate, but I have structures like:</p>\n\n<pre><code>#[cfg(target-platform(\"windows\")]\nmod winstuff {\n     /// Explanation of Windows-specific tasks\n}\n\n#[cfg(target-platfrom(\"linux\")]\nmod linstuff {\n    /// Explanation of Linux-specific tasks\n}\n</code></pre>\n\n<p>When I run <code>cargo docs --no-deps</code>, only the platform-specific module I'm generating documentation for gets generated. How can I generate documentation for <em>all</em> platforms?</p>\n"}, {"tags": ["rust", "ffi"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479483472, "post_id": 40680417, "comment_id": 68591728, "body": "Related: <a href=\"http://stackoverflow.com/q/31503488/155423\">Why is it possible to implement Read on an immutable reference to File?</a>. In that case, the OS handles multiple uses of the underlying file descriptor, so there&#39;s no reason to enforce that in Rust."}], "answers": [{"comments": [{"owner": {"reputation": 33, "user_id": 7178710, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6b4c2651994b5e8a816fcc066ae24f91?s=128&d=identicon&r=PG&f=1", "display_name": "rotty", "link": "https://stackoverflow.com/users/7178710/rotty"}, "edited": false, "score": 0, "creation_date": 1479492656, "post_id": 40680782, "comment_id": 68597340, "body": "I should have added that the socket options in question are not thread-safe, but sharing across threads should be forbidden by the type system if the binding not implementing the <code>Sync</code> thread, right? And the libzmq C API does not employ callbacks at all, AFAIK."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 5, "last_activity_date": 1479483525, "last_edit_date": 1479483525, "creation_date": 1479483082, "answer_id": 40680782, "question_id": 40680417, "link": "https://stackoverflow.com/questions/40680417/when-should-i-use-mut-self-vs-self-in-rust-bindings-for-a-c-library/40680782#40680782", "title": "When should I use `&amp;mut self` vs. `&amp;self` in Rust bindings for a C library?", "body": "<p>In this case whether the object is mutated is secondary; the main question is \"is it safe for two references to be used at the same time?\".  Would it be ok for two threads to call <code>zmq_send</code> (or other methods) on the same object at the same time, or (if the API allows that) via nested callbacks, etc?</p>\n\n<p>If not, use <code>&amp;mut self</code> and let Rust enforce the safety guarantees you need.</p>\n\n<p>If it is safe, then maybe <code>&amp;self</code> is appropriate, if <code>zmq</code> guarantees it's ok; this would be like <code>Mutex::lock</code> taking <code>&amp;self</code>.</p>\n"}], "owner": {"reputation": 33, "user_id": 7178710, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6b4c2651994b5e8a816fcc066ae24f91?s=128&d=identicon&r=PG&f=1", "display_name": "rotty", "link": "https://stackoverflow.com/users/7178710/rotty"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 434, "favorite_count": 0, "accepted_answer_id": 40680782, "answer_count": 1, "score": 3, "last_activity_date": 1479483525, "creation_date": 1479481936, "last_edit_date": 1479483383, "question_id": 40680417, "link": "https://stackoverflow.com/questions/40680417/when-should-i-use-mut-self-vs-self-in-rust-bindings-for-a-c-library", "title": "When should I use `&amp;mut self` vs. `&amp;self` in Rust bindings for a C library?", "body": "<p>I'm unsure when to use <code>&amp;mut self</code> vs. just <code>&amp;self</code> in the Rust bindings for the libzmq C API.</p>\n\n<p>A bit of background: libzmq provides socket \"objects\", which have an API similar to the BSD socket API, and are represented by an opaque pointer in C. This pointer is really just a handle, similar to POSIX file descriptors, and the C API is designed so that it is <em>not</em> possible to obtain any references to memory behind that pointer.</p>\n\n<p>Under these circumstances, is it safe and good API design to expose socket methods with an immutable <code>self</code>? As a concrete example, consider <a href=\"http://api.zeromq.org/4-2:zmq-send\" rel=\"nofollow noreferrer\"><code>zmq_send()</code></a>:</p>\n\n<pre><code>int zmq_send (void *socket, void *buf, size_t len, int flags);\n</code></pre>\n\n<p>I think it can (and should) be exposed using immutable self, i.e.:</p>\n\n<pre><code>pub fn send(&amp;self, data: &amp;[u8], flags: i32) -&gt; Result&lt;()&gt; { ... }\n</code></pre>\n\n<p>However, comparable Rust standard library methods use <code>&amp;mut self</code>, e.g. <a href=\"https://doc.rust-lang.org/std/io/trait.Write.html#tymethod.write\" rel=\"nofollow noreferrer\"><code>std::io::Write::write()</code></a>, as implemented by <code>std::net::TcpStream</code>. On the other hand, <code>std::net::UdpStream::write()</code> takes just <code>&amp;self</code>. My guess is that <code>&amp;mut self</code> is used just because it is an implementation of the <code>Write</code> trait, which in turn (I guess) uses <code>&amp;mut self</code> to not constrain implementations of the trait.</p>\n\n<p>I hope someone can back up or refute my speculations here -- I could not find anything specific about that topic in the Book or the Nomicon.</p>\n"}, {"tags": ["reference", "rust"], "comments": [{"owner": {"reputation": 1331, "user_id": 2207958, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/SJNmA.jpg?s=128&g=1", "display_name": "Max Linke", "link": "https://stackoverflow.com/users/2207958/max-linke"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1479472639, "post_id": 40677086, "comment_id": 68584390, "body": "yes the change to <code>*c</code> works. But why do I have to deref it?"}], "answers": [{"comments": [{"owner": {"reputation": 478030, "user_id": 279627, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/2dceea858ad8f1577bec6ddaa0485d15?s=128&d=identicon&r=PG", "display_name": "Sven Marnach", "link": "https://stackoverflow.com/users/279627/sven-marnach"}, "edited": false, "score": 9, "creation_date": 1546992375, "post_id": 40677781, "comment_id": 95035897, "body": "Only two additional implementation per type would be needed \u2013 <code>&amp;i32 == i32</code> and <code>i32 == &amp;i32</code>. The comparison <code>&amp;i32 == &amp;32</code> already works by virtue of deref coercions, and mutable references coerce to immutable references, so no separate implementations are required. This doesn&#39;t really make a difference for the point you make, but I thought it&#39;s still worth commenting."}, {"owner": {"reputation": 73, "user_id": 14500449, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ef63b21921080fff540eb415ed962834?s=128&d=identicon&r=PG&f=1", "display_name": "Tokubara", "link": "https://stackoverflow.com/users/14500449/tokubara"}, "edited": false, "score": 0, "creation_date": 1616251204, "post_id": 40677781, "comment_id": 117945978, "body": "But there is auto-dereferencing rules. As I see, <code>b==32</code>"}], "tags": [], "owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "is_accepted": true, "score": 24, "last_activity_date": 1479473987, "creation_date": 1479473987, "answer_id": 40677781, "question_id": 40677086, "link": "https://stackoverflow.com/questions/40677086/why-isnt-it-possible-to-compare-a-borrowed-integer-to-a-literal-integer/40677781#40677781", "title": "Why isn&#39;t it possible to compare a borrowed integer to a literal integer?", "body": "<p>You interpret the error correctly, and the reason is that it simply isn't implemented. If the standard library writers wanted to make this work, they'd have to implement <code>PartialEq</code> for <code>&amp;i32 == i32</code>, <code>i32 == &amp;i32</code>, <code>&amp;mut i32 == i32</code>, <code>i32 == &amp;mut i32</code>, <code>&amp;i32 == &amp;mut i32</code> and <code>&amp;mut i32 == &amp;i32</code>. And then they'd have to do that for all other primitive types (<code>i8</code>, <code>i16</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>f32</code>, <code>f64</code>, and <code>char</code>).</p>\n\n<p>That's a <strong>lot</strong> of <code>PartialEq</code> implementations.</p>\n\n<p>Or instead they can just ask the users of the language to write <code>*c != 0</code>.</p>\n\n<p>(If you're coming from C++, the key thing to understand is that syntactically, borrows are more like pointers than references. Only method call syntax has the auto-deref feature.)</p>\n"}], "owner": {"reputation": 1331, "user_id": 2207958, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/SJNmA.jpg?s=128&g=1", "display_name": "Max Linke", "link": "https://stackoverflow.com/users/2207958/max-linke"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 7101, "favorite_count": 4, "accepted_answer_id": 40677781, "answer_count": 1, "score": 21, "last_activity_date": 1546984880, "creation_date": 1479471881, "last_edit_date": 1546984880, "question_id": 40677086, "link": "https://stackoverflow.com/questions/40677086/why-isnt-it-possible-to-compare-a-borrowed-integer-to-a-literal-integer", "title": "Why isn&#39;t it possible to compare a borrowed integer to a literal integer?", "body": "<p>I want to get the elements in an array where a condition is true. For example. I would like all indices where the array elements are 0:</p>\n\n<pre><code>fn main() {\n    let lim = 10;\n    let mut sieve = vec![0; lim + 1];\n    sieve[1] = 1;\n    println!(\n        \"{:?}\",\n        sieve\n            .iter()\n            .enumerate()\n            .filter(|&amp;(_, c)| c != 0)\n            .map(|(i, _)| i)\n            .collect::&lt;Vec&lt;usize&gt;&gt;()\n    );\n}\n</code></pre>\n\n<p>But this is a compile error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: can't compare `&amp;{integer}` with `{integer}`\n  --&gt; src/main.rs:10:33\n   |\n10 |             .filter(|&amp;(_, c)| c != 0)\n   |                                 ^^ no implementation for `&amp;{integer} == {integer}`\n   |\n   = help: the trait `std::cmp::PartialEq&lt;{integer}&gt;` is not implemented for `&amp;{integer}`\n</code></pre>\n\n<p>When I use <code>c.clone() != 0</code> it works.</p>\n\n<p>If I understand the error message correctly, Rust complains that it can't compare a borrow to an integer with an integer. I don't see why it shouldn't be possible.</p>\n"}, {"tags": ["iterator", "rust", "lifetime", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "edited": false, "score": 0, "creation_date": 1479436129, "post_id": 40668157, "comment_id": 68567675, "body": "I already knew how to implement using <code>&#39;a</code> instead of <code>&#39;static</code> as I mentioned in the question as to just simplifying and already had a version using <code>&#39;a</code> in the same places as you do; what I missed was the <code>+ &#39;a</code> in the definition for the <code>Iter struct</code> (your first point).  For that, I thank you very much.  For others reading this, as @Shpmaster saids, using <code>&#39;static</code> doesn&#39;t work here, even with the <code>+</code>, as the general use in an iteration/for loop will be inside another function/block."}, {"owner": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "edited": false, "score": 0, "creation_date": 1479515711, "post_id": 40668157, "comment_id": 68606355, "body": "While I agree that your last suggestion may make the code clearer as to lifetimes, it requires a deep knowledge of the internals of the standard library and increases the complexity of initializing as in something like <code>std::slice::Iter { ptr: self.0[0], end: (self.0[0] as *const i32).offset(self.0.len() as isize), _marker: std::marker::PhantomData }</code>, which isn&#39;t possible since the <code>ptr</code>, <code>end</code>, and <code>_marker</code> fields are private and can&#39;t be initialized outside the module  That&#39;s not usable, is it?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "edited": false, "score": 0, "creation_date": 1479516374, "post_id": 40668157, "comment_id": 68606477, "body": "@GordonBGood <i>it requires a deep knowledge of the internals of the standard library</i> \u2014 what? <a href=\"http://play.integer32.com/?gist=fe12ab6a13ba9e6ec722d430bb1bc20a&amp;version=stable\" rel=\"nofollow noreferrer\">Just... call the normal method</a>."}, {"owner": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "edited": false, "score": 0, "creation_date": 1479516756, "post_id": 40668157, "comment_id": 68606556, "body": "Ah, sorry, I forgot that <code>Vec</code> is overloaded to call through to produce the slice <code>Iter</code>; but in order to declare the Iter wrapper to contain this, it still requires we know that <code>Vec::iter()</code> produces and in what module it can be found."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "edited": false, "score": 0, "creation_date": 1479516994, "post_id": 40668157, "comment_id": 68606598, "body": "@GordonBGood <i>requires we know that <code>Vec::iter()</code> produces</i> \u2014 which is available in the API docs and from the compiler. It&#39;s also part of the public API, so it can&#39;t really change."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 9, "last_activity_date": 1588601264, "last_edit_date": 1588601264, "creation_date": 1479434004, "answer_id": 40668157, "question_id": 40668074, "link": "https://stackoverflow.com/questions/40668074/am-i-incorrectly-implementing-intoiterator-for-a-reference-or-is-this-a-rust-bug/40668157#40668157", "title": "Am I incorrectly implementing IntoIterator for a reference or is this a Rust bug that should be reported?", "body": "<p>You have correctly implemented the iterator for references to <code>VecWrapper</code>s that <em>live for the entire length of the program</em> \u2014 the <code>'static</code> lifetime.</p>\n\n<p>Chances are you want to have a generic lifetime. That lifetime will then be provided a concrete lifetime, unique to each instantiation. Usually, we are lazy and just give this lifetime the name <code>'a</code>:</p>\n\n<pre><code>struct VecWrapper(Vec&lt;i32&gt;);\n\nimpl VecWrapper {\n    fn iter(&amp;self) -&gt; Iter {\n        Iter(Box::new(self.0.iter()))\n    }\n}\n\nstruct Iter&lt;'a&gt;(Box&lt;dyn Iterator&lt;Item = &amp;'a i32&gt; + 'a&gt;);\n\nimpl&lt;'a&gt; Iterator for Iter&lt;'a&gt; {\n    type Item = &amp;'a i32;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.0.next()\n    }\n}\n\nimpl&lt;'a&gt; IntoIterator for &amp;'a VecWrapper {\n    type Item = &amp;'a i32;\n    type IntoIter = Iter&lt;'a&gt;;\n\n    fn into_iter(self) -&gt; Self::IntoIter {\n        self.iter()\n    }\n}\n\nfn main() {\n    let test = VecWrapper(vec![1, 2, 3]);\n    for v in &amp;test {\n        println!(\"{}\", v);\n    }\n}\n</code></pre>\n\n<p>Important changes:</p>\n\n<ul>\n<li><code>Box&lt;dyn Iterator&lt;Item = &amp;'a i32&gt; + 'a&gt;</code> - <code>+ 'a</code> was added. This is needed because a <em>trait object</em> will assume that there are no interior values that reference anything with a short lifetime.</li>\n<li>The <code>Item</code> type is now <code>&amp;'a i32</code>.</li>\n<li>A generic lifetime is declared in many places and provided in many others (<code>&lt;'a&gt;</code>).</li>\n</ul>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/42028470/155423\">Why is adding a lifetime to a trait with the plus operator (Iterator&lt;Item = &amp;Foo&gt; + &#39;a) needed?</a></li>\n</ul>\n\n<hr>\n\n<p>Normally, there wouldn't be a reason to use a trait object here. I'd just embed the iterator directly:</p>\n\n<pre><code>struct Iter&lt;'a&gt;(std::slice::Iter&lt;'a, i32&gt;);\n</code></pre>\n\n<p>This avoids the need to have any indirection, which is unused in this case anyway. Additionally, it more obviously couples the lifetimes.</p>\n"}], "owner": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1423, "favorite_count": 1, "accepted_answer_id": 40668157, "answer_count": 1, "score": 1, "last_activity_date": 1588601264, "creation_date": 1479433349, "last_edit_date": 1558568067, "question_id": 40668074, "link": "https://stackoverflow.com/questions/40668074/am-i-incorrectly-implementing-intoiterator-for-a-reference-or-is-this-a-rust-bug", "title": "Am I incorrectly implementing IntoIterator for a reference or is this a Rust bug that should be reported?", "body": "<p>Furthering the example of implementing <code>IntoIterator</code> for a wrapped vector as per <a href=\"https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\" rel=\"nofollow noreferrer\">the Rust book</a>, I am also trying to <strong>implement IntoIterator for a reference</strong> to the wrapper, as per <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3395a2a5afe87741df18d1bcf91ecd94\" rel=\"nofollow noreferrer\">the following code (Playground link)</a>:</p>\n\n<pre><code>struct VecWrapper(Vec&lt;i32&gt;);\n\nimpl VecWrapper {\n    fn iter(&amp;'static self) -&gt; Iter {\n        Iter(Box::new(self.0.iter()))\n    }\n}\n\nstruct Iter(Box&lt;Iterator&lt;Item = &amp;'static i32&gt;&gt;);\n\nimpl Iterator for Iter {\n    type Item = &amp;'static i32;\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.0.next()\n    }\n}\n\nimpl IntoIterator for &amp;'static VecWrapper {\n    type Item = &amp;'static i32;\n    type IntoIter = Iter;\n    fn into_iter(self) -&gt; Self::IntoIter {\n        self.iter()\n    }\n}\n\nfn main() {\n    // let test = vec![1, 2, 3]; // obviously, works\n    let test = VecWrapper(vec![1, 2, 3]); // not working\n    for v in &amp;test {\n        println!(\"{}\", v);\n    }\n}\n</code></pre>\n\n<p>Although the implementation compiles, the attempt to use it in <code>main</code> doesn't with the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0597]: `test` does not live long enough\n  --&gt; src/main.rs:31:14\n   |\n31 |     for v in &amp;test {\n   |              ^^^^^\n   |              |\n   |              borrowed value does not live long enough\n   |              argument requires that `test` is borrowed for `'static`\n...\n34 | }\n   | - `test` dropped here while still borrowed\n</code></pre>\n\n<p>This code is greatly simplified from what I would actually want to use as to using only <code>'static</code> lifetimes, using an existing contained type, and using <code>i32</code> for the inner (iterated) type, but it is boiled down to show just the problem.</p>\n\n<hr>\n\n<p>The accepted answer solves the first part of the problem as to not using <code>'static</code> and using <code>+ 'a</code> with traits. I still am having a problem with the actual code, which is a <code>LazyList</code> implementation.  I've posted that as <a href=\"https://stackoverflow.com/questions/40687955/am-i-incorrectly-implementing-intoiterator-for-a-reference-to-a-lazylist-impleme\">Am I incorrectly implementing IntoIterator for a reference to a LazyList implementation or is this a Rust bug?</a>.</p>\n"}, {"tags": ["windows", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1479423460, "post_id": 40662397, "comment_id": 68564284, "body": "Please produce a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a> (emphasis on the <b>minimal</b>). As it is right now, I don&#39;t understand your project setup, so I cannot reproduce it in a VM. I will note that the Rust ABI <i>is not stable</i>, so any dynamic libraries <b>must</b> use the C ABI if you hope for them to actually be compatible, at least across Rust versions."}], "owner": {"reputation": 81, "user_id": 5305054, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e3b66e716878ddf35d5b8065525c68a4?s=128&d=identicon&r=PG&f=1", "display_name": "Xylotrope", "link": "https://stackoverflow.com/users/5305054/xylotrope"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 107, "favorite_count": 0, "answer_count": 0, "score": 2, "last_activity_date": 1479409535, "creation_date": 1479407258, "last_edit_date": 1479409535, "question_id": 40662397, "link": "https://stackoverflow.com/questions/40662397/inconsistent-symbol-mangling-in-rust-on-windows", "title": "Inconsistent Symbol Mangling in Rust on Windows", "body": "<p>I have two interdependent, cross platform Rust projects. Project A is the main application, producing the main executable and a dynamic library containing common dependencies. Project B contains plugins for the application, each distributed as a dynamic library with a dependency on the Project A common library.</p>\n\n<p>Because the two projects are separate, Cargo builds the common library with both projects A and B. On Windows, symbol name mangling is inconsistent between the two builds, meaning that the Project B plugins cannot use the common library produced from the Project A build, and vice versa. I also tried placing a <code>#[no_mangle]</code> directive on the pertinent symbols in the Project A common library, but on Windows it is ignored in the Project B build.</p>\n\n<p>On Linux, the symbol names are consistent between the two builds, with or without the <code>#[no_mangle]</code> directive.</p>\n\n<p>What could be causing this inconsistency on Windows builds and how can it be resolved? I would like to keep the two projects separate to make it easier to develop new plugins in the future.</p>\n\n<p>All testing has been done using Rust 1.13.0 on Windows 10 and CentOS 7. This issue occurs with both the MSVC and GNU ABIs on Windows, but the application ultimately needs to compile with the MSVC ABI.</p>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 4, "last_activity_date": 1479494337, "last_edit_date": 1479494337, "creation_date": 1479395920, "answer_id": 40658597, "question_id": 40658487, "link": "https://stackoverflow.com/questions/40658487/how-to-pass-optionmut-to-multiple-function-calls-without-causing-move-e/40658597#40658597", "title": "How to pass `Option&lt;&amp;mut ...&gt;` to multiple function calls without causing move errors?", "body": "<p>You can pass the <code>Option</code> by reference too, if you don't want it moved into the function.</p>\n\n<pre><code>fn maybe_push(mut v_option: &amp;mut Option&lt;&amp;mut Vec&lt;usize&gt;&gt;) -&gt; usize\n\n// ...\n\nmaybe_push_twice(&amp;mut v_option);\n</code></pre>\n\n<p>Then replace:</p>\n\n<pre><code>maybe_push(None);\n</code></pre>\n\n<p>With:</p>\n\n<pre><code>maybe_push(&amp;mut None);\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1479501856, "post_id": 40683895, "comment_id": 68601845, "body": "Good to know as an alternative to the existing answer. While a valid, this makes it annoying to use when passing an argument to functions many times. I&#39;d be tempted to put <code>opt.as_mut().map(|x| &amp;mut **x)</code> into a macro."}], "tags": [], "owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "is_accepted": false, "score": 2, "last_activity_date": 1479503134, "last_edit_date": 1479503134, "creation_date": 1479494092, "answer_id": 40683895, "question_id": 40658487, "link": "https://stackoverflow.com/questions/40658487/how-to-pass-optionmut-to-multiple-function-calls-without-causing-move-e/40683895#40683895", "title": "How to pass `Option&lt;&amp;mut ...&gt;` to multiple function calls without causing move errors?", "body": "<p>You can destructure the <code>Option</code> with a <code>match</code> expression and then create a new <code>Option</code> value for every call of the function <code>maybe_push()</code>:</p>\n\n<pre><code>fn maybe_push_twice(v_option: Option&lt;&amp;mut Vec&lt;usize&gt;&gt;) -&gt; usize {\n    let mut c = 0;\n    match v_option {\n        Some(v) =&gt; {\n            c += maybe_push(Some(v));\n            c += maybe_push(Some(v));\n        }\n        None =&gt; {\n            c += maybe_push(None);\n            c += maybe_push(None);        \n        }\n    };\n    return c;\n}\n</code></pre>\n\n<hr>\n\n<p>Here is a more convenient way:</p>\n\n<pre><code>fn maybe_push_twice(mut v_option: Option&lt;&amp;mut Vec&lt;usize&gt;&gt;) -&gt; usize {\n    let mut c = 0;\n    c += maybe_push(v_option.as_mut().map(|x| &amp;mut **x));\n    c += maybe_push(v_option);\n    return c;\n}\n</code></pre>\n\n<hr>\n\n<p>You can use a trait instead of a macro:</p>\n\n<pre><code>trait RefMut&lt;T&gt; {\n    fn ref_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt;;\n}\n\nimpl&lt;'t, T&gt; RefMut&lt;T&gt; for Option&lt;&amp;'t mut T&gt;{\n    #[inline]\n    fn ref_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt;{\n        self.as_mut().map(|x| &amp;mut**x)\n    }\n}\n\nfn maybe_push_twice(mut v_option: Option&lt;&amp;mut Vec&lt;usize&gt;&gt;) -&gt; usize {\n    let mut c = 0;\n    c += maybe_push(v_option.ref_mut());\n    c += maybe_push(v_option);\n    return c;\n}\n</code></pre>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 487, "favorite_count": 0, "accepted_answer_id": 40658597, "answer_count": 2, "score": 1, "last_activity_date": 1479503134, "creation_date": 1479395604, "last_edit_date": 1479396331, "question_id": 40658487, "link": "https://stackoverflow.com/questions/40658487/how-to-pass-optionmut-to-multiple-function-calls-without-causing-move-e", "title": "How to pass `Option&lt;&amp;mut ...&gt;` to multiple function calls without causing move errors?", "body": "<p>Since it's possible to pass a mutable reference to a vector around (without causing moves), how can an <code>Option&lt;reference&gt;</code> be passed to functions multiple times without causing borrow checking errors?</p>\n\n<p>This simple example just shows what happens when an <code>Option&lt;&amp;mut Vec&lt;usize&gt;&gt;</code> is passed multiple times to a function:</p>\n\n<pre><code>fn maybe_push(mut v_option: Option&lt;&amp;mut Vec&lt;usize&gt;&gt;) -&gt; usize {\n    let mut c = 0;\n    if let Some(ref mut v) = v_option.as_mut() {\n        for i in 0..10 {\n            v.push(i);\n            c += i;\n        }\n    }\n\n    return c;\n}\n\nfn maybe_push_multi(v_option: Option&lt;&amp;mut Vec&lt;usize&gt;&gt;) -&gt; usize {\n    let mut c = 0;\n    c += maybe_push(v_option);\n    c += maybe_push(v_option);\n    c += maybe_push(None);\n    return c;\n}\n\nfn main() {\n    let mut v: Vec&lt;usize&gt; = vec![];\n    let v_option = Some(&amp;mut v);\n    println!(\"{}\", maybe_push_multi(v_option));\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=9d06575206bb5dfe575db524747d68bd&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a>)</p>\n\n<p>Gives the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of moved value: `v_option`\n  --&gt; &lt;anon&gt;:17:21\n   |\n16 |     c += maybe_push(v_option);\n   |                     -------- value moved here\n17 |     c += maybe_push(v_option);\n   |                     ^^^^^^^^ value used here after move\n   |\n   = note: move occurs because `v_option` has type `std::option::Option&lt;&amp;mut std::vec::Vec&lt;usize&gt;&gt;`, which does not implement the `Copy` trait\n</code></pre>\n"}, {"tags": ["memory-management", "rust"], "answers": [{"comments": [{"owner": {"reputation": 412, "user_id": 10779150, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-PdwkjFzp4rE/AAAAAAAAAAI/AAAAAAAAABU/9BZconXx6W0/photo.jpg?sz=128", "display_name": "Laevus Dexter", "link": "https://stackoverflow.com/users/10779150/laevus-dexter"}, "edited": false, "score": 0, "creation_date": 1581559166, "post_id": 40663945, "comment_id": 106478740, "body": "<code>da&#39;s free-list allocators</code> -- what&#39;s <code>da</code>?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 412, "user_id": 10779150, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-PdwkjFzp4rE/AAAAAAAAAAI/AAAAAAAAABU/9BZconXx6W0/photo.jpg?sz=128", "display_name": "Laevus Dexter", "link": "https://stackoverflow.com/users/10779150/laevus-dexter"}, "edited": false, "score": 0, "creation_date": 1581580379, "post_id": 40663945, "comment_id": 106484572, "body": "@LaevusDexter: This is a colloquialism. <i>Your da</i> (or <i>your pa</i>) means <i>Your dad</i>, with an undertone of obsolescence."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 50, "last_activity_date": 1479454242, "last_edit_date": 1479454242, "creation_date": 1479412688, "answer_id": 40663945, "question_id": 40658045, "link": "https://stackoverflow.com/questions/40658045/does-rusts-memory-management-result-in-fragmented-memory/40663945#40663945", "title": "Does Rust&#39;s memory management result in fragmented memory?", "body": "<p><strong>TL;DR: Most programs will never have to worry about fragmentation in C, C++ or Rust. Those which do will have to handle it by themselves.</strong></p>\n\n<hr>\n\n<blockquote>\n  <p>Does the Rust programming language's automatic memory management need to reclaim fragmented memory?</p>\n</blockquote>\n\n<p>Rust does not have automatic memory management; it has manual memory management which the compiler checks for correctness. The difference might sound theoretical, however it is important because it means that the memory operations map directly to the source code, there is no magic going on behind the scenes.</p>\n\n<p>In general, a language needs to have a Compacting GC to be able to compact fragmented memory. Rust, like C and C++, does not have a GC so its memory may be fragmented depending on usage, and <em>cannot</em> be defragmented without the program freeing the annoying blocks because relocation is impossible.</p>\n\n<hr>\n\n<p>However, before we start dreading fragmentation, we must first think about what it means.</p>\n\n<p><strong>What is the effect of fragmentation?</strong></p>\n\n<p>Fragmentation causes a waste of physical memory and address space: your program occupies more than it uses. At the extreme, this waste may prevent allocation requests even though the amount of unused memory should be sufficient to grant them.</p>\n\n<p>When making a parallel with a GC'ed language, it's important to realize that most GC'ed languages <em>also</em> cause some waste.</p>\n\n<p>Indeed, it's notable that fragmentation is not the ONLY source of waste; over-allocation is a common \"issue\" too:</p>\n\n<ul>\n<li>a <code>Vec</code> will allocate a power-of-2 number of elements, but maybe you only use <code>2^N + 1</code>, wasting <code>2^N - 1</code> slots</li>\n<li>a <code>BTreeMap</code> or <code>HashMap</code> allocate more space than they really use</li>\n<li>even the memory allocator generally allocates chunks of predefined sizes, so that asking for 157 bytes may actually be rounded up to maybe 196 bytes, wasting 39 bytes</li>\n</ul>\n\n<p>And that's not even counting the waste going on with the management of this memory, since the memory allocator maintains some state to know what pages it has, and what's used in them.</p>\n\n<p>This underlines a very important fact: there's little point getting rid of fragmentation if you consume so much memory because of the book-keeping/overhead your allocation scheme imposes that you suffer the same issues.</p>\n\n<hr>\n\n<p><strong>How do modern allocators manage memory?</strong></p>\n\n<p>Modern allocators are NOT your da's free-list allocators.</p>\n\n<p>The typical allocation scheme is relatively simple, and yet very good at keeping fragmentation down for small requests:</p>\n\n<ol>\n<li>Large slabs of memory for \"big\" requests (close or over the OS page size: 4kB in general)</li>\n<li>Small slabs of memory for \"smaller\" requests</li>\n</ol>\n\n<p>For the small slabs, a number of classes are defined by size. For example: <code>(0, 8]</code>, <code>(8, 12]</code>, <code>(12, 16]</code>, ..., <code>(164, 196]</code>, ..., <code>(..., 512]</code>. Each class size manage its own list of OS pages, and carves each OS page for its own private use. An example of the 512 bytes class on a 4kB OS page could be:</p>\n\n<pre><code>+---+---+---+---+---+---+---+---+\n| a | b | c | d | e | f | g | h |\n+---+---+---+---+---+---+---+---+\n</code></pre>\n\n<p>where 512-bytes slots <code>a</code> through <code>g</code> are available for allocations and the latest slots <code>h</code> is reserved for meta-data (free slots, next/prev pages in the same class, etc...). Note that the bigger the class size, the more is wasted in the last slot, which is why larger allocations use a different scheme.</p>\n\n<p>When deallocating, the page is kept in the class size until the last slot is deallocated at which point the page is blank again and can be used for another group.</p>\n\n<p><em>Note: By default, Rust executables uses <a href=\"http://jemalloc.net/\" rel=\"noreferrer\">jemalloc</a>, this <a href=\"http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf\" rel=\"noreferrer\">paper</a> has specific details about it.</em></p>\n\n<hr>\n\n<p><strong>What does it mean for memory consumption?</strong></p>\n\n<p>The maximum memory consumption of the small slabs scheme<sup>1</sup> is a number of OS pages which can be computed as the sum of the maximum number of OS pages consumed by each bucket size, which itself is the maximum number of concurrent allocations in this size multiplied divided by the number of allocations fitting in a page (and rounded up).</p>\n\n<p>This is because if you allocate 1000 slots of a given size, release most of them in a haphazard fashion that pokes holes in the OS pages, and then re-allocate slots of the same size until you reach 1000 again... then your memory consumption is constant because the allocator will use the free slots from the already partially filled OS pages to fulfill the second wave of allocations.</p>\n\n<p>Which means that allocations in small class sizes is both fast, and yet does not contribute much to fragmentation.</p>\n\n<p>Of course, that's ignoring the case of a program which would make 1M 1 byte allocation, deallocate most of them in a way that leaves all pages used, then do the same with 2 bytes, 3 bytes, etc... but this seems like a pathological case.</p>\n\n<p><sup>1</sup> <em>Yes, I am lying through my teeth. You also need to account for the allocator's internal structures overhead and the fact that it may cache a few unused OS pages to prepare for future allocations, ... still, it's sufficient for explaining the effect of fragmentation.</em></p>\n\n<hr>\n\n<p><strong>So, is fragmentation an issue?</strong></p>\n\n<p>Well, it can still be. The address space can still be fragmented, though at the granularity of OS pages.</p>\n\n<p>With virtual memory, the RAM need not be contiguous, so as long as there is sufficient space the pages can be used. That is, the address space gives the user the illusion of contiguous memory even if the memory is physically spread all over RAM.</p>\n\n<p>And there lies the issue: this illusion of contiguous memory requires finding a contiguous region of the address space, which is subject to fragmentation.</p>\n\n<p>This fragmentation does not show up in small requests, but for requests over the page size they can be an issue. These days, with 64-bits pointers, this is much less of an issue in practice (even when only using 47-bits for user-land) however in 32-bits programs it is slightly more likely to surface: for example, it is extremely difficult to <code>mmap</code> a 2GB file in the 32 bits address space, because it immediately occupies half of it... assuming no stray allocation prevents it (in which case the request will fail).</p>\n\n<hr>\n\n<p><strong>Is the fight lost?</strong></p>\n\n<p>Well, the main advantage of systems programming is that... you can talk the systems language.</p>\n\n<p>If your program has an allocation behavior which the typical allocator does not handle well, you can:</p>\n\n<ul>\n<li>take control of the particular allocations that cause issues (using <code>sbrk</code>/<code>mmap</code> yourself to handle them)</li>\n<li>or just rewrite a specifically tuned-up allocator</li>\n</ul>\n\n<p>In 10 years, I've personally never needed to, and only wrote allocators for fun in my spare time; but it's possible.</p>\n"}, {"tags": [], "owner": {"reputation": 623, "user_id": 966276, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/c8742a26abaedb6d4d7ef4fd2418496d?s=128&d=identicon&r=PG", "display_name": "Rusty Fieldstone", "link": "https://stackoverflow.com/users/966276/rusty-fieldstone"}, "is_accepted": false, "score": 6, "last_activity_date": 1479498614, "creation_date": 1479498614, "answer_id": 40684965, "question_id": 40658045, "link": "https://stackoverflow.com/questions/40658045/does-rusts-memory-management-result-in-fragmented-memory/40684965#40684965", "title": "Does Rust&#39;s memory management result in fragmented memory?", "body": "<p>To summarize Matthieu's great, detailed explanation -- </p>\n\n<p>Rust and C and C++, when using their standard memory management, <em>do</em> result in fragmented memory. They <em>do not</em> defragment.</p>\n\n<p>But in the vast majority of real-world use cases, the fragmentation is so minimal that it's not a problem.</p>\n\n<p>If it is a problem, you can roll your own allocator.</p>\n"}], "owner": {"reputation": 623, "user_id": 966276, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/c8742a26abaedb6d4d7ef4fd2418496d?s=128&d=identicon&r=PG", "display_name": "Rusty Fieldstone", "link": "https://stackoverflow.com/users/966276/rusty-fieldstone"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3984, "favorite_count": 6, "accepted_answer_id": 40663945, "answer_count": 2, "score": 23, "last_activity_date": 1479498614, "creation_date": 1479394478, "last_edit_date": 1479394623, "question_id": 40658045, "link": "https://stackoverflow.com/questions/40658045/does-rusts-memory-management-result-in-fragmented-memory", "title": "Does Rust&#39;s memory management result in fragmented memory?", "body": "<p>Does the Rust programming language's automatic memory management need to reclaim fragmented memory? If so, how does it do this?</p>\n\n<p>My understanding is that its type system (ownership types, borrowing, <code>Rc</code>, <code>Arc</code>) allows it to deterministically know at compile-time when a chunk of allocated memory can be freed.</p>\n\n<p>But isn't it possible that memory chunks are allocated in one order, and freed in a different order, resulting in fragmentation? If this is prevented, how? If this does happen, how are the memory fragments managed efficiently? If they are defragmented, what's the methodology used?</p>\n"}, {"tags": ["rust", "ffi"], "answers": [{"comments": [{"owner": {"reputation": 3306, "user_id": 3980369, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/sZ3vt.jpg?s=128&g=1", "display_name": "Mathieu David", "link": "https://stackoverflow.com/users/3980369/mathieu-david"}, "edited": false, "score": 0, "creation_date": 1479394093, "post_id": 40657666, "comment_id": 68546921, "body": "Thanks! I never thought about using both at the same time. A follow up question, why doesn&#39;t it work when you have only <code>as *const _</code>?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 3306, "user_id": 3980369, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/sZ3vt.jpg?s=128&g=1", "display_name": "Mathieu David", "link": "https://stackoverflow.com/users/3980369/mathieu-david"}, "edited": false, "score": 0, "creation_date": 1479396652, "post_id": 40657666, "comment_id": 68548940, "body": "@MathieuDavid: <code>as</code> can only perform a very limited number of conversions, and array to pointer is not one of them. I wonder if there&#39;s a limit somewhere of what it can do..."}, {"owner": {"reputation": 3306, "user_id": 3980369, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/sZ3vt.jpg?s=128&g=1", "display_name": "Mathieu David", "link": "https://stackoverflow.com/users/3980369/mathieu-david"}, "edited": false, "score": 0, "creation_date": 1479397161, "post_id": 40657666, "comment_id": 68549331, "body": "I see. I tried chaining two casts <code>as *const _ as *const _</code> and that works. It seems strange to require two explicit casts instead of one."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 3306, "user_id": 3980369, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/sZ3vt.jpg?s=128&g=1", "display_name": "Mathieu David", "link": "https://stackoverflow.com/users/3980369/mathieu-david"}, "edited": false, "score": 0, "creation_date": 1479399022, "post_id": 40657666, "comment_id": 68550696, "body": "@MathieuDavid: Ah, so the array to pointer conversion does work and it&#39;s just that <code>as</code> only converts one thing at a time. I thing I prefer it that way rather, it makes it more obvious what conversions are taking place."}, {"owner": {"reputation": 3306, "user_id": 3980369, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/sZ3vt.jpg?s=128&g=1", "display_name": "Mathieu David", "link": "https://stackoverflow.com/users/3980369/mathieu-david"}, "edited": false, "score": 0, "creation_date": 1479400704, "post_id": 40657666, "comment_id": 68551842, "body": "Yes, <code>as_ptr</code> is definitely more elegant. I just tried the double cast because I wanted to make a static instance of <code>OfxPlugin</code> and <code>as_ptr</code> can&#39;t be used in that scenario."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 1, "last_activity_date": 1479393419, "creation_date": 1479393419, "answer_id": 40657666, "question_id": 40657395, "link": "https://stackoverflow.com/questions/40657395/what-is-the-best-way-to-get-a-const-c-char-from-a-const-array-via-ffi/40657666#40657666", "title": "What is the best way to get a `*const c_char` from a const array via FFI?", "body": "<p>Let's start from a minimal example and work our way through:</p>\n\n<pre><code>const K: &amp;'static [u8; 24usize] = b\"OfxImageEffectPluginAPI\\x00\";\n\n#[derive(Debug)]\nstruct OfxPlugin {\n    plugin_api: *const ::std::os::raw::c_char,\n    // other fields...\n}\n\nfn main() {\n    let p = OfxPlugin { plugin_api: K };\n    println!(\"{:?}\", p);\n}\n</code></pre>\n\n<p>The first thing to do is to get a pointer from the array; this is indeed <code>as_ptr()</code>.</p>\n\n<pre><code>error[E0308]: mismatched types\n  --&gt; &lt;anon&gt;:10:41\n   |\n10 |         let p = OfxPlugin { plugin_api: K.as_ptr() };\n   |                                         ^^^^^^^^^^ expected i8, found u8\n\nerror: aborting due to previous error\n</code></pre>\n\n<p>The types mismatch, so we need to cast from one pointer type to another. This is achieved with <code>as</code>:</p>\n\n<pre><code>fn main() {\n    let p = OfxPlugin { plugin_api: K.as_ptr() as *const _ };\n    println!(\"{:?}\", p);\n}\n</code></pre>\n\n<p>We <em>could</em> be explicit about the kind of pointer we want; but it's simpler here to let the compiler manage it.</p>\n"}], "owner": {"reputation": 3306, "user_id": 3980369, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/sZ3vt.jpg?s=128&g=1", "display_name": "Mathieu David", "link": "https://stackoverflow.com/users/3980369/mathieu-david"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 852, "favorite_count": 0, "accepted_answer_id": 40657666, "answer_count": 1, "score": 1, "last_activity_date": 1479393888, "creation_date": 1479392706, "last_edit_date": 1479393888, "question_id": 40657395, "link": "https://stackoverflow.com/questions/40657395/what-is-the-best-way-to-get-a-const-c-char-from-a-const-array-via-ffi", "title": "What is the best way to get a `*const c_char` from a const array via FFI?", "body": "<p>I am trying to interface with a C API in Rust. They define a couple of string constants with macros:</p>\n\n<pre class=\"lang-c prettyprint-override\"><code>#define kOfxImageEffectPluginApi \"OfxImageEffectPluginAPI\"\n</code></pre>\n\n<p>and a struct with a <code>const char *pluginApi;</code> where that constant is supposed to be used:</p>\n\n<pre class=\"lang-c prettyprint-override\"><code>typedef struct OfxPlugin {\n  const char *pluginApi;\n  // Other fields...\n} OfxPlugin;\n</code></pre>\n\n<p><a href=\"https://github.com/servo/rust-bindgen\" rel=\"nofollow noreferrer\">Bindgen (servo)</a> creates the following Rust equivalent:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub const kOfxImageEffectPluginApi: &amp;'static [u8; 24usize] = b\"OfxImageEffectPluginAPI\\x00\";\n</code></pre>\n\n<pre class=\"lang-rust prettyprint-override\"><code>#[repr(C)]\n#[derive(Debug, Copy)]\npub struct OfxPlugin {\n    pub pluginApi: *const ::std::os::raw::c_char,\n    // other fields...\n}\n</code></pre>\n\n<p>What is the best way to get a <code>*const c_char</code> from that const array? I tried both <code>as_ptr</code> and a cast, but the types don't match because the array is <code>u8</code> and <code>c_char</code> is <code>i8</code>...</p>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1479392376, "post_id": 40657177, "comment_id": 68545633, "body": "In the book: <a href=\"https://doc.rust-lang.org/book/patterns.html#ref-and-ref-mut\" rel=\"nofollow noreferrer\">doc.rust-lang.org/book/patterns.html#ref-and-ref-mut</a> (very very succinct)."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1479398688, "post_id": 40657177, "comment_id": 68550466, "body": "@Shepmaster Nice alternative, thanks. I&#39;ve now updated the answer to include it, as well additional explanation about why the original move doesn&#39;t work."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 8, "last_activity_date": 1479565032, "last_edit_date": 1479565032, "creation_date": 1479392110, "answer_id": 40657177, "question_id": 40657075, "link": "https://stackoverflow.com/questions/40657075/how-to-access-a-vector-multiple-times-within-an-option/40657177#40657177", "title": "How to access a vector multiple times within an &#39;Option&#39;?", "body": "<p>Matching by value <em>moves</em> the value into the pattern variables. Moving makes the original value unusable, except for the very simple objects that implement the <code>Copy</code> trait, such as numbers. Unlike pointers in C, mutable references are not copyable, which can be seen in the following example that doesn't compile either:</p>\n\n<pre><code>let mut v = vec![1, 2, 3];\nlet rv = &amp;mut v;  // mutable reference to v\n{\n    // move rv to r1, r1 now becomes the sole mutable reference to v\n    let r1 = rv;\n    r1.push(4);\n}\n{\n    let r2 = rv;  // error: rv was already moved to r1\n    r2.push(5);\n}\n</code></pre>\n\n<p>Rust rejects the above because it enforces the general rule prohibiting multiple mutable references to an object. Despite this particular snippet being safe, allowing multiple mutable references to the same object at the same time would make it easy to write the kind of unsafe programs that Rust is explicitly designed to prevent, e.g. those that contain data races in multithreaded code, or those that access data through an invalidated iterator. Thus the assignment <code>let r1 = rv</code> can only <em>move</em> the <code>rv</code> reference to <code>r1</code>, disallowing the <code>let r2 = rv</code> statement which now refers to moved variable <code>rv</code>.</p>\n\n<p>To fix the code, we must create separate references <em>to the reference</em>. This will create two distinct mutable references to the original reference rather than moving the original mutable reference into an inner scope:</p>\n\n<pre><code>let mut v = vec![1, 2, 3];\nlet mut rv = &amp;mut v;\n{\n    // rr1 is a *new* mutable reference to rv - no move is performed\n    let rr1 = &amp;mut rv;\n    rr1.push(4);\n}\n{\n    // rr2 is a *separate* new mutable reference to rv - also no move\n    let rr2 = &amp;mut rv;\n    rr2.push(5);\n}\n</code></pre>\n\n<p>The syntax of <code>push</code> invocation is the same with <code>r1.push</code> and <code>rr1.push</code> because Rust's <code>.</code> operator will automatically dereference any number of references.</p>\n\n<p>To return to the example from the question, the reference to <code>Vec&lt;usize&gt;</code> in the <code>Option</code> is like the <code>v</code> reference above, and matching it using the <code>Some(v)</code> pattern moves the reference into the <code>v</code> pattern variable.</p>\n\n<p>To fix it, the pattern must be changed as in the above example, to specify a variable that <em>refers</em> to the value which is itself a reference. This is achieved using the <code>if let Some(ref mut v)</code> syntax. As above, where the <code>rv</code> declaration had to be changed to mutable, this fix also requires the <code>Option</code> to be mutable. With those two changes, the code compiles:</p>\n\n<pre><code>fn maybe_push(mut v_option: Option&lt;&amp;mut Vec&lt;usize&gt;&gt;) -&gt; usize {\n    let mut c = 0;\n    if let Some(ref mut v) = v_option {\n        for i in 0..10 {\n            v.push(i);\n            c += i;\n        }\n    } else {\n        for i in 0..10 {\n            c += i;\n        }\n    }\n\n    if let Some(ref mut v) = v_option {\n        for i in 10..20 {\n            v.push(i);\n            c += i;\n        }\n    } else {\n        for i in 10..20 {\n            c += i;\n        }\n    }\n\n    return c;\n}\n\nfn main() {\n    let mut v: Vec&lt;usize&gt; = vec![];\n\n    println!(\"{}\", maybe_push(Some(&amp;mut v)));\n    println!(\"{}\", maybe_push(None));\n\n    println!(\"{:?}\", v);\n}\n</code></pre>\n\n<p>Another possibility is to use the <code>as_mut()</code> method to return the option content as a mutable reference to the previous content. This is conceptually equivalent to the change from <code>let r1 = rv</code> to <code>let rr1 = &amp;mut rv</code> in the first snippet, and would allow the use of <code>if let Some(v)</code> pattern, where <code>v</code> would still be a reference to mutable reference to the vector. This also requires that <code>v_option</code> is declared as mutable.</p>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 651, "favorite_count": 0, "accepted_answer_id": 40657177, "answer_count": 1, "score": 2, "last_activity_date": 1479565032, "creation_date": 1479391824, "last_edit_date": 1479393831, "question_id": 40657075, "link": "https://stackoverflow.com/questions/40657075/how-to-access-a-vector-multiple-times-within-an-option", "title": "How to access a vector multiple times within an &#39;Option&#39;?", "body": "<p>How to access a vector within an option without Rust moving it on the first access?</p>\n\n<pre><code>fn maybe_push(v_option: Option&lt;&amp;mut Vec&lt;usize&gt;&gt;) -&gt; usize {\n    let mut c = 0;\n    if let Some(v) = v_option {\n        for i in 0..10 {\n            v.push(i);\n            c += i;\n        }\n    } else {\n        for i in 0..10 {\n            c += i;\n        }\n    }\n\n    // second access, fails\n    if let Some(v) = v_option {\n        for i in 10..20 {\n            v.push(i);\n            c += i;\n        }\n    } else {\n        for i in 10..20 {\n            c += i;\n        }\n    }\n\n    return c;\n}\n\n\nfn main() {\n    let mut v: Vec&lt;usize&gt; = vec![];\n\n    println!(\"{}\", maybe_push(Some(&amp;mut v)));\n    println!(\"{}\", maybe_push(None));\n\n    println!(\"{:?}\", v);\n}\n</code></pre>\n\n<p>This gives the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of partially moved value: `v_option`\n  --&gt; src/main.rs:16:22\n   |\n4  |     if let Some(v) = v_option {\n   |                 - value moved here\n...\n16 |     if let Some(v) = v_option {\n   |                      ^^^^^^^^ value used here after move\n</code></pre>\n\n<p>Using <code>if let Some(ref mut v) = v_option {</code> which has been suggested fails too:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: cannot borrow immutable anonymous field `(v_option:std::prelude::v1::Some).0` as mutable\n --&gt; src/main.rs:4:21\n  |\n4 |         if let Some(ref mut v) = v_option {\n  |                     ^^^^^^^^^\n\nerror: cannot borrow immutable anonymous field `(v_option:std::prelude::v1::Some).0` as mutable\n  --&gt; src/main.rs:17:21\n   |\n17 |         if let Some(ref mut v) = v_option {\n   |                     ^^^^^^^^^\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479386802, "post_id": 40655179, "comment_id": 68541575, "body": "Yes, by muttable and immutable I always mean the borrow/reference, not the variable binding. The problem I am trying to describe is that I made mutable borrow (u) and that borrow became an immutable borrow in some circumstances (when used only like a immutable borrow)."}], "tags": [], "owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "is_accepted": false, "score": 0, "last_activity_date": 1479386519, "creation_date": 1479386519, "answer_id": 40655179, "question_id": 40654940, "link": "https://stackoverflow.com/questions/40654940/mutable-borrow-automatically-changes-to-immutable/40655179#40655179", "title": "Mutable borrow automatically changes to immutable?", "body": "<p>First of all, <code>u</code> is not mutable at any point, as it was declared with <code>let u</code>, not <code>let mut u</code>. The reason why you can mutate the <code>String</code> it points to is that it holds a mutable reference to it; <code>make_ascii_uppercase()</code> modifies <code>t</code>.</p>\n\n<p><code>v</code> is also immutable (no <code>mut</code> in <code>let v</code>), so when you call <code>show()</code> that works on immutable references, the borrowing rules are not violated - you can perform multiple immutable borrows at once.</p>\n"}, {"comments": [{"owner": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479387130, "post_id": 40655210, "comment_id": 68541797, "body": "I still does not understand. By calling <i>u.make_ascii_uppercase();</i> I am sure that the borrow is mutable, or compiler would complain otherwise."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479387498, "post_id": 40655210, "comment_id": 68542053, "body": "@RomanPolach: There are two different things here. (1) <code>u</code> borrows <code>t</code> mutably and (2) <code>make_ascii_uppercase</code> borrows the referee of <code>u</code> mutably. (1) lasts until the end of the function, however (2) only lasts for the duration of the function call (no return value to extend it). Then, in the lines <code>show(u)</code> you have (3) <code>show</code> borrowing the referee of <code>u</code> immutably for the duration of the function call."}, {"owner": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479387813, "post_id": 40655210, "comment_id": 68542275, "body": "So <i>u</i> is muttable borrow before calling <i>make_ascii_uppercase</i> and then it is an immutable borrow after that because it is <i>used</i> as immutable? That is the thing I am curious about."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1479389038, "post_id": 40655210, "comment_id": 68543103, "body": "I&#39;m not sure I get this either. Are you saying that <code>u</code>, despite being an <code>&amp;mut</code> reference to <code>t</code>, doesn&#39;t actually borrow <code>t</code> until passed to a function which makes use of it?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479389339, "post_id": 40655210, "comment_id": 68543302, "body": "@RomanPolach: <code>u</code> is an immutable binding, its value cannot change (it cannot refer to another variable), whose value is a mutable reference to <code>t</code>. The type of <code>u</code> does not change, it is <i>always</i> a mutable reference. However, one can borrow from <code>u</code> (forming a new reference), and this new reference may be either mutable or immutable."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1479389410, "post_id": 40655210, "comment_id": 68543357, "body": "@ChrisEmerson: Uh... no. Or if I do, it&#39;s certainly accidental... Am I that unclear?"}, {"owner": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479389613, "post_id": 40655210, "comment_id": 68543500, "body": "When I made <code>u</code> a mutable reference, then making another reference (<code>v</code>) should be disallowed. But the code compiles. That is I do not understand."}, {"owner": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479389756, "post_id": 40655210, "comment_id": 68543601, "body": "Moreover, if I add a new call to the end of <code>main</code> function that <i>uses</i> <code>u</code> as mutable (like second call <code>u.make_ascii_uppercase();</code>), then the compiler recall that <code>let v = &amp;*u;</code> is really illegal. But why it didn&#39;t complain before?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479390595, "post_id": 40655210, "comment_id": 68544242, "body": "@RomanPolach: I reviewed the answer, to explain how I understand this. I must admit it&#39;s quite difficult for me as I find the behavior intuitive and never really attempted an in-depth explanation of how it worked, so please tell me if there are still portions of the answer that are unclear."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1479390790, "post_id": 40655210, "comment_id": 68544417, "body": "The section on re-borrowing makes it clear for me, thanks."}, {"owner": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479392626, "post_id": 40655210, "comment_id": 68545823, "body": "Thanks a lot, your reviewed answer makes me understand now. I was unaware of re-borrowing mechanism before, though I suspected something like that (but simpler) in transforming real <code>&amp;mut str</code> parameter in place of formal <code>&amp;str</code> function parameter. But The compiler cleverness making side-effect to <code>u</code> when binding <code>v</code> was beyond my imagination."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 8, "last_activity_date": 1479390509, "last_edit_date": 1479390509, "creation_date": 1479386594, "answer_id": 40655210, "question_id": 40654940, "link": "https://stackoverflow.com/questions/40654940/mutable-borrow-automatically-changes-to-immutable/40655210#40655210", "title": "Mutable borrow automatically changes to immutable?", "body": "<p>A mutable reference <em>can</em> be borrowed immutably, however this is not what is happening here.</p>\n\n<p>When forming a reference with <code>&amp;</code>, you need to be explicit about mutability; unless you specify <code>&amp;mut</code> it will be an immutable reference.</p>\n\n<hr>\n\n<p>Your example can be reduced to:</p>\n\n<pre><code>use std::ascii::AsciiExt;\n\nfn main() {\n    let mut t = \"s\".to_string();\n    let u = &amp;mut t;\n    u.make_ascii_uppercase();\n    let v = &amp;*u;\n\n    let () = v;\n}\n</code></pre>\n\n<p>The last line is a trick to get the compiler to tell us (in the error message) what the type of <code>v</code> is. It reports:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; &lt;anon&gt;:9:9\n  |\n9 |     let () = v;\n  |         ^^ expected reference, found ()\n  |\n  = note: expected type `&amp;std::string::String`\n  = note:    found type `()`\n</code></pre>\n\n<p>Here we have:</p>\n\n<ul>\n<li><code>u</code>: an immutable binding, which is a mutable borrow of <code>t</code></li>\n<li><code>v</code>: an immutable binding, which is an immutable re-borrow of <code>t</code> through <code>u</code></li>\n</ul>\n\n<p>If, however, I change the <code>v</code> line to <code>let v = &amp;mut *u;</code>, then I get <code>expected type '&amp;mut std::string::String'</code> and then we have:</p>\n\n<ul>\n<li><code>u</code>: an immutable binding, which is a mutable borrow of <code>t</code></li>\n<li><code>v</code>: an immutable binding, which is a mutable re-borrow of <code>t</code> through <code>u</code></li>\n</ul>\n\n<hr>\n\n<p>The important concept here is <em>re-borrowing</em>, which is what <code>&amp;*u</code> and <code>&amp;mut *u</code> are about. Re-borrowing allows forming a new reference from an existing reference:</p>\n\n<ul>\n<li>a re-borrow access the initially borrowed variable</li>\n<li>for the lifetime of the re-borrow, the reference from which it is formed is borrowed</li>\n</ul>\n\n<p>The re-borrowing rules are relatively simple, they mirror the borrowing rules:</p>\n\n<ul>\n<li>if you start from an immutable reference:\n\n<ul>\n<li>you can re-borrow it only as an immutable reference, with multiple concurrent immutable re-borrow if you wish</li>\n</ul></li>\n<li>if you start from a mutable reference:\n\n<ul>\n<li>you can either re-borrow it as a mutable reference, exclusively</li>\n<li>or you can re-borrow it as an immutable reference, with multiple concurrent immutable re-borrow if you wish</li>\n</ul></li>\n</ul>\n\n<p>It is interesting to note that a re-borrowed reference can live longer than the reference it was formed from:</p>\n\n<pre><code>fn main() {\n    let mut t = \"s\".to_string();\n\n    let v;\n    {\n        let u = &amp;mut t;\n        v = &amp;mut *u;\n    }\n\n    v.make_ascii_uppercase();\n    show(v);\n}\n</code></pre>\n\n<p>This is necessary to ensure that you can return a reference from functions; of course.</p>\n\n<p>So, ultimately, a re-borrow is tracked down to the original borrowed value by the compiler; however, due the re-borrowing mechanics it allows forming an immutable reference to this original value even though a mutable reference is in scope... and simply make sure that this mutable reference is unusable for the lifetime of the new immutable reference.</p>\n\n<hr>\n\n<p>When a function takes a reference, the compiler automatically introduces a re-borrow at the call site with the appropriate mutability; this is what happens with <code>show</code> here: <code>show(u)</code> really is <code>show(&amp;*u)</code> with a new immutable reference formed for the duration of the function call.</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1479390681, "post_id": 40656548, "comment_id": 68544322, "body": "My take is that <code>u</code> is itself borrowed while <code>v</code> exists, and thus must obey the same rules as normal: if <code>v</code> is a mutable borrow, <code>u</code> cannot be re-borrowed at all, if <code>v</code> is an immutable borrow, then only other immutable borrows can be formed."}, {"owner": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "edited": false, "score": 0, "creation_date": 1479393364, "post_id": 40656548, "comment_id": 68546365, "body": "The most confusing is the side effect to <code>u</code> when binding <code>v</code>. In the first code example compiler check that <code>u</code> is not used mutably after <code>&amp;*u</code> and allows taking mutable reference <code>v</code>. In the last code example it knows that <code>u</code> is really used as mutable reference, so it disallows <code>&amp;*u</code>..."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 1, "last_activity_date": 1479390291, "creation_date": 1479390291, "answer_id": 40656548, "question_id": 40654940, "link": "https://stackoverflow.com/questions/40654940/mutable-borrow-automatically-changes-to-immutable/40656548#40656548", "title": "Mutable borrow automatically changes to immutable?", "body": "<p>This is confusing, so let's do some experiments.</p>\n\n<p>Your code compiles:</p>\n\n<pre><code>let mut t = String::new();\nt.push('s');\nlet u = &amp;mut t;\nu.make_ascii_uppercase(); // u is really mutable here\nlet v = &amp;*u; // u became immutable to allow this?\nshow(u); // both u and v are now accessible!\nshow(v);\n</code></pre>\n\n<p>What happens if we change the <code>let v</code> line to:</p>\n\n<pre><code>let v = &amp;t;\n</code></pre>\n\n<blockquote>\n  <p>error[E0502]: cannot borrow <code>t</code> as immutable because it is also borrowed as mutable</p>\n  \n  <p>--> :12:14</p>\n</blockquote>\n\n<p>Ok, so that's different.  That tells me that <code>&amp;*u</code>, despite being the same type as <code>&amp;t</code>, is not the same; the former is (sub-)borrowing from <em><code>u</code></em>, but the latter is trying to reborrow <code>t</code>.</p>\n\n<p>Let's try a different experiment.  Putting the previous line back, but now adding something new:</p>\n\n<pre><code>let v = &amp;*u;   // the original reborrow\nlet w = u;     // Try to move out of `u`\n</code></pre>\n\n<blockquote>\n  <p>error[E0502]: cannot borrow <code>t</code> as immutable because it is also borrowed as mutable</p>\n  \n  <p>--> :12:14</p>\n</blockquote>\n\n<p>Aha!  That confirms that <code>v</code> really is borrowing from <code>u</code> rather than directly from <code>t</code>.</p>\n\n<p>Now, in the original, let's add an attempted mutation via <code>u</code> to the end:</p>\n\n<pre><code>let mut t = String::new();\nt.push('s');\nlet u = &amp;mut t;\nu.make_ascii_uppercase(); // u is really mutable here\nlet v = &amp;*u; // u became immutable to allow this?\nshow(u); // both u and v are now accessible!\nshow(v);\nu.make_ascii_uppercase();\n</code></pre>\n\n<p>Now I get:</p>\n\n<blockquote>\n  <p>error[E0502]: cannot borrow <code>*u</code> as mutable because it is also borrowed as immutable</p>\n</blockquote>\n\n<p>I think that basically explains what's going on:</p>\n\n<ul>\n<li><code>u</code> borrows <code>t</code> mutably.  This stops <code>t</code> being accessed at all directly.</li>\n<li><code>v</code> borrows <code>u</code> immutably.  This means that <code>u</code> can still be used immutably, but it can't be used mutably or moved out of.</li>\n<li>The other key thing is that you can only use mutable values if the <em>full path</em> to the item is mutable.  Since <code>u</code> can't be borrowed mutably while <code>v</code> exists, you can't use <code>*u</code> mutably either.  (This last bit is slightly handwavey; I'd welcome further clarifications...)</li>\n</ul>\n"}], "owner": {"reputation": 287, "user_id": 4480093, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/8d91b56823dec49f7e945f0ed0ca094b?s=128&d=identicon&r=PG&f=1", "display_name": "Roman Polach", "link": "https://stackoverflow.com/users/4480093/roman-polach"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 782, "favorite_count": 3, "accepted_answer_id": 40655210, "answer_count": 3, "score": 3, "last_activity_date": 1479390509, "creation_date": 1479385840, "last_edit_date": 1479389028, "question_id": 40654940, "link": "https://stackoverflow.com/questions/40654940/mutable-borrow-automatically-changes-to-immutable", "title": "Mutable borrow automatically changes to immutable?", "body": "<p>It seems that <code>u</code>, a mutable borrow, becomes automatically immutable in</p>\n\n<pre><code>let v = &amp;*u;\n</code></pre>\n\n<p>Both <code>u</code> and <code>v</code> are then immutable borrowed references so they are both allowed.</p>\n\n<pre><code>use std::ascii::AsciiExt;\n\nfn show(a: &amp;str) {\n    println!(\"a={}\", a);\n}\n\nfn main() {\n    let mut t = String::new();\n    t.push('s');\n    let u = &amp;mut t;\n    u.make_ascii_uppercase(); // u is really mutable here\n    let v = &amp;*u; // u became immutable to allow this?\n    show(u); // both u and v are now accessible!\n    show(v);\n}\n</code></pre>\n\n<p>Outputs:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>a=S\na=S\n</code></pre>\n\n<p>If I try to use <code>u</code> as a mutable borrow after</p>\n\n<pre><code>show(v);\n</code></pre>\n\n<p>compiler will recall that </p>\n\n<pre><code>let v = &amp;*u;\n</code></pre>\n\n<p>is really not allowed:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>cannot borrow `*u` as mutable because it is also borrowed as immutable\n</code></pre>\n\n<p>Is it a bug or is there really some \"automatically convert mutable borrow to immutable when mutability is no longer needed\" principle? I am using Rust 1.13.0.</p>\n"}]