[{"tags": ["rust", "move-semantics", "ffi", "dangling-pointer"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458772666, "post_id": 36188870, "comment_id": 60015080, "body": "<i>is that if a value of <code>Cached</code> was to be moved</i> - I feel like you aren&#39;t providing enough information. What would be keeping a pointer to <code>bar.p_foo</code> that would be invalidated when it&#39;s moved? Does something like <a href=\"https://play.rust-lang.org/?gist=53bf026d76e0665e2381&amp;version=stable\" rel=\"nofollow noreferrer\">this</a> seem useful at all?"}, {"owner": {"reputation": 1042, "user_id": 1236574, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/hyl6L.jpg?s=128&g=1", "display_name": "jmegaffin", "link": "https://stackoverflow.com/users/1236574/jmegaffin"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458785452, "post_id": 36188870, "comment_id": 60018832, "body": "<code>bar.p_foo</code> <i>is</i> the pointer that would be invalidated if the object was to be moved, as it points to a (part of a) field of the structure itself.  I&#39;ll clarify by writing the equivalent to what I want in C++."}], "answers": [{"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 1, "last_activity_date": 1458808380, "creation_date": 1458808380, "answer_id": 36195952, "question_id": 36188870, "link": "https://stackoverflow.com/questions/36188870/move-semantics-in-rust/36195952#36195952", "title": "Move semantics in Rust", "body": "<p>The Rust-equivalent would be to not use raw pointers, as raw pointers are there for implementing our safe datastructures, not for implementing normal datastructures.</p>\n\n<pre><code>#[repr(C)]\nstruct Foo {\n    x: i32,\n    y: f32\n}\n\n#[repr(C)]\nstruct Bar {\n    p_foo: Option&lt;Box&lt;Foo&gt;&gt;,\n    z: bool\n}\n</code></pre>\n\n<p>An <code>Option&lt;Box&lt;T&gt;&gt;</code> is guaranteed to be exactly equivalent (in bits in memory) to a <code>*const T</code>, as long as <code>T</code> is a type and not a trait. The only difference is that it's safe to use within Rust.</p>\n\n<p>This way you don't even need a <code>Cached</code> struct anymore, but can directly pass around the <code>Bar</code> object.</p>\n\n<hr>\n\n<blockquote>\n  <p>I'd also rather not Box the substructures up on the heap.</p>\n</blockquote>\n\n<p>Then I suggest you don't keep a <code>Bar</code> object around, and instead conjure it up whenever you need to pass one to C:</p>\n\n<pre><code>#[repr(C)]\nstruct Foo {\n    x: i32,\n    y: f32\n}\n\n#[repr(C)]\nstruct Bar&lt;'a&gt; {\n    p_foo: Option&lt;&amp;'a Foo&gt;,\n    z: bool\n}\n\nstruct Cached {\n    foo: Option&lt;Foo&gt;,\n    z: bool,\n}\n\nimpl Cached {\n    fn bar&lt;'a&gt;(&amp;'a self) -&gt; Bar&lt;'a&gt; {\n        Bar {\n            p_foo: self.foo.as_ref(),\n            z: self.z,\n        }\n    }\n}\n</code></pre>\n\n<blockquote>\n  <p>there is a bit of work involved to set up these pointers, especially if the nesting/chaining is deep/long. </p>\n</blockquote>\n\n<p>That sounds a lot like premature optimization. Don't optimize where you haven't benchmarked.</p>\n"}], "owner": {"reputation": 1042, "user_id": 1236574, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/hyl6L.jpg?s=128&g=1", "display_name": "jmegaffin", "link": "https://stackoverflow.com/users/1236574/jmegaffin"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 295, "favorite_count": 0, "answer_count": 1, "score": 2, "last_activity_date": 1458808380, "creation_date": 1458767932, "last_edit_date": 1458785820, "question_id": 36188870, "link": "https://stackoverflow.com/questions/36188870/move-semantics-in-rust", "title": "Move semantics in Rust", "body": "<p>I'm wrapping a C library in Rust, and many of its functions take parameters by pointers to structs, which themselves often have pointers to other structs.  In the interest of reducing overhead, I'd like to provide the ability to cache the results of marshaling the Rust data into the C structs.</p>\n\n<p>Here's an example of how the C library might expect some parameters:</p>\n\n<pre><code>#[repr(C)]\nstruct Foo {\n    x: i32,\n    y: f32\n}\n\n#[repr(C)]\nstruct Bar {\n    p_foo: *const Foo,\n    z: bool\n}\n</code></pre>\n\n<p>And how I'd imagine an owning, \"cached\" version would look:</p>\n\n<pre><code>struct Cached {\n    foo: Option&lt;Foo&gt;,\n    bar: Bar\n}\n</code></pre>\n\n<p>The <code>p_foo</code> field of <code>bar</code> would be constructed to point to <code>Some</code> value within <code>foo</code>, or a null pointer if there was <code>None</code>.</p>\n\n<p>The issue, here, of course, is that if a value of <code>Cached</code> was to be moved, a straight <code>memcpy</code> would be inappropriate and <code>bar.p_foo</code> would additionally need to be redirected.  This would be easy to ensure in C++, with its definable move semantics, but does Rust offer a solution besides \"don't set <code>bar.p_foo</code> until it's used\"?  While it would certainly work to do it that way, I don't imagine that these cached values will be moved more than (or even close to the frequency that) they are reused, and there is a bit of work involved to set up these pointers, especially if the nesting/chaining is deep/long.  I'd also rather not <code>Box</code> the substructures up on the heap.</p>\n\n<hr>\n\n<p>To clarify, here's what I can write in C++, which I would like to replicate in Rust:</p>\n\n<pre><code>struct Foo {\n    int x;\n    float y;\n};\n\nstruct Bar {\n    Foo const*pFoo;\n    bool z;\n};\n\n// bear with me while I conjure up a Maybe for C++\nclass Cached {\npublic:\n    // would have appropriate copy constructor/assignment\n\n    Cached(Cached &amp;&amp;other) {\n        m_foo = other.m_foo;\n        m_bar = other.m_bar;\n\n        if(m_foo.isJust()) {\n            m_bar.pFoo = &amp;m_foo.value();\n        } // else already nullptr\n    }\n\n    // similar move assignment\n\nprivate:\n    Maybe&lt;Foo&gt; m_foo;\n    Bar m_bar;\n};\n</code></pre>\n"}, {"tags": ["reference", "rust", "option", "traits"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1458755788, "last_edit_date": 1495542649, "creation_date": 1458755202, "answer_id": 36185227, "question_id": 36184843, "link": "https://stackoverflow.com/questions/36184843/how-to-implement-errorcause-properly/36185227#36185227", "title": "How to implement Error::cause properly?", "body": "<p>It is useful to <a href=\"https://stackoverflow.com/q/21747136/155423\">print the type of variables</a> in cases like this:</p>\n\n<pre><code>match *self {\n    MyError::NotFound(_) =&gt; None,\n    MyError::PersistenceError(ref cause) =&gt; {\n        let () = cause;\n    },\n}\n</code></pre>\n\n<p>This will tell you that <code>cause</code> is a <code>&amp;Box&lt;std::error::Error + Send + Sync&gt;</code>.</p>\n\n<p>If we dereference it once, we will have a <code>Box&lt;std::error::Error + Send + Sync&gt;</code> and if we dereference it a second time we will have a <code>std::error::Error + Send + Sync</code> (this isn't a real type). We can then take another reference which can be implicitly made into an <code>&amp;Error</code>:</p>\n\n<pre><code>match *self {\n    MyError::NotFound(_) =&gt; None,\n    MyError::PersistenceError(ref cause) =&gt; Some(&amp;**cause),\n}\n</code></pre>\n"}], "owner": {"reputation": 53, "user_id": 3592271, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/156c2ee3c0939564a2a9b71cb894f614?s=128&d=identicon&r=PG&f=1", "display_name": "chridou", "link": "https://stackoverflow.com/users/3592271/chridou"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 105, "favorite_count": 0, "accepted_answer_id": 36185227, "answer_count": 1, "score": 5, "last_activity_date": 1458755788, "creation_date": 1458754022, "last_edit_date": 1458754823, "question_id": 36184843, "link": "https://stackoverflow.com/questions/36184843/how-to-implement-errorcause-properly", "title": "How to implement Error::cause properly?", "body": "<p>I have a problem implementing the <code>Error</code> trait. I want to wrap an error from Diesel or another database driver. I didn't even get close to implementing <code>From</code> since I'm already failing at implementing <code>Error</code>. The line that causes the code not to compile is the one at the very end of the code block. </p>\n\n<pre><code>use std::fmt;\nuse std::error::{self, Error};\n\n#[derive(Debug)]\npub enum MyError {\n    NotFound(String),\n    PersistenceError(Box&lt;Error + Send + Sync&gt;),\n}\n\npub type MyResult&lt;T&gt; = Result&lt;T, MyError&gt;;\n\nimpl fmt::Display for MyError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match *self {\n            MyError::NotFound(ref msg) =&gt; write!(f, \"Not found: {}\", msg),\n            MyError::PersistenceError(ref cause) =&gt; write!(f, \"Persistence error: {}\", cause),\n        }\n    }\n}\n\nimpl Error for MyError {\n    fn description(&amp;self) -&gt; &amp;str {\n        match *self {\n            MyError::NotFound(ref msg) =&gt; msg,\n            MyError::PersistenceError(ref cause) =&gt; cause.description(),\n        }\n    }\n\n    fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; {\n        match *self {\n            MyError::NotFound(_) =&gt; None,\n            // `*cause` does not live long enough\n            MyError::PersistenceError(cause) =&gt; Some(&amp;*cause),\n        }\n    }\n}\n</code></pre>\n\n<p>I also tried:</p>\n\n<blockquote>\n  <p>*cause does not live long enough</p>\n</blockquote>\n\n<pre><code>MyError::PersistenceError(cause) =&gt; Some(&amp;*cause),\n</code></pre>\n\n<blockquote>\n  <p>the trait core::marker::Sized is not implemented for the type\n  std::error::Error + Send + Sync + 'static [E0277]</p>\n</blockquote>\n\n<pre><code>MyError::PersistenceError(ref cause) =&gt; Some(cause),\n</code></pre>\n\n<blockquote>\n  <p>the trait std::error::Error is not implemented for the type `&amp;Box</p>\n</blockquote>\n\n<pre><code>MyError::PersistenceError(ref cause) =&gt; Some(&amp;cause)\n</code></pre>\n\n<p>But none of these worked.</p>\n"}, {"tags": ["documentation", "rust"], "answers": [{"comments": [{"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 0, "creation_date": 1458815413, "post_id": 36184584, "comment_id": 60029317, "body": "It is somewhat analogous to how attributes work (though I tried <code>&#47;&#47;&#47;!</code> first)."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 0, "creation_date": 1458820869, "post_id": 36184584, "comment_id": 60032682, "body": "@starblue: Yes, when I realized there was a <code>!</code> I found the resemblance with attributes striking; I think it shows well in the code sample given how close the two are together."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 18, "last_activity_date": 1557360373, "last_edit_date": 1557360373, "creation_date": 1458753200, "answer_id": 36184584, "question_id": 36184407, "link": "https://stackoverflow.com/questions/36184407/how-can-i-write-crate-wide-documentation/36184584#36184584", "title": "How can I write crate-wide documentation?", "body": "<p>I found the hidden nugget in the <a href=\"https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#commenting-contained-items\" rel=\"noreferrer\">book's Publishing a Crate to Crates.io section</a>.</p>\n\n<p>Regular documentation comments (starting with <code>///</code>) document the <em>next</em> item, however a crate is nobody's next.</p>\n\n<p>The solution is to switch to using another kind of comment, this time starting with <code>//!</code>, which documents the <em>enclosing</em> item.</p>\n\n<p>And suddenly it works:</p>\n\n<pre><code>#![deny(missing_docs)]\n\n//! Hello world example for Rust.\n\nfn main() {\n    println!(\"Hello world!\");\n}\n</code></pre>\n"}], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 930, "favorite_count": 1, "accepted_answer_id": 36184584, "answer_count": 1, "score": 14, "last_activity_date": 1557360373, "creation_date": 1458752602, "last_edit_date": 1557360261, "question_id": 36184407, "link": "https://stackoverflow.com/questions/36184407/how-can-i-write-crate-wide-documentation", "title": "How can I write crate-wide documentation?", "body": "<p>In order to ensure that all public artifacts of my crate are documented (if minimally to start with), I specified <code>#![deny(missing_docs)]</code> in my <code>lib.rs</code>. This backfired.</p>\n\n<p>I expected to write a documentation comment at the top and the code afterwards:</p>\n\n<pre><code>/// Hello world example for Rust.\n\n#![deny(missing_docs)]\n\nfn main() {\n    println!(\"Hello world!\");\n}\n</code></pre>\n\n<p>This fails with:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: an inner attribute is not permitted following an outer doc comment\n --&gt; src/main.rs:3:3\n  |\n3 | #![deny(missing_docs)]\n  |   ^\n  |\n  = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n</code></pre>\n\n<p>Reverting the order so that the attribute is first and the comment second:</p>\n\n<pre><code>#![deny(missing_docs)]\n\n/// Hello world example for Rust.\n\nfn main() {\n    println!(\"Hello world!\");\n}\n</code></pre>\n\n<p>Also fails:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: missing documentation for crate\n --&gt; src/main.rs:1:1\n  |\n1 | / #![deny(missing_docs)]\n2 | |\n3 | | /// Hello world example for Rust.\n4 | |\n5 | | fn main() {\n6 | |     println!(\"Hello world!\");\n7 | | }\n  | |_^\n  |\nnote: lint level defined here\n --&gt; src/main.rs:1:9\n  |\n1 | #![deny(missing_docs)]\n  |         ^^^^^^^^^^^^\n</code></pre>\n\n<p>I could not find how to actually write documentation for the crate itself. How should I be writing the crate's documentation to satisfy <code>#![deny(missing_docs)]</code>?</p>\n"}, {"tags": ["pattern-matching", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1458751900, "post_id": 36183896, "comment_id": 60003567, "body": "We really like <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a>, because it ensures that the answers are appropriate, instead of being wild guesses. Specifically here, it&#39;s unclear to me what the signature of <code>util::request_mem</code> is. From your comment it seems it returns some kind of <code>Option&lt;T*&gt;</code>, but I am not quite sure. Also, while it&#39;s nice to know that you would like to avoid <code>unwrap</code>, you are not specifying what should occur if <code>request_mem</code> returns <code>None</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458756201, "post_id": 36183896, "comment_id": 60006343, "body": "In addition, if you wrote the code <i>with</i> the &quot;doubly indented match statement&quot;, that would be a way of showing what you want it to do."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1458756483, "post_id": 36185480, "comment_id": 60006520, "body": "I&#39;ve been wondering about the readability of the upcoming <code>?</code> but here I must admit... it takes a moment to understand the exact scope of <code>try!</code> with all those parentheses going on!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458756654, "post_id": 36185480, "comment_id": 60006630, "body": "@MatthieuM. yeah. I don&#39;t like that I had to make a &quot;fake&quot; error value of <code>0</code> and I don&#39;t like that the line is so long such that the <code>try</code> is hard to understand. I really want a method on <code>Option</code> that takes a <code>F: FnOnce() -&gt; Result&lt;T, E&gt;</code>, but that seems pretty special-cased. I might normally split the <code>try</code> onto two lines as well..."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1458758013, "last_edit_date": 1458758013, "creation_date": 1458756103, "answer_id": 36185480, "question_id": 36183896, "link": "https://stackoverflow.com/questions/36183896/remove-unwrap-calls-from-options-and-results-without-introducing-doubly-indented/36185480#36185480", "title": "Remove unwrap calls from Options and Results without introducing doubly indented match statements", "body": "<p>One solution is to convert the returned <code>Option</code> into a <code>Result</code>, then use methods like <a href=\"http://doc.rust-lang.org/core/result/enum.Result.html#method.or_else\" rel=\"nofollow\"><code>Result::or_else</code></a> to chain further work and macros like <a href=\"http://doc.rust-lang.org/core/macro.try!.html\" rel=\"nofollow\"><code>try!</code></a> to return early:</p>\n\n<pre><code>struct Thing;\nimpl Thing {\n    fn split(&amp;self, size: u8) -&gt; bool { false }\n}\n\nfn find_free_block(size: u8) -&gt; Option&lt;*mut Thing&gt; { None }\nfn request_mem(size: u8) -&gt; Result&lt;*mut Thing, i32&gt; { Err(1) }\n\nfn the_answer(size: u8) -&gt; Result&lt;bool, i32&gt; {\n    let thing_ptr = try!(find_free_block(size).ok_or(0).or_else(|_| request_mem(size)));\n    let thing = unsafe { &amp;*thing_ptr }; \n    Ok(thing.split(size))\n}\n\nfn main() {}\n</code></pre>\n\n<p>Alternately:</p>\n\n<pre><code>fn the_answer(size: u8) -&gt; Result&lt;bool, i32&gt; {\n    find_free_block(size)\n        .ok_or(0)\n        .or_else(|_| request_mem(size))\n        .map(|t| unsafe { &amp;*t })\n        .map(|t| t.split(size))\n}\n</code></pre>\n\n<hr>\n\n<p>What would be pretty great is if something like this could work</p>\n\n<pre><code>fn the_answer(size: u8) -&gt; Result&lt;bool, i32&gt; {\n    find_free_block(size)\n        .ok_or_maybe(|| request_mem(size))\n        .map(|t| unsafe { &amp;*t })\n        .map(|t| t.split(size))\n}\n</code></pre>\n\n<p>You could make this happen <em>right now</em> though:</p>\n\n<pre><code>trait Secret&lt;T&gt; {\n    fn ok_or_maybe&lt;E, F&gt;(self, F) -&gt; Result&lt;T, E&gt;\n        where F: FnOnce() -&gt; Result&lt;T, E&gt;;\n}\n\nimpl&lt;T&gt; Secret&lt;T&gt; for Option&lt;T&gt; {\n    fn ok_or_maybe&lt;E, F&gt;(self, f: F) -&gt; Result&lt;T, E&gt;\n        where F: FnOnce() -&gt; Result&lt;T, E&gt;\n    {\n        match self {\n            Some(e) =&gt; Ok(e),\n            None =&gt; f(),\n        }\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 688, "user_id": 4157647, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/82e77ab7941218ff6733d668b8049185?s=128&d=identicon&r=PG&f=1", "display_name": "Harvey Adcock", "link": "https://stackoverflow.com/users/4157647/harvey-adcock"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 156, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1458758013, "creation_date": 1458751191, "last_edit_date": 1458756172, "question_id": 36183896, "link": "https://stackoverflow.com/questions/36183896/remove-unwrap-calls-from-options-and-results-without-introducing-doubly-indented", "title": "Remove unwrap calls from Options and Results without introducing doubly indented match statements", "body": "<p>I'm trying to remove some unwrap functions from a project, but I can't figure out what the idiomatic version of this block would be::</p>\n\n<pre><code>let free_block = match util::find_free_block(size) {\n    Some(block) =&gt; unsafe { (*block).split(size) },\n    None        =&gt; unsafe { (*util::request_mem(size).unwrap()).split(size) }\n};\n</code></pre>\n\n<p>without having a doubly indented match statement in the case of the <code>None</code> matching.</p>\n\n<p><code>util::request_mem(size)</code> returns a <code>Result&lt;*mut T, i32&gt;</code> and upon failure the <code>i32</code> value should be returned.</p>\n\n<p>I understand there isn't a C-like equivalent of the arrow operator for dereferencing and calling a method on a raw pointer, which makes some of my code look awful but it's somewhat understandable why it isn't in the language.</p>\n"}, {"tags": ["multithreading", "rust"], "comments": [{"owner": {"reputation": 2597, "user_id": 263132, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c6b8139c802fb2123f01ad1ee173dbd4?s=128&d=identicon&r=PG", "display_name": "Mike Cooper", "link": "https://stackoverflow.com/users/263132/mike-cooper"}, "edited": false, "score": 3, "creation_date": 1458745766, "post_id": 36181719, "comment_id": 59998917, "body": "It would probably be better if your sample code was more minimal, showing only the problem at hand instead of a page of command line argument parsing and option fiddling."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458746012, "post_id": 36181719, "comment_id": 59999129, "body": "Terminating or killing a thread was a <a href=\"http://stackoverflow.com/q/5218969/155423\">bad</a> <a href=\"http://stackoverflow.com/q/1559255/155423\">idea</a> in the languages that added it. Rust won&#39;t be adding it."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 2597, "user_id": 263132, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/c6b8139c802fb2123f01ad1ee173dbd4?s=128&d=identicon&r=PG", "display_name": "Mike Cooper", "link": "https://stackoverflow.com/users/263132/mike-cooper"}, "edited": false, "score": 0, "creation_date": 1458746519, "post_id": 36181719, "comment_id": 59999589, "body": "@Ba7a7chy: I think @MikeCooper meant an <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a>, meaning something that doesn&#39;t even relate to tcp. Just a thread that does <code>loop {}</code> and your attempts at killing it."}, {"owner": {"reputation": 1261, "user_id": 1526733, "user_type": "registered", "accept_rate": 96, "profile_image": "https://www.gravatar.com/avatar/b3478b696e8b26f4562569fb35fe4844?s=128&d=identicon&r=PG", "display_name": "Ba7a7chy", "link": "https://stackoverflow.com/users/1526733/ba7a7chy"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1458746893, "post_id": 36181719, "comment_id": 59999859, "body": "@ker I have some hopes that maybe someone would see this example in Rust and will say &quot;oh, you can&#39;t set timeout but you can do x&quot; so I&#39;ll leave the specific tcp socket example in the hope of this will come true :)"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1458747069, "post_id": 36181719, "comment_id": 59999997, "body": "oh right, that makes sense. Still, the <code>argparse</code> crate import is not necessary"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1458747308, "post_id": 36181719, "comment_id": 60000181, "body": "The <a href=\"https://doc.rust-lang.org/net2-rs/net2/index.html\" rel=\"nofollow noreferrer\"><code>net2</code></a> crate gives you more finegrained control for the tcp-case according to <a href=\"https://github.com/rust-lang/rust/issues/31724#issuecomment-185298027\" rel=\"nofollow noreferrer\">alexcrichton</a>"}], "answers": [{"comments": [{"owner": {"reputation": 1261, "user_id": 1526733, "user_type": "registered", "accept_rate": 96, "profile_image": "https://www.gravatar.com/avatar/b3478b696e8b26f4562569fb35fe4844?s=128&d=identicon&r=PG", "display_name": "Ba7a7chy", "link": "https://stackoverflow.com/users/1526733/ba7a7chy"}, "edited": false, "score": 0, "creation_date": 1458747818, "post_id": 36182336, "comment_id": 60000572, "body": "I tried that now, it seems that Receiver blocks until it gets an answer, if that is really the case I&#39;m in the same place when using Send\\Receive"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 1261, "user_id": 1526733, "user_type": "registered", "accept_rate": 96, "profile_image": "https://www.gravatar.com/avatar/b3478b696e8b26f4562569fb35fe4844?s=128&d=identicon&r=PG", "display_name": "Ba7a7chy", "link": "https://stackoverflow.com/users/1526733/ba7a7chy"}, "edited": false, "score": 2, "creation_date": 1458747981, "post_id": 36182336, "comment_id": 60000705, "body": "I updated with some code. You need to use <code>try_recv</code>, which is the non-blocking receiving method"}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 13, "last_activity_date": 1458747961, "last_edit_date": 1458747961, "creation_date": 1458747008, "answer_id": 36182336, "question_id": 36181719, "link": "https://stackoverflow.com/questions/36181719/what-is-the-correct-way-in-rust-to-create-a-timeout-for-a-thread-or-a-function/36182336#36182336", "title": "What is the correct way in Rust to create a timeout for a thread or a function?", "body": "<p>As @Shepmaster noted: it's a bad idea to terminate threads.</p>\n\n<p>What you can do instead is to give the thread a <a href=\"https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html\"><code>Sender</code></a> through which it should notify you if it has successfully opened a connection (maybe even by sending you the handle). Then you can let your main thread <a href=\"https://doc.rust-lang.org/std/thread/fn.sleep.html\"><code>sleep</code></a> for the time you wish to wait. When your thread wakes up, it checks its corresponding <a href=\"https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html\"><code>Receiver</code></a> for some sign of life from the thread. In case the thread did not answer, just <a href=\"https://doc.rust-lang.org/std/thread/struct.JoinHandle.html\">release it into the wild by dropping the <code>JoinHandle</code></a> and the <code>Receiver</code>. It's not like it's consuming cpu-time (it's blocked), and it's not consuming too much memory. If it ever unblocks, it'll detect that the <code>Sender</code> is not connected and can shut down for good.</p>\n\n<p>Of course you should not have bazillions of these open threads, because they still use resources (memory and system thread handles), but on a normal system that's not too much of an issue.</p>\n\n<p>Example:</p>\n\n<pre><code>use std::net;\nuse std::thread;\nuse std::sync::mpsc;\n\nfn scan_port(host: &amp;str, port: u16) -&gt; bool {\n    let host = host.to_string();\n    let port = port;\n    let (sender, receiver) = mpsc::channel();\n    let t = thread::spawn(move || {\n        match sender.send(net::TcpStream::connect((host.as_str(), port))) {\n            Ok(()) =&gt; {}, // everything good\n            Err(_) =&gt; {}, // we have been released, don't panic\n        }\n    });\n\n    thread::sleep(std::time::Duration::new(5, 0));\n\n    match receiver.try_recv() {\n        Ok(Ok(handle)) =&gt; true, // we have a connection\n        Ok(Err(_)) =&gt; false, // connecting failed\n        Err(mpsc::TryRecvError::Empty) =&gt; {\n            drop(receiver);\n            drop(t);\n            // connecting took more than 5 seconds\n            false\n        },\n        Err(mpsc::TryRecvError::Disconnected) =&gt; unreachable!(),\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 20458, "user_id": 122087, "user_type": "registered", "accept_rate": 91, "profile_image": "https://www.gravatar.com/avatar/431c64e3e3fd0c892ad2a7e4150cf63e?s=128&d=identicon&r=PG", "display_name": "Paul A Jungwirth", "link": "https://stackoverflow.com/users/122087/paul-a-jungwirth"}, "is_accepted": true, "score": 7, "last_activity_date": 1489155356, "creation_date": 1489155356, "answer_id": 42720480, "question_id": 36181719, "link": "https://stackoverflow.com/questions/36181719/what-is-the-correct-way-in-rust-to-create-a-timeout-for-a-thread-or-a-function/42720480#42720480", "title": "What is the correct way in Rust to create a timeout for a thread or a function?", "body": "<p>The answer by @ker will always wait 5 seconds, even if the connection finishes more quickly. Here is a similar approach where the timeout and network request <em>both</em> happen on separate threads, and the first one finished wins:</p>\n\n<pre><code>let (sender, receiver) = mpsc::channel();\nlet tsender = sender.clone();\nlet t = thread::spawn(move || {\n    match sender.send(Ok(net::TcpStream::connect((host.as_str(), port)))) {\n        Ok(()) =&gt; {}, // everything good\n        Err(_) =&gt; {}, // we have been released, don't panic\n    }\n});\nlet timer = thread::spawn(move || {\n  thread::sleep(Duration::from_millis(5000));\n  match tsender.send(Err(MyTimeoutError)) {\n    Ok(()) =&gt; {}, // oops, we timed out\n    Err(_) =&gt; {}, // great, the request finished already\n  }\n});\nreturn receiver.recv().unwrap();\n</code></pre>\n\n<p>But as long as you're doing that, you might as well just use <a href=\"https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv_timeout\" rel=\"noreferrer\"><code>recv_timeout</code></a> instead:</p>\n\n<pre><code>let (sender, receiver) = mpsc::channel();\nlet t = thread::spawn(move || {\n    match sender.send(net::TcpStream::connect((host.as_str(), port))) {\n        Ok(()) =&gt; {}, // everything good\n        Err(_) =&gt; {}, // we have been released, don't panic\n    }\n});\nreturn receiver.recv_timeout(Duration::from_millis(5000));\n</code></pre>\n"}], "owner": {"reputation": 1261, "user_id": 1526733, "user_type": "registered", "accept_rate": 96, "profile_image": "https://www.gravatar.com/avatar/b3478b696e8b26f4562569fb35fe4844?s=128&d=identicon&r=PG", "display_name": "Ba7a7chy", "link": "https://stackoverflow.com/users/1526733/ba7a7chy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 7226, "favorite_count": 4, "accepted_answer_id": 42720480, "answer_count": 2, "score": 15, "last_activity_date": 1607095107, "creation_date": 1458745411, "last_edit_date": 1607095107, "question_id": 36181719, "link": "https://stackoverflow.com/questions/36181719/what-is-the-correct-way-in-rust-to-create-a-timeout-for-a-thread-or-a-function", "title": "What is the correct way in Rust to create a timeout for a thread or a function?", "body": "<p>This is my code:</p>\n<pre><code>use std::net;\nuse std::thread;\n\nfn scan_port(host: &amp;str, port: u16) -&gt; bool {\n    let host = host.to_string();\n    let port = port;\n    let t = thread::spawn(move || net::TcpStream::connect((host.as_str(), port)).is_ok());\n\n    t.join().unwrap()\n}\n</code></pre>\n<p>How do I create a situation where the thread will be terminated or killed if the connection didn't finish in N seconds?</p>\n<p>The reason for all of this is that Rust has no way to set a socket connection timeout so I have no way to ensure the program won't get stuck.</p>\n"}, {"tags": ["macros", "rust"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1458733368, "post_id": 36176584, "comment_id": 59989601, "body": "your macro doesn&#39;t work in the regular case: <a href=\"https://play.rust-lang.org/?gist=6ce29f2366951025ad4b&amp;version=stable\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a> . It complains with &quot;expected one of <code>.</code>, <code>]</code>, or an operator, found <code>,</code>&quot;"}], "answers": [{"comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1458734353, "post_id": 36177280, "comment_id": 59990240, "body": "Aside from that, the problem is that the outer invocation matches as <code>:expr</code>, which prevents the &quot;special case&quot; rules from <i>ever</i> matching.  This can&#39;t be done except by incremental parsing."}, {"owner": {"reputation": 7040, "user_id": 254704, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/68cf83e8ac5c4a10aa9a45f24cac12f8?s=128&d=identicon&r=PG", "display_name": "porgarmingduod", "link": "https://stackoverflow.com/users/254704/porgarmingduod"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1458737015, "post_id": 36177280, "comment_id": 59992106, "body": "What confuses me is that, in the case of <code>mactest(1)</code>, I don&#39;t see how any of the first three rules matches <code>1</code>. Those are the special cases, which is why they are at the top. <code>1</code> is not an <code>ident</code> nor a <code>path</code>. To narrow it down, <a href=\"https://play.rust-lang.org/?gist=dc58b6e911d75f546cb3&amp;version=stable\" rel=\"nofollow noreferrer\">this</a> error message really confuses me. @DK. What does incremental parsing mean in this context?"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 7040, "user_id": 254704, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/68cf83e8ac5c4a10aa9a45f24cac12f8?s=128&d=identicon&r=PG", "display_name": "porgarmingduod", "link": "https://stackoverflow.com/users/254704/porgarmingduod"}, "edited": false, "score": 1, "creation_date": 1458748746, "post_id": 36177280, "comment_id": 60001299, "body": "@porgarmingduod Bed time for me, but this (among other things) is explained in <a href=\"https://danielkeep.github.io/tlborm/\" rel=\"nofollow noreferrer\">TLBoRM</a>.  Short version: the <code>macro_rules!</code> parser is <i>really</i> dumb, and the fact that <code>1</code> isn&#39;t an ident <i>is</i> the problem.  That specific formulation is <i>impossible</i> to get working; see section 2.3.1."}, {"owner": {"reputation": 7040, "user_id": 254704, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/68cf83e8ac5c4a10aa9a45f24cac12f8?s=128&d=identicon&r=PG", "display_name": "porgarmingduod", "link": "https://stackoverflow.com/users/254704/porgarmingduod"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1458807979, "post_id": 36177280, "comment_id": 60025379, "body": "@DK. Thanks, that is just the kind of resource I needed to shore up my shortcomings about rust macros. Can&#39;t believe it never showed up when I was googling various macro stuff."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 0, "last_activity_date": 1458733453, "creation_date": 1458733453, "answer_id": 36177280, "question_id": 36176584, "link": "https://stackoverflow.com/questions/36176584/macro-matching-a-single-expr-after-expr-pathtt-and-identtt-branches/36177280#36177280", "title": "Macro matching a single expr after [expr*], path[tt*] and ident[tt*] branches", "body": "<p>macro rules are tried by starting with the first one and going down from there. So if you want to prevent your other rules from triggering in special cases, you need to put the special case rule first.</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=483ac8eef58586c782dc&amp;version=stable\" rel=\"nofollow\">Try it out in the playground</a></p>\n"}], "owner": {"reputation": 7040, "user_id": 254704, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/68cf83e8ac5c4a10aa9a45f24cac12f8?s=128&d=identicon&r=PG", "display_name": "porgarmingduod", "link": "https://stackoverflow.com/users/254704/porgarmingduod"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 525, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1458733453, "creation_date": 1458731534, "last_edit_date": 1458733124, "question_id": 36176584, "link": "https://stackoverflow.com/questions/36176584/macro-matching-a-single-expr-after-expr-pathtt-and-identtt-branches", "title": "Macro matching a single expr after [expr*], path[tt*] and ident[tt*] branches", "body": "<p>I'm trying to make a macro that I can call in the following manner:</p>\n\n<pre><code>mactest!(some::Path[1, 2, AnotherName[3, 4]])\n</code></pre>\n\n<p>Which would be equivalent to the following:</p>\n\n<pre><code>make_result(\n    \"some::Path\", \n    1.convert(), \n    2.convert(), \n    make_result(\n        \"AnotherName\", \n        3.convert(), \n        4.convert()\n    )\n)\n</code></pre>\n\n<p>where <code>convert</code> is some trait that will be implemented for a bunch of types. (<code>convert</code> and <code>make_result</code> has the same result type).</p>\n\n<p>This is as far as I've come:</p>\n\n<pre><code>// Note: u32 is used as an example result type. \n// The real code attempts to create a more complicated object.\n\ntrait Foo {\n    fn convert(&amp;self) -&gt; u32;\n}\n\nfn make_result(name: &amp;str, data: Vec&lt;u32&gt;) -&gt; u32 {\n    // This example ignores name and makes a meaningless result\n    data.iter().fold(0,|a, &amp;b| a + b)\n}\n\n\n#[macro_export]\nmacro_rules! mactest {\n    ( [ $($inner:expr),* ] ) =&gt; {{\n        let mut result = Vec::new();\n        $(\n            // Process each element.\n            result.push(mactest!($inner));\n        )*\n        result\n    }};\n    ($name:path [ $($inner:tt),* ] ) =&gt; {\n        make_result(stringify!($name), mactest!([$($inner),*]))\n    };\n    ($name:ident [ $($inner:tt),* ] ) =&gt; {\n        make_result(stringify!($name), mactest!([$($inner),*]))\n    };\n    // Process single value. This is never matched?\n    ($x:expr) =&gt; {\n        $x.convert()\n    };\n}\n</code></pre>\n\n<p>The first matching branch of the macro is supposed to match each element of a list to either the <code>path/ident[items]</code> or the single item <code>.convert</code> branch at the end. But the final branch is never reached, with rust complaining <code>error: expected ident, found '1'</code> when single items enter the macro, i.e. <code>mactest!(1)</code>.</p>\n\n<p>My reasoning as a beginner rust user is that the macro has four patterns: <code>[expr*]</code>, <code>path[tt*]</code>, <code>ident[tt*]</code> and <code>expr</code>. When I pass something like 1 into the macro, I don't see why any of the above patterns should match/interfere.</p>\n\n<p>Can someone explain why this doesn't work? Is there a workaround to get the intended result?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "edited": false, "score": 1, "creation_date": 1458707736, "post_id": 36169793, "comment_id": 59976692, "body": "Hmm, well that&#39;s a problem. I have to use <code>Arc&lt;[T]&gt;</code> as the input, because it is coming from an <code>Iterator&lt;Item=Arc&lt;[T]&gt;&gt;</code>. I can&#39;t really change this to  <code>Iterator&lt;Item=&amp;Arc&lt;[T]&gt;&gt;</code> because the source is creating the values by cloning subslices from an immutable backing vector, and letting them go, relying on the <code>Arc</code> to clean up the backing vector when it runs out of references. Using <code>&amp;Arc&lt;[T]&gt;</code> this way seems to just push the issue down the road."}, {"owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "edited": false, "score": 0, "creation_date": 1458712703, "post_id": 36169793, "comment_id": 59978205, "body": "I added some code for the source iterator. How would you modify it to produce <code>&amp;Arc&lt;[T]&gt;</code> data?"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 2, "last_activity_date": 1458706745, "creation_date": 1458706745, "answer_id": 36169793, "question_id": 36169652, "link": "https://stackoverflow.com/questions/36169652/returning-a-borrow-from-an-owned-resource/36169793#36169793", "title": "Returning a borrow from an owned resource", "body": "<p>There's no way to make this work by passing an <code>Arc&lt;[T]&gt;</code> by value. You need to start from a reference to an <code>Arc&lt;[T]&gt;</code> in order to construct a valid <code>slice::Iter</code>.</p>\n\n<pre><code>fn my_iter&lt;'a, T&gt;(n: &amp;'a Arc&lt;[T]&gt;) -&gt; slice::Iter&lt;'a, T&gt; {\n    n.into_iter()\n}\n</code></pre>\n\n<p>Or, if we elide the lifetimes:</p>\n\n<pre><code>fn my_iter&lt;T&gt;(n: &amp;Arc&lt;[T]&gt;) -&gt; slice::Iter&lt;T&gt; {\n    n.into_iter()\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "edited": false, "score": 0, "creation_date": 1458724396, "post_id": 36172539, "comment_id": 59983684, "body": "Thanks for this enlightening writeup, which helped me fix the issue. I realized I was very much overusing <code>Arc</code> in this case; iterators should not use <code>Arc</code> because they do not take ownership of the data - the client already owns the <code>data</code> field, and the iterators should just borrow from that. (My data structure is a kind of binary tree with shared children, so I think <code>Arc</code> is still appropriate for the child links in the data structure, but iterators over it should not take control of the data.)"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "edited": false, "score": 0, "creation_date": 1458727448, "post_id": 36172539, "comment_id": 59985645, "body": "@MarioCarneiro, yep, your summary is correct. Iterators take ownership of the data they yield afterwards only when the original structure is consumed, like with <code>Vec::into_iter()</code>, otherwise references are more appropriate."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 5, "last_activity_date": 1458720333, "last_edit_date": 1458720333, "creation_date": 1458719790, "answer_id": 36172539, "question_id": 36169652, "link": "https://stackoverflow.com/questions/36169652/returning-a-borrow-from-an-owned-resource/36172539#36172539", "title": "Returning a borrow from an owned resource", "body": "<p>You cannot do this. Remember, lifetimes in Rust are purely compile-time entities and are only used to validate that your code doesn't accidentally access dropped data. For example:</p>\n\n<pre><code>fn my_iter&lt;'a, T&gt;(n: Arc&lt;[T]&gt;) -&gt; slice::Iter&lt;'a, T&gt;\n</code></pre>\n\n<p>Here <code>'a</code> does not \"last until the client drops the returned iterator\"; this reasoning is incorrect. From the point of view of <code>slice::Iter</code> its lifetime parameter means the lifetime <em>of the slice it is pointing at</em>; from the point of view of <code>my_iter</code> <code>'a</code> is just a lifetime parameter which can be chosen <em>arbitrarily</em> by the caller. In other words, <code>slice::Iter</code> is always tied to some slice with some <em>concrete</em> lifetime, but the signature of <code>my_iter</code> states that it is able to return <em>arbitrary</em> lifetime. Do you see the contradiction?</p>\n\n<p>As a side note, due to covariance of lifetimes you can return a slice of a <em>static</em> slice from such a function:</p>\n\n<pre><code>static DATA: &amp;'static [u8] = &amp;[1, 2, 3];\n\nfn get_data&lt;'a&gt;() -&gt; &amp;'a [u8] {\n    DATA\n}\n</code></pre>\n\n<p>The above definition compiles, but it only works because <code>DATA</code> is stored in static memory of your program and is <em>always</em> valid when your program is running; this is not so with <code>Arc&lt;[T]&gt;</code>.</p>\n\n<p><code>Arc&lt;[T]&gt;</code> implies <em>shared ownership</em>, that is, the data inside <code>Arc&lt;[T]&gt;</code> is jointly owned by all clones of the original <code>Arc&lt;[T]&gt;</code> value. Therefore, when the last clone of an <code>Arc</code> goes out of scope, the value it contains is dropped, and the respective memory is freed. Now, consider what would happen if <code>my_iter()</code> was allowed to compile:</p>\n\n<pre><code>let iter = {\n    let data: Arc&lt;[i32]&gt; = get_arc_slice();\n    my_iter(data.clone())\n};\niter.map(|x| x+1).collect::&lt;Vec&lt;_&gt;&gt;();\n</code></pre>\n\n<p>Because in <code>my_iter()</code> <code>'a</code> can be arbitrary and is not linked in any way to <code>Arc&lt;[T]&gt;</code> (and can not be, actually), nothing prevents this code from compilation - the user might as well choose <code>'static</code> lifetime. However, here all clones of <code>data</code> will be dropped inside the block, and the array it contains inside will be freed. Using <code>iter</code> after the block is unsafe because it now provides access to the freed memory.</p>\n\n<blockquote>\n  <p>How do I clone the Arc in such a way that the client takes ownership of the clone, so that the value is only dropped after the client is done with the iterator (assuming no one else is using the Arc)?</p>\n</blockquote>\n\n<p>So, as follows from the above, this is impossible. Only the <em>owner</em> of the data determines when this data should be destroyed, and borrowed references (whose existence is always implied by lifetime parameters) may only borrow the data for the time when it exists, but borrows <em>cannot</em> affect when and how the data is destroyed. In order for borrowed references to compile, they need to always borrow only the data which is valid through the whole time these references are active.</p>\n\n<p>What you can do is to rethink your architecture. It is hard to say what exactly can be done without looking at the full code, but in the case of this particular example you can, for example, first collect the iterator into a vector and then iterate over the vector:</p>\n\n<pre><code>let items: Vec&lt;_&gt; = your_iter.collect();\nitems.iter().flat_map(my_iter)\n</code></pre>\n\n<p>Note that now <code>my_iter()</code> should indeed accept <code>&amp;Arc&lt;[T]&gt;</code>, just as Francis Gagn\u00e9 has suggested; this way, the lifetimes of the output iterator will be tied to the lifetime of the input reference, and everything should work fine, because now it is guaranteed that <code>Arc</code>s are stored stably in the vector for their later perusal during the iteration.</p>\n"}, {"tags": [], "owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "is_accepted": false, "score": 1, "last_activity_date": 1458797364, "last_edit_date": 1458797364, "creation_date": 1458763924, "answer_id": 36187829, "question_id": 36169652, "link": "https://stackoverflow.com/questions/36169652/returning-a-borrow-from-an-owned-resource/36187829#36187829", "title": "Returning a borrow from an owned resource", "body": "<p>You need to use another iterator as return type of the function <code>my_iter</code>. <code>slice::Iter&lt;'a, T&gt;</code> has an associated type <code>Item = &amp;'a T</code>. You need an iterator with associated type <code>Item = T</code>. Something like <code>vec::IntoIter&lt;T&gt;</code>. You can implement such an iterator yourself:</p>\n\n<pre><code>use std::sync::Arc;\n\nstruct BaseIter&lt;T&gt;(Arc&lt;[T]&gt;);\n\nimpl&lt;T&gt; Iterator for BaseIter&lt;T&gt; {\n    type Item = Arc&lt;[T]&gt;;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        Some(self.0.clone())\n    }\n}\n\nstruct ArcIntoIter&lt;T&gt;(usize, Arc&lt;[T]&gt;);\n\nimpl&lt;T:Clone&gt; Iterator for ArcIntoIter&lt;T&gt; {\n    type Item = T;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        if self.0 &lt; self.1.len(){\n            let i = self.0;\n            self.0+=1;\n            Some(self.1[i].clone())\n        }else{\n            None\n        }    \n    }\n}\n\nfn my_iter&lt;T&gt;(n: Arc&lt;[T]&gt;) -&gt; ArcIntoIter&lt;T&gt; {\n    ArcIntoIter(0, n)\n}\n\nfn main() {\n    let data = Arc::new([\"A\",\"B\",\"C\"]);\n    println!(\"{:?}\", BaseIter(data).take(3).flat_map(my_iter).collect::&lt;String&gt;());\n    //output:\"ABCABCABC\"\n}\n</code></pre>\n"}], "owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1297, "favorite_count": 0, "accepted_answer_id": 36172539, "answer_count": 3, "score": 3, "last_activity_date": 1458797364, "creation_date": 1458705937, "last_edit_date": 1458712597, "question_id": 36169652, "link": "https://stackoverflow.com/questions/36169652/returning-a-borrow-from-an-owned-resource", "title": "Returning a borrow from an owned resource", "body": "<p>I am trying to write a function that maps an <code>Arc&lt;[T]&gt;</code> into an <code>Iterable</code>, for use with <code>flat_map</code> (that is, I want to call <code>i.flat_map(my_iter)</code> for some other <code>i: Iterator&lt;Item=Arc&lt;[T]&gt;&gt;</code>).</p>\n\n<pre><code>fn my_iter&lt;'a, T&gt;(n: Arc&lt;[T]&gt;) -&gt; slice::Iter&lt;'a, T&gt; {\n    let t: &amp;'a [T] = &amp;*n.clone();\n    t.into_iter()\n}\n</code></pre>\n\n<p>The function above does not work because <code>n.clone()</code> produces an owned value of type <code>Arc&lt;[T]&gt;</code>, which I can dereference to <code>[T]</code> and then borrow to get <code>&amp;[T]</code>, but the lifetime of the borrow only lasts until the end of the function, while the <code>'a</code> lifetime lasts until the client drops the returned iterator.</p>\n\n<p>How do I clone the <code>Arc</code> in such a way that the client takes ownership of the clone, so that the value is only dropped after the client is done with the iterator (assuming no one else is using the <code>Arc</code>)?</p>\n\n<hr>\n\n<p>Here's some sample code for the source iterator:</p>\n\n<pre><code>struct BaseIter&lt;T&gt;(Arc&lt;[T]&gt;);\n\nimpl&lt;T&gt; Iterator for BaseIter&lt;T&gt; {\n    type Item = Arc&lt;[T]&gt;;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        Some(self.0.clone())\n    }\n}\n</code></pre>\n\n<p>How do I implement the result of <code>BaseIter(data).flat_map(my_iter)</code> (which is of type <code>Iterator&lt;&amp;T&gt;</code>) given that <code>BaseIter</code> is <em>producing</em> data, not just borrowing it? (The real thing is more complicated than this, it's not always the same result, but the ownership semantics are the same.)</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": false, "score": 8, "last_activity_date": 1527259190, "last_edit_date": 1527259190, "creation_date": 1458705485, "answer_id": 36169592, "question_id": 36168500, "link": "https://stackoverflow.com/questions/36168500/struggling-with-closures-and-lifetimes-in-rust/36169592#36169592", "title": "Struggling with closures and lifetimes in Rust", "body": "<blockquote>\n  <p>I seem to have to double bracket things: is that correct?</p>\n</blockquote>\n\n<p>No: the double bracketes are because you've chosen to use tuples and calling a function that takes a tuple requires creating the tuple first, but one can have closures that take multiple arguments, like <code>F: Fn(i32, i32)</code>. That is, one could write that function as:</p>\n\n<pre><code>fn iterNeighbors&lt;F&gt;(i: i32, j: i32, f: F)\nwhere\n    F: Fn(i32, i32),\n{\n    f(i - 1, j);\n    f(i + 1, j);\n    f(i, j - 1);\n    f(i, j + 1);\n}\n</code></pre>\n\n<p>However, it seems that retaining the tuples makes sense for this case.</p>\n\n<blockquote>\n  <p>I think I'm struggling to get the lifetimes of the arguments correct because they are rotated in the recursive call. How should I annotate the lifetimes if I want s2 to be deallocated just before the returns and I want s1 to survive either when returned or into the recursive call?</p>\n</blockquote>\n\n<p>No need for references (and hence no need for lifetimes), just pass the data through directly:</p>\n\n<pre><code>fn nthLoop(n: i32, s1: HashSet&lt;(i32, i32)&gt;, s2: HashSet&lt;(i32, i32)&gt;) -&gt; HashSet&lt;(i32, i32)&gt; {\n    if n == 0 {\n        return s1;\n    } else {\n        let mut s0 = HashSet::new();\n        for &amp;p in &amp;s1 {\n            iterNeighbors(p, |p| {\n                if !(s1.contains(&amp;p) || s2.contains(&amp;p)) {\n                    s0.insert(p);\n                }\n            })\n        }\n        drop(s2); // guarantees timely deallocation\n        return nthLoop(n - 1, s0, s1);\n    }\n}\n</code></pre>\n\n<p>The key here is you can do everything by value, and things passed around by value will of course keep their values around.</p>\n\n<p>However, this fails to compile:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0387]: cannot borrow data mutably in a captured outer variable in an `Fn` closure\n  --&gt; src/main.rs:21:21\n   |\n21 |                     s0.insert(p);\n   |                     ^^\n   |\nhelp: consider changing this closure to take self by mutable reference\n  --&gt; src/main.rs:19:30\n   |\n19 |               iterNeighbors(p, |p| {\n   |  ______________________________^\n20 | |                 if !(s1.contains(&amp;p) || s2.contains(&amp;p)) {\n21 | |                     s0.insert(p);\n22 | |                 }\n23 | |             })\n   | |_____________^\n</code></pre>\n\n<p>That is to say, the closure is trying to mutate values it captures (<code>s0</code>), but the <code>Fn</code> closure trait doesn't allow this. That trait can be called in a more flexible manner (when shared), but this imposes more restrictions on what the closure can do internally. (If you're interested, <a href=\"http://huonw.github.io/blog/2015/05/finding-closure-in-rust/\" rel=\"nofollow noreferrer\">I've written more about this</a>)</p>\n\n<p>Fortunately there's an easy fix: using the <code>FnMut</code> trait, which requires that the closure can only be called when one has unique access to it, but allows the internals to mutate things.</p>\n\n<pre><code>fn iterNeighbors&lt;F&gt;((i, j): (i32, i32), mut f: F)\nwhere\n    F: FnMut((i32, i32)),\n{\n    f((i - 1, j));\n    f((i + 1, j));\n    f((i, j - 1));\n    f((i, j + 1));\n}\n</code></pre>\n\n<blockquote>\n  <p>The caller would look something like this:</p>\n</blockquote>\n\n<p>Values work here too: returning a reference in that case would be returning a pointer to <code>s0</code>, which lives the stack frame that is being destroyed as the function returns. That is, the reference is pointing to dead data. </p>\n\n<p>The fix is just not using references:</p>\n\n<pre><code>fn nth(n: i32, p: (i32, i32)) -&gt; HashSet&lt;(i32, i32)&gt; {\n    let s0 = HashSet::new();\n    let mut s1 = HashSet::new();\n    s1.insert(p);\n    return nthLoop(n, s1, s0);\n}\n</code></pre>\n\n<blockquote>\n  <p>This works if I inline the closure by hand but I cannot figure out how to invoke the closure. Ideally, I'd like static dispatch here.</p>\n</blockquote>\n\n<p>(I don't understand what this means, including the compiler error messages you're having trouble with helps us help you.)</p>\n\n<blockquote>\n  <p>Also, I only used HashSet in the F# because I assume Rust doesn't provide a purely functional Set with efficient set-theoretic operations (union, intersection and difference). Am I correct in assuming that?</p>\n</blockquote>\n\n<p>Depending on exactly what you want, no, e.g. both <code>HashSet</code> and <code>BTreeSet</code> provide various set-theoretic operations as <a href=\"http://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference\" rel=\"nofollow noreferrer\">methods which return iterators</a>.</p>\n\n<hr>\n\n<p>Some small points:</p>\n\n<ul>\n<li>explicit/named lifetimes allow the compiler to reason about the static validity of data, they don't control it (i.e. they allow the compiler to point out when you do something wrong, but language still has the same sort of static resource usage/life-cycle guarantees as C++)</li>\n<li>the version with a loop is likely to be more efficient as written, as it reuses memory directly (swapping the sets, plus the <code>s0.clear()</code>, however, the same benefit can be realised with a recursive version by passing <code>s2</code> down for reuse instead of dropping it.</li>\n<li>the <code>while</code> loop could be <code>for _ in 0..n</code></li>\n<li>there's no need to pass closures by reference, but with or without the reference, there's still static dispatch (the closure is a type parameter, not a trait object).</li>\n<li>conventionally, closure arguments are last, and not taken by reference, because it makes defining &amp; passing them inline easier to read (e.g. <code>foo(x, |y| bar(y + 1))</code> instead of <code>foo(&amp;|y| bar(y + 1), x)</code>)</li>\n<li><p>the <code>return</code> keyword isn't necessary for trailing returns (if the <code>;</code> is omitted):</p>\n\n<pre><code>fn nth(n: i32, p: (i32, i32)) -&gt; HashSet&lt;(i32, i32)&gt; {\n    let s0 = HashSet::new();\n    let mut s1 = HashSet::new();\n    s1.insert(p);\n    nthLoop(n, s1, s0)\n}\n</code></pre></li>\n</ul>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1458736805, "post_id": 36169663, "comment_id": 59991959, "body": "A rare example of using <code>drop</code> that actually makes sense. Exciting! For OP, I&#39;d point out that having <code>return</code> as the last statement in a method / block is non-idiomatic Rust; normally you end with an expression. Additionally rust uses <code>snake_case</code> identifiers, not <code>camelCase</code>"}, {"owner": {"reputation": 46453, "user_id": 13924, "user_type": "registered", "accept_rate": 45, "profile_image": "https://i.stack.imgur.com/rRkqv.jpg?s=128&g=1", "display_name": "J D", "link": "https://stackoverflow.com/users/13924/j-d"}, "edited": false, "score": 0, "creation_date": 1458740154, "post_id": 36169663, "comment_id": 59994423, "body": "&quot;However, HashSet does implement set-theoretic operations. There are two ways to use them: iterators (difference, symmetric_difference, intersection, union), which generate the sequence lazily, or operators (|, &amp;, ^, -, as listed in the trait implementations for HashSet), which produce new sets containing clones of the values from the source sets&quot;. That&#39;s going to be really slow compared to a purely functional <code>Set</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458744828, "post_id": 36169663, "comment_id": 59998199, "body": "<i>A functional set would probably impose using some form of reference counting or garbage collection in order to share items across sets.</i> =&gt; referencing counting should be sufficient for a &quot;functional-like&quot; set, taking advantage of the fact that a new node cannot reference a <i>newer</i> node so you get a DAG."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 46453, "user_id": 13924, "user_type": "registered", "accept_rate": 45, "profile_image": "https://i.stack.imgur.com/rRkqv.jpg?s=128&g=1", "display_name": "J D", "link": "https://stackoverflow.com/users/13924/j-d"}, "edited": false, "score": 0, "creation_date": 1458775570, "post_id": 36169663, "comment_id": 60016123, "body": "@JonHarrop: <i>That&#39;s going to be really slow compared to a purely functional Set.</i> =&gt; It depends on what&#39;s being cloned. If the data in the set implements <code>Copy</code>, this will be a simple bitwise copy, which is very fast. Otherwise, <code>Clone</code> implementations can be expensive, but wrapping them in <code>Rc</code> can mitigate this, as <code>Rc</code> implements <code>Clone</code> by duplicating a pointer and incrementing a reference count, which is reasonably fast, and probably faster than, say, cloning a <code>Vec</code> or a <code>String</code>, which requires a new heap allocation."}, {"owner": {"reputation": 46453, "user_id": 13924, "user_type": "registered", "accept_rate": 45, "profile_image": "https://i.stack.imgur.com/rRkqv.jpg?s=128&g=1", "display_name": "J D", "link": "https://stackoverflow.com/users/13924/j-d"}, "edited": false, "score": 0, "creation_date": 1458813998, "post_id": 36169663, "comment_id": 60028493, "body": "@FrancisGagn&#233;: Yes but a bitwise copy is just a constant factor faster whereas a purely functional Set is asymptotically faster because doesn&#39;t copy the elements, it just refers back to them. And <code>Rc</code> will be a lot slower than a tracing GC."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 8, "last_activity_date": 1527258518, "last_edit_date": 1527258518, "creation_date": 1458705994, "answer_id": 36169663, "question_id": 36168500, "link": "https://stackoverflow.com/questions/36168500/struggling-with-closures-and-lifetimes-in-rust/36169663#36169663", "title": "Struggling with closures and lifetimes in Rust", "body": "<blockquote>\n  <p>I think that is a function that accepts a closure (that itself accepts a pair and returns unit) and a pair and returns unit. I seem to have to double bracket things: is that correct?</p>\n</blockquote>\n\n<p>You need the double brackets because you're passing a 2-tuple to the closure, which matches your original F# code.</p>\n\n<blockquote>\n  <p>I think I'm struggling to get the lifetimes of the arguments correct because they are rotated in the recursive call. How should I annotate the lifetimes if I want s2 to be deallocated just before the returns and I want s1 to survive either when returned or into the recursive call?</p>\n</blockquote>\n\n<p>The problem is that you're using references to <code>HashSet</code>s when you should just use <code>HashSet</code>s directly. Your signature for <code>nthLoop</code> is already correct; you just need to remove a few occurrences of <code>&amp;</code>.</p>\n\n<p>To deallocate <code>s2</code>, you can write <code>drop(s2)</code>. Note that Rust doesn't have guaranteed tail calls, so each recursive call will still take a bit of stack space (you can see how much with the <a href=\"https://doc.rust-lang.org/std/mem/fn.size_of.html\" rel=\"nofollow noreferrer\"><code>mem::size_of</code></a> function), but the <code>drop</code> call will purge the data on the heap.</p>\n\n<blockquote>\n  <p>The caller would look something like this:</p>\n</blockquote>\n\n<p>Again, you just need to remove the <code>&amp;</code>'s here.</p>\n\n<blockquote>\n  <p>Note that I haven't even bothered with the call to iterNeighbors yet.</p>\n  \n  <hr>\n  \n  <p>This works if I inline the closure by hand but I cannot figure out how to invoke the closure. Ideally, I'd like static dispatch here.</p>\n</blockquote>\n\n<p>There are three types of closures in Rust: <a href=\"https://doc.rust-lang.org/stable/std/ops/trait.Fn.html\" rel=\"nofollow noreferrer\"><code>Fn</code></a>, <a href=\"https://doc.rust-lang.org/stable/std/ops/trait.FnMut.html\" rel=\"nofollow noreferrer\"><code>FnMut</code></a> and <a href=\"https://doc.rust-lang.org/stable/std/ops/trait.FnOnce.html\" rel=\"nofollow noreferrer\"><code>FnOnce</code></a>. They differ by the type of their <code>self</code> argument. The distinction is important because it puts restrictions on what the closure is allowed to do and on how the caller can use the closure. The Rust book has <a href=\"https://doc.rust-lang.org/stable/book/closures.html\" rel=\"nofollow noreferrer\">a chapter on closures</a> that already explains this well.</p>\n\n<p>Your closure needs to mutate <code>s0</code>. However, <code>iterNeighbors</code> is defined as expecting an <code>Fn</code> closure. Your closure cannot implement <code>Fn</code> because <code>Fn</code> receives <code>&amp;self</code>, but to mutate <code>s0</code>, you need <code>&amp;mut self</code>. <code>iterNeighbors</code> cannot use <code>FnOnce</code>, since it needs to call the closure more than once. Therefore, you need to use <code>FnMut</code>.</p>\n\n<p>Also, it's not necessary to pass the closure by reference to <code>iterNeighbors</code>. You can just pass it by value; each call to the closure will only borrow the closure, not consume it.</p>\n\n<blockquote>\n  <p>Also, I only used HashSet in the F# because I assume Rust doesn't provide a purely functional Set with efficient set-theoretic operations (union, intersection and difference). Am I correct in assuming that?</p>\n</blockquote>\n\n<p>There's no purely functional set implementation in the standard library (maybe there's one on <a href=\"https://crates.io/\" rel=\"nofollow noreferrer\">crates.io</a>?). While Rust embraces functional programming, it also takes advantage of its ownership and borrowing system to make imperative programming safer. A functional set would probably impose using some form of reference counting or garbage collection in order to share items across sets.</p>\n\n<p>However, <a href=\"https://doc.rust-lang.org/std/collections/struct.HashSet.html\" rel=\"nofollow noreferrer\"><code>HashSet</code></a> does implement set-theoretic operations. There are two ways to use them: iterators (<a href=\"https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference\" rel=\"nofollow noreferrer\"><code>difference</code></a>, <a href=\"https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.symmetric_difference\" rel=\"nofollow noreferrer\"><code>symmetric_difference</code></a>, <a href=\"https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.intersection\" rel=\"nofollow noreferrer\"><code>intersection</code></a>, <a href=\"https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.union\" rel=\"nofollow noreferrer\"><code>union</code></a>), which generate the sequence lazily, or operators (<code>|</code>, <code>&amp;</code>, <code>^</code>, <code>-</code>, as listed in the <a href=\"https://doc.rust-lang.org/std/collections/struct.HashSet.html#implementations\" rel=\"nofollow noreferrer\">trait implementations for <code>HashSet</code></a>), which produce new sets containing clones of the values from the source sets.</p>\n\n<hr>\n\n<p>Here's the working code:</p>\n\n<pre><code>use std::collections::HashSet;\n\nfn iterNeighbors&lt;F&gt;(mut f: F, (i, j): (i32, i32)) -&gt; ()\nwhere\n    F: FnMut((i32, i32)) -&gt; (),\n{\n    f((i - 1, j));\n    f((i + 1, j));\n    f((i, j - 1));\n    f((i, j + 1));\n}\n\nfn nthLoop(n: i32, s1: HashSet&lt;(i32, i32)&gt;, s2: HashSet&lt;(i32, i32)&gt;) -&gt; HashSet&lt;(i32, i32)&gt; {\n    if n == 0 {\n        return s1;\n    } else {\n        let mut s0 = HashSet::new();\n        for &amp;p in &amp;s1 {\n            let add = |p| {\n                if !(s1.contains(&amp;p) || s2.contains(&amp;p)) {\n                    s0.insert(p);\n                }\n            };\n            iterNeighbors(add, p);\n        }\n        drop(s2);\n        return nthLoop(n - 1, s0, s1);\n    }\n}\n\nfn nth(n: i32, p: (i32, i32)) -&gt; HashSet&lt;(i32, i32)&gt; {\n    let mut s1 = HashSet::new();\n    s1.insert(p);\n    let s2 = HashSet::new();\n    return nthLoop(n, s1, s2);\n}\n\nfn main() {\n    let s = nth(2000, (0, 0));\n    println!(\"{}\", s.len());\n}\n</code></pre>\n"}], "owner": {"reputation": 46453, "user_id": 13924, "user_type": "registered", "accept_rate": 45, "profile_image": "https://i.stack.imgur.com/rRkqv.jpg?s=128&g=1", "display_name": "J D", "link": "https://stackoverflow.com/users/13924/j-d"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1124, "favorite_count": 2, "accepted_answer_id": 36169663, "answer_count": 2, "score": 6, "last_activity_date": 1527259190, "creation_date": 1458698190, "last_edit_date": 1527258323, "question_id": 36168500, "link": "https://stackoverflow.com/questions/36168500/struggling-with-closures-and-lifetimes-in-rust", "title": "Struggling with closures and lifetimes in Rust", "body": "<p>I'm trying to port a little benchmark from F# to Rust. The F# code looks like this:</p>\n\n<pre class=\"lang-ml prettyprint-override\"><code>let inline iterNeighbors f (i, j) =\n  f (i-1, j)\n  f (i+1, j)\n  f (i, j-1)\n  f (i, j+1)\n\nlet rec nthLoop n (s1: HashSet&lt;_&gt;) (s2: HashSet&lt;_&gt;) =\n  match n with\n  | 0 -&gt; s1\n  | n -&gt;\n      let s0 = HashSet(HashIdentity.Structural)\n      let add p =\n        if not(s1.Contains p || s2.Contains p) then\n          ignore(s0.Add p)\n      Seq.iter (fun p -&gt; iterNeighbors add p) s1\n      nthLoop (n-1) s0 s1\n\nlet nth n p =\n  nthLoop n (HashSet([p], HashIdentity.Structural)) (HashSet(HashIdentity.Structural))\n\n(nth 2000 (0, 0)).Count\n</code></pre>\n\n<p>It computes the nth-nearest neighbor shells from an initial vertex in a potentially infinite graph. I used something similar during my PhD to study amorphous materials.</p>\n\n<p>I've spent many hours trying and failing to port this to Rust. I have managed to get one version working but only by manually inlining the closure and converting the recursion into a loop with local mutables (yuk!).</p>\n\n<p>I tried writing the <code>iterNeighbors</code> function like this:</p>\n\n<pre><code>use std::collections::HashSet;\n\nfn iterNeighbors&lt;F&gt;(f: &amp;F, (i, j): (i32, i32)) -&gt; ()\nwhere\n    F: Fn((i32, i32)) -&gt; (),\n{\n    f((i - 1, j));\n    f((i + 1, j));\n    f((i, j - 1));\n    f((i, j + 1));\n}\n</code></pre>\n\n<p>I think that is a function that accepts a closure (that itself accepts a pair and returns unit) and a pair and returns unit. I seem to have to double bracket things: is that correct?</p>\n\n<p>I tried writing a recursive version like this:</p>\n\n<pre><code>fn nthLoop(n: i32, s1: HashSet&lt;(i32, i32)&gt;, s2: HashSet&lt;(i32, i32)&gt;) -&gt; HashSet&lt;(i32, i32)&gt; {\n    if n == 0 {\n        return &amp;s1;\n    } else {\n        let mut s0 = HashSet::new();\n        for &amp;p in s1 {\n            if !(s1.contains(&amp;p) || s2.contains(&amp;p)) {\n                s0.insert(p);\n            }\n        }\n        return &amp;nthLoop(n - 1, s0, s1);\n    }\n}\n</code></pre>\n\n<p>Note that I haven't even bothered with the call to <code>iterNeighbors</code> yet.</p>\n\n<p>I think I'm struggling to get the lifetimes of the arguments correct because they are rotated in the recursive call. How should I annotate the lifetimes if I want <code>s2</code> to be deallocated just before the <code>return</code>s and I want <code>s1</code> to survive either when returned or into the recursive call?</p>\n\n<p>The caller would look something like this:</p>\n\n<pre><code>fn nth&lt;'a&gt;(n: i32, p: (i32, i32)) -&gt; &amp;'a HashSet&lt;(i32, i32)&gt; {\n    let s0 = HashSet::new();\n    let mut s1 = HashSet::new();\n    s1.insert(p);\n    return &amp;nthLoop(n, &amp;s1, s0);\n}\n</code></pre>\n\n<p>I gave up on that and wrote it as a <code>while</code> loop with mutable locals instead:</p>\n\n<pre><code>fn nth&lt;'a&gt;(n: i32, p: (i32, i32)) -&gt; HashSet&lt;(i32, i32)&gt; {\n    let mut n = n;\n    let mut s0 = HashSet::new();\n    let mut s1 = HashSet::new();\n    let mut s2 = HashSet::new();\n    s1.insert(p);\n    while n &gt; 0 {\n        for &amp;p in &amp;s1 {\n            let add = &amp;|p| {\n                if !(s1.contains(&amp;p) || s2.contains(&amp;p)) {\n                    s0.insert(p);\n                }\n            };\n            iterNeighbors(&amp;add, p);\n        }\n        std::mem::swap(&amp;mut s0, &amp;mut s1);\n        std::mem::swap(&amp;mut s0, &amp;mut s2);\n        s0.clear();\n        n -= 1;\n    }\n    return s1;\n}\n</code></pre>\n\n<p>This works if I inline the closure by hand, but I cannot figure out how to invoke the closure. Ideally, I'd like static dispatch here.</p>\n\n<p>The <code>main</code> function is then:</p>\n\n<pre><code>fn main() {\n    let s = nth(2000, (0, 0));\n    println!(\"{}\", s.len());\n}\n</code></pre>\n\n<p>So... what am I doing wrong? :-)</p>\n\n<p>Also, I only used <code>HashSet</code> in the F# because I assume Rust doesn't provide a purely functional <code>Set</code> with efficient set-theoretic operations (union, intersection and difference). Am I correct in assuming that?</p>\n"}, {"tags": ["c", "rust", "ffi"], "comments": [{"owner": {"reputation": 426981, "user_id": 596781, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/a18405dd4b022837867d1f5453a05f41?s=128&d=identicon&r=PG", "display_name": "Kerrek SB", "link": "https://stackoverflow.com/users/596781/kerrek-sb"}, "edited": false, "score": 0, "creation_date": 1458697048, "post_id": 36168281, "comment_id": 59973844, "body": "What&#39;s the question?"}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 0, "creation_date": 1458698269, "post_id": 36168281, "comment_id": 59974142, "body": "I&#39;m also not clear on what the question is, but I have one additional comment: the testStruct should be #[repr(C)]`."}, {"owner": {"reputation": 81, "user_id": 1440612, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/F3fAm.jpg?s=128&g=1", "display_name": "CallumStyan", "link": "https://stackoverflow.com/users/1440612/callumstyan"}, "edited": false, "score": 0, "creation_date": 1458698731, "post_id": 36168281, "comment_id": 59974280, "body": "Added a line to clarify what my actual question is, but any prod in the right direction regarding pointers and FFI in Rust is appreciated."}], "answers": [{"comments": [{"owner": {"reputation": 30697, "user_id": 31667, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/082b069c287878a1bd5731f44c8f10e7?s=128&d=identicon&r=PG", "display_name": "viraptor", "link": "https://stackoverflow.com/users/31667/viraptor"}, "edited": false, "score": 0, "creation_date": 1458705377, "post_id": 36169235, "comment_id": 59975995, "body": "I found the <code>Box&lt;T&gt;</code> comment interesting. What do you mean by accidental freeing when compared to local variable? Isn&#39;t it also possible in the same way if you use the <code>TestStruct&lt;&#39;a&gt;</code> from your second example, and do <code>fn foo() { let mut ts = TestStruct {...}; start_test(&amp;mut ts); }</code> ? If  <code>a_string</code> is generated in <code>foo</code> (for example ref&#39;d local string) and <code>start_test</code> saves the pointer for later, rust will also free it, right?"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 30697, "user_id": 31667, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/082b069c287878a1bd5731f44c8f10e7?s=128&d=identicon&r=PG", "display_name": "viraptor", "link": "https://stackoverflow.com/users/31667/viraptor"}, "edited": false, "score": 0, "creation_date": 1458706442, "post_id": 36169235, "comment_id": 59976336, "body": "You&#39;re right, the same issue could occur with a local variable and a borrowed pointer in the struct. This will catch lifetime errors in the Rust code, but not in the C code. There&#39;s a reason why calling <code>extern</code> functions is unsafe, after all. :)"}, {"owner": {"reputation": 30697, "user_id": 31667, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/082b069c287878a1bd5731f44c8f10e7?s=128&d=identicon&r=PG", "display_name": "viraptor", "link": "https://stackoverflow.com/users/31667/viraptor"}, "edited": false, "score": 0, "creation_date": 1458710701, "post_id": 36169235, "comment_id": 59977530, "body": "Thanks, I thought there&#39;s some specific issue on top of that in case of Boxes :)"}, {"owner": {"reputation": 81, "user_id": 1440612, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/F3fAm.jpg?s=128&g=1", "display_name": "CallumStyan", "link": "https://stackoverflow.com/users/1440612/callumstyan"}, "edited": false, "score": 0, "creation_date": 1458754034, "post_id": 36169235, "comment_id": 60004988, "body": "@FrancisGagn&#233; Thank you for the detailed explanation in your answer, I&#39;ll play around with this today and mark it as accepted!"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 6, "last_activity_date": 1458703423, "creation_date": 1458703423, "answer_id": 36169235, "question_id": 36168281, "link": "https://stackoverflow.com/questions/36168281/what-is-the-correct-way-to-declare-a-structure-or-just-a-variable-in-rust-that/36169235#36169235", "title": "What is the correct way to declare a structure, or just a variable, in Rust that can be passed to C code expecting a pointer?", "body": "\n\n<blockquote>\n  <p>What is the correct way to declare a structure, or just a variable, in Rust that can be passed to C code expecting a pointer?</p>\n</blockquote>\n\n<p>The memory layout of a struct is undefined (the compiler is allowed to reorder fields, for instance) unless you add the <code>#[repr(C)]</code> attribute to the struct. This attribute gives the struct a layout compatible with C.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>#[repr(C)]\nstruct TestStruct {\n    an_int: libc::c_int,\n    a_string: *mut libc::c_char\n}\n</code></pre>\n\n<p>Using a raw pointer in the struct works fine, but we can do better. There are two other important types in Rust that are only composed of a pointer: borrowed pointers (<code>&amp;'a T</code> or <code>&amp;'a mut T</code>) and <code>Box&lt;T&gt;</code>. You can use these types instead <code>*const T</code> or <code>*mut T</code> to make it clear that the pointer borrows an existing value (and enables the compiler to validate that the pointer doesn't outlive its referent) or points to an object on the heap that should be dropped when the pointer (or the struct containing it) goes out of scope. However, be careful with <code>Box&lt;T&gt;</code>, since you could accidentally free a value while the C code still has a pointer to the value.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>#[repr(C)]\nstruct TestStruct&lt;'a&gt; {\n    an_int: libc::c_int,\n    a_string: &amp;'a mut libc::c_char\n}\n</code></pre>\n\n<p>Another thing to watch out for is the use of fat pointers. In Rust, some pointer types are <em>fat</em>, i.e. they carry additional data along with the pointer. For example, slices (<code>*const [T]</code>, <code>*mut [T]</code>, <code>&amp;'a [T]</code>, <code>&amp;'a mut [T]</code>) can be thought of as a struct or tuple containing a pointer to the first item and the number of items in the slice (a <code>usize</code>); trait objects (<code>*const T</code>, <code>*mut T</code>, <code>&amp;'a T</code>, <code>&amp;'a mut T</code> where <code>T</code> is the name of a trait) are composed of a pointer to the object and a pointer to the virtual method table for the trait implementation. You should avoid using these types when defining a Rust struct matching a C struct.</p>\n\n<p>You can find more information on using Rust's FFI in <a href=\"http://doc.rust-lang.org/stable/book/ffi.html\">the FFI section of the Rust book</a>.</p>\n"}], "owner": {"reputation": 81, "user_id": 1440612, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/F3fAm.jpg?s=128&g=1", "display_name": "CallumStyan", "link": "https://stackoverflow.com/users/1440612/callumstyan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 496, "favorite_count": 0, "accepted_answer_id": 36169235, "answer_count": 1, "score": 0, "last_activity_date": 1458737006, "creation_date": 1458696644, "last_edit_date": 1458737006, "question_id": 36168281, "link": "https://stackoverflow.com/questions/36168281/what-is-the-correct-way-to-declare-a-structure-or-just-a-variable-in-rust-that", "title": "What is the correct way to declare a structure, or just a variable, in Rust that can be passed to C code expecting a pointer?", "body": "<p>I'm having a hard time wrapping my head around declaring mutable (or pointer) variables and interacting with C code through FFI. I've been playing with this for most of the day and have found conflicting examples due to how quickly Rust is developing. :)</p>\n\n<p>The situation is like this: I have a C function which takes in a pointer to a <code>struct</code>, this struct has fields that are <code>int</code>s and <code>char *</code>s.  My understanding is that I need to declare a similar struct in Rust to pass to the <code>extern C</code> function.</p>\n\n<hr>\n\n<p>Here are my example files I've written while trying to figure this out:</p>\n\n<pre><code>main.rs\nextern crate libc;\n\nstruct testStruct {\n  an_int: libc::c_int,\n  a_string: *mut libc::c_char\n}\n\nextern {\n  fn start_test(test: *mut testStruct) -&gt; libc::c_int;\n}\n\nfn main() {\n  // println!(\"Hello, world!\");\n  let test_struct = testStruct { an_int: 1, a_string: \"hello\" };\n  start_test(&amp;mut test_struct);\n}\n</code></pre>\n\n<p>--</p>\n\n<pre><code>test_file.c\n#include &lt;stdio.h&gt;\n#include \"test_file.h\"\n\nstruct test_struct {\n    int an_int;\n    char *a_string;\n};\n\nint start_client(struct test_struct *test) {\n    printf(\"Test function!\\n\");\n    return 0;\n}\n</code></pre>\n\n<p>Obviously the actual code is more complex, I'm just trying to get a basic example working to understand how mutability/pointers work in Rust with FFI.</p>\n"}, {"tags": ["data-structures", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1458690602, "post_id": 36167160, "comment_id": 59971937, "body": "What is your question?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1458743115, "post_id": 36167160, "comment_id": 59996771, "body": "The ownership is not expressed through types in your current example, did you meant to write <code>std::vector&lt;std::unique_ptr&lt;Node&gt;&gt; children;</code>? Also, why is the destructor <code>virtual</code>? Is this supposed to be an interface?"}, {"owner": {"reputation": 596, "user_id": 789371, "user_type": "registered", "accept_rate": 0, "profile_image": "https://www.gravatar.com/avatar/a6a8d60cf810d14224154d35a1854aaf?s=128&d=identicon&r=PG", "display_name": "nulleight", "link": "https://stackoverflow.com/users/789371/nulleight"}, "edited": false, "score": 2, "creation_date": 1458772986, "post_id": 36167160, "comment_id": 60015192, "body": "The node owns its children and is owned by the parent. I didn&#39;t want to use more templates than nesessary."}], "answers": [{"comments": [{"owner": {"reputation": 5518, "user_id": 2648679, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/6zeEM.jpg?s=128&g=1", "display_name": "Abhinav Gauniyal", "link": "https://stackoverflow.com/users/2648679/abhinav-gauniyal"}, "edited": false, "score": 0, "creation_date": 1516467923, "post_id": 36168774, "comment_id": 83704314, "body": "while I agree that the example provided by OP is <i>unsafe</i> but note that <code>parent</code> pointer is not unsafe by itself since it&#39;s not the owner of the parent memory region. The problem is with <code>vector&lt;Node*&gt;</code> which should&#39;ve been <code>unique_ptr</code> or <code>shared_ptr</code> atleast."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 21, "last_activity_date": 1458700263, "creation_date": 1458700263, "answer_id": 36168774, "question_id": 36167160, "link": "https://stackoverflow.com/questions/36167160/how-do-i-express-mutually-recursive-data-structures-in-safe-rust/36168774#36168774", "title": "How do I express mutually recursive data structures in safe Rust?", "body": "<p>The problem is that this data structure is inherently unsafe; it doesn't <em>have</em> a direct equivalent in Rust that doesn't use <code>unsafe</code>.  This is by design.</p>\n\n<p>If you want to translate this into safe Rust code, you need to be more specific about what, exactly, you want from it.  I know you listed some properties above, but often people coming to Rust will say \"I want everything I have in this C/C++ code\", to which the direct answer is \"well, you <em>can't</em>.\"</p>\n\n<p>You're also, <em>unavoidably</em>, going to have to change how you approach this.  The example you've given has pointers without any ownership semantics, mutable aliasing, and cycles; all of which Rust will not allow you to simply ignore like C++ does.</p>\n\n<p>The simplest solution is to just get rid of the <code>parent</code> pointer, and maintain that externally (like a filesystem path).  This also plays nicely with borrowing because there are no cycles anywhere:</p>\n\n<pre><code>pub struct Node1 {\n    children: Vec&lt;Node1&gt;,\n}\n</code></pre>\n\n<p>If you <em>need</em> parent pointers, you could go half-way and use Ids instead:</p>\n\n<pre><code>use std::collections::BTreeMap;\n\ntype Id = usize;\n\npub struct Tree {\n    descendants: BTreeMap&lt;Id, Node2&gt;,\n    root: Option&lt;Id&gt;,\n}\n\npub struct Node2 {\n    parent: Id,\n    children: Vec&lt;Id&gt;,\n}\n</code></pre>\n\n<p>The <code>BTreeMap</code> is effectively your \"address space\", bypassing borrowing and aliasing issues by <em>not</em> directly using memory addresses.</p>\n\n<p>Of course, this introduces the problem of a given <code>Id</code> not being tied to the particular tree, meaning that the node it belongs to could be destroyed, and now you have what is <em>effectively</em> a dangling pointer.  But, that's the price you pay for having aliasing and mutation.  It's also less direct.</p>\n\n<p>Or, you could go whole-hog and use reference-counting and dynamic borrow checking:</p>\n\n<pre><code>use std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n// Note: do not derive Clone to make this move-only.\npub struct Node3(Rc&lt;RefCell&lt;Node3_&gt;&gt;);\n\npub type WeakNode3 = Weak&lt;RefCell&lt;Node3&gt;&gt;;\n\npub struct Node3_ {\n    parent: Option&lt;WeakNode3&gt;,\n    children: Vec&lt;Node3&gt;,\n}\n\nimpl Node3 {\n    pub fn add(&amp;self, node: Node3) {\n        // No need to remove from old parent; move semantics mean that must have\n        // already been done.\n        (node.0).borrow_mut().parent = Some(Rc::downgrade(&amp;self.0));\n        self.children.push(node);\n    }\n}\n</code></pre>\n\n<p>Here, you'd use <code>Node3</code> to transfer ownership of a node between parts of the tree, and <code>WeakNode3</code> for external references.  Or, you could make <code>Node3</code> cloneable and add back the logic in <code>add</code> to make sure a given node doesn't accidentally stay a child of the wrong parent.</p>\n\n<p>This is not strictly better than the second option, because <em>this</em> design absolutely <em>cannot</em> benefit from static borrow-checking.  The second one can <em>at least</em> prevent you from mutating the graph from two places at once at compile time; here, if that happens, you'll just crash.</p>\n\n<p>The point is: you can't just have <em>everything</em>.  You have to decide which operations you <em>actually</em> need to support.  At that point, it's usually just a case of picking the types that give you the necessary properties.</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458742638, "post_id": 36168919, "comment_id": 59996385, "body": "+1! I had seen zippers before in the context of immutable data structures and never even thought about using them in the context of <i>mutable</i> ones!"}, {"owner": {"reputation": 1155, "user_id": 6449910, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/OvekE.jpg?s=128&g=1", "display_name": "SeSodesa", "link": "https://stackoverflow.com/users/6449910/sesodesa"}, "edited": false, "score": 0, "creation_date": 1591707036, "post_id": 36168919, "comment_id": 110152537, "body": "Wouldn&#39;t storing both the children and the parent as <code>Rc</code> cause a cyclic reference count? Isn&#39;t a <code>Weak</code> pointer better suited to storing a reference to the parent in a child to prevent this?"}, {"owner": {"reputation": 1155, "user_id": 6449910, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/OvekE.jpg?s=128&g=1", "display_name": "SeSodesa", "link": "https://stackoverflow.com/users/6449910/sesodesa"}, "edited": false, "score": 0, "creation_date": 1591775354, "post_id": 36168919, "comment_id": 110180501, "body": "Also, just to clarify as I&#39;m interested in trying out the zipper technique, the tree would consist of these zipper-wrappers instead of the nodes themselves? And if the parent zipper is optional, then shouldn&#39;t the <code>id_in_parent</code> be optional as well?"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1591799527, "post_id": 36168919, "comment_id": 110194488, "body": "The zipper owns the nodes, so in a way, the zipper <i>is</i> the tree. Indeed, when the parent is <code>None</code>, the <code>index_in_parent</code> is irrelevant. It would make sense to bundle the parent and the index together in a single <code>Option</code> (either you have neither, or you have both)."}, {"owner": {"reputation": 1155, "user_id": 6449910, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/OvekE.jpg?s=128&g=1", "display_name": "SeSodesa", "link": "https://stackoverflow.com/users/6449910/sesodesa"}, "edited": false, "score": 0, "creation_date": 1592595155, "post_id": 36168919, "comment_id": 110492083, "body": "@FrancisGagn&#233; Right, so if I wanted to create a structure <code>TreeWithMetadata</code>that contained the tree as one field and information about the tree in other fields, it would look something like <code>TreeWithMetadata{ tree: TreeZipper&lt;T&gt;, .. }</code> and not <code>TreeWithMetadata{ tree: Node&lt;T&gt;, .. }</code>. So the structure that owns the tree would actually own the <code>TreeZipper</code> representing the tree. The <code>child</code> and <code>parent</code> methods would then shift focus to either the parent of the current node or one of the children. These could be used to traverse the tree."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 38, "last_activity_date": 1591707516, "last_edit_date": 1591707516, "creation_date": 1458701225, "answer_id": 36168919, "question_id": 36167160, "link": "https://stackoverflow.com/questions/36167160/how-do-i-express-mutually-recursive-data-structures-in-safe-rust/36168919#36168919", "title": "How do I express mutually recursive data structures in safe Rust?", "body": "<p>Rust tries to ensure memory safety by forbidding you from doing things that might potentially be unsafe. Since this analysis is performed at compile-time, the compiler can only reason about a subset of manipulations that are known to be safe.</p>\n\n<p>In Rust, you could easily store <em>either</em> a reference to the parent (by borrowing the parent, thus preventing mutation) <em>or</em> the list of child nodes (by owning them, which gives you more freedom), but <em>not both</em> (without using <code>unsafe</code>). This is especially problematic for your implementation of <code>addNode</code>, which requires mutable access to the given node's parent. However, if you store the <code>parent</code> pointer as a mutable reference, then, since only a single mutable reference to a particular object may be usable at a time, the only way to access the parent would be through a child node, and you'd only be able to have a single child node, otherwise you'd have two mutable references to the same parent node.</p>\n\n<p>If you want to avoid unsafe code, there are many alternatives, but they'll all require some sacrifices.</p>\n\n<hr>\n\n<p>The easiest solution is to simply remove the <code>parent</code> field. We can define a separate data structure to remember the parent of a node while we traverse a tree, rather than storing it in the node itself.</p>\n\n<p>First, let's define <code>Node</code>:</p>\n\n<pre><code>#[derive(Debug)]\nstruct Node&lt;T&gt; {\n    data: T,\n    children: Vec&lt;Node&lt;T&gt;&gt;,\n}\n\nimpl&lt;T&gt; Node&lt;T&gt; {\n    fn new(data: T) -&gt; Node&lt;T&gt; {\n        Node { data: data, children: vec![] }\n    }\n\n    fn add_child(&amp;mut self, child: Node&lt;T&gt;) {\n        self.children.push(child);\n    }\n}\n</code></pre>\n\n<p>(I added a <code>data</code> field because a tree isn't super useful without data at the nodes!)</p>\n\n<p>Let's now define another struct to track the parent as we navigate:</p>\n\n<pre><code>#[derive(Debug)]\nstruct NavigableNode&lt;'a, T: 'a&gt; {\n    node: &amp;'a Node&lt;T&gt;,\n    parent: Option&lt;&amp;'a NavigableNode&lt;'a, T&gt;&gt;,\n}\n\nimpl&lt;'a, T&gt; NavigableNode&lt;'a, T&gt; {\n    fn child(&amp;self, index: usize) -&gt; NavigableNode&lt;T&gt; {\n        NavigableNode {\n            node: &amp;self.node.children[index],\n            parent: Some(self)\n        }\n    }\n}\n\nimpl&lt;T&gt; Node&lt;T&gt; {\n    fn navigate&lt;'a&gt;(&amp;'a self) -&gt; NavigableNode&lt;T&gt; {\n        NavigableNode { node: self, parent: None }\n    }\n}\n</code></pre>\n\n<p>This solution works fine if you don't need to mutate the tree as you navigate it and you can keep the parent <code>NavigableNode</code> objects around (which works fine for a recursive algorithm, but doesn't work too well if you want to store a <code>NavigableNode</code> in some other data structure and keep it around). The second restriction can be alleviated by using something other than a borrowed pointer to store the parent; if you want maximum genericity, you can use the <a href=\"https://doc.rust-lang.org/stable/std/borrow/trait.Borrow.html\" rel=\"noreferrer\"><code>Borrow</code> trait</a> to allow direct values, borrowed pointers, <code>Box</code>es, <code>Rc</code>'s, etc.</p>\n\n<hr>\n\n<p>Now, let's talk about <a href=\"https://en.wikipedia.org/wiki/Zipper_%28data_structure%29\" rel=\"noreferrer\">zippers</a>. In functional programming, zippers are used to \"focus\" on a particular element of a data structure (list, tree, map, etc.) so that accessing that element takes constant time, while still retaining all the data of that data structure. If you need to navigate your tree and <strong>mutate</strong> it during the navigation, while retaining the ability to navigate up the tree, then you could turn a tree into a zipper and perform the modifications through the zipper.</p>\n\n<p>Here's how we could implement a zipper for the <code>Node</code> defined above:</p>\n\n<pre><code>#[derive(Debug)]\nstruct NodeZipper&lt;T&gt; {\n    node: Node&lt;T&gt;,\n    parent: Option&lt;Box&lt;NodeZipper&lt;T&gt;&gt;&gt;,\n    index_in_parent: usize,\n}\n\nimpl&lt;T&gt; NodeZipper&lt;T&gt; {\n    fn child(mut self, index: usize) -&gt; NodeZipper&lt;T&gt; {\n        // Remove the specified child from the node's children.\n        // A NodeZipper shouldn't let its users inspect its parent,\n        // since we mutate the parents\n        // to move the focused nodes out of their list of children.\n        // We use swap_remove() for efficiency.\n        let child = self.node.children.swap_remove(index);\n\n        // Return a new NodeZipper focused on the specified child.\n        NodeZipper {\n            node: child,\n            parent: Some(Box::new(self)),\n            index_in_parent: index,\n        }\n    }\n\n    fn parent(self) -&gt; NodeZipper&lt;T&gt; {\n        // Destructure this NodeZipper\n        let NodeZipper { node, parent, index_in_parent } = self;\n\n        // Destructure the parent NodeZipper\n        let NodeZipper {\n            node: mut parent_node,\n            parent: parent_parent,\n            index_in_parent: parent_index_in_parent,\n        } = *parent.unwrap();\n\n        // Insert the node of this NodeZipper back in its parent.\n        // Since we used swap_remove() to remove the child,\n        // we need to do the opposite of that.\n        parent_node.children.push(node);\n        let len = parent_node.children.len();\n        parent_node.children.swap(index_in_parent, len - 1);\n\n        // Return a new NodeZipper focused on the parent.\n        NodeZipper {\n            node: parent_node,\n            parent: parent_parent,\n            index_in_parent: parent_index_in_parent,\n        }\n    }\n\n    fn finish(mut self) -&gt; Node&lt;T&gt; {\n        while let Some(_) = self.parent {\n            self = self.parent();\n        }\n\n        self.node\n    }\n}\n\nimpl&lt;T&gt; Node&lt;T&gt; {\n    fn zipper(self) -&gt; NodeZipper&lt;T&gt; {\n        NodeZipper { node: self, parent: None, index_in_parent: 0 }\n    }\n}\n</code></pre>\n\n<p>To use this zipper, you need to have ownership of the root node of the tree. By taking ownership of the nodes, the zipper can move things around in order to avoid copying or cloning nodes. When we move a zipper, we actually drop the old zipper and create a new one (though we could also do it by mutating <code>self</code>, but I thought it was clearer that way, plus it lets you chain method calls).</p>\n\n<hr>\n\n<p>If the above options are not satisfactory, and you must absolutely store the parent of a node in a node, then the next best option is to use <code>Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;</code> to refer to the parent and <code>Weak&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;</code> to the children. <a href=\"https://doc.rust-lang.org/stable/std/rc/struct.Rc.html\" rel=\"noreferrer\"><code>Rc</code></a> enables shared ownership, but adds overhead to perform reference counting at runtime. <a href=\"https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html\" rel=\"noreferrer\"><code>RefCell</code></a> enables interior mutability, but adds overhead to keep track of the active borrows at runtime. <a href=\"https://doc.rust-lang.org/stable/std/rc/struct.Weak.html\" rel=\"noreferrer\"><code>Weak</code></a> is like <code>Rc</code>, but it doesn't increment the reference count; this is used to break reference cycles, which would prevent the reference count from dropping to zero, causing a memory leak. <a href=\"https://stackoverflow.com/a/36168774/234590\">See DK.'s answer</a> for an implementation using <code>Rc</code>, <code>Weak</code> and <code>RefCell</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 14, "last_activity_date": 1572352739, "last_edit_date": 1572352739, "creation_date": 1500057488, "answer_id": 45109686, "question_id": 36167160, "link": "https://stackoverflow.com/questions/36167160/how-do-i-express-mutually-recursive-data-structures-in-safe-rust/45109686#45109686", "title": "How do I express mutually recursive data structures in safe Rust?", "body": "<p>In certain cases, you can also use an <em>arena</em>. An arena guarantees that values stored in it will have the same lifetime as the arena itself. This means that adding more values will not invalidate any existing lifetimes, but moving the arena will. Thus, such a solution is not viable if you need to <em>return</em> the tree.</p>\n\n<p>This solves the problem by removing the ownership from the nodes themselves. </p>\n\n<p>Here's an example that also uses <em>interior mutability</em> to allow a node to be mutated after it is created. In other cases, you can remove this mutability if the tree is constructed once and then simply navigated.</p>\n\n<pre><code>use std::{\n    cell::{Cell, RefCell},\n    fmt,\n};\nuse typed_arena::Arena; // 1.6.1\n\nstruct Tree&lt;'a, T: 'a&gt; {\n    nodes: Arena&lt;Node&lt;'a, T&gt;&gt;,\n}\n\nimpl&lt;'a, T&gt; Tree&lt;'a, T&gt; {\n    fn new() -&gt; Tree&lt;'a, T&gt; {\n        Self {\n            nodes: Arena::new(),\n        }\n    }\n\n    fn new_node(&amp;'a self, data: T) -&gt; &amp;'a mut Node&lt;'a, T&gt; {\n        self.nodes.alloc(Node {\n            data,\n            tree: self,\n            parent: Cell::new(None),\n            children: RefCell::new(Vec::new()),\n        })\n    }\n}\n\nstruct Node&lt;'a, T: 'a&gt; {\n    data: T,\n    tree: &amp;'a Tree&lt;'a, T&gt;,\n    parent: Cell&lt;Option&lt;&amp;'a Node&lt;'a, T&gt;&gt;&gt;,\n    children: RefCell&lt;Vec&lt;&amp;'a Node&lt;'a, T&gt;&gt;&gt;,\n}\n\nimpl&lt;'a, T&gt; Node&lt;'a, T&gt; {\n    fn add_node(&amp;'a self, data: T) -&gt; &amp;'a Node&lt;'a, T&gt; {\n        let child = self.tree.new_node(data);\n        child.parent.set(Some(self));\n        self.children.borrow_mut().push(child);\n        child\n    }\n}\n\nimpl&lt;'a, T&gt; fmt::Debug for Node&lt;'a, T&gt;\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"{:?}\", self.data)?;\n        write!(f, \" (\")?;\n        for c in self.children.borrow().iter() {\n            write!(f, \"{:?}, \", c)?;\n        }\n        write!(f, \")\")\n    }\n}\n\nfn main() {\n    let tree = Tree::new();\n    let head = tree.new_node(1);\n    let _left = head.add_node(2);\n    let _right = head.add_node(3);\n\n    println!(\"{:?}\", head); // 1 (2 (), 3 (), )\n}\n</code></pre>\n"}], "owner": {"reputation": 596, "user_id": 789371, "user_type": "registered", "accept_rate": 0, "profile_image": "https://www.gravatar.com/avatar/a6a8d60cf810d14224154d35a1854aaf?s=128&d=identicon&r=PG", "display_name": "nulleight", "link": "https://stackoverflow.com/users/789371/nulleight"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 7279, "favorite_count": 14, "answer_count": 3, "score": 29, "last_activity_date": 1591707516, "creation_date": 1458689527, "last_edit_date": 1542840330, "question_id": 36167160, "link": "https://stackoverflow.com/questions/36167160/how-do-i-express-mutually-recursive-data-structures-in-safe-rust", "title": "How do I express mutually recursive data structures in safe Rust?", "body": "<p>I am trying to implement a scenegraph-like data structure in Rust. I would like an equivalent to this C++ code expressed in <em>safe</em> Rust:</p>\n\n<pre class=\"lang-cpp prettyprint-override\"><code>struct Node\n{\n    Node* parent; // should be mutable, and nullable (no parent)\n    std::vector&lt;Node*&gt; child;\n\n    virtual ~Node() \n    { \n        for(auto it = child.begin(); it != child.end(); ++it)\n        {\n            delete *it;\n        }\n    }\n\n    void addNode(Node* newNode)\n    {\n        if (newNode-&gt;parent)\n        {\n            newNode-&gt;parent.child.erase(newNode-&gt;parent.child.find(newNode));\n        }\n        newNode-&gt;parent = this;\n        child.push_back(newNode);\n    }\n}\n</code></pre>\n\n<p>Properties I want:</p>\n\n<ul>\n<li>the parent takes ownership of its children</li>\n<li>the nodes are accessible from the outside via a reference of some kind</li>\n<li>events that touch one <code>Node</code> can potentially mutate the whole tree</li>\n</ul>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458668575, "post_id": 36159031, "comment_id": 59960148, "body": "@Shepmaster, thanks for the suggestion! I just added a simple example of using a wrapper--is this what you mean? This is definitely easier/simpler than defining a builder or serializer, but isn&#39;t really ideal..."}], "answers": [{"tags": [], "owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "is_accepted": false, "score": 6, "last_activity_date": 1460754798, "last_edit_date": 1460754798, "creation_date": 1460752791, "answer_id": 36656449, "question_id": 36159031, "link": "https://stackoverflow.com/questions/36159031/add-value-of-a-method-to-serde-serialization-output/36656449#36656449", "title": "Add value of a method to serde serialization output", "body": "<p>Here is what I am using now. It's still verbose, and I don't know if it is the best way to handle this, but I thought I would add it here for the record:</p>\n\n<pre><code>#[derive(Deserialize, Debug)]\nstruct Foo {\n    bar: String\n}\n\nimpl Foo {\n    fn baz(&amp;self) -&gt; i32 { self.bar.len() as i32 }\n}\n\nimpl ::serde::Serialize for Foo {\n    fn serialize&lt;S&gt;(&amp;self, serializer: &amp;mut S) -&gt; Result&lt;(), S::Error&gt; \n        where S: ::serde::Serializer {\n\n        #[derive(Serialize)]\n        struct Extended&lt;'a&gt; {\n            bar: &amp;'a String,\n            baz: i32\n        }\n\n        let ext = Extended {\n            bar: &amp;self.bar,\n            baz: self.baz()\n        };\n\n        Ok(try!(ext.serialize(serializer)))\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 695, "favorite_count": 0, "answer_count": 1, "score": 10, "last_activity_date": 1460754798, "creation_date": 1458661687, "last_edit_date": 1460754780, "question_id": 36159031, "link": "https://stackoverflow.com/questions/36159031/add-value-of-a-method-to-serde-serialization-output", "title": "Add value of a method to serde serialization output", "body": "<p>Is there a way to add the value of a  method to the serialization output of <code>serde</code> when the struct derives <code>Serialize</code>? I'm looking for something like a \"virtual field\".</p>\n\n<p>I know I can define my own <code>Serializer</code> / <code>Visitor</code> or use <code>serde_json::builder</code> to get a <code>Value</code>, I just wanted to check first if there was any way to do this using <code>serde_macro</code> magic.</p>\n\n<p>To be clear I want something like this:</p>\n\n<pre><code>#[derive(Serialize, Deserialize, Debug)]\nstruct Foo {\n    bar: String,\n    #[serde(call=\"Foo::baz\")]\n    baz: i32 // but this is not a real field\n}\n\nimpl Foo {\n    fn baz(&amp;self) -&gt; i32 { self.bar.len() as i32 }\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 22726, "user_id": 544621, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f0be786869c99d345f60209f98dd7b64?s=128&d=identicon&r=PG", "display_name": "hamstergene", "link": "https://stackoverflow.com/users/544621/hamstergene"}, "edited": false, "score": 6, "creation_date": 1458652822, "post_id": 36155023, "comment_id": 59948145, "body": "Calling C with zero runtime overhead does not mean being able to call any C function right away. As Rust can not import C headers automatically (unlike for example, Swift), someone has to rewrite declarations of each function in Rust by hand to make them callable from Rust."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458652942, "post_id": 36155023, "comment_id": 59948233, "body": "@Shepmaster has a point here. Maybe you could change the question to something like &quot;What is the purpose of C bindings in Rust on the example of Vulkan&quot;..."}, {"owner": {"reputation": 44714, "user_id": 731620, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/6e2168c4647a4f096a14c254bd3d3f68?s=128&d=identicon&r=PG", "display_name": "ratchet freak", "link": "https://stackoverflow.com/users/731620/ratchet-freak"}, "reply_to_user": {"reputation": 22726, "user_id": 544621, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f0be786869c99d345f60209f98dd7b64?s=128&d=identicon&r=PG", "display_name": "hamstergene", "link": "https://stackoverflow.com/users/544621/hamstergene"}, "edited": false, "score": 0, "creation_date": 1458656231, "post_id": 36155023, "comment_id": 59950935, "body": "@hamstergene or use the vk.xml to generate the function signatures."}, {"owner": {"reputation": 319, "user_id": 3256878, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a4980dd755918b1223d87875da9b524b?s=128&d=identicon&r=PG", "display_name": "Andreas Fl&#246;jt", "link": "https://stackoverflow.com/users/3256878/andreas-fl%c3%b6jt"}, "reply_to_user": {"reputation": 22726, "user_id": 544621, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f0be786869c99d345f60209f98dd7b64?s=128&d=identicon&r=PG", "display_name": "hamstergene", "link": "https://stackoverflow.com/users/544621/hamstergene"}, "edited": false, "score": 0, "creation_date": 1458656833, "post_id": 36155023, "comment_id": 59951449, "body": "@hamstergene Well, that was simple. I guess in this case the bindings are not an intermediate layer at all, but rather just a declaration of what is available to call."}], "answers": [{"comments": [{"owner": {"reputation": 319, "user_id": 3256878, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a4980dd755918b1223d87875da9b524b?s=128&d=identicon&r=PG", "display_name": "Andreas Fl&#246;jt", "link": "https://stackoverflow.com/users/3256878/andreas-fl%c3%b6jt"}, "edited": false, "score": 1, "creation_date": 1458656541, "post_id": 36155347, "comment_id": 59951192, "body": "This answer together with hamstergene&#39;s comment cleared things up. If the reason for using raw bindings in the first place is to declare available functions without including headers, is this what results in zero overhead because we don&#39;t have to perform marshaling, unlike many other bindings (C#, for example)?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1458659071, "post_id": 36155347, "comment_id": 59953234, "body": "Note that a convention is developing in the Rust ecosystem: a crate simply re-exporting a C API (unchanged) should be name <code>xxx-sys</code> where <code>xxx</code> is the name of the C library. Then, multiple higher level crates can be built on top, from the minimalist ones (just enforcing memory safety) to higher-level ones."}, {"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "edited": false, "score": 3, "creation_date": 1458680727, "post_id": 36155347, "comment_id": 59967528, "body": "I always call idiomatic Rust code &#39;rustic&#39;, not &#39;rusty&#39;. I think it has more positive connotations."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 13, "last_activity_date": 1458655059, "last_edit_date": 1458655059, "creation_date": 1458652432, "answer_id": 36155347, "question_id": 36155023, "link": "https://stackoverflow.com/questions/36155023/whats-the-purpose-of-writing-bindings-for-c-libraries-for-rust/36155347#36155347", "title": "What&#39;s the purpose of writing bindings for C libraries for Rust?", "body": "<p>While Rust can call C functions without overhead, the Rust compiler still needs to know about the existence of those functions. To tell the compiler you have to declare those functions in an <code>extern \"C\" { .. }</code> block. You can read more about the topic in the <a href=\"https://doc.rust-lang.org/book/ffi.html\" rel=\"noreferrer\">FFI chapter of the Rust book</a>. For C functions that are used by many people (e.g. Vulkan), it makes sense to put all those declarations into a Rust library that others can just use, instead of writing the bindings themselves.</p>\n\n<p>With the bindings mentioned above we simply expose the original C interface to the Rust programmer. But most Rust programmers rather want to use an API that is idiomatic in Rust (we call it \"rusty\"). That is: using high level concepts of Rust, like traits and closures, and being \"safe\".</p>\n\n<p>The Vulkan libraries you linked:</p>\n\n<ul>\n<li><p>The <a href=\"https://gist.github.com/bonsairobo/a21b768c49989415251d\" rel=\"noreferrer\">second</a> link is just is a raw binding generated with a tool (rust-bindgen).</p></li>\n<li><p>The purpose of <a href=\"https://github.com/tomaka/vulkano\" rel=\"noreferrer\">tomaka's library</a> is to create a rusty API, so it isn't just a collection of function declarations. tomaka chooses to introduce very little overhead in order to create a library that most Rust programmers are more comfortable to use than the C interface. (by the way: tomaka did this <a href=\"https://github.com/tomaka/glium\" rel=\"noreferrer\">for OpenGL</a>, too).</p></li>\n<li><p>I don't really know about the first library you linked, but I think it's something in between the two approaches above.</p></li>\n</ul>\n"}], "owner": {"reputation": 319, "user_id": 3256878, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a4980dd755918b1223d87875da9b524b?s=128&d=identicon&r=PG", "display_name": "Andreas Fl&#246;jt", "link": "https://stackoverflow.com/users/3256878/andreas-fl%c3%b6jt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4716, "favorite_count": 3, "accepted_answer_id": 36155347, "answer_count": 1, "score": 11, "last_activity_date": 1458655059, "creation_date": 1458651480, "last_edit_date": 1458654201, "question_id": 36155023, "link": "https://stackoverflow.com/questions/36155023/whats-the-purpose-of-writing-bindings-for-c-libraries-for-rust", "title": "What&#39;s the purpose of writing bindings for C libraries for Rust?", "body": "<p>I was under the impression that bindings are intermediate layers you write so that you may use a library written in one language in an application written in another. It seems that Rust may <a href=\"http://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html\">call C with zero overhead</a></p>\n\n<p>For a concrete example, Vulkan is a C API, yet people are working on bindings for Vulkan (<a href=\"https://github.com/kainino0x/rust-vulkan-bind\">1</a>, <a href=\"https://gist.github.com/bonsairobo/a21b768c49989415251d\">2</a>, <a href=\"https://github.com/tomaka/vulkano\">3</a>).</p>\n\n<p>If C can be called directly from Rust, why would you want to create bindings? Have I misunderstood something?</p>\n"}, {"tags": ["iterator", "rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 31, "user_id": 6098511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/99699d72a0850fb876306cf26838a6d8?s=128&d=identicon&r=PG&f=1", "display_name": "nujemid", "link": "https://stackoverflow.com/users/6098511/nujemid"}, "edited": false, "score": 0, "creation_date": 1458651909, "post_id": 36155041, "comment_id": 59947406, "body": "<b><code>EditIter</code> should be able to change the <code>Letter</code>. (for example, <code>words</code>).</b> <code>Mode</code> - component of the external  API. The <code>Letter</code> has some public methods."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 31, "user_id": 6098511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/99699d72a0850fb876306cf26838a6d8?s=128&d=identicon&r=PG&f=1", "display_name": "nujemid", "link": "https://stackoverflow.com/users/6098511/nujemid"}, "edited": false, "score": 0, "creation_date": 1458652052, "post_id": 36155041, "comment_id": 59947517, "body": "@nujemid I&#39;m not sure what to tell you. Based on the <a href=\"/help/mcve\">MCVE</a> and descriptive text that you provided in the question, the code compiles and runs with the changes I&#39;ve made."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 31, "user_id": 6098511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/99699d72a0850fb876306cf26838a6d8?s=128&d=identicon&r=PG&f=1", "display_name": "nujemid", "link": "https://stackoverflow.com/users/6098511/nujemid"}, "edited": false, "score": 0, "creation_date": 1458658937, "post_id": 36155041, "comment_id": 59953137, "body": "@nujemid: then... it might be that your MCVE is not C (Complete)? You have much more context that we do (obviously), and we cannot pry it from your mind, so please include all necessary details in the example code."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1458651521, "creation_date": 1458651521, "answer_id": 36155041, "question_id": 36154246, "link": "https://stackoverflow.com/questions/36154246/lifetime-in-iterator-fn-nexta-mut-self/36155041#36155041", "title": "Lifetime in Iterator: fn next(&amp;&#39;a mut self)", "body": "<p>Since your <code>Mode</code> doesn't have any need for a mutable reference, remove the <code>mut</code> from <code>EditIter</code> and it will work:</p>\n\n<pre><code>struct Person&lt;T&gt; {\n    letter: Letter&lt;T&gt;,\n}\n\nstruct Letter&lt;T&gt; {\n    words: [Option&lt;T&gt;; 5],\n}\n\nstruct EditIter&lt;'a, T: 'a&gt; {\n    letter: &amp;'a Letter&lt;T&gt;,\n}\n\nimpl&lt;'a, T: 'a&gt; Iterator for EditIter&lt;'a, T&gt; {\n    type Item = Mode&lt;'a, T&gt;;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        Some(Mode::Editing(self.letter))\n    }\n}\n\nenum Mode&lt;'a, T: 'a&gt; {\n    Editing(&amp;'a Letter&lt;T&gt;),\n    Speaking(&amp;'a Letter&lt;T&gt;),\n}\n</code></pre>\n"}], "owner": {"reputation": 31, "user_id": 6098511, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/99699d72a0850fb876306cf26838a6d8?s=128&d=identicon&r=PG&f=1", "display_name": "nujemid", "link": "https://stackoverflow.com/users/6098511/nujemid"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 116, "favorite_count": 1, "answer_count": 1, "score": 3, "last_activity_date": 1458651521, "creation_date": 1458649245, "last_edit_date": 1458651306, "question_id": 36154246, "link": "https://stackoverflow.com/questions/36154246/lifetime-in-iterator-fn-nexta-mut-self", "title": "Lifetime in Iterator: fn next(&amp;&#39;a mut self)", "body": "<pre><code>struct Person&lt;T&gt; {\n    letter: Letter&lt;T&gt;\n}\n\nstruct Letter&lt;T&gt; {\n    words: [Option&lt;T&gt;; 5]\n}\n\nstruct EditIter&lt;'a, T: 'a&gt; {\n    letter: &amp;'a mut Letter&lt;T&gt;\n}\nimpl&lt;'a, T: 'a&gt; Iterator for EditIter&lt;'a, T&gt; {\n    type Item = Mode&lt;'a, T&gt;;\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        /* ... */\n        Some(Mode::Editing(self.letter))\n    }\n}\n\nenum Mode&lt;'a, T: 'a&gt; {\n    Editing(&amp;'a Letter&lt;T&gt;),\n    Speaking(&amp;'a Letter&lt;T&gt;)\n}\n</code></pre>\n\n<p>Error:</p>\n\n<pre><code>src/temp.rs:16:28: 16:39 error: cannot infer an appropriate lifetime for automatic coercion due to conflicting requirements [E0495]\nsrc/temp.rs:16         Some(Mode::Editing(self.letter))\n                                          ^~~~~~~~~~~\nsrc/temp.rs:14:5: 17:6 help: consider using an explicit lifetime parameter as shown: fn next(&amp;'a mut self) -&gt; Option&lt;Self::Item&gt;\nsrc/temp.rs:14     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\nsrc/temp.rs:15         /* ... */\nsrc/temp.rs:16         Some(Mode::Editing(self.letter))\nsrc/temp.rs:17     }\n</code></pre>\n\n<p><code>Person</code> owns the <code>Letter</code>, <code>Person</code> transfers a mutable borrow of <code>Letter</code> to <code>EditIter</code>, <code>EditIter</code> creates a <code>Mode</code> with the borrowed <code>Letter</code> and sends it. If you remove the <code>Iterator</code> trait and do as written in the error message, it works, but this would not implement the <code>Iterator</code> trait.</p>\n\n<p>How can I save the logic and fix the error?</p>\n"}, {"tags": ["rust", "traits"], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 1, "creation_date": 1459169203, "post_id": 36148375, "comment_id": 60153212, "body": "Is this the only difference? So what about <code>impl</code>s of structs? Is there no difference at all? Does anyone know?"}], "tags": [], "owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "is_accepted": false, "score": 3, "last_activity_date": 1458631417, "creation_date": 1458631417, "answer_id": 36148375, "question_id": 36142626, "link": "https://stackoverflow.com/questions/36142626/is-it-better-to-specify-trait-bound-on-the-impl-block-or-on-the-method/36148375#36148375", "title": "Is it better to specify trait bound on the impl block or on the method?", "body": "<p>One semantic difference is that with the type bound on the method you can partially implement a trait:</p>\n\n<pre><code>trait Trait {\n    fn f(self) where Self: std::fmt::Display;\n    fn g(self);\n}\n\nstruct Struct&lt;T&gt;(T);\n\nimpl&lt;T&gt; Trait for Struct&lt;T&gt; {\n    fn f(self) where Struct&lt;T&gt;: std::fmt::Display {\n        println!(\"{}\", self);\n    }\n    fn g(self) {\n        println!(\"Hello world!\");\n    }\n}\n\nfn main() {\n    let s = Struct(vec![1]);\n\n    // f is not implemented, but g is\n    //s.f();\n    s.g();\n}\n</code></pre>\n\n<p>This may be useful if you have many optional methods with different type bounds, which would otherwise require separate traits.</p>\n"}], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2402, "favorite_count": 4, "answer_count": 1, "score": 10, "last_activity_date": 1528061803, "creation_date": 1458598370, "last_edit_date": 1528061803, "question_id": 36142626, "link": "https://stackoverflow.com/questions/36142626/is-it-better-to-specify-trait-bound-on-the-impl-block-or-on-the-method", "title": "Is it better to specify trait bound on the impl block or on the method?", "body": "<p>Suppose I want to create some type that wraps some other generic type, like so:</p>\n\n<pre><code>struct MyWrapper&lt;T&gt; {\n    pub inner: T,\n}\n</code></pre>\n\n<p>Now I want my type to have a method if the inner type satisfies a specific bound. For example: I want to print it (in this example without using <code>fmt</code> traits for simplicity). To do this I have two possibilities: adding a bound to the <code>impl</code> or to the method itself.</p>\n\n<h3>Method Bound</h3>\n\n<pre><code>impl&lt;T&gt; MyWrapper&lt;T&gt; {\n    pub fn print_inner(&amp;self) where T: std::fmt::Display {\n        println!(\"[[ {} ]]\", self.inner);\n    }\n}\n</code></pre>\n\n<p>When calling this function with a <code>MyWrapper&lt;()&gt;</code> I get:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: `()` doesn't implement `std::fmt::Display`\n  --&gt; src/main.rs:20:7\n   |\n20 |     w.print_inner();\n   |       ^^^^^^^^^^^ `()` cannot be formatted with the default formatter; try using `:?` instead if you are using a format string\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `()`\n</code></pre>\n\n<h3>Impl Bound</h3>\n\n<pre><code>impl&lt;T: std::fmt::Display&gt; MyWrapper&lt;T&gt; {\n    pub fn print_inner(&amp;self) {\n        println!(\"[[ {} ]]\", self.inner);\n    }\n}\n</code></pre>\n\n<p>Calling it incorrectly again, gives:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0599]: no method named `print_inner` found for type `MyWrapper&lt;()&gt;` in the current scope\n  --&gt; src/main.rs:19:7\n   |\n1  | struct MyWrapper&lt;T&gt; {\n   | ------------------- method `print_inner` not found for this\n...\n19 |     w.print_inner();\n   |       ^^^^^^^^^^^\n   |\n   = note: the method `print_inner` exists but the following trait bounds were not satisfied:\n           `() : std::fmt::Display` \n</code></pre>\n\n<hr>\n\n<p><strong>My question is</strong>: what is more idiomatic? Are there semantic differences (aside from lifetime stuff with traits, explained <a href=\"https://stackoverflow.com/questions/31470146/difference-between-specifying-lifetime-parameter-on-impl-or-method\">here</a>)? Are there differences apart from the compiler message?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 1, "last_activity_date": 1458634282, "creation_date": 1458634282, "answer_id": 36149146, "question_id": 36141804, "link": "https://stackoverflow.com/questions/36141804/how-to-write-a-safe-wrap-for-hashmap-with-default-value/36149146#36149146", "title": "How to write a safe wrap for HashMap with default value", "body": "<p>I think that you are covered by the borrowing rules here.</p>\n\n<p>Applying the Mutability XOR Aliasing principle here, unsafety would crop up if you could maintain multiple paths to the same value and mutate something at the same time.</p>\n\n<p>In your case, however:</p>\n\n<ul>\n<li>while the internal <code>HashMap</code> can be mutated even through an aliasable reference to <code>DefaultHashMap</code>, nobody has a reference into the <code>HashMap</code> itself</li>\n<li>while there are references into the <code>Box</code>, there is no possibility here to erase a <code>Box</code>, so no dangling pointer from here</li>\n<li>since you take care to preserve the borrowing relationship (ie, <code>&amp;mut T</code> is only obtained through a <code>&amp;mut DefaultHashMap</code>), it is not possible to have a <code>&amp;mut T</code> and an alias into it</li>\n</ul>\n\n<p>So, your short example <em>looks</em> safe, however be especially wary of not accidentally introducing a method on <code>&amp;DefaultHashMap</code> which would allow to modify an existing value as this would be a short road to dangling pointers.</p>\n\n<p>Personally, I would execute all tests with an <code>Option&lt;String&gt;</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1545321165, "last_edit_date": 1545321165, "creation_date": 1458650996, "answer_id": 36154859, "question_id": 36141804, "link": "https://stackoverflow.com/questions/36141804/how-to-write-a-safe-wrap-for-hashmap-with-default-value/36154859#36154859", "title": "How to write a safe wrap for HashMap with default value", "body": "<p>Since you cannot<sup>1</sup> mutate the value returned from <code>get</code>, I'd just return a reference to the default value when the value is missing. When you call <code>get_mut</code> however, you can then add the value to the map and return the reference to the newly-added value.</p>\n\n<p>This has the nice benefit of not needing any <code>unsafe</code> code.</p>\n\n<pre><code>use std::{borrow::Borrow, collections::HashMap, hash::Hash};\n\npub struct DefaultHashMap&lt;K, V&gt; {\n    default: V,\n    map: HashMap&lt;K, V&gt;,\n}\n\nimpl&lt;K, V&gt; DefaultHashMap&lt;K, V&gt;\nwhere\n    K: Hash + Eq,\n    V: Clone,\n{\n    pub fn new(default: V) -&gt; Self {\n        DefaultHashMap {\n            default,\n            map: HashMap::new(),\n        }\n    }\n\n    pub fn get_mut(&amp;mut self, v: K) -&gt; &amp;mut V {\n        let def = &amp;self.default;\n        self.map.entry(v).or_insert_with(|| def.clone())\n    }\n\n    pub fn get&lt;B&gt;(&amp;self, v: B) -&gt; &amp;V\n    where\n        B: Borrow&lt;K&gt;,\n    {\n        self.map.get(v.borrow()).unwrap_or(&amp;self.default)\n    }\n}\n\n#[test]\nfn test() {\n    let mut m = DefaultHashMap::new(10usize);\n    *m.get_mut(4) = 40;\n    let a = m.get(4);\n    for i in 1..1024 {\n        m.get(i);\n    }\n    assert_eq!(a, m.get(4));\n    assert_eq!(40, *m.get(4));\n}\n</code></pre>\n\n<hr>\n\n<p>[1]: Technically this will have different behavior if your default value contains <em>internal mutability</em>. In that case, modifications to the default value would apply across the collection. If that's a concern, you'd need to use a solution closer to your original.</p>\n"}], "owner": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 604, "favorite_count": 3, "accepted_answer_id": 36154859, "answer_count": 2, "score": 2, "last_activity_date": 1545321165, "creation_date": 1458595147, "last_edit_date": 1458603142, "question_id": 36141804, "link": "https://stackoverflow.com/questions/36141804/how-to-write-a-safe-wrap-for-hashmap-with-default-value", "title": "How to write a safe wrap for HashMap with default value", "body": "<p>I implemented a wrap for <code>HashMap</code> with default values and I would like to know if it's safe.</p>\n\n<p>When <code>get</code> is called, the internal map may be resized and previous references to values (obtained with <code>get</code>) would be pointing to invalid address. I tried to solve this problem using the idea that \"all problems in computer science can be solved by another level of indirection\" (<a href=\"http://www.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html\" rel=\"nofollow\">Butler Lampson</a>). I would like to know if this trick makes this code safe.</p>\n\n<pre><code>use std::cell::UnsafeCell;\nuse std::collections::HashMap;\nuse std::hash::Hash;\n\npub struct DefaultHashMap&lt;I: Hash + Eq, T: Clone&gt; {\n    default: T,\n    map: UnsafeCell&lt;HashMap&lt;I, Box&lt;T&gt;&gt;&gt;,\n}\n\nimpl&lt;I: Hash + Eq, T: Clone&gt; DefaultHashMap&lt;I, T&gt; {\n    pub fn new(default: T) -&gt; Self {\n        DefaultHashMap {\n            default: default,\n            map: UnsafeCell::new(HashMap::new()),\n        }\n    }\n\n    pub fn get_mut(&amp;mut self, v: I) -&gt; &amp;mut T {\n        let m = unsafe { &amp;mut *self.map.get() };\n        m.entry(v).or_insert_with(|| Box::new(self.default.clone()))\n    }\n\n    pub fn get(&amp;self, v: I) -&gt; &amp;T {\n        let m = unsafe { &amp;mut *self.map.get() };\n        m.entry(v).or_insert_with(|| Box::new(self.default.clone()))\n    }\n}\n\n#[test]\nfn test() {\n    let mut m = DefaultHashMap::new(10usize);\n    *m.get_mut(4) = 40;\n    let a = m.get(4);\n    for i in 1..1024 {\n        m.get(i);\n    }\n    assert_eq!(a, m.get(4));\n    assert_eq!(40, *m.get(4));\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=9a6b22174c512d23dc7d&amp;version=stable\" rel=\"nofollow\">Playground</a>)</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 6, "creation_date": 1458588748, "post_id": 36139896, "comment_id": 59918342, "body": "You forgot the <code>match</code> after the <code>=</code> assignment... Just compare it with the original code again."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1458589313, "post_id": 36139896, "comment_id": 59918661, "body": "A diffing tool would be invaluable to point out the differences. There are <a href=\"https://www.diffchecker.com/\" rel=\"nofollow noreferrer\">online versions</a> and command-line versions."}, {"owner": {"reputation": 5801, "user_id": 2586392, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/9d89d4072afb4457b0c49131d8d258f5?s=128&d=identicon&r=PG", "display_name": "rpadovani", "link": "https://stackoverflow.com/users/2586392/rpadovani"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1458593376, "post_id": 36139896, "comment_id": 59920829, "body": "@LukasKalbertodt thanks! I fell quite stupid right now..."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 2, "creation_date": 1458593628, "post_id": 36139896, "comment_id": 59920988, "body": "@rpadovani It happens to the best of us ;) However, checking your code and doing a minimal amount of thinking before asking on StackOverflow is expected to avoid unhelpful questions like this one. Just keep on coding and have fun learning Rust! :3"}], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1458598734, "post_id": 36141538, "comment_id": 59923420, "body": "Nice explanation. However, this is a parsing error and the parser doesn&#39;t care about the return type of <code>parse</code>. Indeed the <code>guess.trim().parse()</code> expression mustn&#39;t be followed by a code block, but again, the type doesn&#39;t matter. Maybe you could remove that part from your answer..."}], "tags": [], "owner": {"reputation": 2105, "user_id": 6081776, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/11c9accc109dd8929f6d128693b8f4e2?s=128&d=identicon&r=PG", "display_name": "Matt Champion", "link": "https://stackoverflow.com/users/6081776/matt-champion"}, "is_accepted": true, "score": 5, "last_activity_date": 1458638138, "last_edit_date": 1458638138, "creation_date": 1458594161, "answer_id": 36141538, "question_id": 36139896, "link": "https://stackoverflow.com/questions/36139896/guessing-game-error-on-shadowing-guess-bind/36141538#36141538", "title": "Guessing game, error on shadowing guess bind", "body": "<p>There is a syntax error and the compiler message is directing your attention to the wrong place on the line to fix the problem.</p>\n\n<p>The <code>parse</code> method evaluates to a value. This expression should not be followed by a block, causing the syntax error reported by the compiler.</p>\n\n<p><a href=\"https://doc.rust-lang.org/std/string/struct.String.html#method.parse\" rel=\"nofollow\">https://doc.rust-lang.org/std/string/struct.String.html#method.parse</a></p>\n\n<p>The example you linked to has the keyword <code>match</code> between the assignment and call to <code>parse</code>. The <code>match</code> keyword takes an expression and branches based on the value of the expression. The block contains the branching patterns and expressions. In this case it is also destructuring the <code>Result</code> into either an <code>u32</code> or <code>u32::Err</code>.</p>\n\n<p><a href=\"https://doc.rust-lang.org/book/match.html\" rel=\"nofollow\">https://doc.rust-lang.org/book/match.html</a></p>\n\n<p>Below is an example that separates the parse and match for clarity.</p>\n\n<pre><code>// Store result of parsing in a variable\nlet parse_result = guess.trim().parse();\n// Destructure the result\nlet guess: u32 = match parse_result {\n    // If parse succeeded evaluate to the number\n    Ok(num) =&gt; num,\n    // If parse failed repeat the loop\n    Err(_) =&gt; continue,\n};\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 21, "user_id": 11673089, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-Dko9SS6Arfg/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rd_7pkYDidwjRzGwtcE-UnDYakUrw/mo/photo.jpg?sz=128", "display_name": "Durid Ahmad", "link": "https://stackoverflow.com/users/11673089/durid-ahmad"}, "is_accepted": false, "score": 1, "last_activity_date": 1595537525, "creation_date": 1595537525, "answer_id": 63062954, "question_id": 36139896, "link": "https://stackoverflow.com/questions/36139896/guessing-game-error-on-shadowing-guess-bind/63062954#63062954", "title": "Guessing game, error on shadowing guess bind", "body": "<p>You forgot to add the <code>match</code> keyword before calling <code>guess.trim().parse()</code>\nThat line should look like  this:\n<code>let guess : u32 = match guess.trim().parse() {...</code></p>\n<p>source: <a href=\"https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html\" rel=\"nofollow noreferrer\">https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html</a></p>\n"}], "owner": {"reputation": 5801, "user_id": 2586392, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/9d89d4072afb4457b0c49131d8d258f5?s=128&d=identicon&r=PG", "display_name": "rpadovani", "link": "https://stackoverflow.com/users/2586392/rpadovani"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 850, "favorite_count": 0, "accepted_answer_id": 36141538, "answer_count": 2, "score": 3, "last_activity_date": 1595537525, "creation_date": 1458588478, "last_edit_date": 1458589196, "question_id": 36139896, "link": "https://stackoverflow.com/questions/36139896/guessing-game-error-on-shadowing-guess-bind", "title": "Guessing game, error on shadowing guess bind", "body": "<p>I'm following the <a href=\"https://doc.rust-lang.org/book/guessing-game.html\" rel=\"nofollow\">Rust tutorial</a> but I'm stuck on this code (the last snippet in the page):</p>\n\n<pre><code>extern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is {}\", secret_number);\n\n    loop {\n        println!(\"Please input your guess\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&amp;mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; continue,\n        }\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&amp;secret_number) {\n            Ordering::Less      =&gt; println!(\"Too small!\"),\n            Ordering::Greater   =&gt; println!(\"Too big!\"),\n            Ordering::Equal     =&gt; {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>When I run <code>cargo run</code> I have the following error:</p>\n\n<pre><code>src/main.rs:23:47: 23:48 error: expected one of `.`, `;`, or an operator, found `{`\nsrc/main.rs:23         let guess: u32 = guess.trim().parse() {\n                                                             ^\n</code></pre>\n\n<p>What's the right syntax? </p>\n"}, {"tags": ["reference", "rust", "borrow-checker"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458633061, "post_id": 36138477, "comment_id": 59935065, "body": "Possible duplicate of <a href=\"http://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct\">Why can&#39;t I store a value and a reference to that value in the same struct?</a>"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458633178, "post_id": 36138477, "comment_id": 59935128, "body": "@PeterLudvigsen: What you are looking for is impossible (see <a href=\"http://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct\" title=\"why cant i store a value and a reference to that value in the same struct\">stackoverflow.com/questions/32300132/&hellip;</a>). Storing one item will <i>permanently</i> anchor the parent <code>struct</code>, preventing any further borrow."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458632994, "post_id": 36144811, "comment_id": 59935031, "body": "Have you tried inserting a second subscription? I did, and it does not work."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 1, "last_activity_date": 1458655393, "last_edit_date": 1458655393, "creation_date": 1458610943, "answer_id": 36144811, "question_id": 36138477, "link": "https://stackoverflow.com/questions/36138477/aquire-a-t-from-optionta/36144811#36144811", "title": "Aquire &amp;&#39;a T from Option&lt;T&lt;&#39;a&gt;&gt;", "body": "<p><a href=\"http://doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.insert\" rel=\"nofollow\"><code>HashMap.insert()</code></a> returns the <strong>old</strong> value for the given key, not the value you just passed. That's not what you want!</p>\n\n<p>After you've inserted an item into the <code>HashMap</code>, you must call <code>HashMap.get()</code> to retrieve a pointer to the value. As <code>HashMap.insert()</code> takes ownership of both the key and the value, we need to pass a clone of <code>id</code> to <code>insert()</code> so we can use the original <code>id</code> for the <code>get()</code> call. (If the type of <code>id</code> is <code>Copy</code>, you may omit the call to <code>clone()</code> and let the compiler copy the value.)</p>\n\n<pre><code>use std::collections::HashMap;\n\n#[derive(Eq, PartialEq, Hash, Clone)]\nstruct SubscriptionKey;\nstruct Subscription&lt;'a&gt;(&amp;'a ());\n\nstruct Foo&lt;'a&gt; {\n    subscriptions_map: HashMap&lt;SubscriptionKey, Subscription&lt;'a&gt;&gt;,\n    subscriptions: Vec&lt;&amp;'a Subscription&lt;'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Foo&lt;'a&gt; {\n    fn add(&amp;'a mut self, id: SubscriptionKey, item: Subscription&lt;'a&gt;) {\n        self.subscriptions_map.insert(id.clone(), item);\n        let subs = self.subscriptions_map.get(&amp;id).unwrap();\n        self.subscriptions.push(subs);\n    }\n}\n\nfn main() {\n    let subscription_data = &amp;();\n\n    let mut f = Foo {\n        subscriptions_map: HashMap::new(),\n        subscriptions: Vec::new(),\n    };\n\n    f.add(SubscriptionKey, Subscription(subscription_data));\n}\n</code></pre>\n\n<p>This works fine, but it falls apart if we try to add another subscription. If we do this:</p>\n\n<pre><code>fn main() {\n    let subscription_data = &amp;();\n    let subscription_data2 = &amp;();\n\n    let mut f = Foo {\n        subscriptions_map: HashMap::new(),\n        subscriptions: Vec::new(),\n    };\n\n    f.add(SubscriptionKey, Subscription(subscription_data));\n    f.add(SubscriptionKey, Subscription(subscription_data2));\n}\n</code></pre>\n\n<p>the compiler gives the following messages:</p>\n\n<pre><code>&lt;anon&gt;:30:5: 30:6 error: cannot borrow `f` as mutable more than once at a time [E0499]\n&lt;anon&gt;:30     f.add(SubscriptionKey, Subscription(subscription_data2));\n              ^\n&lt;anon&gt;:30:5: 30:6 help: see the detailed explanation for E0499\n&lt;anon&gt;:29:5: 29:6 note: previous borrow of `f` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `f` until the borrow ends\n&lt;anon&gt;:29     f.add(SubscriptionKey, Subscription(subscription_data));\n              ^\n&lt;anon&gt;:31:2: 31:2 note: previous borrow ends here\n&lt;anon&gt;:20 fn main() {\n...\n&lt;anon&gt;:31 }\n          ^\n</code></pre>\n\n<p>What's going on? Why does the mutable borrow persist after the first call to <code>Foo::add</code>?</p>\n\n<p>The problem comes from the definition of the <code>subscriptions</code> field. It's defined as a <code>Vec&lt;&amp;'a Subscription&lt;'a&gt;&gt;</code>. Satisfying the <code>'a</code> in <code>Subscription&lt;'a&gt;</code> is easy, since we receive the object with the correct lifetime in <code>add</code>. Satisfying the <code>'a</code> in <code>&amp;'a ...</code> is harder, since the <code>Subscription&lt;'a&gt;</code> value doesn't have a fixed address until we insert it into <code>subscriptions_map</code> (in my example, a <code>Subscription&lt;'a&gt;</code> is moved from a local variable in <code>main()</code> to a parameter in <code>Foo::add()</code> to inside <code>self.subscriptions_map</code>).</p>\n\n<p>In order to satisfy the outer <code>'a</code>, <code>Foo::add()</code> must define its <code>self</code> parameter as <code>&amp;'a mut self</code>. If we defined it as <code>&amp;mut self</code>, we couldn't be sure that the references we get out of <code>subscriptions_map</code> would live long enough (their lifetime could be shorter than <code>'a</code>).</p>\n\n<p>However, by inserting a <code>&amp;'a Subscription&lt;'a&gt;</code> inside of a <code>Foo&lt;'a&gt;</code>, we are effectively <em>locking down</em> the <code>Foo</code> for further modifications, since we are now storing a borrow from <code>self.subscriptions_map</code> in <code>self.subscriptions</code>. Consider what would happen if we inserted another item in <code>subscriptions_map</code>: how can we be sure that the <code>HashMap</code> won't move its items around in memory? If the <code>HashMap</code> does move our item, the pointer in <code>self.subscriptions</code> wouldn't be updated automatically and would be dangling.</p>\n\n<p>Now, suppose that we have this buggy <code>remove()</code> method:</p>\n\n<pre><code>impl&lt;'a&gt; Foo&lt;'a&gt; {\n    fn remove(&amp;mut self, id: &amp;SubscriptionKey) {\n        self.subscriptions_map.remove(id);\n    }\n}\n</code></pre>\n\n<p>This method compiles fine. However, if we tried to call this on a <code>Foo</code> on which we called <code>add()</code> earlier, then <code>self.subscriptions</code> would contain a dangling reference to an item that used to be in <code>self.subscriptions_map</code>.</p>\n\n<p>So the reason why the mutable borrow persists after calling <code>add()</code> is that, since the <code>'a</code> in <code>Foo&lt;'a&gt;</code> is equal to the lifetime of the <code>Foo&lt;'a&gt;</code> itself, the compiler sees that the object borrows from itself. As you know, we can't have a mutable borrow and another borrow (mutable or not) active at the same time, so Rust prevents us from taking a mutable borrow on <code>f</code> while <code>f</code> itself retains an active borrow. In fact, since we used a method that takes <code>self</code> by mutable reference, Rust assumes that <code>Foo&lt;'a&gt;</code> stores a mutable reference, even though that's not the case, since Rust only looks at the signatures to determine borrows (this is to ensure that changing a private field from <code>&amp;'a T</code> to <code>&amp;'a mut T</code> doesn't cause borrow checking failures to you and, if you're developing a library, to your users). Since the type of an object never changes, the <code>Foo&lt;'a&gt;</code> is locked for the rest of its lifetime.</p>\n\n<p>Now, what can you do? Clearly, you can't usefully have a <code>Vec&lt;&amp;'a Subscription&lt;'a&gt;&gt;</code> in your struct. <code>HashMap</code> provides a <a href=\"http://doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.values\" rel=\"nofollow\"><code>values()</code></a> iterator, but it enumerates the values in an unspecified order, so it won't help you if you want to enumerate the values in the order in which they were added. Instead of using borrowed pointers, you could use <a href=\"http://doc.rust-lang.org/stable/std/rc/struct.Rc.html\" rel=\"nofollow\"><code>Rc</code></a>:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::rc::Rc;\n\n#[derive(Eq, PartialEq, Hash)]\nstruct SubscriptionKey;\nstruct Subscription&lt;'a&gt;(&amp;'a ());\n\nstruct Foo&lt;'a&gt; {\n    subscriptions_map: HashMap&lt;SubscriptionKey, Rc&lt;Subscription&lt;'a&gt;&gt;&gt;,\n    subscriptions: Vec&lt;Rc&lt;Subscription&lt;'a&gt;&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Foo&lt;'a&gt; {\n    fn add(&amp;mut self, id: SubscriptionKey, item: Subscription&lt;'a&gt;) {\n        let item = Rc::new(item);\n        self.subscriptions_map.insert(id, item.clone());\n        self.subscriptions.push(item);\n    }\n}\n\nfn main() {\n    let subscription_data = &amp;();\n\n    let mut f = Foo {\n        subscriptions_map: HashMap::new(),\n        subscriptions: Vec::new(),\n    };\n\n    f.add(SubscriptionKey, Subscription(subscription_data));\n}\n</code></pre>\n"}], "owner": {"reputation": 180, "user_id": 5218118, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/712c19ee522b71854d1e6d2d7d2639be?s=128&d=identicon&r=PG&f=1", "display_name": "Peter Ludvigsen", "link": "https://stackoverflow.com/users/5218118/peter-ludvigsen"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 64, "favorite_count": 0, "accepted_answer_id": 36144811, "answer_count": 1, "score": 0, "last_activity_date": 1458655393, "creation_date": 1458583427, "last_edit_date": 1458584717, "question_id": 36138477, "link": "https://stackoverflow.com/questions/36138477/aquire-a-t-from-optionta", "title": "Aquire &amp;&#39;a T from Option&lt;T&lt;&#39;a&gt;&gt;", "body": "<p>I'm afraid this may be very basic but I haven't been able to figure it out on my own. I have this map:</p>\n\n<pre><code>subscriptions_map: HashMap&lt;SubscriptionKey, Subscription&lt;'a&gt;&gt;\n</code></pre>\n\n<p>and this vector:</p>\n\n<pre><code>subscriptions: Vec&lt;&amp;'a Subscription&lt;'a&gt;&gt;,\n</code></pre>\n\n<p>I want to insert a value into the <code>HashMap</code> and a reference to the same item into the vector. I've tried to do it like this:</p>\n\n<pre><code>let subs: &amp;'a Subscription = &amp;self.subscriptions_map.insert(id, item).unwrap();\nself.subscriptions.push(subs);\n</code></pre>\n\n<p>But it gets this error:</p>\n\n<pre><code>error: borrowed value does not live long enough\n         let subs: &amp;'a Subscription = &amp;self.subscriptions_map.insert(id, item).unwrap();\n                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: reference must be valid for the lifetime 'a as defined on the block at 40:70...\n     pub fn add_subscription(&amp;'a mut self, mut item: Subscription&lt;'a&gt;) {\n         let id = item.get_id();\n\n         let _lock = self.lock.lock().unwrap();\n\n         let subs: &amp;'a Subscription = &amp;self.subscriptions_map.insert(id, item).unwrap();\n ...\nnote: ...but borrowed value is only valid for the block suffix following statement 2 at 45:87\n         let subs: &amp;'a Subscription = &amp;self.subscriptions_map.insert(id, item).unwrap();\n         self.subscriptions.push(subs);\n     }\nerror: aborting due to previous error\n</code></pre>\n\n<p>I guess my question boils down to: If I have an <code>Option&lt;T&lt;'a&gt;&gt;</code>, how can I get a <code>&amp;'a T</code>?</p>\n"}, {"tags": ["memory-management", "segmentation-fault", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458577782, "post_id": 36136201, "comment_id": 59911435, "body": "Java also guarantees memory safety and prevents segfault (through its VM + Garbage Collector), so what difference between Java and Rust are you looking for? Also, have you read <a href=\"https://doc.rust-lang.org/book/\" rel=\"nofollow noreferrer\">the Rust Book</a>? (it might not answer your questions). Also, have you read <a href=\"http://stackoverflow.com/questions/29628650/how-does-rust-achieve-compile-time-only-pointer-safety\" title=\"how does rust achieve compile time only pointer safety\">stackoverflow.com/questions/29628650/&hellip;</a> ?"}, {"owner": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "edited": false, "score": 0, "creation_date": 1458578433, "post_id": 36136201, "comment_id": 59911894, "body": "Java uses a tracing garbage collector that keeps all objects alive except those that are provably unreachable (and therefore their absence is unobservable). Rust uses an affine type system that ensures that each object has a well-defined lifetime and rules that forbid taking references that could survive past the lifetime of the referent object."}, {"owner": {"reputation": 4847, "user_id": 1079908, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/5dcc6fb47ea5cb45425a768aa059facd?s=128&d=identicon&r=PG", "display_name": "ferit", "link": "https://stackoverflow.com/users/1079908/ferit"}, "edited": false, "score": 0, "creation_date": 1458578452, "post_id": 36136201, "comment_id": 59911906, "body": "As far as I know, Java does not guarantee memory safety."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 4847, "user_id": 1079908, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/5dcc6fb47ea5cb45425a768aa059facd?s=128&d=identicon&r=PG", "display_name": "ferit", "link": "https://stackoverflow.com/users/1079908/ferit"}, "edited": false, "score": 0, "creation_date": 1458579887, "post_id": 36136201, "comment_id": 59912979, "body": "@Saibot: What does memory safety mean, to you :) ?"}], "answers": [{"comments": [{"owner": {"reputation": 161, "user_id": 5730287, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/218da47dfaa19dd7da2562845f9d8426?s=128&d=identicon&r=PG&f=1", "display_name": "Myra", "link": "https://stackoverflow.com/users/5730287/myra"}, "edited": false, "score": 0, "creation_date": 1458582337, "post_id": 36137381, "comment_id": 59914619, "body": "Thanks for answer. Would you like to add something about segfault prevention?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 161, "user_id": 5730287, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/218da47dfaa19dd7da2562845f9d8426?s=128&d=identicon&r=PG&f=1", "display_name": "Myra", "link": "https://stackoverflow.com/users/5730287/myra"}, "edited": false, "score": 2, "creation_date": 1458583177, "post_id": 36137381, "comment_id": 59915175, "body": "@Myra: A segmentation fault is only one of the symptoms of an unsafe memory access. Rust is memory safe, thanks to the mechanism explained here, and therefore is as free of segmentation fault as it is free of memory corruptions."}, {"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "reply_to_user": {"reputation": 161, "user_id": 5730287, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/218da47dfaa19dd7da2562845f9d8426?s=128&d=identicon&r=PG&f=1", "display_name": "Myra", "link": "https://stackoverflow.com/users/5730287/myra"}, "edited": false, "score": 1, "creation_date": 1458642626, "post_id": 36137381, "comment_id": 59940881, "body": "@Myra With rust only segfault you easily can provoke is &quot;stack overflow&quot;. Any other segfaults mean there is bug in the compiler or in libraries that uses unsafe code (and C libraries through ffi)."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "edited": false, "score": 0, "creation_date": 1458651216, "post_id": 36137381, "comment_id": 59946890, "body": "@qthree: Actually, a small &quot;stack overflow&quot; (&lt; 4KB) is no longer reported as a segmentation fault since the latest release to simplify the message since many people equate &quot;memory safe&quot; with &quot;segmentation fault free&quot; not realizing that not all segmentation faults are a memory safety issue. I believe there&#39;s an open bug to implement proper stack-depth checking to ensure that even large stack allocations will not cause a stack overflow."}, {"owner": {"reputation": 695, "user_id": 340297, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lUvl2.png?s=128&g=1", "display_name": "Catalin Hritcu", "link": "https://stackoverflow.com/users/340297/catalin-hritcu"}, "edited": false, "score": 0, "creation_date": 1498258865, "post_id": 36137381, "comment_id": 76444736, "body": "Your answer and most Rust propaganda seems to focus solely on <i>temporal</i> memory safety, i.e. preventing double frees and use after frees, where Rust has indeed an interesting solution. What about <i>spatial</i> memory safety though? How are out of bounds memory accesses prevented?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 695, "user_id": 340297, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lUvl2.png?s=128&g=1", "display_name": "Catalin Hritcu", "link": "https://stackoverflow.com/users/340297/catalin-hritcu"}, "edited": false, "score": 1, "creation_date": 1498299955, "post_id": 36137381, "comment_id": 76452306, "body": "@CatalinHritcu: <i>Propaganda</i>, really? :D The focus is mostly on temporal safety because it is where Rust innovates. On spatial safety, Rust simply performs bounds-check at run-time, like pretty much any other language. There have been library experiments on branded indices, but without direct language support the &quot;solutions&quot; are awkward."}, {"owner": {"reputation": 695, "user_id": 340297, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/lUvl2.png?s=128&g=1", "display_name": "Catalin Hritcu", "link": "https://stackoverflow.com/users/340297/catalin-hritcu"}, "edited": false, "score": 1, "creation_date": 1498396417, "post_id": 36137381, "comment_id": 76474263, "body": "Dynamic bounds checks make sense as an answer here, but this is not what &quot;pretty much any other language&quot; does. Memory unsafe languages like C/C++ don&#39;t do these checks at their programmers&#39; peril. Given that spatial memory safety is as important for security as the temporal kind, I suggest updating your answer to reflect this reality, instead of making it sound as if temporal memory safety is &quot;all there is to it&quot;. I believe Rust is awesome enough that it doesn&#39;t need propaganda that silently redefines general concepts like &quot;memory safety&quot; to mean only &quot;temporal memory safety&quot;."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 30, "last_activity_date": 1498402127, "last_edit_date": 1498402127, "creation_date": 1458579862, "answer_id": 36137381, "question_id": 36136201, "link": "https://stackoverflow.com/questions/36136201/how-does-rust-guarantee-memory-safety-and-prevent-segfaults/36137381#36137381", "title": "How does Rust guarantee memory safety and prevent segfaults?", "body": "<p>How Rust achieves memory safety is, at its core, actually quite simple. It hinges mainly on two principles: ownership and borrowing.</p>\n\n<p><strong>Ownership</strong></p>\n\n<p>The compiler uses an affine type system to track the ownership of each value: a value can only be used at most once, after which the compiler refuses to use it again.</p>\n\n<pre><code>fn main() {\n    let original = \"Hello, World!\".to_string();\n    let other = original;\n    println!(\"{}\", original);\n}\n</code></pre>\n\n<p>yields an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of moved value: `original`\n --&gt; src/main.rs:4:20\n  |\n3 |     let other = original;\n  |         ----- value moved here\n4 |     println!(\"{}\", original);\n  |                    ^^^^^^^^ value used here after move\n  |\n  = note: move occurs because `original` has type `std::string::String`, which does not implement the `Copy` trait\n</code></pre>\n\n<p>This, notably, prevents the dreaded <em>double-free</em> regularly encountered in C or C++ (prior to smart pointers).</p>\n\n<p><strong>Borrowing</strong></p>\n\n<p>The illumination that comes from Rust is that memory issues occur when one mixes aliasing and mutability: that is, when a single piece of memory is accessible through multiple paths and it is mutated (or moved away) leaving behind <em>dangling pointers</em>.</p>\n\n<p>The core tenet of borrow checking is therefore: <strong>Mutability XOR Aliasing</strong>. It's similar to a Read-Write Lock, in principle.</p>\n\n<p>This means that the Rust compiler tracks <em>aliasing</em> information, for which it uses the <em>lifetime annotations</em> (those <code>'a</code> in <code>&amp;'a var</code>) to connect the lifetime of references and the value they refer to together.</p>\n\n<p>A value is borrowed if someone has a reference to it or INTO it (for example, a reference to a field of a <code>struct</code> or to an element of a collection). A borrowed value cannot be moved.</p>\n\n<p><em>Mutability (without aliasing)</em></p>\n\n<p>You can obtain only a single <em>mutable reference</em> (<code>&amp;mut T</code>) into a given value at any time, and no <em>immutable reference</em> into this value may exist at the same time; it guarantees that you have exclusive access to this tidbit of memory and thus you can safely mutate it.</p>\n\n<p><em>Aliasing (without mutability)</em></p>\n\n<p>You can obtain multiple <em>immutable references</em> (<code>&amp;T</code>) into a given value at any time. However you cannot mutate anything through those references (*).</p>\n\n<p>(*) <em>I am lying; there are structs like <code>RefCell</code> which implement \"interior mutability\"; they do respect the Mutability XOR Aliasing principle, but defer the check to run-time instead.</em></p>\n\n<p><strong>That's it?</strong></p>\n\n<p>Nearly so ;)</p>\n\n<p>It is already quite complicated to implement for the compiler-writers, and may unduly constrain the users (some programs that would be safe cannot be proven safe using this system, requiring to jump through hoops), however the core principles are really that simple.</p>\n\n<p><strong>So what's left?</strong></p>\n\n<p>Bounds-checking. It is not rocket-science, but may induce a performance penalty though. Most languages have some degree of support for it, C being the big exception, and C++ having <em>some</em> support for it, although it is optional.</p>\n"}], "owner": {"reputation": 161, "user_id": 5730287, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/218da47dfaa19dd7da2562845f9d8426?s=128&d=identicon&r=PG&f=1", "display_name": "Myra", "link": "https://stackoverflow.com/users/5730287/myra"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5702, "favorite_count": 6, "accepted_answer_id": 36137381, "answer_count": 1, "score": 15, "last_activity_date": 1498402127, "creation_date": 1458576713, "last_edit_date": 1458577595, "question_id": 36136201, "link": "https://stackoverflow.com/questions/36136201/how-does-rust-guarantee-memory-safety-and-prevent-segfaults", "title": "How does Rust guarantee memory safety and prevent segfaults?", "body": "<p>I was looking for a language to learn, and I saw that Rust is getting quite popular.</p>\n\n<p>Two things impressed me about Rust, memory safety and preventing segfaults.</p>\n\n<p>How does Rust achieve this? What differences between Rust and Java for example enable Rust's safety features?</p>\n"}, {"tags": ["rust", "rust-cargo"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458575958, "post_id": 36135834, "comment_id": 59910150, "body": "Do you have the (stable) version of the Cargo/Rust release which first activated this? It would allow users using older releases knowing whether it&#39;s &quot;fixed&quot; in their release or not."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1458582177, "post_id": 36135834, "comment_id": 59914530, "body": "That&#39;s exactly my problem: my library had an old dependency that still uses wildcard dependencies. I can still publish my crate to <code>crates.io</code>, because it doesn&#39;t use wildcard dependencies directly, but only through one other crate. So with a huge dependency tree I want to check whether or not anything in this tree still uses wildcard dependencies."}], "tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 3, "last_activity_date": 1458577343, "last_edit_date": 1458577343, "creation_date": 1458575764, "answer_id": 36135834, "question_id": 36132016, "link": "https://stackoverflow.com/questions/36132016/check-for-unwanted-wildcard-dependencies-recursively/36135834#36135834", "title": "Check for unwanted wildcard dependencies recursively", "body": "<p>As of a few months back, Cargo no longer allows for wildcard dependencies. So you don't need to do this yourself.</p>\n\n<p>This is a crates.io feature, not a Rust or Cargo feature, so it's not associated with any particular version of these tools. The update happened <a href=\"http://blog.rust-lang.org/2016/01/21/Rust-1.6.html\" rel=\"nofollow\">around the time we released Rust 1.6</a>.</p>\n"}, {"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1459370116, "post_id": 36318945, "comment_id": 60261683, "body": "So... this is just checking the direct dependencies? So if my crate depends on <code>crate-a</code>, which depends on <code>crate-b</code>, which has a wildcard dependency, then: (1) <code>crate-b</code> is listed in your list (2) looking up the dependencies of my crate (namely <code>[crate-a]</code>) won&#39;t help me. Did I understand correctly? If yes, it would be awesome if you could do this recursive stuff and/or publish your script. :)"}, {"owner": {"reputation": 1706, "user_id": 4255842, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/b0d7dfd98472547776f7d23112d000f5?s=128&d=identicon&r=PG&f=1", "display_name": "Pyfisch", "link": "https://stackoverflow.com/users/4255842/pyfisch"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1459370864, "post_id": 36318945, "comment_id": 60262123, "body": "You have to check all dependencies mentioned in &quot;Cargo.lock&quot;. The initial text had a typo that said &quot;Cargo.toml&quot;. But this only works if all dependencies use up-to-date dependencies. :-("}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1459371162, "post_id": 36318945, "comment_id": 60262293, "body": "Ah ok, that makes sense I guess. Could you still post your script? I would certainly be interested in it. Also: I think I will ping the <a href=\"https://github.com/kbknapp/cargo-outdated\" rel=\"nofollow noreferrer\">cargo-outdated</a> guys and ask if they want to integrate this feature..."}, {"owner": {"reputation": 1706, "user_id": 4255842, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/b0d7dfd98472547776f7d23112d000f5?s=128&d=identicon&r=PG&f=1", "display_name": "Pyfisch", "link": "https://stackoverflow.com/users/4255842/pyfisch"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 1, "creation_date": 1459371961, "post_id": 36318945, "comment_id": 60262749, "body": "Here is the <a href=\"https://gist.github.com/pyfisch/a535fec885dd4efb2f77b4c4fd6ebd3b\" rel=\"nofollow noreferrer\">script that generated the list</a>. The cargo-outdated people can probably better implement it since doing it properly requires knowledge of semver to determine the correct version of all dependencies."}], "tags": [], "owner": {"reputation": 1706, "user_id": 4255842, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/b0d7dfd98472547776f7d23112d000f5?s=128&d=identicon&r=PG&f=1", "display_name": "Pyfisch", "link": "https://stackoverflow.com/users/4255842/pyfisch"}, "is_accepted": true, "score": 3, "last_activity_date": 1459370270, "last_edit_date": 1459370270, "creation_date": 1459369240, "answer_id": 36318945, "question_id": 36132016, "link": "https://stackoverflow.com/questions/36132016/check-for-unwanted-wildcard-dependencies-recursively/36318945#36318945", "title": "Check for unwanted wildcard dependencies recursively", "body": "<p>I have written a small script that takes the <a href=\"https://github.com/rust-lang/crates.io-index\" rel=\"nofollow\">crates.io-index</a> and reads the current information for all packages. If a package has a direct wildcard dependency on another package there is a line printed in the format <code>crate-name -&gt; wildcard-dependency, another-one</code>.</p>\n\n<p>There are <a href=\"https://gist.github.com/pyfisch/563c6e64b57492c92bf399a495064660\" rel=\"nofollow\">995 current packages with wildcard dependencies</a>. The list is exhaustive and will only decrease in length if the packages are updated.</p>\n\n<p>You can go manually through all dependencies in your Cargo.lock and check if they are mentioned in the list. Note that you must use the most current version of your dependencies to assure that you are not depending on an outdated package with wildcard dependencies.</p>\n"}], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 215, "favorite_count": 0, "accepted_answer_id": 36318945, "answer_count": 2, "score": 6, "last_activity_date": 1459370270, "creation_date": 1458565965, "last_edit_date": 1459168675, "question_id": 36132016, "link": "https://stackoverflow.com/questions/36132016/check-for-unwanted-wildcard-dependencies-recursively", "title": "Check for unwanted wildcard dependencies recursively", "body": "<p>I have a library and want to make sure that none of the dependencies in my dependency-tree uses wildcard dependencies. Wildcard dependencies are evil :(</p>\n\n<p>Can I check this recursively with <code>cargo</code> in the command line? Or can I check it manually in <code>Cargo.lock</code>?</p>\n\n<p><strong>EDIT</strong>: While <code>crates.io</code> rejects crates with wildcard dependencies since the release Rust 1.6 (<a href=\"http://blog.rust-lang.org/2016/01/21/Rust-1.6.html\" rel=\"nofollow\">approximately</a>, thanks Steve Klabnik), there are still old crates on <code>crates.io</code> that <em>do</em> have wildcard dependencies. I can upload my own crate that depends on such an old crate. Therefore my crate indirectly also depends on wildcard dependencies. This is what I want to avoid and check for.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": true, "score": 2, "last_activity_date": 1458559913, "creation_date": 1458559913, "answer_id": 36129910, "question_id": 36123041, "link": "https://stackoverflow.com/questions/36123041/any-way-to-give-a-file-descriptor-to-a-child-process-without-closing-it/36129910#36129910", "title": "Any way to give a file descriptor to a child process, without closing it?", "body": "<p>There is currently no better solution, alas. However, the correct solution would be a <code>Command::into_io(self) -&gt; (Option&lt;StdIo&gt;, Option&lt;StdIo&gt;, Option&lt;StdIo&gt;)</code> method that deconstructs the <code>Command</code> to return stdin, stdout and stderr, if available.</p>\n\n<p>I've filed an <a href=\"https://github.com/rust-lang/rust/issues/32394\" rel=\"nofollow\">issue</a> to add that function.</p>\n"}], "owner": {"reputation": 7971, "user_id": 823869, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/0e7b6173470ead2fe170d55b317a9b1d?s=128&d=identicon&r=PG", "display_name": "Jack O&#39;Connor", "link": "https://stackoverflow.com/users/823869/jack-oconnor"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 147, "favorite_count": 0, "accepted_answer_id": 36129910, "answer_count": 1, "score": 4, "last_activity_date": 1458559913, "creation_date": 1458533788, "last_edit_date": 1458558804, "question_id": 36123041, "link": "https://stackoverflow.com/questions/36123041/any-way-to-give-a-file-descriptor-to-a-child-process-without-closing-it", "title": "Any way to give a file descriptor to a child process, without closing it?", "body": "<p>The <a href=\"https://doc.rust-lang.org/std/process/struct.Stdio.html\" rel=\"nofollow\"><code>Stdio</code></a> type implements <code>FromRawFd</code>, which lets me build one out of any file descriptor. (In my case, I want to use pipes.) That's exactly what I need, but my problem is that the <code>stdin()</code>/<code>stdout()</code>/<code>stderr()</code> methods take their <code>Stdio</code> argument by value. That means that when the <code>Command</code> object goes out of scope, all its fd's get closed. Is there any way to give an fd to a child process sort of by reference, so that it's still available in the parent process after the child is done? Right now I've settled for just calling <code>libc::dup()</code> for each child, which doesn't seem great.</p>\n"}, {"tags": ["go", "rust"], "comments": [{"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 14, "creation_date": 1458516201, "post_id": 36120811, "comment_id": 59881933, "body": "The Rust code will be significantly faster if you compile with optimisations: <code>rustc -O parity.rs</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458518288, "post_id": 36120811, "comment_id": 59882441, "body": "Compiling with optimizations is described in the <a href=\"http://doc.rust-lang.org/stable/book/getting-started.html\" rel=\"nofollow noreferrer\">Getting Started</a> section of <a href=\"http://doc.rust-lang.org/stable/book/README.html\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i></a>, the section immediately after the 1-page introduction."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 7, "creation_date": 1458522357, "post_id": 36120811, "comment_id": 59883475, "body": "I get it taking 3 seconds unoptimised and 0.45 seconds optimised in Rust, and 0.6 seconds in Go."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 5, "creation_date": 1458523575, "post_id": 36120811, "comment_id": 59883709, "body": "For what it&#39;s worth, I&#39;d recommend using the built-in <a href=\"http://doc.rust-lang.org/std/primitive.i64.html#method.count_ones\" rel=\"nofollow noreferrer\"><code>count_ones</code></a> method. Looks <a href=\"http://is.gd/tjLsyF\" rel=\"nofollow noreferrer\">like this</a>."}, {"owner": {"reputation": 627, "user_id": 1932023, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6fac0b138f6450a33f88a08e89109150?s=128&d=identicon&r=PG", "display_name": "Alex Chekunkov", "link": "https://stackoverflow.com/users/1932023/alex-chekunkov"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458563207, "post_id": 36120811, "comment_id": 59900557, "body": "@Shepmaster thanks for the suggestion, good to know!"}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1458522670, "post_id": 36121578, "comment_id": 59883545, "body": "While interesting, this doesn&#39;t answer the question OP asked: <i>Why do the Rust and Go programs I&#39;ve written have such a dramatic difference in performance</i>. This seems like it would be better as a comment on the question about the methodology of the benchmarking. Both Go and Rust versions are measuring code that performs the same functions."}, {"owner": {"reputation": 133115, "user_id": 221700, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad32856042eea9fd2db5210ac033787d?s=128&d=identicon&r=PG", "display_name": "peterSO", "link": "https://stackoverflow.com/users/221700/peterso"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 4, "creation_date": 1458523509, "post_id": 36121578, "comment_id": 59883693, "body": "@Shepmaster: The OPs implicit question was why a &quot;brute-force parity check for 64-bit unsigned integers&quot; has such a dramatic difference in performance between Rust and Go. To paraphrase, there are lies, damn lies, and benchmarks."}, {"owner": {"reputation": 627, "user_id": 1932023, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6fac0b138f6450a33f88a08e89109150?s=128&d=identicon&r=PG", "display_name": "Alex Chekunkov", "link": "https://stackoverflow.com/users/1932023/alex-chekunkov"}, "edited": false, "score": 1, "creation_date": 1458562964, "post_id": 36121578, "comment_id": 59900375, "body": "@peterSO &quot;The OPs implicit question was why a &quot;brute-force parity check for 64-bit unsigned integers&quot; has such a dramatic difference in performance between Rust and Go&quot; Just no."}], "tags": [], "owner": {"reputation": 133115, "user_id": 221700, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad32856042eea9fd2db5210ac033787d?s=128&d=identicon&r=PG", "display_name": "peterSO", "link": "https://stackoverflow.com/users/221700/peterso"}, "is_accepted": false, "score": 0, "last_activity_date": 1458522339, "last_edit_date": 1458522339, "creation_date": 1458521866, "answer_id": 36121578, "question_id": 36120811, "link": "https://stackoverflow.com/questions/36120811/why-is-my-rust-program-4x-slower-than-a-go-program-doing-the-same-bitwise-and-i/36121578#36121578", "title": "Why is my Rust program 4x slower than a Go program doing the same bitwise and I/O operations?", "body": "<p>Your benchmark doesn't measure the parity check. It measures input plus parity check plus output. For example, in Go, you measure <code>scanner.Scan</code> and <code>strconv.ParseUint</code> and <code>fmt.Println</code> as well as the parity check. </p>\n\n<p>Here's a Go benchmark that just measures 1000000 parity checks.</p>\n\n<p><code>parity_test.go</code>:</p>\n\n<pre><code>package parity\n\nimport (\n    \"math/rand\"\n    \"runtime\"\n    \"testing\"\n)\n\nfunc parity(n uint64) uint64 {\n    var parity uint64\n    for n &gt; 0 {\n        parity ^= n &amp; 1\n        n &gt;&gt;= 1\n    }\n    return parity\n}\n\nfunc init() { runtime.GOMAXPROCS(1) }\n\n// Benchmark 1000000 parity checks.\nfunc BenchmarkParity1000000(b *testing.B) {\n    n := make([]uint64, 1000000)\n    for i := range n {\n        r := uint64(rand.Uint32())\n        n[i] = (r &lt;&lt; 32) | r\n    }\n    p := parity(42)\n    b.ResetTimer()\n    for i := 0; i &lt; b.N; i++ {\n        for _, n := range n {\n            p = parity(n)\n        }\n    }\n    b.StopTimer()\n    _ = p\n}\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>$ go test -bench=.\nBenchmarkParity1000000        50      34586769 ns/op\n$\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 627, "user_id": 1932023, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6fac0b138f6450a33f88a08e89109150?s=128&d=identicon&r=PG", "display_name": "Alex Chekunkov", "link": "https://stackoverflow.com/users/1932023/alex-chekunkov"}, "edited": false, "score": 0, "creation_date": 1458563397, "post_id": 36124361, "comment_id": 59900705, "body": "You&#39;re so right, thanks! For others who will read this - there&#39;s another way to set optimization level - <code>rustc -C opt-level=3 parity.rs</code>, and <code>-O</code> is a shortcut for <code>-C opt-level=2</code>."}, {"owner": {"reputation": 1343, "user_id": 4365239, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/88acc4986ddaf51e21c254fb8c0f11b8?s=128&d=identicon&r=PG&f=1", "display_name": "tafia", "link": "https://stackoverflow.com/users/4365239/tafia"}, "reply_to_user": {"reputation": 627, "user_id": 1932023, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6fac0b138f6450a33f88a08e89109150?s=128&d=identicon&r=PG", "display_name": "Alex Chekunkov", "link": "https://stackoverflow.com/users/1932023/alex-chekunkov"}, "edited": false, "score": 0, "creation_date": 1458788817, "post_id": 36124361, "comment_id": 60019694, "body": "you can also use <code>cargo build --release</code>, I find it more convenient than rustc"}], "tags": [], "owner": {"reputation": 1343, "user_id": 4365239, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/88acc4986ddaf51e21c254fb8c0f11b8?s=128&d=identicon&r=PG&f=1", "display_name": "tafia", "link": "https://stackoverflow.com/users/4365239/tafia"}, "is_accepted": true, "score": 5, "last_activity_date": 1458541159, "creation_date": 1458541159, "answer_id": 36124361, "question_id": 36120811, "link": "https://stackoverflow.com/questions/36120811/why-is-my-rust-program-4x-slower-than-a-go-program-doing-the-same-bitwise-and-i/36124361#36124361", "title": "Why is my Rust program 4x slower than a Go program doing the same bitwise and I/O operations?", "body": "<p>I think you're not compiling with optimisation.\ntry </p>\n\n<pre><code>$ rustc -O parity.rs\n</code></pre>\n"}], "owner": {"reputation": 627, "user_id": 1932023, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/6fac0b138f6450a33f88a08e89109150?s=128&d=identicon&r=PG", "display_name": "Alex Chekunkov", "link": "https://stackoverflow.com/users/1932023/alex-chekunkov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 707, "favorite_count": 1, "closed_date": 1458563835, "accepted_answer_id": 36124361, "answer_count": 2, "score": 0, "last_activity_date": 1458541159, "creation_date": 1458515663, "last_edit_date": 1458518182, "question_id": 36120811, "link": "https://stackoverflow.com/questions/36120811/why-is-my-rust-program-4x-slower-than-a-go-program-doing-the-same-bitwise-and-i", "closed_reason": "Duplicate", "title": "Why is my Rust program 4x slower than a Go program doing the same bitwise and I/O operations?", "body": "<p>I have a Rust program that implements a brute-force parity check for 64-bit unsigned integers:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::io;\nuse std::io::BufRead;\n\nfn parity(mut num: u64) -&gt; u8 {\n    let mut result: u8 = 0;\n    while num &gt; 0 {\n        result = result ^ (num &amp; 1) as u8;\n        num = num &gt;&gt; 1;\n    }\n    result\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut num: u64;\n    let mut it = stdin.lock().lines();\n    // skip 1st line with number of test cases\n    it.next();\n    for line in it {\n        num = line.unwrap().parse().unwrap();\n        println!(\"{}\", parity(num));\n    }\n}\n</code></pre>\n\n<p>When I feed it with input file containing 1000000 unsigned integers:</p>\n\n<pre><code>$ rustc parity.rs\n$ time cat input.txt | ./parity &amp;&gt; /dev/null\ncat input.txt  0.00s user 0.02s system 0% cpu 4.178 total\n./parity &amp;&gt; /dev/null  3.87s user 0.32s system 99% cpu 4.195 total\n</code></pre>\n\n<p>And here comes a surprise - the effectively same program in Go does 4x faster:</p>\n\n<pre><code>$ go build parity.go\n$ time cat input.txt | ./parity &amp;&gt; /dev/null\ncat input.txt  0.00s user 0.03s system 3% cpu 0.952 total\n./parity &amp;&gt; /dev/null  0.63s user 0.32s system 99% cpu 0.955 total\n</code></pre>\n\n<p>Here's the code in Go:</p>\n\n<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n)\n\nfunc parity(line string) uint64 {\n    var parity uint64\n    u, err := strconv.ParseUint(line, 10, 64)\n    if err != nil {\n        panic(err)\n    }\n    for u &gt; 0 {\n        parity ^= u &amp; 1\n        u &gt;&gt;= 1\n    }\n    return parity\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    // skip line with number of cases\n    if !scanner.Scan() {\n        // panic if there's no number of test cases\n        panic(\"missing number of test cases\")\n    }\n    for scanner.Scan() {\n        fmt.Println(parity(scanner.Text()))\n    }\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintln(os.Stderr, \"reading standard input:\", err)\n    }\n}\n</code></pre>\n\n<p>Versions:</p>\n\n<pre><code>$ rustc --version\nrustc 1.7.0\n$ go version\ngo version go1.6 darwin/amd64\n</code></pre>\n\n<p>Sample of input file, first line contains number of input values in the file:</p>\n\n<pre><code>8\n7727369244898783789\n2444477357490019411\n4038350233697550492\n8106226119927945594\n1538904728446207070\n0\n1\n18446744073709551615\n</code></pre>\n\n<p>Why do the Rust and Go programs I've written have such a dramatic difference in performance? I expected Rust to be a bit faster than Go in this case. Am I doing something wrong in my Rust code?</p>\n"}, {"tags": ["multithreading", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1458518047, "post_id": 36119811, "comment_id": 59882390, "body": "There are <b>many</b> questions about dividing processing of slices / vectors to multiple threads. I found <a href=\"http://stackoverflow.com/q/28599334/155423\">this one</a>, <a href=\"http://stackoverflow.com/q/33818141/155423\">this one</a>, and <a href=\"http://stackoverflow.com/q/31644152/155423\">this one</a> with a small amount of searching."}], "answers": [{"comments": [{"owner": {"reputation": 2372, "user_id": 5039582, "user_type": "registered", "accept_rate": 29, "profile_image": "https://www.gravatar.com/avatar/2753151bbe8511e6705d432533cef910?s=128&d=identicon&r=PG&f=1", "display_name": "Mandragor", "link": "https://stackoverflow.com/users/5039582/mandragor"}, "edited": false, "score": 0, "creation_date": 1458511303, "post_id": 36120067, "comment_id": 59880424, "body": "Thanks that works great!. I have no idea, what you are doing, but hey  i am going to look it up and learn ;)"}], "tags": [], "owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "is_accepted": false, "score": 3, "last_activity_date": 1458511786, "last_edit_date": 1458511786, "creation_date": 1458510780, "answer_id": 36120067, "question_id": 36119811, "link": "https://stackoverflow.com/questions/36119811/pass-a-matrix-vecvecf64-readonly-to-multiple-threads/36120067#36120067", "title": "Pass a matrix (Vec&lt;Vec&lt;f64&gt;&gt;) readonly to multiple threads", "body": "<p>Wrap the object to be shared into an <code>Arc</code> which stands for atomically reference counted (pointer). For each thread, clone this pointer and pass ownership of the clone to the thread. The wrapped object will be deallocated when it's no longer used by anything.</p>\n\n<pre><code>fn process(matrix: &amp;Vec&lt;Vec&lt;f64&gt;&gt;) {\n    // do nothing for now\n}\n\nfn test() {\n    use std::sync::Arc;\n    let filename = \"matrix.tsv\";\n    // loads matrix into a Vec&lt;Vec&lt;f64&gt;&gt;\n    let mut matrix = Arc::new(load_matrix(filename));\n\n    // Determine number of cpus\n    let ncpus = num_cpus::get();\n    println!(\"Number of cpus on this machine: {}\", ncpus);\n    for i in 0..ncpus {\n        let matrix = matrix.clone();\n        let _ = thread::spawn(move || {\n            println!(\"Thread number: {}\", i);\n            process(&amp;matrix);\n        });\n    }\n    let d = Duration::from_millis(1000 * 1000);\n    thread::sleep(d);\n}\n</code></pre>\n"}], "owner": {"reputation": 2372, "user_id": 5039582, "user_type": "registered", "accept_rate": 29, "profile_image": "https://www.gravatar.com/avatar/2753151bbe8511e6705d432533cef910?s=128&d=identicon&r=PG&f=1", "display_name": "Mandragor", "link": "https://stackoverflow.com/users/5039582/mandragor"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 315, "favorite_count": 0, "answer_count": 1, "score": 2, "last_activity_date": 1458517869, "creation_date": 1458509184, "last_edit_date": 1458517869, "question_id": 36119811, "link": "https://stackoverflow.com/questions/36119811/pass-a-matrix-vecvecf64-readonly-to-multiple-threads", "title": "Pass a matrix (Vec&lt;Vec&lt;f64&gt;&gt;) readonly to multiple threads", "body": "<p>I am new to Rust and I am struggling with the concept of borrowing.</p>\n\n<p>I want to load a <code>Vec&lt;Vec&lt;f64&gt;&gt;</code> matrix and then process it in parallel. However when I try to compile this piece of code I get <code>error: capture of moved value: `matrix` [E0382]</code> at the <code>let _ =</code> line.</p>\n\n<p>This matrix is supposed to be readonly for the threads, they won't modify it. How can I pass it readonly and make the \"moved value\" error go away?</p>\n\n<pre><code>fn process(matrix: &amp;Vec&lt;Vec&lt;f64&gt;&gt;) {\n    // do nothing for now\n}\n\nfn test() {\n    let filename = \"matrix.tsv\";\n    // loads matrix into a Vec&lt;Vec&lt;f64&gt;&gt;\n    let mut matrix = load_matrix(filename);\n\n    // Determine number of cpus\n    let ncpus = num_cpus::get();\n    println!(\"Number of cpus on this machine: {}\", ncpus);\n    for i in 0..ncpus {\n        // In the next line the \"error: capture of moved value: matrix\" happens\n        let _ = thread::spawn(move || {\n            println!(\"Thread number: {}\", i);\n            process(&amp;matrix);\n        });\n    }\n    let d = Duration::from_millis(1000 * 1000);\n    thread::sleep(d);\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "edited": false, "score": 2, "creation_date": 1458503360, "post_id": 36118565, "comment_id": 59877553, "body": "Try to change <code>match self.hash.get(&amp;id) {</code> into <code>match self.hash.get(&amp;id).cloned() {</code> and <code>*value</code> to <code>value</code>"}, {"owner": {"reputation": 2481, "user_id": 327786, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/ZmpBr.jpg?s=128&g=1", "display_name": "TlmaK0", "link": "https://stackoverflow.com/users/327786/tlmak0"}, "reply_to_user": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "edited": false, "score": 0, "creation_date": 1458503566, "post_id": 36118565, "comment_id": 59877633, "body": "Thanks, it has a lot of sense. It works!!"}, {"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "edited": false, "score": 1, "creation_date": 1458504081, "post_id": 36118565, "comment_id": 59877815, "body": "That&#39;s because <code>get</code> returns <code>Option&lt;&amp;u32&gt;</code> but you actually don&#39;t need that borrowed reference but only value. So <code>cloned()</code> transforms <code>Option&lt;&amp;T&gt;</code> into <code>Option&lt;T&gt;</code> and releases borrow."}, {"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 3, "creation_date": 1458509677, "post_id": 36118565, "comment_id": 59879860, "body": "There is a better idiom for what you are trying to do, <code>.entry().or_insert()</code>: <a href=\"https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.entry\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/collections/hash_map/&hellip;</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1458517662, "post_id": 36118565, "comment_id": 59882287, "body": "<a href=\"http://stackoverflow.com/q/28512394/155423\"><b>Highly</b> relevant</a>."}], "answers": [{"comments": [{"owner": {"reputation": 13057, "user_id": 729541, "user_type": "registered", "accept_rate": 96, "profile_image": "https://www.gravatar.com/avatar/9c8f35ef59003de814a4bca351071045?s=128&d=identicon&r=PG", "display_name": "John H", "link": "https://stackoverflow.com/users/729541/john-h"}, "edited": false, "score": 0, "creation_date": 1534194510, "post_id": 36118804, "comment_id": 90615501, "body": "Thank you so much for this. I thought I was going crazy."}], "tags": [], "owner": {"reputation": 2231, "user_id": 4465497, "user_type": "registered", "accept_rate": 89, "profile_image": "https://i.stack.imgur.com/vibwv.png?s=128&g=1", "display_name": "XAMPPRocky", "link": "https://stackoverflow.com/users/4465497/xampprocky"}, "is_accepted": true, "score": 8, "last_activity_date": 1583847512, "last_edit_date": 1583847512, "creation_date": 1458504041, "answer_id": 36118804, "question_id": 36118565, "link": "https://stackoverflow.com/questions/36118565/cannot-borrow-self-hash-as-mutable-because-it-is-also-borrowed-as-immutable/36118804#36118804", "title": "cannot borrow `self.hash` as mutable because it is also borrowed as immutable", "body": "<h1>Update</h1>\n\n<p>With the addition of <a href=\"https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes\" rel=\"nofollow noreferrer\">Non-Lexical Lifetimes</a> in Rust, this problem should no longer be an issue if you're using <a href=\"https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06\" rel=\"nofollow noreferrer\">1.31.0</a> with Rust 2018 edition and <a href=\"https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1360-2019-07-04\" rel=\"nofollow noreferrer\">1.36.0</a> with Rust 2015 edition.</p>\n\n<h1>Original Answer</h1>\n\n<p>This is a problem with the current state of Rust, where borrows are always lexical. That is, they last the entire <code>{}</code> or block scope. In a <code>match</code> expression, the borrow performed on <code>self</code> continues into the <code>Some</code> and <code>None</code> blocks. The simplest way to solve this problem is to use an <code>if let</code> statement. It provides pattern matching, and allows you to use <code>self</code> in both blocks.</p>\n\n<h1><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=a89a382b24ad89cdbc95810cf1e76215\" rel=\"nofollow noreferrer\">Code</a></h1>\n\n<pre><code>use std::collections::HashMap;\n\nstruct Test1 {\n    total: u32,\n    hash: HashMap&lt;u32, u32&gt;,\n}\n\nimpl Test1 {\n    fn new() -&gt; Test1 {\n        Test1 {\n            total: 0,\n            hash: HashMap::new(),\n        }\n    }\n\n    fn add(&amp;mut self) -&gt; u32 {\n        self.total += 1;\n        self.total\n    }\n\n    fn get_or_create(&amp;mut self, id: u32) -&gt; u32 {\n        if let Some(&amp;value) = self.hash.get(&amp;id) {\n            value\n        } else {\n            let value = self.add();\n            self.hash.insert(id, value);\n            value\n        }\n    }\n}\n\nfn main() {\n    let mut test = Test1::new();\n    println!(\"{:?}\", test.get_or_create(1));\n    println!(\"{:?}\", test.get_or_create(1));\n}\n</code></pre>\n"}], "owner": {"reputation": 2481, "user_id": 327786, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/ZmpBr.jpg?s=128&g=1", "display_name": "TlmaK0", "link": "https://stackoverflow.com/users/327786/tlmak0"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1413, "favorite_count": 0, "closed_date": 1504488995, "accepted_answer_id": 36118804, "answer_count": 1, "score": 4, "last_activity_date": 1583847512, "creation_date": 1458502738, "last_edit_date": 1458517588, "question_id": 36118565, "link": "https://stackoverflow.com/questions/36118565/cannot-borrow-self-hash-as-mutable-because-it-is-also-borrowed-as-immutable", "closed_reason": "Duplicate", "title": "cannot borrow `self.hash` as mutable because it is also borrowed as immutable", "body": "<p>I'm trying to make this work </p>\n\n<pre><code>use std::collections::HashMap;\n\nstruct Test1 {\n    total: u32,\n    hash: HashMap&lt;u32, u32&gt;,\n}\n\nimpl Test1 {\n    fn new() -&gt; Test1 {\n        Test1 {\n            total: 0,\n            hash: HashMap::new(),\n        }\n    }\n\n    fn add(&amp;mut self) -&gt; u32 {\n        self.total += 1;\n        self.total\n    }\n\n    fn get_or_create(&amp;mut self, id: u32) -&gt; u32 {\n        match self.hash.get(&amp;id) {\n            Some(value) =&gt; *value,\n            None =&gt; {\n                let value = self.add();\n                self.hash.insert(id, value);\n                value\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut test = Test1::new();\n    println!(\"{:?}\", test.get_or_create(1));\n    println!(\"{:?}\", test.get_or_create(1));\n}\n</code></pre>\n\n<p>(playpen)[<a href=\"http://is.gd/hDLEaL]\" rel=\"nofollow\">http://is.gd/hDLEaL]</a></p>\n\n<p>but I get </p>\n\n<pre><code>&lt;anon&gt;:25:33: 25:37 error: cannot borrow `*self` as mutable because `self.hash` is also borrowed as immutable [E0502]\n</code></pre>\n\n<p>removing pattern matching doesn't address the problem, but I don't understand why.</p>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": false, "score": 1, "last_activity_date": 1458507236, "creation_date": 1458507236, "answer_id": 36119455, "question_id": 36117966, "link": "https://stackoverflow.com/questions/36117966/why-does-my-trait-need-a-lifetime-parameter/36119455#36119455", "title": "Why does my trait need a lifetime parameter?", "body": "<p>Lifetime elision works only in very simple cases. This makes them weak, but easy to explain (also simple cases are surprisingly common).</p>\n\n<p>As soon as you have a generic lifetime parameter, elision no longer applies \u2013 the compiler refuses to guess your intention.</p>\n"}, {"comments": [{"owner": {"reputation": 53, "user_id": 1427088, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/48c1e51825df1b5b64fb1c6740e101b7?s=128&d=identicon&r=PG", "display_name": "Olaf Bergner", "link": "https://stackoverflow.com/users/1427088/olaf-bergner"}, "edited": false, "score": 0, "creation_date": 1458545349, "post_id": 36120253, "comment_id": 59890017, "body": "Thank you, Djzin, this answer has the ring of truth, although I do not fully understand it. I will need some time to think about it. Don&#39;t be surprised if I get back to you with more questions. One I already have: if the Rust community says &quot;mutable reference&quot; does it really mean &quot;(immutable) reference to a mutable value&quot;?"}, {"owner": {"reputation": 53, "user_id": 1427088, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/48c1e51825df1b5b64fb1c6740e101b7?s=128&d=identicon&r=PG", "display_name": "Olaf Bergner", "link": "https://stackoverflow.com/users/1427088/olaf-bergner"}, "edited": false, "score": 0, "creation_date": 1458585531, "post_id": 36120253, "comment_id": 59916567, "body": "I accepted your answer because I believe I now almost fully understand your reasoning:"}, {"owner": {"reputation": 53, "user_id": 1427088, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/48c1e51825df1b5b64fb1c6740e101b7?s=128&d=identicon&r=PG", "display_name": "Olaf Bergner", "link": "https://stackoverflow.com/users/1427088/olaf-bergner"}, "edited": false, "score": 0, "creation_date": 1458586572, "post_id": 36120253, "comment_id": 59917136, "body": "I accepted your answer because I believe I now almost fully understand your reasoning: a reference to <code>MQTTFrameDecoder</code> is - by transitivity - a <i>mutable</i> reference to the vector <code>payload</code>. Likewise, a reference to <code>MQTTFrame</code> is a reference to the same vector <code>payload</code>. The code you presented would lead - through scope widening - to a situation where a mutable and a distinct immutable reference - <code>decoder</code> and <code>frame</code> - were in scope. Which is forbidden. Correct?"}, {"owner": {"reputation": 53, "user_id": 1427088, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/48c1e51825df1b5b64fb1c6740e101b7?s=128&d=identicon&r=PG", "display_name": "Olaf Bergner", "link": "https://stackoverflow.com/users/1427088/olaf-bergner"}, "edited": false, "score": 0, "creation_date": 1458586657, "post_id": 36120253, "comment_id": 59917185, "body": "I wonder what rule the compiler employs to reach this conclusion. I doubt that it uses some kind of speculative data flow analysis to essentially do what you did, namely construct a counter example. In the original test case you presented, when the compiler sees <code>MQTTFrame{ payload: self.payload }</code> there is lifetime <code>&#39;b</code> assigned to <code>self.payload</code> and lifetime <code>&#39;a</code> assigned to the <code>MQTTFrame</code> about to be constructed - and hence to that frame&#39;s <code>payload</code>. And probably that is what the compiler complains about: that lifetime needs to be uniquely determined. Correct?"}, {"owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "reply_to_user": {"reputation": 53, "user_id": 1427088, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/48c1e51825df1b5b64fb1c6740e101b7?s=128&d=identicon&r=PG", "display_name": "Olaf Bergner", "link": "https://stackoverflow.com/users/1427088/olaf-bergner"}, "edited": false, "score": 0, "creation_date": 1458600934, "post_id": 36120253, "comment_id": 59924235, "body": "&quot;A reference to <code>MQTTFrameDecoder</code> is - by transitivity - a mutable reference to the vector <code>payload</code>&quot; - this is correct. However, it is not correct that the compiler needs the lifetime to be &quot;uniquely determined&quot;. It just needs <i>some</i> lifetime to work. The static rules in place see a type with lifetime <code>&#39;b</code> (arbitrarily short) trying to coerce into a type with lifetime <code>&#39;a</code>. If <code>&#39;b : &#39;a</code> (b lives at least as long as a) or <code>&#39;b = &#39;a</code> then there is no problem. Compare the examples <a href=\"https://play.rust-lang.org/?gist=84758e66a70d87b02aa5&amp;version=stable\" rel=\"nofollow noreferrer\">here</a>."}, {"owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "reply_to_user": {"reputation": 53, "user_id": 1427088, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/48c1e51825df1b5b64fb1c6740e101b7?s=128&d=identicon&r=PG", "display_name": "Olaf Bergner", "link": "https://stackoverflow.com/users/1427088/olaf-bergner"}, "edited": false, "score": 0, "creation_date": 1458601544, "post_id": 36120253, "comment_id": 59924458, "body": "&quot;If the Rust community says &quot;mutable reference&quot; does it really mean &quot;(immutable) reference to a mutable value&quot;&quot; - yes exactly. &quot;Mutable reference to t&quot; is declared <code>let x = &amp;mut t;</code> and if the type of <code>t</code> is <code>T</code>, <code>x</code> has type <code>&amp;&#39;a mut T</code>. A reference that can be mutated depends on the <i>binding</i> and is declared <code>let mut x = &amp;t</code>. <code>x</code> here has type <code>&amp;&#39;a T</code>, so it is not a &quot;mutable reference&quot;, even though it is a reference that is mutable."}, {"owner": {"reputation": 53, "user_id": 1427088, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/48c1e51825df1b5b64fb1c6740e101b7?s=128&d=identicon&r=PG", "display_name": "Olaf Bergner", "link": "https://stackoverflow.com/users/1427088/olaf-bergner"}, "edited": false, "score": 0, "creation_date": 1458603668, "post_id": 36120253, "comment_id": 59925127, "body": "Great clarification of the static lifetime rule enforced by the compiler here, much appreciated. It&#39;s beginning to make sense to me."}, {"owner": {"reputation": 53, "user_id": 1427088, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/48c1e51825df1b5b64fb1c6740e101b7?s=128&d=identicon&r=PG", "display_name": "Olaf Bergner", "link": "https://stackoverflow.com/users/1427088/olaf-bergner"}, "edited": false, "score": 0, "creation_date": 1458603814, "post_id": 36120253, "comment_id": 59925184, "body": "I strongly suspected that &quot;mutable reference&quot; had this meaning in Rust. That sums things up nicely, thanks."}], "tags": [], "owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "is_accepted": true, "score": 4, "last_activity_date": 1458512583, "last_edit_date": 1458512583, "creation_date": 1458511825, "answer_id": 36120253, "question_id": 36117966, "link": "https://stackoverflow.com/questions/36117966/why-does-my-trait-need-a-lifetime-parameter/36120253#36120253", "title": "Why does my trait need a lifetime parameter?", "body": "<p>Here's a reduced testcase that fails to compile (<a href=\"http://is.gd/EQaNvB\" rel=\"nofollow\">playpen</a>):</p>\n\n<pre><code>pub trait Decode&lt;T&gt; {\n    fn decode_from&lt;'b&gt;(&amp;'b mut self) -&gt; T;\n}\n\npub struct MQTTFrame&lt;'a&gt; {\n    pub payload: &amp;'a Vec&lt;u8&gt;,\n}\n\npub struct MQTTFrameDecoder&lt;'a&gt; {\n    pub payload: &amp;'a mut Vec&lt;u8&gt;,\n}\n\nimpl&lt;'a&gt; Decode&lt;MQTTFrame&lt;'a&gt;&gt; for MQTTFrameDecoder&lt;'a&gt; {\n    fn decode_from&lt;'b&gt;(&amp;'b mut self) -&gt; MQTTFrame&lt;'a&gt; {\n        MQTTFrame{ payload: self.payload }\n    }\n}\n</code></pre>\n\n<p>Note that I have <a href=\"http://doc.rust-lang.org/book/lifetimes.html#lifetime-elision\" rel=\"nofollow\">elided the lifetimes</a> for the <code>decode_from</code> function and removed the redundant stream parameter.</p>\n\n<p>It is clear then that the function is taking a reference with an arbitrarily short lifetime <code>'b</code>, and then extending it to have lifetime <code>'a</code>. This is a problem with mutable references as then you can borrow something mutably and immutably at the same time:</p>\n\n<pre><code>fn main() {\n    let mut v = vec![];\n    /* lifetime 'a */ {\n        let mut decoder = MQTTFrameDecoder{ payload: &amp;mut v };\n        let frame: MQTTFrame;\n        /* lifetime 'b */ {\n            frame = decoder.decode_from(); // borrows decoder just for lifetime 'b\n        }\n        // v is mutably borrowed (by decoder) and immutably borrowed (by frame) at the same time! oops!\n        decoder.payload.push(1);\n        println!(\"{:?}\", frame.payload);\n    }\n}\n</code></pre>\n\n<p>For this reason the borrow checker refuses to let the function compile.</p>\n\n<p>If you force the reference to <code>decoder</code> to have lifetime <code>'a</code>, though, then there is no longer a problem. The compiler cannot use the reference with the shorter lifetime, it must mutably borrow <code>decoder</code> for longer, and so the compiler should give us an error when we try to borrow it again.</p>\n\n<p>In order to achieve this, we would like to write</p>\n\n<pre><code>fn decode_from(&amp;'a mut self) -&gt; MQTTFrame&lt;'a&gt; {\n    MQTTFrame{ payload: self.payload }\n}\n</code></pre>\n\n<p>But now we get an error:</p>\n\n<pre><code>&lt;anon&gt;:14:5: 16:6 error: method `decode_from` has an incompatible type for trait:\n expected bound lifetime parameter 'b,\n    found concrete lifetime [E0053]\n</code></pre>\n\n<p>To fix this, we need to have our trait be aware that you can only <code>decode_from</code> certain lifetimes, not arbitrary ones. So change decode to</p>\n\n<pre><code>pub trait Decode&lt;'a, T&gt; {\n    fn decode_from(&amp;'a mut self) -&gt; T;\n}\n</code></pre>\n\n<p>And make the appropriate change to the implementation</p>\n\n<pre><code>impl&lt;'a&gt; Decode&lt;'a, MQTTFrame&lt;'a&gt;&gt; for MQTTFrameDecoder&lt;'a&gt; { ... }\n</code></pre>\n\n<p>Now if we try the code above (playpen is.gd/BLStYq), the borrow checker complains:</p>\n\n<pre><code>&lt;anon&gt;:28:9: 28:24 error: cannot borrow `*decoder.payload` as mutable more than once at a time [E0499]\n&lt;anon&gt;:28         decoder.payload.push(1);\n</code></pre>\n\n<p>That's because, now, the reference to <code>decoder</code> must have lifetime <code>'a</code> when it is taken in order to call the function <code>decode_from</code>. Comment out the offending line and the rest of the example compiles! This code is now safe because no mutable lifetimes are being extended.</p>\n\n<hr>\n\n<p>Aside:</p>\n\n<p>As the reference to <code>decoder</code> must live as long as the decoder itself, you can't actually use <code>decoder</code> at all after you have called <code>decode_from</code>. As this is the case, it may be better to express this by taking <code>self</code> instead of <code>&amp;'a mut self</code>. Then the syntax is a little cleaner, and it is obvious that once a decoder has been used then it can't be used again.</p>\n\n<pre><code>pub trait Decode&lt;T&gt; {\n    fn decode_from(self) -&gt; T;\n}\n\npub struct MQTTFrame&lt;'a&gt; {\n    pub payload: &amp;'a Vec&lt;u8&gt;,\n}\n\npub struct MQTTFrameDecoder&lt;'a&gt; {\n    pub payload: &amp;'a mut Vec&lt;u8&gt;,\n}\n\nimpl&lt;'a&gt; Decode&lt;MQTTFrame&lt;'a&gt;&gt; for MQTTFrameDecoder&lt;'a&gt; {\n    fn decode_from(self) -&gt; MQTTFrame&lt;'a&gt; {\n        MQTTFrame{ payload: self.payload }\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 53, "user_id": 1427088, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/48c1e51825df1b5b64fb1c6740e101b7?s=128&d=identicon&r=PG", "display_name": "Olaf Bergner", "link": "https://stackoverflow.com/users/1427088/olaf-bergner"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2794, "favorite_count": 1, "accepted_answer_id": 36120253, "answer_count": 2, "score": 5, "last_activity_date": 1458512583, "creation_date": 1458499529, "last_edit_date": 1458502417, "question_id": 36117966, "link": "https://stackoverflow.com/questions/36117966/why-does-my-trait-need-a-lifetime-parameter", "title": "Why does my trait need a lifetime parameter?", "body": "<p>Being a Rust newbie, I probably somewhat naively started with this:</p>\n\n<pre><code>...\n\npub trait Decode&lt;T&gt; {\n    fn decode_from&lt;R: io::Read + ?Sized&gt;(&amp;mut self, stream: &amp;mut R) -&gt; T;\n}\n\npub struct MQTTFrame&lt;'a&gt; {\n    pub payload: &amp;'a Vec&lt;u8&gt;,\n}\n\npub struct MQTTFrameDecoder&lt;'a&gt; {\n    pub payload: &amp;'a mut Vec&lt;u8&gt;,\n}\n\nimpl&lt;'a&gt; Decode&lt;MQTTFrame&lt;'a&gt;&gt; for MQTTFrameDecoder&lt;'a&gt; {\n    fn decode_from&lt;R: io::Read + ?Sized&gt;(&amp;mut self, stream: &amp;mut R) -&gt;    MQTTFrame&lt;'a&gt; {\n        stream.read(&amp;mut self.payload);\n        MQTTFrame{ payload: self.payload }\n    }\n}\n</code></pre>\n\n<p>Which, when trying to compile, was greeted with:</p>\n\n<pre><code>src/testbed/mod.rs:31:24: 31:36 error: cannot infer an appropriate   lifetime for automatic coercion due to conflicting requirements [E0495]\nsrc/testbed/mod.rs:31         MQTTFrame{ payload: self.payload }\n                                                  ^~~~~~~~~~~~\nsrc/testbed/mod.rs:29:5: 32:6 help: consider using an explicit lifetime  parameter as shown: fn decode_from&lt;R: io::Read + ?Sized&gt;(&amp;'a mut self,   stream: &amp;mut R)\n -&gt; MQTTFrame&lt;'a&gt;\nsrc/testbed/mod.rs:29     fn decode_from&lt;R: io::Read + ?Sized&gt;(&amp;mut self, stream: &amp;mut R) -&gt; MQTTFrame&lt;'a&gt; {\nsrc/testbed/mod.rs:30         stream.read(&amp;mut self.payload);\nsrc/testbed/mod.rs:31         MQTTFrame{ payload: self.payload }\nsrc/testbed/mod.rs:32     }\n</code></pre>\n\n<p>Somewhere on StackOverflow - sorry, I forgot where - someone in a similar case suggested to add a lifetime parameter like so (omitting unchanged code):</p>\n\n<pre><code>pub trait Decode&lt;'a, T&gt; {\n    fn decode_from&lt;R: io::Read + ?Sized&gt;(&amp;'a mut self, stream: &amp;mut R) -&gt; T;\n}\n\nimpl&lt;'a&gt; Decode&lt;'a, MQTTFrame&lt;'a&gt;&gt; for MQTTFrameDecoder&lt;'a&gt; {\n    fn decode_from&lt;R: io::Read + ?Sized&gt;(&amp;'a mut self, stream: &amp;mut R) -&gt; MQTTFrame&lt;'a&gt; {\n        stream.read(&amp;mut self.payload);\n        MQTTFrame{ payload: self.payload }\n    }\n}\n</code></pre>\n\n<p>And lo and behold! It compiles. Now if I could only understand <em>why</em> it compiles. Could someone explain</p>\n\n<ol>\n<li>why the original code did not compile?</li>\n<li>why the modified code compiles?</li>\n</ol>\n"}, {"tags": ["rust", "traits", "hyper"], "answers": [{"tags": [], "owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "is_accepted": true, "score": 1, "last_activity_date": 1458515238, "creation_date": 1458515238, "answer_id": 36120752, "question_id": 36117268, "link": "https://stackoverflow.com/questions/36117268/trait-coreopsfnrequest-response-is-not-implemented-for-a-closure-when/36120752#36120752", "title": "&quot;trait core::ops::Fn&lt;(Request, Response)&gt; is not implemented&quot; for a closure when passing a connection pool to a Hyper handler", "body": "<p>If we look at the source for hyper, we can see for which closures the required trait is implemented:</p>\n\n<pre><code>impl&lt;F&gt; Handler for F where F: Fn(Request, Response&lt;Fresh&gt;), F: Sync + Send {\n    fn handle&lt;'a, 'k&gt;(&amp;'a self, req: Request&lt;'a, 'k&gt;, res: Response&lt;'a, Fresh&gt;) {\n        self(req, res)\n    }\n}\n</code></pre>\n\n<p>This means your closure needs to implement <code>Fn(Request, Response) + Sync + Send</code> for the <code>Handler</code> trait to be implemented for you. Otherwise, you need to implement it yourself. Since your closure takes <code>pool</code> by value, it only implements <code>FnOnce(Request, Response)</code> (can only be called once as <code>pool</code> gets moved into the function).</p>\n\n<p>To fix this, take an immutable reference to the pool instead so that your function can be called multiple times (i.e. implements <code>Fn(Request, Response)</code>).</p>\n\n<pre><code>fn hello(pool: &amp;Pool&lt;PostgresConnectionManager&gt;, req: Request, res: Response) {\n    res.send(b\"Hello world\").unwrap();\n}\n\nfn main() {\n    let pool = connect();\n    let dispatch = move |req: Request, res: Response| hello(&amp;pool, req, res);\n    Server::http(\"127.0.0.1:3000\").unwrap().handle(dispatch).unwrap();\n}\n</code></pre>\n\n<hr>\n\n<p>N.B. The trait <code>Fn(Request, Response)</code> is syntactic sugar for the higher-rank trait bound <code>for&lt;'r&gt; Fn(Request&lt;'r,'r&gt;, Response&lt;'r&gt;)</code>. This is because <code>Request</code> and <code>Response</code> are both generic on a lifetime and so your function must handle <code>Request</code>s and <code>Response</code>s of <em>any</em> lifetime.</p>\n"}], "owner": {"reputation": 576, "user_id": 478503, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c1b8e9154a084498c7eb1576f32a8488?s=128&d=identicon&r=PG&f=1", "display_name": "Martijn", "link": "https://stackoverflow.com/users/478503/martijn"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 129, "favorite_count": 0, "accepted_answer_id": 36120752, "answer_count": 1, "score": 1, "last_activity_date": 1458515238, "creation_date": 1458496079, "last_edit_date": 1458496281, "question_id": 36117268, "link": "https://stackoverflow.com/questions/36117268/trait-coreopsfnrequest-response-is-not-implemented-for-a-closure-when", "title": "&quot;trait core::ops::Fn&lt;(Request, Response)&gt; is not implemented&quot; for a closure when passing a connection pool to a Hyper handler", "body": "<p>I'm trying to build a small web service in Rust using <a href=\"https://github.com/hyperium/hyper\" rel=\"nofollow\">Hyper</a> and <a href=\"https://github.com/sfackler/r2d2\" rel=\"nofollow\">r2d2</a>, but I'm running into some issues concerning traits. I'm unable to parse the error message thrown by the compiler, so I was hoping someone could help me out.</p>\n\n<p>Consider the following code:</p>\n\n<pre><code>extern crate hyper;\nextern crate postgres;\nextern crate r2d2;\nextern crate r2d2_postgres;\n\nuse hyper::Server;\nuse hyper::server::{Request,Response,Handler};\nuse r2d2_postgres::{SslMode, PostgresConnectionManager};\nuse r2d2::{Pool, PooledConnection};\nuse postgres::{Connection};\n\nfn connect() -&gt; Pool&lt;PostgresConnectionManager&gt;{\n    let config = r2d2::Config::default();\n    let conns = \"postgres://abc:abc@localhost/abc\";\n    let manager = PostgresConnectionManager::new(conns, SslMode::None).unwrap();\n    let pool = r2d2::Pool::new(config, manager).unwrap();\n    return pool;\n}\n\nfn hello(pool: Pool&lt;PostgresConnectionManager&gt;, req: Request, res: Response) {\n    res.send(b\"Hello world\").unwrap();\n}\n\nfn main() {\n    let pool = connect();\n    let dispatch = move |req: Request, res: Response| hello(pool, req, res);\n    Server::http(\"127.0.0.1:3000\").unwrap().handle(dispatch).unwrap();\n}\n</code></pre>\n\n<p>My goal is to use <code>pool</code> in the function <code>hello</code>. By using closures, I thought, I could pass an environment variable wile still living up to the expectations Hyper has. Unfortunately, I get the following error:</p>\n\n<pre><code>src/main.rs:28:45: 28:61 error: the trait `for&lt;'r, 'r, 'r&gt; core::ops::Fn&lt;(hyper::server::request::Request&lt;'r, 'r&gt;, hyper::server::response::Response&lt;'r&gt;)&gt;` is not implemented for the type `[closure@src/main.rs:27:20: 27:76 pool:r2d2::Pool&lt;r2d2_postgres::PostgresConnectionManager&gt;]` [E0277]\nsrc/main.rs:28     Server::http(\"127.0.0.1:3000\").unwrap().handle(dispatch).unwrap();\n                                                           ^~~~~~~~~~~~~~~~\nsrc/main.rs:28:45: 28:61 help: run `rustc --explain E0277` to see a detailed explanation\nerror: aborting due to previous error\n</code></pre>\n\n<p>It depends on the type of <code>pool</code>. If I try to pass an <code>i64</code> for example, it's all swell and the compiler doesn't complain.</p>\n"}, {"tags": ["pointers", "rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 5, "last_activity_date": 1458496111, "creation_date": 1458496111, "answer_id": 36117274, "question_id": 36117057, "link": "https://stackoverflow.com/questions/36117057/when-to-use-box-instead-of-reference/36117274#36117274", "title": "When to use Box instead of reference?", "body": "<p>A <code>Box</code> denotes that a type is <strong>owned</strong> and that it is allocated <strong>on the heap</strong>. A reference (<code>&amp;</code>) denotes that you are <strong>borrowing</strong> the value from something else.</p>\n\n<p>You can even get a reference from a <code>Box</code> (explicit types are not needed here, only shown for clarity):</p>\n\n<pre><code>let boxed: Box&lt;i32&gt; = Box::new(42);\nlet reference: &amp;i32 = &amp;boxed;\n</code></pre>\n\n<p>The primary distinction boils down to <em>ownership</em>. When you own a value, you can do more things to it, such as destroying it or controlling its mutability.</p>\n\n<p>Heap vs stack is also important, but less immediately so. Stacks tend to have a fixed size that is relatively small (on my machine it's 8MiB), so declaring large variables on the stack can lead to exhausting that memory. The heap tends to be bigger, conceptually addressing 2^32 or 2^48 bytes.</p>\n\n<p><a href=\"http://doc.rust-lang.org/stable/book/\" rel=\"noreferrer\"><em>The Rust Programming Language</em></a> has a <a href=\"http://doc.rust-lang.org/stable/book/ownership.html\" rel=\"noreferrer\">section on ownership</a> as well as a section on <a href=\"http://doc.rust-lang.org/stable/book/the-stack-and-the-heap.html\" rel=\"noreferrer\">the stack and the heap</a>; I'd encourage you to read both.</p>\n"}, {"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 6, "last_activity_date": 1458499100, "last_edit_date": 1458499100, "creation_date": 1458497117, "answer_id": 36117500, "question_id": 36117057, "link": "https://stackoverflow.com/questions/36117057/when-to-use-box-instead-of-reference/36117500#36117500", "title": "When to use Box instead of reference?", "body": "<p>(<em>Additional to Shepmaster's great answer: another way to think of ownership</em>)</p>\n\n<p><strong>\u27a1</strong> You always have to think about: where does the value <strong>live</strong>? \ud83c\udfe0</p>\n\n<p>For example, data can live on the stack, in some special place of the executable, or in a <code>Box</code>. On the other hand, a reference isn't a place to <strong>live</strong> in -- it just points to some data that <strong>lives</strong> <em>somewhere else</em>. So:</p>\n\n<ul>\n<li>if you know that the data you want to work with has a home to live in: you can usually just use a reference (address) to just get access to it (visit it \u2708). </li>\n<li>if your data does not have a place to live in, put it in a box to give it a home \ud83c\udfe0 \u2665</li>\n</ul>\n\n<hr>\n\n<p>The chapters <a href=\"https://doc.rust-lang.org/book/ownership.html\" rel=\"nofollow\">ownership</a> and <a href=\"https://doc.rust-lang.org/book/references-and-borrowing.html\" rel=\"nofollow\">borrowing</a> in the Rust book are a great way to learn about these concepts.</p>\n"}], "owner": {"reputation": 2159, "user_id": 2570866, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/719063be2f6f7ca6be51df7833a26c25?s=128&d=identicon&r=PG", "display_name": "JelteF", "link": "https://stackoverflow.com/users/2570866/jeltef"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 132, "favorite_count": 0, "answer_count": 2, "score": 2, "last_activity_date": 1458499100, "creation_date": 1458495068, "question_id": 36117057, "link": "https://stackoverflow.com/questions/36117057/when-to-use-box-instead-of-reference", "title": "When to use Box instead of reference?", "body": "<p>I'm new to Rust and I'm trying to understand when a <code>Box</code> should be used instead of a regular reference.</p>\n\n<p>All the examples I can find show how to use a <code>Box</code>, but none of them explain in what situation you should use them over regular <code>&amp;</code> references.</p>\n"}, {"tags": ["multithreading", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1458488121, "post_id": 36115527, "comment_id": 59871946, "body": "Does the identifier need to remain unique even after the thread ends or could another newly created thread reuse the thread ID of a previously extinct one? For a re-entrant mutex, I am thinking that reuse would not be an issue, but I&#39;d rather be sure."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458490445, "post_id": 36115527, "comment_id": 59872806, "body": "@MatthieuM. great question! I&#39;m unable to think how a reused ID could cause problems for my case, but maybe I&#39;m not thinking hard enough ;-)"}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1458488257, "post_id": 36115633, "comment_id": 59871984, "body": "Amusingly, the thread-local implementation is quite likely to have a thread id for its inner working."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1458487416, "creation_date": 1458487416, "answer_id": 36115633, "question_id": 36115527, "link": "https://stackoverflow.com/questions/36115527/how-can-i-get-a-unique-thread-identifier/36115633#36115633", "title": "How can I get a unique thread identifier?", "body": "<p>Although it would be much nicer to use something built-in to the threading system, one solution is to track our own thread IDs. These can be created using a combination of atomic and thread-local variables:</p>\n\n<pre><code>use std::sync::atomic;\nuse std::thread;\n\nstatic THREAD_COUNT: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\nthread_local!(static THREAD_ID: usize = THREAD_COUNT.fetch_add(1, atomic::Ordering::SeqCst));\n\nfn thread_id() -&gt; usize {\n    THREAD_ID.with(|&amp;id| id)\n}\n\n// Example usage\n\nfn main() {\n    println!(\"{}\", thread_id());\n\n    let handles: Vec&lt;_&gt; = (0..10).map(|_| { \n        thread::spawn(|| {\n            println!(\"{}\", thread_id());\n        })\n    }).collect();\n\n    for h in handles { h.join().unwrap() }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1458563742, "post_id": 36125176, "comment_id": 59900977, "body": "While true, this is pretty unlikely to work on Windows. There appears to be <a href=\"https://crates.io/crates/thread-id\" rel=\"nofollow noreferrer\">a crate</a> based on the same idea but it is also Windows-compatible."}], "tags": [], "owner": {"reputation": 1094, "user_id": 713387, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/d839d9aa56849a71d8a9aa3d292a6ce6?s=128&d=identicon&r=PG", "display_name": "daschl", "link": "https://stackoverflow.com/users/713387/daschl"}, "is_accepted": false, "score": 3, "last_activity_date": 1458544951, "creation_date": 1458544951, "answer_id": 36125176, "question_id": 36115527, "link": "https://stackoverflow.com/questions/36115527/how-can-i-get-a-unique-thread-identifier/36125176#36125176", "title": "How can I get a unique thread identifier?", "body": "<p>Another way is, if you can use <code>libc</code>:</p>\n\n<pre><code>fn get_thread_id() -&gt; libc::pthread_t {\n    unsafe { libc::pthread_self() }\n}\n</code></pre>\n\n<p><code>pthread_t</code> will map to the right target per plattform.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 0, "last_activity_date": 1510365015, "creation_date": 1510365015, "answer_id": 47233546, "question_id": 36115527, "link": "https://stackoverflow.com/questions/36115527/how-can-i-get-a-unique-thread-identifier/47233546#47233546", "title": "How can I get a unique thread identifier?", "body": "<blockquote>\n  <p>but <code>Thread</code> doesn't seem to have anything that could be used (or abused) as an identifier.</p>\n</blockquote>\n\n<p>This was rectified in Rust 1.19 via <a href=\"https://doc.rust-lang.org/std/thread/struct.Thread.html#method.id\" rel=\"nofollow noreferrer\"><code>Thread::id</code></a>.</p>\n"}], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 564, "favorite_count": 0, "accepted_answer_id": 47233546, "answer_count": 3, "score": 3, "last_activity_date": 1510365015, "creation_date": 1458486882, "last_edit_date": 1458490305, "question_id": 36115527, "link": "https://stackoverflow.com/questions/36115527/how-can-i-get-a-unique-thread-identifier", "title": "How can I get a unique thread identifier?", "body": "<p>In an attempt to build an \"emulated\" <a href=\"https://en.wikipedia.org/wiki/Reentrant_mutex\" rel=\"nofollow\">Reentrant mutex</a>, I need an identifier that is unique to each thread. I can get the current thread via <a href=\"https://doc.rust-lang.org/std/thread/fn.current.html\" rel=\"nofollow\"><code>thread::current</code></a>, but <a href=\"https://doc.rust-lang.org/std/thread/struct.Thread.html\" rel=\"nofollow\"><code>Thread</code></a> doesn't seem to have anything that could be used (or abused) as an identifier.</p>\n\n<p>For my purposes, I believe the identifier can be reused once a thread exits, although I would be also interested in answers that didn't reuse identifiers as those may be useful in other cases.</p>\n"}, {"tags": ["rust", "ffi", "mruby"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458485993, "post_id": 36114087, "comment_id": 59871203, "body": "It rather sounds like you want a <a href=\"https://en.wikipedia.org/wiki/Reentrant_mutex\" rel=\"nofollow noreferrer\">reentrant lock</a> of some kind."}, {"owner": {"reputation": 2289, "user_id": 1454653, "user_type": "registered", "accept_rate": 87, "profile_image": "https://i.stack.imgur.com/FvI1V.jpg?s=128&g=1", "display_name": "dragostis", "link": "https://stackoverflow.com/users/1454653/dragostis"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458486084, "post_id": 36114087, "comment_id": 59871241, "body": "Sure, but <a href=\"https://github.com/rust-lang/rust/blob/master/src/libstd/sys/common/remutex.rs#L24\" rel=\"nofollow noreferrer\"><code>ReentrantMutex</code></a> is not even in <code>std</code>. :D"}], "owner": {"reputation": 2289, "user_id": 1454653, "user_type": "registered", "accept_rate": 87, "profile_image": "https://i.stack.imgur.com/FvI1V.jpg?s=128&g=1", "display_name": "dragostis", "link": "https://stackoverflow.com/users/1454653/dragostis"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 102, "favorite_count": 0, "answer_count": 0, "score": 2, "last_activity_date": 1458485950, "creation_date": 1458479339, "last_edit_date": 1458485950, "question_id": 36114087, "link": "https://stackoverflow.com/questions/36114087/how-can-i-make-a-c-pointer-wait-if-called-from-a-different-thread-but-work-in-a", "title": "How can I make a C pointer wait if called from a different thread, but work in a callback?", "body": "<p>I'm trying to implement a thread-safe version of an <a href=\"https://github.com/mruby/mruby\" rel=\"nofollow\">mruby</a> Rust binding.</p>\n\n<p>mruby has a <code>*mut MRState</code> (a wrapper over <code>mrb_state</code>). You need to pass this <code>*mut MRState</code> when running mruby code. The mruby code has a Rust callback that it can call where it passes the same <code>*mut MRState</code> variable.</p>\n\n<p>This <code>*mut MRState</code> is wrapped in a <code>MRuby</code> <code>struct</code> which I'm trying to make thread-safe. The problem is that if I wrap <code>MRuby</code> in a <code>Mutex</code>, it won't be able to re-enter inside of the Rust-written callback.</p>\n\n<p>I'm currently wrapping <code>MRuby</code> in a <code>RwLock</code> but it's not very useful. The <code>*mut MRState</code> should be in a more permissive lock that lets it run inside of the callbacks.</p>\n\n<p>How can I make <code>MRuby</code> work in both the callback and be forced to wait if called from different threads?</p>\n\n<p>Apart from this, I'm having an issue with the <code>*mut MRState</code> inside <code>MRuby</code> which is not <code>Send</code> &amp; <code>Sync</code>.</p>\n\n<pre><code>struct MRuby {\n    mrb: *mut MRState,\n    ...\n}\n</code></pre>\n\n<p>This is an example of the callback.</p>\n\n<pre><code>// this callback will be run with a mrb_ function with takes\n// *mut MRState as an argument, so it would need to lock\nextern \"C\" callback(...) {\n    // I need to use MRuby here which will make use of\n    // its inner *mut MRState\n    ...\n}\n</code></pre>\n\n<p>This is an example of running mruby on a thread. <code>mruby</code> variable here could be an <code>Arc&lt;RwLock&lt;MRuby&gt;&gt;</code>.</p>\n\n<pre><code>thread::spawn(move || {\n    mruby.run(\"*mruby code*\"); // should run sequentially with\n                               // with a lock on *mut MRState\n});\n</code></pre>\n\n<p>The main reason why I want to implement this is not functionality. Actually, it's <a href=\"https://doc.rust-lang.org/std/thread/fn.catch_panic.html\" rel=\"nofollow\"><code>catch_panic</code></a> which I need in order to catch any possible panics from the Rust callback. <code>catch_panic</code> runs in another thread, so I need to make <code>MRuby</code> thread-safe. Rust will stabilize <a href=\"https://doc.rust-lang.org/std/panic/index.html\" rel=\"nofollow\"><code>std::panic</code></a> only in 1.9.0 and until then I would need a working solution that doesn't need Rust nightly.</p>\n\n<p>CORRECTION</p>\n\n<p>Due to a bug in Rust's documentation generation, <code>catch_panic</code> is only marked as deprecated and not as unstable, even though it is. So a very simple solution is to just use <code>std::panic</code> and give up on thread-safety. I'm going to leave the question open, though, in case there is a good answer to this, even though my personal interest is lower now considering the aforementioned.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 2, "creation_date": 1458476141, "post_id": 36113081, "comment_id": 59867834, "body": "Neither can we, if you don&#39;t show your code. Please provide an <a href=\"https://stackoverflow.com/help/mcve\">MCVE</a>."}, {"owner": {"reputation": 688, "user_id": 4157647, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/82e77ab7941218ff6733d668b8049185?s=128&d=identicon&r=PG&f=1", "display_name": "Harvey Adcock", "link": "https://stackoverflow.com/users/4157647/harvey-adcock"}, "reply_to_user": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 0, "creation_date": 1458480465, "post_id": 36113081, "comment_id": 59869260, "body": "@starblue fair enough, it seems to happen with any use of the function though. Have edited to show a new project which only uses the problem call."}], "answers": [{"tags": [], "owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "is_accepted": false, "score": 1, "last_activity_date": 1458485225, "last_edit_date": 1458485225, "creation_date": 1458481276, "answer_id": 36114477, "question_id": 36113081, "link": "https://stackoverflow.com/questions/36113081/unresolved-name-error-when-using-stdptrset-memory/36114477#36114477", "title": "Unresolved name error when using std::ptr::set_memory", "body": "<p>The problem is that you are accidentally using outdated, unofficial documentation. <code>ptr::set_memory</code> is not part of <code>std</code>. Use <a href=\"https://doc.rust-lang.org/std/\" rel=\"nofollow\">the official documentation</a>.</p>\n"}, {"tags": [], "owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "is_accepted": true, "score": 5, "last_activity_date": 1458485248, "last_edit_date": 1458485248, "creation_date": 1458481511, "answer_id": 36114521, "question_id": 36113081, "link": "https://stackoverflow.com/questions/36113081/unresolved-name-error-when-using-stdptrset-memory/36114521#36114521", "title": "Unresolved name error when using std::ptr::set_memory", "body": "<p>The documentation you found is for a rather old version of Rust. In the current version you could use <a href=\"https://doc.rust-lang.org/std/ptr/fn.write_bytes.html\" rel=\"nofollow\"><code>std::ptr::write_bytes</code></a></p>\n"}], "owner": {"reputation": 688, "user_id": 4157647, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/82e77ab7941218ff6733d668b8049185?s=128&d=identicon&r=PG&f=1", "display_name": "Harvey Adcock", "link": "https://stackoverflow.com/users/4157647/harvey-adcock"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 291, "favorite_count": 0, "accepted_answer_id": 36114521, "answer_count": 2, "score": 0, "last_activity_date": 1458485248, "creation_date": 1458473000, "last_edit_date": 1458485198, "question_id": 36113081, "link": "https://stackoverflow.com/questions/36113081/unresolved-name-error-when-using-stdptrset-memory", "title": "Unresolved name error when using std::ptr::set_memory", "body": "<p>I'm using <code>ptr::set_memory</code> from <a href=\"http://smallcultfollowing.com/rust-int-variations/imem-umem/std/ptr/fn.set_memory.html\" rel=\"nofollow\">the std module</a>:</p>\n\n<pre><code>use std::ptr;\n\nfn main() {\n    let addr = 0 as *mut u8;\n    unsafe { ptr::set_memory(addr, 0, 8); }\n}\n</code></pre>\n\n<p>But the program won't compile due to this error:</p>\n\n<pre><code>src/main.rs:160:18: 160:33 error: unresolved name `ptr::set_memory` [E0425]\nsrc/main.rs:160         unsafe { ptr::set_memory(p, 0, total_size); }\n                                 ^~~~~~~~~~~~~~~\n</code></pre>\n"}, {"tags": ["rust", "integer-overflow", "integer-arithmetic"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1458484932, "post_id": 36112911, "comment_id": 59870784, "body": "It&#39;s not very clear what your question is. What would an ideal answer contain?"}, {"owner": {"reputation": 271, "user_id": 2217151, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Y9UhE.jpg?s=128&g=1", "display_name": "mzabaluev", "link": "https://stackoverflow.com/users/2217151/mzabaluev"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458582935, "post_id": 36112911, "comment_id": 59915025, "body": "I&#39;d like people to come up with anecdotes, or better, observations of consistent compiler behavior, when the unrolled approach ends up insignificantly better than the more ergonomic code with <code>Option</code>."}], "answers": [{"comments": [{"owner": {"reputation": 271, "user_id": 2217151, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Y9UhE.jpg?s=128&g=1", "display_name": "mzabaluev", "link": "https://stackoverflow.com/users/2217151/mzabaluev"}, "edited": false, "score": 1, "creation_date": 1458588126, "post_id": 36115397, "comment_id": 59918015, "body": "Thanks for the playground tips!  On x86-64, the optimizer produces very similar code from both examples, but only because it turns <code>oflo1 | oflo2 | ...</code> into a series of tests and branches. If that&#39;s not really a problem after all, the idiomatic code may not be prime subject for hand-optimization. The branches will tend to be well-predicted in typical calculations (where overflows are exceptional or result from misuse), but there may be many of them to crank up eject pressure on the predictor, especially if the code is generic."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 4, "last_activity_date": 1458486297, "creation_date": 1458486297, "answer_id": 36115397, "question_id": 36112911, "link": "https://stackoverflow.com/questions/36112911/chaining-checked-arithmetic-operations-in-rust/36115397#36115397", "title": "Chaining checked arithmetic operations in Rust", "body": "<blockquote>\n  <p>Does anyone have experience with how the Rust compiler optimizes either of the patterns above on various CPU architectures, to tell whether the explicit unrolling is worthwhile, especially for more complex expressions?</p>\n</blockquote>\n\n<p>You can use the <a href=\"https://play.rust-lang.org/\" rel=\"nofollow\">playground</a> to check how LLVM optimizes things: just click on \"LLVM IR\" or \"ASM\" instead of \"Run\". Stick a <code>#[inline(never)]</code> on the function you wish to check, and pay attention to pass it run-time arguments, to avoid constant folding. As in <a href=\"https://play.rust-lang.org/?gist=24a8e99565f68331c64c&amp;version=stable\" rel=\"nofollow\">here</a>:</p>\n\n<pre><code>use std::env;\n\n#[inline(never)]\nfn calculate_size(elem_size: usize,\n                  length: usize,\n                  offset: usize)\n                  -&gt; Option&lt;usize&gt; {\n    let (acc, oflo1) = elem_size.overflowing_mul(length);\n    let (acc, oflo2) = acc.overflowing_add(offset);\n    if oflo1 | oflo2 {\n        None\n    } else {\n        Some(acc)\n    }\n}\n\nfn main() {\n    let vec: Vec&lt;usize&gt; = env::args().map(|s| s.parse().unwrap()).collect();\n    let result = calculate_size(vec[0], vec[1], vec[2]);\n    println!(\"{:?}\",result);\n}\n</code></pre>\n\n<p>The answer you'll get, however, is that the overflow intrinsics in Rust and LLVM have been coded for convenience and not performance, unfortunately. This means that while the explicit unrolling optimizes well, counting on LLVM to optimize the checked code is not realistic for now.</p>\n\n<p>Normally this is not an issue; but for a performance hotspot, you may want to unroll manually.</p>\n\n<p><em>Note: this lack of performance is also the reason that overflow checking is disabled by default in Release mode.</em></p>\n"}], "owner": {"reputation": 271, "user_id": 2217151, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Y9UhE.jpg?s=128&g=1", "display_name": "mzabaluev", "link": "https://stackoverflow.com/users/2217151/mzabaluev"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 624, "favorite_count": 0, "answer_count": 1, "score": 4, "last_activity_date": 1458486297, "creation_date": 1458471774, "question_id": 36112911, "link": "https://stackoverflow.com/questions/36112911/chaining-checked-arithmetic-operations-in-rust", "title": "Chaining checked arithmetic operations in Rust", "body": "<p>When doing integer arithmetic with checks for overflows, calculations often need to compose several arithmetic operations. A straightforward way of chaining checked arithmetic in Rust uses <code>checked_*</code> methods and <code>Option</code> chaining:</p>\n\n<pre><code>fn calculate_size(elem_size: usize,\n                  length: usize,\n                  offset: usize)\n                  -&gt; Option&lt;usize&gt; {\n    elem_size.checked_mul(length)\n             .and_then(|acc| acc.checked_add(offset))\n}\n</code></pre>\n\n<p>However, this tells the compiler to generate a branch per each elementary operation. I have encountered a more unrolled approach using <code>overflowing_*</code> methods:</p>\n\n<pre><code>fn calculate_size(elem_size: usize,\n                  length: usize,\n                  offset: usize)\n                  -&gt; Option&lt;usize&gt; {\n    let (acc, oflo1) = elem_size.overflowing_mul(length);\n    let (acc, oflo2) = acc.overflowing_add(offset);\n    if oflo1 | oflo2 {\n        None\n    } else {\n        Some(acc)\n    }\n}\n</code></pre>\n\n<p>Continuing computation regardless of overflows and aggregating the overflow flags with bitwise OR ensures that at most one branching is performed in the entire evaluation (provided that the implementations of <code>overflowing_*</code> generate branchless code). This optimization-friendly approach is more cumbersome and requires some caution in dealing with intermediate values.</p>\n\n<p>Does anyone have experience with how the Rust compiler optimizes either of the patterns above on various CPU architectures, to tell whether the explicit unrolling is worthwhile, especially for more complex expressions?</p>\n"}, {"tags": ["string", "vector", "rust"], "comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1458464199, "post_id": 36111784, "comment_id": 59864880, "body": "What part of this doesn&#39;t work? Can you provide a minimal, complete, example on the Playpen? There doesn&#39;t seem to be anything wrong with this code."}, {"owner": {"reputation": 2372, "user_id": 5039582, "user_type": "registered", "accept_rate": 29, "profile_image": "https://www.gravatar.com/avatar/2753151bbe8511e6705d432533cef910?s=128&d=identicon&r=PG&f=1", "display_name": "Mandragor", "link": "https://stackoverflow.com/users/5039582/mandragor"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1458464993, "post_id": 36111784, "comment_id": 59865056, "body": "it should print   string&lt;tab&gt;string&lt;tab&gt;string    but it prints a leading tab. there must be a more elegant solution than that, without fiddling"}, {"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 0, "creation_date": 1458466083, "post_id": 36111784, "comment_id": 59865318, "body": "Look at the examples under <a href=\"https://doc.rust-lang.org/std/fmt/#format_args\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/fmt/#format_args</a>"}], "answers": [{"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 6, "last_activity_date": 1458469904, "creation_date": 1458469904, "answer_id": 36112642, "question_id": 36111784, "link": "https://stackoverflow.com/questions/36111784/how-to-convert-a-vecvecf64-into-a-string/36112642#36112642", "title": "How to convert a Vec&lt;Vec&lt;f64&gt;&gt; into a string", "body": "<p>There is indeed a <code>join</code> in the standard library, but it's not super useful (often additional allocation is required). But you can see a solution here:</p>\n\n<pre><code>fn print_matrix(vec: &amp;Vec&lt;Vec&lt;f64&gt;&gt;) {\n    for row in vec {\n        let cols_str: Vec&lt;_&gt; = row.iter().map(ToString::to_string).collect();\n        let line = cols_str.join(\"\\t\");\n        println!(\"{}\", line);\n    }\n}\n</code></pre>\n\n<p>The problem is that this <code>join</code> works with slices and not with iterators. We have to convert all elements into a string first, collect the result in a new vector and can use <code>join</code> then. </p>\n\n<p>The crate <a href=\"https://github.com/bluss/rust-itertools\"><code>itertools</code></a> defines a <code>join</code> method for iterators and can be applied like so:</p>\n\n<pre><code>for row in vec {\n    let line = row.iter().join(\"\\t\");\n    println!(\"{}\", line);\n}\n</code></pre>\n\n<p>And to avoid using any of the named functionality, you can of course do it manually:</p>\n\n<pre><code>for row in vec {\n    if let Some(first) = row.get(0) {\n        print!(\"{}\", first);            \n    }\n    for col in row.iter().skip(1) {\n        print!(\"\\t{}\", col);\n    }\n    println!(\"\");\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1343, "user_id": 4365239, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/88acc4986ddaf51e21c254fb8c0f11b8?s=128&d=identicon&r=PG&f=1", "display_name": "tafia", "link": "https://stackoverflow.com/users/4365239/tafia"}, "edited": false, "score": 0, "creation_date": 1458485903, "post_id": 36112667, "comment_id": 59871173, "body": "This will end with one extra <code>\\t</code>"}], "tags": [], "owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "is_accepted": false, "score": 4, "last_activity_date": 1458470070, "creation_date": 1458470070, "answer_id": 36112667, "question_id": 36111784, "link": "https://stackoverflow.com/questions/36111784/how-to-convert-a-vecvecf64-into-a-string/36112667#36112667", "title": "How to convert a Vec&lt;Vec&lt;f64&gt;&gt; into a string", "body": "<p>Besides <code>join</code> from <code>itertools</code> you could always use <code>fold</code> on iterator (which is really useful), like this:</p>\n\n<pre><code>row.iter().fold(\"\", |tab, col| { print!(\"{}{:?}\", tab, col); \"\\t\" });\n</code></pre>\n"}], "owner": {"reputation": 2372, "user_id": 5039582, "user_type": "registered", "accept_rate": 29, "profile_image": "https://www.gravatar.com/avatar/2753151bbe8511e6705d432533cef910?s=128&d=identicon&r=PG&f=1", "display_name": "Mandragor", "link": "https://stackoverflow.com/users/5039582/mandragor"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 696, "favorite_count": 0, "answer_count": 2, "score": 3, "last_activity_date": 1458484817, "creation_date": 1458463727, "last_edit_date": 1458484817, "question_id": 36111784, "link": "https://stackoverflow.com/questions/36111784/how-to-convert-a-vecvecf64-into-a-string", "title": "How to convert a Vec&lt;Vec&lt;f64&gt;&gt; into a string", "body": "<p>I am new to Rust, and I am struggling with a simple task. I'd like to convert a matrix into a string, with the fields separated by tabs. I think this is possible by using the <code>map</code> function or something similar, but right now whatever I try gives me an error.</p>\n\n<p>This is what I have, and I'd like to convert the <code>col</code> part into function, which returns a tab separated string, which I can print.\nIn Python this is something like <code>row.join(\"\\t\")</code>. Is there something similar in Rust?</p>\n\n<pre><code>fn print_matrix(vec: &amp;Vec&lt;Vec&lt;f64&gt;&gt;) {\n    for row in vec.iter() {\n        for col in row.iter() {\n           print!(\"\\t{:?}\",col);\n        }\n        println!(\"\\n\");\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 133, "user_id": 161297, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/498f8acba476827f4389bf7ed535a02c?s=128&d=identicon&r=PG", "display_name": "Divye Kapoor", "link": "https://stackoverflow.com/users/161297/divye-kapoor"}, "edited": false, "score": 0, "creation_date": 1488499807, "post_id": 36106280, "comment_id": 72270631, "body": "The summary of the answers below: Use a &quot;Box&quot; type. A Box is a soft polymorphic reference (similar to a pointer in C / C++ style languages)."}], "answers": [{"comments": [{"owner": {"reputation": 9296, "user_id": 1446742, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ff5e3600cba841c184385605d1d99d03?s=128&d=identicon&r=PG", "display_name": "fjh", "link": "https://stackoverflow.com/users/1446742/fjh"}, "edited": false, "score": 1, "creation_date": 1458419608, "post_id": 36106794, "comment_id": 59855536, "body": "An <code>&amp;BufRead</code> won&#39;t be very helpful though, since all the interesting <code>BufRead</code> methods take <code>&amp;mut self</code>."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1458419698, "post_id": 36106794, "comment_id": 59855560, "body": "I&#39;d like to note that there is no need to declare any of the variables before the condition because they are not used in it. So it is better to rewrite the code to avoid trait objects as they are really unnecessary here."}], "tags": [], "owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "is_accepted": false, "score": 5, "last_activity_date": 1458484553, "last_edit_date": 1495540024, "creation_date": 1458419464, "answer_id": 36106794, "question_id": 36106280, "link": "https://stackoverflow.com/questions/36106280/forcing-bufread-trait-compatibility-between-iostdio-and-bufreader/36106794#36106794", "title": "Forcing BufRead trait compatibility between io::stdio and BufReader", "body": "<p>Your code can be rewritten so that there is no need to reassign <code>reader</code> variable (see @Vladimir Matveev <a href=\"https://stackoverflow.com/a/36106782/5138648\">answer</a>).</p>\n\n<p>If you really need it, then <code>reader</code> variable must be a <a href=\"https://doc.rust-lang.org/book/trait-objects.html#dynamic-dispatch\" rel=\"nofollow noreferrer\">trait object</a>:</p>\n\n<pre><code>let mut bufread;//must be defined before reader to avoid lifetime issues \nlet stdin = io::stdin();\nlet mut reader = &amp;mut stdin.lock() as &amp;mut BufRead;   // Assignment. (1)\n\n//...\n\nbufread = BufReader::new(file.unwrap());//store BufReader value  \nreader = &amp;mut bufread;// reassign BufRead reference\n</code></pre>\n\n<p>Boxed form of trait object allows to avoid additional variable <code>bufread</code>:</p>\n\n<pre><code>let stdin = io::stdin();\nlet mut reader = Box::new(stdin.lock()) as Box&lt;BufRead&gt;;   \n\n//...\n\nreader = Box::new(BufReader::new(file.unwrap()));  \n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 133, "user_id": 161297, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/498f8acba476827f4389bf7ed535a02c?s=128&d=identicon&r=PG", "display_name": "Divye Kapoor", "link": "https://stackoverflow.com/users/161297/divye-kapoor"}, "edited": false, "score": 0, "creation_date": 1458513019, "post_id": 36115599, "comment_id": 59880996, "body": "Thanks for pointing to the correct use of Box in such a scenario. Very helpful."}], "tags": [], "owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "is_accepted": true, "score": 2, "last_activity_date": 1458487243, "creation_date": 1458487243, "answer_id": 36115599, "question_id": 36106280, "link": "https://stackoverflow.com/questions/36106280/forcing-bufread-trait-compatibility-between-iostdio-and-bufreader/36115599#36115599", "title": "Forcing BufRead trait compatibility between io::stdio and BufReader", "body": "<p>This will work.</p>\n\n<pre><code>use std::io;\nuse std::io::BufReader;\nuse std::io::prelude::*;\nuse std::env;\nuse std::process::exit;\nuse std::fs::File;\n\nfn usage() {\n    println!(\"Usage: cat input.csv | csv_to_json\");\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut reader = Box::new(stdin.lock()) as Box&lt;BufRead&gt;;\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    if args.len() &gt; 1 {\n        usage();\n        exit(1);\n    } else if args.len() == 1 {\n        let file = File::open(args[0].clone());\n        if !file.is_ok() {\n            usage();\n            exit(1);\n        }\n        reader = Box::new(BufReader::new(file.unwrap()));\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 133, "user_id": 161297, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/498f8acba476827f4389bf7ed535a02c?s=128&d=identicon&r=PG", "display_name": "Divye Kapoor", "link": "https://stackoverflow.com/users/161297/divye-kapoor"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1083, "favorite_count": 2, "accepted_answer_id": 36115599, "answer_count": 2, "score": 4, "last_activity_date": 1458487243, "creation_date": 1458416388, "last_edit_date": 1458484362, "question_id": 36106280, "link": "https://stackoverflow.com/questions/36106280/forcing-bufread-trait-compatibility-between-iostdio-and-bufreader", "title": "Forcing BufRead trait compatibility between io::stdio and BufReader", "body": "<p>I'm trying to type-pun an <code>io::stdio</code> instance and a <code>BufReader</code> wrapping a file so that I can write code assuming a buffered input source. I've tried several variations of trying to cast an <code>io::stdio()</code> to a <code>BufRead</code> type and all have failed with one or more variations of:</p>\n\n<pre><code>error: mismatched types:\n expected `std::io::stdio::StdinLock&lt;'_&gt;`,\n    found `std::io::buffered::BufReader&lt;std::fs::File&gt;`\n(expected struct `std::io::stdio::StdinLock`,\n    found struct `std::io::buffered::BufReader`) [E0308]\ncsv_to_json.rs:26     reader = BufReader::new(file.unwrap());\n</code></pre>\n\n<p>Here's the code:</p>\n\n<pre><code>use std::io;\nuse std::io::BufReader;\nuse std::io::prelude::*;\nuse std::env;\nuse std::process::exit;\nuse std::fs::File;\n\nfn usage() {\n    println!(\"Usage: cat input.csv | csv_to_json\");\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut reader = stdin.lock();   // Assignment. (1)\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    if args.len() &gt; 1 {\n        usage();\n        exit(1);\n    } else if args.len() == 1 {\n        let file = File::open(args[0].clone());\n        if !file.is_ok() {\n            usage();\n            exit(1);\n        }\n        reader = BufReader::new(file.unwrap());  // Reassignment. This is the line that fails.\n    }\n\n    // Rest of the code works with reader assuming a buffered input source.\n}\n</code></pre>\n\n<p>Things that I have tried:</p>\n\n<pre><code>let mut reader : BufRead = io::stdin();  // Fails.\nlet mut reader : BufReader&lt;Read&gt; = io::stdin();  // Fails.\nlet mut reader : BufReader&lt;_&gt; = io::stdin(); // Fails\nlet mut reader : BufRead = io::stdin().lock(); // Fails later.\nlet mut reader = BufReader::new(io::stdin());  // Fails with type mismatch.\nlet mut reader = BufReader::new(io::stdin().lock());  // Fails with type mismatch.\n</code></pre>\n\n<p>I've even tried extracting that code to its own function and the return type signature fails with similar error conditions. How can I create a \"reader\" variable that's either a <code>BufferedReader</code> over <code>stdio</code> or a <code>BufferedReader</code> over a <code>File</code> without facing type errors everywhere?</p>\n"}, {"tags": ["rust", "ffi"], "comments": [{"owner": {"reputation": 3039, "user_id": 2851815, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/37MCt.png?s=128&g=1", "display_name": "\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438", "link": "https://stackoverflow.com/users/2851815/%d0%bd%d0%b0%d0%b1%d0%b8%d1%8f%d1%87%d0%bb%d1%8d%d0%b2%d1%8d%d0%bb%d0%b8"}, "edited": false, "score": 0, "creation_date": 1458415948, "post_id": 36105579, "comment_id": 59854404, "body": "The <a href=\"https://doc.rust-lang.org/book/ffi.html\" rel=\"nofollow noreferrer\">FFI chapter in The Book</a> specifies how to use FFI in Rust. The type would be <code>*const libc::c_char</code>."}, {"owner": {"reputation": 416, "user_id": 1296536, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/ufh61.png?s=128&g=1", "display_name": "Thiago Pontes", "link": "https://stackoverflow.com/users/1296536/thiago-pontes"}, "reply_to_user": {"reputation": 3039, "user_id": 2851815, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/37MCt.png?s=128&g=1", "display_name": "\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438", "link": "https://stackoverflow.com/users/2851815/%d0%bd%d0%b0%d0%b1%d0%b8%d1%8f%d1%87%d0%bb%d1%8d%d0%b2%d1%8d%d0%bb%d0%b8"}, "edited": false, "score": 0, "creation_date": 1458498717, "post_id": 36105579, "comment_id": 59876018, "body": "I&#39;m using i8(which is the type c_char is mapped to), the problem is that the only way I found to make it visible as a symbol is to define it as a <code>static</code> value, but I couldn&#39;t find a way to define a <code>static</code> value equivalent to this C&#39;s <code>char *</code> array"}, {"owner": {"reputation": 3039, "user_id": 2851815, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/37MCt.png?s=128&g=1", "display_name": "\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438", "link": "https://stackoverflow.com/users/2851815/%d0%bd%d0%b0%d0%b1%d0%b8%d1%8f%d1%87%d0%bb%d1%8d%d0%b2%d1%8d%d0%bb%d0%b8"}, "edited": false, "score": 0, "creation_date": 1458515671, "post_id": 36105579, "comment_id": 59881767, "body": "<code>extern {static Vmod_Spec: *const i8}</code>?"}, {"owner": {"reputation": 416, "user_id": 1296536, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/ufh61.png?s=128&g=1", "display_name": "Thiago Pontes", "link": "https://stackoverflow.com/users/1296536/thiago-pontes"}, "reply_to_user": {"reputation": 3039, "user_id": 2851815, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/37MCt.png?s=128&g=1", "display_name": "\u043d\u0430\u0431\u0438\u044f\u0447\u043b\u044d\u0432\u044d\u043b\u0438", "link": "https://stackoverflow.com/users/2851815/%d0%bd%d0%b0%d0%b1%d0%b8%d1%8f%d1%87%d0%bb%d1%8d%d0%b2%d1%8d%d0%bb%d0%b8"}, "edited": false, "score": 0, "creation_date": 1459114466, "post_id": 36105579, "comment_id": 60135541, "body": "This doesn&#39;t work too, I get an error saying that <code>*const i8</code> doesn&#39;t implement the <code>Sync</code> trait then it can&#39;t be shared across threads(the compiler assumes that if it&#39;s being exposed it should be thread-safe). I also can&#39;t implement <code>Sync</code> for <code>*const i8</code> because I don&#39;t own any of these types. I&#39;ll be trying to wrap <code>*const i8</code> in another struct and implement <code>Sync</code> for it to see if the exported symbol is C compatible"}], "answers": [{"tags": [], "owner": {"reputation": 416, "user_id": 1296536, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/ufh61.png?s=128&g=1", "display_name": "Thiago Pontes", "link": "https://stackoverflow.com/users/1296536/thiago-pontes"}, "is_accepted": true, "score": 1, "last_activity_date": 1459180429, "creation_date": 1459180429, "answer_id": 36265897, "question_id": 36105579, "link": "https://stackoverflow.com/questions/36105579/exposing-a-c-symbol-containing-an-array-of-strings-from-rust-to-c/36265897#36265897", "title": "Exposing a C symbol containing an array of strings from Rust to C", "body": "<p>The Rust equivalent for this would be exposing a <code>[*const c_char;3]</code> as an <code>static</code> value. The problem is that if you declare your value like this you will get an error: <code>error: the trait core::marker::Sync is not implemented for the type *const i8 [E0277]</code>. And you can't implement this trait for <code>*const c_char</code> because you don't own this type. The workaround was to declare a wrapper type around <code>*const c_char</code> and use it instead:</p>\n\n<pre><code>struct Wrapper(*const c_char)\nunsafe impl Sync for Wrapper { }\n#[no_mangle]\npub static Vmod_Spec: [Wrapper; 3] = etc..\n</code></pre>\n\n<p>And then I'll have a <code>Vmod_Spec</code> symbol which points to an array of values.</p>\n"}], "owner": {"reputation": 416, "user_id": 1296536, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/ufh61.png?s=128&g=1", "display_name": "Thiago Pontes", "link": "https://stackoverflow.com/users/1296536/thiago-pontes"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 290, "favorite_count": 0, "accepted_answer_id": 36265897, "answer_count": 1, "score": 0, "last_activity_date": 1459180429, "creation_date": 1458412592, "question_id": 36105579, "link": "https://stackoverflow.com/questions/36105579/exposing-a-c-symbol-containing-an-array-of-strings-from-rust-to-c", "title": "Exposing a C symbol containing an array of strings from Rust to C", "body": "<p>I have the following C code:</p>\n\n<pre><code>const char * const Vmod_Spec[] = {\n    \"example.hello\\0Vmod_Func_example.hello\\0STRING\\0STRING\\0\",\n    \"INIT\\0Vmod_Func_example._init\",\n    0\n};\n</code></pre>\n\n<p>After compiling a <code>.so</code> from this code I can load this symbol with <code>dlsym</code> and get the contents of <code>Vmod_Spec</code> and iterate over it. How can I achieve the same result exposing a symbol like this one from Rust?</p>\n"}, {"tags": ["rust", "suppress-warnings"], "comments": [{"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "edited": false, "score": 0, "creation_date": 1458471389, "post_id": 36104552, "comment_id": 59866598, "body": "I have a hunch that this is due to the way the lint is constructed. Will look at the code when I get to my PC."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458479791, "post_id": 36113947, "comment_id": 59869006, "body": "Thanks! It&#39;s annoying that it&#39;s implemented this way, but at least I know there&#39;s no best way for now."}], "tags": [], "owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "is_accepted": true, "score": 2, "last_activity_date": 1458478502, "creation_date": 1458478502, "answer_id": 36113947, "question_id": 36104552, "link": "https://stackoverflow.com/questions/36104552/how-to-suppress-the-warning-for-drop-with-repr-extern-at-a-fine-granularity/36113947#36113947", "title": "How to suppress the warning for &quot;drop_with_repr_extern&quot; at a fine granularity?", "body": "<p>The reason is <a href=\"https://github.com/rust-lang/rust/blob/015d3b70929a31af48d056a8e05d113e362339e9/src/librustc_lint/builtin.rs#L1144\" rel=\"nofollow\">near the end of rustc_lint/builtin.rs</a>:</p>\n\n<p>The lint does not walk the crate, instead using <code>ctx.tcx.lang_items.drop_trait()</code> to look up all <code>Drop</code> trait implementations within the crate. The annotations are only picked up while walking the crate. I've stumbled upon the same problem in <a href=\"https://stackoverflow.com/questions/35284646/how-do-i-get-the-lint-level-from-a-visitor-given-a-block\">this question</a>. So unless someone changes the lint to actually walk the crate and pick up <code>Drop</code> <code>impl</code>s as it goes, you need to annotate the whole crate.</p>\n"}], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 492, "favorite_count": 0, "accepted_answer_id": 36113947, "answer_count": 1, "score": 4, "last_activity_date": 1458478502, "creation_date": 1458406893, "question_id": 36104552, "link": "https://stackoverflow.com/questions/36104552/how-to-suppress-the-warning-for-drop-with-repr-extern-at-a-fine-granularity", "title": "How to suppress the warning for &quot;drop_with_repr_extern&quot; at a fine granularity?", "body": "<p>I am currently experimenting with multi-threading code, and its performance is affected by whether two data members share the same cache line or not.</p>\n\n<p>In order to avoid false-sharing, I need to specify the layout of the <code>struct</code> without the Rust compiler interfering, and thus I use <code>repr(C)</code>. However, this same <code>struct</code> also implements <code>Drop</code>, and therefore the compiler warns about the \"incompatibility\" of <code>repr(C)</code> and <code>Drop</code>, which I care naught for.</p>\n\n<p>However, attempting to silence this futile warning has proven beyond me.</p>\n\n<p>Here is a <a href=\"https://play.rust-lang.org/?gist=9aadf3dfdcca551fef75&amp;version=stable\" rel=\"nofollow\">reduced example</a>:</p>\n\n<pre><code>#[repr(C)]\n#[derive(Default, Debug)]\nstruct Simple&lt;T&gt; {\n    item: T,\n}\n\nimpl&lt;T&gt; Drop for Simple&lt;T&gt; {\n    fn drop(&amp;mut self) {}\n}\n\nfn main() {\n    println!(\"{:?}\", Simple::&lt;u32&gt;::default());\n}\n</code></pre>\n\n<p>which emits <code>#[warn(drop_with_repr_extern)]</code>.</p>\n\n<p>I have tried specifying <code>#[allow(drop_with_repr_extern)]</code>:</p>\n\n<ul>\n<li>at <code>struct</code></li>\n<li>at <code>impl Drop</code></li>\n<li>at <code>mod</code></li>\n</ul>\n\n<p>and neither worked. Only the crate-level suppression worked, which is rather heavy-handed.</p>\n\n<p>Which leads us to: is there a more granular way of suppressing this warning?</p>\n\n<p><em>Note: remarks on a better way to ensure that two data members are spread over different cache lines are welcome; however they will not constitute answers on their own.</em></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1458348328, "post_id": 36096129, "comment_id": 59837195, "body": "You cannot do this. For one, you are trying to take a reference to a value where the address is only valid for the one statement before it&#39;s moved. You also <a href=\"http://stackoverflow.com/q/32300132/155423\">can&#39;t store a value and a reference to that value in the same struct</a>, so the end goal is unreachable. Also, note that the <a href=\"http://is.gd/vh6kD6\" rel=\"nofollow noreferrer\">vector has nothing to do with your question</a>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1458348739, "post_id": 36096129, "comment_id": 59837299, "body": "<i>the key would have the same lifetime since it&#39;s valid as long as the HashMap contains the structure</i> \u2014 not true;  as soon as the <code>HashMap</code> decides to reallocate the storage of the values, any references would be invalidated."}, {"owner": {"reputation": 26014, "user_id": 123695, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/c1e4202cb329b1e3343a571dff94c68c?s=128&d=identicon&r=PG", "display_name": "Michael Mior", "link": "https://stackoverflow.com/users/123695/michael-mior"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458354067, "post_id": 36096129, "comment_id": 59838251, "body": "@Shepmaster Well, it is true that the key will not be dropped until the value is removed from the HashMap. That was the point I was trying to make. I see the point you&#39;re making in your earlier comment though. Thanks!"}], "owner": {"reputation": 26014, "user_id": 123695, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/c1e4202cb329b1e3343a571dff94c68c?s=128&d=identicon&r=PG", "display_name": "Michael Mior", "link": "https://stackoverflow.com/users/123695/michael-mior"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 36, "favorite_count": 0, "closed_date": 1458348581, "answer_count": 0, "score": 1, "last_activity_date": 1458348435, "creation_date": 1458345100, "last_edit_date": 1458348435, "question_id": 36096129, "link": "https://stackoverflow.com/questions/36096129/building-a-hashmap-where-the-key-is-a-field-in-the-structure-and-the-value-is-th", "closed_reason": "Duplicate", "title": "Building a HashMap where the key is a field in the structure and the value is the structure itself", "body": "<p>I want to build a <code>HashMap</code> of a vector of structures where the key is a <code>String</code> field in the structure and the value is the structure itself. It seems like this should be possible without copying. I want to move the lifetime of the structure to the <code>HashMap</code> and then the key would have the same lifetime since it's valid as long as the <code>HashMap</code> contains the structure.</p>\n\n<pre><code>use std::collections::{HashMap};\n\n#[derive(Hash, PartialEq, Eq)]\nstruct A {\n    pub x: String,\n}\n\nfn main() {\n    let mut map = HashMap::new();\n    let mut vec = Vec::new();\n    vec.push(A { x: \"foo\".to_string() });\n    for x in vec {\n        map.insert(&amp;x.x, x);\n    }\n}\n</code></pre>\n\n<p>This gives me the following error</p>\n\n<pre><code>src/main.rs:13:19: 13:22 error: `x.x` does not live long enough\nsrc/main.rs:13       map.insert(&amp;x.x, x);\n                                 ^~~\nsrc/main.rs:9:34: 15:2 note: reference must be valid for the block suffix following statement 0 at 9:33...\nsrc/main.rs: 9     let mut map = HashMap::new();\nsrc/main.rs:10     let mut vec = Vec::new();\nsrc/main.rs:11     vec.push(A { x: \"foo\".to_string() });\nsrc/main.rs:12     for x in vec {\nsrc/main.rs:13       map.insert(&amp;x.x, x);\nsrc/main.rs:14     }\n               ...\nsrc/main.rs:12:5: 14:6 note: ...but borrowed value is only valid for the for at 12:4\nsrc/main.rs:12     for x in vec {\nsrc/main.rs:13       map.insert(&amp;x.x, x);\nsrc/main.rs:14     }\n</code></pre>\n\n<p>Any help sorting this out is greatly appreciated!</p>\n"}, {"tags": ["io", "polymorphism", "rust"], "comments": [{"owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "edited": false, "score": 0, "creation_date": 1458315690, "post_id": 36088116, "comment_id": 59821402, "body": "Your current approach will not work since <code>StdinLock</code> contains a reference to a <code>Stdin</code> object."}, {"owner": {"reputation": 353, "user_id": 833591, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/32a2f52a30d53f12b0d8e3f0696fe4ac?s=128&d=identicon&r=PG", "display_name": "neektza", "link": "https://stackoverflow.com/users/833591/neektza"}, "reply_to_user": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "edited": false, "score": 1, "creation_date": 1458316510, "post_id": 36088116, "comment_id": 59822001, "body": "Could you expand on that a little if you have time? Thanks."}], "answers": [{"tags": [], "owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "is_accepted": true, "score": 20, "last_activity_date": 1524409822, "last_edit_date": 1524409822, "creation_date": 1458317556, "answer_id": 36089209, "question_id": 36088116, "link": "https://stackoverflow.com/questions/36088116/how-to-do-polymorphic-io-from-either-a-file-or-stdin-in-rust/36089209#36089209", "title": "How to do polymorphic IO from either a File or stdin in Rust?", "body": "<p>This is the simplest solution but will borrow and lock <code>Stdin</code>.</p>\n\n<pre><code>use std::fs::File;\nuse std::io::{self, BufRead, Read};\n\nstruct Input&lt;'a&gt; {\n    source: Box&lt;BufRead + 'a&gt;,\n}\n\nimpl&lt;'a&gt; Input&lt;'a&gt; {\n    fn console(stdin: &amp;'a io::Stdin) -&gt; Input&lt;'a&gt; {\n        Input {\n            source: Box::new(stdin.lock()),\n        }\n    }\n\n    fn file(path: &amp;str) -&gt; io::Result&lt;Input&lt;'a&gt;&gt; {\n        File::open(path).map(|file| Input {\n            source: Box::new(io::BufReader::new(file)),\n        })\n    }\n}\n\nimpl&lt;'a&gt; Read for Input&lt;'a&gt; {\n    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {\n        self.source.read(buf)\n    }\n}\n\nimpl&lt;'a&gt; BufRead for Input&lt;'a&gt; {\n    fn fill_buf(&amp;mut self) -&gt; io::Result&lt;&amp;[u8]&gt; {\n        self.source.fill_buf()\n    }\n\n    fn consume(&amp;mut self, amt: usize) {\n        self.source.consume(amt);\n    }\n}\n</code></pre>\n\n<p>Due to default trait methods, <code>Read</code> and <code>BufRead</code> are fully implemented for <code>Input</code>. So you can call <code>lines</code> on <code>Input</code>.</p>\n\n<pre><code>let input = Input::file(\"foo.txt\").unwrap();\nfor line in input.lines() {\n    println!(\"input line: {:?}\", line);\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 1677, "user_id": 2610048, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8d292ad35efc8a59d27b3798a54c034?s=128&d=identicon&r=PG", "display_name": "Yerke", "link": "https://stackoverflow.com/users/2610048/yerke"}, "is_accepted": false, "score": 35, "last_activity_date": 1524386104, "creation_date": 1524386104, "answer_id": 49964042, "question_id": 36088116, "link": "https://stackoverflow.com/questions/36088116/how-to-do-polymorphic-io-from-either-a-file-or-stdin-in-rust/49964042#49964042", "title": "How to do polymorphic IO from either a File or stdin in Rust?", "body": "<p>The answer by @A.B. is correct, but it tries to conform to OP's original program structure. I want to have a more readable alternative for newcomers who stumble upon this question (just like I did).</p>\n\n<pre><code>use std::env;\nuse std::fs;\nuse std::io::{self, BufReader, BufRead};\n\nfn main() {\n    let input = env::args().nth(1);\n    let reader: Box&lt;BufRead&gt; = match input {\n        None =&gt; Box::new(BufReader::new(io::stdin())),\n        Some(filename) =&gt; Box::new(BufReader::new(fs::File::open(filename).unwrap()))\n    };\n    for line in reader.lines() {\n        println!(\"{:?}\", line);\n    }\n}\n</code></pre>\n\n<p>See the discussion in <a href=\"https://www.reddit.com/r/rust/comments/32rjdd/reading_from_a_file_or_stdin_based_on_command/\" rel=\"noreferrer\">reddit</a> from which I borrowed the code.</p>\n"}], "owner": {"reputation": 353, "user_id": 833591, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/32a2f52a30d53f12b0d8e3f0696fe4ac?s=128&d=identicon&r=PG", "display_name": "neektza", "link": "https://stackoverflow.com/users/833591/neektza"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2705, "favorite_count": 2, "accepted_answer_id": 36089209, "answer_count": 2, "score": 24, "last_activity_date": 1524410214, "creation_date": 1458314410, "last_edit_date": 1524410214, "question_id": 36088116, "link": "https://stackoverflow.com/questions/36088116/how-to-do-polymorphic-io-from-either-a-file-or-stdin-in-rust", "title": "How to do polymorphic IO from either a File or stdin in Rust?", "body": "<p>I'm trying to implement a \"polymorphic\" <code>Input</code> enum which hides whether we're reading from a file or from a stdin. More concretely, I'm trying build an enum that will have a <code>lines</code> method that will in turn \"delegate\" that call to either a <code>File</code> wrapped into a <code>BufReader</code> or to a <code>StdInLock</code> (both of which have the <code>lines()</code> method).</p>\n\n<p>Here's the enum: </p>\n\n<pre><code>enum Input&lt;'a&gt; {\n    Console(std::io::StdinLock&lt;'a&gt;),\n    File(std::io::BufReader&lt;std::fs::File&gt;)\n}\n</code></pre>\n\n<p>I have three methods:</p>\n\n<ul>\n<li><code>from_arg</code> for deciding whether we're reading from a file or from a stdin by checking whether an argument (filename) was provided,</li>\n<li><code>file</code> for wrapping a file with a <code>BufReader</code>,</li>\n<li><code>console</code> for locking the stdin.</li>\n</ul>\n\n<p>The implementation:</p>\n\n<pre><code>impl&lt;'a&gt; Input&lt;'a&gt; {\n    fn console() -&gt; Input&lt;'a&gt; {\n        Input::Console(io::stdin().lock())\n    }\n\n    fn file(path: String) -&gt; io::Result&lt;Input&lt;'a&gt;&gt; {\n        match File::open(path) {\n            Ok(file) =&gt; Ok(Input::File(std::io::BufReader::new(file))),\n            Err(_) =&gt; panic!(\"kita\"),\n        }\n    }\n\n    fn from_arg(arg: Option&lt;String&gt;) -&gt; io::Result&lt;Input&lt;'a&gt;&gt; {\n        Ok(match arg {\n            None =&gt; Input::console(),\n            Some(path) =&gt; try!(Input::file(path)),\n        })\n    }\n}\n</code></pre>\n\n<p>As far as I understand, I have to implement both <code>BufRead</code> and <code>Read</code> traits for this to work. This is my attempt:</p>\n\n<pre><code>impl&lt;'a&gt; io::Read for Input&lt;'a&gt; {\n    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {\n        match *self {\n            Input::Console(ref mut c) =&gt; c.read(buf),\n            Input::File(ref mut f) =&gt; f.read(buf),\n        }\n    }\n}\n\nimpl&lt;'a&gt; io::BufRead for Input&lt;'a&gt; {\n    fn lines(self) -&gt; Lines&lt;Self&gt; {\n        match self {\n            Input::Console(ref c) =&gt; c.lines(),\n            Input::File(ref f) =&gt; f.lines(),\n        }\n    }\n\n    fn consume(&amp;mut self, amt: usize) {\n        match *self {\n            Input::Console(ref mut c) =&gt; c.consume(amt),\n            Input::File(ref mut f) =&gt; f.consume(amt),\n        }\n    }\n\n    fn fill_buf(&amp;mut self) -&gt; io::Result&lt;&amp;[u8]&gt; {\n        match *self {\n            Input::Console(ref mut c) =&gt; c.fill_buf(),\n            Input::File(ref mut f) =&gt; f.fill_buf(),\n        }\n    }\n}\n</code></pre>\n\n<p>Finally, the invocation:</p>\n\n<pre><code>fn load_input&lt;'a&gt;() -&gt; io::Result&lt;Input&lt;'a&gt;&gt; {\n    Ok(try!(Input::from_arg(env::args().skip(1).next())))\n}\n\nfn main() {\n    let mut input = match load_input() {\n        Ok(input) =&gt; input,\n        Err(error) =&gt; panic!(\"Failed: {}\", error),\n    };\n\n    for line in input.lines() { /* do stuff */ }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=7016c56cbda005109bcc3c80f28c6b5e&amp;version=stable\" rel=\"noreferrer\">Complete example in the playground</a></p>\n\n<p>The compiler tells me that I'm pattern matching wrongly and that I have <code>mismatched types</code>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: match arms have incompatible types\n  --&gt; src/main.rs:41:9\n   |\n41 | /         match self {\n42 | |             Input::Console(ref c) =&gt; c.lines(),\n   | |                                      --------- match arm with an incompatible type\n43 | |             Input::File(ref f) =&gt; f.lines(),\n44 | |         }\n   | |_________^ expected enum `Input`, found struct `std::io::StdinLock`\n   |\n   = note: expected type `std::io::Lines&lt;Input&lt;'a&gt;&gt;`\n              found type `std::io::Lines&lt;std::io::StdinLock&lt;'_&gt;&gt;`\n</code></pre>\n\n<p>I tried to satisfy it with:</p>\n\n<pre><code>match self {\n    Input::Console(std::io::StdinLock(ref c)) =&gt; c.lines(),\n    Input::File(std::io::BufReader(ref f)) =&gt; f.lines(),\n}\n</code></pre>\n\n<p>... but that doesn't work either.</p>\n\n<p>I'm really out of my depth here, it seems.</p>\n"}, {"tags": ["data-structures", "rust"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1458312065, "post_id": 36086832, "comment_id": 59818791, "body": "you can have a vector with references to structures, but then you won&#39;t be able to modify the structures anymore."}], "answers": [{"comments": [{"owner": {"reputation": 180, "user_id": 5218118, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/712c19ee522b71854d1e6d2d7d2639be?s=128&d=identicon&r=PG&f=1", "display_name": "Peter Ludvigsen", "link": "https://stackoverflow.com/users/5218118/peter-ludvigsen"}, "edited": false, "score": 0, "creation_date": 1458312166, "post_id": 36087194, "comment_id": 59818861, "body": "Ahh, so I assume you have a HashMap of &lt;Key, &amp;reference&gt;? If that is the case the solution is of course obvious. I guess I sort of assumed that was not an option since you could not have a vector of references"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 180, "user_id": 5218118, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/712c19ee522b71854d1e6d2d7d2639be?s=128&d=identicon&r=PG&f=1", "display_name": "Peter Ludvigsen", "link": "https://stackoverflow.com/users/5218118/peter-ludvigsen"}, "edited": false, "score": 0, "creation_date": 1458312504, "post_id": 36087194, "comment_id": 59819106, "body": "@PeterLudvigsen: You can have a vector of references, in general, if you can prove to the compiler that the references will outlive the vector. However in your case the references point into a sibling of the vector, and thus you cannot prove it. Thus, you will have a <code>BTreeMap&lt;BookId, Book&gt;</code> and a <code>BTreeMap&lt;AuthorId, Author&gt;</code> as the &quot;authoritative&quot; sources of data, and then your <code>Author</code> can contain a <code>Vec&lt;BookId&gt;</code>."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 2, "last_activity_date": 1458311971, "creation_date": 1458311971, "answer_id": 36087194, "question_id": 36086832, "link": "https://stackoverflow.com/questions/36086832/structuring-of-data-in-rust/36087194#36087194", "title": "Structuring of data in Rust", "body": "<p>Given that your code sample already features IDs, the solution can be straightforward:</p>\n\n<ul>\n<li>the <code>Library</code> will have a hash-map or BTree mapping an <code>BookId</code> to its <code>Book</code></li>\n<li>all other structures that reference a book do so by having a copy of its <code>BookId</code></li>\n</ul>\n\n<p>And of course you would do the same with <code>AuthorId</code> and <code>Author</code>.</p>\n\n<p>Another possibility is to use <code>Rc</code> and <code>Weak</code>, however unless carefully managed you may get memory leaks.</p>\n"}], "owner": {"reputation": 180, "user_id": 5218118, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/712c19ee522b71854d1e6d2d7d2639be?s=128&d=identicon&r=PG&f=1", "display_name": "Peter Ludvigsen", "link": "https://stackoverflow.com/users/5218118/peter-ludvigsen"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 127, "favorite_count": 0, "accepted_answer_id": 36087194, "answer_count": 1, "score": 0, "last_activity_date": 1458321557, "creation_date": 1458311034, "last_edit_date": 1458321557, "question_id": 36086832, "link": "https://stackoverflow.com/questions/36086832/structuring-of-data-in-rust", "title": "Structuring of data in Rust", "body": "<p>I'm trying to convert an old personal Java project into Rust as a learning experience. The basic data structure looked like this:</p>\n\n<ul>\n<li>There is one main <code>Library</code>. The <code>Library</code> has a list of authors, and a list of books.</li>\n<li>Each author also has a list of books he/she has written.</li>\n<li>Each book has a reference to its author.</li>\n</ul>\n\n<p>In the Java program I took a decision that there should never exist more than one object for each book (\"The Hobbit\") in the program. If a new book (maybe through user input) entered the system the first thing I would do was to test if it was already in the <code>Library</code>, and then replace the user input with the book-object from the <code>Library</code>. This vastly simplified a lot of logic since you could always count on comparing books by reference was valid. </p>\n\n<p>Anyway, I am now rewriting this code in Rust and I have run into a problem regarding organizing my data in memory.</p>\n\n<p>Having a <code>Library</code> with a collection of <code>Authors</code> is straight forward. However, how do I organize my books?</p>\n\n<p>In Java the <code>Library</code> contained a <code>HashMap</code> with all the books which made it possible to find a book in constant time. Each <code>Author</code> also has a list of books (ordered by date) which made it possible to list all the books by an author.</p>\n\n<p>However, unless I'm mistaken, a <code>Vec</code> in Rust can't contain references to structures. So, to me it looks like it is not possible to for each <code>Author</code> to have a vector of references to the books in the <code>Library</code>.</p>\n\n<p>How should I do this? Is it possible to keep this structure without having multiple copies of the same <code>Book</code> structure? I would really like to be able to say <code>Library.get_book(id).set_title(\"New title\")</code> and then have the title changed in the entire program. </p>\n"}, {"tags": ["macros", "rust"], "comments": [{"owner": {"reputation": 13359, "user_id": 489590, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/e16b3d117fa188c4dbdafb8dc27a4df0?s=128&d=identicon&r=PG&f=1", "display_name": "Brian Cain", "link": "https://stackoverflow.com/users/489590/brian-cain"}, "edited": false, "score": 1, "creation_date": 1458308811, "post_id": 36085618, "comment_id": 59816463, "body": "Before reporting it as a bug you&#39;d be well served to create the minimal complete example which illustrates the problem."}, {"owner": {"reputation": 2289, "user_id": 1454653, "user_type": "registered", "accept_rate": 87, "profile_image": "https://i.stack.imgur.com/FvI1V.jpg?s=128&g=1", "display_name": "dragostis", "link": "https://stackoverflow.com/users/1454653/dragostis"}, "reply_to_user": {"reputation": 13359, "user_id": 489590, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/e16b3d117fa188c4dbdafb8dc27a4df0?s=128&d=identicon&r=PG&f=1", "display_name": "Brian Cain", "link": "https://stackoverflow.com/users/489590/brian-cain"}, "edited": false, "score": 0, "creation_date": 1458309115, "post_id": 36085618, "comment_id": 59816682, "body": "@BrianCain Of course."}], "answers": [{"comments": [{"owner": {"reputation": 2289, "user_id": 1454653, "user_type": "registered", "accept_rate": 87, "profile_image": "https://i.stack.imgur.com/FvI1V.jpg?s=128&g=1", "display_name": "dragostis", "link": "https://stackoverflow.com/users/1454653/dragostis"}, "edited": false, "score": 0, "creation_date": 1458310534, "post_id": 36086556, "comment_id": 59817748, "body": "This works, but since they are in the same context, it makes no sense for them to be different, especially considering the output that I got from the macro&#39;s output."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 4, "last_activity_date": 1458310150, "creation_date": 1458310150, "answer_id": 36086556, "question_id": 36085618, "link": "https://stackoverflow.com/questions/36085618/why-does-rust-not-find-variables-in-multi-statement-macros/36086556#36086556", "title": "Why does Rust not find variables in multi-statement macros?", "body": "<p>Try this:</p>\n\n<pre><code>( $mrb:expr, $sig:expr, $args:ident, $name:ident : $t:tt) =&gt; {{\n    let $args = uninitialized::&lt;*const MRValue&gt;();\n    let count = uninitialized::&lt;i32&gt;();\n\n    mrb_get_args($mrb, $sig, args!($name, $t), &amp;$args as *const *const MRValue,\n                 &amp;count as *const i32);\n}};\n</code></pre>\n\n<p>(note that the body of the macro expansion is wrapped into the second set of braces)</p>\n\n<p>I don't remember the exact reason why you need this, but the basic idea is that each statement in the macro expansion block is expanded with its own hygiene context, therefore <code>$args</code> in the first line is not the same as <code>$args</code> in the last line. If you put all the statements into a single block, however, the hygiene context becomes shared, and both expansions of <code>$args</code> now refer to the same identifier. So, this is likely not a bug; it's just how macro expansion in Rust works.</p>\n"}, {"tags": [], "owner": {"reputation": 2289, "user_id": 1454653, "user_type": "registered", "accept_rate": 87, "profile_image": "https://i.stack.imgur.com/FvI1V.jpg?s=128&g=1", "display_name": "dragostis", "link": "https://stackoverflow.com/users/1454653/dragostis"}, "is_accepted": true, "score": 0, "last_activity_date": 1461948362, "creation_date": 1461948362, "answer_id": 36943597, "question_id": 36085618, "link": "https://stackoverflow.com/questions/36085618/why-does-rust-not-find-variables-in-multi-statement-macros/36943597#36943597", "title": "Why does Rust not find variables in multi-statement macros?", "body": "<p>The basic reason why this doesn't work is because multi-statement macros are broken. Any macros that don't return a value (e.g. a block) will only return the first statement.</p>\n\n<pre><code>macro_rules! example {\n    ( $name:ident ) =&gt; {\n        let mut $name = 0;\n        let mut $name = 1;\n    }\n}\n\nfn main() {\n    example!(x);\n\n    println!(\"{}\", x);\n}\n</code></pre>\n\n<p>This example prints <code>0</code>, not <code>1</code>. The <a href=\"https://github.com/rust-lang/rust/issues/31856\" rel=\"nofollow\">bug</a> has been closed, though, at it will probably land in Rust 1.10.</p>\n\n<p>In the meanwhile, use blocks where applicable.</p>\n"}], "owner": {"reputation": 2289, "user_id": 1454653, "user_type": "registered", "accept_rate": 87, "profile_image": "https://i.stack.imgur.com/FvI1V.jpg?s=128&g=1", "display_name": "dragostis", "link": "https://stackoverflow.com/users/1454653/dragostis"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 147, "favorite_count": 0, "accepted_answer_id": 36943597, "answer_count": 2, "score": 4, "last_activity_date": 1461948396, "creation_date": 1458307556, "last_edit_date": 1461948396, "question_id": 36085618, "link": "https://stackoverflow.com/questions/36085618/why-does-rust-not-find-variables-in-multi-statement-macros", "title": "Why does Rust not find variables in multi-statement macros?", "body": "<p>I have a macro that gets called inside an <code>unsafe</code> block which has the following pattern:</p>\n\n<pre><code>( $mrb:expr, $sig:expr, $args:ident, $name:ident : $t:tt) =&gt; {\n    let $args = uninitialized::&lt;*const MRValue&gt;();\n    let count = uninitialized::&lt;i32&gt;();\n\n    mrb_get_args($mrb, $sig, args!($name, $t), &amp;$args as *const *const MRValue,\n                 &amp;count as *const i32);\n};\n</code></pre>\n\n<p>I've expanded the macro with <code>--pretty expanded,hygiene</code> which gives me:</p>\n\n<pre><code>let args /* 77#30 */ =\n    uninitialized /* 789#28\n        */::&lt;*const MRValue /* 793#28 */&gt;();\n let count /* 807#31 */ =\n     uninitialized /* 789#28 */::&lt;i32 /* 68#28 */&gt;();\n mrb_get_args /* 805#28\n     */(mrb /* 804#29 */, sig /* 797#29 */,\n        &amp;v /* 76#33 */ as *const i32 /* 68#34 */,\n        &amp;args /* 77#27 */ as\n            *const *const MRValue /* 793#28 */,\n        &amp;count /* 807#28 */ as *const i32 /* 68#28 */);\n</code></pre>\n\n<p><code>args</code> appear to be the same (<code>77</code>) and count also appear to be the same (<code>807</code>), but I'm getting the following error nonetheless:</p>\n\n<pre><code>&lt;mrusty macros&gt;:24:20: 24:21 error: unresolved name `args`. Did you mean the macro `args!`? [E0425]\n&lt;mrusty macros&gt;:24 mrb , sig , $ args , $ ( $ name : $ t ) , * ) ; conv ! (\n                                  ^\n&lt;mrusty macros&gt;:23:29: 24:48 note: in this expansion of args_rest! (defined in &lt;mrusty macros&gt;)\nsrc/main.rs:12:47: 16:7 note: in this expansion of mrfn! (defined in &lt;mrusty macros&gt;)\n&lt;mrusty macros&gt;:24:20: 24:21 help: run `rustc --explain E0425` to see a detailed explanation\n&lt;mrusty macros&gt;:6:5: 6:10 error: unresolved name `count` [E0425]\n&lt;mrusty macros&gt;:6 , &amp; count as * const i32 ) ; } ; (\n                  ^~~~~\n&lt;mrusty macros&gt;:23:29: 24:48 note: in this expansion of args_rest! (defined in &lt;mrusty macros&gt;)\nsrc/main.rs:12:47: 16:7 note: in this expansion of mrfn! (defined in  &lt;mrusty macros&gt;)\n&lt;mrusty macros&gt;:6:5: 6:10 help: run `rustc --explain E0425` to see a detailed explanation\n</code></pre>\n\n<p>This looks fishy and it appears to be a bug, but I'd like another pair of eyes over this before I submit an issue on Rust.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 0, "creation_date": 1458221127, "post_id": 36061817, "comment_id": 59770318, "body": "Is there always 8 bits of padding between each item in a struct?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 0, "creation_date": 1458221227, "post_id": 36061817, "comment_id": 59770390, "body": "no, padding is just stuff that&#39;s irrelevant. the padding exists just because the other field is aligned"}, {"owner": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "reply_to_user": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 1, "creation_date": 1458221258, "post_id": 36061817, "comment_id": 59770412, "body": "@Fluffy Not necessarily. If <code>x</code> was also <code>u16</code>, no padding would be required. If <code>x</code> was still <code>u8</code> and you had a <code>x2</code> field that&#39;s also <code>u8</code> between <code>x</code> and <code>y</code>, you still wouldn&#39;t need padding. Do you see why? (Note that you can look up struct alignment regardless of language - the reasons are always the same.)"}, {"owner": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "reply_to_user": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "edited": false, "score": 0, "creation_date": 1458221387, "post_id": 36061817, "comment_id": 59770523, "body": "@TheodorosChatzigiannakis I think so. It&#39;s faster if all the fields are the same size?"}, {"owner": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "reply_to_user": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 3, "creation_date": 1458221536, "post_id": 36061817, "comment_id": 59770654, "body": "@Fluffy It&#39;s not faster if all fields are the same size. The logic is that <code>u8</code> is 8-bit aligned while <code>u16</code> is16-bit aligned. This creates a necessary 8-bit space between the two. You can choose to use the space yourself (by extending the first field to 16 bits or by introducing an intermediate 8-bit field) or you can leave it unused (and it&#39;s called padding) but either way the compiler will put the 8-bit space there, whether you intend to name it as a field or not. (Unless you explicitly ask for a packed struct, as mentioned in the answer.)"}, {"owner": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "edited": false, "score": 0, "creation_date": 1458221643, "post_id": 36061817, "comment_id": 59770738, "body": "Look at this answer for a relevant schematic: <a href=\"http://stackoverflow.com/a/381368/1892179\">stackoverflow.com/a/381368/1892179</a>"}, {"owner": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "reply_to_user": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "edited": false, "score": 0, "creation_date": 1458221648, "post_id": 36061817, "comment_id": 59770742, "body": "@TheodorosChatzigiannakis Sorry if I&#39;m not getting it, but would the way to circumnavigate the issue be making each successive field the same size or larger than the previous one?"}, {"owner": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "reply_to_user": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 0, "creation_date": 1458221924, "post_id": 36061817, "comment_id": 59770979, "body": "@Fluffy Maybe rearranging the fields could give you a different size in some cases, but probably not in this particular case where you only have an 8-bit field and a 16-bit field (because even if you turn them around, I would expect the compiler to introduce padding at the end to make sure that <i>arrays</i> of your struct are aligned). I don&#39;t know if there&#39;s any algorithm you can do in your mind to pack structs manually without sacrificing speed. It&#39;s usually an intuitive process, but there are resources that could help you get a general idea. See <a href=\"http://www.catb.org/esr/structure-packing/\" rel=\"nofollow noreferrer\">catb.org/esr/structure-packing</a>"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 0, "creation_date": 1458221944, "post_id": 36061817, "comment_id": 59770997, "body": "@Fluffy: no, as I said, Rust&#39;s memory layout is undefined, Rust may at any time change the order and introduce arbitrary padding. It&#39;s unlikely it&#39;ll do something odd, but it&#39;s allowed to. If you use <code>repr(C)</code> or <code>repr(packed)</code>, you get a somewhat deterministic layout (on a single platform, e.g. windows and linux may differ), but following complex rules"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 4, "creation_date": 1458222026, "post_id": 36061817, "comment_id": 59771071, "body": "@Fluffy even if you somehow work around alignment problems (which is unlikely), you will still have the problem of byte order, which is important if you need your data to be passed across network. Reinterpreting a byte array as a struct is inherently non-portable. That&#39;s why there is a lot of serialization formats available."}, {"owner": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "edited": false, "score": 0, "creation_date": 1458222036, "post_id": 36061817, "comment_id": 59771084, "body": "Thanks, you&#39;ve been really useful."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 16, "last_activity_date": 1471098277, "last_edit_date": 1495541780, "creation_date": 1458220917, "answer_id": 36061817, "question_id": 36061560, "link": "https://stackoverflow.com/questions/36061560/can-i-take-a-byte-array-and-deserialize-it-into-a-struct/36061817#36061817", "title": "Can I take a byte array and deserialize it into a struct?", "body": "<p>The issue here is that the <code>y</code> field is 16-bit-aligned. So your memory layout is actually</p>\n\n<pre><code>x\npadding\ny\ny\n</code></pre>\n\n<p>Note that swapping the order of <code>x</code> and <code>y</code> doesn't help, because Rust's memory layout for structs is actually undefined (and thus still 32 bits for no reason but simplicity in the compiler). If you depend on it you will get undefined behavior.</p>\n\n<p>The reasons for alignment are explained in <a href=\"https://stackoverflow.com/questions/381244/purpose-of-memory-alignment/381368#381368\">Purpose of memory alignment</a>.</p>\n\n<p>You can prevent alignment from happening by adding the attribute <code>repr(packed)</code> to your struct, but you'll lose performance and the ability to take references of fields:</p>\n\n<pre><code>#[repr(packed)]\nstruct Things {\n    x: u8,\n    y: u16,\n}\n</code></pre>\n\n<hr>\n\n<p>The best way would be to not use <code>transmute</code> at all, but to extract the values manually and hope the optimizer makes it fast:</p>\n\n<pre><code>let foobar = Things {\n    x: array[0],\n    y: ((array[1] as u16) &lt;&lt; 8) | (array[2] as u16),\n};\n</code></pre>\n\n<p>A crate like <a href=\"https://github.com/BurntSushi/byteorder\" rel=\"nofollow noreferrer\">byteorder</a> may simplify the process of reading different sizes and endianness from the bytes.</p>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1471179839, "post_id": 38939285, "comment_id": 65240003, "body": "Note that this has the same issues as many other answers on SO: It doesn&#39;t take into account alignment, potential padding in the target type (not a problem for <code>u64</code>), or endianness."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1471249831, "post_id": 38939285, "comment_id": 65257688, "body": "There&#39;s no need to use transmute on a pointer, just cast the pointer. This will prevent accidental transmuting between pointers and pointers to pointers, as the casts are somewhat typechecked"}, {"owner": {"reputation": 3376, "user_id": 134409, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/e1ec6b4e77bfbae1b992957792572630?s=128&d=identicon&r=PG", "display_name": "dpc.pw", "link": "https://stackoverflow.com/users/134409/dpc-pw"}, "edited": false, "score": 0, "creation_date": 1471286249, "post_id": 38939285, "comment_id": 65276390, "body": "As other have said, this is not recommended, but it&#39;s exactly what OP asked, and it&#39;s technically correct. Endianess and rest of the details to take care of if someone wants to go this route."}], "tags": [], "owner": {"reputation": 3376, "user_id": 134409, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/e1ec6b4e77bfbae1b992957792572630?s=128&d=identicon&r=PG", "display_name": "dpc.pw", "link": "https://stackoverflow.com/users/134409/dpc-pw"}, "is_accepted": false, "score": -1, "last_activity_date": 1471150725, "creation_date": 1471150725, "answer_id": 38939285, "question_id": 36061560, "link": "https://stackoverflow.com/questions/36061560/can-i-take-a-byte-array-and-deserialize-it-into-a-struct/38939285#38939285", "title": "Can I take a byte array and deserialize it into a struct?", "body": "<pre><code>use std::mem;\n\nfn main() {\n    let bytes = vec!(0u8, 1u8,2u8, 3, 4, 5, 6, 7, 8, 9, 0xffu8, );\n\n\n    let data_ptr: *const u64 = unsafe { mem::transmute(bytes[0..4].as_ptr()) };\n\n    let data: u64 = unsafe { *data_ptr };\n\n    println!(\"{:#x}\", data);\n}\n</code></pre>\n"}], "owner": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5944, "favorite_count": 1, "accepted_answer_id": 36061817, "answer_count": 2, "score": 13, "last_activity_date": 1471150725, "creation_date": 1458220302, "last_edit_date": 1471098434, "question_id": 36061560, "link": "https://stackoverflow.com/questions/36061560/can-i-take-a-byte-array-and-deserialize-it-into-a-struct", "title": "Can I take a byte array and deserialize it into a struct?", "body": "<p>I'm reading a series of bytes from a socket and I need to put each segment of n bytes as a item in a struct.</p>\n\n<pre><code>use std::mem;\n\n#[derive(Debug)]\nstruct Things {\n    x: u8,\n    y: u16,\n}\n\nfn main() {\n    let array = [22 as u8, 76 as u8, 34 as u8];\n    let foobar: Things;\n    unsafe {\n        foobar = mem::transmute::&lt;[u8; 3], Things&gt;(array);\n    }\n\n    println!(\"{:?}\", foobar);\n\n}\n</code></pre>\n\n<p>I'm getting errors that say that <code>foobar</code> is 32 bits when <code>array</code> is 24 bits. Shouldn't <code>foobar</code> be 24 bits (8 + 16 = 24)?</p>\n"}, {"tags": ["windows", "rust", "rust-cargo"], "comments": [{"owner": {"reputation": 644, "user_id": 5326062, "user_type": "registered", "accept_rate": 67, "profile_image": "https://lh3.googleusercontent.com/-wyQqFvVdnKo/AAAAAAAAAAI/AAAAAAAAAwY/atuvPb80mWU/photo.jpg?sz=128", "display_name": "Ivan Temchenko", "link": "https://stackoverflow.com/users/5326062/ivan-temchenko"}, "edited": false, "score": 0, "creation_date": 1458220006, "post_id": 36061005, "comment_id": 59769454, "body": "try to rename folder <code>c:\\users\\YORUSERNAME\\.cargo\\registry\\index\\github.com-88ac12&zwnj;&#8203;8001ac3a9a</code> and run it again"}, {"owner": {"reputation": 45, "user_id": 899847, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/39922d3d533e4c0daa6bcf40d903f56d?s=128&d=identicon&r=PG", "display_name": "McAvoy", "link": "https://stackoverflow.com/users/899847/mcavoy"}, "reply_to_user": {"reputation": 644, "user_id": 5326062, "user_type": "registered", "accept_rate": 67, "profile_image": "https://lh3.googleusercontent.com/-wyQqFvVdnKo/AAAAAAAAAAI/AAAAAAAAAwY/atuvPb80mWU/photo.jpg?sz=128", "display_name": "Ivan Temchenko", "link": "https://stackoverflow.com/users/5326062/ivan-temchenko"}, "edited": false, "score": 0, "creation_date": 1458220436, "post_id": 36061005, "comment_id": 59769751, "body": "The actual folder in the could not open message is c:\\users\\YORUSERNAME\\.cargo\\registry\\index\\github.com-88ac12&zwnj;&#8203;8001ac3a9a. I omitted c:\\users\\username."}, {"owner": {"reputation": 644, "user_id": 5326062, "user_type": "registered", "accept_rate": 67, "profile_image": "https://lh3.googleusercontent.com/-wyQqFvVdnKo/AAAAAAAAAAI/AAAAAAAAAwY/atuvPb80mWU/photo.jpg?sz=128", "display_name": "Ivan Temchenko", "link": "https://stackoverflow.com/users/5326062/ivan-temchenko"}, "edited": false, "score": 0, "creation_date": 1458221072, "post_id": 36061005, "comment_id": 59770265, "body": "I know, but can you rename it VIA explorer? )"}, {"owner": {"reputation": 45, "user_id": 899847, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/39922d3d533e4c0daa6bcf40d903f56d?s=128&d=identicon&r=PG", "display_name": "McAvoy", "link": "https://stackoverflow.com/users/899847/mcavoy"}, "reply_to_user": {"reputation": 644, "user_id": 5326062, "user_type": "registered", "accept_rate": 67, "profile_image": "https://lh3.googleusercontent.com/-wyQqFvVdnKo/AAAAAAAAAAI/AAAAAAAAAwY/atuvPb80mWU/photo.jpg?sz=128", "display_name": "Ivan Temchenko", "link": "https://stackoverflow.com/users/5326062/ivan-temchenko"}, "edited": false, "score": 0, "creation_date": 1458222972, "post_id": 36061005, "comment_id": 59771841, "body": "I did. I get the same error"}], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 0, "last_activity_date": 1458611698, "creation_date": 1458611698, "answer_id": 36144910, "question_id": 36061005, "link": "https://stackoverflow.com/questions/36061005/cargo-registry-update-always-fails/36144910#36144910", "title": "Cargo registry update always fails", "body": "<p>Your anti-virus software may be interfering with the operation. Try disabling your anti-virus software temporarily, or add an exception for the problematic folders in your anti-virus software configuration.</p>\n"}], "owner": {"reputation": 45, "user_id": 899847, "user_type": "registered", "accept_rate": 33, "profile_image": "https://www.gravatar.com/avatar/39922d3d533e4c0daa6bcf40d903f56d?s=128&d=identicon&r=PG", "display_name": "McAvoy", "link": "https://stackoverflow.com/users/899847/mcavoy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 345, "favorite_count": 0, "answer_count": 1, "score": 0, "last_activity_date": 1458611698, "creation_date": 1458218858, "last_edit_date": 1458221397, "question_id": 36061005, "link": "https://stackoverflow.com/questions/36061005/cargo-registry-update-always-fails", "title": "Cargo registry update always fails", "body": "<p>I am having trouble building Rust programs on Windows. Everything builds fine until I add a dependency. Once a dependency is added I get the following trying to update the crates registry. Any ideas? </p>\n\n<pre><code>cargo build --verbose\n        Updating registry `https://github.com/rust-lang/crates.io-index`\n           error Unable to update registry https://github.com/rust-lang/crates.io-index\n\n    Caused by:\n      [2/-1] Could not open '.cargo/registry/index/github.com-88ac128001ac3a9a/bi/tt/bittorrent' for writing: Access is denied.\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 920, "user_id": 217275, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/f01054ce44a50811a5fc96f634e8a0d2?s=128&d=identicon&r=PG", "display_name": "Piotr Zolnierek", "link": "https://stackoverflow.com/users/217275/piotr-zolnierek"}, "edited": false, "score": 0, "creation_date": 1458276493, "post_id": 36068569, "comment_id": 59798017, "body": "How do you get the MIR output??"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 920, "user_id": 217275, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/f01054ce44a50811a5fc96f634e8a0d2?s=128&d=identicon&r=PG", "display_name": "Piotr Zolnierek", "link": "https://stackoverflow.com/users/217275/piotr-zolnierek"}, "edited": false, "score": 0, "creation_date": 1458289365, "post_id": 36068569, "comment_id": 59803492, "body": "so basically it means rustc can&#39;t unsize rvalue references, but only actual references. @PiotrZolnierek: there&#39;s a <code>MIR</code> button on <a href=\"http://play.rust-lang.org\" rel=\"nofollow noreferrer\">play.rust-lang.org</a>"}], "tags": [], "owner": {"reputation": 133, "user_id": 1030074, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f611c9486d0d7303f29e453599e52cee?s=128&d=identicon&r=PG", "display_name": "Sean Gillespie", "link": "https://stackoverflow.com/users/1030074/sean-gillespie"}, "is_accepted": false, "score": 5, "last_activity_date": 1458262713, "last_edit_date": 1458262713, "creation_date": 1458238429, "answer_id": 36068569, "question_id": 36057645, "link": "https://stackoverflow.com/questions/36057645/why-is-let-ref-a-trait-struct-forbidden/36068569#36068569", "title": "Why is `let ref a: Trait = Struct` forbidden?", "body": "<p>There's a little bit of unsized subtlety going on here. The key difference between </p>\n\n<pre><code>let a: &amp;Struct = &amp;Struct;\nlet ref a: Struct = *a;\n</code></pre>\n\n<p>and</p>\n\n<pre><code>let a: &amp;Trait = &amp;Struct;\nlet ref a: Trait = *a;\n</code></pre>\n\n<p>Is that the expression <code>*a</code> produces a value whose size is not known at compile-time. This manifests as an error when we attempt to do:</p>\n\n<pre><code>let ref a: Trait = Struct as Trait;\n\n&lt;anon&gt;:6:24: 6:39 error: cast to unsized type: `Struct` as `Trait`\n&lt;anon&gt;:6     let ref a: Trait = Struct as Trait;\n                                ^~~~~~~~~~~~~~~\n&lt;anon&gt;:6:24: 6:30 help: consider using a box or reference as appropriate\n&lt;anon&gt;:6     let ref a: Trait = Struct as Trait;\n</code></pre>\n\n<p>In general, the compiler can't know the size of a bare trait used as a type, like <code>Trait</code> is used here. This is because <em>any type</em> can implement <code>Trait</code> - so the size of trait can be <em>any size</em>, depending on the type that implements it. So, that explains why <code>let ref a: Trait = Struct</code> and <code>let a: &amp;Struct = &amp;Struct; let ref a: Trait = *a</code> don't work, because casting a <code>Struct</code> to a <code>Trait</code> is an unsized cast.</p>\n\n<p>As for why your working trait code snippet works, looking at the MIR for these two examples, we can see that the compiler is treating the two above assignments slightly differently:</p>\n\n<pre><code>let a: &amp;Struct = &amp;Struct;\nlet ref a: Struct = *a;\n\nbb0: {\n    tmp1 = Struct;\n    tmp0 = &amp;tmp1;\n    var0 = &amp;(*tmp0);\n    var1 = &amp;(*var0);\n    return = ();\n    goto -&gt; bb1;\n}\n\nlet a: &amp;Trait = &amp;Struct;\nlet ref a: Trait = *a;\n\nbb0: {\n    tmp2 = Struct;\n    tmp1 = &amp;tmp2;\n    tmp0 = &amp;(*tmp1);\n    var0 = tmp0 as &amp;'static Trait + 'static (Unsize);\n    var1 = &amp;(*var0);\n    return = ();\n    goto -&gt; bb1;\n}\n</code></pre>\n\n<p>We see that the compiler has to do a cast to a <em>trait object</em> <code>&amp;'static Trait + 'static</code> to satisfy the implicit coercion of <code>&amp;Struct</code> to <code>&amp;Trait</code>. From there, the ref pattern is simply <code>var1 = &amp;(*var0);</code>, which in this case is a simple assignment from the trait object <code>var0</code> to the trait object <code>var1</code>.</p>\n\n<p>This is similar to the MIR generated by this function:</p>\n\n<pre><code>fn stuff() {\n    let sized = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n    let slice : &amp;[u8] = &amp;sized;\n    let ref other_slice = *slice;\n}\n\nbb0: {\n    var0 = [const 1u8, ..., const 0u8];\n    tmp2 = &amp;var0;\n    tmp1 = &amp;(*tmp2);\n    var1 = tmp1 as &amp;'static [u8] (Unsize);\n    var2 = &amp;(*var1);\n    return = ();\n    goto -&gt; bb1;\n}\n</code></pre>\n\n<p>Since the type <code>[u8]</code> is unsized, it does a similar cast to a <em>slice</em>, which is quite similar in layout to a trait object. Ultimately, the compiler allows the code that doesn't introduce any unsized locals.</p>\n"}], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 264, "favorite_count": 1, "answer_count": 1, "score": 4, "last_activity_date": 1527898166, "creation_date": 1458210092, "last_edit_date": 1527898166, "question_id": 36057645, "link": "https://stackoverflow.com/questions/36057645/why-is-let-ref-a-trait-struct-forbidden", "title": "Why is `let ref a: Trait = Struct` forbidden?", "body": "<p>We have a noncopyable type and a trait:</p>\n\n<pre><code>struct Struct;\ntrait Trait {}\nimpl Trait for Struct {}\n</code></pre>\n\n<p>If we create a <code>&amp;Struct</code> and dereference it, we get an rvalue reference that we can use to initialize a by-ref binding:</p>\n\n<pre><code>let a: &amp;Struct = &amp;Struct;\nlet ref a: Struct = *a;\n</code></pre>\n\n<p>We can also directly initialize that by ref binding:</p>\n\n<pre><code>let ref a: Struct = Struct;\n</code></pre>\n\n<p>But if we declare our variable binding to require a reference, only the first code snippet works</p>\n\n<pre><code>let a: &amp;Trait = &amp;Struct;\nlet ref a: Trait = *a;\n</code></pre>\n\n<p>Attempting to do this directly</p>\n\n<pre><code>let ref a: Trait = Struct;\n</code></pre>\n\n<p>Or by going through loops</p>\n\n<pre><code>let a: &amp;Struct = &amp;Struct;\nlet ref a: Trait = *a;\n</code></pre>\n\n<p>Or</p>\n\n<pre><code>let ref a: Trait = *&amp;Struct;\n</code></pre>\n\n<p>Will give us a <code>mismatched types</code> error. Obviously they aren't the same type, but inference works for references.</p>\n\n<p>Is this simply not implemented (yet?) or is there a deeper reason it's disallowed?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 5, "last_activity_date": 1458208031, "creation_date": 1458208031, "answer_id": 36056861, "question_id": 36056408, "link": "https://stackoverflow.com/questions/36056408/access-to-self-from-the-parameters-of-a-macro-that-creates-a-struct/36056861#36056861", "title": "Access to self from the parameters of a macro that creates a struct", "body": "<p>You can pass a closure instead of a block.</p>\n\n<pre><code>make_struct!(Test |this| println!(\"Foo: {:?}\", this.foo));\n</code></pre>\n\n<p>Then the macro can use the closure and call it with <code>self</code>:</p>\n\n<pre><code>macro_rules! make_struct {\n    ($name:ident $closure:expr) =&gt; {\n        struct $name {\n            foo: i32,\n        }\n\n        impl $name {\n            fn new() -&gt; Self {\n                $name { foo: 42 }\n            }\n            fn act (&amp;self) {\n                let x: &amp;Fn(&amp;Self) = &amp;$closure;\n                x(self)\n            }\n        }\n    };\n}\n</code></pre>\n\n<p>The dance with the let binding is necessary, because the type of <code>this</code> in the closure can't be inferred (yet?). And it also makes your macro's error reporting a little more readable when something other than a closure is passed.</p>\n"}, {"tags": [], "owner": {"reputation": 8877, "user_id": 5397009, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/7405bb106a62e8a3ea2d6d787b7261ee?s=128&d=identicon&r=PG&f=1", "display_name": "Jmb", "link": "https://stackoverflow.com/users/5397009/jmb"}, "is_accepted": true, "score": 3, "last_activity_date": 1458228892, "creation_date": 1458228892, "answer_id": 36065137, "question_id": 36056408, "link": "https://stackoverflow.com/questions/36056408/access-to-self-from-the-parameters-of-a-macro-that-creates-a-struct/36065137#36065137", "title": "Access to self from the parameters of a macro that creates a struct", "body": "<p>Found a way to do it by adding a parameter to the macro that stores the name by which <code>self</code> will be accessed in the blocks:</p>\n\n<pre><code>macro_rules! make_struct {\n    ($myname:ident : $type_name:ident $block:block) =&gt; {\n        struct $type_name {\n            foo: i32,\n        }\n\n        impl $type_name {\n            fn new() -&gt; Self {\n                $type_name { foo: 42 }\n            }\n            fn act (&amp;self) {\n                let $myname = self;\n                $block\n            }\n        }\n    };\n}\n\nfn main() {\n    make_struct!(myself: Test { println! (\"Foo: {:?}\", myself.foo); });\n    let test = Test::new();\n    test.act();\n}\n</code></pre>\n"}], "owner": {"reputation": 8877, "user_id": 5397009, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/7405bb106a62e8a3ea2d6d787b7261ee?s=128&d=identicon&r=PG&f=1", "display_name": "Jmb", "link": "https://stackoverflow.com/users/5397009/jmb"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 719, "favorite_count": 0, "accepted_answer_id": 36065137, "answer_count": 2, "score": 2, "last_activity_date": 1458228892, "creation_date": 1458206898, "question_id": 36056408, "link": "https://stackoverflow.com/questions/36056408/access-to-self-from-the-parameters-of-a-macro-that-creates-a-struct", "title": "Access to self from the parameters of a macro that creates a struct", "body": "<p>I'm trying to write a macro that generates a struct. The implementation for the struct will be generated by the macro, but some blocks of code will be provided as macro arguments. Here is a minimal example of such a macro:</p>\n\n<pre><code>macro_rules! make_struct {\n    ($name:ident $block:block) =&gt; {\n        struct $name {\n            foo: i32,\n        }\n\n        impl $name {\n            fn new() -&gt; Self {\n                $name { foo: 42 }\n            }\n            fn act (&amp;self) {\n                $block\n            }\n        }\n    };\n}\n</code></pre>\n\n<p>And here is an example of how the macro can be used:</p>\n\n<pre><code>fn main() {\n    // Works\n    make_struct!(Test { println! (\"Bar: {:?}\", 24); });\n    let test = Test::new();\n    test.act();\n}\n</code></pre>\n\n<p>I would like to give access to <code>self</code> inside the supplied code. Something like:</p>\n\n<pre><code>fn main() {\n    // Does not work\n    make_struct!(Test { println! (\"Foo: {:?}\", self.foo); });\n    let test = Test::new();\n    test.act();\n}\n</code></pre>\n\n<p>I understand that this does not work because of macro hygiene rules. Specifically, the <code>self.foo</code> expression is evaluated in the syntax context of the <code>main</code> function, where <code>self</code> does not exist. The question is: is there a way to modify the macro so that <code>self</code> may be accessed from the user-supplied code?</p>\n\n<p><a href=\"http://is.gd/r0LRcE\" rel=\"nofollow\">Code on playground</a></p>\n"}]