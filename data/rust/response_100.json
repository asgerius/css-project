[{"tags": ["rust"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1481120874, "post_id": 41019780, "comment_id": 69247075, "body": "I was looking for something like <code>let pipe2 = Stdio::from_raw_fd(pipe.to_raw_fd())</code>, but I can&#39;t see an implementation of <code>AsRawFd</code> in the documentation, annoyingly."}, {"owner": {"reputation": 10840, "user_id": 1198729, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/0a3069491bfded90cdf623341cadc1d1?s=128&d=identicon&r=PG", "display_name": "Manishearth", "link": "https://stackoverflow.com/users/1198729/manishearth"}, "edited": false, "score": 0, "creation_date": 1481127568, "post_id": 41019780, "comment_id": 69251804, "body": "I&#39;m not sure if <code>Stdio::piped()</code> is what you need, but why not just use <code>.stdout(Stdio::piped()).stderr(Stdio::piped())</code>? <a href=\"http://rustbyexample.com/std_misc/process/pipe.html\" rel=\"nofollow noreferrer\">RustByExample</a> does this."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 10840, "user_id": 1198729, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/0a3069491bfded90cdf623341cadc1d1?s=128&d=identicon&r=PG", "display_name": "Manishearth", "link": "https://stackoverflow.com/users/1198729/manishearth"}, "edited": false, "score": 1, "creation_date": 1481128390, "post_id": 41019780, "comment_id": 69252344, "body": "@Manishearth That sounds like it will redirect stdin and stdout to two <i>separate</i> pipes. The OP might want to redirect them to the same pipe without losing ordering information between their contents. The equivalent Bourne shell construct is, for instance, <code>output=$(command 2&gt;&amp;1)</code>."}, {"owner": {"reputation": 361, "user_id": 4237232, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-9O5kKSPEl6Y/AAAAAAAAAAI/AAAAAAAAAB0/ht9QINTIVnQ/photo.jpg?sz=128", "display_name": "Demur Rumed", "link": "https://stackoverflow.com/users/4237232/demur-rumed"}, "edited": false, "score": 3, "creation_date": 1481135700, "post_id": 41019780, "comment_id": 69256850, "body": "<a href=\"https://github.com/rust-lang/rfcs/issues/871\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/issues/871</a>"}], "answers": [{"comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1481144022, "post_id": 41024767, "comment_id": 69261650, "body": "The solution provided in the answer is not equivalent to the <code>2&gt;&amp;1</code> style redirection because it loses ordering information (as correctly described in the answer). In unstable Rust there is a <code>before_exec</code> method which could be used to perform <code>unsafe { libc::dup2(1, 2) }</code> - except that would only work on Unix-like platforms."}, {"owner": {"reputation": 25756, "user_id": 39648, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/0d9ffb2252f073517660f2d0bf71d0db?s=128&d=identicon&r=PG", "display_name": "Autodidact", "link": "https://stackoverflow.com/users/39648/autodidact"}, "edited": false, "score": 0, "creation_date": 1481169911, "post_id": 41024767, "comment_id": 69270583, "body": "Yeah the ordering may not be totally deterministic in the general case but consider the case when all output is generated on a single thread in the child process. In this case there is going to be strict ordering between all &quot;printfs&quot; in the program. This ordering information is lost when the printfs print to different pipes but if they print to the same pipe then you will always be able to know the order in which the messages were printed."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1481142819, "last_edit_date": 1495541344, "creation_date": 1481135449, "answer_id": 41024767, "question_id": 41019780, "link": "https://stackoverflow.com/questions/41019780/merge-child-process-stdout-and-stderr/41024767#41024767", "title": "Merge child process stdout and stderr", "body": "<p>I see nothing in the standard library that does this for you. Doesn't mean you can't write it yourself. This also means you get to decide how frequently each file descriptor is read and how to combine the data from each of the file descriptors. Here, I attempt to read in chunks using the default <code>BufReader</code> size and prefer to put stdout data first when both descriptors have data.</p>\n\n<pre><code>use std::io::prelude::*;\nuse std::io::BufReader;\nuse std::process::{Command, Stdio};\n\nfn main() {\n    let mut child =\n        Command::new(\"/tmp/output\")\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped())\n        .spawn()\n        .expect(\"Couldn't run program\");\n\n    let mut output = Vec::new();\n\n    // Should be moved to a function that accepts something implementing `Write`\n    {\n        let stdout = child.stdout.as_mut().expect(\"Wasn't stdout\");\n        let stderr = child.stderr.as_mut().expect(\"Wasn't stderr\");\n\n        let mut stdout = BufReader::new(stdout);\n        let mut stderr = BufReader::new(stderr);\n\n        loop {\n            let (stdout_bytes, stderr_bytes) = match (stdout.fill_buf(), stderr.fill_buf()) {\n                (Ok(stdout), Ok(stderr)) =&gt; {\n                    output.write_all(stdout).expect(\"Couldn't write\");\n                    output.write_all(stderr).expect(\"Couldn't write\");\n\n                    (stdout.len(), stderr.len())\n                }\n                other =&gt; panic!(\"Some better error handling here... {:?}\", other)\n            };\n\n            if stdout_bytes == 0 &amp;&amp; stderr_bytes == 0 {\n                // Seems less-than-ideal; should be some way of\n                // telling if the child has actually exited vs just\n                // not outputting anything.\n                break;\n            }\n\n            stdout.consume(stdout_bytes);\n            stderr.consume(stderr_bytes);\n        }\n    }\n\n    let status = child.wait().expect(\"Waiting for child failed\");\n    println!(\"Finished with status {:?}\", status);\n    println!(\"Combined output: {:?}\", std::str::from_utf8(&amp;output))\n}\n</code></pre>\n\n<p>The biggest gap is telling when the process has exited. I'm surprised by the lack of a relevant method on <code>Child</code>.</p>\n\n<p>See also <a href=\"https://stackoverflow.com/q/29458970/155423\">How do I prefix Command stdout with [stdout] and [sterr]?</a></p>\n\n<hr>\n\n<p>In this solution, there isn't any intrinsic ordering between the file descriptors. As an analogy, imagine two buckets of water. If you empty a bucket and later see that it's been filled up again, you know the second bucket came after the first. However, if you empty two buckets and come back later and both are filled up, you can't tell which bucket was filled first.</p>\n\n<p>The \"quality\" of interleaving is a matter of how frequently you read from each file descriptor and which file descriptor is read first. If you read a single byte from each in a very tight loop, you might get completely garbled results but these would be the most \"accurate\" with regard to ordering. Likewise, if a program prints \"A\" to stderr then \"B\" to stdout but the shell reads from stdout before stderr, then the result would be \"BA\", which looks backwards.</p>\n"}, {"tags": [], "owner": {"reputation": 7971, "user_id": 823869, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/0e7b6173470ead2fe170d55b317a9b1d?s=128&d=identicon&r=PG", "display_name": "Jack O&#39;Connor", "link": "https://stackoverflow.com/users/823869/jack-oconnor"}, "is_accepted": false, "score": 11, "last_activity_date": 1569191545, "last_edit_date": 1569191545, "creation_date": 1481138706, "answer_id": 41025699, "question_id": 41019780, "link": "https://stackoverflow.com/questions/41019780/merge-child-process-stdout-and-stderr/41025699#41025699", "title": "Merge child process stdout and stderr", "body": "<p>My <a href=\"https://github.com/oconnor663/duct.rs\" rel=\"nofollow noreferrer\"><code>duct</code></a> crate supports this:</p>\n\n<pre><code>#[macro_use]\nextern crate duct;\n\nfn main() {\n    cmd!(\"echo\", \"hi\").stderr_to_stdout().run();\n}\n</code></pre>\n\n<p>The \"right way\" to do something like this, which <code>duct</code> is doing for you under the covers, is to create a double-ended OS pipe and pass the write end of it to both stdout and stderr. The standard library's <code>Command</code> class supports this sort of thing in general because <code>Stdio</code> implements <code>FromRawFd</code>, but unfortunately the standard library doesn't expose a way to create pipes. I've written another crate called <a href=\"https://github.com/oconnor663/os_pipe.rs\" rel=\"nofollow noreferrer\"><code>os_pipe</code></a> to do this inside of <code>duct</code>, and if you want you can use it directly.</p>\n\n<p><em>This has been tested on Linux, Windows, and macOS.</em></p>\n"}, {"tags": [], "owner": {"reputation": 11, "user_id": 13801793, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1bd07f791d8ed5989a92790b0a1f9ea4?s=128&d=identicon&r=PG", "display_name": "Josh Triplett", "link": "https://stackoverflow.com/users/13801793/josh-triplett"}, "is_accepted": false, "score": 1, "last_activity_date": 1592948367, "creation_date": 1592948367, "answer_id": 62544179, "question_id": 41019780, "link": "https://stackoverflow.com/questions/41019780/merge-child-process-stdout-and-stderr/62544179#62544179", "title": "Merge child process stdout and stderr", "body": "<p>I wrote the <a href=\"https://github.com/joshtriplett/io-mux/\" rel=\"nofollow noreferrer\">io-mux crate</a> to provide a multi-ended pipe-like construct; the primary use case is to capture stdout and stderr from a process, properly interleaved, and distinguish which data came from which one. See <a href=\"https://github.com/joshtriplett/highlight-stderr\" rel=\"nofollow noreferrer\">highlight-stderr</a> for an example of how to use it.</p>\n<p>(io-mux primarily works on Linux; it can work on other UNIX platforms as well, but there it has some limitations that arise from the behavior of UNIX sockets on those platforms.)</p>\n<p>If you don't care about distinguishing which data came from stdout and which data came from stderr, you can use a normal pipe. On UNIX, use <a href=\"https://docs.rs/libc/0.2.71/libc/fn.pipe.html\" rel=\"nofollow noreferrer\"><code>libc::pipe</code></a> to create a pipe, <a href=\"https://doc.rust-lang.org/std/process/struct.Stdio.html#implementations\" rel=\"nofollow noreferrer\"><code>Stdio::from_raw_fd</code></a> twice to create stdout and stderr, spawn the process, and then read from the other end of the pipe. On Windows, you can do something similar, using handles rather than file descriptors.</p>\n<p>If you don't need to distinguish which data came from stdout and which data came from stderr, and you don't want to deal with the platform-specific details of setting up a pipe, try something like <a href=\"https://crates.io/crates/subprocess\" rel=\"nofollow noreferrer\">subprocess</a>, which specifically mentions support for combining stdout and stderr.</p>\n"}, {"tags": [], "owner": {"reputation": 42073, "user_id": 113632, "user_type": "registered", "accept_rate": 84, "profile_image": "https://www.gravatar.com/avatar/f0aa6977c75f54ca9033d4f4d0244023?s=128&d=identicon&r=PG", "display_name": "dimo414", "link": "https://stackoverflow.com/users/113632/dimo414"}, "is_accepted": false, "score": 0, "last_activity_date": 1611438108, "creation_date": 1611438108, "answer_id": 65864722, "question_id": 41019780, "link": "https://stackoverflow.com/questions/41019780/merge-child-process-stdout-and-stderr/65864722#65864722", "title": "Merge child process stdout and stderr", "body": "<p>I know you're asking about <a href=\"https://doc.rust-lang.org/std/process/struct.Command.html\" rel=\"nofollow noreferrer\"><code>std::Command</code></a> but just in case it helps anyone using the <a href=\"https://crates.io/crates/subprocess\" rel=\"nofollow noreferrer\">subprocess</a> crate you can do this with <a href=\"https://docs.rs/subprocess/0.2.6/subprocess/enum.Redirection.html#variant.Merge\" rel=\"nofollow noreferrer\"><code>Redirection::Merge</code></a>:</p>\n<pre><code>.stderr(Redirection::Merge)\n</code></pre>\n"}], "owner": {"reputation": 25756, "user_id": 39648, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/0d9ffb2252f073517660f2d0bf71d0db?s=128&d=identicon&r=PG", "display_name": "Autodidact", "link": "https://stackoverflow.com/users/39648/autodidact"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2085, "favorite_count": 1, "answer_count": 4, "score": 22, "last_activity_date": 1611438108, "creation_date": 1481120352, "last_edit_date": 1481120771, "question_id": 41019780, "link": "https://stackoverflow.com/questions/41019780/merge-child-process-stdout-and-stderr", "title": "Merge child process stdout and stderr", "body": "<p>How do I merge child process stdout and stderr?</p>\n\n<p>The following does not work since ownership cannot be shared between <code>stdout</code> and <code>stderr</code>:</p>\n\n<pre><code>let pipe = Stdio::piped();\nlet prog = Command::new(\"prog\")\n                        .stdout(pipe)\n                        .stderr(pipe)\n                        .spawn()\n                        .expect(\"failed to execute prog\");\n</code></pre>\n\n<p>In other words, what is the Rust equivalent of <code>2&gt;&amp;1</code> in the shell?</p>\n"}, {"tags": ["types", "rust", "type-inference"], "comments": [{"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1481147634, "post_id": 41017140, "comment_id": 69263562, "body": "Related question: <a href=\"http://stackoverflow.com/q/40243061/1233251\">stackoverflow.com/q/40243061/1233251</a>"}], "answers": [{"comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1481192691, "post_id": 41019677, "comment_id": 69281483, "body": "A logical step missing I think; Just because multiple types want to sum to the same thing, doesn&#39;t mean there has to be another type parameter. It could be solved with an associated type <code>&amp;&#39;a i8 -&gt; i8</code> and <code>i8 -&gt; i8</code> and so on."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1481229921, "post_id": 41019677, "comment_id": 69304529, "body": "Thanks. I mean, it&#39;s not your issue, it&#39;s in the library, but since this answer was sort of going through steps to rationalize it, I wanted to point it out. Rationalizing the impl that exists is probably the road to happiness anyway ;-)"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 13, "last_activity_date": 1520944914, "last_edit_date": 1520944914, "creation_date": 1481120068, "answer_id": 41019677, "question_id": 41017140, "link": "https://stackoverflow.com/questions/41017140/why-cant-rust-infer-the-resulting-type-of-iteratorsum/41019677#41019677", "title": "Why can&#39;t Rust infer the resulting type of Iterator::sum?", "body": "<blockquote>\n  <p>and then <code>sum()</code> knows to return an <code>i32</code></p>\n</blockquote>\n\n<p>This is the key missing point. While the \"input\" type is already known (it has to be something that implements <code>Iterator</code> in order for <code>sum</code> to even be available), the \"output\" type is very flexible.</p>\n\n<p>Check out <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum\" rel=\"noreferrer\"><code>Iterator::sum</code></a>:</p>\n\n<pre><code>fn sum&lt;S&gt;(self) -&gt; S\nwhere\n    S: Sum&lt;Self::Item&gt;,\n</code></pre>\n\n<p>It returns a generic type <code>S</code> which has to implement <a href=\"https://doc.rust-lang.org/std/iter/trait.Sum.html\" rel=\"noreferrer\"><code>Sum</code></a>. <code>S</code> <strong>does not</strong> have to match <code>Self::Item</code>. Therefore, the compiler requires you to specify what \ntype to sum into.</p>\n\n<p>Why is this useful? Check out these two sample implementations from the standard library:</p>\n\n<pre><code>impl Sum&lt;i8&gt; for i8\nimpl&lt;'a&gt; Sum&lt;&amp;'a i8&gt; for i8\n</code></pre>\n\n<p>That's right! You can sum up an iterator of <code>u8</code> <strong>or</strong> an iterator of <code>&amp;u8</code>! If we didn't have this, then this code wouldn't work:</p>\n\n<pre><code>fn main() {\n    let a: i32 = (0..5).sum();\n    let b: i32 = [0, 1, 2, 3, 4].iter().sum();\n    assert_eq!(a, b);\n}\n</code></pre>\n\n<p><a href=\"https://stackoverflow.com/questions/41017140/why-cant-rust-infer-the-resulting-type-of-iteratorsum/41019677?noredirect=1#comment69281483_41019677\">As bluss points out</a>, we could accomplish this by having an <em>associated type</em> which would tie <code>u8 -&gt; u8</code> and <code>&amp;'a u8 -&gt; u8</code>. </p>\n\n<p>If we only had an associated type though, then the target sum type would always be fixed, and we'd lose flexibility. See <a href=\"https://stackoverflow.com/q/32059370/155423\">When is it appropriate to use an associated type versus a generic type?</a> for more details.</p>\n\n<p>As an example, we can also implement <code>Sum&lt;u8&gt;</code> for our own types. Here, we sum up <code>u8</code>s, but increase the size of the type we are summing, as it's likely the sum would exceed a <code>u8</code>. This implementation is in <em>addition</em> to the existing implementations from the standard library:</p>\n\n<pre><code>#[derive(Debug, Copy, Clone)]\nstruct Points(i32);\n\nimpl std::iter::Sum&lt;u8&gt; for Points {\n    fn sum&lt;I&gt;(iter: I) -&gt; Points\n    where\n        I: Iterator&lt;Item = u8&gt;,\n    {\n        let mut pts = Points(0);\n        for v in iter {\n            pts.0 += v as i32;\n        }\n        pts\n    }\n}\n\nfn main() {\n    let total: Points = (0u8..42u8).sum();\n    println!(\"{:?}\", total);\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 21, "last_activity_date": 1520944663, "last_edit_date": 1520944663, "creation_date": 1481120082, "answer_id": 41019689, "question_id": 41017140, "link": "https://stackoverflow.com/questions/41017140/why-cant-rust-infer-the-resulting-type-of-iteratorsum/41019689#41019689", "title": "Why can&#39;t Rust infer the resulting type of Iterator::sum?", "body": "<p>The way <code>sum</code> is defined, the return value is open-ended; more than one type can implement the trait <code>Sum&lt;i32&gt;</code>.  Here's an example where different types for <code>a</code> are used, both of which compile:</p>\n\n<pre><code>#[derive(Clone, Copy)]\nstruct Summer {\n    s: isize,\n}\n\nimpl Summer {\n    fn pow(&amp;self, p: isize) {\n        println!(\"pow({})\", p);\n    }\n}\n\nimpl std::iter::Sum&lt;i32&gt; for Summer {\n    fn sum&lt;I&gt;(iter: I) -&gt; Self\n    where\n        I: Iterator&lt;Item = i32&gt;,\n    {\n        let mut result = 0isize;\n        for v in iter {\n            result += v as isize;\n        }\n        Summer { s: result }\n    }\n}\n\nfn main() {\n    let a1: i32 = (1i32..10).sum();\n    let a2: Summer = (1i32..10).sum();\n    let b1 = a1.pow(2);\n    let b2 = a2.pow(2);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=174437a2ff96bdfb5bad672cc1999e68&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Playground</a></p>\n\n<p>Since both result types are possible, the type cannot be inferred and must be explicitly specified, either by a turbofish (<code>sum::&lt;X&gt;()</code>) or as the result of the expression (<code>let x: X = ...sum();</code>).</p>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2914, "favorite_count": 1, "accepted_answer_id": 41019689, "answer_count": 2, "score": 23, "last_activity_date": 1520944914, "creation_date": 1481112641, "last_edit_date": 1481141098, "question_id": 41017140, "link": "https://stackoverflow.com/questions/41017140/why-cant-rust-infer-the-resulting-type-of-iteratorsum", "title": "Why can&#39;t Rust infer the resulting type of Iterator::sum?", "body": "<p>This code works:</p>\n\n<pre><code>fn main() {\n    let a: i32 = (1i32..10).sum();\n    let b = a.pow(2);\n}\n</code></pre>\n\n<p>If I remove the <code>i32</code> type from <code>a</code>, then I get this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>rustc 1.13.0 (2c6933acc 2016-11-07)\nerror: the type of this value must be known in this context\n --&gt; &lt;anon&gt;:3:13\n  |\n5 |     let b = a.pow(2);\n  |             ^^^^^^^^\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20(1i32..10).sum()%3B%0A%20%20%20%20let%20b%20%3D%20a.pow(2)%3B%0A%7D&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Run the example</a></p>\n\n<p>I would have expected that Rust turns <code>(1i32..10)</code> into an <code>i32</code> iterator and then <code>sum()</code> knows to return an <code>i32</code>. What am I missing?</p>\n"}, {"tags": ["rust", "serde"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1481149336, "post_id": 41025891, "comment_id": 69264335, "body": "This doesn&#39;t answer the question; it deserves to be a comment."}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1481149692, "post_id": 41025891, "comment_id": 69264484, "body": "I wanted to call attention to the fact that a comment has the answer"}], "tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 1, "last_activity_date": 1481195811, "last_edit_date": 1495541831, "creation_date": 1481139434, "answer_id": 41025891, "question_id": 41016657, "link": "https://stackoverflow.com/questions/41016657/how-to-use-serde-on-stable-release-of-rust/41025891#41025891", "title": "How to use serde on stable release of Rust", "body": "<p>Ker's <a href=\"https://stackoverflow.com/questions/41016657/how-to-use-serde-on-stable-release-of-rust/41025891#comment69240572_41016657\">comment</a> deserves to be an answer. </p>\n\n<blockquote>\n  <p>right now you still need to use a build script: <a href=\"https://serde.rs/codegen-stable.html\" rel=\"nofollow noreferrer\">https://serde.rs/codegen-stable.html</a></p>\n</blockquote>\n\n<p>But in addition, we're looking to stabilize the stuff necessary to have Serde work without build scripts in Rust 1.15. That's not guaranteed yet, but it's very likely.</p>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1481149403, "post_id": 41028041, "comment_id": 69264360, "body": "You don&#39;t have to do it completely manually; a build script can do it mostly automatically, but it&#39;s not as pretty as <code>#[derive]</code>."}], "tags": [], "owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "is_accepted": false, "score": 5, "last_activity_date": 1481147526, "creation_date": 1481147526, "answer_id": 41028041, "question_id": 41016657, "link": "https://stackoverflow.com/questions/41016657/how-to-use-serde-on-stable-release-of-rust/41028041#41028041", "title": "How to use serde on stable release of Rust", "body": "<p>The unstable features used are only needed for the <code>#[derive]</code> support. So if you don't need to define serialization or deserialization for new data types, using serde with stable Rust is easy.</p>\n\n<p>If you do need to define serialization for new types, you can implement the traits manually (which isn't necessarily easy), which is still possible using stable Rust.</p>\n\n<p>The <a href=\"https://serde.rs/\" rel=\"noreferrer\">serde documentation</a> also covers <a href=\"https://serde.rs/examples.html\" rel=\"noreferrer\">how to do this.</a></p>\n"}, {"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 1, "last_activity_date": 1489066264, "last_edit_date": 1489066264, "creation_date": 1489054287, "answer_id": 42692448, "question_id": 41016657, "link": "https://stackoverflow.com/questions/41016657/how-to-use-serde-on-stable-release-of-rust/42692448#42692448", "title": "How to use serde on stable release of Rust", "body": "<p>As of Rust 1.15, you can use <code>serde</code> on stable Rust by using the <code>serde_derive</code> crate. This means you just need to remove the <code>#![feature(proc_macro)]</code> from your code and it works out of the box.</p>\n\n<pre><code>#[macro_use]\nextern crate serde_derive;\n\nextern crate serde_json;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n</code></pre>\n"}], "owner": {"reputation": 111, "user_id": 6940553, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dc5bc23aacbf15cbb492bf854c4fbdab?s=128&d=identicon&r=PG&f=1", "display_name": "Steve", "link": "https://stackoverflow.com/users/6940553/steve"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 326, "favorite_count": 1, "answer_count": 3, "score": 3, "last_activity_date": 1489066264, "creation_date": 1481111235, "last_edit_date": 1481120530, "question_id": 41016657, "link": "https://stackoverflow.com/questions/41016657/how-to-use-serde-on-stable-release-of-rust", "title": "How to use serde on stable release of Rust", "body": "<p>I understand serde is the preferred serialization tool in Rust world. However, it seems to be using features that are not there in stable channel. Does that mean I can't use serde while using Rust stable release? Am I missing something? For example:</p>\n\n<pre><code>#![feature(proc_macro)]\n\n#[macro_use]\nextern crate serde_derive;\n\nextern crate serde_json;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n</code></pre>\n"}, {"tags": ["rust", "rust-cargo", "gfx"], "answers": [{"tags": [], "owner": {"reputation": 91, "user_id": 4175307, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/80a9089fa5897c2c829bd9f232fd276f?s=128&d=identicon&r=PG&f=1", "display_name": "adahn", "link": "https://stackoverflow.com/users/4175307/adahn"}, "is_accepted": true, "score": 1, "last_activity_date": 1509698488, "creation_date": 1509698488, "answer_id": 47091538, "question_id": 41016224, "link": "https://stackoverflow.com/questions/41016224/cargo-workspace-and-temporary-local-dependency/47091538#47091538", "title": "Cargo, workspace and temporary local dependency", "body": "<p>To close the topic; This discussion resolves the issue:\n<a href=\"https://github.com/rust-lang/cargo/issues/3192\" rel=\"nofollow noreferrer\">https://github.com/rust-lang/cargo/issues/3192</a></p>\n\n<p>Now, paths pointing outside workspace directory are not implicitly included into workspace. Moreover there is <code>exclude</code> key in workspace configuration.</p>\n"}], "owner": {"reputation": 91, "user_id": 4175307, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/80a9089fa5897c2c829bd9f232fd276f?s=128&d=identicon&r=PG&f=1", "display_name": "adahn", "link": "https://stackoverflow.com/users/4175307/adahn"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1198, "favorite_count": 0, "accepted_answer_id": 47091538, "answer_count": 1, "score": 5, "last_activity_date": 1509698488, "creation_date": 1481109893, "last_edit_date": 1481110217, "question_id": 41016224, "link": "https://stackoverflow.com/questions/41016224/cargo-workspace-and-temporary-local-dependency", "title": "Cargo, workspace and temporary local dependency", "body": "<p>I have two projects my_project and my_inner_project in one cargo workspace. They both depend on gfx (and gfx_core and gfx_device_gl).\nI've found a bug in gfx_device_core, so I've forked it, cloned, patched locally and want to test it before commit.</p>\n\n<p>Projects structure:</p>\n\n<pre><code>-my_project\n--my_inner_project\n---Cargo.toml\n--Cargo.toml\n-gfx\n--src\n---core\n----Cargo.toml  #package gfx_core\n---backend\n----gl\n-----Cargo.toml #package gfx_device_gl\n---render\n----Cargo.toml  #package gfx\n--Cargo.toml\n</code></pre>\n\n<p>Now I want cargo to use local copy of gfx during my_project build:</p>\n\n<ol>\n<li>First approach (local path in Cargo.toml): I've changed source of all gfx packages to local path in Cargo.tomls of both my projects.\\\nUnfortunately, cargo implicitly assumes (which is a bit insane for me), that all dependencies pointed by \"path\" are part of workspace, yet workspace member must lay below workspace root in file system. So it refuses to build project, complaining that gfx* is part of the workspace, but it is not below workspace root. AFAIK, there is currently no way to change this implicit \"everything is in workspace\" behavior.</li>\n<li>Second approach ([replace]): This approach leads to the same behavior as described above. Path specified inside [replace] is also added implicitly into workspace.</li>\n<li><p>Third approach (local path overrides): I've added gfx to paths in .cargo/config. It was also necessary to change source of gfx package in my .tomls from crate.io, to git repository, because version in overriden package and version referrenced in .toml must match. This also don't work in stable rust 1.13. I get warning:</p>\n\n<pre><code>warning: path override for crate `gfx_device_gl` has altered the original list of dependencies; the dependency on `gfx_core` was either added or modified to not match the previously resolved version\n\nThis is currently allowed but is known to produce buggy behavior with spurious recompiles and changes to the crate graph. Path overrides unfortunately were never intended to support this feature, so for now this message is just a warning. In the future, however, this message will become a hard error.\n\nTo change the dependency graph via an override it's recommended to use the `[replace]` feature of Cargo instead of the path override feature. This is documented online at the url below for more information.\n</code></pre>\n\n<p>And error:</p>\n\n<pre><code>error: failed to find lock source of gfx_core\n</code></pre>\n\n<p>My local copy of gfx and repository pointed in Cargo.toml inside my projects are identical, so I don't understand why this warning is emited.</p>\n\n<p>The error is fixed in rust nightly, so I've installed it and finally was able to compile project with my local gfx copy.</p></li>\n</ol>\n\n<p>So after a day of struggling with relatively basic task, I have a solution, which works only in nightly and promises it will not work in feature releases.</p>\n\n<p>My questions: </p>\n\n<ol>\n<li>How it should be done?</li>\n<li>How to get rid of this warning?</li>\n</ol>\n"}, {"tags": ["string", "rust"], "comments": [{"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 12555, "user_id": 1750757, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/Zmc7D.jpg?s=128&g=1", "display_name": "Victor Polevoy", "link": "https://stackoverflow.com/users/1750757/victor-polevoy"}, "edited": false, "score": 0, "creation_date": 1481108824, "post_id": 41015509, "comment_id": 69238888, "body": "Yeah, the ends_with function doesn&#39;t show up nicely in Google. I&#39;m betting this question will. Edit: Yep it&#39;s already 4th, and by far the most obviously title, so I think it will help some people."}, {"owner": {"reputation": 59971, "user_id": 1835379, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/i63aC.gif?s=128&g=1", "display_name": "Cerbrus", "link": "https://stackoverflow.com/users/1835379/cerbrus"}, "edited": false, "score": 6, "creation_date": 1481183635, "post_id": 41015509, "comment_id": 69276004, "body": "To be fair, the <b><i>fist</i></b> google search result for <i>&quot;Rust string ends with&quot;</i> links to the rust docs for the <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\" rel=\"nofollow noreferrer\">string primitive</a>, where the <code>ends_with</code> function is easily found if you search for &quot;ends&quot; or &quot;suffix&quot;. People need to learn how to search."}, {"owner": {"reputation": 59971, "user_id": 1835379, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/i63aC.gif?s=128&g=1", "display_name": "Cerbrus", "link": "https://stackoverflow.com/users/1835379/cerbrus"}, "edited": false, "score": 0, "creation_date": 1481183788, "post_id": 41015509, "comment_id": 69276075, "body": "^ For that reason, I&#39;m close-voting this as a request for an off-site resource. I&#39;m not saying it&#39;s a bad question, just that people are better off being linked to the documentation."}, {"owner": {"reputation": 881859, "user_id": 100297, "user_type": "moderator", "profile_image": "https://www.gravatar.com/avatar/24780fb6df85a943c7aea0402c843737?s=128&d=identicon&r=PG", "display_name": "Martijn Pieters", "link": "https://stackoverflow.com/users/100297/martijn-pieters"}, "reply_to_user": {"reputation": 59971, "user_id": 1835379, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/i63aC.gif?s=128&g=1", "display_name": "Cerbrus", "link": "https://stackoverflow.com/users/1835379/cerbrus"}, "edited": false, "score": 17, "creation_date": 1481184820, "post_id": 41015509, "comment_id": 69276535, "body": "@Cerbrus: there is <i>no resource request in this question</i>. You are stretching the close option way past the intended use here."}, {"owner": {"reputation": 7341, "user_id": 4822120, "user_type": "registered", "accept_rate": 44, "profile_image": "https://www.gravatar.com/avatar/cb73b37b475eb2c8c710875ac9d842ba?s=128&d=identicon&r=PG&f=1", "display_name": "ggrr", "link": "https://stackoverflow.com/users/4822120/ggrr"}, "edited": false, "score": 0, "creation_date": 1481258198, "post_id": 41015509, "comment_id": 69313665, "body": "I cannot see any words about requesting off-site resource here, even provided that the answers can be found outside the site, to be fair we can just only assume it is not requesting off-site resource"}], "answers": [{"comments": [{"owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "edited": false, "score": 2, "creation_date": 1481145931, "post_id": 41015566, "comment_id": 69262718, "body": "Note that code completion for Rust is not very mature at the moment"}], "tags": [], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "is_accepted": true, "score": 26, "last_activity_date": 1481120444, "last_edit_date": 1481120444, "creation_date": 1481108078, "answer_id": 41015566, "question_id": 41015509, "link": "https://stackoverflow.com/questions/41015509/check-if-string-ends-with-given-suffix-in-rust/41015566#41015566", "title": "Check if string ends with given suffix in Rust", "body": "<p>It turns out there is <a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.ends_with\" rel=\"noreferrer\"><code>str::ends_with</code></a>. For some reason, code completion didn't find it for me.</p>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6920, "favorite_count": 0, "accepted_answer_id": 41015566, "answer_count": 1, "score": 12, "last_activity_date": 1481120444, "creation_date": 1481107907, "question_id": 41015509, "link": "https://stackoverflow.com/questions/41015509/check-if-string-ends-with-given-suffix-in-rust", "title": "Check if string ends with given suffix in Rust", "body": "<p>What is the Rust equivalent of Go's <a href=\"https://golang.org/pkg/strings/#HasSuffix\" rel=\"noreferrer\"><code>HasSuffix()</code> function</a>?</p>\n"}, {"tags": ["vector", "lambda", "split", "rust", "borrowing"], "answers": [{"comments": [{"owner": {"reputation": 397, "user_id": 1935704, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/382a4c5ffd7beb1bc74a9820fd426489?s=128&d=identicon&r=PG", "display_name": "Sardtok", "link": "https://stackoverflow.com/users/1935704/sardtok"}, "edited": false, "score": 0, "creation_date": 1481104668, "post_id": 41012913, "comment_id": 69236033, "body": "Thanks!  Was trying to find a way to dereference it, but there was no mention of it in the References and Borrowing chapter of the Rust Book. Should have been able to guess it was the same operator as in C. It&#39;s been almost a year since I last did any Rust, but have been wanting to get back into it, so I&#39;m a bit rusty on the syntax (pardon the pun). :/  I really like the first version where the dereferencing happens early."}, {"owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "reply_to_user": {"reputation": 397, "user_id": 1935704, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/382a4c5ffd7beb1bc74a9820fd426489?s=128&d=identicon&r=PG", "display_name": "Sardtok", "link": "https://stackoverflow.com/users/1935704/sardtok"}, "edited": false, "score": 2, "creation_date": 1481121459, "post_id": 41012913, "comment_id": 69247512, "body": "It is great to see you coming back to Rust! Don&#39;t hesitate to hang out on the <a href=\"https://www.reddit.com/r/rust\" rel=\"nofollow noreferrer\">rust subreddit</a> or #rust at irc.mozilla.org in case you want to follow the community more closely."}], "tags": [], "owner": {"reputation": 4190, "user_id": 2110623, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/a5f1b5f95d5b3bb75901fb546cd1c52d?s=128&d=identicon&r=PG", "display_name": "aochagavia", "link": "https://stackoverflow.com/users/2110623/aochagavia"}, "is_accepted": true, "score": 4, "last_activity_date": 1481101632, "last_edit_date": 1481101632, "creation_date": 1481100437, "answer_id": 41012913, "question_id": 41012885, "link": "https://stackoverflow.com/questions/41012885/cannot-compare-u8-with-u8/41012913#41012913", "title": "Cannot compare &amp;u8 with u8", "body": "<h3>The code</h3>\n\n<p>You are actually reading it right: <code>c</code> is indeed a borrowed byte and cannot be compared to a regular byte. Try using any of the functions below instead:</p>\n\n<pre><code>fn count_spaces(text: Vec&lt;u8&gt;) -&gt; usize {\n    text.split(|&amp;c| c == 32u8).count()\n}\n\nfn count_spaces(text: Vec&lt;u8&gt;) -&gt; usize {\n    text.split(|c| *c == 32u8).count()\n}\n</code></pre>\n\n<p>The first one uses pattern matching on the parameter (<code>&amp;c</code>) to dereference it, while the second one uses the dereference operator (<code>*</code>).</p>\n\n<h3>Why is <code>c</code> a <code>&amp;u8</code> instead of a <code>u8</code>?</h3>\n\n<p>If you take a look at the <a href=\"https://static.rust-lang.org/doc/master/std/primitive.slice.html#method.split\" rel=\"nofollow noreferrer\">split</a> method on the docs, you will see that the closure parameter is a <em>borrow</em> of the data in <code>Vec</code>. In this case, it means that the parameter will be <code>&amp;u8</code> instead of <code>u8</code> (so in your code you are actually comparing <code>&amp;u8</code> to <code>u8</code>, which Rust doesn't like).</p>\n\n<p>In order to understand why the closure takes the parameter by borrow and not by value, consider what would happen if the parameter was taken by value. In the case of <code>Vec&lt;u8&gt;</code>, there would be no problem since <code>u8</code> implements <code>Copy</code>. However, in the case of a a <code>Vec&lt;String&gt;</code>, each <code>String</code> would be moved into the closure and destroyed!</p>\n"}], "owner": {"reputation": 397, "user_id": 1935704, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/382a4c5ffd7beb1bc74a9820fd426489?s=128&d=identicon&r=PG", "display_name": "Sardtok", "link": "https://stackoverflow.com/users/1935704/sardtok"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1692, "favorite_count": 0, "accepted_answer_id": 41012913, "answer_count": 1, "score": 3, "last_activity_date": 1481120659, "creation_date": 1481100349, "last_edit_date": 1481120659, "question_id": 41012885, "link": "https://stackoverflow.com/questions/41012885/cannot-compare-u8-with-u8", "title": "Cannot compare &amp;u8 with u8", "body": "<pre><code>fn count_spaces(text: Vec&lt;u8&gt;) -&gt; usize {\n    text.split(|c| c == 32u8).count()\n}\n</code></pre>\n\n<p>The above function does not compile, and gives the following error on the comparison:</p>\n\n<blockquote>\n  <p>trait `&amp;u8: std::cmp::PartialEq` not satisfied</p>\n</blockquote>\n\n<p>I read this as: \"<code>c</code> is a borrowed byte and cannot be compared to a regular byte\", but I must be reading this wrong.</p>\n\n<p>What would be the appropriate way to split a <code>Vec&lt;u8&gt;</code> on specific values?</p>\n\n<p>I do realize that there are options when reading files, like splitting a <code>BufReader</code> or I could convert the vector to a string and use <code>str::split</code>. I might go with such a solution (passing in a <code>BufReader</code> instead of a <code>Vec&lt;u8&gt;</code>), but right now I'm just playing around, testing stuff and want to know what I'm doing wrong.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 4, "creation_date": 1481098865, "post_id": 41009481, "comment_id": 69232319, "body": "It can be done with a <a href=\"https://mcarton.github.io/rust-derivative/cmp.html#ignoring-a-field\" rel=\"nofollow noreferrer\">crate of mine</a> but not with standard derive."}], "answers": [{"tags": [], "owner": {"reputation": 6045, "user_id": 1036670, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/8d2dr.jpg?s=128&g=1", "display_name": "vitiral", "link": "https://stackoverflow.com/users/1036670/vitiral"}, "is_accepted": true, "score": 7, "last_activity_date": 1525322701, "last_edit_date": 1525322701, "creation_date": 1481088226, "answer_id": 41009989, "question_id": 41009481, "link": "https://stackoverflow.com/questions/41009481/exclude-field-when-deriving-partialeq/41009989#41009989", "title": "Exclude field when deriving PartialEq", "body": "<p>No, there is no way to do that currently and I doubt it will be supported. </p>\n\n<p>You could consider making the fields that you want to compare into a sub-struct which is derived, which would make the implementation for the larger struct trivial. </p>\n"}, {"tags": [], "owner": {"reputation": 385, "user_id": 1299302, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dee7b64c37b908bfbc06935accd78fcc?s=128&d=identicon&r=PG", "display_name": "dherman", "link": "https://stackoverflow.com/users/1299302/dherman"}, "is_accepted": false, "score": 6, "last_activity_date": 1548028523, "creation_date": 1548028523, "answer_id": 54282086, "question_id": 41009481, "link": "https://stackoverflow.com/questions/41009481/exclude-field-when-deriving-partialeq/54282086#54282086", "title": "Exclude field when deriving PartialEq", "body": "<p>Check out the derivative create (<a href=\"https://mcarton.github.io/rust-derivative/\" rel=\"noreferrer\">docs</a>). It provides alternate <code>derive</code> macros with more power than the standard library versions, including ways to ignore fields for <a href=\"https://mcarton.github.io/rust-derivative/Hash.html#ignoring-a-field\" rel=\"noreferrer\"><code>Hash</code></a> and <a href=\"https://mcarton.github.io/rust-derivative/cmp.html#ignoring-a-field\" rel=\"noreferrer\"><code>PartialEq</code></a> traits. </p>\n"}, {"tags": [], "owner": {"reputation": 5593, "user_id": 223433, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/xOqMQ.png?s=128&g=1", "display_name": "Eric Seppanen", "link": "https://stackoverflow.com/users/223433/eric-seppanen"}, "is_accepted": false, "score": 0, "last_activity_date": 1597725363, "creation_date": 1597725363, "answer_id": 63461948, "question_id": 41009481, "link": "https://stackoverflow.com/questions/41009481/exclude-field-when-deriving-partialeq/63461948#63461948", "title": "Exclude field when deriving PartialEq", "body": "<p>I would also recommend the <a href=\"https://docs.rs/derivative/latest\" rel=\"nofollow noreferrer\"><code>derivative</code></a> crate if you need a more sophisticated form of <code>#[derive]</code>.</p>\n<p>If you only need something like this once or twice, it may be easier to just implement the required traits manually rather than derive them.  <code>PartialEq</code> and <code>Eq</code> are <a href=\"https://doc.rust-lang.org/std/cmp/trait.Eq.html#how-can-i-implement-eq\" rel=\"nofollow noreferrer\">very easy</a> to implement yourself:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>impl PartialEq for UndirectedGraph {\n    fn eq(&amp;self, other: &amp;Self) -&gt; bool {\n        self.nodes == other.nodes\n    }\n}\nimpl Eq for UndirectedGraph {}\n</code></pre>\n"}], "owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1288, "favorite_count": 0, "accepted_answer_id": 41009989, "answer_count": 3, "score": 6, "last_activity_date": 1597725363, "creation_date": 1481085246, "last_edit_date": 1481120390, "question_id": 41009481, "link": "https://stackoverflow.com/questions/41009481/exclude-field-when-deriving-partialeq", "title": "Exclude field when deriving PartialEq", "body": "<p>Is there an easy way to annotate fields in a struct so that they are ignored when deriving the <code>PartialEq</code> trait? For example:</p>\n\n<pre><code>#[derive(PartialEq,Eq)]\npub struct UndirectedGraph {\n    nodes: HashMap&lt;NodeIdx, UndirectedNode&gt;,\n    // mapping of degree to nodes of that degree\n    degree_index: Vec&lt;HashSet&lt;NodeIdx&gt;&gt;,\n}\n</code></pre>\n\n<p>I want two undirected graphs to be considered equal when they have the same <code>nodes</code> field, but the <code>degree_index</code> field may differ (the vector may contain extra empty hash-sets at the end).</p>\n\n<p>Obviously I could just implement the trait manually, but automatic derivation would be simpler.</p>\n"}, {"tags": ["multithreading", "concurrency", "rust"], "answers": [{"tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": true, "score": 5, "last_activity_date": 1481066516, "creation_date": 1481066516, "answer_id": 41006761, "question_id": 41003914, "link": "https://stackoverflow.com/questions/41003914/why-does-the-rust-playground-not-produce-different-results-for-threads/41006761#41006761", "title": "Why does the Rust playground not produce different results for threads?", "body": "<p>This may not be the only thing at play here, but the playground does caching; if you don't change the code, it won't re-run it.</p>\n"}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 146, "favorite_count": 0, "accepted_answer_id": 41006761, "answer_count": 1, "score": 1, "last_activity_date": 1481066516, "creation_date": 1481054815, "last_edit_date": 1481061214, "question_id": 41003914, "link": "https://stackoverflow.com/questions/41003914/why-does-the-rust-playground-not-produce-different-results-for-threads", "title": "Why does the Rust playground not produce different results for threads?", "body": "<p>For the following sample code in <a href=\"https://doc.rust-lang.org/book/concurrency.html\" rel=\"nofollow noreferrer\">Rust book concurrency</a> chapter.  </p>\n\n<pre><code>use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n\n    for i in 0..3 {\n        let data = data.clone();\n        thread::spawn(move || {\n            let mut data = data.lock().unwrap();\n            data[0] += i;\n            println!(\"{}\", data[0]);\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n</code></pre>\n\n<p>My friend and I separately ran this code on the Rust playground and always got the same order: <code>3, 4, 4</code>, so it seems the threads are always started in the order of <code>2, 1, 0</code>. </p>\n\n<p>With multi-threaded programming, shouldn't we never know which thread will start first, as there is no fixed order of running the spawned threads?\nIs the Rust playground considered a single computer?</p>\n"}, {"tags": ["rust", "size", "abstract", "traits"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1481054746, "post_id": 41003646, "comment_id": 69216517, "body": "FYI: <a href=\"http://stackoverflow.com/q/40006219/155423\">stackoverflow.com/q/40006219/155423</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1481058776, "post_id": 41003646, "comment_id": 69218643, "body": "Potentially related: <a href=\"http://stackoverflow.com/q/28932450/155423\">How can I have a vector of objects that differ by their associated type?</a>"}], "owner": {"reputation": 2134, "user_id": 1527244, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/82b81a8c0375cf62e749e2b48fc553e6?s=128&d=identicon&r=PG", "display_name": "Danyel", "link": "https://stackoverflow.com/users/1527244/danyel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 216, "favorite_count": 0, "closed_date": 1514934405, "answer_count": 0, "score": 2, "last_activity_date": 1481054755, "creation_date": 1481053814, "last_edit_date": 1481054755, "question_id": 41003646, "link": "https://stackoverflow.com/questions/41003646/in-rust-how-can-i-abstract-over-a-trait-that-has-an-associated-type", "closed_reason": "Duplicate", "title": "In Rust, how can I abstract over a trait that has an associated type?", "body": "<p>I'm writing a downloader for different hosts/providers and need to abstract over the different meta information they provide for files. For example, one host might return an MD5 sum, another an SHA1 sum or even no checksum at all. I wrote a <code>Hoster</code> trait that can return a file (whose specific type should be unknown).</p>\n\n<pre><code>trait Hoster {\n    type File: Remote;\n    fn meta(&amp;self, urls: &amp;Vec&lt;Url&gt;) -&gt; hyper::Result&lt;Vec&lt;Self::File&gt;&gt;;\n    // several other methods\n}\n</code></pre>\n\n<p>The <code>meta</code> function takes URLs and returns their meta information in the specific type. That type in turn may have its own functions.</p>\n\n<p>When using <code>Hoster</code> anywhere in my code, the compiler complains that I need to provide the specific <code>File</code> trait type. I asked in IRC and kimundi offered me a solution which does <em>work</em> but is very much not what I had hoped/wanted. The general solution is <a href=\"https://gist.github.com/14d49f258d9c106222afb029b03ba02d\" rel=\"nofollow noreferrer\">this</a>. <a href=\"https://gist.github.com/dd27f41d4388deb6484c3ea248a1e499\" rel=\"nofollow noreferrer\">Translated to my example</a>:</p>\n\n<pre><code>pub trait Remote: std::fmt::Debug {\n    fn url(&amp;self) -&gt; String;\n}\n\ntrait _Hoster {\n    type File: Remote + 'static;\n\n    fn id(&amp;self) -&gt; &amp;'static str;\n\n    // Returns true if this host is responsible for this URL, false otherwise.\n    fn accepts(&amp;self, url: &amp;url::Url) -&gt; bool;\n\n    // Returns meta information on given URLs.\n    fn meta(&amp;self, url: &amp;Vec&lt;url::Url&gt;) -&gt; hyper::Result&lt;Vec&lt;Self::File&gt;&gt;;\n}\n\nstruct Wrapper&lt;T&gt;(T);\n\nuse std::ops::Deref;\nimpl Remote for Box&lt;Remote&gt; {\n    fn url(&amp;self) -&gt; String {\n        self.deref().url()\n    }\n}\n\nimpl&lt;T: _Hoster&gt; _Hoster for Wrapper&lt;T&gt; {\n    type File = Box&lt;Remote&gt;;\n    fn id(&amp;self) -&gt; &amp;'static str {\n        self.0.id()\n    }\n\n    fn accepts(&amp;self, url: &amp;url::Url) -&gt; bool {\n        self.0.accepts(url)\n    }\n\n    fn meta(&amp;self, urls: &amp;Vec&lt;url::Url&gt;) -&gt; hyper::Result&lt;Vec&lt;Box&lt;Remote&gt;&gt;&gt; {\n        self.0.meta(urls)?.into_iter().map(|x| Box::new(x) as Box&lt;Remote&gt;).collect()\n    }\n}\n\npub type Hoster = _Hoster&lt;File = Box&lt;Remote&gt;&gt;;\n</code></pre>\n\n<p>but as you can see I have to specify <code>Box&lt;Trait&lt;Out=Box&lt;Assoc&gt;&gt;&gt;</code> everywhere in the code which can be solved by specifying my own type (as I did).</p>\n\n<p>Some other things that are irritating: </p>\n\n<ol>\n<li>I have to duplicate all the <code>Wrapper</code> methods for every new <code>Remote</code> method. </li>\n<li>Most irritating of all: As you can see in my applied example, I have to write something like <code>self.0.foo(bar)?.into_iter().map(|x| Box::new(x) as Box&lt;Remote&gt;).collect()</code> in the wrapper just to turn all <code>Remote</code>s inside a <code>Vec</code> into <code>Box&lt;Remote&gt;</code>s. While this is frustrating to type out, it is also very ill performing.</li>\n<li>The same with the <code>Remote</code> trait. I have to <code>impl Remote for Box&lt;Remote&gt;</code> and import the <code>std::ops::Deref</code> trait and manually delegate all trait methods to the innards of the Box...</li>\n</ol>\n\n<p>Is there another way?</p>\n"}, {"tags": ["rust", "cross-compiling"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1481038983, "post_id": 40998256, "comment_id": 69207211, "body": "When I search the Internet for <code>rust &quot;Relocations in generic ELF&quot;</code>, the first result is <a href=\"https://github.com/japaric/ruststrap/blob/master/1-how-to-cross-compile.md\" rel=\"nofollow noreferrer\">this excellent guide</a>, which <a href=\"https://github.com/japaric/rust-cross\" rel=\"nofollow noreferrer\">has since moved</a>. You need to pass <code>-C linker=my-linker-for-the-target-platform</code> to the <code>rustc</code> invocation inside the stage 2 build."}], "owner": {"reputation": 553, "user_id": 4830306, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cIfRj.png?s=128&g=1", "display_name": "Nicolas Jean", "link": "https://stackoverflow.com/users/4830306/nicolas-jean"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 695, "favorite_count": 0, "answer_count": 0, "score": 3, "last_activity_date": 1481042790, "creation_date": 1481036081, "last_edit_date": 1481042790, "question_id": 40998256, "link": "https://stackoverflow.com/questions/40998256/how-to-cross-compile-rust-for-mipsel-unknown-linux-uclibc", "title": "How to cross-compile Rust for mipsel-unknown-linux-uclibc?", "body": "<p>I tried to cross-compile Rust for <code>mipsel-unknown-linux-uclibc</code> on my computer (<code>x86_64-unknown-linux-gnu</code>) and failed:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>~ git clone https://github.com/rust-lang/rust &amp;&amp; cd rust\n# checkout the right commit (rustc -V ---&gt; rustc 1.13.0 (2c6933acc 2016-11-07))\n~ git checkout 2c6933acc\n~ configure --enable-rustbuild --target=mipsel-unknown-linux-uclibc\n~ make\n</code></pre>\n\n<p>I encountered the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Documenting stage2 error index (x86_64-unknown-linux-gnu)\nBuilding stage2 std artifacts (x86_64-unknown-linux-gnu -&gt; mipsel-unknown-linux-uclibc)\n   Compiling core v0.0.0 (file:///mnt/ssd/rust/rust/src/libcore)\n   Compiling unwind v0.0.0 (file:///mnt/ssd/rust/rust/src/libunwind)\n   Compiling libc v0.0.0 (file:///mnt/ssd/rust/rust/src/rustc/libc_shim)\n   Compiling alloc_jemalloc v0.0.0 (file:///mnt/ssd/rust/rust/src/liballoc_jemalloc)\n   Compiling compiler_builtins v0.0.0 (file:///mnt/ssd/rust/rust/src/libcompiler_builtins)\n   Compiling std v0.0.0 (file:///mnt/ssd/rust/rust/src/libstd)\n   Compiling rand v0.0.0 (file:///mnt/ssd/rust/rust/src/librand)\n   Compiling alloc v0.0.0 (file:///mnt/ssd/rust/rust/src/liballoc)\n   Compiling rustc_unicode v0.0.0 (file:///mnt/ssd/rust/rust/src/librustc_unicode)\n   Compiling panic_abort v0.0.0 (file:///mnt/ssd/rust/rust/src/libpanic_abort)\n   Compiling alloc_system v0.0.0 (file:///mnt/ssd/rust/rust/src/liballoc_system)\n   Compiling panic_unwind v0.0.0 (file:///mnt/ssd/rust/rust/src/libpanic_unwind)\n   Compiling collections v0.0.0 (file:///mnt/ssd/rust/rust/src/libcollections)\nerror: linking with `cc` failed: exit code: 1\n  |\n  = note: \"cc\" \"-Wl,--as-needed\" \"-Wl,-z,noexecstack\" \"-L\" \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2/lib/rustlib/mipsel-unknown-linux-uclibc/lib\" \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o\" \"-o\" \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/libstd-c59cddcd0af2e166.so\" \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.metadata.o\" \"-Wl,-O1\" \"-nodefaultlibs\" \"-L\" \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps\" \"-L\" \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/build/std-a809d8d8110a0c2c/out/.libs\" \"-L\" \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/build/alloc_jemalloc-3fdf800200d00d2b/out/lib\" \"-L\" \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/build/compiler_builtins-6f98225e9c197338/out\" \"-L\" \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2/lib/rustlib/mipsel-unknown-linux-uclibc/lib\" \"-Wl,-Bstatic\" \"-Wl,--whole-archive\" \"-l\" \"backtrace\" \"-Wl,--no-whole-archive\" \"-Wl,-Bdynamic\" \"-l\" \"dl\" \"-l\" \"rt\" \"-l\" \"pthread\" \"-Wl,--whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/libpanic_unwind-7bbc0f7aeca8d97e.rlib\" \"-Wl,--no-whole-archive\" \"-Wl,--whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/libcollections-2384fa75982df921.rlib\" \"-Wl,--no-whole-archive\" \"-Wl,--whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/liballoc-97c94bbcbb6ce588.rlib\" \"-Wl,--no-whole-archive\" \"-Wl,--whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/liballoc_jemalloc-d3ea7757ad00d487.rlib\" \"-Wl,--no-whole-archive\" \"-Wl,--whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/librustc_unicode-0f8a4e3472bf9986.rlib\" \"-Wl,--no-whole-archive\" \"-Wl,--whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/libunwind-a2900b506cabe0f1.rlib\" \"-Wl,--no-whole-archive\" \"-Wl,--whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/liblibc-5e16cc1287996e06.rlib\" \"-Wl,--no-whole-archive\" \"-Wl,--whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/librand-9e79fbad0cb1c989.rlib\" \"-Wl,--no-whole-archive\" \"-Wl,--whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/libcore-2bfca94c87453f15.rlib\" \"-Wl,--no-whole-archive\" \"/tmp/rustc.Lmi5cZaoYeZ8/libcompiler_builtins-66ce650a45b25434.rlib\" \"-l\" \"pthread\" \"-l\" \"gcc_s\" \"-l\" \"c\" \"-l\" \"m\" \"-l\" \"rt\" \"-l\" \"util\" \"-shared\" \"-Wl,-rpath,$ORIGIN/../lib\"\n  = note: /usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n/usr/bin/ld: /mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: Relocations in generic ELF (EM: 8)\n...\n&lt;many more similar lines&gt;\n...\n/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage2-std/mipsel-unknown-linux-uclibc/release/deps/std-c59cddcd0af2e166.0.o: error adding symbols: File in wrong format\ncollect2: error: ld returned 1 exit status\n\n\nerror: aborting due to previous error\n\nerror: Could not compile `std`.\n\nTo learn more, run the command again with --verbose.\n\n\ncommand did not execute successfully: \"/mnt/ssd/rust/rust_build/build/x86_64-unknown-linux-gnu/stage0/bin/cargo\" \"build\" \"-j\" \"8\" \"--target\" \"mipsel-unknown-linux-uclibc\" \"--release\" \"--features\" \" jemalloc backtrace\" \"--manifest-path\" \"/mnt/ssd/rust/rust/src/rustc/std_shim/Cargo.toml\"\nexpected success, got: exit code: 101\n\n\nMakefile:23: recipe for target 'all' failed\nmake: *** [all] Error 1\n</code></pre>\n\n<p>It seems that the build system is using <code>cc</code> to link object files cross-compiled for MIPS. I did not find a way to tell the build system to use the right linker. </p>\n\n<p><a href=\"https://github.com/japaric/rust-cross\" rel=\"nofollow noreferrer\">rust-cross</a> was very helpful when I first tried to cross-compile Rust, but I did not find a solution for my problem in it. I don't know how to pass the <code>-C linker=...</code> flag for the stage 2 build. I tried <code>export RUSTFLAGS_STAGE2='-C /path/to/mipsel-unknown-linux-uclibc-gcc'</code>, but it didn't work.</p>\n\n<p>Additional information:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>~ rustc --version --verbose\nrustc 1.13.0 (2c6933acc 2016-11-07)\nbinary: rustc\ncommit-hash: 2c6933acc05c61e041be764cb1331f6281993f3f\ncommit-date: 2016-11-07\nhost: x86_64-unknown-linux-gnu\nrelease: 1.13.0\n</code></pre>\n\n<p>My <code>~/.cargo/config</code>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>[target.mipsel-unknown-linux-uclibc]\nlinker = \"/path/to/mipsel-unknown-linux-uclibc-gcc\"\n</code></pre>\n"}, {"tags": ["rust", "variable-assignment"], "comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 2, "creation_date": 1480987267, "post_id": 40986141, "comment_id": 69181803, "body": "I was literally about to <a href=\"https://play.rust-lang.org/?gist=19b24cb31e915860916a99f41347b727&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">put this as an answer</a> until I noticed your edit that included short-circuiting. I don&#39;t think its possible to short-circuit multiple <code>if let</code> bindings. There is <a href=\"https://github.com/rust-lang/rfcs/issues/929\" rel=\"nofollow noreferrer\">however an open RFC for it</a>."}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1480987520, "post_id": 40986141, "comment_id": 69181860, "body": "@SimonWhitehead, thanks all the same, added it to the question for clarification - since it may be handy in some situations still."}, {"owner": {"reputation": 2621, "user_id": 7884305, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7f582791bc217379415cc2bc54abc718?s=128&d=identicon&r=PG&f=1", "display_name": "Chayim Friedman", "link": "https://stackoverflow.com/users/7884305/chayim-friedman"}, "edited": false, "score": 0, "creation_date": 1600372731, "post_id": 40986141, "comment_id": 113075811, "body": "Duplicate <a href=\"https://stackoverflow.com/questions/53235477/does-rust-2018-support-if-let-chaining/53237008\" title=\"does rust 2018 support if let chaining\">stackoverflow.com/questions/53235477/&hellip;</a>"}, {"owner": {"reputation": 2621, "user_id": 7884305, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7f582791bc217379415cc2bc54abc718?s=128&d=identicon&r=PG&f=1", "display_name": "Chayim Friedman", "link": "https://stackoverflow.com/users/7884305/chayim-friedman"}, "edited": false, "score": 0, "creation_date": 1600372746, "post_id": 40986141, "comment_id": 113075818, "body": "Does this answer your question? <a href=\"https://stackoverflow.com/questions/53235477/does-rust-2018-support-if-let-chaining\">Does Rust 2018 support &quot;if let&quot; chaining?</a>"}], "answers": [{"comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 1, "creation_date": 1480989936, "post_id": 40986547, "comment_id": 69182508, "body": "Great answer! I considered the macro approach but couldn&#39;t quite figure out how to go about implementing it (macros are still a bit intimidating for me!)."}, {"owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 1, "creation_date": 1480990390, "post_id": 40986547, "comment_id": 69182623, "body": "@SimonWhitehead honestly, I&#39;m quite new to macros too. You should&#39;ve seen my face when I realized this actually works."}], "tags": [], "owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "is_accepted": false, "score": 5, "last_activity_date": 1480991224, "last_edit_date": 1480991224, "creation_date": 1480989254, "answer_id": 40986547, "question_id": 40986141, "link": "https://stackoverflow.com/questions/40986141/how-to-group-option-assignments-in-rust/40986547#40986547", "title": "How to group &#39;Option&#39; assignments in Rust?", "body": "<p>The standard library doesn't include that exact functionality, but the language allows you to create the desired behavior using a small macro.</p>\n\n<p>Here's what I came up with:</p>\n\n<pre><code>macro_rules! all_or_nothing {\n    ($($opt:expr),*) =&gt; {{\n        if false $(|| $opt.is_none())* {\n            None\n        } else {\n            Some(($($opt.unwrap(),)*))\n        }\n    }};\n}\n</code></pre>\n\n<p>You can feed it all your options and get some tuple containing the unwrapped values if all values are <code>Some</code>, or <code>None</code> in the case that any of the options are <code>None</code>.</p>\n\n<p>The following is a brief example on how to use it:</p>\n\n<pre><code>fn main() {\n    let foo = Some(0);\n    let bar = Some(1);\n    let baz = Some(2);\n    if let Some((a, b, c)) = all_or_nothing!(foo, bar, baz) {\n        println!(\"foo: {}; bar: {}; baz: {}\", a, b, c);\n    } else {\n        panic!(\"Something was `None`!\");\n    }\n}\n</code></pre>\n\n<p>Here's a full test-suite for the macro: <a href=\"https://play.rust-lang.org/?gist=106c7a1064333976f4dcd739e16fef67&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Rust Playground</a></p>\n"}, {"comments": [{"owner": {"reputation": 471, "user_id": 2319934, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/df4fd94526342e5486f1df4362c33abe?s=128&d=identicon&r=PG", "display_name": "SplittyDev", "link": "https://stackoverflow.com/users/2319934/splittydev"}, "edited": false, "score": 1, "creation_date": 1480992084, "post_id": 40986885, "comment_id": 69183078, "body": "Works, but gets progressively worse with more arguments."}], "tags": [], "owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "is_accepted": false, "score": 3, "last_activity_date": 1480991562, "creation_date": 1480991562, "answer_id": 40986885, "question_id": 40986141, "link": "https://stackoverflow.com/questions/40986141/how-to-group-option-assignments-in-rust/40986885#40986885", "title": "How to group &#39;Option&#39; assignments in Rust?", "body": "<p>Honestly, someone should notice about <code>Option</code> being an applicative functor :)</p>\n\n<p>The code will be quite ugly without currying support in Rust, but it works and it shouldn't make a noisy diff:</p>\n\n<pre><code>fn foo_a() -&gt; Option&lt;isize&gt; {\n    println!(\"foo_a() invoked\");\n    Some(1)\n}\n\nfn foo_b() -&gt; Option&lt;isize&gt; {\n    println!(\"foo_b() invoked\");\n    Some(2)\n}\n\nfn foo_c() -&gt; Option&lt;isize&gt; {\n    println!(\"foo_c() invoked\");\n    Some(3)\n}\n\nlet x = Some(|v| v)\n    .and_then(|k| foo_a().map(|v| move |x| k((v, x))))\n    .and_then(|k| foo_b().map(|v| move |x| k((v, x))))\n    .and_then(|k| foo_c().map(|v| move |x| k((v, x))))\n    .map(|k| k(()));\n\nmatch x {\n    Some((a, (b, (c, ())))) =&gt;\n        println!(\"matched: a = {}, b = {}, c = {}\", a, b, c),\n    None =&gt;\n        println!(\"nothing matched\"),\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1480992616, "post_id": 40986989, "comment_id": 69183238, "body": "I really like this to be honest ... and I think I can see where this technique would be applicable in what I am currently working on. Thanks!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 5, "last_activity_date": 1480992306, "last_edit_date": 1495540385, "creation_date": 1480992306, "answer_id": 40986989, "question_id": 40986141, "link": "https://stackoverflow.com/questions/40986141/how-to-group-option-assignments-in-rust/40986989#40986989", "title": "How to group &#39;Option&#39; assignments in Rust?", "body": "<p>My first inclination was to do something similar to <a href=\"https://stackoverflow.com/a/40986885/155423\">swizard's answer</a>, but to wrap it up in a trait to make the chaining cleaner. It's also a bit simpler without the need for extra function invocations.</p>\n\n<p>It does have the downside of increasing the nesting of the tuples.</p>\n\n<pre><code>fn foo_a() -&gt; Option&lt;u8&gt; {\n    println!(\"foo_a() invoked\");\n    Some(1)\n}\n\nfn foo_b() -&gt; Option&lt;u8&gt; {\n    println!(\"foo_b() invoked\");\n    None\n}\n\nfn foo_c() -&gt; Option&lt;u8&gt; {\n    println!(\"foo_c() invoked\");\n    Some(3)\n}\n\ntrait Thing&lt;T&gt; {\n    fn thing&lt;F, U&gt;(self, f: F) -&gt; Option&lt;(T, U)&gt; where F: FnOnce() -&gt; Option&lt;U&gt;;\n}\n\nimpl&lt;T&gt; Thing&lt;T&gt; for Option&lt;T&gt; {\n    fn thing&lt;F, U&gt;(self, f: F) -&gt; Option&lt;(T, U)&gt;\n        where F: FnOnce() -&gt; Option&lt;U&gt;\n    {\n        self.and_then(|a| f().map(|b| (a, b)))\n    }\n}\n\nfn main() {\n    let x = foo_a()\n        .thing(foo_b)\n        .thing(foo_c);\n\n    match x {\n        Some(((a, b), c)) =&gt; println!(\"matched: a = {}, b = {}, c = {}\", a, b, c),\n        None =&gt; println!(\"nothing matched\"),\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1481326734, "post_id": 40987097, "comment_id": 69348073, "body": "Really nice, minor wart is it requires the <code>body</code> to be a macro argument, which makes me prefer @SplittyDev&#39;s answer."}, {"owner": {"reputation": 4257, "user_id": 3347227, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/160c472b1c6c43b47cc98cc01d3ce317?s=128&d=identicon&r=PG", "display_name": "Erik Vesteraas", "link": "https://stackoverflow.com/users/3347227/erik-vesteraas"}, "reply_to_user": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1481332256, "post_id": 40987097, "comment_id": 69349234, "body": "@ideasman42 Macro argument? As far as I understand the body can be any arbitrary code block. I&#39;ll admit I&#39;m not that well versed in the restrictions on macros, so if you have a good example of something that would not work with this macro it would certainly be a good amendment to the answer for future visitors."}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1481334055, "post_id": 40987097, "comment_id": 69349538, "body": "@Eric, theres no error in the macro - as you say it can take any block of code as an argument, it just reads a little awkward having <code>if macro!(args, { body });</code> compared to <code>if macro!(args) { body }</code> its not that its especially bad, just my personal preference to avoid it - given the choice, and assuming the alternative isn&#39;t worse in some other way."}, {"owner": {"reputation": 4257, "user_id": 3347227, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/160c472b1c6c43b47cc98cc01d3ce317?s=128&d=identicon&r=PG", "display_name": "Erik Vesteraas", "link": "https://stackoverflow.com/users/3347227/erik-vesteraas"}, "reply_to_user": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1481334655, "post_id": 40987097, "comment_id": 69349656, "body": "@ideasman42 Yeah, I get what you&#39;re saying and I have to agree. It&#39;s not quite as good as native syntax, so it comes down to personal preference in the end. You could always fiddle with the exact syntax for the macro arguments but you will always need something to disambiguate arguments from body."}], "tags": [], "owner": {"reputation": 4257, "user_id": 3347227, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/160c472b1c6c43b47cc98cc01d3ce317?s=128&d=identicon&r=PG", "display_name": "Erik Vesteraas", "link": "https://stackoverflow.com/users/3347227/erik-vesteraas"}, "is_accepted": false, "score": 10, "last_activity_date": 1480993333, "last_edit_date": 1495539939, "creation_date": 1480993178, "answer_id": 40987097, "question_id": 40986141, "link": "https://stackoverflow.com/questions/40986141/how-to-group-option-assignments-in-rust/40987097#40987097", "title": "How to group &#39;Option&#39; assignments in Rust?", "body": "<p>As <a href=\"https://stackoverflow.com/a/40986547/155423\">@SplittyDev said</a>, you can create a macro to get the functionality you want. Here is an alternate macro-based solution which also retains the short-circuiting behaviour:</p>\n\n<pre><code>macro_rules! iflet {\n    ([$p:pat = $e:expr] $($rest:tt)*) =&gt; {\n        if let $p = $e {\n            iflet!($($rest)*);\n        }\n    };\n    ($b:block) =&gt; {\n        $b\n    };\n}\n\n\nfn main() {\n    iflet!([Some(a) = foo_a()] [Some(b) = foo_b()] [Some(c) = foo_c()] {\n        println!(\"{} {} {}\", a, b, c);\n    });\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?code=macro_rules!%20iflet%20%7B%0A%20%20%20%20(%5B%24p%3Apat%20%3D%20%24e%3Aexpr%5D%20%24(%24rest%3Att)*)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20let%20%24p%20%3D%20%24e%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20iflet!(%24(%24rest)*)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20(%24b%3Ablock)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%24b%0A%20%20%20%20%7D%3B%0A%7D%0A%0A%0Afn%20main()%20%7B%0A%20%20%20%20iflet!(%5BSome(a)%20%3D%20foo_a()%5D%20%5BSome(b)%20%3D%20foo_b()%5D%20%5BSome(c)%20%3D%20foo_c()%5D%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%7B%7D%20%7B%7D%22%2C%20a%2C%20b%2C%20c)%3B%0A%20%20%20%20%7D)%3B%0A%7D%0A%0Afn%20foo_a()%20-%3E%20Option%3Cu32%3E%20%7B%0A%20%20%20%20Some(0)%0A%7D%0A%0Afn%20foo_b()%20-%3E%20Option%3Cu32%3E%20%7B%0A%20%20%20%20Some(1)%0A%7D%0A%0Afn%20foo_c()%20-%3E%20Option%3Cu32%3E%20%7B%0A%20%20%20%20Some(2)%0A%7D%0A&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}, {"tags": [], "owner": {"reputation": 143, "user_id": 10451311, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-F7lXZBEyZC0/AAAAAAAAAAI/AAAAAAAAKUE/y6-joRvzek0/photo.jpg?sz=128", "display_name": "Frank Moreno", "link": "https://stackoverflow.com/users/10451311/frank-moreno"}, "is_accepted": false, "score": 1, "last_activity_date": 1612148857, "creation_date": 1612148857, "answer_id": 65986679, "question_id": 40986141, "link": "https://stackoverflow.com/questions/40986141/how-to-group-option-assignments-in-rust/65986679#65986679", "title": "How to group &#39;Option&#39; assignments in Rust?", "body": "<p>You can group the values using the '?' operator to return an <code>Option</code> of a tuple with the required values. If on of then is <code>None</code>, the <code>group_options</code> function will return <code>None</code>.</p>\n<pre class=\"lang-rust prettyprint-override\"><code>fn foo_a() -&gt; Option&lt;u8&gt; {\n    println!(&quot;foo_a() invoked&quot;);\n    Some(1)\n}\n\nfn foo_b() -&gt; Option&lt;u8&gt; {\n    println!(&quot;foo_b() invoked&quot;);\n    None\n}\n\nfn foo_c() -&gt; Option&lt;u8&gt; {\n    println!(&quot;foo_c() invoked&quot;);\n    Some(3)\n}\n\nfn group_options() -&gt; Option&lt;(u8, u8, u8)&gt; {\n    let a = foo_a()?;\n    let b = foo_b()?;\n    let c = foo_c()?;\n    Some((a, b, c))\n}\n\nfn main() {\n    if let Some((a, b, c)) = group_options() {\n        println!(&quot;{}&quot;, a);\n        println!(&quot;{}&quot;, b);\n        println!(&quot;{}&quot;, c);\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 450, "favorite_count": 1, "answer_count": 5, "score": 9, "last_activity_date": 1612148857, "creation_date": 1480986369, "last_edit_date": 1480995734, "question_id": 40986141, "link": "https://stackoverflow.com/questions/40986141/how-to-group-option-assignments-in-rust", "title": "How to group &#39;Option&#39; assignments in Rust?", "body": "<p>I have a block of code where multiple optional variables need to be assigned at once. There is very little chance any of the values will be <code>None</code>, so individually handing each failed case isn't especially useful.</p>\n\n<p>Currently I write the checks like this:</p>\n\n<pre><code>if let Some(a) = foo_a() {\n    if let Some(b) = foo_b() {\n        if let Some(c) = foo_c() {\n            if let Some(d) = foo_d() {\n                // code\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>It would be convenient if it was possible to group assignments. Without this, adding a new variable indents the block one level, making for noisy diffs and causes unnecessarily deep indentation:</p>\n\n<pre><code>if let Some(a) = foo_a() &amp;&amp;\n   let Some(b) = foo_b() &amp;&amp;\n   let Some(c) = foo_c() &amp;&amp;\n   let Some(d) = foo_d()\n{\n    // code\n}\n</code></pre>\n\n<p>Is there a way to assign multiple <code>Option</code>s in one if statement?</p>\n\n<hr>\n\n<p>Some details worth noting:</p>\n\n<p>The first function that fails should short circuit and not call the others. Otherwise, it could be written like this:</p>\n\n<pre><code>if let (Some(a), Some(b), Some(c), Some(d)) = (foo_a(), foo_b(), foo_c(), foo_d()) {\n    // Code\n}\n</code></pre>\n\n<p>Deep indentation could be avoided using a function, but I would prefer not to do this since you may not want to have the body in a different scope...</p>\n\n<pre><code>fn my_function(a: Foo, b: Foo, c: Foo, d: Foo) {\n    // code\n}\n\nif let Some(a) = foo_a() {\n    if let Some(b) = foo_b() {\n        if let Some(c) = foo_c() {\n            if let Some(d) = foo_d() {\n                my_function(a, b, c, d);\n            }\n        }\n    }\n}\n</code></pre>\n"}, {"tags": ["concurrency", "rust", "clone"], "answers": [{"tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": false, "score": 5, "last_activity_date": 1480982495, "creation_date": 1480982495, "answer_id": 40985593, "question_id": 40984932, "link": "https://stackoverflow.com/questions/40984932/what-happens-when-an-arc-is-cloned/40985593#40985593", "title": "What happens when an Arc is cloned?", "body": "<p>I am not an expert on the standard library internals and I am still learning Rust.. but here is what I can see: (<a href=\"https://doc.rust-lang.org/src/alloc/up/src/liballoc/arc.rs.html#379\" rel=\"noreferrer\">you could check the source yourself too if you wanted</a>). </p>\n\n<p>Firstly, an important thing to remember in Rust is that it is actually possible to step outside the \"safe bounds\" that the compiler provides, if you know what you're doing. So attempting to reason about how some of the standard library types work internally, with the ownership system as your base of understanding may not make lots of sense.</p>\n\n<p><code>Arc</code> is one of the standard library types that sidesteps the ownership system internally. It essentially manages a pointer all by itself and calling <code>clone()</code> returns a new <code>Arc</code> that points at the exact same piece of memory the original did.. with an incremented reference count.</p>\n\n<p>So on a high level, yes, <code>clone()</code> returns a new <code>Arc</code> instance and the ownership of that new instance is moved into the left hand side of the assignment. However, internally the new <code>Arc</code> instance still points where the old one did.. via a raw pointer (or as it appears in the source, via a <code>Shared</code> instance, which is a wrapper around a raw pointer). The wrapper around the raw pointer is what I imagine the documentation refers to as an \"owned handle\".</p>\n"}, {"comments": [{"owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "edited": false, "score": 6, "creation_date": 1480995727, "post_id": 40985661, "comment_id": 69183987, "body": "Super fun and cool explanation. I wish the rust book would be written in the same way in the future."}, {"owner": {"reputation": 1470, "user_id": 2075745, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/6f9a084d236381e1882c4e28edb5151f?s=128&d=identicon&r=PG", "display_name": "user25064", "link": "https://stackoverflow.com/users/2075745/user25064"}, "edited": false, "score": 0, "creation_date": 1481029838, "post_id": 40985661, "comment_id": 69200885, "body": "@Lukas I look forward to reading more of your answers, thank you"}, {"owner": {"reputation": 148712, "user_id": 19750, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/13b41b2620da0b1e630715e0c91a0b03?s=128&d=identicon&r=PG", "display_name": "Josh Lee", "link": "https://stackoverflow.com/users/19750/josh-lee"}, "edited": false, "score": 4, "creation_date": 1481056883, "post_id": 40985661, "comment_id": 69217619, "body": "Arc&lt;Mutex&lt;T&gt;&gt; is the thread-safe analogy to Rc&lt;RefCell&lt;T&gt;&gt;, and Arc&lt;RwLock&lt;T&gt;&gt; may come in handy if access to the turtle is not always mutable. All three compositions are pretty common."}], "tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": true, "score": 48, "last_activity_date": 1481033772, "last_edit_date": 1495541408, "creation_date": 1480983024, "answer_id": 40985661, "question_id": 40984932, "link": "https://stackoverflow.com/questions/40984932/what-happens-when-an-arc-is-cloned/40985661#40985661", "title": "What happens when an Arc is cloned?", "body": "<blockquote>\n  <p>[...] what is happening on <code>let data = data.clone()</code>?</p>\n</blockquote>\n\n<p><code>Arc</code> stands for <strong>A</strong>tomically <strong>R</strong>eference <strong>C</strong>ounted. An <code>Arc</code> manages <em>one</em> object (of type <code>T</code>) and serves as a proxy to allow for <em>shared ownership</em>, meaning: one object is owned by multiple names. Wow, that sounds abstract, let's break it down!</p>\n\n<h3>Shared Ownership</h3>\n\n<p>Let's say you have an object of type <code>Turtle</code> \ud83d\udc22 which you bought for your family. Now the problem arises that you can't assign a clear owner of the turtle: every family-member kind of owns that pet! This means (and sorry for being morbid here) that if one member of the family dies, the turtle won't die with that family-member. The turtle will only die if all members of the family are gone as well. <strong>Everyone owns and the last one cleans up</strong>.</p>\n\n<p>So how would you express that kind of shared ownership in Rust? You will quickly notice that it's impossible to do with only standard methods: you'd always have to choose one owner and everyone else would only have a reference to the turtle. Not good!</p>\n\n<p>So along come <code>Rc</code> and <code>Arc</code> (which, for the sake of this story, serve the exact same purpose). These allow for shared ownership by tinkering a bit with unsafe-Rust. Let's look at the memory after executing the following code (<em>note</em>: the memory layout is for learning and might not represent the exact same memory layout from the real world):</p>\n\n<pre><code>let annas = Rc::new(Turtle { legs: 4 });\n</code></pre>\n\n<p>Memory:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>  Stack                    Heap\n  -----                    ----\n\n\n  annas:\n+--------+               +------------+\n| ptr: o-|--------------&gt;| count: 1   |\n+--------+               | data: \ud83d\udc22   |\n                         +------------+\n</code></pre>\n\n<p>We see that the turtle lives on the heap... next to a counter which is set to 1. This counter knows how many owners the object <code>data</code> currently has. And 1 is correct: <code>annas</code> is the only one owning the turtle right now. Let's <code>clone()</code> the <code>Rc</code> to get more owners:</p>\n\n<pre><code>let peters = annas.clone();\nlet bobs = annas.clone();\n</code></pre>\n\n<p>Now the memory looks like this:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>  Stack                    Heap\n  -----                    ----\n\n\n  annas:\n+--------+               +------------+\n| ptr: o-|--------------&gt;| count: 3   |\n+--------+    ^          | data: \ud83d\udc22   |\n              |          +------------+\n peters:      |\n+--------+    |\n| ptr: o-|----+\n+--------+    ^\n              |\n  bobs:       |\n+--------+    |\n| ptr: o-|----+\n+--------+\n</code></pre>\n\n<p>As you can see, the turtle still exists only once. But the reference count was increased and is now 3, which makes sense, because the turtle has three owners now. All those three owners reference this memory block on the heap. That's what the Rust book calls <strong>owned handle</strong>: each owner of such a handle also kind of owns the underlying object.</p>\n\n<p>(<em>also see <a href=\"https://stackoverflow.com/questions/40014703/why-is-stdrcrc-not-copy/40014837#40014837\">\"Why is <code>std::rc::Rc&lt;&gt;</code> not Copy?\"</a></em>)</p>\n\n<h3>Atomicity and Mutability</h3>\n\n<p>What's the difference between <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> you ask? The <code>Arc</code> increments and decrements its counter in an atomic fashion. That means that multiple threads can increment and decrement the counter simultaneously without a problem. That's why you can send <code>Arc</code>s across thread-boundaries, but not <code>Rc</code>s.</p>\n\n<p>Now you notice that you can't mutate the data through an <code>Arc&lt;T&gt;</code>! What if your \ud83d\udc22 loses a leg? <code>Arc</code> is not designed to allow mutable access from multiple owners at (possibly) the same time. That's why you often see types like <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Mutex&lt;T&gt;</code> is a type that offers <em>interior mutability</em>, which means that you can get a <code>&amp;mut T</code> from a <code>&amp;Mutex&lt;T&gt;</code>! This would normally conflict with the Rust core principles, but it's perfectly safe because the mutex also manages access: you have to request access to the object. If another thread/source currently has access to the object, you have to wait. Therefore, at one given moment in time, there is only one thread able to access <code>T</code>. </p>\n\n<h2>Conclusion</h2>\n\n<blockquote>\n  <p>[...] is each thread modifying the original data instead of a copy?</p>\n</blockquote>\n\n<p>As you can hopefully understand from the explanation above: yes, each thread is modifying the original data. A <code>clone()</code> on an <code>Arc&lt;T&gt;</code> won't clone the <code>T</code>, but merely create another <em>owned handle</em>; which in turn is just a pointer that behaves as if it owns the underlying object.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 5, "last_activity_date": 1480983081, "creation_date": 1480983081, "answer_id": 40985671, "question_id": 40984932, "link": "https://stackoverflow.com/questions/40984932/what-happens-when-an-arc-is-cloned/40985671#40985671", "title": "What happens when an Arc is cloned?", "body": "<p><a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html\" rel=\"noreferrer\"><code>std::sync::Arc</code></a> is a <em>smart pointer</em>, one that adds the following abilities:</p>\n\n<blockquote>\n  <p>An atomically reference counted wrapper for shared state.</p>\n</blockquote>\n\n<p><code>Arc</code> (and its non-thread-safe friend <a href=\"https://doc.rust-lang.org/std/rc/struct.Rc.html\" rel=\"noreferrer\"><code>std::rc::Rc</code></a>) allow <strong>shared ownership</strong>. That means that multiple \"handles\" point to the same value. Whenever a handle is cloned, a <em>reference counter</em> is incremented. Whenever a handle is dropped, the counter is decremented. When the counter goes to zero, the value that the handles were pointing to is freed. </p>\n\n<p>Note that this smart pointer does <em>not</em> call the underlying <code>clone</code> method of the data; in fact, there may doesn't need to be an underlying <code>clone</code> method! <code>Arc</code> handles what happens when <code>clone</code> is called.</p>\n\n<blockquote>\n  <p>What is the new \"owned handle\"? It sounds like a reference to the data?</p>\n</blockquote>\n\n<p>It both <em>is</em> and <em>isn't</em> a reference. In the broader programming and English sense of the word \"reference\", it <strong>is a reference</strong>. In the specific sense of a Rust reference (<code>&amp;Foo</code>), it is <strong>not a reference</strong>. Confusing, right?</p>\n\n<hr>\n\n<p>The second part of your question is about <a href=\"https://doc.rust-lang.org/std/sync/struct.Mutex.html\" rel=\"noreferrer\"><code>std::sync::Mutex</code></a>, which is described as:</p>\n\n<blockquote>\n  <p>A mutual exclusion primitive useful for protecting shared data</p>\n</blockquote>\n\n<p>Mutexes are common tools in multithreaded programs, and are well-described\nelsewhere so I won't bother repeating that here. The important thing to note is that a Rust <code>Mutex</code> <em>only</em> gives you the ability to modify shared state. It is up to the <code>Arc</code> to allow multiple owners to have access to the <code>Mutex</code> to even attempt to modify the state.</p>\n\n<p>This is a bit more granular than other languages, but allows for these pieces to be reused in novel ways.</p>\n"}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2234, "favorite_count": 5, "accepted_answer_id": 40985661, "answer_count": 3, "score": 26, "last_activity_date": 1481210872, "creation_date": 1480978938, "last_edit_date": 1480984091, "question_id": 40984932, "link": "https://stackoverflow.com/questions/40984932/what-happens-when-an-arc-is-cloned", "title": "What happens when an Arc is cloned?", "body": "<p>I am learning concurrency and want to clarify my understanding on the following <a href=\"https://doc.rust-lang.org/book/concurrency.html\">code example from the Rust book</a>. Please correct me if I am wrong.  </p>\n\n<pre><code>use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n\n    for i in 0..3 {\n        let data = data.clone();\n        thread::spawn(move || {\n            let mut data = data.lock().unwrap();\n            data[0] += i;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n</code></pre>\n\n<p>What is happening on the line <code>let data = data.clone()</code>?</p>\n\n<p>The Rust book says</p>\n\n<blockquote>\n  <p>we use <code>clone()</code> to create a new owned handle. This handle is then moved into the new thread.</p>\n</blockquote>\n\n<p>What is the new \"owned handle\"? It sounds like a reference to the data? </p>\n\n<p>Since <code>clone</code> takes a <code>&amp;self</code> and returns a <code>Self</code>, is each thread modifying the original data instead of a copy? I guess that is why the code is not using <code>data.copy()</code> but <code>data.clone()</code> here.</p>\n\n<p>The <code>data</code> on the right side is a reference, and the <code>data</code> on the left is a owned value. There is a variable shadowing here.</p>\n"}, {"tags": ["rust", "type-inference"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480982250, "post_id": 40984757, "comment_id": 69180546, "body": "In the future, you will be well-served by <a href=\"http://stackoverflow.com/q/21747136/155423\">printing out the type of a variable</a>."}], "answers": [{"comments": [{"owner": {"reputation": 1985, "user_id": 2080712, "user_type": "registered", "accept_rate": 93, "profile_image": "https://i.stack.imgur.com/NyaqQ.jpg?s=128&g=1", "display_name": "Bernardo Meurer", "link": "https://stackoverflow.com/users/2080712/bernardo-meurer"}, "edited": false, "score": 1, "creation_date": 1480981307, "post_id": 40985117, "comment_id": 69180287, "body": "Awesome answer! Thank you!"}], "tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": true, "score": 7, "last_activity_date": 1480980170, "last_edit_date": 1480980170, "creation_date": 1480979848, "answer_id": 40985117, "question_id": 40984757, "link": "https://stackoverflow.com/questions/40984757/rust-type-inference-error/40985117#40985117", "title": "Rust Type Inference Error", "body": "<p><code>move |message|</code> shadows the <code>message</code> variable you've declared outside the closure. So within the closure.. <code>message</code> is said to be a <code>ws::Message</code> ... except you've done this:</p>\n\n<pre><code>message = message.trim();\n</code></pre>\n\n<p>The compiler goes \"oh no! <code>trim()</code>? That doesn't exist for <code>ws::Message</code>\".. and so now it doesn't quite know what to do.</p>\n\n<h3>Option 1</h3>\n\n<p>The first fix involves delegating the <code>trim()</code> call to the client who sends the message.</p>\n\n<p>The fix is to not make any assumptions about what the message is inside this closure. If you keep this:</p>\n\n<pre><code>move |message|\n</code></pre>\n\n<p>..but remove the <code>trim()</code> call, the compiler happily infers its type as <code>ws::Message</code> and will build:</p>\n\n<pre><code>if let Err(error) = listen(\"127.0.0.1:3012\", |out| {\n    // The handler needs to take ownership of out, so we use move\n    move |message| {\n        // --- REMOVED trim() call ---\n\n        // Handle messages received on this connection\n        println!(\"Server got message '{}'. \", message);\n\n        // Use the out channel to send messages back\n        out.send(message)\n    }\n}\n</code></pre>\n\n<p>This gives you the option of delegating the <code>trim()</code> call to the client instead.</p>\n\n<h3>Option 2</h3>\n\n<p>Option 2 involves inspecting the type of message you've received, and making sure you trim it only if it is text:</p>\n\n<pre><code>// The handler needs to take ownership of out, so we use move\nmove |mut message: ws::Message| {\n    // Only do it if the Message is text\n    if message.is_text() {\n        message = ws::Message::Text(message.as_text().unwrap().trim().into());\n    }\n\n    // Handle messages received on this connection\n    println!(\"Server got message '{}'. \", message);\n\n    // Use the out channel to send messages back\n    out.send(message)\n}\n</code></pre>\n\n<p>This is perhaps a little more verbose than it needs to be.. but hopefully it shows you what the actual issue is with your original snippet of code.</p>\n"}], "owner": {"reputation": 1985, "user_id": 2080712, "user_type": "registered", "accept_rate": 93, "profile_image": "https://i.stack.imgur.com/NyaqQ.jpg?s=128&g=1", "display_name": "Bernardo Meurer", "link": "https://stackoverflow.com/users/2080712/bernardo-meurer"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 132, "favorite_count": 1, "accepted_answer_id": 40985117, "answer_count": 1, "score": 6, "last_activity_date": 1481002458, "creation_date": 1480978029, "last_edit_date": 1481002458, "question_id": 40984757, "link": "https://stackoverflow.com/questions/40984757/rust-type-inference-error", "title": "Rust Type Inference Error", "body": "<p>I'm writing a chat server over TCP as a learning project. I've been tinkering with the <a href=\"https://crates.io/crates/ws\" rel=\"nofollow noreferrer\">ws</a> crate today, but I've come across an issue. This is the code I wrote, modifying their <a href=\"https://github.com/housleyjk/ws-rs/blob/master/examples/server.rs\" rel=\"nofollow noreferrer\">server example</a>.</p>\n\n<pre><code>extern crate ws;\nextern crate env_logger;\n\nuse ws::listen;\n\nfn main() {\n    // Setup logging\n    env_logger::init().unwrap();\n\n    // Listen on an address and call the closure for each connection\n    if let Err(error) = listen(\"127.0.0.1:3012\", |out| {\n        let mut message: String;\n        // The handler needs to take ownership of out, so we use move\n        move |message| {\n            message = message.trim();\n            // Handle messages received on this connection\n            println!(\"Server got message '{}'. \", message);\n\n            // Use the out channel to send messages back\n            out.send(message)\n        }\n\n    }) {\n        // Inform the user of failure\n        println!(\"Failed to create WebSocket due to {:?}\", error);\n    }\n}\n</code></pre>\n\n<p>When I try compiling it I get an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: the type of this value must be known in this context\n  --&gt; src/main.rs:15:23\n   |\n15 |             message = message.trim();\n   |                       ^^^^^^^^^^^^^^\n</code></pre>\n\n<p>Why is this happening? How may I fix this?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 453, "user_id": 768714, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a4dd2e481fe489e55996896279ba52be?s=128&d=identicon&r=PG", "display_name": "Erik", "link": "https://stackoverflow.com/users/768714/erik"}, "edited": false, "score": 0, "creation_date": 1480968153, "post_id": 40981551, "comment_id": 69174282, "body": "Awesome! That was it. I&#39;ll make sure to report the error.  Just so I know exactly what happened, the implementation of Agent for Miner wasn&#39;t compatible because the trait Agent didn&#39;t have a lifetime associated with it. So when it was trying to compile new in the implementation, it found that it had a lifetime from the Agent::new but a was a random other lifetime it couldn&#39;t figure out since that lifetime wasn&#39;t in the output. The lifetime at the trait level allows you to associated the lifetime in the impl block and your able to say that the agent will have the same lifetime as the miner?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1480968887, "last_edit_date": 1480968887, "creation_date": 1480964937, "answer_id": 40981551, "question_id": 40981338, "link": "https://stackoverflow.com/questions/40981338/method-not-compatible-with-trait-with-confusing-error-message/40981551#40981551", "title": "Method not compatible with trait with confusing error message", "body": "<p>That's a pretty bad error message, and I'd encourage you <a href=\"https://github.com/rust-lang/rust/issues/new\" rel=\"nofollow noreferrer\">to report it</a>. If you change your generic lifetime parameter names...</p>\n\n<pre><code>trait Agent {\n    fn new&lt;'a&gt;(&amp;'a mut Vec&lt;ResourceEntry&gt;) -&gt; Self;\n}\n\nstruct Miner&lt;'b&gt; {\n    inventory: &amp;'b mut Vec&lt;ResourceEntry&gt;,\n}\n\nimpl&lt;'c&gt; Agent for Miner&lt;'c&gt; {\n    fn new(starting_resource: &amp;'c mut Vec&lt;ResourceEntry&gt;) -&gt; Miner {\n        Miner { inventory: starting_resource }\n    }\n}\n</code></pre>\n\n<p>you get a better error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: method not compatible with trait\n  --&gt; src/main.rs:32:5\n   |\n32 |     fn new(starting_resource: &amp;'c mut Vec&lt;ResourceEntry&gt;) -&gt; Miner {\n   |     ^ lifetime mismatch\n   |\n   = note: expected type `fn(&amp;'a mut std::vec::Vec&lt;ResourceEntry&gt;) -&gt; Miner&lt;'c&gt;`\n   = note:    found type `fn(&amp;'c mut std::vec::Vec&lt;ResourceEntry&gt;) -&gt; Miner&lt;'c&gt;`\n</code></pre>\n\n<p>Adding a lifetime to an <code>impl</code> block is <strong>not a shorthand</strong> for specifying a lifetime on each function; they have different scopes. You can see that what you are trying to do doesn't make sense:</p>\n\n<pre><code>fn new&lt;'a&gt;(&amp;'a mut Vec&lt;ResourceEntry&gt;) -&gt; Self;\n</code></pre>\n\n<p>That lifetime isn't <em>used</em> anywhere in the output. Instead, you need to make the the lifetime play a role in the trait:</p>\n\n<pre><code>trait Agent&lt;'a&gt; {\n    fn new(&amp;'a mut Vec&lt;ResourceEntry&gt;) -&gt; Self;\n}\n\nimpl&lt;'c&gt; Agent&lt;'c&gt; for Miner&lt;'c&gt; {\n    fn new(starting_resource: &amp;'c mut Vec&lt;ResourceEntry&gt;) -&gt; Miner&lt;'c&gt; {\n        Miner { inventory: starting_resource }\n    }\n}\n</code></pre>\n\n<blockquote>\n  <p>Just so I know exactly what happened, the implementation of <code>Agent</code> for <code>Miner</code> wasn't compatible because the trait <code>Agent</code> didn't have a lifetime associated with it. So when it was trying to compile <code>new</code> in the implementation, it found that it had a lifetime from the <code>Agent::new</code> but <code>a</code> was a random other lifetime it couldn't figure out since that lifetime wasn't in the output.</p>\n</blockquote>\n\n<p>Kind of. It wasn't compatible because the implementation of <code>new</code> didn't have a lifetime parameter (<code>fn new&lt;'x&gt;</code>) while the trait definition did. Adding a lifetime to <code>new</code> would have \"solved\" that problem, but would either not compile or not do what you want.  </p>\n\n<blockquote>\n  <p>The lifetime at the trait level allows you to associated the lifetime in the impl block </p>\n</blockquote>\n\n<p>The lifetime at the trait level means that the types that implement the trait can be parameterized with a lifetime. The trait also will know about that lifetime.</p>\n\n<blockquote>\n  <p>and your able to say that the agent will have the same lifetime as the miner?</p>\n</blockquote>\n\n<p>I think you understand the concept, but I'll point out that this terminology is subtly wrong. The <code>Miner</code> will be provided with a reference \nwith a concrete lifetime; this is <em>not</em> the same thing as the <code>Miner</code>'s lifetime! The implementation of <code>Agent</code> for <code>Miner</code> will be able to make use of the provided lifetime, but <code>Agent</code> does not itself have a lifetime; it's just a trait.</p>\n\n<p>This is a weakness of humans and how we talk about things fast and loose. A value's lifetime is when it comes into being until it is moved. In Rust, <code>'a</code> are lifetime annotations / generic lifetime parameters, and these allow a value to contain references. The concrete lifetime will replace the parameter when the value is constructed with a reference.</p>\n"}], "owner": {"reputation": 453, "user_id": 768714, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a4dd2e481fe489e55996896279ba52be?s=128&d=identicon&r=PG", "display_name": "Erik", "link": "https://stackoverflow.com/users/768714/erik"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 562, "favorite_count": 0, "accepted_answer_id": 40981551, "answer_count": 1, "score": 4, "last_activity_date": 1480968887, "creation_date": 1480964159, "last_edit_date": 1480964293, "question_id": 40981338, "link": "https://stackoverflow.com/questions/40981338/method-not-compatible-with-trait-with-confusing-error-message", "title": "Method not compatible with trait with confusing error message", "body": "<p>I am venturing to the world of lifetimes and structs that contain mutable structs:</p>\n\n<pre><code>enum Resources {\n    Food,\n    Wood,\n    Tools,\n    Ore,\n    Metal,\n}\n\nstruct ResourceEntry {\n    resource: Resources,\n    amount: i32,\n}\n\nimpl ResourceEntry {\n    fn new(resource: Resources, amount: i32) -&gt; ResourceEntry {\n        ResourceEntry {\n            resource: resource,\n            amount: amount,\n        }\n    }\n}\n\ntrait Agent {\n    fn new&lt;'a&gt;(&amp;'a mut Vec&lt;ResourceEntry&gt;) -&gt; Self;\n}\n\nstruct Miner&lt;'a&gt; {\n    inventory: &amp;'a mut Vec&lt;ResourceEntry&gt;,\n}\n\nimpl&lt;'a&gt; Agent for Miner&lt;'a&gt; {\n    fn new(starting_resource: &amp;'a mut Vec&lt;ResourceEntry&gt;) -&gt; Miner {\n        Miner { inventory: starting_resource }\n    }\n}\n\nfn main() {\n    let mut resource = ResourceEntry::new(Resources::Food, 3);\n    let mut vec = vec![resource];\n    let miner: Miner = Miner::new(vec);\n\n    miner.perform();\n}\n</code></pre>\n\n<p>I get the following error</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: method not compatible with trait\n  --&gt; other.rs:47:5\n   |\n47 |     fn new(starting_resource: &amp;'a mut Vec&lt;ResourceEntry&gt;) -&gt; Miner\n   |     ^ lifetime mismatch\n   |\n   = note: expected type `fn(&amp;'a mut std::vec::Vec&lt;ResourceEntry&gt;) -&gt; Miner&lt;'a&gt;`\n   = note:    found type `fn(&amp;'a mut std::vec::Vec&lt;ResourceEntry&gt;) -&gt; Miner&lt;'a&gt;`\nnote: the lifetime 'a as defined on the block at 48:4...\n  --&gt; other.rs:48:5\n   |\n48 |     {\n   |     ^\nnote: ...does not necessarily outlive the lifetime 'a as defined on the block at 48:4\n  --&gt; other.rs:48:5\n   |\n48 |     {\n   |     ^\nhelp: consider using an explicit lifetime parameter as shown: fn new(starting_resource: &amp;'a mut Vec&lt;ResourceEntry&gt;) -&gt; Miner\n  --&gt; other.rs:47:5\n   |\n47 |     fn new(starting_resource: &amp;'a mut Vec&lt;ResourceEntry&gt;) -&gt; Miner\n   |     ^\n</code></pre>\n\n<p>I can't for the life of me wrap my head around what the compiler is telling me. The error messages are saying to do exactly what I am doing. Maybe I'm misunderstanding but it's saying that the lifetime of <code>a</code> doesn't match the lifetime of <code>a</code>? I thought I had a pretty good grasp of borrowing and ownership but the use of explicit lifetimes and objects that reference other objects has me confused. </p>\n\n<p>Is the problem </p>\n\n<blockquote>\n  <p>fn new&lt;'a>(&amp;'a mut Vec) -> Self;</p>\n</blockquote>\n\n<p>I had trouble with getting new to accept a lifetime correctly and I'm wondering if this isn't something you should do in Rust?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480963955, "post_id": 40981225, "comment_id": 69171914, "body": "You haven&#39;t provided the definition of <code>mailparse::ParsedMail</code> (or <b>even better</b> a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>). My intuition says that <code>ParsedMail</code> contains a reference to the buffer, so the answer to your question is: <i>you can&#39;t</i>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480964105, "post_id": 40981225, "comment_id": 69171993, "body": "See also <a href=\"http://stackoverflow.com/q/28820781/155423\">stackoverflow.com/q/28820781/155423</a>; <a href=\"http://stackoverflow.com/q/25464151/155423\">stackoverflow.com/q/25464151/155423</a>; <a href=\"http://stackoverflow.com/q/27570978/155423\">stackoverflow.com/q/27570978/155423</a>; <a href=\"http://stackoverflow.com/q/35666024/155423\">stackoverflow.com/q/35666024/155423</a>; <a href=\"http://stackoverflow.com/q/30330697/155423\">stackoverflow.com/q/30330697/155423</a>; <b>all</b> of which contain the search string &quot;rust extend lifetime&quot;. You are expected to <a href=\"http://meta.stackoverflow.com/q/261592/155423\">perform (and then show us) your research before asking a question</a>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480965128, "post_id": 40981225, "comment_id": 69172567, "body": "One of <a href=\"https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetimes\" rel=\"nofollow noreferrer\">the better ways I&#39;ve seen it described</a>: <i>It&#39;s important to understand that lifetime annotations are descriptive, not prescriptive. This means that how long a reference is valid is determined by the code, not by the annotations.</i>"}], "owner": {"reputation": 1331, "user_id": 2207958, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/SJNmA.jpg?s=128&g=1", "display_name": "Max Linke", "link": "https://stackoverflow.com/users/2207958/max-linke"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 100, "favorite_count": 0, "closed_date": 1480964152, "answer_count": 0, "score": 0, "last_activity_date": 1480963822, "creation_date": 1480963693, "last_edit_date": 1480963822, "question_id": 40981225, "link": "https://stackoverflow.com/questions/40981225/extend-borrow-lifetime-of-scope-local-variable", "closed_reason": "Duplicate", "title": "Extend borrow lifetime of scope local variable", "body": "<p>I have the following function to parse mail in Rust. </p>\n\n<pre><code>fn read_mail(fname: &amp;Path) -&gt; Result&lt;mailparse::ParsedMail, mailparse::MailParseError&gt; {\n    let mut f = File::open(fname).unwrap();\n    let mut buf = String::new();\n    let _ = f.read_to_string(&amp;mut buf);\n    mailparse::parse_mail(buf.as_bytes())\n}\n</code></pre>\n\n<p>Here <code>buf</code> only lives until the function returns and <code>parse_mail</code> borrows it. This won't compile since the return value would outlive it's borrow. </p>\n\n<p>How can I tell Rust that <code>buf</code> can have a longer lifetime until the return value is destroyed?</p>\n"}, {"tags": ["concurrency", "rust", "closures"], "answers": [{"comments": [{"owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "edited": false, "score": 0, "creation_date": 1480929641, "post_id": 40970605, "comment_id": 69150599, "body": "super effective. Thanks!"}, {"owner": {"reputation": 1540, "user_id": 2606171, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/F4ncy.png?s=128&g=1", "display_name": "belst", "link": "https://stackoverflow.com/users/2606171/belst"}, "edited": false, "score": 0, "creation_date": 1480934305, "post_id": 40970605, "comment_id": 69153450, "body": "the compiler should give the <code>move</code> solution for threads aswell."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 5, "last_activity_date": 1480945256, "last_edit_date": 1480945256, "creation_date": 1480928883, "answer_id": 40970605, "question_id": 40970432, "link": "https://stackoverflow.com/questions/40970432/can-you-provide-any-example-where-the-closure-outlives-the-current-function/40970605#40970605", "title": "Can you provide any example where the closure outlives the current function?", "body": "<p>Since you moved the closure into a thread and threads may outlive the current function (they are not automatically joined an the function end, use the <code>crossbeam</code> crate for this kind of feature), it's just the same as moving it on the heap.</p>\n\n<p>If you look at the following piece of code, you can see that moving a closure to the heap and returning it is forbidden. Since threads are basically the same thing with respect to borrowing, you can't reference anything in a thread.</p>\n\n<pre><code>fn foo() -&gt; Box&lt;FnOnce()&gt; {\n    let x = 1;\n    Box::new(|| {\n        println!(\"x is {}\", x);\n    })\n}\n\nfn main() {\n    let f = foo();\n}\n</code></pre>\n\n<p>Note that the compiler gives a solution to the Problem in the error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>help: to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword, as shown:\n  |     Box::new(move || {\n</code></pre>\n"}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 160, "favorite_count": 0, "accepted_answer_id": 40970605, "answer_count": 1, "score": 0, "last_activity_date": 1480945256, "creation_date": 1480928261, "last_edit_date": 1480945224, "question_id": 40970432, "link": "https://stackoverflow.com/questions/40970432/can-you-provide-any-example-where-the-closure-outlives-the-current-function", "title": "Can you provide any example where the closure outlives the current function?", "body": "<p>Based on the Rust book, the following code can cause the <code>closure may outlive the current function</code> error:</p>\n\n<pre><code>use std::thread;\n\nfn main() {\n    let x = 1;\n    thread::spawn(|| {\n        println!(\"x is {}\", x);\n    });\n}\n</code></pre>\n\n<p>It is abstract to think when and how the closure would outlive the current function happen; can you provide any examples or specifications? </p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 8365, "user_id": 529459, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/fad57613bb8451cdb8820707924133a6?s=128&d=identicon&r=PG", "display_name": "Mark Tozzi", "link": "https://stackoverflow.com/users/529459/mark-tozzi"}, "edited": false, "score": 0, "creation_date": 1480949410, "post_id": 40966030, "comment_id": 69163151, "body": "One quick follow up: I noticed you didn&#39;t put any trait bounds on the struct itself, only on the implementations.  Is that a Rust convention?"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 8365, "user_id": 529459, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/fad57613bb8451cdb8820707924133a6?s=128&d=identicon&r=PG", "display_name": "Mark Tozzi", "link": "https://stackoverflow.com/users/529459/mark-tozzi"}, "edited": false, "score": 0, "creation_date": 1480949476, "post_id": 40966030, "comment_id": 69163192, "body": "@MarkTozzi It&#39;s mostly up to personal preference.  You can repeat the bounds everywhere if you want to make it more difficult to &quot;mis-use&quot; a type, but it seemed overkill for an example."}, {"owner": {"reputation": 293, "user_id": 478658, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/357dd2bc31ed5785c639b641415c3db5?s=128&d=identicon&r=PG", "display_name": "Sebastian", "link": "https://stackoverflow.com/users/478658/sebastian"}, "edited": false, "score": 1, "creation_date": 1489512117, "post_id": 40966030, "comment_id": 72699634, "body": "In case anybody is wondering as well: the &quot;where for&quot; construct is called (The Magic of) Higher-Rank Trait Bounds (HRTBs) and is documented here <a href=\"https://doc.rust-lang.org/nomicon/hrtb.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/nomicon/hrtb.html</a>"}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 10, "last_activity_date": 1480907796, "last_edit_date": 1480907796, "creation_date": 1480903040, "answer_id": 40966030, "question_id": 40965230, "link": "https://stackoverflow.com/questions/40965230/how-to-avoid-excessive-cloning-in-rust/40966030#40966030", "title": "How to avoid excessive cloning in Rust?", "body": "<p>The solution is to use a <code>where</code> clause like so:</p>\n\n<pre><code>extern crate num;\n\nuse num::One;\nuse std::ops::Add;\n\npub struct Fibonacci&lt;T&gt; {\n    nth: T,\n    n_plus_one_th: T,\n}\n\nimpl&lt;T&gt; Fibonacci&lt;T&gt;\n    where T: One\n{\n    pub fn new() -&gt; Fibonacci&lt;T&gt; {\n        Fibonacci {\n            nth: T::one(),\n            n_plus_one_th: T::one(),\n        }\n    }\n}\n\nimpl&lt;T&gt; Iterator for Fibonacci&lt;T&gt;\n    where for&lt;'a&gt; &amp;'a T: Add&lt;&amp;'a T, Output = T&gt;\n{\n    type Item = T;\n    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {\n        use std::mem::swap;\n        let mut temp = &amp;self.nth + &amp;self.n_plus_one_th;\n        swap(&amp;mut self.nth, &amp;mut temp);\n        swap(&amp;mut self.n_plus_one_th, &amp;mut self.nth);\n        Some(temp)\n    }\n}\n</code></pre>\n\n<p>Specifically, the <code>for&lt;'a&gt; &amp;'a T: Add&lt;&amp;'a T, Output=T&gt;</code> clause reads as \"for any lifetime <code>'a</code>, <code>&amp;'a T</code> must implement <code>Add</code> with a RHS of <code>&amp;'a T</code> and <code>Output=T</code>.  That is, you can add two <code>&amp;T</code>s to get a new <code>T</code>.</p>\n\n<p>With that, the only remaining issue is shuffling the values around, which can be done using <code>swap</code>.</p>\n\n<p>I also took the liberty of simplifying the constraints elsewhere (you only needed <code>One</code>, not <code>Integer</code>).</p>\n"}], "owner": {"reputation": 8365, "user_id": 529459, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/fad57613bb8451cdb8820707924133a6?s=128&d=identicon&r=PG", "display_name": "Mark Tozzi", "link": "https://stackoverflow.com/users/529459/mark-tozzi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1619, "favorite_count": 1, "accepted_answer_id": 40966030, "answer_count": 1, "score": 10, "last_activity_date": 1480907796, "creation_date": 1480896062, "last_edit_date": 1480907767, "question_id": 40965230, "link": "https://stackoverflow.com/questions/40965230/how-to-avoid-excessive-cloning-in-rust", "title": "How to avoid excessive cloning in Rust?", "body": "<p>I'm trying to learn Rust, and like many before me set off to write a Fibonacci sequence iterator for practice.  My first pass used <code>u32</code>s and worked fine, so I decided to try to write a generic version.  This is my result:</p>\n\n<pre><code>use num::Integer;\nuse std::ops::Add;\n\npub struct Fibonacci&lt;T: Integer + Add + Clone&gt; {\n    nth: T,\n    n_plus_one_th: T,\n}\n\nimpl&lt;T: Integer + Add + Clone&gt; Iterator for Fibonacci&lt;T&gt; {\n    type Item = T;\n    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {\n        let temp = self.nth.clone();\n        self.nth = self.n_plus_one_th.clone();\n        self.n_plus_one_th = temp.clone() + self.n_plus_one_th.clone();\n        Some(temp)\n    }\n}\n\nimpl&lt;T: Integer + Add + Clone&gt; Fibonacci&lt;T&gt; {\n    pub fn new() -&gt; Fibonacci&lt;T&gt; {\n        Fibonacci {\n            nth: T::one(),\n            n_plus_one_th: T::one(),\n        }\n    }\n}\n</code></pre>\n\n<p>I tested this with a <code>u32</code> and a <code>num::BigUint</code>, and it works fine.  I'm concerned about all the cloning in the <code>next</code> method though.  In particular, I don't understand why I need to clone during the addition step.</p>\n\n<p>I suspect there is a better way to write this using some of Rust's more advanced reference concepts, but so far I haven't figured it out.</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480894250, "post_id": 40964736, "comment_id": 69139496, "body": "Note that the examples you are looking are just examples of <b>syntax</b>; they aren&#39;t necessarily <i>valid</i> or <i>useful</i>."}, {"owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480894478, "post_id": 40964736, "comment_id": 69139560, "body": "I see. Thanks for pointing me to the right direction. The other related post answers everything!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480896234, "post_id": 40964736, "comment_id": 69139999, "body": "You may wish to review <a href=\"http://rust-lang.github.io/book/ch10-03-lifetime-syntax.html\" rel=\"nofollow noreferrer\">the new version of the book</a> which removes that confusing line."}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 43, "favorite_count": 0, "closed_date": 1480894148, "answer_count": 0, "score": 0, "last_activity_date": 1480896574, "creation_date": 1480892357, "last_edit_date": 1495541321, "question_id": 40964736, "link": "https://stackoverflow.com/questions/40964736/why-would-a-function-taking-no-arguments-and-returning-a-reference-have-a-lifeti", "closed_reason": "Duplicate", "title": "Why would a function taking no arguments and returning a reference have a lifetime error?", "body": "<p>Update: this question has been answered in <a href=\"https://stackoverflow.com/questions/32682876/is-there-any-way-to-return-a-reference-to-a-variable-created-in-a-function\">Is there any way to return a reference to a variable created in a function?</a></p>\n\n<p>Also the confusing example that mentioned has been cleared in the <a href=\"http://rust-lang.github.io/book/ch10-03-lifetime-syntax.html\" rel=\"nofollow noreferrer\">new Rust book</a>.</p>\n\n<p>Based on the closure examples in the Rust book:</p>\n\n<pre><code>fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {\n    let num = 5;    \n    |x| x + num\n}\n\nlet f = factory();   \nlet answer = f(1);\nassert_eq!(6, answer);\n</code></pre>\n\n<p>This example would have error: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: missing lifetime specifier [E0106]\nfn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {\n                ^~~~~~~~~~~~~~~~~\n</code></pre>\n\n<p>I found this <code>fn factory() -&gt; &amp;(Fn(i32) -&gt; i32)</code> can be abstracted as </p>\n\n<pre><code>fn foo&lt;'a&gt;() -&gt; &amp;'a Someclosure. \n</code></pre>\n\n<p>I am trying to understand why a function takes no arguments would have a lifetime problem here. </p>\n\n<p>Is that similar to the example given in the <a href=\"https://doc.rust-lang.org/book/lifetimes.html#lifetime-elision\" rel=\"nofollow noreferrer\">lifetime elision</a> in Rust book:<code>fn foo&lt;'a&gt;() -&gt; &amp;'a str</code>? This seems to be a valid example about how to use lifetime. </p>\n"}, {"tags": ["struct", "rust", "closures", "move"], "answers": [{"comments": [{"owner": {"reputation": 375, "user_id": 3150550, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/aec1172df116b59824119f1d72080c0c?s=128&d=identicon&r=PG", "display_name": "cderwin", "link": "https://stackoverflow.com/users/3150550/cderwin"}, "edited": false, "score": 0, "creation_date": 1480897128, "post_id": 40964654, "comment_id": 69140217, "body": "This helps loads, thanks.  I ended up using <code>Fn</code> instead of <code>FnOnce</code> because I wanted to create a const instance of the struct, but this whole response helps a ton with understanding the whole thing."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 6, "last_activity_date": 1480903648, "last_edit_date": 1480903648, "creation_date": 1480891796, "answer_id": 40964654, "question_id": 40964474, "link": "https://stackoverflow.com/questions/40964474/calling-a-stack-allocated-closure-stored-in-a-struct-in-rust/40964654#40964654", "title": "Calling a Stack-Allocated Closure Stored in a Struct in Rust", "body": "<p>The closure is being moved because <a href=\"https://doc.rust-lang.org/stable/std/ops/trait.FnOnce.html#tymethod.call_once\" rel=\"nofollow noreferrer\"><code>FnOnce::call_once</code></a> takes <code>self</code> by value. This contract enforces the guarantee that the function will not be called more than once.</p>\n\n<p>If you will indeed be calling the closure at most once, and you want to use the <code>FnOnce</code> trait, then your struct needs to take ownership of that closure (and you will need to make your struct generic on the closure type). Note that calling the closure will move the closure out of your struct, thereby invalidating the whole struct; you may work around that by wrapping the <code>FnOnce</code> in an <code>Option</code> and <a href=\"https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.take\" rel=\"nofollow noreferrer\"><code>take</code></a>-ing the closure out of the <code>Option</code> before calling it.</p>\n\n<p>If you might be calling the closure more than once, you don't want to take ownership of the closure, or you don't want to make your struct generic on the closure type, then you should use either <code>Fn</code> or <code>FnMut</code> instead. <a href=\"https://doc.rust-lang.org/stable/std/ops/trait.Fn.html#tymethod.call\" rel=\"nofollow noreferrer\"><code>Fn::call</code></a> takes <code>self</code> by reference and <a href=\"https://doc.rust-lang.org/stable/std/ops/trait.FnMut.html#tymethod.call_mut\" rel=\"nofollow noreferrer\"><code>FnMut::call_mut</code></a> takes <code>self</code> by mutable reference. Since both accept references, you can use trait objects with them.</p>\n"}, {"tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": false, "score": 2, "last_activity_date": 1480894930, "last_edit_date": 1480894930, "creation_date": 1480894578, "answer_id": 40965033, "question_id": 40964474, "link": "https://stackoverflow.com/questions/40964474/calling-a-stack-allocated-closure-stored-in-a-struct-in-rust/40965033#40965033", "title": "Calling a Stack-Allocated Closure Stored in a Struct in Rust", "body": "<p>As explained by Francis, declaring a closure <code>FnOnce</code> tells Rust that you accept the broadest class of closures, including those that exhaust the objects they capture. That such closures are invoked only once is ensured by the compiler by destroying the closure object itself (by moving it into its own <code>call</code> method) when invoked.</p>\n\n<p>It is possible to use <code>FnOnce</code> and still not have <code>S</code> generic on the closure, but it requires some work to set things up so that the closure can't be possibly invoked more than once:</p>\n\n<ul>\n<li>the closure must be stored in an <code>Option</code>, so its contents can be \"stolen\" and the <code>Option</code> replaced with <code>None</code> (this part ensures that the closure won't be called twice);</li>\n<li>invent a trait that knows how to steal the closure from the option and invoke it (or do something else if the closure was already stolen);</li>\n<li>store a reference to the trait object in <code>S</code> - this enables the same <code>S</code> type works on different closures without being generic on closure type.</li>\n</ul>\n\n<p>The result looks like this:</p>\n\n<pre><code>trait Callable {\n    fn call_once_safe(&amp;mut self, default: u32) -&gt; u32;\n}\n\nimpl&lt;F: FnOnce() -&gt; u32&gt; Callable for Option&lt;F&gt; {\n    fn call_once_safe(&amp;mut self, default: u32) -&gt; u32 {\n        if let Some(func) = self.take() {\n            func()\n        } else {\n            default\n        }\n    }\n}\n\nstruct S&lt;'a&gt; {\n    func: &amp;'a mut Callable\n}\n\nimpl&lt;'a&gt; S&lt;'a&gt; {\n    pub fn invoke(&amp;mut self) -&gt; u32 {\n        self.func.call_once_safe(1)\n    }\n}\n\nfn main() {\n    let mut s = S { func: &amp;mut Some(|| 0) };\n    let val1 = s.invoke();\n    let val2 = s.invoke();\n    println!(\"{} {}\", val1, val2);\n}\n</code></pre>\n\n<p>The only place that knows details about the closure is the implementation of <code>Callable</code> for the particular <code>Option&lt;F&gt;</code>, generated for each closure and referenced by the vtable of the <code>&amp;mut Callable</code> fat pointer created when initializing the <code>func</code> in <code>S</code>.</p>\n"}], "owner": {"reputation": 375, "user_id": 3150550, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/aec1172df116b59824119f1d72080c0c?s=128&d=identicon&r=PG", "display_name": "cderwin", "link": "https://stackoverflow.com/users/3150550/cderwin"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 542, "favorite_count": 1, "accepted_answer_id": 40964654, "answer_count": 2, "score": 4, "last_activity_date": 1480903648, "creation_date": 1480890540, "last_edit_date": 1480894333, "question_id": 40964474, "link": "https://stackoverflow.com/questions/40964474/calling-a-stack-allocated-closure-stored-in-a-struct-in-rust", "title": "Calling a Stack-Allocated Closure Stored in a Struct in Rust", "body": "<p>I am storing a closure in a struct like this:</p>\n\n<pre><code>#[derive(Clone)]\nstruct S&lt;'a&gt; {\n    func: &amp;'a FnOnce() -&gt; u32\n}\n\nfn main() {\n    let s = S { func: &amp;|| 0 };\n    let val = (s.func)();\n    println!(\"{}\", val);\n}\n</code></pre>\n\n<p>When I compile, <code>s.func</code> cannot be moved to execute itself.  I understand why it cannot be moved (namely that it's only a reference and that its size is not known at compile time), but don't know why it's being moved at all -- is it just because closures are implemented via traits?</p>\n\n<p>Here's the error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0161]: cannot move a value of type std::ops::FnOnce() -&gt; u32:\nthe size of std::ops::FnOnce() -&gt; u32 cannot be statically determined\n --&gt; main.rs:8:15\n  |\n8 |     let val = (s.func)();\n  |               ^^^^^^^^\n\nerror[E0507]: cannot move out of borrowed content\n --&gt; main.rs:8:15\n  |\n8 |     let val = (s.func)();\n  |               ^^^^^^^^ cannot move out of borrowed content\n\nerror: aborting due to 2 previous errors\n</code></pre>\n\n<p>Is this only way the solve this to store the closure on the heap (via <code>Box&lt;FnOnce() -&gt; u32&gt;</code>)?  And why does calling a closure move it?  Presumably calling it doesn't mutate the function itself.</p>\n"}, {"tags": ["generics", "rust", "traits"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 4, "creation_date": 1480888596, "post_id": 40963710, "comment_id": 69137680, "body": "You can&#39;t really use <code>Ord</code> with trait objects, as it can only compare concrete objects of the same type (I can&#39;t resist saying you can&#39;t compare <code>Apple</code>s and <code>Orange</code>s). Do you need to store multiple different <code>Fruit</code>s in one container? I&#39;d try <code>impl Ord for Box&lt;WeightedFruit&gt;</code> (and Eq), but I haven&#39;t got time right now. If this is still open tomorrow I&#39;ll have a play."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480893379, "post_id": 40963710, "comment_id": 69139249, "body": "How is this different from other existing questions with the same error message (&quot;the trait ... cannot be made into an object&quot;)?"}, {"owner": {"reputation": 23, "user_id": 7249319, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9a67e43a39b817528be50fb9ade33586?s=128&d=identicon&r=PG&f=1", "display_name": "zaari", "link": "https://stackoverflow.com/users/7249319/zaari"}, "edited": false, "score": 0, "creation_date": 1480916933, "post_id": 40963710, "comment_id": 69144974, "body": "I really couldn&#39;t find an existing question which could explain why you seem to be able to use traits as objects in some cases but not in some others (the Linkedlist part above compiles). And yeah, my intention was to compare apples and oranges... :-) OO languages wouldn&#39;t have any problems on that."}, {"owner": {"reputation": 4182, "user_id": 2992101, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7363e9ce46406af3326492e2f6cf40ca?s=128&d=identicon&r=PG", "display_name": "michalsrb", "link": "https://stackoverflow.com/users/2992101/michalsrb"}, "edited": false, "score": 0, "creation_date": 1480943009, "post_id": 40963710, "comment_id": 69158863, "body": "OO languages have similar kind of problem: For example in Java you can reimplement <code>compareTo</code> method, but then you have to dynamically check if you actually got an object of a type that you are able to compare. If you go the typed way and implement the <code>Comparable&lt;T&gt;</code> interface, you must choose the <code>T</code>. The <code>Ord</code> in rust is like <code>Comparable&lt;T&gt;</code> in Java, but you can not choose the <code>T</code>, it is always <code>Self</code>."}], "answers": [{"comments": [{"owner": {"reputation": 23, "user_id": 7249319, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9a67e43a39b817528be50fb9ade33586?s=128&d=identicon&r=PG&f=1", "display_name": "zaari", "link": "https://stackoverflow.com/users/7249319/zaari"}, "edited": false, "score": 1, "creation_date": 1480949979, "post_id": 40975454, "comment_id": 69163514, "body": "I wish Rust documentation had examples and information like this. This is exactly what I tried to do. Thank you!"}], "tags": [], "owner": {"reputation": 4182, "user_id": 2992101, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7363e9ce46406af3326492e2f6cf40ca?s=128&d=identicon&r=PG", "display_name": "michalsrb", "link": "https://stackoverflow.com/users/2992101/michalsrb"}, "is_accepted": true, "score": 2, "last_activity_date": 1480946099, "last_edit_date": 1480946099, "creation_date": 1480944710, "answer_id": 40975454, "question_id": 40963710, "link": "https://stackoverflow.com/questions/40963710/extended-traits-in-collections/40975454#40975454", "title": "Extended Traits in Collections", "body": "<pre><code>pub trait WeightedFruit: Fruit + Ord { }\n</code></pre>\n\n<p>This says the every struct that implements <code>WeightedFruit</code> must be comparable to itself. But not to other structs that implement that trait. So if an <code>Apple</code> implements <code>WeightedFruit</code>, it will be comparable to <code>Apple</code>, if an <code>Orange</code> implements <code>WeightedFruit</code>, it will be comparable to <code>Orange</code>, but not to each other.</p>\n\n<p>You can not build a collection of \"anything that is WeightedFruit\", because they are not interchangeable - Apples and Oranges are different, because each is comparable to different kind.</p>\n\n<p>Instead you want to do something like this:</p>\n\n<pre><code>use std::cmp::*;\nuse std::collections::*;\n\npub trait Fruit { }\n\npub trait WeightedFruit: Fruit {\n    fn weight(&amp;self) -&gt; u32;\n}\n\nimpl Ord for WeightedFruit {\n    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {\n        self.weight().cmp(&amp;other.weight())\n    }\n}\n\nimpl PartialOrd for WeightedFruit {\n    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {\n        Some(self.cmp(other))\n    }\n}\n\nimpl PartialEq for WeightedFruit {\n    fn eq(&amp;self, other: &amp;Self) -&gt; bool {\n        self.weight() == other.weight()\n    }\n}\n\nimpl Eq for WeightedFruit {}\n\n\nstruct Apple {\n    weight: u32\n}\n\nimpl Fruit for Apple {}\n\nimpl WeightedFruit for Apple {\n    fn weight(&amp;self) -&gt; u32 {\n        self.weight\n    }\n}\n\nstruct Orange {\n    weight: u32\n}\n\nimpl Fruit for Orange {}\n\nimpl WeightedFruit for Orange {\n    fn weight(&amp;self) -&gt; u32 {\n        self.weight\n    }\n}\n\npub fn main() {\n    let unsorted: LinkedList&lt;Box&lt;Fruit&gt;&gt; = LinkedList::new();\n    let sorted: BTreeSet&lt;Box&lt;WeightedFruit&gt;&gt; = BTreeSet::new();\n}\n</code></pre>\n\n<p>This says that every <code>WeightedFruit</code> fruit must be able to provide its <code>weight</code> and every <code>WeightedFruit</code> can be compared to any other <code>WeightedFruit</code> using this <code>weight</code>. Now you can make trait objects of <code>WeightedFruit</code> and mix them together in collections because they are interchangeable.</p>\n\n<hr>\n\n<p>Additional explanation about the <code>Ord</code> and the <code>the trait ... cannot be made into an object</code> error:</p>\n\n<p>When you work with trait objects, traits look kinda like interfaces in OO languages. You can have s trait and multiple structs that implement it and a function that takes a trait object. It can then call the functions of the trait on the object because it knows that it will have them and that they are exactly the same for every object. Just like in OO languages.</p>\n\n<p>However traits have one extra feature: They can use the <code>Self</code> type in the function declarations. <code>Self</code> is always the type that implements the trait. If a trait uses the <code>Self</code> in any of its functions, it becomes special and can no longer be used as a trait object. Every time a struct implements such trait, it is implementing different version of it (a version where <code>Self</code> is different). You can not make a trait object because every struct that implements it is implementing different version of it.</p>\n\n<p>The <code>Ord</code> in rust is like <code>Comparable&lt;T&gt;</code> in java, where <code>T</code> is selected for you by compiler. And just like you can not have a method that accepts anything <code>Comparable</code> in java (I hope you can not?), you can not have a method that accepts any <code>Ord</code> trait object.</p>\n"}], "owner": {"reputation": 23, "user_id": 7249319, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9a67e43a39b817528be50fb9ade33586?s=128&d=identicon&r=PG&f=1", "display_name": "zaari", "link": "https://stackoverflow.com/users/7249319/zaari"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 64, "favorite_count": 1, "accepted_answer_id": 40975454, "answer_count": 1, "score": 1, "last_activity_date": 1480946099, "creation_date": 1480885926, "last_edit_date": 1480893328, "question_id": 40963710, "link": "https://stackoverflow.com/questions/40963710/extended-traits-in-collections", "title": "Extended Traits in Collections", "body": "<p>I have a plain trait <code>Fruit</code> and an extended trait <code>WeightedFruit</code>. The Rust compiler accepts the <code>Fruit</code> trait in a <code>LinkedList</code> but not <code>WeightedFruit</code> in <code>BTreeSet</code>. What should be changed to make the sorted set work?</p>\n\n<pre><code>pub trait Fruit { }\n\npub trait WeightedFruit: Fruit + Ord { }\n\npub fn main() {\n    let unsorted: LinkedList&lt;Box&lt;Fruit&gt;&gt; = LinkedList::new();\n    let sorted: BTreeSet&lt;Box&lt;WeightedFruit&gt;&gt; = BTreeSet::new();\n}\n</code></pre>\n\n<p>The error messages are:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>the trait `WeightedFruit` cannot be made into an object\ntrait `WeightedFruit: std::cmp::Ord` not satisfied\n...\n</code></pre>\n"}, {"tags": ["rust", "match"], "comments": [{"owner": {"reputation": 133611, "user_id": 152602, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7f370b4bd787fc68f9f62d9c6781cb79?s=128&d=identicon&r=PG", "display_name": "Lee", "link": "https://stackoverflow.com/users/152602/lee"}, "edited": false, "score": 3, "creation_date": 1480875685, "post_id": 40961938, "comment_id": 69133138, "body": "Your second example should work"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480893237, "post_id": 40961938, "comment_id": 69139205, "body": "<code>_x =&gt; _x</code> will <i>work</i>, but it isn&#39;t semantically correct. A leading underscore means &quot;this value is unused&quot;, so it isn&#39;t appropriate here."}], "answers": [{"comments": [{"owner": {"reputation": 133611, "user_id": 152602, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7f370b4bd787fc68f9f62d9c6781cb79?s=128&d=identicon&r=PG", "display_name": "Lee", "link": "https://stackoverflow.com/users/152602/lee"}, "edited": false, "score": 0, "creation_date": 1480876007, "post_id": 40962017, "comment_id": 69133249, "body": "<code>x</code> and the unbound value are the same thing so you should just be able to use <code>x =&gt; x</code>?"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 133611, "user_id": 152602, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7f370b4bd787fc68f9f62d9c6781cb79?s=128&d=identicon&r=PG", "display_name": "Lee", "link": "https://stackoverflow.com/users/152602/lee"}, "edited": false, "score": 0, "creation_date": 1480876966, "post_id": 40962017, "comment_id": 69133535, "body": "@Lee Good point. I&#39;ve expanded the answer to show more realistic usage of <code>@</code> pattern."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 17, "last_activity_date": 1614004961, "last_edit_date": 1614004961, "creation_date": 1480875790, "answer_id": 40962017, "question_id": 40961938, "link": "https://stackoverflow.com/questions/40961938/referring-to-matched-value-in-rust/40962017#40962017", "title": "Referring to matched value in Rust", "body": "<p>A match arm that consists of just an identifier will match any value, declare a variable named as the identifier, and move the value to the variable. For example:</p>\n<pre><code>match rand() {\n    0 =&gt; 1,\n    x =&gt; x * 2,\n}\n</code></pre>\n<p>A more general way to create a variable and match it is using the <code>@</code> pattern:</p>\n<pre><code>match rand() {\n    0 =&gt; 1,\n    x @ _ =&gt; x * 2,\n}\n</code></pre>\n<p>In this case it is not necessary, but it can come useful when dealing with conditional matches such as ranges:</p>\n<pre><code>match code {\n    None =&gt; Empty,\n    Some(ascii @ 0 ... 127) =&gt; Ascii(ascii as u8),\n    Some(latin1 @ 160 ... 255) =&gt; Latin1(latin1 as u8),\n    _ =&gt; Invalid\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 1540, "user_id": 2606171, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/F4ncy.png?s=128&g=1", "display_name": "belst", "link": "https://stackoverflow.com/users/2606171/belst"}, "is_accepted": false, "score": 2, "last_activity_date": 1480893252, "last_edit_date": 1480893252, "creation_date": 1480881244, "answer_id": 40962944, "question_id": 40961938, "link": "https://stackoverflow.com/questions/40961938/referring-to-matched-value-in-rust/40962944#40962944", "title": "Referring to matched value in Rust", "body": "<p>You can bind the pattern to a name:</p>\n\n<pre><code>fn non_zero_rand() -&gt; i32 {\n    match rand() {\n        0 =&gt; 1, // 0 is a refutable pattern so it only matches when it fits.\n        x =&gt; x, // the pattern is x here,\n                // which is non refutable, so it matches on everything\n                // which wasn't matched already before\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1963, "favorite_count": 0, "accepted_answer_id": 40962017, "answer_count": 2, "score": 8, "last_activity_date": 1614004961, "creation_date": 1480875374, "question_id": 40961938, "link": "https://stackoverflow.com/questions/40961938/referring-to-matched-value-in-rust", "title": "Referring to matched value in Rust", "body": "<p>Suppose I have this code:</p>\n\n<pre><code>fn non_zero_rand() -&gt; i32 {\n    let x = rand();\n    match x {\n        0 =&gt; 1,\n        _ =&gt; x,\n    }\n}\n</code></pre>\n\n<p>Is there a concise way to put the <code>rand()</code> in the match, and then bind it to a value. E.g. something like this:</p>\n\n<pre><code>fn non_zero_rand() -&gt; i32 {\n    match let x = rand() {\n        0 =&gt; 1,\n        _ =&gt; x,\n    }\n}\n</code></pre>\n\n<p>Or maybe:</p>\n\n<pre><code>fn non_zero_rand() -&gt; i32 {\n    match rand() {\n        0 =&gt; 1,\n        _x =&gt; _x,\n    }\n}\n</code></pre>\n"}, {"tags": ["types", "rust", "unwrap"], "answers": [{"comments": [{"owner": {"reputation": 11374, "user_id": 437679, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/ded1c591320cc2be6aa8109d02a74640?s=128&d=identicon&r=PG", "display_name": "Martin Algesten", "link": "https://stackoverflow.com/users/437679/martin-algesten"}, "edited": false, "score": 0, "creation_date": 1480852765, "post_id": 40958374, "comment_id": 69125956, "body": "Thanks! The second option is what I needed."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 11374, "user_id": 437679, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/ded1c591320cc2be6aa8109d02a74640?s=128&d=identicon&r=PG", "display_name": "Martin Algesten", "link": "https://stackoverflow.com/users/437679/martin-algesten"}, "edited": false, "score": 1, "creation_date": 1480852849, "post_id": 40958374, "comment_id": 69125984, "body": "@MartinAlgesten Yup, I figured it out after taking another look at the question. It&#39;s now presented as the first option. :)"}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 7, "last_activity_date": 1480863686, "last_edit_date": 1480863686, "creation_date": 1480852706, "answer_id": 40958374, "question_id": 40958148, "link": "https://stackoverflow.com/questions/40958148/how-to-unwrap-or-to-string/40958374#40958374", "title": "How to unwrap_or to String", "body": "<p>You misread the first error. The problem is not in the type passed to <code>unwrap_or()</code>, but in the type <em>returned</em> by <code>unwrap_or()</code>. Since you are assigning to a <code>String</code>, the right-hand-side of the assignment must also provide a <code>String</code>. The original error can be fixed simply by adding <code>to_string()</code> after the <code>unwrap_or</code>:</p>\n\n<pre><code>let mut blah: String;\nlet opt: Option&lt;&amp;str&gt; = Some(\"foo\");\nblah = opt.unwrap_or(\"bar\").to_string();\n</code></pre>\n\n<p>It is of course also possible for <code>Option</code> to contain a string, in which case your attempted fix would work just fine:</p>\n\n<pre><code>let mut blah: String;\nlet opt: Option&lt;String&gt; = Some(\"foo\".to_string());\nblah = opt.unwrap_or(\"bar\".to_string());\n</code></pre>\n\n<p>Note that the type annotations are not required in either variable, Rust's type inference is smart enough to figure it out on its own.</p>\n"}], "owner": {"reputation": 11374, "user_id": 437679, "user_type": "registered", "accept_rate": 63, "profile_image": "https://www.gravatar.com/avatar/ded1c591320cc2be6aa8109d02a74640?s=128&d=identicon&r=PG", "display_name": "Martin Algesten", "link": "https://stackoverflow.com/users/437679/martin-algesten"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 821, "favorite_count": 0, "accepted_answer_id": 40958374, "answer_count": 1, "score": 1, "last_activity_date": 1480863686, "creation_date": 1480851147, "last_edit_date": 1480863651, "question_id": 40958148, "link": "https://stackoverflow.com/questions/40958148/how-to-unwrap-or-to-string", "title": "How to unwrap_or to String", "body": "<p>When using <code>unwrap_or</code>, how do I get a <code>String</code>?</p>\n\n<p>I've distilled my problem down to this (with more type annotation than needed): </p>\n\n<pre><code>fn main() {\n    let mut blah: String;\n    let opt: Option&lt;&amp;str&gt; = Some(\"foo\");\n    blah = opt.unwrap_or(\"bar\");\n}\n</code></pre>\n\n<p>This (reasonably) tells me that we need a <code>String</code> not a <code>&amp;str</code>.</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:33:12\n   |\n33 |     blah = opt.unwrap_or(\"bar\");\n   |            ^^^^^^^^^^^^^^^^^^^^ expected struct `std::string::String`, found &amp;str\n   |\n   = note: expected type `std::string::String`\n   = note:    found type `&amp;str`\n</code></pre>\n\n<p>So I try to provide the type wanted.</p>\n\n<pre><code>blah = opt.unwrap_or(\"bar\".to_string());\n</code></pre>\n\n<p>But I get told off:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:33:26\n   |\n33 |     blah = opt.unwrap_or(\"bar\".to_string());\n   |                          ^^^^^^^^^^^^^^^^^ expected &amp;str, found struct `std::string::String`\n   |\n   = note: expected type `&amp;str`\n   = note:    found type `std::string::String`\n\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:33:12\n   |\n33 |     blah = opt.unwrap_or(\"bar\".to_string());\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::string::String`, found &amp;str\n   |\n   = note: expected type `std::string::String`\n   = note:    found type `&amp;str`\n</code></pre>\n"}, {"tags": ["rust", "closures"], "answers": [{"comments": [{"owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "edited": false, "score": 0, "creation_date": 1480843818, "post_id": 40957116, "comment_id": 69123744, "body": "This is super helpful! Thanks."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 5, "last_activity_date": 1480842899, "creation_date": 1480842899, "answer_id": 40957116, "question_id": 40957018, "link": "https://stackoverflow.com/questions/40957018/how-is-an-argument-delivered-across-closure-and-function/40957116#40957116", "title": "How is an argument delivered across closure and function?", "body": "<p>It doesn't.  You may have the wrong mental model for how closures work.</p>\n\n<p>A closure is just a syntactic short-hand for a function with an extra initial argument that captures values from the defining environment.  We can rewrite your example into something which is <em>logically</em> equivalent:</p>\n\n<pre><code>fn factory() -&gt; Box&lt;Closure&gt; {\n    let num = 5;\n\n    Box::new(Closure { num: num })\n}\n\nstruct Closure {\n    num: i32,\n}\n\nimpl Closure {\n    pub fn invoke(&amp;self, x: i32) -&gt; i32 {\n        x + self.num\n    }\n}\n\nfn main() {\n    let f = factory();\n    let answer = f.invoke(1);\n    assert_eq!(6, answer);\n}\n</code></pre>\n\n<p>Note how <code>num</code> gets captured <em>into</em> the \"closure\" at the point the \"closure\" is constructed.  The body of the closure accesses this via <code>self</code> (which is magic'ed away for real closures).</p>\n\n<p>The only differences between <em>this</em> and your original code are that:</p>\n\n<ol>\n<li><p>The <code>Closure</code> type exists, but is <em>anonymous</em>.  That is, you cannot name the type directly, and thus you have to use <code>Fn(i32) -&gt; i32</code> in the return type.</p></li>\n<li><p>Because of the above, we return a boxed concrete type, rather than a boxed trait object.  In terms of how the \"closure\" is used, this doesn't really matter much to us.  The reason we can't return <code>Box&lt;Fn(i32) -&gt; i32&gt;</code> is because...</p></li>\n<li><p>We don't implement <code>Fn</code>.  This cannot be done in stable code yet.  If we <em>could</em>, it would be almost identical to the <code>invoke</code> method.</p></li>\n<li><p>We define the body of the \"closure\" outside of the <code>factory</code> function.  However, this is just a syntactic difference: the body of a closure is no more \"part\" of the execution of your <code>factory</code> than the body of <code>invoke</code> is \"part\" of the execution of <em>this</em> <code>factory</code>.</p></li>\n</ol>\n\n<p>So hopefully you can see that execution does <em>not</em> return to the <code>factory</code> function: it goes into a different function that just happens to be <em>defined</em> within <code>factory</code> for the sake of convenience.</p>\n"}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 53, "favorite_count": 0, "accepted_answer_id": 40957116, "answer_count": 1, "score": 2, "last_activity_date": 1480937444, "creation_date": 1480842033, "last_edit_date": 1480937444, "question_id": 40957018, "link": "https://stackoverflow.com/questions/40957018/how-is-an-argument-delivered-across-closure-and-function", "title": "How is an argument delivered across closure and function?", "body": "<p>I am reading <a href=\"https://doc.rust-lang.org/book/closures.html\" rel=\"nofollow noreferrer\">the closure examples in the Rust book</a>. For the following example code:</p>\n\n<pre><code>fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {\n    let num = 5;\n\n    Box::new(move |x| x + num)\n}\n\nfn main() {\n    let f = factory();\n    let answer = f(1);\n    assert_eq!(6, answer);\n}\n</code></pre>\n\n<p>The factory is a function that takes 0 argument, but when binding <code>factory()</code> to <code>f</code>, why can <code>f(1)</code> deliver an argument of 1 into the factory? </p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480807995, "post_id": 40953585, "comment_id": 69117134, "body": "Why do you have 30 lines of code when 3 will do? <code>fn main() { let _v = Box::new([0i32; 5_000_000]); }</code>."}, {"owner": {"reputation": 1518, "user_id": 332348, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/694d53039b1ff43bdfcd2033c90a1647?s=128&d=identicon&r=PG", "display_name": "echo", "link": "https://stackoverflow.com/users/332348/echo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480808250, "post_id": 40953585, "comment_id": 69117198, "body": "I am learning rust. This is a contrived example."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480808665, "post_id": 40953585, "comment_id": 69117284, "body": "FWIW, I&#39;d <a href=\"http://play.integer32.com/?gist=ac8e61e86bf71ab7c8bb106c1e0af0d1&amp;version=stable\" rel=\"nofollow noreferrer\">write the code like this</a>."}, {"owner": {"reputation": 1518, "user_id": 332348, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/694d53039b1ff43bdfcd2033c90a1647?s=128&d=identicon&r=PG", "display_name": "echo", "link": "https://stackoverflow.com/users/332348/echo"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480809152, "post_id": 40953585, "comment_id": 69117382, "body": "Vec is the way to go. What if I want to create a large array in heap? Is it possible in rust?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480809799, "post_id": 40953585, "comment_id": 69117507, "body": "No, not right now. I added another answer to the duplicate for future Rust. However, a <code>Vec</code> is going to be basically the same in 99.99% of the cases, so it&#39;s highly recommended to use it."}], "owner": {"reputation": 1518, "user_id": 332348, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/694d53039b1ff43bdfcd2033c90a1647?s=128&d=identicon&r=PG", "display_name": "echo", "link": "https://stackoverflow.com/users/332348/echo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 634, "favorite_count": 0, "closed_date": 1480808099, "answer_count": 0, "score": 0, "last_activity_date": 1480808050, "creation_date": 1480807017, "last_edit_date": 1480808050, "question_id": 40953585, "link": "https://stackoverflow.com/questions/40953585/how-to-create-a-very-large-array", "closed_reason": "Duplicate", "title": "How to create a very large array?", "body": "<p>I know arrays are in the stack by default, so I'm boxing it, but I still get a segfault if the size of it is too big. </p>\n\n<p>How can I fix the problem and why will my program segfault if the size of the array is 5 million?</p>\n\n<pre><code>extern crate rand;                                                                                                                                                                                                  \nuse rand::Rng;\n\nfn main() {\n    const SIZE: usize = 500000; // segfaut if SIZE is 5 million\n    let mut v: Box&lt;[i32; SIZE]&gt; = Box::new([0; SIZE]);\n    let mut i = 0;\n    while i &lt; SIZE {\n        let mut rng = rand::thread_rng();\n        if rng.gen() {\n            v[i] = 1;\n        }\n        i = i + 1;\n    }   \n    i = 0;\n    let mut sum = 0;\n    while i &lt; SIZE {\n        sum = sum + v[i];\n        i = i + 1;\n    }   \n    println!(\"Total number is {}\", SIZE);\n    println!(\"number of 1 is {}\", sum);\n}\n</code></pre>\n"}, {"tags": ["rust", "ownership", "clap"], "answers": [{"comments": [{"owner": {"reputation": 592, "user_id": 1443418, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/FkskD.png?s=128&g=1", "display_name": "Jiehong", "link": "https://stackoverflow.com/users/1443418/jiehong"}, "edited": false, "score": 0, "creation_date": 1480794080, "post_id": 40951660, "comment_id": 69113146, "body": "Thanks for shedding light on my big misunderstanding here! It&#39;s just a strange feeling on some point Rust, at first\u2026"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 592, "user_id": 1443418, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/FkskD.png?s=128&g=1", "display_name": "Jiehong", "link": "https://stackoverflow.com/users/1443418/jiehong"}, "edited": false, "score": 0, "creation_date": 1480794280, "post_id": 40951660, "comment_id": 69113213, "body": "@Jiehong yeah, there&#39;s definitely a learning curve, but pretty much everything has a good reason for existing. In this case, I wish I could explain exactly why this library is designed like this. The best I can provide is that <code>clap::App</code> documentation refers to itself as a builder. Generally, once you have built something, the builder is consumed in the process."}, {"owner": {"reputation": 28407, "user_id": 109618, "user_type": "registered", "accept_rate": 84, "profile_image": "https://www.gravatar.com/avatar/84a4143803eafa1966191c604864a7b5?s=128&d=identicon&r=PG", "display_name": "David J.", "link": "https://stackoverflow.com/users/109618/david-j"}, "reply_to_user": {"reputation": 592, "user_id": 1443418, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/FkskD.png?s=128&g=1", "display_name": "Jiehong", "link": "https://stackoverflow.com/users/1443418/jiehong"}, "edited": false, "score": 0, "creation_date": 1482695908, "post_id": 40951660, "comment_id": 69851831, "body": "@Shepmaster nicely explained. May I add this: many command line tools show full help on a &#39;bare&#39; command invocation, including <code>java</code> and <code>cloc</code>. So I see it as reasonable for @Jiehong to want clap to provide a full help message. I have not yet found a simple way to provide this behavior with clap."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 28407, "user_id": 109618, "user_type": "registered", "accept_rate": 84, "profile_image": "https://www.gravatar.com/avatar/84a4143803eafa1966191c604864a7b5?s=128&d=identicon&r=PG", "display_name": "David J.", "link": "https://stackoverflow.com/users/109618/david-j"}, "edited": false, "score": 0, "creation_date": 1482696058, "post_id": 40951660, "comment_id": 69851863, "body": "@DavidJames certainly, although that sounds like a case for a feature request for clap itself. My point is mostly that clap has chosen to be opinionated in design, hopefully for a good reason. Going with the flow will make using a library easier. ^_^"}, {"owner": {"reputation": 28407, "user_id": 109618, "user_type": "registered", "accept_rate": 84, "profile_image": "https://www.gravatar.com/avatar/84a4143803eafa1966191c604864a7b5?s=128&d=identicon&r=PG", "display_name": "David J.", "link": "https://stackoverflow.com/users/109618/david-j"}, "edited": false, "score": 1, "creation_date": 1482696521, "post_id": 40951660, "comment_id": 69851965, "body": "Re: &quot;presumably the author has good rationale for this&quot; ... I asked directly on the Clap issue tracker: <a href=\"https://github.com/kbknapp/clap-rs/issues/785\" rel=\"nofollow noreferrer\">github.com/kbknapp/clap-rs/issues/785</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1521081129, "last_edit_date": 1521081129, "creation_date": 1480793437, "answer_id": 40951660, "question_id": 40951538, "link": "https://stackoverflow.com/questions/40951538/method-call-on-clapapp-moving-ownership-more-than-once/40951660#40951660", "title": "Method call on clap::App moving ownership more than once", "body": "<p>Read the <a href=\"https://docs.rs/clap/2.19.1/clap/struct.App.html#method.get_matches\" rel=\"nofollow noreferrer\">function signature for <code>App::get_matches</code></a>:</p>\n\n<pre><code>fn get_matches(self) -&gt; ArgMatches&lt;'a&gt;\n</code></pre>\n\n<p>This takes <code>self</code> by value, also said as it <em>consumes</em> the value; you <em>cannot</em> call any methods on it afterwards. There's nothing to be done about this; presumably the author has good rationale for this.</p>\n\n<p>Now review <a href=\"https://docs.rs/clap/2.19.1/clap/struct.App.html#method.print_help\" rel=\"nofollow noreferrer\"><code>App::print_help</code></a>:</p>\n\n<pre><code>fn print_help(&amp;mut self) -&gt; ClapResult&lt;()&gt;\n</code></pre>\n\n<p>It takes a reference (which happens to be mutable). You do not have to transfer ownership to call this method.</p>\n\n<hr>\n\n<blockquote>\n  <p>If I understand correctly, <code>app.get_matches()</code> asks to borrow the ownership, thus app must be <code>mut</code>. Where does the ownership go once the function returns?</p>\n</blockquote>\n\n<p>You do not understand correctly, in multiple dimensions.</p>\n\n<ol>\n<li><code>get_matches</code> consumes the value, it does not borrow anything.</li>\n<li>A value does not need to be mutable to be borrowed.</li>\n<li>When you do borrow something, the ownership doesn't \"go\" anywhere. The original owner continues to own it. That's why it's called <em>borrowing</em>.</li>\n</ol>\n\n<blockquote>\n  <p>How can I get the matches, and effectively still call another method, such as <code>print_help</code> on app then?</p>\n</blockquote>\n\n<p>You don't. The obvious workaround is to clone the original object, producing a second value. Then you can consume one value and still call methods on the second value.</p>\n\n<hr>\n\n<p>Basically, it sounds like you are trying to do something that the library is discouraging you from doing. Perhaps you should re-evaluate your goals and/or review the intended usage of the library. For example, <code>get_matches</code> will automatically display the help text when the user requests it, so why should your code try to do so?</p>\n\n<p>From the <a href=\"https://github.com/kbknapp/clap-rs/issues/785\" rel=\"nofollow noreferrer\">Clap issue tracker</a>:</p>\n\n<blockquote>\n  <p>You have a few options. You can either use <a href=\"https://docs.rs/clap/2.19.2/clap/enum.AppSettings.html#variant.ArgRequiredElseHelp\" rel=\"nofollow noreferrer\"><code>AppSettings::ArgRequiredElseHelp</code></a> or you can keep the move from happening by using <a href=\"https://docs.rs/clap/2.19.2/clap/struct.App.html#method.get_matches_from_safe_borrow\" rel=\"nofollow noreferrer\"><code>App::get_matches_from_safe_borrow</code></a>.</p>\n</blockquote>\n"}], "owner": {"reputation": 592, "user_id": 1443418, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/FkskD.png?s=128&g=1", "display_name": "Jiehong", "link": "https://stackoverflow.com/users/1443418/jiehong"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 876, "favorite_count": 0, "accepted_answer_id": 40951660, "answer_count": 1, "score": 3, "last_activity_date": 1524413823, "creation_date": 1480792706, "last_edit_date": 1524413823, "question_id": 40951538, "link": "https://stackoverflow.com/questions/40951538/method-call-on-clapapp-moving-ownership-more-than-once", "title": "Method call on clap::App moving ownership more than once", "body": "<p>Even after reading the chapters about reference ownership and borrowing, I  cannot understand some things in the following code, effectively stopping me from calling more than one method from <code>clap::App</code>!</p>\n\n<pre><code>extern crate clap;\n\nuse clap::App;\n\nfn main() {\n    let mut app =\n        App::new(\"name me\").args_from_usage(\"&lt;input_file&gt;          'Sets the input file to use'\");\n    let matches = app.get_matches();\n    app.print_help();\n    println!(\n        \"Using input file: {}\",\n        matches.value_of(\"input_file\").unwrap()\n    );\n}\n</code></pre>\n\n<p>Compiling this code leads to:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of moved value: `app`\n --&gt; src/main.rs:9:5\n  |\n8 |     let matches = app.get_matches();\n  |                   --- value moved here\n9 |     app.print_help();\n  |     ^^^ value used here after move\n  |\n  = note: move occurs because `app` has type `clap::App&lt;'_, '_&gt;`, which does not implement the `Copy` trait\n</code></pre>\n\n<ol>\n<li>If I understand correctly, <code>app.get_matches()</code> asks to borrow the ownership, thus <code>app</code> must be <code>mut</code>. Where does the ownership go once the function returns?</li>\n<li>I thought <code>app</code> would still have ownership of the object, yet the compiler has a different opinion.</li>\n</ol>\n\n<p>How can I get the matches, and effectively still call another method, such as <code>print_help</code> on <code>app</code> then?</p>\n"}, {"tags": ["rust", "traits"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480792595, "post_id": 40945264, "comment_id": 69112650, "body": "Your question is not very clear. Why not just implement <code>B</code> at the same time you are expanding the macro that creates the trait <code>A</code>?"}, {"owner": {"reputation": 3861, "user_id": 590967, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/88ccc433efa17e12844762353ce93b8c?s=128&d=identicon&r=PG", "display_name": "Shisoft", "link": "https://stackoverflow.com/users/590967/shisoft"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480806548, "post_id": 40945264, "comment_id": 69116775, "body": "@Shepmaster because there will be more traits like A generated by the macro the server need a common trait to invoke dispatch"}], "answers": [{"comments": [{"owner": {"reputation": 3861, "user_id": 590967, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/88ccc433efa17e12844762353ce93b8c?s=128&d=identicon&r=PG", "display_name": "Shisoft", "link": "https://stackoverflow.com/users/590967/shisoft"}, "edited": false, "score": 0, "creation_date": 1480792089, "post_id": 40945952, "comment_id": 69112502, "body": "Thank you for your kind answer. But what if there is another function in <code>B</code> like <code>foo</code> I have update in the question which it should be implement by developers for <code>S</code>?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 3861, "user_id": 590967, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/88ccc433efa17e12844762353ce93b8c?s=128&d=identicon&r=PG", "display_name": "Shisoft", "link": "https://stackoverflow.com/users/590967/shisoft"}, "edited": false, "score": 0, "creation_date": 1480793828, "post_id": 40945952, "comment_id": 69113060, "body": "Add <code>foo</code> to <code>A</code> for the developer to implement, and have the generated <code>B</code> impl call that?"}, {"owner": {"reputation": 3861, "user_id": 590967, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/88ccc433efa17e12844762353ce93b8c?s=128&d=identicon&r=PG", "display_name": "Shisoft", "link": "https://stackoverflow.com/users/590967/shisoft"}, "edited": false, "score": 0, "creation_date": 1480806679, "post_id": 40945952, "comment_id": 69116809, "body": "In this case the server that looking for <code>B</code> can&#39;t see it"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 3861, "user_id": 590967, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/88ccc433efa17e12844762353ce93b8c?s=128&d=identicon&r=PG", "display_name": "Shisoft", "link": "https://stackoverflow.com/users/590967/shisoft"}, "edited": false, "score": 0, "creation_date": 1480810891, "post_id": 40945952, "comment_id": 69117786, "body": "I think that these should be a new question rather than changes to the original one."}, {"owner": {"reputation": 3861, "user_id": 590967, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/88ccc433efa17e12844762353ce93b8c?s=128&d=identicon&r=PG", "display_name": "Shisoft", "link": "https://stackoverflow.com/users/590967/shisoft"}, "edited": false, "score": 0, "creation_date": 1480819731, "post_id": 40945952, "comment_id": 69119288, "body": "I am sorry for this. I will close this question and open a new one"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 6, "last_activity_date": 1480792210, "last_edit_date": 1480792210, "creation_date": 1480755070, "answer_id": 40945952, "question_id": 40945264, "link": "https://stackoverflow.com/questions/40945264/any-alternative-way-for-trait-to-implement-its-parent-trait/40945952#40945952", "title": "Any alternative way for trait to implement its parent trait?", "body": "<p>You don't need <code>B</code> to be a supertrait of <code>A</code> at all.  You can instead add a blanket implementation of <code>B</code> for any <code>T: A</code>.  I think this closer to the intent.</p>\n\n<p>Paraphrasing the Rust code:</p>\n\n<pre><code>trait A: B {\n</code></pre>\n\n<p>\"You can implement <code>A</code>, but only if you've implemented <code>B</code>.\"</p>\n\n<pre><code>trait A {\n    //...\n}\nimpl&lt;T: A&gt; B for T {\n</code></pre>\n\n<p>\"If you implement <code>A</code>, here's a free implementation of <code>B</code>.\"</p>\n\n<p>Here's the full version:</p>\n\n<pre><code>trait B {\n    fn dispatch(&amp;mut self, fn_id: u64) -&gt; Vec&lt;u8&gt;;\n}\n\n// macro generated trait\ntrait A {\n    fn a(&amp;self) -&gt; Vec&lt;u8&gt;;  // added &amp;self\n    fn b(&amp;self) -&gt; Vec&lt;u8&gt;;\n}\n\nimpl&lt;T: A&gt; B for T {\n    fn dispatch(&amp;mut self, fn_id: u64) -&gt; Vec&lt;u8&gt; {\n        match fn_id {\n            1 =&gt; self.a(),\n            2 =&gt; self.b(),\n            _ =&gt; panic!(),   // Needed so that match cases are exhaustive\n        }\n    }\n}\n\nstruct S {}\n\nimpl A for S {\n    fn a(&amp;self) -&gt; Vec&lt;u8&gt; {\n        unimplemented!()\n    }\n    fn b(&amp;self) -&gt; Vec&lt;u8&gt; {\n        unimplemented!()\n    }\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=8645ebbbb4e2bc90ba1c0ea267244a03&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}], "owner": {"reputation": 3861, "user_id": 590967, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/88ccc433efa17e12844762353ce93b8c?s=128&d=identicon&r=PG", "display_name": "Shisoft", "link": "https://stackoverflow.com/users/590967/shisoft"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 341, "favorite_count": 0, "accepted_answer_id": 40945952, "answer_count": 1, "score": 0, "last_activity_date": 1481106978, "creation_date": 1480749288, "last_edit_date": 1481106978, "question_id": 40945264, "link": "https://stackoverflow.com/questions/40945264/any-alternative-way-for-trait-to-implement-its-parent-trait", "title": "Any alternative way for trait to implement its parent trait?", "body": "<p>I am building a Raft consensus algorithm middleware for Rust with a similar architecture to <a href=\"http://atomix.io/copycat/\" rel=\"nofollow noreferrer\">copycat</a>. I wrote a macro for developers to define a scheme for commands. The macro generates a trait <code>A</code> with a <code>dispatch</code> function for user defined commands, which requires the developer to implement a struct for its behavior and an encoder/decoder which is irrelevant to this topic.</p>\n\n<p>The trait objects register with a <code>Server</code> object to make it work. Because trait <code>A</code> is dynamically generated, I have to define another trait <code>B</code> as parent trait for <code>A</code>. <code>Server</code> works with <code>B</code> to invoke the <code>dispatch</code> function defined in <code>A</code>.</p>\n\n<p>I tried different combination but none of them works.</p>\n\n<pre><code>trait B {\n    fn dispatch(&amp;mut self, fn_id: u64) -&gt; Vec&lt;u8&gt;;\n}\n\n// macro generated trait\ntrait A: B {\n    fn a(&amp;self) -&gt; Vec&lt;u8&gt;;\n    fn b(&amp;self) -&gt; Vec&lt;u8&gt;;\n    fn dispatch(&amp;mut self, fn_id: u64) -&gt; Vec&lt;u8&gt; {\n        match fn_id {\n            1 =&gt; a(),\n            2 =&gt; b(),\n            _ =&gt; {}\n        }\n    }\n}\n</code></pre>\n\n<p>Unfortunately, the <code>dispatch</code> function in <code>A</code> will not implement <code>dispatch</code> in <code>B</code>. When I implement the structure for <code>A</code>, the compiler still asked to implement <code>dispatch</code> for <code>B</code>. </p>\n\n<p>I also tried to move <code>dispatch</code> in trait <code>B</code> to another trait as the parent trait for <code>B</code>, but the trait cannot implement for <code>A</code>.</p>\n\n<p>I have also reviewed <a href=\"https://github.com/rust-lang/rfcs/issues/1024\" rel=\"nofollow noreferrer\">https://github.com/rust-lang/rfcs/issues/1024</a>. It seems the issue is open but have been ditched. Is there any alternative way to make this pattern work?</p>\n"}, {"tags": ["plugins", "rust", "ffi", "lv2"], "comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1480760544, "post_id": 40944524, "comment_id": 69103624, "body": "This question would be much clearer if it concentrated on <i>one</i> use case and e.g. described a simple example of interfacing C and Rust possible to follow without specialized knowledge. It should probably also be split - one question is about references vs. pointers in <code>AmpNew</code>, and another about exposing Rust&#39;s generic functions to C."}, {"owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480762264, "post_id": 40944524, "comment_id": 69104087, "body": "I&#39;m providing a specific use case in the example. Isn&#39;t the plugin as simple as it gets? The floats in the host-provided input buffer are multiplied by a constant. I agree that there are multiple questions, hence one is marked as the &quot;main question&quot;."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1480764606, "post_id": 40944524, "comment_id": 69104679, "body": "I meant a use case that doesn&#39;t require external code and concepts to understand. For example, &quot;take a C function with the following signature and the following ownership semantics; how would one go about wrapping it in Rust?&quot;"}, {"owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480766625, "post_id": 40944524, "comment_id": 69105192, "body": "OK fair enough I&#39;ll simplify it tomorrow. The drawback is it won&#39;t be complete any more. My previous questions all got edited by rust gurus anyways, let&#39;s see tomorrow."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1480768334, "post_id": 40944524, "comment_id": 69105578, "body": "Maybe it can be made complete (and self-contained) by providing the sample (and trivial) implementation of the C part? Ideally the question would include an <a href=\"http://sscce.org/\" rel=\"nofollow noreferrer\">SSCCE</a>, but that&#39;s not always feasible in practice."}, {"owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480773063, "post_id": 40944524, "comment_id": 69106803, "body": "OK I&#39;ll try to write SSCCE, what I meant by &quot;complete&quot; was &quot;real life&quot;, i.e. a true LV2 plugin. But yeah I get it, for most people here that&#39;s little value if they&#39;re not into audio. I just thought, given it&#39;s so simple, I could get away with it."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480773549, "post_id": 40944524, "comment_id": 69106946, "body": "Good point, but you can still include a github (or pastebin etc.) link for those who prefer to see the real-world use case."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1480781244, "post_id": 40944524, "comment_id": 69109165, "body": "Also, that GitHub user <b>might be wrong or incomplete</b>. There should be a <code>lv2-sys</code> (or something reasonable) that creates a <a href=\"http://doc.crates.io/build-script.html#-sys-packages\" rel=\"nofollow noreferrer\">*-sys package</a>. That crate <b>only</b> exposes the raw C API. Then, it&#39;s up to <i>other</i> crates (potentially more than one!) to expose an idiomatic Rust API. Maybe your crate should really just be the *-sys package."}, {"owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "edited": false, "score": 0, "creation_date": 1480817549, "post_id": 40944524, "comment_id": 69118970, "body": "Interesting, I did not know about *-sys packages. I think that was the hint I was looking for. So one packs all the close-to-C-like stuff in there, and provides a separate more high-level (&quot;opinionated&quot;) package building on that? Sounds good."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480828478, "post_id": 40944524, "comment_id": 69120871, "body": "All that opinionated and idiomatic API is closer to what @user4815162342 was getting at. If you phrase your question in terms of what the ownership and lifetimes of the underlying C code are, then we will be able to provide useful guidance on how to make a better API on top of it."}, {"owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "edited": false, "score": 0, "creation_date": 1480844295, "post_id": 40944524, "comment_id": 69123837, "body": "Good idea, I&#39;ll do that but first I think I&#39;ll improve the low level API. That will be more useful for people who know how to design the high level API."}], "owner": {"reputation": 373, "user_id": 5101356, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/afc758f07608f93dfb31bbde7d87b5a6?s=128&d=identicon&r=PG&f=1", "display_name": "poidl", "link": "https://stackoverflow.com/users/5101356/poidl"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 317, "favorite_count": 0, "answer_count": 0, "score": 0, "last_activity_date": 1480823252, "creation_date": 1480742435, "last_edit_date": 1480823252, "question_id": 40944524, "link": "https://stackoverflow.com/questions/40944524/how-does-one-design-a-plugin-interface-for-digital-audio-workstation-hosts-in-pu", "title": "How does one design a plugin interface for digital-audio-workstation hosts in pure Rust?", "body": "<p>I'm a beginner writing an LV2 audio plugin in Rust, and as a \"side effect\" I wrote an <a href=\"https://github.com/poidl/lv2\" rel=\"nofollow noreferrer\">LV2 interface in Rust</a>. A GitHub user noted that</p>\n\n<blockquote>\n  <p>this is a raw C API that you can only use in unsafe. A good library needs a rustic api with traits and types.</p>\n</blockquote>\n\n<p>and I have questions on how to do that. </p>\n\n<p><strong>EDIT</strong> The question was addressed by Shepmaster's comment below. Although the comment doesn't answer the question directly, it makes the question much less relevant to me at the moment. I wrongly assumed that <em>all</em> Rust libraries should provide an idiomatic Rust interface.</p>\n\n<p>Consider a very simple <a href=\"http://lv2plug.in/book/#_amp_c\" rel=\"nofollow noreferrer\">amplifier plugin in C</a>, which I translated to Rust like so:</p>\n\n<pre><code>extern crate libc;\nextern crate lv2;\nuse std::ptr;\n\n// This is a simple \"amplifier\" plugin. It holds references to input and output\n// buffers, and a reference to a single number (gain) by which the input buffer\n// is multiplied. Memory managemet of these resources is done by the host.\n\npub struct AmpNew&lt;'a&gt; {\n    gain: &amp;'a f32,\n    input: &amp;'a [f32],\n    output: &amp;'a mut [f32],\n}\n\n// The main question is: Should one use raw pointers instead of references in this\n// struct?\n\n// I'd say NO, because:\n\n// I want to implement \"lv2::LV2HandleNew\"\n// without having to use \"unsafe\", i.e. to \"provide a safe interface\" to the\n// lv2 library. What is the correct (let's say idiomatic) way to \"provide a safe\n// interface\"?\n\n// I'd say YES, because:\n\n// *) AFAIK it's impossible to implement a constructor \"::new()\" function for this\n// struct, since the resources go out of scope when \"new()\" terminates. Instead, the\n// plugin is instantiated by the lv2::instantiate::&lt;&gt;() function using\n// libc::malloc(), similar to the code I commented at the bottom of this page.\n// It seems weired to not being able to allocate the plugin from safe code.\n// How would one design a plugin interface in pure Rust (i.e.\n// with a host written in Rust)?\n\n// *) There are potential problems arising with unkown buffer sizes. The function\n// connect_port() below takes an \"&amp;'a mut [f32]\", which is constructed in the\n// calling function (containing unsafe code) by \"slice::from_raw_parts_mut()\",\n// which needs a buffer size as argument. This size is not passed by host to\n// the extern \"C\" connect_port(). Instead,\n// the host passes the \"n_samples\" argument to the real-time \"run()\" function to\n// indicate which part of the buffer it wants to have processed by the plugin.\n// This may not be an issue, since one can pass a really high buffer size\n// to \"slice::from_raw_parts_mut()\" without having to worry about perfomance/space,\n// since no resources are actually allocated anyways, right?\n\nimpl&lt;'a&gt; lv2::LV2HandleNew&lt;'a&gt; for AmpNew&lt;'a&gt; {\n    // For now, initialize() is a placeholder function that doesn't do anything. More complicated plugins may scan host features, set a sample rate, etc.\n    fn initialize(&amp;mut self) {}\n    fn connect_port(&amp;mut self, port: u32, data: &amp;'a mut [f32]) {\n        match port {\n            0 =&gt; self.gain = &amp;data[0] as &amp;f32, // data may be NULL pointer, so don't dereference!\n            1 =&gt; self.input = data as &amp;'a [f32],\n            2 =&gt; self.output = data,\n            _ =&gt; panic!(\"Not a valid PortIndex: {}\", port),\n        }\n    }\n    fn activate(&amp;mut self) {}\n    fn run(&amp;mut self, n_samples: u32) {\n\n        let coef: f32;\n        match *self.gain &gt; -90.0 {\n            true =&gt; coef = (10.0 as f32).powf(self.gain * 0.05),\n            false =&gt; coef = 0.0,\n        }\n        for x in 0..n_samples {\n            let i = x as usize;\n            self.output[i] = self.input[i] * coef;\n        }\n\n    }\n    fn deactivate(&amp;mut self) {}\n    fn cleanup(&amp;mut self) {}\n}\n\ntype Newtype&lt;'a&gt; = AmpNew&lt;'a&gt;;\n\n// If I understand correctly, the lv2::LV2Descriptor struct that is delivered\n// to the host by \"lv2_descriptor()\" CANNOT be generic over \"Newtype\", since this\n// would require \"lv2_descriptor()\" to be generic. But functions called from C\n// (by their name) CANNOT be generic.\n// The reason why \"lv2::instantiate::&lt;&gt;\" etc. CAN be generic, is that those functions\n// get passed to C via FUNCTION POINTERS contained in a #[repr(C)] struct.\n// A secondary question is: Is this necessary? How to implement this more\n// effectively?\n\nstatic S: &amp;'static [u8] = b\"http://example.org/eg-amp_rust\\0\";\nstatic mut desc: lv2::LV2Descriptor = lv2::LV2Descriptor {\n    uri: 0 as *const libc::c_char, // ptr::null() isn't const fn (yet)\n    instantiate: lv2::instantiate::&lt;Newtype&gt;,\n    connect_port: lv2::connect_port::&lt;Newtype&gt;,\n    activate: lv2::activate,\n    run: lv2::run::&lt;Newtype&gt;,\n    deactivate: lv2::deactivate,\n    cleanup: lv2::cleanup,\n    extension_data: lv2::extension_data,\n};\n\n\n#[no_mangle]\npub extern \"C\" fn lv2_descriptor(index: i32) -&gt; *const lv2::LV2Descriptor {\n    if index != 0 {\n        return ptr::null();\n    } else {\n        // credits to ker on stackoverflow: http://stackoverflow.com/questions/31334356/static-struct-with-c-strings-for-lv2-plugin (duplicate) or http://stackoverflow.com/questions/25880043/creating-a-static-c-struct-containing-strings\n        let ptr = S.as_ptr() as *const libc::c_char;\n        unsafe {\n            desc.uri = ptr;\n            return &amp;desc as *const lv2::LV2Descriptor;\n        }\n    }\n}\n\n// fn instantiate&lt;T&gt;() -&gt; *mut libc::c_void {\n//     let ptr: *mut libc::c_void;\n//     unsafe {\n//         ptr = libc::malloc(mem::size_of::&lt;T&gt;() as libc::size_t) as *mut libc::c_void;\n//         let plgptr = ptr as *mut T;\n//     }\n//     ptr\n// }\n\n// impl&lt;'a&gt; AmpNew&lt;'a&gt; {\n//     fn new_ptr() -&gt; *mut libc::c_void {\n//         instantiate::&lt;AmpNew&gt;()\n//     }\n// }\n</code></pre>\n\n<p>Specific questions are contained in the code. The code uses functions and types <a href=\"https://github.com/poidl/lv2/blob/master/src/core.rs\" rel=\"nofollow noreferrer\">defined here</a>.</p>\n"}, {"tags": ["recursion", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480777280, "post_id": 40944473, "comment_id": 69108001, "body": "You should upgrade your version of Rust to get the improved error messages. I&#39;ve edited this question with them as they are also easier to read."}], "answers": [{"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 3, "last_activity_date": 1480753755, "creation_date": 1480753755, "answer_id": 40945796, "question_id": 40944473, "link": "https://stackoverflow.com/questions/40944473/recursive-inorder-traversal-of-a-binary-search-tree/40945796#40945796", "title": "Recursive inorder traversal of a binary search tree", "body": "<p>The problem is that there's confusion about where the options are:</p>\n\n<pre><code>impl&lt;T: Ord&gt; Node&lt;T&gt; {\n    pub fn inorder(&amp;self) -&gt; Vec&lt;&amp;T&gt; {\n    //...\n    match *self {\n</code></pre>\n\n<p>Here, <code>self</code> is a <code>Node&lt;T&gt;</code>, not an option.  Instead, <code>self.left</code> and <code>self.right</code> are options.</p>\n\n<p>This compiles (until lack of <code>main()</code>):</p>\n\n<pre><code>pub fn inorder(&amp;self) -&gt; Vec&lt;&amp;T&gt; {\n\n    let mut result: Vec&lt;&amp;T&gt; = Vec::new();\n\n    if let Some(ref left) = self.left {\n        let left_vec = left.inorder();\n        result.extend(left_vec);\n    }\n    result.push(&amp;self.value);\n    if let Some(ref right) = self.right {\n        let right_vec = right.inorder();\n        result.extend(right_vec);\n    }\n    result\n}\n</code></pre>\n\n<p>I also added the return, and fixed <code>result.extend(self.value)</code> to instead <code>push</code> a reference.</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=76f0b92a07e0ed0765022f154644780d&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 4, "last_activity_date": 1480777957, "last_edit_date": 1495541628, "creation_date": 1480777957, "answer_id": 40949231, "question_id": 40944473, "link": "https://stackoverflow.com/questions/40944473/recursive-inorder-traversal-of-a-binary-search-tree/40949231#40949231", "title": "Recursive inorder traversal of a binary search tree", "body": "<p><a href=\"https://stackoverflow.com/a/40945796/155423\">Chris Emerson's answer</a> is correct, but I'd advocate for a more memory efficient version that always appends to the same vector. This prevents excessive copying of the values.</p>\n\n<pre><code>impl&lt;T&gt; Tree&lt;T&gt; {\n    pub fn inorder(&amp;self) -&gt; Vec&lt;&amp;T&gt; {\n        let mut nodes = Vec::new();\n        if let Some(ref root) = self.root {\n            root.inorder(&amp;mut nodes);\n        }\n        nodes\n    }\n}\n\nimpl&lt;T: Ord&gt; Node&lt;T&gt; {\n    pub fn inorder&lt;'a&gt;(&amp;'a self, result: &amp;mut Vec&lt;&amp;'a T&gt;) {\n        if let Some(ref left) = self.left {\n            left.inorder(result);\n        }\n        result.push(&amp;self.value);\n        if let Some(ref right) = self.right {\n            right.inorder(result);\n        }\n    }\n}\n</code></pre>\n\n<p>Note that I've removed the <code>: Ord</code> restriction as it's not needed for traversal.</p>\n\n<p>Even better would be to create an iterator that traverses inorder, then you could just call <code>collect</code>.</p>\n"}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1145, "favorite_count": 0, "accepted_answer_id": 40945796, "answer_count": 2, "score": 2, "last_activity_date": 1480777957, "creation_date": 1480741969, "last_edit_date": 1480777227, "question_id": 40944473, "link": "https://stackoverflow.com/questions/40944473/recursive-inorder-traversal-of-a-binary-search-tree", "title": "Recursive inorder traversal of a binary search tree", "body": "<p>I want to implement a recursive inorder in a binary search tree (BST). I built a tree using two structs: <code>Node</code> and <code>Tree</code>. My code has not worked so far, mainly because of a type mismatch in <code>Node::inorder</code>. </p>\n\n<pre><code>pub struct Node&lt;T&gt; {\n    value: T,\n    left: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n    right: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\n\npub struct Tree&lt;T&gt; {\n    root: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\n\nimpl&lt;T: Ord&gt; Tree&lt;T&gt; {\n    /// Creates an empty tree\n    pub fn new() -&gt; Self {\n        Tree { root: None }\n    }\n\n    pub fn inorder(&amp;self) -&gt; Vec&lt;&amp;T&gt; {\n        self.root.as_ref().map(|n| n.inorder()).unwrap() // how to pass result ?\n    }\n}\n\nimpl&lt;T: Ord&gt; Node&lt;T&gt; {\n    pub fn inorder(&amp;self) -&gt; Vec&lt;&amp;T&gt; {\n        let mut result: Vec&lt;&amp;T&gt; = Vec::new();\n\n        match *self {\n            None =&gt; return result,\n\n            Some(ref node) =&gt; {\n                let left_vec = node.left.inorder();\n                result.extend(left_vec);\n                result.extend(node.value);\n                let right_vec = node.right.inorder();\n                result.extend(right_vec);\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>This is the error report:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:27:13\n   |\n27 |             None =&gt; return result,\n   |             ^^^^ expected struct `Node`, found enum `std::option::Option`\n   |\n   = note: expected type `Node&lt;T&gt;`\n   = note:    found type `std::option::Option&lt;_&gt;`\n\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:29:13\n   |\n29 |             Some(ref node) =&gt; {\n   |             ^^^^^^^^^^^^^^ expected struct `Node`, found enum `std::option::Option`\n   |\n   = note: expected type `Node&lt;T&gt;`\n   = note:    found type `std::option::Option&lt;_&gt;`\n</code></pre>\n\n<p>In <code>Node::inorder</code>, I want to return a empty vector if a node does not exist; if the node does exist, I want to grow the vector inorder and recur. \nThe <code>match</code> doesn't work between a <code>Node</code> and <code>Option</code>, but I am not sure how to bridge between them.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1480728925, "post_id": 40943296, "comment_id": 69097957, "body": "<i>and disable smart pointer optimizations</i> \u2014 what &quot;optimizations&quot; do you think <code>&amp;self</code> or <code>&amp;mut self</code> perform? Also, <code>&amp;self</code> and <code>&amp;mut self</code> are not &quot;smart pointers&quot;. I could see <code>Box&lt;Self&gt;</code> being called a smart pointer, <a href=\"http://stackoverflow.com/q/25462935/155423\">but not many people know you can use that as <code>self</code></a>."}, {"owner": {"reputation": 53, "user_id": 6525953, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca9758970f874c9d6773b755bb130df8?s=128&d=identicon&r=PG&f=1", "display_name": "ttarikbnr", "link": "https://stackoverflow.com/users/6525953/ttarikbnr"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480729372, "post_id": 40943296, "comment_id": 69098020, "body": "As fas as i understand references generate noalias flag and this flag cause some optimizations."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1480926004, "post_id": 40943296, "comment_id": 69148685, "body": "only <code>&amp;mut</code> references generate <code>noalias</code> (and afaik even that has been turned off until further notice due to llvm bugs). Could you please share your use case (a code example that shows why <code>&amp;self</code> doesn&#39;t work)"}, {"owner": {"reputation": 53, "user_id": 6525953, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca9758970f874c9d6773b755bb130df8?s=128&d=identicon&r=PG&f=1", "display_name": "ttarikbnr", "link": "https://stackoverflow.com/users/6525953/ttarikbnr"}, "edited": false, "score": 0, "creation_date": 1481152612, "post_id": 40943296, "comment_id": 69265706, "body": "Only &amp;T references generate noalias atm. I asked a question if &amp;mut T generate  noalias in the future on www.reddit.com/r/rust. And they said that after some llvm  bugs get fixed it will generate noalias too. I wanna write some unsafe methods and because its unsafe i wanna turn reference optimizations(noalias, nocapture) off like UnsafeCell semantics."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 3, "last_activity_date": 1481195695, "creation_date": 1481195695, "answer_id": 41038127, "question_id": 40943296, "link": "https://stackoverflow.com/questions/40943296/why-is-passing-self-as-a-raw-pointer-not-allowed/41038127#41038127", "title": "Why is passing `self` as a raw pointer not allowed?", "body": "<p>Because nobody has requested it, which probably means that nobody cared much for it.</p>\n\n<p>Note that since the unsafe semantics of Rust have not been finalized, it may not be a good idea to <em>bet</em> that aliasing is fine, anyway.</p>\n"}, {"tags": [], "owner": {"reputation": 93, "user_id": 13954423, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/5f92e1ed13323402c3f2d66f02fb4514?s=128&d=identicon&r=PG&f=1", "display_name": "cdecompilador", "link": "https://stackoverflow.com/users/13954423/cdecompilador"}, "is_accepted": false, "score": 0, "last_activity_date": 1606395880, "creation_date": 1606395880, "answer_id": 65022653, "question_id": 40943296, "link": "https://stackoverflow.com/questions/40943296/why-is-passing-self-as-a-raw-pointer-not-allowed/65022653#65022653", "title": "Why is passing `self` as a raw pointer not allowed?", "body": "<p>I use to do this, for example in case of <code>*const T</code></p>\n<pre class=\"lang-rust prettyprint-override\"><code>\n/// Consider that Self is a struct composed of f64 fields, like a vector\n\npub fn foo(&amp;self) {\n    let self_ptr = self as *const Self as *const f64;\n}\n</code></pre>\n"}], "owner": {"reputation": 53, "user_id": 6525953, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ca9758970f874c9d6773b755bb130df8?s=128&d=identicon&r=PG&f=1", "display_name": "ttarikbnr", "link": "https://stackoverflow.com/users/6525953/ttarikbnr"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 343, "favorite_count": 0, "accepted_answer_id": 41038127, "answer_count": 2, "score": 4, "last_activity_date": 1606395880, "creation_date": 1480728288, "last_edit_date": 1480728822, "question_id": 40943296, "link": "https://stackoverflow.com/questions/40943296/why-is-passing-self-as-a-raw-pointer-not-allowed", "title": "Why is passing `self` as a raw pointer not allowed?", "body": "<p>It would be good when we want to use method syntax and disable smart pointer optimizations.</p>\n\n<pre><code>fn foo(*const self) // this would not let smart pointer optimizations\n</code></pre>\n"}, {"tags": ["rust", "ffi", "abort"], "answers": [{"comments": [{"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1480721621, "post_id": 40941776, "comment_id": 69096320, "body": "I presume there is a reason standard Rust code doesn&#39;t <code>panic!()</code> on OOM, hence why I didn&#39;t want to use it."}, {"owner": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "reply_to_user": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 1, "creation_date": 1480722474, "post_id": 40941776, "comment_id": 69096565, "body": "@Timmmm That&#39;s because Rust assumes unwinding will allocate memory, and that one OOM means nothing else will be able to allocate. Personally, I think it&#39;s <a href=\"https://internals.rust-lang.org/t/could-we-support-unwinding-from-oom-at-least-for-collections/3673\" rel=\"nofollow noreferrer\">too pessimistic and causes problems</a>."}, {"owner": {"reputation": 74890, "user_id": 246776, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/PZwCJ.jpg?s=128&g=1", "display_name": "eonil", "link": "https://stackoverflow.com/users/246776/eonil"}, "edited": false, "score": 0, "creation_date": 1594784339, "post_id": 40941776, "comment_id": 111244376, "body": "Does <code>panic!</code> aborts whole processes, not single thread?"}, {"owner": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "edited": false, "score": 0, "creation_date": 1595020156, "post_id": 40941776, "comment_id": 111341093, "body": "It&#39;s configurable what <code>panic!()</code> does. With <code>panic=abort</code> mode it immediately kills the whole process. With <code>panic=unwind</code> mode it works like a C++ exception."}], "tags": [], "owner": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "is_accepted": false, "score": 3, "last_activity_date": 1480717433, "creation_date": 1480717433, "answer_id": 40941776, "question_id": 40941632, "link": "https://stackoverflow.com/questions/40941632/how-do-i-abort-a-rust-process/40941776#40941776", "title": "How do I abort a Rust process?", "body": "<p>You could call <a href=\"https://doc.rust-lang.org/stable/std/macro.panic.html\" rel=\"nofollow noreferrer\"><code>panic!()</code></a>.</p>\n\n<p>However, if you can intercept a failed allocation, and return to Rust in a stable program state, I think it's better to report the error (using <code>Result</code>, etc.)</p>\n"}, {"tags": [], "owner": {"reputation": 14813, "user_id": 141502, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/zgvfq.png?s=128&g=1", "display_name": "Daniel", "link": "https://stackoverflow.com/users/141502/daniel"}, "is_accepted": false, "score": 2, "last_activity_date": 1480728775, "last_edit_date": 1480728775, "creation_date": 1480718686, "answer_id": 40941991, "question_id": 40941632, "link": "https://stackoverflow.com/questions/40941632/how-do-i-abort-a-rust-process/40941991#40941991", "title": "How do I abort a Rust process?", "body": "<p>Because Rust code typically is linked with a C runtime library where <code>abort</code> is defined, you can import that function using an <code>extern</code> block:</p>\n\n<pre><code>extern {\n    fn abort();\n}\n\nfn main() {\n    unsafe { abort(); }\n}\n</code></pre>\n\n<p>Note that this actually differs from the <code>abort</code> intrinsic: the <code>abort()</code> function raises <code>SIGABRT</code>, while the intrinsic generates an invalid instruction (<code>ud2</code>), which causes <code>SIGILL</code>.</p>\n\n<p>Hopefully <a href=\"https://doc.rust-lang.org/nightly/std/process/fn.abort.html\" rel=\"nofollow noreferrer\"><code>std::process::abort</code></a> will be stabilized in the future.</p>\n"}, {"tags": [], "owner": {"reputation": 1045, "user_id": 1600476, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cE94p.png?s=128&g=1", "display_name": "Richard Matheson", "link": "https://stackoverflow.com/users/1600476/richard-matheson"}, "is_accepted": true, "score": 2, "last_activity_date": 1562012696, "last_edit_date": 1562012696, "creation_date": 1561973785, "answer_id": 56833263, "question_id": 40941632, "link": "https://stackoverflow.com/questions/40941632/how-do-i-abort-a-rust-process/56833263#56833263", "title": "How do I abort a Rust process?", "body": "<p>Since Rust 1.17.0, you can call <a href=\"https://doc.rust-lang.org/std/process/fn.abort.html\" rel=\"nofollow noreferrer\"><code>std::process::abort()</code></a>.</p>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 422, "favorite_count": 0, "accepted_answer_id": 56833263, "answer_count": 3, "score": 2, "last_activity_date": 1562012696, "creation_date": 1480716747, "question_id": 40941632, "link": "https://stackoverflow.com/questions/40941632/how-do-i-abort-a-rust-process", "title": "How do I abort a Rust process?", "body": "<p>I'm wrapping a C library that does some <code>malloc</code>s that can fail. The rest of Rust aborts on OOM so I'd like to do the same. There is <code>std::intrinsics::abort()</code> and <code>core::intrinsics::abort()</code> (what's the difference?) but they are both unstable.</p>\n\n<p>How can I abort() with stable Rust?</p>\n"}, {"tags": ["recursion", "rust"], "answers": [{"tags": [], "owner": {"reputation": 1540, "user_id": 2606171, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/F4ncy.png?s=128&g=1", "display_name": "belst", "link": "https://stackoverflow.com/users/2606171/belst"}, "is_accepted": false, "score": 2, "last_activity_date": 1480710806, "last_edit_date": 1480710806, "creation_date": 1480709673, "answer_id": 40940168, "question_id": 40939940, "link": "https://stackoverflow.com/questions/40939940/recursive-search-of-node-in-tree/40940168#40940168", "title": "Recursive search of node in tree", "body": "<p>Implement the <code>find</code> method on <code>Node</code> and create a stub <code>find</code> method for <code>Tree</code> which could look like this:</p>\n\n<pre><code>impl&lt;T: Ord&gt; Tree&lt;T&gt; {\n    pub fn find(&amp;self, key: &amp;T) -&gt; bool {\n        match self.root.as_ref() {\n            None =&gt; false,\n            Some(x) =&gt; x.find(key)\n        }\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "edited": false, "score": 0, "creation_date": 1480729580, "post_id": 40940216, "comment_id": 69098054, "body": "For example, target_node.as_ref() convert a reference (&amp;Tree) to ?? (&amp;T)"}, {"owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "edited": false, "score": 0, "creation_date": 1480732790, "post_id": 40940216, "comment_id": 69098538, "body": "I deleted my first comment question since I felt bad about asking too many...   Didn&#39;t expect you still see it and answer everything. Thanks!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1480730851, "last_edit_date": 1495542629, "creation_date": 1480709895, "answer_id": 40940216, "question_id": 40939940, "link": "https://stackoverflow.com/questions/40939940/recursive-search-of-node-in-tree/40940216#40940216", "title": "Recursive search of node in tree", "body": "<p>You need to move the majority of the implementation to the <code>Node</code> type, then leave only a small shim in <code>Tree</code>:</p>\n\n<pre><code>impl&lt;T: Ord&gt; Tree&lt;T&gt; {\n    pub fn find(&amp;self, key: &amp;T) -&gt; bool {\n        self.root.as_ref().map(|n| n.find(key)).unwrap_or(false)\n    }\n}\n\nimpl&lt;T: Ord&gt; Node&lt;T&gt; {\n    // search the tree\n    pub fn find(&amp;self, key: &amp;T) -&gt; bool {\n        if self.value == *key {\n            return true;\n        }\n\n        let target_node = if *key &lt; self.value {\n            &amp;self.left\n        } else {\n            &amp;self.right\n        };\n\n        target_node.as_ref().map(|n| n.find(key)).unwrap_or(false)\n    }\n}\n</code></pre>\n\n<p>However, I might avoid multiple comparisons by just matching on the result:</p>\n\n<pre><code>pub fn find(&amp;self, key: &amp;T) -&gt; bool {\n    use ::std::cmp::Ordering::*;\n\n    match self.value.cmp(key) {\n        Equal =&gt; true,\n        Less =&gt; self.left.as_ref().map(|n| n.find(key)).unwrap_or(false),\n        Greater =&gt; self.right.as_ref().map(|n| n.find(key)).unwrap_or(false),\n    }\n}\n</code></pre>\n\n<p>Or</p>\n\n<pre><code>pub fn find(&amp;self, key: &amp;T) -&gt; bool {\n    use ::std::cmp::Ordering::*;\n\n    let child = match self.value.cmp(key) {\n        Equal =&gt; return true,\n        Less =&gt; self.left.as_ref(),\n        Greater =&gt; self.right.as_ref(),\n    };\n\n    child.map(|n| n.find(key)).unwrap_or(false)\n}\n</code></pre>\n\n<blockquote>\n  <p>I found it is hard to understand <code>target_node.as_ref().map(|n| n.find(key)).unwrap_or(false)</code>. I just started to learn the iterator. Is that possible to explain the long expression step by step?</p>\n</blockquote>\n\n<p>Just follow the type signatures of each function:</p>\n\n<ol>\n<li><code>self</code> is a <code>&amp;Node&lt;T&gt;</code></li>\n<li><code>&amp;self.left</code> / <code>&amp;self.right</code> / <code>target_node</code> are a <code>&amp;Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;</code></li>\n<li><a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref\" rel=\"nofollow noreferrer\"><code>Option::as_ref</code></a> converts an <code>&amp;Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code>. Now we have <code>Option&lt;&amp;Box&lt;Node&lt;T&gt;&gt;&gt;</code>.</li>\n<li><a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.map\" rel=\"nofollow noreferrer\"><code>Option::map</code></a> applies a function (which may change the contained type) to the option if it is <code>Some</code>, otherwise it leaves it <code>None</code>. \n\n<ol>\n<li>The function we apply is <code>Node::find</code>, which takes a <code>&amp;Node&lt;T&gt;</code> and returns a <code>bool</code>.</li>\n<li><code>Box&lt;T&gt;</code> implements <code>Deref</code> so any methods on <code>T</code> appear on <code>Box&lt;T&gt;</code>.</li>\n<li><a href=\"https://stackoverflow.com/q/28519997/155423\">Automatic dereferencing</a> allows us to treat <code>&amp;Box&lt;T&gt;</code> as <code>Box&lt;T&gt;</code>.</li>\n<li>Now we have <code>Option&lt;bool&gt;</code></li>\n</ol></li>\n<li><a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or\" rel=\"nofollow noreferrer\"><code>Option::unwrap_or</code></a> returns the contained value if there is one, otherwise the fallback value provided. The final type is <code>bool</code>.</li>\n</ol>\n\n<p>There is no usage of the <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\" rel=\"nofollow noreferrer\"><code>Iterator</code></a> trait. Both <code>Iterator</code> and <code>Option</code> have a <code>map</code> method. If you are interested in the fact that they have the same name and do similar things, that [is what people refer to as a <a href=\"https://en.wikipedia.org/wiki/Monad_(functional_programming)\" rel=\"nofollow noreferrer\">monad</a>. Understanding monads is interesting but not <em>required</em> to actually use them.</p>\n"}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 347, "favorite_count": 0, "accepted_answer_id": 40940216, "answer_count": 2, "score": 0, "last_activity_date": 1480730851, "creation_date": 1480708585, "last_edit_date": 1480710092, "question_id": 40939940, "link": "https://stackoverflow.com/questions/40939940/recursive-search-of-node-in-tree", "title": "Recursive search of node in tree", "body": "<p>I want to build a tree using exactly two structs: <code>Node</code> and <code>Tree</code> and then recursively search for a target node from the tree. If a target is found, return <code>true</code>, else return <code>false</code>. </p>\n\n<p>The challenge for me here is how to recursively call the <code>find</code> function, since it is only defined on <code>Tree</code> not <code>Node</code>. </p>\n\n<pre><code>pub struct Node&lt;T&gt; {\n    value: T,\n    left: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n    right: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\n\npub struct Tree&lt;T&gt; {\n    root: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,\n}\n\nimpl&lt;T: Ord&gt; Tree&lt;T&gt; {\n    /// Creates an empty tree\n    pub fn new() -&gt; Self {\n        Tree { root: None }\n    }\n\n    // search the tree\n    pub fn find(&amp;self, key: &amp;T) -&gt; bool {\n        let root_node = &amp;self.root; // root is Option\n\n        match *root_node {\n            Some(ref node) =&gt; {\n\n                if node.value == *key {\n                    return true;\n                }\n\n                let target_node = if *key &lt; node.value {\n                    &amp;node.left\n                } else {\n                    &amp;node.right\n                };\n\n                match *target_node {\n                    Some(sub_node) =&gt; sub_node.find(key),\n                    None =&gt; {\n                        return false;\n                    } \n                }\n            }\n            None =&gt; return false,\n        }\n    }\n}\n\nfn main() {\n    let mut mytree: Tree&lt;i32&gt; = Tree::new();\n\n    let node1 = Node {\n        value: 100,\n        left: None,\n        right: None,\n    };\n    let boxed_node1 = Some(Box::new(node1));\n\n    let root = Node {\n        value: 200,\n        left: boxed_node1,\n        right: None,\n    };\n    let boxed_root = Some(Box::new(root));\n    let mytree = Tree { root: boxed_root };\n\n    let res = mytree.find(&amp;100);\n}\n</code></pre>\n\n<p>The current code reports the error: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: no method named `find` found for type `Box&lt;Node&lt;T&gt;&gt;` in the current scope\n  --&gt; src/main.rs:36:48\n   |\n36 |                     Some(sub_node) =&gt; sub_node.find(key),\n   |                                                ^^^^\n   |\n   = note: the method `find` exists but the following trait bounds were not satisfied: `Node&lt;T&gt; : std::iter::Iterator`\n   = help: items from traits can only be used if the trait is implemented and in scope; the following traits define an item `find`, perhaps you need to implement one of them:\n   = help: candidate #1: `std::iter::Iterator`\n   = help: candidate #2: `core::str::StrExt`\n</code></pre>\n\n<p>I understand that <code>find</code> is only implemented on <code>Tree</code>, so there is an error, but I don't think it is efficient to implement <code>find</code> on both <code>Tree</code> and <code>Node</code>. Any hint to solve this?</p>\n"}, {"tags": ["rust", "closures"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1480693887, "post_id": 40936078, "comment_id": 69083426, "body": "<i>The closure will be executed multiple times till all the values in the list are emptied. How can I send the list data without loosing the scope of the variable.</i> =&gt; what do you mean? Looking at the code as written I would expect <code>list</code> to be consumed <i>once</i> completely (in one shot)."}, {"owner": {"reputation": 654, "user_id": 4079123, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/0c28786e5157a528eb01657fda5a46b6?s=128&d=identicon&r=PG&f=1", "display_name": "Bharadwaj", "link": "https://stackoverflow.com/users/4079123/bharadwaj"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1480694019, "post_id": 40936078, "comment_id": 69083509, "body": "I meant that the function <code>put</code> will read out all the data in the vector. Of course the function takes it at one shot."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480695081, "post_id": 40936078, "comment_id": 69084259, "body": "Naming functions with capital letters is not idiomatic Rust. Functions and variables use <code>snake_case</code>."}], "answers": [{"comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 2, "creation_date": 1480695252, "post_id": 40936507, "comment_id": 69084390, "body": "A simple reference might do instead of an <code>Rc</code>, wouldn&#39;t it?."}, {"owner": {"reputation": 654, "user_id": 4079123, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/0c28786e5157a528eb01657fda5a46b6?s=128&d=identicon&r=PG&f=1", "display_name": "Bharadwaj", "link": "https://stackoverflow.com/users/4079123/bharadwaj"}, "edited": false, "score": 0, "creation_date": 1480695723, "post_id": 40936507, "comment_id": 69084734, "body": "Thank you very much for the inputs, a simple reference was perfect."}], "tags": [], "owner": {"reputation": 8378, "user_id": 124538, "user_type": "registered", "accept_rate": 95, "profile_image": "https://www.gravatar.com/avatar/82159aeb57c52bc0c7bfe6e9c832c3ea?s=128&d=identicon&r=PG", "display_name": "Wesley Wiser", "link": "https://stackoverflow.com/users/124538/wesley-wiser"}, "is_accepted": true, "score": 0, "last_activity_date": 1480695354, "last_edit_date": 1480695354, "creation_date": 1480695088, "answer_id": 40936507, "question_id": 40936078, "link": "https://stackoverflow.com/questions/40936078/copying-vector-of-structures/40936507#40936507", "title": "Copying vector of structures", "body": "<p>When you write <code>Message::Value(list)</code>, you have consumed <code>list</code> by passing it to <code>Value</code>. <code>FnMut</code> closures <em>may</em> be executed multiple times so the compiler must assume that it will be called multiple times. Since your closure is attempting to move <code>list</code>, the compiler complains because you are not allowed to move a value out of a location multiple times.</p>\n\n<p>Depending on what <code>output.put()</code> is trying to do there might be several solutions:</p>\n\n<ul>\n<li><p>If the closure will only be called once, then you should change the type of the closure argument to <code>FnOnce</code>. This will allow you to move <code>list</code> as you are trying to do.</p></li>\n<li><p>If the closure may be called multiple times, you will need to take a reference to <code>list</code> and then clone it:</p>\n\n<pre><code>fn Task() {\n    let mut list: AList = AList::new();\n\n    // ...\n    // I fill up the list with many items\n    // ...\n\n    output.put(|msg| *msg = Some(Message::Value((&amp;list).clone())));\n}\n</code></pre></li>\n</ul>\n"}], "owner": {"reputation": 654, "user_id": 4079123, "user_type": "registered", "accept_rate": 76, "profile_image": "https://www.gravatar.com/avatar/0c28786e5157a528eb01657fda5a46b6?s=128&d=identicon&r=PG&f=1", "display_name": "Bharadwaj", "link": "https://stackoverflow.com/users/4079123/bharadwaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 118, "favorite_count": 0, "accepted_answer_id": 40936507, "answer_count": 1, "score": 0, "last_activity_date": 1480695354, "creation_date": 1480693764, "last_edit_date": 1480695022, "question_id": 40936078, "link": "https://stackoverflow.com/questions/40936078/copying-vector-of-structures", "title": "Copying vector of structures", "body": "<p>I am implementing a Rust application where the vector of structures are to be passed into a closure.</p>\n\n<pre><code>#[derive(Clone, Copy)]\nstruct AttackInfo {\n    ppid: usize,\n    pname: &amp;'static str,\n    cpu: f32,\n}\n\ntype AList = Vec&lt;AttackInfo&gt;;\n\nfn Task() {\n    let mut list: AList = AList::new();\n\n    // ...\n    // I fill up the list with many items\n    // ...\n\n    output.put(|msg| *msg = Some(Message::Value(list)));\n}\n</code></pre>\n\n<p><code>output.put</code> is a function that takes a closure, this is defined by the library.</p>\n\n<p>I am unable to send the value of list because of the error for the <code>list</code> variable:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>cannot move out of captured outer variable in an `FnMut` closure\n</code></pre>\n\n<p>The closure will be executed multiple times until all the values in the list are emptied. How can I send the list data without losing the scope of the variable?</p>\n"}, {"tags": ["generics", "nested", "rust", "traits"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480688511, "post_id": 40929991, "comment_id": 69079756, "body": "I&#39;m not sure how this answers the question (although it evidently does as OP accepted it). OP wanted to be able to say <code>struct Partition {</code>, but this answer still has a generic parameter for <code>Partition</code> and <code>File</code>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480689501, "post_id": 40929991, "comment_id": 69080482, "body": "@Shepmaster: I read the question as reducing the complexity (and abstracting away the bounds of inner members), not necessarily removing all bounds. Note that if <code>Volume</code> is object-safe, it would be possible to have <code>Partition</code> contain ` Box&lt;Volume&gt;` and it would be parameter-less."}, {"owner": {"reputation": 336, "user_id": 3748215, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/ed0e35e4fdc144d63a02e84d2e6e1168?s=128&d=identicon&r=PG&f=1", "display_name": "eddy", "link": "https://stackoverflow.com/users/3748215/eddy"}, "edited": false, "score": 0, "creation_date": 1480690616, "post_id": 40929991, "comment_id": 69081275, "body": "I accepted this because it reduces the complexity. Through it is true that using a trait object in a box <code>Box&lt;Volume&gt;</code> would answer the question more correctly."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 336, "user_id": 3748215, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/ed0e35e4fdc144d63a02e84d2e6e1168?s=128&d=identicon&r=PG&f=1", "display_name": "eddy", "link": "https://stackoverflow.com/users/3748215/eddy"}, "edited": false, "score": 0, "creation_date": 1480692198, "post_id": 40929991, "comment_id": 69082305, "body": "@eddy: Let me add the variation then, and make it complete. Also, in the future, do not feel pressured to accept an answer right away. An accepted answer is like a &quot;nothing to see here, move along&quot; sign to potential answerers, some might still answers but most will move on to greener pastures. Therefore, I encourage you to only accept answers once they really answer your question, and otherwise wait for a better answer... at least for a few days."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 3, "last_activity_date": 1480692341, "last_edit_date": 1480692341, "creation_date": 1480674509, "answer_id": 40929991, "question_id": 40929867, "link": "https://stackoverflow.com/questions/40929867/how-do-you-abstract-generics-in-nested-rust-types/40929991#40929991", "title": "How do you abstract generics in nested Rust types?", "body": "<blockquote>\n  <p>How do you abstract generics in nested types?</p>\n</blockquote>\n\n<p>Rust does abstractions by traits; so use a trait (not a type).</p>\n\n<p>Specifically, <code>Partition</code> should depend on a generic parameter implementing a trait rather than on <code>Disk&lt;T: ...&gt;</code> itself.</p>\n\n<pre><code>trait Volume {}\n\nstruct Disk&lt;T: Read + Seek + Write&gt; {\n    handle: T,\n}\n\nimpl&lt;T: Read + Seek + Write&gt; Volume for Disk&lt;T&gt; {}\n\nstruct Partition&lt;V: Volume&gt; {\n    volume: V,\n}\n\nstruct File&lt;V: Volume&gt; {\n    partition: Partition&lt;V&gt;,\n}\n</code></pre>\n\n<p><em>Alternatively <code>File</code> could itself depend on an abstract partition.</em></p>\n\n<p>Note that using this <code>Volume</code> trait, it is even possible to remove the generic parameter completely; as long as the <code>Volume</code> trait is object-safe <em>and</em> the object behind does not need to store a local reference:</p>\n\n<pre><code>struct Partition {\n    volume: Box&lt;Volume&gt;,\n}\n\nstruct File {\n    partition: Partition,\n}\n</code></pre>\n\n<p>It adds a tiny bit of over-head (a dynamic allocation + indirect calls), but gives you a single type instead of a family.</p>\n\n<hr>\n\n<p>Another solution to only reduce verbosity is to introduce a new <code>trait</code> for specifically this purpose:</p>\n\n<pre><code>trait Volume: Read + Seek + Write {}\n\nimpl&lt;T&gt; Volume for T where T: Read + Seek + Write {}\n</code></pre>\n\n<p>Allows you to thereafter use the <code>Volume</code> trait as a short-hand for the sum of traits it represents. This does not abstract the disk, but is certainly convenient.</p>\n"}], "owner": {"reputation": 336, "user_id": 3748215, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/ed0e35e4fdc144d63a02e84d2e6e1168?s=128&d=identicon&r=PG&f=1", "display_name": "eddy", "link": "https://stackoverflow.com/users/3748215/eddy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1002, "favorite_count": 0, "accepted_answer_id": 40929991, "answer_count": 1, "score": 2, "last_activity_date": 1480692341, "creation_date": 1480674180, "last_edit_date": 1480688406, "question_id": 40929867, "link": "https://stackoverflow.com/questions/40929867/how-do-you-abstract-generics-in-nested-rust-types", "title": "How do you abstract generics in nested Rust types?", "body": "<pre><code>struct Disk&lt;T: Read + Seek + Write&gt; {\n    handle: T,\n}\n\nstruct Partition&lt;T: Read + Seek + Write&gt; {\n    disk: Disk&lt;T&gt;,\n}\n\nstruct File&lt;T: Read + Seek + Write&gt; {\n    partition: Partition&lt;T&gt;,\n}\n</code></pre>\n\n<p>At the point of <code>struct Partition</code>, it is no longer interesting what <code>Disk</code>s trait-bounds are. Through the language design, it is not possible to create a <code>Disk</code> with a handle what does not have <code>Read + Seek + Write</code>. Through this example is very simple, types might become extremely complex if they have multiple members with traits. </p>\n\n<p>What I want is:</p>\n\n<pre><code>struct Disk&lt;T: Read + Seek + Write&gt; {\n    handle: T,\n}\n\ntype ExDisk = FIXME;\n\nstruct Partition {\n    disk: ExDisk,\n}\n\nstruct File {\n    partition: Partition,\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480688657, "post_id": 40926762, "comment_id": 69079870, "body": "<code>None</code> is <b>not</b> a type. It is a <i>value</i> of the type <code>Option</code>."}], "answers": [{"tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 2, "last_activity_date": 1480663227, "creation_date": 1480663227, "answer_id": 40926823, "question_id": 40926762, "link": "https://stackoverflow.com/questions/40926762/how-to-create-a-new-empty-tree/40926823#40926823", "title": "How to create a new empty Tree", "body": "<p>With <code>key: T</code> you are explicitly asking for a value of type <code>T</code>. What you gave in the initialization (<code>key: None</code>) is an <code>Option&lt;U&gt;</code>, you need to give it some value, for example by changing <code>new</code> to</p>\n\n<pre><code>pub fn new(t: T) -&gt; Self {\n    Tree {\n        key: t,\n        l: None,\n        r: None,\n    }\n}\n</code></pre>\n\n<p>Alternatively, if you also want the ability to sometimes have keys, and sometimes not, you can change the <code>key</code> field to type <code>Option&lt;T&gt;</code></p>\n"}, {"tags": [], "owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "is_accepted": true, "score": 5, "last_activity_date": 1480688691, "last_edit_date": 1480688691, "creation_date": 1480663469, "answer_id": 40926896, "question_id": 40926762, "link": "https://stackoverflow.com/questions/40926762/how-to-create-a-new-empty-tree/40926896#40926896", "title": "How to create a new empty Tree", "body": "<p>I'd do something like:</p>\n\n<pre><code>type Tree&lt;T&gt; = Option&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;;\n\nstruct TreeNode&lt;T&gt; {\n    key: T,\n    l: Tree&lt;T&gt;,\n    r: Tree&lt;T&gt;,\n}\n</code></pre>\n\n<p>Now creating an empty <code>Tree</code> is easy (just <code>None</code>), as it is to bind two <code>Tree</code>s into a new bigger one.</p>\n\n<p>If you don't like the <code>None</code>-as-empty or the box in the root tree, you could add a wrapper type instead of the alias <code>Tree</code>, but the main idea is the same: move the <code>Option</code> from the left/right branches into the node type.</p>\n"}, {"tags": [], "owner": {"reputation": 1540, "user_id": 2606171, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/F4ncy.png?s=128&g=1", "display_name": "belst", "link": "https://stackoverflow.com/users/2606171/belst"}, "is_accepted": false, "score": 5, "last_activity_date": 1480688741, "last_edit_date": 1480688741, "creation_date": 1480683119, "answer_id": 40932678, "question_id": 40926762, "link": "https://stackoverflow.com/questions/40926762/how-to-create-a-new-empty-tree/40932678#40932678", "title": "How to create a new empty Tree", "body": "<p>Why don't you make your <code>Tree</code> an enum instead of a struct?</p>\n\n<p>I'd create a binary <code>Tree</code> like this:</p>\n\n<pre><code>enum Tree&lt;T&gt; {\n    Empty,\n    Node {\n        val: T,\n        l: Box&lt;Tree&lt;T&gt;&gt;,\n        r: Box&lt;Tree&lt;T&gt;&gt;,\n    },\n}\n</code></pre>\n\n<p>You could then implement it like this:</p>\n\n<pre><code>impl&lt;T: Ord&gt; Tree&lt;T&gt; {\n    fn empty() -&gt; Self {\n        Tree::Empty\n    }\n    fn singleton(val: T) -&gt; Self {\n        Tree::Node {\n            val: val,\n            l: Box::new(Tree::Empty),\n            r: Box::new(Tree::Empty),\n        }\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 1135, "user_id": 3754101, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/D1eNN.jpg?s=128&g=1", "display_name": "enaJ", "link": "https://stackoverflow.com/users/3754101/enaj"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1010, "favorite_count": 0, "accepted_answer_id": 40926896, "answer_count": 3, "score": 1, "last_activity_date": 1480688741, "creation_date": 1480663014, "last_edit_date": 1480688636, "question_id": 40926762, "link": "https://stackoverflow.com/questions/40926762/how-to-create-a-new-empty-tree", "title": "How to create a new empty Tree", "body": "<p>I have a <code>Tree</code> and I want to create a new empty tree. My first thought is:</p>\n\n<pre><code>struct Tree&lt;T&gt; {\n    key: T,\n    l: Option&lt;Box&lt;Tree&lt;T&gt;&gt;&gt;,\n    r: Option&lt;Box&lt;Tree&lt;T&gt;&gt;&gt;,\n}\n\nimpl&lt;T: Ord&gt; Tree&lt;T&gt; {\n    /// Creates an empty tree\n    pub fn new() -&gt; Self {\n        Tree {\n            key: None, // error of mismatch type\n            l: None,\n            r: None,\n        }\n    }\n}\n</code></pre>\n\n<p>I get an error of <code>Error: mismatched types [E0308]</code></p>\n\n<p>Is it a problem of type <code>T</code> not matching type <code>None</code>?</p>\n"}, {"tags": ["types", "rust"], "answers": [{"comments": [{"owner": {"reputation": 3719, "user_id": 2550406, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/GhBMm.png?s=128&g=1", "display_name": "lucidbrot", "link": "https://stackoverflow.com/users/2550406/lucidbrot"}, "edited": false, "score": 0, "creation_date": 1572546019, "post_id": 40926955, "comment_id": 103603109, "body": "Using a trait instead of a newtype means that it might be not possible to use as return type, because it is not sized. What&#39;s the problem with using a newtype when you don&#39;t care about implementation hiding?"}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 8, "last_activity_date": 1480670570, "last_edit_date": 1480670570, "creation_date": 1480663783, "answer_id": 40926955, "question_id": 40925296, "link": "https://stackoverflow.com/questions/40925296/how-to-create-new-instances-of-a-wrapped-vector-in-rust/40926955#40926955", "title": "How to create new instances of a wrapped vector in Rust?", "body": "<p>A newtype \"hides\" its internals. You do not get transparent access to the interior. To create a new object of <code>MyStructVec</code>, you need to call the inner type's constructor and then wrap it:</p>\n\n<pre><code>MyStructVec(Vec::new())\n\nMyStructVec(Vec::with_capacity(42))\n</code></pre>\n\n<p>After the creation of such an object, you can use the object somewhat transparently by implementing <code>Deref</code> and <code>DerefMut</code> for your type:</p>\n\n<pre><code>impl std::ops::Deref for MyStructVec {\n    type Target = Vec&lt;MyStruct&gt;;\n    fn deref(&amp;self) -&gt; &amp;Vec&lt;MyStruct&gt; {\n        &amp;self.0\n    }\n}\n\nimpl std::ops::DerefMut for MyStructVec {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut Vec&lt;MyStruct&gt; {\n        &amp;mut self.0\n    }\n}\n</code></pre>\n\n<hr>\n\n<blockquote>\n  <p>so I can attach extra methods</p>\n</blockquote>\n\n<p>That's not the way newtypes are used. Newtypes are used for type safety. If all you want is that all <code>Vec&lt;MyStruct&gt;</code> have new methods, create an extension trait:</p>\n\n<pre><code>trait VecMyStructExt {\n    fn foo(&amp;self);\n}\nimpl VecMyStructExt for Vec&lt;MyStruct&gt; {\n    fn foo(&amp;self) { println!(\"foo\"); }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 3, "last_activity_date": 1480679321, "creation_date": 1480679321, "answer_id": 40931542, "question_id": 40925296, "link": "https://stackoverflow.com/questions/40925296/how-to-create-new-instances-of-a-wrapped-vector-in-rust/40931542#40931542", "title": "How to create new instances of a wrapped vector in Rust?", "body": "<blockquote>\n  <p><code>MyStructVec::new()</code> isn't recognized.</p>\n</blockquote>\n\n<p>Indeed, because you've defined a new type but not defined any methods yet.  You can do so easily:</p>\n\n<pre><code>impl MyStructVec {\n    pub fn new() -&gt; MyStructVec {\n        MyStructVec(Vec::new())\n    }\n}\n</code></pre>\n\n<p>but as said well in the other answer you don't get the wrapped type's methods directly on your new struct directly, so you'd need to wrap the ones you want.  (In some cases you might be able to automate to some extent it using macros)</p>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 799, "favorite_count": 0, "accepted_answer_id": 40926955, "answer_count": 2, "score": 2, "last_activity_date": 1480679321, "creation_date": 1480655927, "question_id": 40925296, "link": "https://stackoverflow.com/questions/40925296/how-to-create-new-instances-of-a-wrapped-vector-in-rust", "title": "How to create new instances of a wrapped vector in Rust?", "body": "<p>I'd like to create my own vector <code>struct</code>, so I can attach extra methods.</p>\n\n<pre><code>pub struct MyStructVec(pub Vec&lt;MyStruct&gt;);\n</code></pre>\n\n<p>Having done this, how would a new instance of this vector be created?</p>\n\n<p><code>MyStructVec::new()</code> isn't recognized. How would existing vector creation methods be used with this type? (<code>new</code>, <code>with_capacity</code>... etc.)</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480643335, "post_id": 40922855, "comment_id": 69058834, "body": "<code>Any</code> is not a reasonable equivalent of <code>void *</code>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1480643680, "post_id": 40922855, "comment_id": 69058922, "body": "Anyway, read the first paragraph of <a href=\"https://doc.rust-lang.org/std/any/index.html\" rel=\"nofollow noreferrer\">the <code>Any</code> docs</a> again: <i>which enables dynamic typing of <b>any <code>&#39;static</code> type</b> through runtime reflection.</i> \u2014 your type isn&#39;t static."}, {"owner": {"reputation": 71, "user_id": 5934166, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a3e2e25eae4be20f70b95a92c8e6e556?s=128&d=identicon&r=PG&f=1", "display_name": "chamaken", "link": "https://stackoverflow.com/users/5934166/chamaken"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1481154204, "post_id": 40922855, "comment_id": 69266282, "body": "It&#39;s just as you say. I realize I misunderstood a <code>&#39;static</code> is a type that is known at compile time. Can I think it as one of the reasons for <code>Any</code> is not a reasonable equivalent of <code>void *</code>?"}], "answers": [{"tags": [], "owner": {"reputation": 71, "user_id": 5934166, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a3e2e25eae4be20f70b95a92c8e6e556?s=128&d=identicon&r=PG&f=1", "display_name": "chamaken", "link": "https://stackoverflow.com/users/5934166/chamaken"}, "is_accepted": false, "score": 0, "last_activity_date": 1481855474, "last_edit_date": 1481855474, "creation_date": 1481845574, "answer_id": 41175168, "question_id": 40922855, "link": "https://stackoverflow.com/questions/40922855/cannot-use-downcast-any-to-an-array-containing-references/41175168#41175168", "title": "Cannot use downcast Any to an array containing references", "body": "<p>I can only tell it seems to work. main.rs</p>\n\n<pre><code>extern crate libc;\nuse libc::{c_int, size_t, c_void};\n\ntype CbT = extern \"C\" fn(obj: *const u32, arg: *mut c_void) -&gt; c_int;\nextern { fn cb_run(objs: *const u32, len: size_t, cb: CbT, arg: *mut c_void) -&gt; c_int; }\n\ntype Cb &lt;'a, T: ?Sized&gt; = fn(obj: &amp;'a u32, arg: &amp;mut T) -&gt; i32;\nstruct CbData &lt;'a, 'b, T: 'a + 'b + ?Sized&gt; {\n    cb: Cb&lt;'a, T&gt;,\n    arg: &amp;'b mut T,\n}\n\nextern fn rust_cb&lt;T: ?Sized&gt;(obj: *const u32, arg: *mut c_void) -&gt; c_int {\n    unsafe {\n        let s = &amp;mut *(arg as *mut CbData&lt;T&gt;);\n        (s.cb)(&amp;*obj, s.arg)\n    }\n}\n\nfn cb_run_rs&lt;'a, 'b, T: 'a + ?Sized&gt;(objs: &amp;[u32], cb: Cb&lt;'a, T&gt;, arg: &amp;'b mut T) -&gt; i32 {\n    let mut arg = &amp;mut CbData{ cb: cb, arg: arg } ;\n    unsafe { cb_run(objs.as_ptr() as *const u32, objs.len() as size_t,\n                    rust_cb::&lt;T&gt;, arg as *mut _ as *mut c_void) as i32 }\n}\n\n//// the above is lib, the below is bin\n\nfn my_cb&lt;'a&gt;(obj: &amp;'a u32, arg: &amp;mut [Option&lt;&amp;'a u32&gt;]) -&gt; i32 {\n    arg[*obj as usize] = Some(obj);\n    0\n}\n\nfn main() {\n    let objs = [0u32, 1, 2, 3];\n    let mut arg = [None; 4];\n    println!(\"pre  : {:?}\", arg);\n    cb_run_rs(&amp;objs, my_cb, &amp;mut arg);\n    println!(\"post : {:?}\", arg);\n}\n</code></pre>\n\n<p>FYI build.rs:</p>\n\n<pre><code>extern crate gcc;\n\nfn main() {\n    gcc::compile_library(\"libfoo.a\", &amp;[\"src/foo.c\"]);\n}\n</code></pre>\n\n<p>Cargo.toml:</p>\n\n<pre><code>[package]\nname = \"sof\"\nversion = \"0.1.0\"\nauthors = [\"author@example.com\"]\nbuild = \"build.rs\"\n\n[build-dependencies]\ngcc = \"0.3\"\n\n[dependencies]\nlibc = \"0.2\"\n</code></pre>\n"}], "owner": {"reputation": 71, "user_id": 5934166, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a3e2e25eae4be20f70b95a92c8e6e556?s=128&d=identicon&r=PG&f=1", "display_name": "chamaken", "link": "https://stackoverflow.com/users/5934166/chamaken"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 130, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1481855474, "creation_date": 1480638836, "last_edit_date": 1481844741, "question_id": 40922855, "link": "https://stackoverflow.com/questions/40922855/cannot-use-downcast-any-to-an-array-containing-references", "title": "Cannot use downcast Any to an array containing references", "body": "<p>Passing just an array seems to work fine:</p>\n\n<pre><code>fn set_zero&lt;'a&gt;(u: &amp;'a u32, ms: &amp;mut [Option&lt;&amp;'a u32&gt;; 4]) {\n    ms[0] = Some(u);\n}\n</code></pre>\n\n<p>I'm trying to wrap C callback function which is passed a <code>void *</code>\nso I'm using <code>std::any::Any</code> instead of an array:</p>\n\n<pre><code>fn set_zero&lt;'a&gt;(u: &amp;'a u32, ma: &amp;mut Any) {\n    if let Some(ms) = ma.downcast_mut::&lt;[Option&lt;&amp;'a u32&gt;; 4]&gt;() {\n        ms[0] = Some(u);\n    }\n}\n</code></pre>\n\n<p>This causes an error related to lifetimes:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0477]: the type `[std::option::Option&lt;&amp;'a u32&gt;; 4]` \ndoes not fulfill the required lifetime\n--&gt; option.rs:18:26\n   |\n18 |     if let Some(ms) = ma.downcast_mut::&lt;[Option&lt;&amp;'a u32&gt;; 4]&gt;() {\n   |                          ^^^^^^^^^^^^\n   |\n  = note: type must outlive the static lifetime\n</code></pre>\n\n<p>How can I fix this? What documentation should read to understand the error better?</p>\n\n<p><strong>UPDATE</strong>: more detailed background:</p>\n\n<p>An contrived C prototype is - foo.c:</p>\n\n<pre><code>#include &lt;stdint.h&gt;\n\ntypedef int (*cb_t)(const uint32_t *obj, void *arg);\n\nint32_t cb_run(uint32_t const objs[], uint32_t len, cb_t cb, void *arg)\n{\n        int i;\n        for (i = 0; i &lt; len; i++)\n                if (cb(&amp;objs[i], arg) &lt; 0)\n                        return -1;\n        return 0;\n}\n</code></pre>\n\n<p>Then, I tried to wrap by using <code>Any</code>:</p>\n\n<pre><code>extern crate libc;\nuse libc::{c_int, size_t, c_void};\nuse std::any::Any;\n\ntype CbT = extern \"C\" fn(obj: *const u32, arg: *mut c_void) -&gt; c_int;\nextern { fn cb_run(objs: *const u32, len: size_t, cb: CbT, arg: *mut c_void) -&gt; c_int; }\n\ntype Cb = fn(obj: &amp;u32, arg: &amp;mut Any) -&gt; i32;\nstruct CbData &lt;'a&gt; {\n    cb: Cb,\n    arg: &amp;'a mut Any,\n}\n\nextern fn rust_cb(obj: *const u32, arg: *mut c_void) -&gt; c_int {\n    unsafe {\n        let s = &amp;mut *(arg as *mut CbData);\n        (s.cb)(&amp;*obj, s.arg)\n    }\n}\n\nfn cb_run_rs(objs: &amp;[u32], cb: Cb, arg: &amp;mut Any) -&gt; i32 {\n    let mut arg = &amp;mut CbData{ cb: cb, arg: arg } ;\n    unsafe { cb_run(objs.as_ptr() as *const u32, objs.len() as size_t,\n                    rust_cb, arg as *mut _ as *mut c_void) as i32 }\n}\n\n//// the above is lib, the below is bin\n\n// set_zero() in the above\nfn my_cb&lt;'a&gt;(obj: &amp;'a u32, arg: &amp;mut Any) -&gt; i32 {\n    if let Some(data) = arg.downcast_mut::&lt;[Option&lt;&amp;'a u32&gt;; 4]&gt;() {\n        data[0] = Some(obj);\n    }\n    0\n}\n\nfn main() {\n    let objs = [0u32, 1, 2, 3];\n    let mut arg = [None; 4];\n    println!(\"pre  : {:?}\", arg);\n    cb_run_rs(&amp;objs, my_cb, &amp;mut arg);\n    println!(\"post : {:?}\", arg);\n}\n</code></pre>\n\n<p>And it causes <code>note: type must outlive the static lifetime</code>.\nHow can I handle this kind of <code>void *</code> in good manner without <code>unsafe</code> from library user?</p>\n"}, {"tags": ["rust", "iron"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480643064, "post_id": 40922505, "comment_id": 69058775, "body": "<a href=\"http://stackoverflow.com/q/34489422\">stackoverflow.com/q/34489422</a> has the same error"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480643105, "post_id": 40922505, "comment_id": 69058786, "body": "As does <a href=\"http://stackoverflow.com/q/38659008\">stackoverflow.com/q/38659008</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480649419, "post_id": 40922505, "comment_id": 69060309, "body": "You should upgrade to the newest version of Rust, which has improved error messages and error message formatting. I&#39;ve updated your error message to the newer format because it&#39;s easier for us to read here as well."}], "answers": [{"comments": [{"owner": {"reputation": 2481, "user_id": 327786, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/ZmpBr.jpg?s=128&g=1", "display_name": "TlmaK0", "link": "https://stackoverflow.com/users/327786/tlmak0"}, "edited": false, "score": 0, "creation_date": 1480780789, "post_id": 40924299, "comment_id": 69109033, "body": "Thanks @Shepmaster"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1480649265, "creation_date": 1480649265, "answer_id": 40924299, "question_id": 40922505, "link": "https://stackoverflow.com/questions/40922505/cannot-create-an-iron-handler-because-the-trait-bound-stdopsfnmut-ironr/40924299#40924299", "title": "Cannot create an Iron handler because the trait bound std::ops::Fn&lt;(&amp;mut iron::Request)&gt; is not satisfied", "body": "<p>Here's a reproduction of your issue; can you spot the problem?</p>\n\n<pre><code>trait Foo {}\n\nstruct Bar;\n\nimpl Foo for Bar {}\n\nimpl Bar {\n    fn thing(&amp;self) {\n        requires_bar(self);\n    }\n}\n\nfn requires_bar&lt;F&gt;(foo: F) where F: Foo {}\n\nfn main() {}\n</code></pre>\n\n<p>Give up? </p>\n\n<p>You've implemented the trait for your struct:</p>\n\n<pre><code>impl Handler for Server\n</code></pre>\n\n<p>But are then trying to use <strong>a reference to a reference to your struct</strong>, which does <em>not</em> implement the trait:</p>\n\n<pre><code>pub fn start(&amp;self) {\n    // ...\n    mount.mount(\"/\", &amp;self);\n    // ...\n}\n</code></pre>\n\n<p>So that cannot work. You need to restructure your code or implement the trait for a reference to your struct.</p>\n"}], "owner": {"reputation": 2481, "user_id": 327786, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/ZmpBr.jpg?s=128&g=1", "display_name": "TlmaK0", "link": "https://stackoverflow.com/users/327786/tlmak0"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 259, "favorite_count": 0, "accepted_answer_id": 40924299, "answer_count": 1, "score": 2, "last_activity_date": 1480649393, "creation_date": 1480636412, "last_edit_date": 1480649393, "question_id": 40922505, "link": "https://stackoverflow.com/questions/40922505/cannot-create-an-iron-handler-because-the-trait-bound-stdopsfnmut-ironr", "title": "Cannot create an Iron handler because the trait bound std::ops::Fn&lt;(&amp;mut iron::Request)&gt; is not satisfied", "body": "<p>I'm trying to create a handler for Iron requests:</p>\n\n<pre><code>extern crate iron;\nextern crate mount;\n\nuse iron::{Iron, Request, Response, IronResult, status};\nuse mount::Mount;\nuse iron::middleware::Handler;\n\nstruct Server {\n    message: String\n}\n\nimpl Server {\n    pub fn start(&amp;self){\n        let mut mount = Mount::new();\n        mount.mount(\"/\", &amp;self);\n        Iron::new(mount).http(\"0.0.0.0:3000\").unwrap();\n    }\n}\n\nimpl Handler for Server {\n    fn handle(&amp;self, _req: &amp;mut Request) -&gt; IronResult&lt;Response&gt;{\n        Ok(Response::with((status::Ok, self.message)))\n    }\n}\n\nfn main() {\n    Server{message: \"test\".to_string()}.start();\n}\n</code></pre>\n\n<p>but compiler response is:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `for&lt;'r, 'r, 'r&gt; Server: std::ops::Fn&lt;(&amp;'r mut iron::Request&lt;'r, 'r&gt;,)&gt;` is not satisfied\n  --&gt; src/main.rs:15:15\n   |\n15 |         mount.mount(\"/\", &amp;self);\n   |               ^^^^^ trait `for&lt;'r, 'r, 'r&gt; Server: std::ops::Fn&lt;(&amp;'r mut iron::Request&lt;'r, 'r&gt;,)&gt;` not satisfied\n   |\n   = note: required because of the requirements on the impl of `std::ops::FnOnce&lt;(&amp;mut iron::Request&lt;'_, '_&gt;,)&gt;` for `&amp;Server`\n   = note: required because of the requirements on the impl of `iron::Handler` for `&amp;&amp;Server`\n</code></pre>\n\n<p>I was unable to understand what Rust is saying to me.</p>\n"}, {"tags": ["reference", "rust", "mutable"], "answers": [{"tags": [], "owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "is_accepted": true, "score": 16, "last_activity_date": 1480634006, "last_edit_date": 1480634006, "creation_date": 1480633660, "answer_id": 40922057, "question_id": 40921712, "link": "https://stackoverflow.com/questions/40921712/rust-mutable-value-vs-mutable-reference/40922057#40922057", "title": "Rust mutable value vs mutable reference", "body": "<p>Given your simple example of binding a variable to one or the other, then calling <code>println!</code> locally, there really isn't much difference in the result (as you've noted).</p>\n\n<p>A mutable value vs a mutable reference becomes more clear when you cross function boundaries. Have a look at this code:</p>\n\n<pre><code>fn main() {\n    let mut x = &amp;mut 5;\n\n    do_work(x);\n\n    println!(\"{}\", x);\n}\n\nfn do_work(n: &amp;mut u32) {\n    *n += 5;\n}\n</code></pre>\n\n<p>What do you think it prints? <a href=\"https://play.rust-lang.org/?gist=9401bad045be30e8d8a8b9cb0246fff1&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Here it is on the playground</a></p>\n\n<p>Now look at this code:</p>\n\n<pre><code>fn main() {\n    let mut x = 5;\n\n    do_work(x);\n\n    println!(\"{}\", x);\n}\n\nfn do_work(mut n: u32) {\n    n += 5;\n}\n</code></pre>\n\n<p>What do you think this prints? <a href=\"https://play.rust-lang.org/?gist=88049b740c4ef74e54fd23bcbb4bbd49&amp;version=stable&amp;backtrace=0\" rel=\"noreferrer\">Here it is on the playground</a></p>\n\n<p>The answers are:</p>\n\n<p>The top code block prints <code>10</code>. The bottom code block prints <code>5</code>.</p>\n\n<p>Using the mutable reference means you're referencing the place in memory where the variable <code>x</code> is stored. Across function boundaries, you're able to change the value stored in memory there. When the method returns and <code>println!</code> hits.. the value of <code>x</code> is updated.</p>\n\n<p>In this specific example, <code>x</code> is a <code>u32</code>, which implements the <code>Copy</code> trait. When you pass <code>x</code> into the <code>do_work</code> method, a copy of <code>x</code> is made. In the body of the <code>do_work</code> method, <code>n += 5</code> adds 5 <em>to the copy</em> .. and does not reference the original block of memory at all.</p>\n\n<blockquote>\n  <p>...can't decide which one is preferable.</p>\n</blockquote>\n\n<p>That depends entirely on use-case. Do you need to reference the original memory when crossing a function boundary? If you have marked your variable as mutable, there is a high chance that you do want to reference the original memory in the hopes of updating it. In that case, you would use a mutable reference. If you're just mutating a variable locally within a function.. then you won't require a reference.</p>\n"}], "owner": {"reputation": 105, "user_id": 1649010, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/698230fd48286ec5052b0a42b3397079?s=128&d=identicon&r=PG", "display_name": "tbmale", "link": "https://stackoverflow.com/users/1649010/tbmale"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 7355, "favorite_count": 4, "closed_date": 1480642304, "accepted_answer_id": 40922057, "answer_count": 1, "score": 9, "last_activity_date": 1480649910, "creation_date": 1480632012, "last_edit_date": 1480649910, "question_id": 40921712, "link": "https://stackoverflow.com/questions/40921712/rust-mutable-value-vs-mutable-reference", "closed_reason": "Duplicate", "title": "Rust mutable value vs mutable reference", "body": "<p>What is the difference between </p>\n\n<pre><code>let y = &amp;mut 5;\n*y += 1;\nlet x = *y + 1;\n</code></pre>\n\n<p>and</p>\n\n<pre><code>let mut y = 5;\ny += 1;\nlet x = y + 1;\n</code></pre>\n\n<p>They return the same result via <code>println!</code>, but I can't decide which one is preferable.</p>\n"}, {"tags": ["rust", "nodes", "trie", "borrow-checker"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480627344, "post_id": 40920575, "comment_id": 69053442, "body": "What prevents your code from having mutable aliases, which is <a href=\"https://doc.rust-lang.org/stable/book/references-and-borrowing.html#the-rules\" rel=\"nofollow noreferrer\">forbidden in safe Rust</a>?"}, {"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480627648, "post_id": 40920575, "comment_id": 69053574, "body": "@Shepmaster Sorry, forgot to include that. Was in another file. It currently just contains a function definition. I now included it."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480629451, "post_id": 40920575, "comment_id": 69054428, "body": "Are you ready for some deep magic? <a href=\"http://play.integer32.com/?gist=4638635a652364baf0d30038c932d315&amp;version=stable\" rel=\"nofollow noreferrer\">This works</a>. You can find an explanation on the <a href=\"http://stackoverflow.com/q/37986640/155423\">duplicate question</a>."}], "owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 41, "favorite_count": 0, "closed_date": 1480643751, "answer_count": 0, "score": 0, "last_activity_date": 1480627977, "creation_date": 1480627159, "last_edit_date": 1480627977, "question_id": 40920575, "link": "https://stackoverflow.com/questions/40920575/changing-mutable-reference-in-a-loop", "closed_reason": "Duplicate", "title": "Changing mutable reference in a loop", "body": "<p>I'm trying to implement a recursive insertion on a trie but got stuck with the error: \"cannot assign to <code>cur_node</code> because it is borrowed\", \"cannot borrow <code>*cur_node</code> as mutable more than once at a time\".</p>\n\n<pre><code>pub trait Trie {\n    fn insert_word(&amp;mut self, word: &amp;str);\n}\n\npub struct VectorTrie {\n    edges: Vec&lt;Edge&gt;,\n}\n\npub struct Edge {\n    ch: char,\n    to: VectorTrie,\n}\n\nimpl Trie for VectorTrie {\n    fn insert_word(&amp;mut self, word: &amp;str) {\n        let mut cur_node = self;\n        for ch in word.chars() {\n            cur_node = cur_node.get_or_create(ch);\n        }\n    }\n}\n\nimpl VectorTrie {\n    pub fn get_or_create(&amp;mut self, ch: char) -&gt; &amp;mut VectorTrie {\n        match self.edges.binary_search_by(|e| e.ch.cmp(&amp;ch)) {\n            Ok(idx) =&gt; &amp;mut self.edges[idx].to,\n            Err(idx) =&gt; {\n                let to = VectorTrie { edges: Vec::new() };\n                let e = Edge { ch: ch, to: to };\n                self.edges.insert(idx, e);\n                &amp;mut self.edges[idx].to\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>However, what I wanted to do is just to recursively insert the individual characters in a word by taking the <code>Node(\"VectorTrie\")</code> returned by each insertion and continuing to insert the next character to that <code>Node</code>.</p>\n\n<p>No doubt the error is again because I tried to apply C logic to Rust... I'm trying to create the <code>cur_node</code> variable as a temporary reference, modifiable on each loop, though apparently this is not happening here. What should be the idiomatic way to achieve my aim in Rust then?</p>\n"}, {"tags": ["windows", "path", "rust", "filenames"], "answers": [{"tags": [], "owner": {"reputation": 8404, "user_id": 243712, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/5347c683b6963f418d1b16c65917bf3f?s=128&d=identicon&r=PG", "display_name": "poolie", "link": "https://stackoverflow.com/users/243712/poolie"}, "is_accepted": true, "score": 3, "last_activity_date": 1480616606, "creation_date": 1480616606, "answer_id": 40917781, "question_id": 40917780, "link": "https://stackoverflow.com/questions/40917780/how-to-get-the-executable-extension-across-platforms-in-rust/40917781#40917781", "title": "How to get the executable extension across platforms in Rust?", "body": "<p>Yes, <a href=\"https://doc.rust-lang.org/std/env/consts/\" rel=\"nofollow noreferrer\"><code>std::env::consts::EXE_SUFFIX</code></a> will be <code>.exe</code> on Windows, and <a href=\"https://doc.rust-lang.org/std/env/consts/\" rel=\"nofollow noreferrer\"><code>std::env::consts::EXE_EXTENSION</code></a> will be <code>exe</code>.  Both are empty on Unix. </p>\n\n<p>These can be combined with the base name using for example <a href=\"https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.set_extension\" rel=\"nofollow noreferrer\"><code>std::path::PathBuf::set_extension</code></a>.</p>\n"}], "owner": {"reputation": 8404, "user_id": 243712, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/5347c683b6963f418d1b16c65917bf3f?s=128&d=identicon&r=PG", "display_name": "poolie", "link": "https://stackoverflow.com/users/243712/poolie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 106, "favorite_count": 0, "accepted_answer_id": 40917781, "answer_count": 1, "score": 1, "last_activity_date": 1480616606, "creation_date": 1480616606, "question_id": 40917780, "link": "https://stackoverflow.com/questions/40917780/how-to-get-the-executable-extension-across-platforms-in-rust", "title": "How to get the executable extension across platforms in Rust?", "body": "<p>I'm writing portable Rust code to look for a program in some directories.  On Windows I expect it will be <code>foo.exe</code> and elsewhere just <code>foo</code>.  </p>\n\n<p>Obviously I could just use <code>if cfg!(windows)</code> but that seems ugly.  </p>\n\n<p>Is there a better way to find the platform's executable file extension?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1480678937, "post_id": 40915716, "comment_id": 69073656, "body": "This looks like another job for the <a href=\"https://kimundi.github.io/owning-ref-rs/owning_ref/index.html\" rel=\"nofollow noreferrer\"><code>owning_ref</code></a> crate.  It includes a <a href=\"https://kimundi.github.io/owning-ref-rs/owning_ref/type.RwLockWriteGuardRef.html\" rel=\"nofollow noreferrer\"><code>RwLockWriteGuardRef</code></a> type which behaves much like a reference but keeps hold of the guard."}], "answers": [{"comments": [{"owner": {"reputation": 447, "user_id": 595309, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/1939c75d4c2f5ebfdd9901ef2db98b88?s=128&d=identicon&r=PG", "display_name": "John McCrae", "link": "https://stackoverflow.com/users/595309/john-mccrae"}, "edited": false, "score": 0, "creation_date": 1480610718, "post_id": 40915832, "comment_id": 69044135, "body": "So I have to return a <code>LockResult&lt;&amp;mut T&gt;</code> from <code>name()</code>?"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 447, "user_id": 595309, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/1939c75d4c2f5ebfdd9901ef2db98b88?s=128&d=identicon&r=PG", "display_name": "John McCrae", "link": "https://stackoverflow.com/users/595309/john-mccrae"}, "edited": false, "score": 0, "creation_date": 1480611621, "post_id": 40915832, "comment_id": 69044771, "body": "@JohnMcCrae Another would be to design the API along <a href=\"http://stackoverflow.com/a/40853817/1600898\">these lines</a>. That would allow the same interface in parallel and non-parallel case."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 447, "user_id": 595309, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/1939c75d4c2f5ebfdd9901ef2db98b88?s=128&d=identicon&r=PG", "display_name": "John McCrae", "link": "https://stackoverflow.com/users/595309/john-mccrae"}, "edited": false, "score": 0, "creation_date": 1480612742, "post_id": 40915832, "comment_id": 69045474, "body": "@JohnMcCrae: Well, it&#39;s a bit more complicated. Until Rust implements the ability to parameterize an associated type with a lifetime, it&#39;s unfortunately impossible to return different types borrowing <code>Self</code> from different implementations of a trait..."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 6, "last_activity_date": 1480610139, "creation_date": 1480610139, "answer_id": 40915832, "question_id": 40915716, "link": "https://stackoverflow.com/questions/40915716/convert-arcrwlock-to-mut/40915832#40915832", "title": "Convert Arc&lt;RwLock&gt; to &amp;mut", "body": "<p>Have a better look at the interface of <code>RwLock</code>.</p>\n\n<p><a href=\"https://doc.rust-lang.org/std/sync/struct.RwLock.html#method.get_mut\" rel=\"noreferrer\"><code>get_mut</code></a> returns a <code>LockResult&lt;&amp;mut T&gt;</code> which is a guard object. The destruction of this guard automatically unlocks the lock.</p>\n\n<p>In order for things to be safe, the <code>&amp;mut T</code> that you get by calling <code>unwrap()</code> on the guard is <em>borrowing from the guard</em>, that is, the lifetime of the result of <code>unwrap()</code> is limited by that of the guard (since after the guard is destroyed, the lock is unlocked).</p>\n\n<p>And here, you are creating a temporary guard and throwing it away immediately, so the lifetime of the reference cannot exceed that of the function...</p>\n\n<p><strong>Congratz to Rust!</strong> Yet another data race prevented at compile-time :) </p>\n"}], "owner": {"reputation": 447, "user_id": 595309, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/1939c75d4c2f5ebfdd9901ef2db98b88?s=128&d=identicon&r=PG", "display_name": "John McCrae", "link": "https://stackoverflow.com/users/595309/john-mccrae"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1776, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1480611288, "creation_date": 1480609801, "last_edit_date": 1480611288, "question_id": 40915716, "link": "https://stackoverflow.com/questions/40915716/convert-arcrwlock-to-mut", "title": "Convert Arc&lt;RwLock&gt; to &amp;mut", "body": "<p>I am trying to have a value in a trait that can be mutated by means of a reference. The problem is that the <code>String</code> values are very large and may be accessed by many threads, so my solution looks something like this:</p>\n\n<pre><code>trait MyTrait {\n    fn name&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut String;\n}\n\nstruct SimpleImpl {\n    name: String\n}\n\nimpl MyTrait for SimpleImpl {\n    fn name&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut String {\n        &amp;mut self.name\n    }\n}\n\nuse std::sync::{Arc,RwLock};\n\nstruct ParallelImpl {\n    name: Arc&lt;RwLock&lt;String&gt;&gt;\n}\n\nimpl MyTrait for ParallelImpl {\n    fn name&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut String {\n        self.name.get_mut().unwrap()\n    }\n}\n\nfn main() {\n    let mut a = SimpleImpl { name: String::from(\"simple\") };\n    let mut b = ParallelImpl { name: Arc::new(RwLock::new(String::from(\"parallel\"))) };\n\n    a.name().as_mut_str();\n    b.name().as_mut_str();\n}\n</code></pre>\n\n<p>This fails to compile with </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>main2.rs:23:9: 23:18 error: cannot borrow immutable borrowed content as mutable\nmain2.rs:23         self.name.get_mut().unwrap()\n</code></pre>\n\n<p>Why can't I call <code>get_mut()</code> to unwrap both the <code>Arc</code> and the <code>RwLock</code>?</p>\n"}, {"tags": ["string", "split", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480606474, "post_id": 40914319, "comment_id": 69041357, "body": "<i>but that seems to be inefficient</i> \u2014 why do you think that any of your solutions are inefficient? What would make you believe that any answer we give is efficient?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480606719, "post_id": 40914319, "comment_id": 69041510, "body": "Is it always a <i>single</i> letter? Is the letter always <b>guaranteed</b> to be ASCII?"}, {"owner": {"reputation": 403, "user_id": 3554119, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b79421d48f8e4e753ab9ec19b3a964b7?s=128&d=identicon&r=PG&f=1", "display_name": "dirkt", "link": "https://stackoverflow.com/users/3554119/dirkt"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480606905, "post_id": 40914319, "comment_id": 69041647, "body": "@Shepmaster: Yes, it&#39;s always a single letter. It doesn&#39;t really matter if the letter is ASCII or not, but I don&#39;t want to depend on utf-8 encoding issues. I&#39;m new to Rust, so correct me if I&#39;m wrong, but it looks like a final <code>collect()</code> would go through the effort of turning the tail character by character into a new string, instead of just using a slice of the tail. <code>split_at()</code> on the other hand would create two slices, and the first is not needed."}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 0, "creation_date": 1480607784, "post_id": 40914319, "comment_id": 69042297, "body": "@dirkt Is it also part of your requirements to check whether the first character is a letter?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 5, "creation_date": 1480608108, "post_id": 40914319, "comment_id": 69042507, "body": "@dirkt: You <b>need</b> to know the encoding of the data. Bytes without encoding are as good as encrypted, there&#39;s no sane way to extract information out of them."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1480608768, "post_id": 40914319, "comment_id": 69042912, "body": "Note that &quot;creating two slices&quot; is meaningless because a slice is simply a (pointer, length) pair kept on the stack. Creation of a slice is in-line and can be optimized away by the compiler. If in doubt, use the <code>--emit=asm</code> option to check the resulting assembly."}, {"owner": {"reputation": 1721, "user_id": 4268862, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/daefd26c4e8c4ad64790330214dd26d1?s=128&d=identicon&r=PG", "display_name": "Lud", "link": "https://stackoverflow.com/users/4268862/lud"}, "edited": false, "score": 2, "creation_date": 1480611884, "post_id": 40914319, "comment_id": 69044945, "body": "For information, I have a feeling the problem is coming from: <a href=\"http://adventofcode.com/2016/day/1\" rel=\"nofollow noreferrer\">adventofcode.com/2016/day/1</a>"}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 0, "creation_date": 1480644139, "post_id": 40914319, "comment_id": 69059026, "body": "If this is for that, then R or L are the only letters, so it&#39;s def only one byte."}, {"owner": {"reputation": 403, "user_id": 3554119, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b79421d48f8e4e753ab9ec19b3a964b7?s=128&d=identicon&r=PG&f=1", "display_name": "dirkt", "link": "https://stackoverflow.com/users/3554119/dirkt"}, "reply_to_user": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 0, "creation_date": 1480654800, "post_id": 40914319, "comment_id": 69061581, "body": "@SteveKlabnik: The point of the question was to learn proper Rust, not to solve this particular problem. I already solved day 1 in Haskell before I attempted Rust."}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 0, "creation_date": 1480654847, "post_id": 40914319, "comment_id": 69061597, "body": "Totally fair! I didn&#39;t downvote the question or anything, just mentioning it."}], "answers": [{"comments": [{"owner": {"reputation": 403, "user_id": 3554119, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b79421d48f8e4e753ab9ec19b3a964b7?s=128&d=identicon&r=PG&f=1", "display_name": "dirkt", "link": "https://stackoverflow.com/users/3554119/dirkt"}, "edited": false, "score": 0, "creation_date": 1480607267, "post_id": 40914879, "comment_id": 69041930, "body": "How is <code>iter.as_str()</code> implemented? Does it detect that it&#39;s a tail of a string, and just re-use the tail, or does it construct a new <code>str</code>?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 403, "user_id": 3554119, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b79421d48f8e4e753ab9ec19b3a964b7?s=128&d=identicon&r=PG&f=1", "display_name": "dirkt", "link": "https://stackoverflow.com/users/3554119/dirkt"}, "edited": false, "score": 3, "creation_date": 1480607368, "post_id": 40914879, "comment_id": 69042002, "body": "You cannot &quot;construct&quot; a new <code>str</code>. <code>&amp;str</code> is a string slice, it is inherently borrowed. This way you know no copies happen. The relevant documenation is here: <a href=\"https://doc.rust-lang.org/std/str/struct.Chars.html#method.as_str\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/str/struct.Chars.html#method.as_str</a>"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480607897, "post_id": 40914879, "comment_id": 69042367, "body": "whoops, thanks @Shepmaster. Now it&#39;s not so elegant anymore, but still pretty ok."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480607964, "post_id": 40914879, "comment_id": 69042416, "body": "Yeah, but if OP can guarantee that it always starts with a letter, then that check can be removed. Or maybe this is a good opportunity for <a href=\"https://crates.io/crates/boolinator\" rel=\"nofollow noreferrer\">boolinator</a>."}, {"owner": {"reputation": 403, "user_id": 3554119, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b79421d48f8e4e753ab9ec19b3a964b7?s=128&d=identicon&r=PG&f=1", "display_name": "dirkt", "link": "https://stackoverflow.com/users/3554119/dirkt"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480608091, "post_id": 40914879, "comment_id": 69042499, "body": "@Shepmaster: It&#39;s fine either way, I just wanted to understand how to go about this. Nice solution."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1480608154, "post_id": 40914879, "comment_id": 69042542, "body": "haha definitely. I think I once suggested such a thing to be added to the stdlib, but they didn&#39;t like it <a href=\"https://internals.rust-lang.org/t/bool-into-option-closure-yields-none-or-some-closure/1729\" rel=\"nofollow noreferrer\">internals.rust-lang.org/t/&hellip;</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480608370, "post_id": 40914879, "comment_id": 69042678, "body": "Could always <a href=\"http://play.integer32.com/?gist=264a54ae9bad51237e3607ee587103e4&amp;version=stable\" rel=\"nofollow noreferrer\">make the little function</a>, too."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 6, "last_activity_date": 1480607862, "last_edit_date": 1480607862, "creation_date": 1480607140, "answer_id": 40914879, "question_id": 40914319, "link": "https://stackoverflow.com/questions/40914319/how-do-i-parse-a-string-consisting-of-a-letter-and-number-idiomatically-and-effi/40914879#40914879", "title": "How do I parse a string consisting of a letter and number idiomatically and efficiently in Rust?", "body": "<p>Since you do not care about the error, I assume you want a function of the signature <code>fn(&amp;str) -&gt; Option&lt;(char, u32)&gt;</code>. You can use the fact that <code>.chars()</code> returns an iterator that you can turn back into a <code>&amp;str</code> that contains the rest of the iterator:</p>\n\n<pre><code>fn parse(s: &amp;str) -&gt; Option&lt;(char, i32)&gt; {\n    let mut iter = s.chars();\n    iter.next().and_then(|c| {\n        if c.is_alphabetic() {\n            iter.as_str().parse().ok().map(|i| {\n                (c, i)\n            })\n        } else {\n            None\n        }\n    })\n}\n</code></pre>\n\n<p><code>println!(\"{:?}\", parse(\"R1234\"))</code> will print <code>Some(('R', 1234))</code></p>\n"}], "owner": {"reputation": 403, "user_id": 3554119, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b79421d48f8e4e753ab9ec19b3a964b7?s=128&d=identicon&r=PG&f=1", "display_name": "dirkt", "link": "https://stackoverflow.com/users/3554119/dirkt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 78, "favorite_count": 0, "accepted_answer_id": 40914879, "answer_count": 1, "score": 1, "last_activity_date": 1480607981, "creation_date": 1480605721, "last_edit_date": 1480607399, "question_id": 40914319, "link": "https://stackoverflow.com/questions/40914319/how-do-i-parse-a-string-consisting-of-a-letter-and-number-idiomatically-and-effi", "title": "How do I parse a string consisting of a letter and number idiomatically and efficiently in Rust?", "body": "<p>I have a string with a letter followed by a number, like \"R123\". The letter is <strong>not</strong> guaranteed to be ASCII, and the solution should not depend on the utf-8 encoding. How do I extract the first letter from it, while converting the the number into an integer type? And of course I want this to be idiomatic and efficient.</p>\n\n<p>I tried several things: If I use <code>char_indices()</code>, I can <code>split_at()</code> the position after iterating once, but then I get the first part again. I can also use <code>chars()</code> and <code>collect()</code> the tail, but that seems to be inefficient.</p>\n\n<p>I also want to handle errors in an elegant way: I don't want to check for every possible combination (letter but no number, etc.), an \"all or nothing\" result is fine.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 133611, "user_id": 152602, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7f370b4bd787fc68f9f62d9c6781cb79?s=128&d=identicon&r=PG", "display_name": "Lee", "link": "https://stackoverflow.com/users/152602/lee"}, "edited": false, "score": 1, "creation_date": 1480587555, "post_id": 40907897, "comment_id": 69028387, "body": "What&#39;s the question?"}, {"owner": {"reputation": 37324, "user_id": 513198, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/edf7f2190e60b6470bb6e4aab30152e7?s=128&d=identicon&r=PG", "display_name": "Xavier T.", "link": "https://stackoverflow.com/users/513198/xavier-t"}, "reply_to_user": {"reputation": 133611, "user_id": 152602, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7f370b4bd787fc68f9f62d9c6781cb79?s=128&d=identicon&r=PG", "display_name": "Lee", "link": "https://stackoverflow.com/users/152602/lee"}, "edited": false, "score": 0, "creation_date": 1480588249, "post_id": 40907897, "comment_id": 69028866, "body": "I don&#39;t understand in which case you should use Option&lt;&gt;.iter(), I got maybe wrongly the feeling that it will always return a single item."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480601904, "post_id": 40907897, "comment_id": 69038002, "body": "@XavierT. <code>Option::iter</code> is designed for cases where you want to treat the option as a zero-or-one-element container. It doesn&#39;t seem very useful to me either, but that&#39;s the idea."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480602121, "post_id": 40907897, "comment_id": 69038165, "body": "@user4815162342 <code>let foo: Vec&lt;Option&lt;T&gt; = vec![]; let bar: Vec&lt;T&gt; = foo.into_iter().flat_map(|x| x).collect();</code>."}], "answers": [{"comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 3, "creation_date": 1480589044, "post_id": 40908336, "comment_id": 69029462, "body": "instead of <code>unwrap</code> one could also simply wrap <code>if let Some(ref v) = foo.people {}</code> around the iteration"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1480589249, "post_id": 40908336, "comment_id": 69029595, "body": "@ker That&#39;s another option (no pun intended), but it does require an additional indentation level around the loop. <code>unwrap()</code> is still useful when the code actually expects the option to be non-<code>None</code> and wants to assert that."}, {"owner": {"reputation": 17388, "user_id": 921321, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3f4c4737cb30134f58cc76f06ef5113a?s=128&d=identicon&r=PG", "display_name": "Lukazoid", "link": "https://stackoverflow.com/users/921321/lukazoid"}, "edited": false, "score": 7, "creation_date": 1480601141, "post_id": 40908336, "comment_id": 69037431, "body": "If I always wanted to iterate over the people I would probably do <code>foo.people.iter().flat_map(|v|v.iter())</code>, <code>None</code> would give an empty iterator while otherwise we would give all the elements of the vector."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 17388, "user_id": 921321, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3f4c4737cb30134f58cc76f06ef5113a?s=128&d=identicon&r=PG", "display_name": "Lukazoid", "link": "https://stackoverflow.com/users/921321/lukazoid"}, "edited": false, "score": 5, "creation_date": 1480602208, "post_id": 40908336, "comment_id": 69038245, "body": "@Lukazoid no need for <code>v.iter()</code>; just <code>v</code> will work."}, {"owner": {"reputation": 17388, "user_id": 921321, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3f4c4737cb30134f58cc76f06ef5113a?s=128&d=identicon&r=PG", "display_name": "Lukazoid", "link": "https://stackoverflow.com/users/921321/lukazoid"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480604511, "post_id": 40908336, "comment_id": 69039945, "body": "@Shepmaster I didn&#39;t spot that <code>flat_map</code> handles <code>IntoIterator</code>, even better then."}, {"owner": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "reply_to_user": {"reputation": 17388, "user_id": 921321, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3f4c4737cb30134f58cc76f06ef5113a?s=128&d=identicon&r=PG", "display_name": "Lukazoid", "link": "https://stackoverflow.com/users/921321/lukazoid"}, "edited": false, "score": 0, "creation_date": 1589143805, "post_id": 40908336, "comment_id": 109170268, "body": "@Lukazoid You should answer that. <code>foo.people.iter().flat_map(identity)</code> is a better way to iterate IMO."}, {"owner": {"reputation": 17388, "user_id": 921321, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3f4c4737cb30134f58cc76f06ef5113a?s=128&d=identicon&r=PG", "display_name": "Lukazoid", "link": "https://stackoverflow.com/users/921321/lukazoid"}, "reply_to_user": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "edited": false, "score": 0, "creation_date": 1589151346, "post_id": 40908336, "comment_id": 109172574, "body": "@Boiethios You mean the <code>identity</code> function added 2 years after my comment? Edit: Oh you mean add as an additional answer? Sorry I misunderstood"}, {"owner": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "reply_to_user": {"reputation": 17388, "user_id": 921321, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3f4c4737cb30134f58cc76f06ef5113a?s=128&d=identicon&r=PG", "display_name": "Lukazoid", "link": "https://stackoverflow.com/users/921321/lukazoid"}, "edited": false, "score": 0, "creation_date": 1589177067, "post_id": 40908336, "comment_id": 109178085, "body": "@Lukazoid I meant the solution, whatever if you type <code>|v| v</code> or <code>identity</code>: that&#39;s still beter than an <code>unwrap</code> or an <code>unwrap_or_else(Vec::new)</code>."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "edited": false, "score": 0, "creation_date": 1589178491, "post_id": 40908336, "comment_id": 109178582, "body": "@Boiethios It&#39;s not (stylistically) better than an <code>unwrap</code> because it has different behavior. I argue that it&#39;s not better than <code>unwrap_or_else</code> either because <code>unwrap_or_else</code> makes it clearer what&#39;s going on without relying on <code>Option</code> acting like a container. (Also, <code>Vec::new()</code> is guaranteed not to allocate, so there should be no performance lost in the <code>None</code> case.) Judging by the generated assembly (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=0cb79cdfaad105f1ea06e89684c33231\" rel=\"nofollow noreferrer\">playground</a>), the <code>unwrap_or_else</code> version is more efficient as well."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 8, "last_activity_date": 1589143355, "last_edit_date": 1589143355, "creation_date": 1480588485, "answer_id": 40908336, "question_id": 40907897, "link": "https://stackoverflow.com/questions/40907897/iterator-on-optionvec/40908336#40908336", "title": "Iterator on Option&lt;Vec&lt;&gt;&gt;", "body": "<p><code>Option</code> has an <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.iter\" rel=\"nofollow noreferrer\"><code>iter</code> method</a> that \"iterates over the possibly contained value\", i.e. provides either the single value in the <code>Option</code> (if option is <code>Some</code>), or no values at all (if the option is <code>None</code>). As such it is useful if you want to treat the option as a container where <code>None</code> means the container is empty and <code>Some</code> means it contains a single element.</p>\n\n<p>To iterate over the underlying element's values, you need to switch from <code>foo.people.iter()</code> to either <code>foo.people.unwrap().iter()</code> or <code>foo.people.unwrap_or_else(Vec::new).iter()</code>, depending on whether you want the program to panic or to not iterate when encountering <code>None</code> people.</p>\n\n<p>Compilable example <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=ca0da6a1d400db8e9fc58a0d1e27eb3c\" rel=\"nofollow noreferrer\">in the playground</a>.</p>\n"}, {"tags": [], "owner": {"reputation": 17388, "user_id": 921321, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3f4c4737cb30134f58cc76f06ef5113a?s=128&d=identicon&r=PG", "display_name": "Lukazoid", "link": "https://stackoverflow.com/users/921321/lukazoid"}, "is_accepted": false, "score": 6, "last_activity_date": 1589151586, "creation_date": 1589151586, "answer_id": 61719820, "question_id": 40907897, "link": "https://stackoverflow.com/questions/40907897/iterator-on-optionvec/61719820#61719820", "title": "Iterator on Option&lt;Vec&lt;&gt;&gt;", "body": "<p>As mentioned in comments to another answer, I would use the following:</p>\n\n<pre><code>foo.people.iter().flat_map(identity)\n</code></pre>\n\n<p>The <code>iter</code> method on <code>Option&lt;T&gt;</code> will return an iterator of one or zero elements, the <code>flat_map</code> then takes each element (in this case <code>Vec&lt;Person&gt;</code>) and flattens their nested elements resulting in an <code>Iterator&lt;Item = Person&gt;</code>.</p>\n"}], "owner": {"reputation": 37324, "user_id": 513198, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/edf7f2190e60b6470bb6e4aab30152e7?s=128&d=identicon&r=PG", "display_name": "Xavier T.", "link": "https://stackoverflow.com/users/513198/xavier-t"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3696, "favorite_count": 0, "accepted_answer_id": 40908336, "answer_count": 2, "score": 4, "last_activity_date": 1589151586, "creation_date": 1480587378, "last_edit_date": 1480599170, "question_id": 40907897, "link": "https://stackoverflow.com/questions/40907897/iterator-on-optionvec", "title": "Iterator on Option&lt;Vec&lt;&gt;&gt;", "body": "<p>I am trying to iterate on on <code>Option&lt;Vec&lt;&gt;&gt;</code>.</p>\n\n<pre><code>#[derive(Debug)]\npub struct Person {\n    pub name: Option&lt;String&gt;,\n    pub age: Option&lt;u64&gt;,\n}\n\n#[derive(Debug)]\npub struct Foo {\n    pub people: Option&lt;Vec&lt;Person&gt;&gt;,\n}\n</code></pre>\n\n<p>Naively I am using</p>\n\n<pre><code>for i in foo.people.iter() {\n    println!(\"{:?}\", i);\n}\n</code></pre>\n\n<p>Instead of iterating over all the elements of the <code>Vec</code>, I am actually displaying the whole <code>Vec</code>. It is like I am iterating over the only reference of the <code>Option</code>.</p>\n\n<p>Using the following, I am iterating over the <code>Vec</code> content:</p>\n\n<pre><code>for i in foo.people.iter() {\n    for j in i.iter() {\n        println!(\"{:?}\", j);\n    }\n}\n</code></pre>\n\n<p>I am not sure this is the most pleasant syntax, I believe you should unwrap the <code>Option</code> first to actually iterate on the collection.</p>\n\n<p>Then I don't see where you can actually use <code>Option::iter</code>, if you always have a single reference.</p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=f0cba97a3915f2cf8686794a1a41627e&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Here</a> is the link to the playground.</p>\n"}, {"tags": ["rust", "linear-algebra"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1591014434, "last_edit_date": 1591014434, "creation_date": 1480560919, "answer_id": 40901876, "question_id": 40901735, "link": "https://stackoverflow.com/questions/40901735/how-to-access-individual-elements-of-a-nalgebra-matrix-in-rust/40901876#40901876", "title": "How to access individual elements of a nalgebra matrix in Rust?", "body": "<p>Check <a href=\"https://docs.rs/nalgebra/0.21.0/nalgebra/base/struct.Matrix.html#method.index\" rel=\"nofollow noreferrer\">the documentation for <code>Matrix::index</code></a>:</p>\n\n<pre><code>pub fn index&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; I::Output\nwhere\n    I: MatrixIndex&lt;'a, N, R, C, S&gt;, \n</code></pre>\n\n<p>If we look at the <a href=\"https://docs.rs/nalgebra/0.21.0/nalgebra/base/indexing/trait.MatrixIndex.html\" rel=\"nofollow noreferrer\">implementers of <code>MatrixIndex</code></a>, we see many types, including a <em>tuple</em> of <code>usize</code> (<code>(usize, usize)</code>):</p>\n\n<pre><code>println!(\"{:?}\", b[(0, 1)]);\n</code></pre>\n\n<p><a href=\"https://doc.rust-lang.org/stable/book/ch03-02-data-types.html#the-tuple-type\" rel=\"nofollow noreferrer\"><em>The Rust Programming Language</em> chapter on data types</a> further explains tuples. </p>\n"}], "owner": {"reputation": 7076, "user_id": 1610428, "user_type": "registered", "accept_rate": 75, "profile_image": "https://i.stack.imgur.com/e6gnk.jpg?s=128&g=1", "display_name": "krishnab", "link": "https://stackoverflow.com/users/1610428/krishnab"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1092, "favorite_count": 0, "accepted_answer_id": 40901876, "answer_count": 1, "score": 3, "last_activity_date": 1591014491, "creation_date": 1480559864, "last_edit_date": 1591014491, "question_id": 40901735, "link": "https://stackoverflow.com/questions/40901735/how-to-access-individual-elements-of-a-nalgebra-matrix-in-rust", "title": "How to access individual elements of a nalgebra matrix in Rust?", "body": "<p>I am trying to access the individual elements of an nalgebra matrix in Rust, but keep getting an error. I have not found any examples in the documentation that show how to access individual elements either \u2014 as I would with some multidimensional array.</p>\n\n<p>Here is what I have been trying:</p>\n\n<pre><code>use nalgebra::DMatrix; // 0.21.0\n\nfn main() {\n    let b = DMatrix::&lt;f64&gt;::zeros(4, 4);\n    println!(\"{:?}\", b[0][1]);\n}\n</code></pre>\n\n<p>When I compile this code, I get</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0608]: cannot index into a value of type `f64`\n --&gt; src/main.rs:5:22\n  |\n5 |     println!(\"{:?}\", b[0][1]);\n  |                      ^^^^^^^\n</code></pre>\n\n<p>I am not sure how to interpret this message, or where I am going wrong. </p>\n"}, {"tags": ["sockets", "unix", "docker", "rust", "daemon"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480553075, "post_id": 40900625, "comment_id": 69015359, "body": "Try ...`HTTP/1.1\\r\\n\\r\\n&quot;."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480553199, "post_id": 40900625, "comment_id": 69015390, "body": "Probable duplicate of <a href=\"http://stackoverflow.com/q/6686261/155423\">stackoverflow.com/q/6686261/155423</a>"}, {"owner": {"reputation": 29, "user_id": 3773243, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17e5839627d5e0d77114b16ccb6a11b3?s=128&d=identicon&r=PG&f=1", "display_name": "user3773243", "link": "https://stackoverflow.com/users/3773243/user3773243"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480598187, "post_id": 40900625, "comment_id": 69035401, "body": "My issue is : I get no response. That&#39;s it. No error message. The program doesn&#39;t terminate."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480599427, "post_id": 40900625, "comment_id": 69036259, "body": "And what happens when you make the suggested change?"}, {"owner": {"reputation": 29, "user_id": 3773243, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17e5839627d5e0d77114b16ccb6a11b3?s=128&d=identicon&r=PG&f=1", "display_name": "user3773243", "link": "https://stackoverflow.com/users/3773243/user3773243"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480628494, "post_id": 40900625, "comment_id": 69053967, "body": "No it&#39;s not the solution. Your previous link helped me. Thx."}, {"owner": {"reputation": 29, "user_id": 3773243, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17e5839627d5e0d77114b16ccb6a11b3?s=128&d=identicon&r=PG&f=1", "display_name": "user3773243", "link": "https://stackoverflow.com/users/3773243/user3773243"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480629056, "post_id": 40900625, "comment_id": 69054236, "body": "I forgot : thank you for the kindness."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480629092, "post_id": 40900625, "comment_id": 69054249, "body": "You are quite welcome."}], "owner": {"reputation": 29, "user_id": 3773243, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17e5839627d5e0d77114b16ccb6a11b3?s=128&d=identicon&r=PG&f=1", "display_name": "user3773243", "link": "https://stackoverflow.com/users/3773243/user3773243"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 62, "favorite_count": 0, "closed_date": 1480628612, "answer_count": 0, "score": 0, "last_activity_date": 1480599407, "creation_date": 1480551886, "last_edit_date": 1480599407, "question_id": 40900625, "link": "https://stackoverflow.com/questions/40900625/accessing-docker-daemon-with-rust-doesnt-work", "closed_reason": "Duplicate", "title": "Accessing Docker daemon with Rust doesn&#39;t work", "body": "<p>I'd like to send a request to my Docker daemon with Rust but it doesn't work:</p>\n\n<pre><code>use std::os::unix::net::UnixStream;\nuse std::io::prelude::*;\n\nfn main() {\n    let mut stream = UnixStream::connect(\"/var/run/docker.sock\").unwrap();\n    stream.write_all(b\"GET /containers/json HTTP/1.1\\r\\n\").unwrap();\n    let mut response = String::new();\n    stream.read_to_string(&amp;mut response).unwrap();\n    println!(\"{}\", response);\n}\n</code></pre>\n\n<p>I get no response, no error message. The program doesn't terminate.</p>\n"}]