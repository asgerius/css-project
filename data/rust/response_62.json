[{"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1458171648, "post_id": 36048741, "comment_id": 59746464, "body": "<a href=\"http://is.gd/j8aovB\" rel=\"nofollow noreferrer\">A smaller reproduction</a>."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 1, "creation_date": 1458180219, "post_id": 36048741, "comment_id": 59749016, "body": "I guess &quot;using a moved value&quot; can be interpreted as the point at which you try and read the value of it. Assigning to it doesn&#39;t really change the guarantees of Rust in a &quot;technical&quot; sense, only when you try and consume a moved value. That said, I don&#39;t understand most of this well enough myself so I am interested to hear from people who are more across this."}, {"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "edited": false, "score": 0, "creation_date": 1458181979, "post_id": 36048741, "comment_id": 59749568, "body": "Feels like compiller bug. More interesting thing is that <code>let p2 = point;     point.x = 0.5;     println!(&quot; x is {}&quot;, p2.x);</code> compiles fine and prints 0.3, so <code>point.x = 0.5;</code> does nothng"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "edited": false, "score": 1, "creation_date": 1458184341, "post_id": 36048741, "comment_id": 59750181, "body": "@qthree That&#39;s entirely to be expected; Rust uses value types, not reference types."}], "answers": [{"comments": [{"owner": {"reputation": 7455, "user_id": 5432501, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/8MGE3.png?s=128&g=1", "display_name": "Alex Knauth", "link": "https://stackoverflow.com/users/5432501/alex-knauth"}, "edited": false, "score": 0, "creation_date": 1458188017, "post_id": 36051503, "comment_id": 59751048, "body": "Why do you have another <code>let mut point</code> within the nested block? Doesn&#39;t that change the problem because the point you&#39;re assigning to is a new point, in a different place in memory from the one that was dropped?"}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 7455, "user_id": 5432501, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/8MGE3.png?s=128&g=1", "display_name": "Alex Knauth", "link": "https://stackoverflow.com/users/5432501/alex-knauth"}, "edited": false, "score": 1, "creation_date": 1458188418, "post_id": 36051503, "comment_id": 59751159, "body": "@AlexKnauth I think the idea is to point out whats happening as the compiler sees it. That is, that the compiler sees that extra scope there with its own &quot;point&quot; which is allowing the assignment."}, {"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "edited": false, "score": 0, "creation_date": 1458188449, "post_id": 36051503, "comment_id": 59751166, "body": "Because <code>point.x = 0.5;</code> in original code does nothing with moved value, but tries to initialize new value."}, {"owner": {"reputation": 7455, "user_id": 5432501, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/8MGE3.png?s=128&g=1", "display_name": "Alex Knauth", "link": "https://stackoverflow.com/users/5432501/alex-knauth"}, "edited": false, "score": 0, "creation_date": 1458188833, "post_id": 36051503, "comment_id": 59751290, "body": "But in the original code that scope wasn&#39;t there, and it didn&#39;t create a new <code>point</code> variable, but assigned to the old dropped <code>point</code>. Or am I misunderstanding how this works?"}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 7455, "user_id": 5432501, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/8MGE3.png?s=128&g=1", "display_name": "Alex Knauth", "link": "https://stackoverflow.com/users/5432501/alex-knauth"}, "edited": false, "score": 1, "creation_date": 1458189039, "post_id": 36051503, "comment_id": 59751349, "body": "@AlexKnauth You&#39;re correct in that it wasn&#39;t there in the original code. I think qthree&#39;s intent here is to show what the compiler sees.. the compiler sees the OP&#39;s code as if this extra scope was there. Which is why the assignment works, but the <code>println!</code> line doesn&#39;t."}, {"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "reply_to_user": {"reputation": 7455, "user_id": 5432501, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/8MGE3.png?s=128&g=1", "display_name": "Alex Knauth", "link": "https://stackoverflow.com/users/5432501/alex-knauth"}, "edited": false, "score": 0, "creation_date": 1458189423, "post_id": 36051503, "comment_id": 59751471, "body": "@AlexKnauth Old dropped point already moved and can&#39;t be accessed, the issue is that compiler allow partly initialize new value with old name, but even if you assign all fields it&#39;s still will not be fully initialized and in same time will be out of scope."}, {"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 0, "creation_date": 1458199303, "post_id": 36051503, "comment_id": 59755245, "body": "@qthree Your explanation is wrong. The <code>let mut point</code> inside a nested scope creates another <code>Point</code> variable somewhere else, and its scope ends before the <code>println!</code>, which is different from the OPs code. The real issue is just the compiler bug / misfeature described in <a href=\"https://github.com/rust-lang/rust/issues/21232\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/21232</a> ."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458204050, "post_id": 36051503, "comment_id": 59757885, "body": "@qthree: Rust allows shadowing in the same scope; so to be less confusing I would simply remove the extra scope."}, {"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458205823, "post_id": 36051503, "comment_id": 59759041, "body": "@MatthieuM. then you will get <code>use of possibly uninitialized variable: &#39;point.x&#39;</code>. That bug is especially about trying partly initialize new value, while keeping old moved value in scope."}], "tags": [], "owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "is_accepted": true, "score": 6, "last_activity_date": 1523307425, "last_edit_date": 1523307425, "creation_date": 1458187693, "answer_id": 36051503, "question_id": 36048741, "link": "https://stackoverflow.com/questions/36048741/why-does-compilation-not-fail-when-a-member-of-a-moved-value-is-assigned-to/36051503#36051503", "title": "Why does compilation not fail when a member of a moved value is assigned to?", "body": "<p>What really happens</p>\n\n<pre><code>fn main() {\n    let mut point: Point = Point { x: 0.3, y: 0.4 };\n    println!(\"point coordinates: ({}, {})\", point.x, point.y);\n\n    drop(point);\n\n    {\n        let mut point: Point;\n        point.x = 0.5;\n    }\n\n    println!(\" x is {}\", point.x);\n}\n</code></pre>\n\n<p>It turns out that it's already known as <a href=\"https://github.com/rust-lang/rust/issues/21232\" rel=\"nofollow noreferrer\">issue #21232</a>.</p>\n"}, {"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458305428, "post_id": 36081244, "comment_id": 59813902, "body": "I&#39;m unclear on what this answer provides beyond <a href=\"http://stackoverflow.com/a/36051503/155423\">the existing answer</a>"}, {"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1458307378, "post_id": 36081244, "comment_id": 59815394, "body": "@Shepmaster It removes the part that is wrong. As a bonus I added a brief explanation of the issue, as just posting a link is bad form."}], "tags": [], "owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "is_accepted": false, "score": 4, "last_activity_date": 1523307634, "last_edit_date": 1523307634, "creation_date": 1458294909, "answer_id": 36081244, "question_id": 36048741, "link": "https://stackoverflow.com/questions/36048741/why-does-compilation-not-fail-when-a-member-of-a-moved-value-is-assigned-to/36081244#36081244", "title": "Why does compilation not fail when a member of a moved value is assigned to?", "body": "<p>The problem is that the compiler allows partial reinitialization of a struct, but the whole struct is unusable after that. This happens even if the struct contains only a single field, and even if you only try to read the field you just reinitialized.</p>\n\n<pre><code>struct Test {\n    f: u32,\n}\n\nfn main() {\n    let mut t = Test { f: 0 };\n    let t1 = t;\n    t.f = 1;\n    println!(\"{}\", t.f);\n}\n</code></pre>\n\n<p>This is discussed in <a href=\"https://github.com/rust-lang/rust/issues/21232\" rel=\"nofollow noreferrer\">issue 21232</a></p>\n"}], "owner": {"reputation": 10129, "user_id": 95396, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/3fafc0390e40bf6e659c54dd968b3713?s=128&d=identicon&r=PG", "display_name": "andy boot", "link": "https://stackoverflow.com/users/95396/andy-boot"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 460, "favorite_count": 2, "accepted_answer_id": 36051503, "answer_count": 2, "score": 11, "last_activity_date": 1523307634, "creation_date": 1458169955, "last_edit_date": 1523307351, "question_id": 36048741, "link": "https://stackoverflow.com/questions/36048741/why-does-compilation-not-fail-when-a-member-of-a-moved-value-is-assigned-to", "title": "Why does compilation not fail when a member of a moved value is assigned to?", "body": "<p>I am working through examples in <a href=\"http://rustbyexample.com/\" rel=\"nofollow noreferrer\">Rust by Example</a>.</p>\n\n<pre><code>#[derive(Debug)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n#[derive(Debug)]\nstruct Rectangle {\n    p1: Point,\n    p2: Point,\n}\n\nfn main() {\n    let mut point: Point = Point { x: 0.3, y: 0.4 };\n    println!(\"point coordinates: ({}, {})\", point.x, point.y);\n\n    let rectangle = Rectangle {\n        p1: Point { x: 1.0, y: 1.0 },\n        p2: point,\n    };\n\n    point.x = 0.5; // Why does the compiler not break here,\n    println!(\" x is {}\", point.x); // but it breaks here?\n\n    println!(\"rectangle is {:?} \", rectangle);\n}\n</code></pre>\n\n<p>I get this error (Rust 1.25.0):</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of moved value: `point.x`\n  --&gt; src/main.rs:23:26\n   |\n19 |         p2: point,\n   |             ----- value moved here\n...\n23 |     println!(\" x is {}\", point.x);\n   |                          ^^^^^^^ value used here after move\n   |\n   = note: move occurs because `point` has type `Point`, which does not implement the `Copy` trait\n</code></pre>\n\n<p>I understand that I gave <code>point</code> to the <code>Rectangle</code> object and that is why I can no longer access it, but why does the compilation fail on the <code>println!</code> and not the assignment on the previous line?</p>\n"}, {"tags": ["rust", "rust-cargo"], "answers": [{"tags": [], "owner": {"reputation": 3822, "user_id": 91585, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/58b7ea3d38398e9e2882d23f57762cb6?s=128&d=identicon&r=PG", "display_name": "Florian Doyon", "link": "https://stackoverflow.com/users/91585/florian-doyon"}, "is_accepted": true, "score": 2, "last_activity_date": 1458240143, "creation_date": 1458240143, "answer_id": 36069106, "question_id": 36048449, "link": "https://stackoverflow.com/questions/36048449/mixing-static-and-dynamic-libraries-in-rust-ffi/36069106#36069106", "title": "Mixing static and dynamic libraries in Rust FFI", "body": "<p>The issue is a conflict between the <code>#[link]</code> attribute in the FFI definition and the output of the <code>build.rs</code> build script. </p>\n\n<p>It would seem that the <code>#[link]</code> attribute is instructing <code>rustc</code> to ignore the <code>cargo:rustc-link-*</code> instructions. </p>\n\n<p>The fix was as simple as removing the <code>#[link]</code> attribute.</p>\n"}], "owner": {"reputation": 3822, "user_id": 91585, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/58b7ea3d38398e9e2882d23f57762cb6?s=128&d=identicon&r=PG", "display_name": "Florian Doyon", "link": "https://stackoverflow.com/users/91585/florian-doyon"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1132, "favorite_count": 1, "accepted_answer_id": 36069106, "answer_count": 1, "score": 4, "last_activity_date": 1458240143, "creation_date": 1458168575, "last_edit_date": 1458171104, "question_id": 36048449, "link": "https://stackoverflow.com/questions/36048449/mixing-static-and-dynamic-libraries-in-rust-ffi", "title": "Mixing static and dynamic libraries in Rust FFI", "body": "<p>My executable Rust crate uses a native library <code>libfoo.a</code> which depends on a shared library <code>libbar.so</code>, but does not expose it at all.</p>\n\n<p>My Rust FFI uses the methods from libfoo, so I defined a <code>link</code> attribute on my extern code::</p>\n\n<pre><code>#[link(name=\"foo\", kind=\"static\")]\nextern \"C\"{\n    pub fn do_foo();\n}\n</code></pre>\n\n<p>and my <code>build.rs</code> included from <code>Cargo.toml</code> using <code>build=\"build.rs\"</code></p>\n\n<pre><code>fn main() {\n    let libs = &amp;[(Some(\"../libs/foo/1.0/\"), \"static=foo\"), // use ../libs/foo/1.0/libfoo.a\n                 (None, \"bar\")]; // use libbar.so using LD_LIBRARY_PATH\n    for &amp;(ref m_path, ref lib) in libs {\n        if let &amp;Some(static_path) = m_path {\n            println!(\"cargo:rustc-link-search={}\", &amp;static_path);\n        }\n        println!(\"cargo:rustc-link-lib={}\", &amp;lib);\n    }\n}\n</code></pre>\n\n<p>which outputs</p>\n\n<pre><code>cargo:rustc-link-search=../libs/foo/1.0/\ncargo:rustc-link-lib=static=foo\ncargo:rustc-link-lib=bar\n</code></pre>\n\n<p>Theoretically, I expect Rust to link against <code>libfoo.a</code> and <code>libbar.so</code>. The problem is that rustc does not even try to acknowledge <code>libbar</code>. </p>\n\n<p><code>cargo build --debug</code> ends with</p>\n\n<pre><code>/home/author/src/foo/foo.c:21: undefined reference to 'bar_do_stuff'\ncollect2: error: ld returned 1 exit status\n</code></pre>\n\n<p>When I inspect the linker command, there is an <code>-L ../libs/foo/1.0</code> argument, as well as <code>-l foo</code>, but there is no trace of <code>-l bar</code> !</p>\n\n<p>If I manually add the <code>-l bar</code> to <code>cc</code>, it builds (and runs) just fine.</p>\n\n<p>Could you let me know what I am missing? Should I create an FFI binding for <code>libbar</code> even though I don't use it in Rust and it is not exposed from libfoo's API?</p>\n"}, {"tags": ["rust", "stack-overflow"], "comments": [{"owner": {"reputation": 30697, "user_id": 31667, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/082b069c287878a1bd5731f44c8f10e7?s=128&d=identicon&r=PG", "display_name": "viraptor", "link": "https://stackoverflow.com/users/31667/viraptor"}, "edited": false, "score": 1, "creation_date": 1458172422, "post_id": 36041974, "comment_id": 59746721, "body": "Have you tried with <code>RUST_BACKTRACE=1 cargo test</code> ? (I&#39;m not sure if it displays anything extra at stack overflow, but it does on other panics)"}], "answers": [{"tags": [], "owner": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "is_accepted": false, "score": 9, "last_activity_date": 1529547043, "last_edit_date": 1529547043, "creation_date": 1458147102, "answer_id": 36042050, "question_id": 36041974, "link": "https://stackoverflow.com/questions/36041974/is-there-any-standard-methodology-for-debugging-a-stack-overflow-in-rust/36042050#36042050", "title": "Is there any standard methodology for debugging a stack overflow in Rust?", "body": "<p>The simple answer is to use GDB:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ gdb --args target/debug/partition_ops-b31bcf7b82e2e8d5\n...\n(gdb) run\nStarting program: /home/dhardy/other/pippin/target/debug/partition_ops-b31bcf7b82e2e8d5 \nMissing separate debuginfos, use: dnf debuginfo-install glibc-2.22-7.fc23.x86_64\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib64/libthread_db.so.1\".\n\nrunning 1 test\n[New Thread 0x7ffff67ff700 (LWP 30769)]\n[New Thread 0x7ffff5fff700 (LWP 30770)]\n\nProgram received signal SIGSEGV, Segmentation fault.\n[Switching to Thread 0x7ffff5fff700 (LWP 30770)]\n0x00005555555f8a96 in pippin::detail::elt::PartId::from_num (n=1099511627775) at src/detail/elt.rs:36\n36              assert!(n &gt; 0 &amp;&amp; n &lt;= Self::max().into_num(), \"PartId::from_num(n): n is invalid\");\nMissing separate debuginfos, use: dnf debuginfo-install libgcc-5.3.1-2.fc23.x86_64\n(gdb) bt\n#0  0x00005555555f8a96 in pippin::detail::elt::PartId::from_num (n=1099511627775) at src/detail/elt.rs:36\n#1  0x00005555555f8b57 in pippin::detail::elt::PartId::max () at src/detail/elt.rs:56\n#2  0x00005555555f8ab3 in pippin::detail::elt::PartId::from_num (n=1099511627775) at src/detail/elt.rs:36\n#3  0x00005555555f8b57 in pippin::detail::elt::PartId::max () at src/detail/elt.rs:56\n...\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 25982, "user_id": 305973, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/cd49db0b676767ea4358b1047c4cddd2?s=128&d=identicon&r=PG", "display_name": "robinst", "link": "https://stackoverflow.com/users/305973/robinst"}, "is_accepted": false, "score": 4, "last_activity_date": 1529547049, "last_edit_date": 1529547049, "creation_date": 1529545032, "answer_id": 50959179, "question_id": 36041974, "link": "https://stackoverflow.com/questions/36041974/is-there-any-standard-methodology-for-debugging-a-stack-overflow-in-rust/50959179#50959179", "title": "Is there any standard methodology for debugging a stack overflow in Rust?", "body": "<p>Using LLDB:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ rust-lldb -- target/debug/partition_ops-b31bcf7b82e2e8d5  # append test args here\n...\n(lldb) run\n...\n(lldb) bt\n</code></pre>\n"}], "owner": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2208, "favorite_count": 1, "answer_count": 2, "score": 12, "last_activity_date": 1529547049, "creation_date": 1458146914, "last_edit_date": 1529547020, "question_id": 36041974, "link": "https://stackoverflow.com/questions/36041974/is-there-any-standard-methodology-for-debugging-a-stack-overflow-in-rust", "title": "Is there any standard methodology for debugging a stack overflow in Rust?", "body": "<p>Getting a backtrace would be nice.</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ cargo test\n    Running target/debug/partition_ops-b31bcf7b82e2e8d5\n\nrunning 1 test\n\nthread 'create_small' has overflowed its stack\nProcess didn't exit successfully: `/home/dhardy/other/pippin/target/debug/partition_ops-b31bcf7b82e2e8d5` (signal: 11)\n\nTo learn more, run the command again with --verbose.\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "edited": false, "score": 4, "creation_date": 1458143960, "post_id": 36040725, "comment_id": 59730593, "body": "I believe you&#39;re shadowing the outer binding with an inner binding. Try assigning it without <code>let</code> the second time."}, {"owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "reply_to_user": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "edited": false, "score": 0, "creation_date": 1458144382, "post_id": 36040725, "comment_id": 59730895, "body": "yup, @TheodorosChatzigiannakis is right, you can remove the &quot;let&quot; inside the unsafe (let introduces a new binding, but here you want to reuse a previous one): <a href=\"http://is.gd/Gv9U0A\" rel=\"nofollow noreferrer\">example</a>"}, {"owner": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "reply_to_user": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "edited": false, "score": 0, "creation_date": 1458144436, "post_id": 36040725, "comment_id": 59730945, "body": "@TheodorosChatzigiannakis What do you know? That works. Thanks!"}], "answers": [{"tags": [], "owner": {"reputation": 26917, "user_id": 1892179, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/umfON.jpg?s=128&g=1", "display_name": "Theodoros Chatzigiannakis", "link": "https://stackoverflow.com/users/1892179/theodoros-chatzigiannakis"}, "is_accepted": true, "score": 8, "last_activity_date": 1458165322, "last_edit_date": 1458165322, "creation_date": 1458144361, "answer_id": 36041000, "question_id": 36040725, "link": "https://stackoverflow.com/questions/36040725/how-do-i-reference-a-variable-used-in-an-unsafe-block/36041000#36041000", "title": "How do I reference a variable used in an unsafe block?", "body": "<p>In the inner block, you're not assigning a new value to the outer <code>length</code> binding, <a href=\"http://rustbyexample.com/variable_bindings/scope.html\" rel=\"nofollow\">you are <em>shadowing</em> it</a> by defining a new <code>length</code> binding.</p>\n\n<p>I believe that in a simple code snippet such as this (where the outer mutable variable isn't reassigned) normally there should be a compiler warning along the lines of:</p>\n\n<blockquote>\n  <p>warning: variable does not need to be mutable</p>\n</blockquote>\n\n<p>In any case, since you have declared an outer mutable binding, all you have to do to re-assign the original variable is drop the keyword <code>let</code> in the <code>unsafe</code> block.</p>\n\n<p>Additionally, as pointed out in the comments:</p>\n\n<ul>\n<li>There's no need to initialize this particular binding with a value, because that value is always going to be replaced before it is ever used.</li>\n<li>If you aren't really re-assigning that variable later on (in code not shown in your question), then it doesn't even need to be mutable. Mutability doesn't force you to initialize the variable at the point of its declaration in the source code.</li>\n</ul>\n\n<p>So this should suffice:</p>\n\n<pre><code>let length: u32; // or mut  \nunsafe {\n    length = mem::transmute::&lt;[u8; 4], u32&gt;(buf);\n    println!(\"1: {:}\", length);\n}\n\nprintln!(\"Length: {:}\", length);\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 9509, "user_id": 257568, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/6c736aafc7e3bfcf9f924d09bde3aa99?s=128&d=identicon&r=PG", "display_name": "ArtemGr", "link": "https://stackoverflow.com/users/257568/artemgr"}, "is_accepted": false, "score": 6, "last_activity_date": 1458154330, "creation_date": 1458154330, "answer_id": 36044529, "question_id": 36040725, "link": "https://stackoverflow.com/questions/36040725/how-do-i-reference-a-variable-used-in-an-unsafe-block/36044529#36044529", "title": "How do I reference a variable used in an unsafe block?", "body": "<p>Note (in addition to Theodoros' answer) that unsafe block is an expression, so you can do this:</p>\n\n<pre><code>let buf = [1u8, 2, 3, 4];\n\n// Transmute 4 byte array into u32\nlet length = unsafe {\n    let length = std::mem::transmute::&lt;[u8; 4], u32&gt;(buf); // buf is the 4 item array of u8 that the socket was read into\n    println!(\"1: {:}\", length);\n    length\n};\n\nprintln!(\"Length: {:}\", length);\n</code></pre>\n\n<p>Or in short:</p>\n\n<pre><code>let length = unsafe {std::mem::transmute::&lt;[u8; 4], u32&gt;(buf)};\n</code></pre>\n"}], "owner": {"reputation": 621, "user_id": 5665872, "user_type": "registered", "accept_rate": 50, "profile_image": "https://lh5.googleusercontent.com/-zgQc2CUwwKs/AAAAAAAAAAI/AAAAAAAABKE/Dh96hNnK8Qs/photo.jpg?sz=128", "display_name": "Fluffy", "link": "https://stackoverflow.com/users/5665872/fluffy"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 650, "favorite_count": 0, "accepted_answer_id": 36041000, "answer_count": 2, "score": 5, "last_activity_date": 1458165322, "creation_date": 1458143650, "question_id": 36040725, "link": "https://stackoverflow.com/questions/36040725/how-do-i-reference-a-variable-used-in-an-unsafe-block", "title": "How do I reference a variable used in an unsafe block?", "body": "<p>I'm trying to read 4 bytes from a socket and then transmute those bytes into a single u32.</p>\n\n<pre><code>let mut length: u32 = 0;\n\n// Transmute 4 byte array into u32\nunsafe {\n    let length = mem::transmute::&lt;[u8; 4], u32&gt;(buf); // buf is the 4 item array of u8 that the socket was read into\n    println!(\"1: {:}\", length);\n}\n\nprintln!(\"Length: {:}\", length);\n</code></pre>\n\n<p>However, length has the original value of 0 once outside of the unsafe block. How can I get around this?</p>\n"}, {"tags": ["data-structures", "collections", "concurrency", "rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458142500, "post_id": 36039917, "comment_id": 59729423, "body": "In C++, there is <a href=\"http://www.boost.org/doc/libs/1_60_0/libs/multi_index/doc/index.html\" rel=\"nofollow noreferrer\">Boost.MultiIndex</a>; it&#39;s much more complicated because it supports updates."}], "answers": [{"comments": [{"owner": {"reputation": 180, "user_id": 5218118, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/712c19ee522b71854d1e6d2d7d2639be?s=128&d=identicon&r=PG&f=1", "display_name": "Peter Ludvigsen", "link": "https://stackoverflow.com/users/5218118/peter-ludvigsen"}, "edited": false, "score": 0, "creation_date": 1458150293, "post_id": 36040953, "comment_id": 59735180, "body": "Thank you a lot for your in depth  answer. However, I do not understand what you mean by: &quot;It&#39;s generally better to wrap the item that you want to lock.&quot;."}, {"owner": {"reputation": 180, "user_id": 5218118, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/712c19ee522b71854d1e6d2d7d2639be?s=128&d=identicon&r=PG&f=1", "display_name": "Peter Ludvigsen", "link": "https://stackoverflow.com/users/5218118/peter-ludvigsen"}, "edited": false, "score": 0, "creation_date": 1458201288, "post_id": 36040953, "comment_id": 59756284, "body": "Thank you very much. That helped a lot"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1458222711, "last_edit_date": 1458222711, "creation_date": 1458144254, "answer_id": 36040953, "question_id": 36039917, "link": "https://stackoverflow.com/questions/36039917/how-can-i-lock-the-internals-of-my-rust-data-structure/36040953#36040953", "title": "How can I lock the internals of my Rust data structure?", "body": "<blockquote>\n  <p>I obviously need some kind of lock</p>\n</blockquote>\n\n<p>I don't know that I agree with this need. I'd only introduce a lock when multiple threads could be modifying the object concurrently. Note that's  two conditions: multiple threads AND concurrent modification.</p>\n\n<p>If you only have one thread, then Rust's enforcement of a single mutable reference to an item will prevent any issues. Likewise, if you have multiple threads and fully transfer ownership of the item between them, you don't need any locking because only one thread can mutate it.</p>\n\n<blockquote>\n  <p>I'm looking for something like:</p>\n\n<pre><code>try {\n    lock.lock();\n    // insert into both collections\n} finally {\n    lock.unlock();\n}\n</code></pre>\n</blockquote>\n\n<p>If you need something like that, then you can create a <code>Mutex&lt;()&gt;</code> \u2014 a mutex that locks the <em>unit type</em>, which takes no space:</p>\n\n<pre><code>use std::sync::Mutex;\n\nstruct Thing {\n    lock: Mutex&lt;()&gt;,\n    nums: Vec&lt;i32&gt;,\n    names: Vec&lt;String&gt;,\n}\n\nimpl Thing {\n    fn new() -&gt; Thing {\n        Thing {\n            lock: Mutex::new(()),\n            nums: vec![],\n            names: vec![],\n        }\n    }\n\n    fn add(&amp;mut self) {\n        let _lock = self.lock.lock().unwrap();\n        // Lock is held until the end of the block\n\n        self.nums.push(42);\n        self.names.push(\"The answer\".to_string());\n    }\n}\n\nfn main() {\n    let mut thing = Thing::new();\n    thing.add();\n}\n</code></pre>\n\n<p>Note that there is no explicit <code>unlock</code> required. When you call <code>lock</code>, you get back a <a href=\"http://doc.rust-lang.org/std/sync/struct.MutexGuard.html\" rel=\"nofollow\"><code>MutexGuard</code></a>. This type implements <a href=\"http://doc.rust-lang.org/std/ops/trait.Drop.html\" rel=\"nofollow\"><code>Drop</code></a>, which allows for code to be run when it goes out of scope. In this case, the lock will be automatically released. This is commonly called <em>Resource Acquisition Is Initialization</em> (RAII).</p>\n\n<p>I wouldn't recommend this practice in most cases. It's generally better to wrap the item that you want to lock. This enforces that access to the item can <strong>only</strong> happen when the lock is locked:</p>\n\n<pre><code>use std::sync::Mutex;\n\nstruct Thing {\n    nums: Vec&lt;i32&gt;,\n    names: Vec&lt;String&gt;,\n}\n\nimpl Thing {\n    fn new() -&gt; Thing {\n        Thing {\n            nums: vec![],\n            names: vec![],\n        }\n    }\n\n    fn add(&amp;mut self) {\n        self.nums.push(42);\n        self.names.push(\"The answer\".to_string());\n    }\n}\n\nfn main() {\n    let thing = Thing::new();\n    let protected = Mutex::new(thing);\n    let mut locked_thing = protected.lock().unwrap();\n    locked_thing.add();\n}\n</code></pre>\n\n<p>Note that the <code>MutexGuard</code> also implements <a href=\"http://doc.rust-lang.org/std/ops/trait.Deref.html\" rel=\"nofollow\"><code>Deref</code></a> and <a href=\"http://doc.rust-lang.org/std/ops/trait.DerefMut.html\" rel=\"nofollow\"><code>DerefMut</code></a>, which allow it to \"look\" like the locked type.</p>\n"}], "owner": {"reputation": 180, "user_id": 5218118, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/712c19ee522b71854d1e6d2d7d2639be?s=128&d=identicon&r=PG&f=1", "display_name": "Peter Ludvigsen", "link": "https://stackoverflow.com/users/5218118/peter-ludvigsen"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 803, "favorite_count": 0, "accepted_answer_id": 36040953, "answer_count": 1, "score": 2, "last_activity_date": 1458222711, "creation_date": 1458141647, "last_edit_date": 1458222467, "question_id": 36039917, "link": "https://stackoverflow.com/questions/36039917/how-can-i-lock-the-internals-of-my-rust-data-structure", "title": "How can I lock the internals of my Rust data structure?", "body": "<p>I'm trying to implement a collection that stores values in both a vector and a hashmap and this is what I have so far:</p>\n\n<pre><code>pub struct CollectionWrapper {\n    items:      Vec&lt;Item&gt;,\n    items_map:  HashMap&lt;ItemKey, Item&gt;,\n}\n\nimpl CollectionWrapper {\n    pub fn new() -&gt; Self {\n        CollectionWrapper {\n            items: Vec::new(),\n            items_map: HashMap::new(),\n        }\n    }\n\n    pub fn add(&amp;mut self, item: Item) {\n        let key = item.get_key();\n        self.items.push(item.clone());\n        self.items_map.insert(key, item.clone());\n    }\n}\n</code></pre>\n\n<p>I obviously need some kind of lock. I've looked at the <a href=\"http://doc.rust-lang.org/std/sync/struct.Mutex.html\" rel=\"nofollow\"><code>Mutex</code></a> Rust has, but I do not understand how to use it. When I search for the problem, I only find use cases where people spawn a bunch of threads and synchronize them. I'm looking for something like:</p>\n\n<pre><code>try {\n    lock.lock();\n    // insert into both collections\n} finally {\n    lock.unlock();\n}\n</code></pre>\n"}, {"tags": ["arrays", "rust", "calloc"], "answers": [{"comments": [{"owner": {"reputation": 4354, "user_id": 5967828, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/fJ7P2.jpg?s=128&g=1", "display_name": "xetra11", "link": "https://stackoverflow.com/users/5967828/xetra11"}, "edited": false, "score": 0, "creation_date": 1458109714, "post_id": 36028183, "comment_id": 59706594, "body": "OK then I&#39;ll use vec! macro. But I don&#39;t come along with them very well. When I construct my canvas with a width of 10 and height of 10 the &quot;array&quot; binding will hold a vec with a length of 100 (index range 0-99). After using this API I want to access the 99th index of the array which I could to with array[99] - no problem so far. But when i want to access that array with coordinates style for a mutli-dimensional array I had to do array[9][9] which is not possible and array[9*9] will result in array[81] and not 9 in width and 9 in height...thats the issue I have here tbh"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 4354, "user_id": 5967828, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/fJ7P2.jpg?s=128&g=1", "display_name": "xetra11", "link": "https://stackoverflow.com/users/5967828/xetra11"}, "edited": false, "score": 1, "creation_date": 1458116536, "post_id": 36028183, "comment_id": 59710088, "body": "@xetra11 viewing a flat array as a 2d array can be done with trivial arithmetics (x + y*width, for example, in row-major order (that&#39;s how it is called I think))."}, {"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "edited": false, "score": 0, "creation_date": 1458119251, "post_id": 36028183, "comment_id": 59711709, "body": "fix <code>pub fn new(&amp;self, width: usize, height: usize)</code> to <code>pub fn new(width: usize, height: usize)</code>"}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 5, "last_activity_date": 1458133610, "last_edit_date": 1458133610, "creation_date": 1458109447, "answer_id": 36028183, "question_id": 36028001, "link": "https://stackoverflow.com/questions/36028001/how-to-create-an-array-within-a-constructor-in-rust/36028183#36028183", "title": "How to create an array within a constructor in Rust", "body": "<p>First of all, I <em>deeply</em> suspect you don't want <code>char</code>; I'm assuming you want an \"array of bytes\", in which case you want <code>u8</code>.</p>\n\n<p>Secondly, you can't really use <code>[u8]</code> like this.  I'm not going to get into the <em>why</em> because that would just derail the answer.  For now: if you see a <code>[T]</code> that <em>isn't</em> behind a reference or pointer of some kind, it's <em>probably</em> a mistake.</p>\n\n<p>Finally, this is what <code>Vec</code> is for; use it.  You say you don't want to use it, but don't specify why.  <code>Vec</code> <em>is</em> how you allocate a dynamically sized array in Rust.  If you're trying to allocate a structure that's compatible with the exact same structure in C, then the question changes quite a bit, and you should make that clear.</p>\n\n<p>Assuming what you wanted was the \"Rust equivalent\" of doing it in C:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>pub struct Canvas {\n    width: usize,\n    height: usize,\n    array: Vec&lt;u8&gt;,\n}\n\nimpl Canvas {\n    pub fn new(width: usize, height: usize) -&gt; Canvas {\n        Canvas {\n            width: width,\n            height: height,\n            array: vec![0; width*height],\n        }\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 4354, "user_id": 5967828, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/fJ7P2.jpg?s=128&g=1", "display_name": "xetra11", "link": "https://stackoverflow.com/users/5967828/xetra11"}, "edited": false, "score": 0, "creation_date": 1458118720, "post_id": 36029560, "comment_id": 59711381, "body": "Exactly what I was looking for !!"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1458133795, "post_id": 36029560, "comment_id": 59722203, "body": "For a &quot;built-in&quot; feel, note the presence of the <a href=\"https://doc.rust-lang.org/std/ops/trait.Index.html\" rel=\"nofollow noreferrer\">Index</a> and <a href=\"https://doc.rust-lang.org/std/ops/trait.IndexMut.html\" rel=\"nofollow noreferrer\">IndexMut</a> which could implement for <code>(usize, usize)</code>. They cannot report errors, so they would come in supplement to the methods you wrote here, and then you could use <code>canvas[(50,50)] = 128</code>."}], "tags": [], "owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "is_accepted": true, "score": 5, "last_activity_date": 1458115056, "last_edit_date": 1458115056, "creation_date": 1458114409, "answer_id": 36029560, "question_id": 36028001, "link": "https://stackoverflow.com/questions/36028001/how-to-create-an-array-within-a-constructor-in-rust/36029560#36029560", "title": "How to create an array within a constructor in Rust", "body": "<blockquote>\n  <p>i want to access that array with coordinates style</p>\n</blockquote>\n\n<p>Something like this?</p>\n\n<pre><code>pub struct Canvas {\n    width: usize,\n    height: usize,\n    data: Vec&lt;u8&gt;,\n}\n\nimpl Canvas {\n    pub fn new(width: usize, height: usize) -&gt; Canvas {\n        Canvas {\n            width: width,\n            height: height,\n            data: vec![0; width*height],\n        }\n    }\n\n    fn coords_to_index(&amp;self, x: usize, y: usize) -&gt; Result&lt;usize, &amp;'static str&gt; {\n        if x&lt;self.width &amp;&amp; y&lt;self.height {\n            Ok(x+y*self.width)\n        } else {\n            Err(\"Coordinates are out of bounds\")\n        }\n    }\n\n    pub fn get(&amp;self, x: usize, y: usize) -&gt; Result&lt;u8, &amp;'static str&gt; {\n        self.coords_to_index(x, y).map(|index| self.data[index])\n    }\n\n    pub fn set(&amp;mut self, x: usize, y: usize, new_value: u8) -&gt; Result&lt;(), &amp;'static str&gt;{\n        self.coords_to_index(x, y).map(|index| {self.data[index]=new_value;})\n    }\n}\n\nfn main() {\n    let mut canvas = Canvas::new(100, 100);\n    println!(\"{:?}\", canvas.get(50, 50)); // Ok(0)\n    println!(\"{:?}\", canvas.get(101, 50)); // Err(\"Coordinates are out of bounds\")\n    println!(\"{:?}\", canvas.set(50, 50, 128)); // Ok(())\n    println!(\"{:?}\", canvas.set(101, 50, 128)); // Err(\"Coordinates are out of bounds\")\n    println!(\"{:?}\", canvas.get(50, 50)); // Ok(128)\n}\n</code></pre>\n"}], "owner": {"reputation": 4354, "user_id": 5967828, "user_type": "registered", "accept_rate": 65, "profile_image": "https://i.stack.imgur.com/fJ7P2.jpg?s=128&g=1", "display_name": "xetra11", "link": "https://stackoverflow.com/users/5967828/xetra11"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 391, "favorite_count": 1, "accepted_answer_id": 36029560, "answer_count": 2, "score": 1, "last_activity_date": 1458133610, "creation_date": 1458108702, "last_edit_date": 1458131507, "question_id": 36028001, "link": "https://stackoverflow.com/questions/36028001/how-to-create-an-array-within-a-constructor-in-rust", "title": "How to create an array within a constructor in Rust", "body": "<p>I want to migrate some code from C to Rust for learning purposes and to make my learning library a bit more multi-lingual.</p>\n\n<p>The problem is that I know there's a way to integrate C libraries into Rust. That way I <em>could</em> use <code>calloc</code> in Rust to allow creating my array with a range specified at runtime.</p>\n\n<p><strong>But</strong> I don't want to use <code>calloc</code> here - I'd like to see the Rust way. But I really don't want to use <code>vec!</code> either; I had some stupid issues with it before so I don't want to use it just yet.</p>\n\n<p>Here is the code:</p>\n\n<pre><code>pub struct Canvas {\n    width: usize,\n    height: usize,\n    array: [char], // I want to declare its type but not its size yet\n}\n\nimpl Canvas{\n    pub fn new (&amp;self, width: usize, height: usize) -&gt; Canvas {\n        Canvas {\n            width: width,\n            height: height,\n            array: calloc(width, height), // alternative to calloc ?            }\n    }\n}\n</code></pre>\n\n<p>I hope my question is still idiomatic to the Rust way of code.</p>\n"}, {"tags": ["vector", "rust", "borrowing"], "answers": [{"comments": [{"owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "edited": false, "score": 1, "creation_date": 1458463972, "post_id": 36027606, "comment_id": 59864836, "body": "Nice trick with block in the <code>if</code> condition. Actually <code>clone()</code> does nothing here and <code>unwrap()</code> can cause panic in case <code>elements</code> is empty. I would recommend using: <code>if elements.last().map(|x| *x!=root_element).unwrap_or(true) {elements.push(root_element)}</code>"}, {"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "reply_to_user": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "edited": false, "score": 0, "creation_date": 1458488496, "post_id": 36027606, "comment_id": 59872057, "body": "@aSpex i just copied code from question without additional changes or opimisations, but you are absolutely correct."}], "tags": [], "owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "is_accepted": true, "score": 3, "last_activity_date": 1458488915, "last_edit_date": 1458488915, "creation_date": 1458106929, "answer_id": 36027606, "question_id": 36027235, "link": "https://stackoverflow.com/questions/36027235/how-to-clone-the-last-element-from-a-mutable-vector-and-then-push-a-value-to-the/36027606#36027606", "title": "How to clone the last element from a mutable vector and then push a value to the vector in Rust?", "body": "<p>Try this</p>\n\n<pre><code>fn ElementsFromPoint(&amp;self, ...) -&gt; Vec&lt;Root&lt;Element&gt;&gt; {\n\n    let mut elements: Vec&lt;Root&lt;Element&gt;&gt; = self.elements_from_point(point).iter()\n        .map(|&amp;untrusted_node_addr| {...}).collect();\n\n\n    if let Some(root_element) = self.GetDocumentElement() {\n        if {\n            match elements.last() {\n                Some(last_element) =&gt; *last_element != root_element,\n                None =&gt; true\n            }                \n        } {\n            elements.push(root_element);\n        }\n    }\n\n    elements\n}\n</code></pre>\n"}], "owner": {"reputation": 1508, "user_id": 3919805, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/9261f5cafc1016051e0d9fdae28ce9da?s=128&d=identicon&r=PG", "display_name": "rilut", "link": "https://stackoverflow.com/users/3919805/rilut"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 227, "favorite_count": 0, "accepted_answer_id": 36027606, "answer_count": 1, "score": 2, "last_activity_date": 1458488915, "creation_date": 1458104871, "last_edit_date": 1495539920, "question_id": 36027235, "link": "https://stackoverflow.com/questions/36027235/how-to-clone-the-last-element-from-a-mutable-vector-and-then-push-a-value-to-the", "title": "How to clone the last element from a mutable vector and then push a value to the vector in Rust?", "body": "<p>How to clone the last element from a <em>mutable</em> vector and then push a value to the vector in Rust?</p>\n\n<pre><code>fn ElementsFromPoint(&amp;self, ...) -&gt; Vec&lt;Root&lt;Element&gt;&gt; {\n\n    let mut elements: Vec&lt;Root&lt;Element&gt;&gt; = self.elements_from_point(point).iter()\n        .map(|&amp;untrusted_node_addr| {...}).collect();     \n\n    let last_element = elements.last().clone().unwrap(); // elements.last() is Option&lt;&amp;Root&lt;Element&gt;&gt;\n    if let Some(root_element) = self.GetDocumentElement() { //self.GetDocumentElement() is Option&lt;Root&lt;Element&gt;&gt;\n        if *last_element != root_element {\n            elements.push(root_element);\n        }\n    }\n\n\n    elements\n}\n</code></pre>\n\n<p>The errors are</p>\n\n<pre><code>2620:17: 2620:25 error: cannot borrow `elements` as mutable because it is also borrowed as immutable [E0502]\n2620                 elements.push(root_element);\n                     ^~~~~~~~\n2617:28: 2617:36 note: previous borrow of `elements` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `elements` until the borrow ends\n2617         let last_element = elements.last().clone().unwrap();\n                                ^~~~~~~~\n2626:6: 2626:6 note: previous borrow ends here\n2590     fn ElementsFromPoint(&amp;self, x: Finite&lt;f64&gt;, y: Finite&lt;f64&gt;) -&gt; Vec&lt;Root&lt;Element&gt;&gt; {\n                                                         ...\n2626     }\n                                                             ^\n2625:9: 2625:17 error: cannot move out of `elements` because it is borrowed [E0505]\n2625         elements\n             ^~~~~~~~\n2617:28: 2617:36 note: borrow of `elements` occurs here\n2617         let last_element = elements.last().clone().unwrap();\n</code></pre>\n\n<p>I've read <a href=\"https://stackoverflow.com/questions/31907887/how-to-clone-last-element-from-vector\">this</a> and tried</p>\n\n<pre><code>let last_element = elements.last().unwrap().clone();\n</code></pre>\n\n<p>and also</p>\n\n<pre><code>let last_element = elements.last().map(|t| t.clone()).unwrap();\n</code></pre>\n\n<p>but still failed.</p>\n\n<p>Also <code>.cloned()</code> isn't implemented for <code>Root&lt;T&gt;</code> yet.</p>\n\n<p>Is there a way to clone the last element from a <em>mutable</em> vector and then push a value to the vector in Rust? Or should I implement the <code>Cloned</code> trait first?</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 43, "user_id": 4276252, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/g8nEh.jpg?s=128&g=1", "display_name": "doctor_haifisch", "link": "https://stackoverflow.com/users/4276252/doctor-haifisch"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458091739, "post_id": 36025116, "comment_id": 59701301, "body": "Updated above, sorry about that!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458092990, "post_id": 36025116, "comment_id": 59701627, "body": "You are <a href=\"http://stackoverflow.com/q/32300132/155423\">trying to store a <code>String</code> and a reference to that <code>String</code> in the same struct</a>. Likely a duplicate."}, {"owner": {"reputation": 43, "user_id": 4276252, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/g8nEh.jpg?s=128&g=1", "display_name": "doctor_haifisch", "link": "https://stackoverflow.com/users/4276252/doctor-haifisch"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458093857, "post_id": 36025116, "comment_id": 59701860, "body": "I&#39;m cloning the <code>String</code> before storing it, so the <code>String</code> inside the struct is not referenced. Unless you&#39;re talking about different code from  <code>self.locals.insert(var_ref.binding.clone(), var_ref);</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458093947, "post_id": 36025116, "comment_id": 59701887, "body": "Yes, from <code>self.locals.insert(var_ref.binding.clone(), var_ref)</code>, as <code>var_ref</code> is a reference into <code>self.vars</code>. That&#39;s what drives the requirement of <code>&amp;&#39;a mut self</code> which is then causing the other problems."}, {"owner": {"reputation": 43, "user_id": 4276252, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/g8nEh.jpg?s=128&g=1", "display_name": "doctor_haifisch", "link": "https://stackoverflow.com/users/4276252/doctor-haifisch"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458094152, "post_id": 36025116, "comment_id": 59701939, "body": "Duh. I was just talking to someone about how you can&#39;t do this, and went and did it myself."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1458094502, "post_id": 36025116, "comment_id": 59702033, "body": "You can mark this as a duplicate yourself if you think the other question is useful enough, or you can wait for someone who isn&#39;t half-asleep to give a real answer instead of comments, or you can self-answer; up to you!"}], "owner": {"reputation": 43, "user_id": 4276252, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/g8nEh.jpg?s=128&g=1", "display_name": "doctor_haifisch", "link": "https://stackoverflow.com/users/4276252/doctor-haifisch"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 191, "favorite_count": 0, "closed_date": 1483404419, "answer_count": 0, "score": 2, "last_activity_date": 1458091726, "creation_date": 1458090619, "last_edit_date": 1495541637, "question_id": 36025116, "link": "https://stackoverflow.com/questions/36025116/cannot-borrow-as-mutable-more-than-once-a-at-a-time-cannot-infer-an-appropriat", "closed_reason": "Duplicate", "title": "Cannot borrow as mutable more than once a at a time / Cannot infer an appropriate lifetime parameter", "body": "<p>I've run into a specific lifetime issue in Rust that I cannot wrap my head around, after taking a look at <a href=\"https://stackoverflow.com/questions/31281155/cannot-borrow-x-as-mutable-more-than-once-at-a-time\">this post</a>, <a href=\"https://stackoverflow.com/questions/31067031/cannot-borrow-as-mutable-more-than-once-at-a-time-in-one-code-but-can-in-anoth\">this post</a>, and several other similar ones. In particular, I have these structs &amp; associated implementations:</p>\n\n<pre><code>use std::collections::hash_map::HashMap;\nuse std::mem;\n\npub struct JsVar {\n    binding: String,\n}\n\npub struct Scope&lt;'a&gt; {\n    pub vars: Vec&lt;JsVar&gt;,\n    locals: HashMap&lt;String, &amp;'a JsVar&gt;,\n}\n\nimpl&lt;'a&gt; Scope&lt;'a&gt; {\n    pub fn new() -&gt; Scope&lt;'a&gt; {\n        Scope {\n            vars: Vec::new(),\n            locals: HashMap::new(),\n        }\n    }\n\n    pub fn rebind_var(&amp;'a mut self, var: JsVar) {\n        self.vars.push(var);\n        let var_ref: &amp;'a JsVar = match self.vars.last() {\n            Some(var) =&gt; var,\n            None =&gt; unreachable!(),\n        };\n        self.locals.insert(var_ref.binding.clone(), var_ref);\n    }\n}\n\npub struct ScopeManager&lt;'a&gt; {\n    scopes: Vec&lt;Scope&lt;'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; ScopeManager&lt;'a&gt; {\n    pub fn pop_scope(&amp;'a mut self, gc_yield: bool) -&gt; Result&lt;(), String&gt; {\n        if let Some(mut scope) = self.scopes.pop() {\n            // Actual code snipped for brevity; this is the relevant operation.\n            let mut vars = mem::replace(&amp;mut scope.vars, Vec::new());\n            let mut parent: &amp;mut Scope&lt;'a&gt; = self.scopes.last_mut().unwrap();\n            while let Some(var) = vars.pop() {\n                parent.rebind_var(var);\n            }\n            Ok(())\n        } else {\n            Err(String::from(\"Bad Scope\"))\n        }\n    }\n}\n</code></pre>\n\n<p><a href=\"http://is.gd/d7sLok\" rel=\"nofollow noreferrer\">Playpen Link</a></p>\n\n<p>The compiler complains</p>\n\n<blockquote>\n  <p>cannot borrow *parent as mutable more than once at a time</p>\n</blockquote>\n\n<p>on the line that reads <code>parent.rebind_var(var)</code>, which I think is due to the <code>'a</code> lifetime annotation on <code>self</code> in the method definition, which causes <code>parent</code> to be borrowed for the length of the entire method. However, if I remove the <code>'a</code>, then the compiler is unable to infer an appropriate lifetime for <code>self.scopes</code> on the line where <code>parent</code> is bound. Based on this information, I don't understand</p>\n\n<ol>\n<li>how to make <code>parent</code> not bound to the lifetime of <code>self</code> and</li>\n<li>still be able to bind <code>parent</code> such that its lifetime is correct.</li>\n</ol>\n"}, {"tags": ["module", "rust", "private", "public"], "comments": [{"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 2, "creation_date": 1458110047, "post_id": 36021619, "comment_id": 59706732, "body": "There is an RFC (<a href=\"https://github.com/rust-lang/rfcs/pull/1422\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/pull/1422</a>) now in Final Comment Period for adding more fine-grained control of visibility."}], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1458075803, "post_id": 36022065, "comment_id": 59695446, "body": "Sorry for not being precise enough: <code>Foo</code> and it&#39;s impl also live in their own module/file (<code>src&#47;foo.rs</code>). Will update my question accordingly."}, {"owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1458076608, "post_id": 36022065, "comment_id": 59695840, "body": "That doesn&#39;t matter. Child modules can access the parent&#39;s private items. But here&#39;s an updated example anyway."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1458076891, "post_id": 36022065, "comment_id": 59696001, "body": "Yes, but it&#39;s not about accessing the parent&#39;s items, but about accessing the sibling&#39;s items. The modules <code>foo</code> and <code>do_something</code> are on the same level == are siblings."}, {"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 0, "creation_date": 1458078923, "post_id": 36022065, "comment_id": 59697044, "body": "I will edit my question a lot to make it easier to understand."}], "tags": [], "owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "is_accepted": false, "score": 4, "last_activity_date": 1458076576, "last_edit_date": 1458076576, "creation_date": 1458075713, "answer_id": 36022065, "question_id": 36021619, "link": "https://stackoverflow.com/questions/36021619/split-implementation-across-multiple-files-modules-and-keep-everything-as-privat/36022065#36022065", "title": "Split implementation across multiple files/modules and keep everything as private as possible", "body": "<p>Assuming a cargo project with a file structure like this:</p>\n\n<pre><code>src\\lib.rs\nsrc\\foo\\mod.rs\nsrc\\foo\\do_something.rs\nsrc\\bin\\test.rs\n</code></pre>\n\n<p><code>test.rs</code> is just to demonstrate that it works as intended for users of the library.</p>\n\n<p>In src\\lib.rs:</p>\n\n<pre><code>mod foo;\n\npub use foo::*;\n</code></pre>\n\n<p>In src\\foo\\mod.rs:</p>\n\n<pre><code>mod do_something;\n\npub use self::do_something::*;\n\npub struct Foo;\n\nimpl Foo {\n    fn helper(&amp;self) { /* .. */ }\n}\n</code></pre>\n\n<p>In src\\foo\\do_something.rs:</p>\n\n<pre><code>use super::Foo;\npub fn do_something(foo: &amp;Foo) {\n    foo.helper();\n}\n</code></pre>\n\n<p>In src\\bin\\test.rs</p>\n\n<pre><code>extern crate mylibname;\nuse mylibname::*;\n\nfn main() {\n    let foo = Foo;\n    do_something(&amp;foo);\n    // foo.helper(); //Uncommenting gives an error.\n}\n</code></pre>\n\n<p>This compiles for me.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1496953071, "creation_date": 1496953071, "answer_id": 44444840, "question_id": 36021619, "link": "https://stackoverflow.com/questions/36021619/split-implementation-across-multiple-files-modules-and-keep-everything-as-privat/44444840#44444840", "title": "Split implementation across multiple files/modules and keep everything as private as possible", "body": "<p>As of <a href=\"https://blog.rust-lang.org/2017/06/08/Rust-1.18.html\" rel=\"nofollow noreferrer\">Rust 1.18</a>, you can use the <code>pub(crate)</code> syntax to expose something throughout your entire crate but not outside of it:</p>\n\n<pre><code>mod foo {  // module contents in `src/foo.rs`\n    pub struct Foo;\n    impl Foo {\n        pub(crate) fn helper(&amp;self) { /* .. */ }\n    }    \n}\n</code></pre>\n\n<p>All the possibilities, as suggested by the compiler, include: </p>\n\n<ul>\n<li><code>pub(crate)</code>: visible only on the current crate</li>\n<li><code>pub(super)</code>: visible only in the current module's parent</li>\n<li><code>pub(in path::to::module)</code>: visible only on the specified path</li>\n</ul>\n"}], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1776, "favorite_count": 0, "accepted_answer_id": 44444840, "answer_count": 2, "score": 3, "last_activity_date": 1496953071, "creation_date": 1458074295, "last_edit_date": 1458079130, "question_id": 36021619, "link": "https://stackoverflow.com/questions/36021619/split-implementation-across-multiple-files-modules-and-keep-everything-as-privat", "title": "Split implementation across multiple files/modules and keep everything as private as possible", "body": "<p>Consider the following code in my library:</p>\n\n<pre><code>pub struct Foo;\nimpl Foo {\n    fn helper(&amp;self) { /* .. */ }\n}\n\npub fn do_something(foo: &amp;Foo) {\n    foo.helper();\n}\n</code></pre>\n\n<p>The users of my library should be able to use <code>Foo</code> and <code>do_something()</code>, but shall <em>never</em> call <code>helper()</code>. Everything works fine with the code above. But now imagine the code gets huge and I want to separate those definitions into their own files/modules -- they are then pulled back into the root-namespace with <code>pub use</code>. See here:</p>\n\n<pre><code>mod foo {  // module contents in `src/foo.rs`\n    pub struct Foo;\n    impl Foo {\n        fn helper(&amp;self) { /* .. */ }\n    }    \n}\n\nmod do_something {  // module contents in `src/do_something.rs`\n    use super::Foo;\n    pub fn do_something(foo: &amp;Foo) {\n        foo.helper();\n    }\n}\n\npub use foo::Foo;\npub use do_something::do_something;\n</code></pre>\n\n<p>Now the compiler complains that <code>helper()</code> is private. Indeed it is, but I still want <code>do_something()</code> be able to use it. But I don't want my users to use it. How can I do that?</p>\n\n<p>My attempted solution boils down to \"How to access private items of sibling modules?\". So answering that question would help me. But providing an alternative solution/a workaround would also be great!</p>\n"}, {"tags": ["rust", "iterator"], "answers": [{"comments": [{"owner": {"reputation": 181, "user_id": 12306639, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-S_OG3qbKRZE/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rdxpbJ7jTm5fpJ4d8wbo-nGwuGSqg/photo.jpg?sz=128", "display_name": "Peter Charland", "link": "https://stackoverflow.com/users/12306639/peter-charland"}, "edited": false, "score": 0, "creation_date": 1601662757, "post_id": 36020284, "comment_id": 113485767, "body": "Hallelujah! Just learned about <code>filter_map()</code>. I used it successfully like so: <code>let mut lines: Vec&lt;String&gt; = reader.lines().filter_map(|l| l.ok() ).collect();</code>. To make sure I understand, <code>filter_map</code> converts options returned by <code>Result</code>&#39;s <code>ok()</code> method if they are <code>Ok(T)</code> and skips that item of the iterator if it&#39;s an <code>Err</code>? Thanks so much."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 181, "user_id": 12306639, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-S_OG3qbKRZE/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rdxpbJ7jTm5fpJ4d8wbo-nGwuGSqg/photo.jpg?sz=128", "display_name": "Peter Charland", "link": "https://stackoverflow.com/users/12306639/peter-charland"}, "edited": false, "score": 0, "creation_date": 1601665792, "post_id": 36020284, "comment_id": 113486835, "body": "@PeterCharland more or less. But why use that instead of the shorter versions shown in the answer?"}, {"owner": {"reputation": 181, "user_id": 12306639, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-S_OG3qbKRZE/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rdxpbJ7jTm5fpJ4d8wbo-nGwuGSqg/photo.jpg?sz=128", "display_name": "Peter Charland", "link": "https://stackoverflow.com/users/12306639/peter-charland"}, "edited": false, "score": 0, "creation_date": 1601688164, "post_id": 36020284, "comment_id": 113491954, "body": "I guess I still don&#39;t get why into_iter returns a 2d iterator."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 29, "last_activity_date": 1549308929, "last_edit_date": 1549308929, "creation_date": 1458069734, "answer_id": 36020284, "question_id": 36020110, "link": "https://stackoverflow.com/questions/36020110/how-do-i-avoid-unwrap-when-converting-a-vector-of-options-or-results-to-only-the/36020284#36020284", "title": "How do I avoid unwrap when converting a vector of Options or Results to only the successful values?", "body": "<blockquote>\n  <p>I want to ignore all <code>Err</code> values</p>\n</blockquote>\n\n<p>Since <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html#impl-IntoIterator\" rel=\"noreferrer\"><code>Result</code> implements <code>IntoIterator</code></a>, you can convert your <code>Vec</code> into an iterator (which will be an iterator of iterators) and then flatten it:</p>\n\n<ul>\n<li><p><a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten\" rel=\"noreferrer\"><code>Iterator::flatten</code></a>:</p>\n\n<pre><code>vec.into_iter().flatten().collect()\n</code></pre></li>\n<li><p><a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map\" rel=\"noreferrer\"><code>Iterator::flat_map</code></a>:</p>\n\n<pre><code>vec.into_iter().flat_map(|e| e).collect()\n</code></pre></li>\n</ul>\n\n<p>These methods also work for <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\" rel=\"noreferrer\"><code>Option</code></a>, which <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#impl-IntoIterator-2\" rel=\"noreferrer\">also implements <code>IntoIterator</code></a>.</p>\n\n<hr>\n\n<p>You could also convert the <code>Result</code> into an <code>Option</code> and use  <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map\" rel=\"noreferrer\"><code>Iterator::filter_map</code></a>:</p>\n\n<pre><code>vec.into_iter().filter_map(|e| e.ok()).collect()\n</code></pre>\n"}], "owner": {"reputation": 55268, "user_id": 941764, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/b874953e067d60b5f07bb98c74bf48c8?s=128&d=identicon&r=PG", "display_name": "jgillich", "link": "https://stackoverflow.com/users/941764/jgillich"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5372, "favorite_count": 1, "accepted_answer_id": 36020284, "answer_count": 1, "score": 18, "last_activity_date": 1549308929, "creation_date": 1458069188, "last_edit_date": 1549308910, "question_id": 36020110, "link": "https://stackoverflow.com/questions/36020110/how-do-i-avoid-unwrap-when-converting-a-vector-of-options-or-results-to-only-the", "title": "How do I avoid unwrap when converting a vector of Options or Results to only the successful values?", "body": "<p>I have a <code>Vec&lt;Result&lt;T, E&gt;&gt;</code> and I want to ignore all <code>Err</code> values, converting it into a <code>Vec&lt;T&gt;</code>. I can do this:</p>\n\n<pre><code>vec.into_iter().filter(|e| e.is_ok()).map(|e| e.unwrap()).collect()\n</code></pre>\n\n<p>This is safe, but I want to avoid using <code>unwrap</code>. Is there a better way to write this?</p>\n"}, {"tags": ["rust", "rounding", "floating"], "comments": [{"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 1, "creation_date": 1458067370, "post_id": 36018019, "comment_id": 59690599, "body": "&quot;but it&#39;s not working yet&quot; is not helpful. In what way is it not working?"}, {"owner": {"reputation": 295, "user_id": 6057925, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1ea07abedba9c4fe8c636bebb801b21e?s=128&d=identicon&r=PG", "display_name": "Sidious Lord", "link": "https://stackoverflow.com/users/6057925/sidious-lord"}, "reply_to_user": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 0, "creation_date": 1458068126, "post_id": 36018019, "comment_id": 59691026, "body": "@Veedrac Sorry, I should have given more details.  It seems to me that the Python version modifies an iterator while iterating over it.  This is in general considered bad practice, and I assume it is a source of problems in Rust.  Anyway, the error message I get with the stable <code>rustc</code> is <code>error: use of possibly uninitialized variable: `hi` [E0381]</code>, which is strange since <code>hi</code> is definitely initialized and is defined outside the scope of the inner <code>for</code> loop."}, {"owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "edited": false, "score": 1, "creation_date": 1458069239, "post_id": 36018019, "comment_id": 59691684, "body": "And what does &quot;but it does not give the right answer&quot; refer to? Be <i>specific</i>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458069878, "post_id": 36018019, "comment_id": 59692033, "body": "<code>partials</code> is an empty vector during the first iteration; thus the inner loop will not run and <code>hi</code> will have never been set to any value. In general, even if <code>partials</code> had some initial value, the compiler cannot track that (this is why it says <i>possibly</i> uninitialized) and you have to handle the case where <code>partials</code> might have been empty."}, {"owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "edited": false, "score": 0, "creation_date": 1458070854, "post_id": 36018019, "comment_id": 59692624, "body": "It seems to work.  <a href=\"https://play.rust-lang.org/?gist=ad9bf3273612a651da91&amp;version=stable\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a> You was close. But I do not see any difference in precision"}], "answers": [{"comments": [{"owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458521197, "post_id": 36121326, "comment_id": 59883219, "body": "@Shepmaster Fixed, hope explanation is clear enough now."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458521339, "post_id": 36121326, "comment_id": 59883248, "body": "Looking great! Too bad I have only one upvote to give!"}], "tags": [], "owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "is_accepted": true, "score": 4, "last_activity_date": 1458521468, "last_edit_date": 1458521468, "creation_date": 1458519630, "answer_id": 36121326, "question_id": 36018019, "link": "https://stackoverflow.com/questions/36018019/rewriting-a-floating-point-sum-from-python-to-rust/36121326#36121326", "title": "rewriting a floating point sum from Python to Rust", "body": "<p>Is this what you are looking for? I think you did not mean to clone the <code>partials</code> array but found that you needed to in order to satisfy the borrow checker; if you try to use the code:</p>\n\n<pre><code>for y in partials.iter() {\n    ...\n    partials[i] = lo;\n</code></pre>\n\n<p>The borrow checker will complain:</p>\n\n<pre><code>&lt;anon&gt;:13:17: 13:25 error: cannot borrow `partials` as mutable because it is also borrowed as immutable [E0502]\n</code></pre>\n\n<p>I got around this by using an index into the array instead:</p>\n\n<pre><code>for j in 0..partials.len() {\n    let mut y = partials[j];\n</code></pre>\n\n<p>Then you are not cloning the whole array of partials each time around the outer loop! Since the <code>partials</code> array can be modified whilst iterating through it, taking a clone first means you will end up with the old value of <code>y</code> instead of the new one if it has been modified.</p>\n\n<pre><code>use std::mem;\n\nfn msum(v: &amp;[f64]) -&gt; f64 {\n    let mut partials: Vec&lt;f64&gt; = vec![];\n    for x in v {\n        let mut x = *x;\n        let mut i = 0;\n        for j in 0..partials.len() {\n            let mut y = partials[j];\n            if x.abs() &lt; y.abs() { mem::swap(&amp;mut x, &amp;mut y) }\n            let hi = x + y;\n            let lo = y - (hi - x);\n            if lo != 0.0 {\n                partials[i] = lo;\n                i += 1;\n            }\n            x = hi;\n        }\n        partials.truncate(i);\n        partials.push(x);\n    }\n    partials.iter().fold(0., |a, b| a + b)\n}\n\nfn main() {\n    let v = vec![1.234, 1e16, 1.234, -1e16];\n    println!(\"{}\",msum(&amp;v));\n}\n</code></pre>\n\n<p><a href=\"http://is.gd/3fyxBk\" rel=\"nofollow\">Playpen</a></p>\n"}], "owner": {"reputation": 295, "user_id": 6057925, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1ea07abedba9c4fe8c636bebb801b21e?s=128&d=identicon&r=PG", "display_name": "Sidious Lord", "link": "https://stackoverflow.com/users/6057925/sidious-lord"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 345, "favorite_count": 0, "accepted_answer_id": 36121326, "answer_count": 1, "score": 2, "last_activity_date": 1458521468, "creation_date": 1458062505, "last_edit_date": 1458068574, "question_id": 36018019, "link": "https://stackoverflow.com/questions/36018019/rewriting-a-floating-point-sum-from-python-to-rust", "title": "rewriting a floating point sum from Python to Rust", "body": "<p>I've been trying to rewrite the code below for summing floating point numbers while minimizing the rounding errors, but I found it pretty hard to do in Rust.  Any suggestions would be greatly appreciated.  I attach my non-working Rust attempt</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>def msum(iterable):\n    \"Full precision summation using multiple floats for intermediate values\"\n    # Rounded x+y stored in hi with the round-off stored in lo.  Together\n    # hi+lo are exactly equal to x+y.  The inner loop applies hi/lo summation\n    # to each partial so that the list of partial sums remains exact.\n    # Depends on IEEE-754 arithmetic guarantees.  See proof of correctness at:\n    #www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps\n\n    partials = []               # sorted, non-overlapping partial sums\n    for x in iterable:\n        i = 0\n        for y in partials:\n            if abs(x) &lt; abs(y):\n                x, y = y, x\n            hi = x + y\n            lo = y - (hi - x)\n            if lo:\n                partials[i] = lo\n                i += 1\n            x = hi\n        partials[i:] = [x]\n    return sum(partials, 0.0)\n</code></pre>\n\n<p>The code below is what I have in Rust so far, but it's not working yet</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn inexact_sum(v: &amp;Vec&lt;f64&gt;) -&gt; f64 {\n    let mut partials: Vec&lt;f64&gt; = vec![];\n    for x in v {\n\n        let mut i: usize = 0;\n        let mut hi: f64;\n        let mut lo: f64;\n\n        for y in partials.clone().iter() {\n            hi = x + y;\n            lo = if x.abs() &lt; y.abs() {\n                y - (hi - x)\n            } else {\n                x - (hi - y)\n            };\n            if lo != 0.0_f64 {\n                partials[i] = lo;\n                i += 1;\n            }\n            let x = hi;\n            println!(\"x = {}, y = {}\", x, y);\n        }\n        partials.truncate(i);\n        partials.push(hi);\n    }\n    partials.iter().fold(0.0_f64, |a, b| a + b)\n}\n</code></pre>\n\n<p>EDIT: Thinking about it a bit more, indeed, the error the compiler gave me <code>error: use of possibly uninitialized variable: `hi`</code> is indeed useful.  I should have paid more attention to it.  The point is that the first time the loop does not execute at all, so hi does not get initialized.  So if I change <code>partials.push(hi);</code> to <code>partials.push(*x);</code> the code compiles and runs but it does not give the right answer.</p>\n"}, {"tags": ["pointers", "types", "rust", "borrow-checker", "lmdb"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458061009, "post_id": 36016819, "comment_id": 59686251, "body": "See also <a href=\"http://stackoverflow.com/q/28999104/155423\">stackoverflow.com/q/28999104/155423</a>, <a href=\"http://stackoverflow.com/q/30249720/155423\">stackoverflow.com/q/30249720/155423</a>."}], "answers": [{"comments": [{"owner": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "edited": false, "score": 0, "creation_date": 1458064132, "post_id": 36017434, "comment_id": 59688418, "body": ":( I&#39;m getting more confused. So I added <code>impl&lt;&#39;a, T&gt; ToMdbValue for &amp;&#39;a T where T: ToMdbValue {}</code>, which throws error <code>E0210</code>. Reading the rustc explanation, I add <code>struct MyType&lt;T&gt;(T);</code> and adjust like in the example. Now I get &quot;not all trait items implemented, missing: <code>to_mdb_value</code>&quot; ... this is going down a rabbit hole at this point. I didn&#39;t simplify the example because I don&#39;t fully understand the problem."}, {"owner": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "edited": false, "score": 0, "creation_date": 1458064575, "post_id": 36017434, "comment_id": 59688685, "body": "Also: <code>ToMdbValue</code> is implemented for <code>&amp;&#39;a str</code> according to the docs."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "edited": false, "score": 0, "creation_date": 1458064893, "post_id": 36017434, "comment_id": 59688885, "body": "@o_o_o-- try changing your <code>set</code> to have generic constraints like my <code>user_call</code>:  <code>where for &lt;&#39;a&gt; &amp;&#39;a A: ToMdbValue, for &lt;&#39;a&gt; &amp;&#39;a B: ToMdbValue,</code>."}, {"owner": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "edited": false, "score": 0, "creation_date": 1458065030, "post_id": 36017434, "comment_id": 59688982, "body": "that&#39;s what I did, and it results in those errors. <code>pub fn set&lt;A&gt;(handle: &amp;DbHandle, env: &amp;Environment, pairs: &amp;Vec&lt;(&amp;A, &amp;A)&gt;)        -&gt; ()        where for &lt;&#39;a&gt; &amp;&#39;a A: ToMdbValue {</code>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "edited": false, "score": 0, "creation_date": 1458065104, "post_id": 36017434, "comment_id": 59689027, "body": "@o_o_o-- also try <code>pairs: &amp;[(A, B)]</code> (you do want two different types, right?). There&#39;s never a real need for <code>&amp;Vec</code>."}, {"owner": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "edited": false, "score": 0, "creation_date": 1458065224, "post_id": 36017434, "comment_id": 59689118, "body": "I&#39;m passing it two <code>&amp;str</code>, I originaly had 2 types because I wanted it to also allow for ints, but for now I just want to get it to work as is. -- <code>E0210</code> yells at me because <code>ToMdbValue</code> is defined in an external crate. Hence the added <code>MyType</code> stuff, but it just keeps complicating further..."}, {"owner": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "edited": false, "score": 0, "creation_date": 1458072394, "post_id": 36017434, "comment_id": 59693513, "body": "I got it working (see my answer bellow) by adding one more level of indirection to the variables being passed. Thanks for the help!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1458060845, "last_edit_date": 1495539855, "creation_date": 1458060845, "answer_id": 36017434, "question_id": 36016819, "link": "https://stackoverflow.com/questions/36016819/trait-is-not-implemented-for-the-type-a-when-passing-an-array-of-pairs-to-a-f/36017434#36017434", "title": "Trait is not implemented for the type `&amp;A` when passing an array of pairs to a function", "body": "<p>Here's an <a href=\"/help/mcve\">MCVE</a> of your problem:</p>\n\n<pre><code>trait Example {}\n\nimpl Example for i32 {}\n\nfn library_call&lt;T&gt;(value: T)\n    where T: Example,\n{}\n\nfn user_call&lt;T&gt;(values: &amp;[T])\n    where T: Example,\n{\n    for i in values {\n        library_call(i);\n    }\n}\n\nfn main() {\n    let values = vec![1, 2, 3];\n    user_call(&amp;values);\n}\n</code></pre>\n\n<p>With the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: the trait `Example` is not implemented for the type `&amp;T` [E0277]\n\nlibrary_call(i);\n^~~~~~~~~~~~\n</code></pre>\n\n<p>The error message is exactly correct - <code>Example</code> is <strong>not</strong> implemented for <code>&amp;T</code>, it's only guaranteed to be implemented for <code>T</code>. <code>&amp;T</code> and <code>T</code> are <em>different types</em>.</p>\n\n<p>Instead, you need to indicate that a reference to the generic type implements the trait you need:</p>\n\n<pre><code>fn user_call&lt;T&gt;(values: &amp;[T])\n    where for &lt;'a&gt; &amp;'a T: Example,\n</code></pre>\n\n<p>And then you need to make sure that a reference to the concrete type actually implements the trait:</p>\n\n<pre><code>impl&lt;'a&gt; Example for &amp;'a i32 {}\n</code></pre>\n\n<p>Or a broader version:</p>\n\n<pre><code>impl&lt;'a, T&gt; Example for &amp;'a T\n    where T: Example\n{}\n</code></pre>\n\n<p>See also <a href=\"https://stackoverflow.com/q/28799372/155423\">When should I not implement a trait for references to implementors of that trait?</a></p>\n"}, {"comments": [{"owner": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "edited": false, "score": 0, "creation_date": 1458062937, "post_id": 36017595, "comment_id": 59687601, "body": "I get mismatched type: &quot;expected <code>&amp;collections::vec::Vec&lt;(&amp;lmdb_rs::traits::ToMdbValue, &amp;lmdb_rs::traits::ToMdbValue)&gt;</code>, found <code>&amp;collections::vec::Vec&lt;(&amp;str, &amp;str)&gt;</code>&quot; -- I was getting this before hence I assumed I had to pass a generic that implements <code>ToMdbValue</code> :("}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "edited": false, "score": 0, "creation_date": 1458112915, "post_id": 36017595, "comment_id": 59708120, "body": "@o_o_o--: this means that you have to change the call site of <code>set</code> too, to now pass a <code>Vec&lt;(&amp;ToMdbValue, &amp;ToMdbValue)&gt;</code> instead of a <code>Vec&lt;(&amp;str, &amp;str)&gt;)</code> =&gt; the changes are bubbling up."}], "tags": [], "owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "is_accepted": false, "score": 1, "last_activity_date": 1458061583, "last_edit_date": 1458061583, "creation_date": 1458061265, "answer_id": 36017595, "question_id": 36016819, "link": "https://stackoverflow.com/questions/36016819/trait-is-not-implemented-for-the-type-a-when-passing-an-array-of-pairs-to-a-f/36017595#36017595", "title": "Trait is not implemented for the type `&amp;A` when passing an array of pairs to a function", "body": "<p>The definition of the function that gives you an error (if I'm reading the docs right):</p>\n\n<pre><code>fn set(&amp;self, key: &amp;ToMdbValue, value: &amp;ToMdbValue) -&gt; MdbResult&lt;()&gt;\n</code></pre>\n\n<p><code>key</code> must be a reference to a trait object. You are trying to pass a reference to a generic type implmementing <code>ToMdbValue</code>. </p>\n\n<p><a href=\"https://doc.rust-lang.org/book/trait-objects.html\" rel=\"nofollow\">https://doc.rust-lang.org/book/trait-objects.html</a></p>\n\n<p>I can't verify but this should work:</p>\n\n<pre><code>pub fn set(handle: &amp;DbHandle, env: &amp;Environment, pairs: &amp;Vec&lt;(&amp;ToMdbValue, &amp;ToMdbValue)&gt;) -&gt; () {\n\n    let txn = new_transaction(&amp;env);\n\n    {\n        let db = txn.bind(&amp;handle);\n\n        for &amp;(id, note) in pairs.iter() {\n            db.set(id, note).unwrap();\n        }\n    }\n\n    match txn.commit() {\n            Err(_) =&gt; panic!(\"Failed to commit!\"),\n            Ok(_) =&gt; (),\n    }\n}\n</code></pre>\n\n<p>Other things: you may want to work with boxed trait objects <code>Box&lt;ToMdbValue&gt;</code>. The link above explains it. You should pass a <code>&amp;[YourType]</code> rather than <code>&amp;Vec&lt;[YourType]&gt;</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "is_accepted": true, "score": 1, "last_activity_date": 1458072314, "creation_date": 1458072314, "answer_id": 36021075, "question_id": 36016819, "link": "https://stackoverflow.com/questions/36016819/trait-is-not-implemented-for-the-type-a-when-passing-an-array-of-pairs-to-a-f/36021075#36021075", "title": "Trait is not implemented for the type `&amp;A` when passing an array of pairs to a function", "body": "<p>I managed to get it working. I'm not sure how kosher this solution is, but I'll post it.</p>\n\n<p>So now, in <code>main()</code>, I do the following (example with an <code>(int, string)</code> kv pair):</p>\n\n<pre><code>let k = 1;\nlet val = \"hello there\";\nlet vec = vec![(&amp;k, &amp;val)];\nset(&amp;dbhandle, &amp;env, &amp;vec);\n</code></pre>\n\n<p>I had to declare them separately since <code>vec![(&amp;1, &amp;\"hello there\")]</code> threw an error of the form <code>borrowed value does not live long enough</code>.</p>\n\n<p><code>set</code> now looks like this:</p>\n\n<pre><code>pub fn set&lt;A, B&gt;(handle: &amp;DbHandle, env: &amp;Environment, pairs: &amp;Vec&lt;(&amp;A, &amp;B)&gt;)\n    -&gt; ()\n    where A: ToMdbValue,\n          B: ToMdbValue {\n\n    let txn = new_transaction(&amp;env);\n\n    {\n        let db = txn.bind(&amp;handle);\n\n        for &amp;(id, note) in pairs.iter() {\n            db.set(id, note).unwrap();\n        }\n    }\n\n    match txn.commit() {\n            Err(_) =&gt; panic!(\"Failed to commit!\"),\n            Ok(_) =&gt; (),\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 905, "user_id": 1632175, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/3ac69f95647b6ab2b91e58aa1b9823ff?s=128&d=identicon&r=PG&f=1", "display_name": "o_o_o--", "link": "https://stackoverflow.com/users/1632175/o-o-o"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 604, "favorite_count": 0, "accepted_answer_id": 36021075, "answer_count": 3, "score": 0, "last_activity_date": 1458072314, "creation_date": 1458059035, "last_edit_date": 1458061086, "question_id": 36016819, "link": "https://stackoverflow.com/questions/36016819/trait-is-not-implemented-for-the-type-a-when-passing-an-array-of-pairs-to-a-f", "title": "Trait is not implemented for the type `&amp;A` when passing an array of pairs to a function", "body": "<p>I am trying to write the function <code>set</code> which calls the Rust <a href=\"https://github.com/vhbit/lmdb-rs\" rel=\"nofollow\">LMDB library</a> (<a href=\"http://vhbit.github.io/lmdb-rs/lmdb_rs/\" rel=\"nofollow\">docs</a>), and an example I'm <a href=\"https://github.com/vhbit/lmdb-rs/blob/master/examples/simple.rs\" rel=\"nofollow\">working off of</a>.</p>\n\n<p>I can't for the life of me get this to work. Here is my current attempt:</p>\n\n<pre><code>fn main() {\n    let env = getenv(\"duperdb\");\n    let dbhandle = get_dbhandle(\"\", &amp;env);\n    let txn = new_transaction(&amp;env);\n    let vec = vec![(\"foo\", \"another text\"), (\"bar\", \"and another\")];\n    set(&amp;dbhandle, &amp;env, &amp;vec);\n\n    let reader = env.get_reader().unwrap();\n    let db = reader.bind(&amp;dbhandle);\n    let note = db.get::&lt;&amp;str&gt;(\"foo\").unwrap();\n\n    println!(\"NOTE: {}\", note);\n}\n</code></pre>\n\n<p>Where <code>set</code> is defined as:</p>\n\n<pre><code>pub fn set&lt;A: ToMdbValue, B: ToMdbValue&gt;(\n    handle: &amp;DbHandle,\n    env: &amp;Environment,\n    pairs: &amp;Vec&lt;(&amp;A, &amp;B)&gt;) -&gt; () {\n\n    let txn = new_transaction(&amp;env);\n\n    {\n        let db = txn.bind(&amp;handle);\n\n        for &amp;(id, note) in pairs.iter() {\n            db.set(&amp;id, &amp;note).unwrap();\n        }\n    }\n\n    match txn.commit() {\n            Err(_) =&gt; panic!(\"Failed to commit!\"),\n            Ok(_) =&gt; (),\n    }\n}\n</code></pre>\n\n<p>This spits out the following error:</p>\n\n<pre><code>src/db/wrapper.rs:28:20: 28:23 error: the trait `lmdb::traits::ToMdbValue` is not implemented for the type `&amp;A` [E0277]\nsrc/db/wrapper.rs:28             db.set(&amp;id, &amp;note).unwrap();\n                                        ^~~\n</code></pre>\n\n<hr>\n\n<p>I also tried <code>db.set(id, note).unwrap();</code>, but this time I get:</p>\n\n<pre><code>src/main.rs:13:5: 13:8 error: the trait `core::marker::Sized` is not implemented for the type `str` [E0277]\nsrc/main.rs:13     set(&amp;dbhandle, &amp;env, &amp;vec);\n                   ^~~\nsrc/main.rs:13:5: 13:8 help: run `rustc --explain E0277` to see a detailed explanation\nsrc/main.rs:13:5: 13:8 note: `str` does not have a constant size known at compile-time\nsrc/main.rs:13:5: 13:8 note: required by `dupernote::db::wrapper::set`\nsrc/main.rs:13:5: 13:8 error: the trait `lmdb_rs::traits::ToMdbValue` is not implemented for the type `str` [E0277]\nsrc/main.rs:13     set(&amp;dbhandle, &amp;env, &amp;vec);\n                   ^~~\n</code></pre>\n\n<hr>\n\n<p>I also tried stuff like:</p>\n\n<pre><code>    for (id, note) in pairs.iter() {\n        db.set(id, note).unwrap();\n    }\n</code></pre>\n\n<p>But that doesn't work either... I don't fully understand why. Doesn't <code>id</code> and <code>note</code> have type <code>&amp;str</code>, not <code>str</code>? </p>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 15722, "user_id": 284318, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/1e0588e345236881aff23040eb1d5dc3?s=128&d=identicon&r=PG", "display_name": "Danilo Bargen", "link": "https://stackoverflow.com/users/284318/danilo-bargen"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1458056673, "post_id": 36015828, "comment_id": 59683265, "body": "@ker you&#39;re right. It&#39;s hard to find though, maybe the title of the other question can be adjusted."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1458056734, "post_id": 36015828, "comment_id": 59683302, "body": "no need. if this question is marked as a duplicate, people will find the correct answer through this question"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 2, "creation_date": 1458057585, "post_id": 36015828, "comment_id": 59683976, "body": "@DaniloBargen: As ker mentioned, don&#39;t worry. The very purpose of retaining duplicate on StackOverflow is to provide multiple entry points each with its own wording. This is precisely because some problems can have many different formulations :)"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1458057926, "post_id": 36015828, "comment_id": 59684189, "body": "See also <a href=\"http://stackoverflow.com/questions/35765440/what-are-the-options-to-end-a-mutable-borrow-in-rust/\">these</a> more recent question and answer."}], "owner": {"reputation": 15722, "user_id": 284318, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/1e0588e345236881aff23040eb1d5dc3?s=128&d=identicon&r=PG", "display_name": "Danilo Bargen", "link": "https://stackoverflow.com/users/284318/danilo-bargen"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 48, "favorite_count": 0, "closed_date": 1458057966, "answer_count": 0, "score": 2, "last_activity_date": 1458056438, "creation_date": 1458056438, "question_id": 36015828, "link": "https://stackoverflow.com/questions/36015828/why-does-the-rust-borrow-checker-ignore-drop", "closed_reason": "Duplicate", "title": "Why does the Rust borrow checker ignore drop()?", "body": "<p>The following code fails to compile:</p>\n\n<pre><code>use std::thread;\n\n#[derive(Debug)]\nstruct Contained {\n    a: u8\n}\n\n#[derive(Debug)]\nstruct Wrapper&lt;'a&gt; {\n    b: &amp;'a Contained,\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n\n    let c = Contained { a: 42 };\n    let w = Wrapper { b: &amp;c };\n\n    println!(\"C: {:?}\", c);\n    println!(\"W: {:?}\", w);\n\n    let handle = thread::spawn(move || {\n        println!(\"C in thread: {:?}\", c);\n    });\n    handle.join().unwrap();\n}\n</code></pre>\n\n<p>Error message:</p>\n\n<pre><code>src/main.rs:24:39: 24:40 error: cannot move `c` into closure because it is borrowed [E0504]\nsrc/main.rs:24         println!(\"C in thread: {:?}\", c);\n                                                     ^\n&lt;std macros&gt;:2:25: 2:56 note: in this expansion of format_args!\n&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)\nsrc/main.rs:24:9: 24:42 note: in this expansion of println! (defined in &lt;std macros&gt;)\nsrc/main.rs:18:27: 18:28 note: borrow of `c` occurs here\nsrc/main.rs:18     let w = Wrapper { b: &amp;c };\n                                         ^\n</code></pre>\n\n<p>The borrow checker is obviously right about this. A way to work around this is by using explicit scopes, so that the wrapper is dropped, freeing the borrowed contained object.</p>\n\n<pre><code>let c = Contained { a: 42 };\n{\n    let w = Wrapper { b: &amp;c };\n    println!(\"C: {:?}\", c);\n    println!(\"W: {:?}\", w);\n}\nlet handle = thread::spawn(move || {\n    println!(\"C in thread: {:?}\", c);\n});\n</code></pre>\n\n<p>This compiles properly.</p>\n\n<p>Another way to make an object go out of scope is by using the <code>std::mem::drop</code> function. In this case it does not work though:</p>\n\n<pre><code>let c = Contained { a: 42 };\nlet w = Wrapper { b: &amp;c };\nprintln!(\"C: {:?}\", c);\nprintln!(\"W: {:?}\", w);\ndrop(w);\nlet handle = thread::spawn(move || {\n    println!(\"C in thread: {:?}\", c);\n});\n</code></pre>\n\n<p>The borrow checker complains with the same error message as before.</p>\n\n<p>Why does <code>drop(w)</code> not free the borrowed <code>c</code>?</p>\n"}, {"tags": ["generics", "polymorphism", "rust"], "answers": [{"comments": [{"owner": {"reputation": 16558, "user_id": 1804173, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/53f721a451a1c68caf8316cefcde3083?s=128&d=identicon&r=PG", "display_name": "bluenote10", "link": "https://stackoverflow.com/users/1804173/bluenote10"}, "edited": false, "score": 0, "creation_date": 1578308175, "post_id": 36014734, "comment_id": 105384821, "body": "I might be doing something wrong, but <code>num</code> doesn&#39;t seem to be an official crate anymore, right? Also how does <code>num</code> relate to <code>num_traits</code>, is there any reason to prefer one over the other?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 16558, "user_id": 1804173, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/53f721a451a1c68caf8316cefcde3083?s=128&d=identicon&r=PG", "display_name": "bluenote10", "link": "https://stackoverflow.com/users/1804173/bluenote10"}, "edited": false, "score": 1, "creation_date": 1578358851, "post_id": 36014734, "comment_id": 105405196, "body": "@bluenote10 if I recall correctly, originally <code>num</code> was extracted from the standard library, that&#39;s why I called it &quot;official&quot;. I don&#39;t think it is really official as in &quot;supported by Rust developers&quot;. As for the difference between <code>num</code> and <code>num-traits</code>, it is actually described in the former&#39;s readme: <a href=\"https://crates.io/crates/num\" rel=\"nofollow noreferrer\">crates.io/crates/num</a>. Basically, <code>num</code> reexports <code>num-traits</code> and also other crates in the <code>num-*</code> family, which is useful if you need many of them."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 16, "last_activity_date": 1458053688, "creation_date": 1458053688, "answer_id": 36014734, "question_id": 36013519, "link": "https://stackoverflow.com/questions/36013519/how-can-i-make-a-rust-function-accept-any-floating-type-as-an-argument/36014734#36014734", "title": "How can I make a Rust function accept any floating type as an argument", "body": "<p>Currently all of the generic story with primitive numeric types in Rust is available in the official <a href=\"http://rust-num.github.io/num/num/index.html\" rel=\"noreferrer\"><code>num</code></a> crate. This crate contains, among everything else, a number of traits which are implemented for various primitive numeric types, and in particular there is <a href=\"http://rust-num.github.io/num/num/traits/trait.Float.html\" rel=\"noreferrer\"><code>Float</code></a> which represents a floating-point number.</p>\n\n<p><code>Float</code> trait provides a lot of methods which are specific to floating-point numbers, but it also extends <a href=\"http://rust-num.github.io/num/num/traits/trait.Num.html\" rel=\"noreferrer\"><code>Num</code></a> and <a href=\"http://rust-num.github.io/num/num/traits/trait.NumCast.html\" rel=\"noreferrer\"><code>NumCast</code></a> traits which allow one to perform numeric operations and obtain generic types from arbitrary primitive numbers. With <code>Float</code> your code could look like this:</p>\n\n<pre><code>use num::{Float, NumCast};\n\nfn multiply&lt;F: Float&gt;(n: F) -&gt; F {\n    n * NumCast::from(2).unwrap()\n}\n</code></pre>\n\n<p><code>NumCast::from()</code> returns <code>Option</code> because not all numeric casts make sense, but in this particular case it is guaranteed to work, hence I used <code>unwrap()</code>.</p>\n"}], "owner": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3257, "favorite_count": 0, "accepted_answer_id": 36014734, "answer_count": 1, "score": 13, "last_activity_date": 1579768255, "creation_date": 1458050601, "last_edit_date": 1579768255, "question_id": 36013519, "link": "https://stackoverflow.com/questions/36013519/how-can-i-make-a-rust-function-accept-any-floating-type-as-an-argument", "title": "How can I make a Rust function accept any floating type as an argument", "body": "<p>I'm looking to write a function that can accept any floating point data, similar to the following form:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>fn multiply&lt;F: Float&gt;(floating_point_number: F) -&gt; F {\n    floating_point_number * 2\n}\n</code></pre>\n\n<p>But I can't find the syntax for it in the documentation, or a trait that is common to floating point numbers only.</p>\n"}, {"tags": ["syntax", "attributes", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1458046539, "post_id": 36011559, "comment_id": 59675168, "body": "Yes, it&#39;s likely to be possible, but only in unstable Rust as compiler plugins (which allow creating properties) are unstable. Besides that, <i>global</i> state is highly discouraged in most programming, especially Rust. Beyond that, it sounds like you are asking to have the code for this solution written for you. I&#39;d recommend checking out <a href=\"https://github.com/iron/router\" rel=\"nofollow noreferrer\">iron/router</a> for a less-invasive solution that works today."}, {"owner": {"reputation": 11, "user_id": 5789273, "user_type": "registered", "profile_image": "https://graph.facebook.com/943585512400079/picture?type=large", "display_name": "Moritz John Brandes", "link": "https://stackoverflow.com/users/5789273/moritz-john-brandes"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1458046826, "post_id": 36011559, "comment_id": 59675385, "body": "I&#39;m currently researching different languages fit for doing such things in general. Rust is one of them. I want to do it on my own, I just need to know what&#39;s the best approach to do it. The global object was just as an example."}], "owner": {"reputation": 11, "user_id": 5789273, "user_type": "registered", "profile_image": "https://graph.facebook.com/943585512400079/picture?type=large", "display_name": "Moritz John Brandes", "link": "https://stackoverflow.com/users/5789273/moritz-john-brandes"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 82, "favorite_count": 0, "closed_date": 1490273667, "answer_count": 0, "score": 0, "last_activity_date": 1458046321, "creation_date": 1458045383, "last_edit_date": 1458046321, "question_id": 36011559, "link": "https://stackoverflow.com/questions/36011559/can-rust-attributes-be-used-for-something-like-mapping-url-routes-to-functions", "closed_reason": "Duplicate", "title": "Can Rust attributes be used for something like mapping URL routes to functions?", "body": "<p>I'd like to know whether or not it is possible to to do something like the following with Rust:</p>\n\n<pre><code>#Get(url=\"api/action\")\nvoid action(string[] params) {}\n</code></pre>\n\n<p>To create a REST API, this would be pretty nice syntax sugar. I know that I can create custom attributes for the compiler, but I'm not sure how to best approach this.</p>\n\n<p>For example every method declared with that <code>Get</code> attribute could be registered in a global object to register the routes without writing a single line of code.</p>\n\n<p>Can Rust attributes be used for something like this? And if yes, what would be the best approach?</p>\n"}, {"tags": ["floating-point", "rust", "precision"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1458042042, "post_id": 36008434, "comment_id": 59671938, "body": "why don&#39;t you just use <a href=\"https://doc.rust-lang.org/std/primitive.f32.html#method.ldexp\" rel=\"nofollow noreferrer\">doc.rust-lang.org/std/primitive.f32.html#method.ldexp</a> and wait for it to get stable?"}, {"owner": {"reputation": 1706, "user_id": 4255842, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/b0d7dfd98472547776f7d23112d000f5?s=128&d=identicon&r=PG&f=1", "display_name": "Pyfisch", "link": "https://stackoverflow.com/users/4255842/pyfisch"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1458042166, "post_id": 36008434, "comment_id": 59672039, "body": "The crate should work on stable now. In addition the ldexp method is unlikely to get stabilized."}], "answers": [{"tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 4, "last_activity_date": 1458064180, "creation_date": 1458064180, "answer_id": 36018540, "question_id": 36008434, "link": "https://stackoverflow.com/questions/36008434/how-can-i-decode-f16-to-f32-using-only-the-stable-standard-library/36018540#36018540", "title": "How can I decode f16 to f32 using only the stable standard library?", "body": "<p>You can just replace <code>ffi::c_ldexpf(x, y)</code> with <code>x * (2.0).powi(y)</code>. This works on all <code>u16</code>s, according to <a href=\"https://play.rust-lang.org/?gist=a1cd50f65134d1df54cf&amp;version=nightly\" rel=\"nofollow\">my exhaustive test</a>.</p>\n"}], "owner": {"reputation": 1706, "user_id": 4255842, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/b0d7dfd98472547776f7d23112d000f5?s=128&d=identicon&r=PG&f=1", "display_name": "Pyfisch", "link": "https://stackoverflow.com/users/4255842/pyfisch"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 455, "favorite_count": 0, "accepted_answer_id": 36018540, "answer_count": 1, "score": 6, "last_activity_date": 1458064180, "creation_date": 1458037135, "last_edit_date": 1458046674, "question_id": 36008434, "link": "https://stackoverflow.com/questions/36008434/how-can-i-decode-f16-to-f32-using-only-the-stable-standard-library", "title": "How can I decode f16 to f32 using only the stable standard library?", "body": "<p>I need to convert stored half floats (16 bit) to standard 32 bit floats. I currently use the code below, but it relies on libc. I want to use only <code>std</code> and it should work on stable Rust.</p>\n\n<pre><code>#[inline]\nfn decode_f16(half: u16) -&gt; f32 {\n    let exp: u16 = half &gt;&gt; 10 &amp; 0x1f;\n    let mant: u16 = half &amp; 0x3ff;\n    let val: f32 = if exp == 0 {\n        ffi::c_ldexpf(mant as f32, -24)\n    } else if exp != 31 {\n        ffi::c_ldexpf(mant as f32 + 1024f32, exp as isize - 25)\n    } else if mant == 0 {\n        ::std::f32::INFINITY\n    } else {\n        ::std::f32::NAN\n    };\n    if half &amp; 0x8000 != 0 {\n        -val\n    } else {\n        val\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 9, "last_activity_date": 1572286448, "last_edit_date": 1572286448, "creation_date": 1457989849, "answer_id": 35998141, "question_id": 35998024, "link": "https://stackoverflow.com/questions/35998024/find-the-item-in-an-array-with-the-largest-property/35998141#35998141", "title": "Find the item in an array with the largest property", "body": "<p>Use <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max_by_key\" rel=\"nofollow noreferrer\"><code>Iterator::max_by_key</code></a>:</p>\n\n<pre><code>let a = [Point::new(1, 1), Point::new(4, 2), Point::new(2, 9)];\nlet max = a.iter().max_by_key(|p| p.x);\n</code></pre>\n\n<p>There's also <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min_by_key\" rel=\"nofollow noreferrer\"><code>Iterator::min_by_key</code></a>.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/49311954/155423\">How can min_by_key or max_by_key be used with references to a value created during iteration?</a></li>\n<li><a href=\"https://stackoverflow.com/q/37127209/155423\">Using max_by_key on a vector of floats</a></li>\n<li><a href=\"https://stackoverflow.com/q/53903318/155423\">What is the idiomatic way to get the index of a maximum or minimum floating point value in a slice or Vec in Rust?</a></li>\n</ul>\n"}], "owner": {"reputation": 317, "user_id": 4524649, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/70136933c6a9592e4499a93018315698?s=128&d=identicon&r=PG&f=1", "display_name": "ca1ek", "link": "https://stackoverflow.com/users/4524649/ca1ek"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2690, "favorite_count": 1, "answer_count": 1, "score": 7, "last_activity_date": 1572286448, "creation_date": 1457989439, "last_edit_date": 1543935601, "question_id": 35998024, "link": "https://stackoverflow.com/questions/35998024/find-the-item-in-an-array-with-the-largest-property", "title": "Find the item in an array with the largest property", "body": "<p>I have a struct like this</p>\n\n<pre><code>struct Point {\n    pub x: i32,\n    pub y: i32,\n}\n\nimpl Point {\n    fn new(x: i32, y: i32) -&gt; Self {\n        Point { x, y }\n    }\n}\n</code></pre>\n\n<p>And an array like this</p>\n\n<pre><code>[Point::new(1, 1), Point::new(4, 2), Point::new(2, 9)];\n</code></pre>\n\n<p>How do I pull the item with largest <code>point.x</code> from this array?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457970980, "post_id": 35992161, "comment_id": 59637013, "body": "Potential duplicate of <a href=\"http://stackoverflow.com/q/25474152/155423\">stackoverflow.com/q/25474152/155423</a>."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1457972035, "post_id": 35992161, "comment_id": 59637791, "body": "related issue on uninformative error message in array type length: <a href=\"https://github.com/rust-lang/rust/issues/24414\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/24414</a>"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457972567, "post_id": 35992161, "comment_id": 59638205, "body": "Did you really type <code>[i32::grid_size]</code> or is it <code>[i32; grid_size]</code>?"}, {"owner": {"reputation": 722, "user_id": 270943, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/7811eb1b0c6a0ddcd80c04457af54f2b?s=128&d=identicon&r=PG", "display_name": "tehnyit", "link": "https://stackoverflow.com/users/270943/tehnyit"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457972969, "post_id": 35992161, "comment_id": 59638484, "body": "@MatthieuM. I tried both suggestions and two different error messages were given by the compiler."}, {"owner": {"reputation": 722, "user_id": 270943, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/7811eb1b0c6a0ddcd80c04457af54f2b?s=128&d=identicon&r=PG", "display_name": "tehnyit", "link": "https://stackoverflow.com/users/270943/tehnyit"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457973197, "post_id": 35992161, "comment_id": 59638648, "body": "@MatthieuM. I double check again. The error reported of &quot;undeclared type&quot; is for <code>[i32; grid_size]</code>. I will update the question."}, {"owner": {"reputation": 722, "user_id": 270943, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/7811eb1b0c6a0ddcd80c04457af54f2b?s=128&d=identicon&r=PG", "display_name": "tehnyit", "link": "https://stackoverflow.com/users/270943/tehnyit"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457986644, "post_id": 35992161, "comment_id": 59646927, "body": "@Shepmaster Thanks for the pickup. Corrected."}], "answers": [{"comments": [{"owner": {"reputation": 722, "user_id": 270943, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/7811eb1b0c6a0ddcd80c04457af54f2b?s=128&d=identicon&r=PG", "display_name": "tehnyit", "link": "https://stackoverflow.com/users/270943/tehnyit"}, "edited": false, "score": 0, "creation_date": 1457987001, "post_id": 35996973, "comment_id": 59647146, "body": "Thanks. That fixes it. I made the mistake in a couple of spots. First, I should have used a const so that size of the array is constant. The second mistake is that Iuse i32 instead of the usize."}], "tags": [], "owner": {"reputation": 928, "user_id": 5924630, "user_type": "registered", "profile_image": "https://lh5.googleusercontent.com/-dXM_U4iuN40/AAAAAAAAAAI/AAAAAAAAABI/cayI6h8ZfvA/photo.jpg?sz=128", "display_name": "Yasammez", "link": "https://stackoverflow.com/users/5924630/yasammez"}, "is_accepted": true, "score": 5, "last_activity_date": 1457997296, "last_edit_date": 1457997296, "creation_date": 1457985774, "answer_id": 35996973, "question_id": 35992161, "link": "https://stackoverflow.com/questions/35992161/what-is-the-equivalent-of-cs-define-when-specifying-an-array-size-in-rust/35996973#35996973", "title": "What is the equivalent of C&#39;s #define when specifying an array size in Rust?", "body": "<p>Rust only allows arrays of compile-time fixed size (dynamically sized spans of the same sized thing in memory are called slices and only available by reference into another container, like a <code>Vec</code>). Also, when instantiating them, it wants an unsigned type like <code>usize</code>, not an <code>i32</code>. Try</p>\n\n<pre><code>const GRID_SIZE: usize = 10;\n\nfn main() {\n    let mut grid: [i32; GRID_SIZE] = [0; GRID_SIZE];\n}\n</code></pre>\n"}], "owner": {"reputation": 722, "user_id": 270943, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/7811eb1b0c6a0ddcd80c04457af54f2b?s=128&d=identicon&r=PG", "display_name": "tehnyit", "link": "https://stackoverflow.com/users/270943/tehnyit"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 404, "favorite_count": 1, "accepted_answer_id": 35996973, "answer_count": 1, "score": 0, "last_activity_date": 1457997296, "creation_date": 1457970742, "last_edit_date": 1457988420, "question_id": 35992161, "link": "https://stackoverflow.com/questions/35992161/what-is-the-equivalent-of-cs-define-when-specifying-an-array-size-in-rust", "title": "What is the equivalent of C&#39;s #define when specifying an array size in Rust?", "body": "<p>I am starting to learn Rust and I have a background in C.</p>\n\n<p>I am trying to convert the following code snippet from C to Rust. The code defines an array of <code>uint8_t</code> with a size that is defined at compile time.</p>\n\n<pre><code>#define GRID_SIZE  100\n\nuint8_t grid[GRID_SIZE];\nmemset (grid, 0x00, GRID_SIZE);\n</code></pre>\n\n<p>I have tried the following in Rust</p>\n\n<pre><code>let grid_size: i32 = 10;\nlet mut grid: [i32; grid_size] = [0; grid_size];\n</code></pre>\n\n<p>the compiler complains that <code>error: use of undeclared type name `grid_size` [E0412]</code></p>\n\n<p>Looking up the error E0412 does not provide me with any clue. Is this possible in Rust?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1457969132, "post_id": 35991252, "comment_id": 59635548, "body": "i think <code>.map(AsRef::as_ref)</code> would be cleaner than <code>as</code>"}, {"owner": {"reputation": 197, "user_id": 6061422, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/d6df48adc37617510e77121ef411af80?s=128&d=identicon&r=PG&f=1", "display_name": "cloakedlearning", "link": "https://stackoverflow.com/users/6061422/cloakedlearning"}, "edited": false, "score": 0, "creation_date": 1457969309, "post_id": 35991252, "comment_id": 59635684, "body": "Thanks @Shepmaster, this does the trick. Is this the most idiomatic way to print an optional in a borrowed context?"}, {"owner": {"reputation": 236, "user_id": 6069818, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a8d21e059f672c38a3609d3876a4c6c1?s=128&d=identicon&r=PG&f=1", "display_name": "qthree", "link": "https://stackoverflow.com/users/6069818/qthree"}, "edited": false, "score": 1, "creation_date": 1458124215, "post_id": 35991252, "comment_id": 59715346, "body": "<code>let v = optional.v.as_ref().map_or(&quot;none&quot;, AsRef::as_ref);</code>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1458131725, "last_edit_date": 1495539918, "creation_date": 1457968376, "answer_id": 35991252, "question_id": 35990871, "link": "https://stackoverflow.com/questions/35990871/referencing-options-in-a-borrowed-context/35991252#35991252", "title": "Referencing options in a borrowed context", "body": "<p>Use <a href=\"http://doc.rust-lang.org/core/option/enum.Option.html#method.as_ref\" rel=\"nofollow noreferrer\"><code>Option::as_ref</code></a>. In your example, you also have to deal with the fact that you need to match the type of a <code>&amp;String</code> to the default value.</p>\n\n<pre><code>let v = optional.v.as_ref().map(|s| s as &amp;str).unwrap_or(\"none\");\nlet v2 = optional.v2.as_ref().map(|s| s as &amp;str).unwrap_or(\"none\");\nprintln!(\"v:{} v2:{}\", v, v2);\n</code></pre>\n\n<p>As <a href=\"https://stackoverflow.com/questions/35990871/referencing-options-in-a-borrowed-context/35991252?noredirect=1#comment59635548_35991252\">ker points out</a>, you can also map <a href=\"http://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref\" rel=\"nofollow noreferrer\"><code>AsRef::as_ref</code></a>:</p>\n\n<pre><code>let v = optional.v.as_ref().map(AsRef::as_ref).unwrap_or(\"none\");\nlet v2 = optional.v2.as_ref().map(AsRef::as_ref).unwrap_or(\"none\");\nprintln!(\"v:{} v2:{}\", v, v2);\n</code></pre>\n\n<p>As <a href=\"https://stackoverflow.com/questions/35990871/referencing-options-in-a-borrowed-context/35991252?noredirect=1#comment59715346_35991252\">qthree points out</a>, there's a shorter version of <code>.map().unwrap()</code>. Tools like <a href=\"https://github.com/Manishearth/rust-clippy\" rel=\"nofollow noreferrer\">Rust Clippy</a> can help you find these when you don't have a legion of good programmers looking at your code ;-):</p>\n\n<pre><code>let v = optional.v.as_ref().map_or(\"none\", |s| s as &amp;str);\nlet v2 = optional.v2.as_ref().map_or(\"none\", AsRef::as_ref);\nprintln!(\"v:{} v2:{}\", v, v2);\n</code></pre>\n\n<blockquote>\n  <p>Is this the most idiomatic way to print an optional in a borrowed context?</p>\n</blockquote>\n\n<p>It's debatable. For example, if the value printed <code>\"none\"</code>, there'd be no way for the reader to know if it was actually <code>Some(\"none\")</code> or <code>None</code>. Does that distinction matter for the operation of your code?</p>\n\n<p>If I were printing data to the terminal for programmer consumption, I'd be more likely to just print using the <a href=\"http://doc.rust-lang.org/std/fmt/trait.Debug.html\" rel=\"nofollow noreferrer\"><code>Debug</code></a> formatter:</p>\n\n<pre><code>println!(\"v:{:?} v2:{:?}\", optional.v, optional.v2);\n</code></pre>\n\n<p>Although I'd really just derive <code>Debug</code> for <code>Optional</code> and print the whole thing:</p>\n\n<pre><code>#[derive(Debug)]\nstruct Optional { ... }\n</code></pre>\n\n\n\n<pre><code>for optional in &amp;optionals {\n    println!(\"{:?}\", optional);\n}\n</code></pre>\n\n<p>If it was truly for user consumption, I might have differing phrases:</p>\n\n<pre><code>match optional.v {\n    Some(ref s) =&gt; println!(\"The value is: {}\", s),\n    None =&gt; println!(\"The value is not set\"),\n};\n</code></pre>\n"}], "owner": {"reputation": 197, "user_id": 6061422, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/d6df48adc37617510e77121ef411af80?s=128&d=identicon&r=PG&f=1", "display_name": "cloakedlearning", "link": "https://stackoverflow.com/users/6061422/cloakedlearning"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 247, "favorite_count": 0, "accepted_answer_id": 35991252, "answer_count": 1, "score": 0, "last_activity_date": 1458131725, "creation_date": 1457967345, "last_edit_date": 1457968264, "question_id": 35990871, "link": "https://stackoverflow.com/questions/35990871/referencing-options-in-a-borrowed-context", "title": "Referencing options in a borrowed context", "body": "<p>I'd like to be able to unwrap an optional inside a borrowed context. For example, to <code>println!</code> some value:</p>\n\n<pre><code>struct Optional {\n    v: Option&lt;String&gt;,\n    v2: Option&lt;String&gt;,\n}\n\nfn main() {\n    let mut optionals = vec![];\n    optionals.push(Optional { v: Some(\"foo\".to_string()), v2: Some(\"bar\".to_string())});\n    optionals.push(Optional { v: None, v2: None });\n\n    for optional in &amp;optionals {\n        println!(\"v:{} v2:{}\", optional.v.unwrap_or(\"none\".to_string()), optional.v2.unwrap_or(\"none\".to_string()));\n    }\n}\n</code></pre>\n\n<p>My understanding is that, this isn't possible because <code>optional</code> is borrowed and <code>unwrap_or</code> consumes it's input, which is disallowed because it's borrowed. I tried to take a <code>ref</code> to the struct values but failed again, how can achieve what I want without consuming <code>optionals</code>.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457962459, "post_id": 35988775, "comment_id": 59630370, "body": "Panics <b>are</b> immediately reported and the thread stops running. Your question really seems to be &quot;how can I join on the first thread that ends of a set of running threads&quot;. You want behavior similar to <code>select</code>."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 1, "creation_date": 1457962474, "post_id": 35988775, "comment_id": 59630381, "body": "What you&#39;re saying about Go is not correct. In Go, if a goroutine panics and if this panic is not recovered from, the whole process is aborted. The panic is never &quot;panicked back&quot; to the main thread. Or do you really mean that you need the whole process to stop if the panic has not been caught?"}, {"owner": {"reputation": 2878, "user_id": 655862, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/bad65d3d7319025d73e065d7a29ee22a?s=128&d=identicon&r=PG", "display_name": "Greg Weber", "link": "https://stackoverflow.com/users/655862/greg-weber"}, "edited": false, "score": 0, "creation_date": 1457976941, "post_id": 35988775, "comment_id": 59641097, "body": "good point, in go the main thread doesn&#39;t get unwound, the program just crashes, but the original panic is reported. This is in fact the behavior I want (although ideally resources would get cleaned up properly everywhere)."}, {"owner": {"reputation": 644, "user_id": 5326062, "user_type": "registered", "accept_rate": 67, "profile_image": "https://lh3.googleusercontent.com/-wyQqFvVdnKo/AAAAAAAAAAI/AAAAAAAAAwY/atuvPb80mWU/photo.jpg?sz=128", "display_name": "Ivan Temchenko", "link": "https://stackoverflow.com/users/5326062/ivan-temchenko"}, "edited": false, "score": 0, "creation_date": 1458030288, "post_id": 35988775, "comment_id": 59663416, "body": "will ` std::process::exit` called from thread terminate entire program or only the current thread? mb you can use it instead of panic and return some exit code to main thread?"}, {"owner": {"reputation": 2878, "user_id": 655862, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/bad65d3d7319025d73e065d7a29ee22a?s=128&d=identicon&r=PG", "display_name": "Greg Weber", "link": "https://stackoverflow.com/users/655862/greg-weber"}, "edited": false, "score": 0, "creation_date": 1458100710, "post_id": 35988775, "comment_id": 59703660, "body": "calling exit is a good idea. It doesn&#39;t seem to be possible until <code>recover</code> has stabilized though."}], "answers": [{"comments": [{"owner": {"reputation": 2878, "user_id": 655862, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/bad65d3d7319025d73e065d7a29ee22a?s=128&d=identicon&r=PG", "display_name": "Greg Weber", "link": "https://stackoverflow.com/users/655862/greg-weber"}, "edited": false, "score": 0, "creation_date": 1458137262, "post_id": 36031130, "comment_id": 59725284, "body": "It seems there is no way to kill a thread? If there was then to cleanup resources I could hold a reference to each spawned thread and kill each one."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 2878, "user_id": 655862, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/bad65d3d7319025d73e065d7a29ee22a?s=128&d=identicon&r=PG", "display_name": "Greg Weber", "link": "https://stackoverflow.com/users/655862/greg-weber"}, "edited": false, "score": 1, "creation_date": 1458138891, "post_id": 36031130, "comment_id": 59726577, "body": "There is no portable way to kill a thread at all. For example, you cannot kill (cancel) an arbitrary thread using pthreads (POSIX threads, which are natively available in Linux, for example). Various runtimes may provide some facilities for that (like Java&#39;s <code>Thread#stop()</code>) , but internally they are implemented using synchronization primitives and, moreover, they are not very safe and convenient to use. The only safe way to terminate a thread remotely is to manually provide a remotely triggered flag which a thread knows how to check. This may or may not be suitable for your purpose."}, {"owner": {"reputation": 479, "user_id": 802794, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2e99886b87e73b9e9bf71c1e59ae28ee?s=128&d=identicon&r=PG", "display_name": "Lucien Greathouse", "link": "https://stackoverflow.com/users/802794/lucien-greathouse"}, "edited": false, "score": 0, "creation_date": 1584050654, "post_id": 36031130, "comment_id": 107325969, "body": "There is now a stable version of this API. If you&#39;re running Rust 1.10.0 or newer, the equivalent panic handler APIs are now:  <a href=\"https://doc.rust-lang.org/beta/std/panic/fn.set_hook.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/beta/std/panic/fn.set_hook.html</a> and <a href=\"https://doc.rust-lang.org/beta/std/panic/fn.take_hook.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/beta/std/panic/fn.take_hook.html</a>"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 10, "last_activity_date": 1584121539, "last_edit_date": 1584121539, "creation_date": 1458119441, "answer_id": 36031130, "question_id": 35988775, "link": "https://stackoverflow.com/questions/35988775/how-can-i-cause-a-panic-on-a-thread-to-immediately-end-the-main-thread/36031130#36031130", "title": "How can I cause a panic on a thread to immediately end the main thread?", "body": "<p><strong>Updated for Rust 1.10+, see revision history for the previous version of the answer</strong></p>\n\n<blockquote>\n  <p>good point, in go the main thread doesn't get unwound, the program just crashes, but the original panic is reported. This is in fact the behavior I want (although ideally resources would get cleaned up properly everywhere).</p>\n</blockquote>\n\n<p>This you can achieve with the recently stable <a href=\"https://doc.rust-lang.org/std/panic/fn.set_hook.html\" rel=\"noreferrer\"><code>std::panic::set_hook()</code></a> function. With it, you can set a hook which prints the panic info and then exits the whole process, something like this:</p>\n\n<pre><code>use std::thread;\nuse std::panic;\nuse std::process;\n\nfn main() {\n    // take_hook() returns the default hook in case when a custom one is not set\n    let orig_hook = panic::take_hook();\n    panic::set_hook(Box::new(move |panic_info| {\n        // invoke the default handler and exit the process\n        orig_hook(panic_info);\n        process::exit(1);\n    }));\n\n    thread::spawn(move || {\n        panic!(\"something bad happened\");\n    }).join();\n\n    // this line won't ever be invoked because of process::exit()\n    println!(\"Won't be printed\");\n}\n</code></pre>\n\n<p>Try commenting the <code>set_hook()</code> call out, and you'll see that the <code>println!()</code> line gets executed.</p>\n\n<p>However, this approach, due to the use of <code>process::exit()</code>, will not allow resources allocated by other threads to be freed. In fact, I'm not sure that Go runtime allows this as well; it is likely that it uses the same approach with aborting the process.</p>\n"}, {"tags": [], "owner": {"reputation": 126, "user_id": 7519491, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/a3af280e5dd08982a857f27915c08882?s=128&d=identicon&r=PG", "display_name": "Artur Augustyniak", "link": "https://stackoverflow.com/users/7519491/artur-augustyniak"}, "is_accepted": false, "score": 8, "last_activity_date": 1486309809, "last_edit_date": 1486309809, "creation_date": 1486309379, "answer_id": 42053947, "question_id": 35988775, "link": "https://stackoverflow.com/questions/35988775/how-can-i-cause-a-panic-on-a-thread-to-immediately-end-the-main-thread/42053947#42053947", "title": "How can I cause a panic on a thread to immediately end the main thread?", "body": "<p>I tried to force my code to stop processing when any of threads panicked. The only more-or-less clear solution without using unstable features was to use <code>Drop</code> trait implemented on some struct. This can lead to a resource leak, but in my scenario I'm ok with this.</p>\n\n<pre><code>use std::process;\nuse std::thread;\nuse std::time::Duration;\n\n\nstatic THREAD_ERROR_CODE: i32 = 0x1;\nstatic NUM_THREADS: u32 = 17;\nstatic PROBE_SLEEP_MILLIS: u64 = 500;\n\nstruct PoisonPill;\n\nimpl Drop for PoisonPill {\n    fn drop(&amp;mut self) {\n        if thread::panicking() {\n            println!(\"dropped while unwinding\");\n            process::exit(THREAD_ERROR_CODE);\n        }\n    }\n}\n\nfn main() {\n    let mut thread_handles = vec![];\n\n    for i in 0..NUM_THREADS {\n        thread_handles.push(thread::spawn(move || {\n            let b = PoisonPill;\n            thread::sleep(Duration::from_millis(PROBE_SLEEP_MILLIS));\n            if i % 2 == 0 {\n                println!(\"kill {}\", i);\n                panic!();\n            }\n            println!(\"this is thread number {}\", i);\n        }));\n    }\n\n    for handle in thread_handles {\n        let _ = handle.join();\n    }\n}\n</code></pre>\n\n<p>No matter how <code>b = PoisonPill</code> leaves it's scope, normal or after <code>panic!</code>, its <code>Drop</code> method kicks in. You can distinguish if the caller panicked using <code>thread::panicking</code> and take some action \u2014 in my case killing the process.</p>\n"}], "owner": {"reputation": 2878, "user_id": 655862, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/bad65d3d7319025d73e065d7a29ee22a?s=128&d=identicon&r=PG", "display_name": "Greg Weber", "link": "https://stackoverflow.com/users/655862/greg-weber"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3491, "favorite_count": 1, "accepted_answer_id": 36031130, "answer_count": 2, "score": 10, "last_activity_date": 1584121539, "creation_date": 1457961767, "last_edit_date": 1458060157, "question_id": 35988775, "link": "https://stackoverflow.com/questions/35988775/how-can-i-cause-a-panic-on-a-thread-to-immediately-end-the-main-thread", "title": "How can I cause a panic on a thread to immediately end the main thread?", "body": "<p>In Rust, a panic terminates the current thread but is not sent back to the main thread. The solution we are told is to use <code>join</code>. However, this blocks the currently executing thread. So if my main thread spawns 2 threads, I cannot join both of them and immediately get a panic back.</p>\n\n<pre><code>let jh1 = thread::spawn(|| { println!(\"thread 1\"); sleep(1000000); };\nlet jh2 = thread::spawn(|| { panic!(\"thread 2\") };\n</code></pre>\n\n<p>In the above, if I join on thread 1 and then on thread 2 I will be waiting for 1 before ever receiving a panic from either thread</p>\n\n<p>Although in some cases I desire the current behavior, my goal is to default to Go's behavior where I can spawn a thread and have it panic on that thread and then immediately end the main thread. (The Go specification also documents a <code>protect</code> function, so it is easy to achieve Rust behavior in Go).</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457951070, "post_id": 35984589, "comment_id": 59622593, "body": "Possible duplicate of <a href=\"http://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct\">Why can&#39;t I store a value and a reference to that value in the same struct?</a>"}, {"owner": {"reputation": 1845, "user_id": 716390, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/03291df3e8db07ec188e120f66624272?s=128&d=identicon&r=PG", "display_name": "kriomant", "link": "https://stackoverflow.com/users/716390/kriomant"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457951351, "post_id": 35984589, "comment_id": 59622771, "body": "I have read that question, and I understand why I can&#39;t store reference to owned value \u2014 because value is moved when stored to struct and later, when struct itself is moved. However, in my case value is boxed, so reference is stable and, while it may be not expressible in Rust, it must be valid."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457951472, "post_id": 35984589, "comment_id": 59622851, "body": "In this case, could you (1) cite this link in your question and (2) explain in your question what you understood and why you think that your case is different? This will help us understand exactly what to explain."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457960180, "post_id": 35987278, "comment_id": 59628679, "body": "WoW. This self-locking is just magic. It took me a bit to understand the difference of behavior between before <code>turn_on</code> (where I can move the engine anywhere) and after <code>turn_on</code> (where it&#39;s immovable) and I&#39;m still not sure I have all the details sorted out. The fact that it&#39;s immovable afterward might be painful though (there is no <code>turn_off</code>)."}, {"owner": {"reputation": 1845, "user_id": 716390, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/03291df3e8db07ec188e120f66624272?s=128&d=identicon&r=PG", "display_name": "kriomant", "link": "https://stackoverflow.com/users/716390/kriomant"}, "edited": false, "score": 1, "creation_date": 1457966720, "post_id": 35987278, "comment_id": 59633662, "body": "Yeah, this self-locking is really cool trick. However, I don&#39;t like two-stage initialization, so I will probably resort to sharing API by Rc."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 2, "last_activity_date": 1457957657, "creation_date": 1457957657, "answer_id": 35987278, "question_id": 35984589, "link": "https://stackoverflow.com/questions/35984589/how-to-give-reference-to-owned-boxed-struct-to-other-owned-struct/35987278#35987278", "title": "How to give reference to owned boxed struct to other owned struct", "body": "<p>The problem is that in your example, there's nothing binding the <code>api</code> object to live longer than the scope it is created in. So basically you'd need to create the entire engine object first, and then Rust could reason about these lifetimes. But you can't create an object safely without filling out all fields. But you can change the <code>worker</code> field to an <code>Option</code> and fill it out later:</p>\n\n<pre><code>struct Engine&lt;'a&gt; {\n    api: Box&lt;Api&gt;,\n    worker: Option&lt;Box&lt;Worker&lt;'a&gt;&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Engine&lt;'a&gt; {\n    fn new() -&gt; Self {\n        let api = Box::new(Api);\n        Engine { api: api, worker: None }\n    }\n    fn turn_on(&amp;'a mut self) {\n        self.worker = Some(Box::new(Worker::new(self.api.as_ref())));\n    }\n}\n\nfn main() {\n    let mut engine = Engine::new();\n    engine.turn_on();\n}\n</code></pre>\n\n<p>The call to <code>engine.turn_on()</code> will lock the object to ensure it will stay in the scope. You don't even need boxes to ensure safety then, because the object will become immovable:</p>\n\n<pre><code>struct Engine&lt;'a&gt; {\n    api: Api,\n    worker: Option&lt;Worker&lt;'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Engine&lt;'a&gt; {\n    fn new() -&gt; Self {\n        let api = Api;\n        Engine { api: api, worker: None }\n    }\n    fn turn_on(&amp;'a mut self) {\n        self.worker = Some(Worker::new(&amp;self.api));\n    }\n}\n\nfn main() {\n    let mut engine = Engine::new();\n    engine.turn_on();\n}\n</code></pre>\n\n<p>The Rust compiler cannot use the fact that the object should be movable because the things it references are stored on the heap and live at least as long as the object. Maybe some day in the future. For now you have to resort to unsafe code.</p>\n"}], "owner": {"reputation": 1845, "user_id": 716390, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/03291df3e8db07ec188e120f66624272?s=128&d=identicon&r=PG", "display_name": "kriomant", "link": "https://stackoverflow.com/users/716390/kriomant"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 553, "favorite_count": 0, "accepted_answer_id": 35987278, "answer_count": 1, "score": 3, "last_activity_date": 1457957657, "creation_date": 1457950130, "last_edit_date": 1495535281, "question_id": 35984589, "link": "https://stackoverflow.com/questions/35984589/how-to-give-reference-to-owned-boxed-struct-to-other-owned-struct", "title": "How to give reference to owned boxed struct to other owned struct", "body": "<p>I have <code>Engine</code> which owns <code>Worker</code> and I want <code>Engine</code> to provide some API to <code>Worker</code> as a reference to trait. API implementation is allocated using <code>Box</code> and is owned by <code>Engine</code>, so reference to it is stable and valid as long as worker is alive.</p>\n\n<p>But I don't understand how to express it in Rust.</p>\n\n<p>I have read <a href=\"https://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct\">Why can&#39;t I store a value and a reference to that value in the same struct?</a> and I understand why I can't pass reference to owned value. However, in my case, I pass reference not to owned value itself, but to boxed value, which won't be moved, so reference to it must be stable.</p>\n\n<p>Here is non-working prototype:</p>\n\n<pre><code>trait EngineApi {\n    fn foo(&amp;self);\n}\n\nstruct Worker&lt;'a&gt; {\n    api: &amp;'a EngineApi,\n}\nimpl&lt;'a&gt; Worker&lt;'a&gt; {\n    fn new(engine_api: &amp;'a EngineApi) -&gt; Self {\n        Worker { api: engine_api }\n    }\n}\n\nstruct Api;\nimpl EngineApi for Api {\n    fn foo(&amp;self) {} \n}\n\nstruct Engine&lt;'a&gt; {\n    api: Box&lt;Api&gt;,\n    worker: Box&lt;Worker&lt;'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; Engine&lt;'a&gt; {\n    fn new() -&gt; Self {\n        let api = Box::new(Api);\n        let worker = Box::new(Worker::new(api.as_ref()));\n        Engine { api: api, worker: worker }\n    }\n}\n\nfn main() {\n    let engine = Engine::new();\n}\n</code></pre>\n\n<p>Errors:</p>\n\n<pre><code>test.rs:27:37: 27:40 error: `api` does not live long enough\ntest.rs:27      let worker = Box::new(Worker::new(api.as_ref()));\n                                                  ^~~\ntest.rs:25:19: 29:3 note: reference must be valid for the lifetime 'a as defined on the block at 25:18...\ntest.rs:25  fn new() -&gt; Self {\ntest.rs:26      let api = Box::new(Api);\ntest.rs:27      let worker = Box::new(Worker::new(api.as_ref()));\ntest.rs:28      Engine { api: api, worker: worker }\ntest.rs:29  }\ntest.rs:26:27: 29:3 note: ...but borrowed value is only valid for the block suffix following statement 0 at 26:26\ntest.rs:26      let api = Box::new(Api);\ntest.rs:27      let worker = Box::new(Worker::new(api.as_ref()));\ntest.rs:28      Engine { api: api, worker: worker }\ntest.rs:29  }\nerror: aborting due to previous error\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1457946816, "post_id": 35983028, "comment_id": 59619881, "body": "My foo might be off.. but I don&#39;t think this is the error you&#39;re getting. You&#39;re more likely to get a <code>cannot borrow &#39;builder&#39; as mutable</code> error. Is this the exact error and line number? You appear to be mutating a field on the <code>MyStruct</code> instance with an immutable reference."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1457946877, "post_id": 35983028, "comment_id": 59619915, "body": "@SimonWhitehead: Oh, he&#39;s probably getting quite a few error given the signature of the methods in <a href=\"http://serde-rs.github.io/json/serde_json/builder/struct.ObjectBuilder.html\" rel=\"nofollow noreferrer\">ObjectBuilder</a>, they take <i>everything</i> by value :)"}, {"owner": {"reputation": 152, "user_id": 5974452, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh4.googleusercontent.com/-QVXEmZ-6WJc/AAAAAAAAAAI/AAAAAAAAABI/nZqax0SHiMY/photo.jpg?sz=128", "display_name": "Matrix", "link": "https://stackoverflow.com/users/5974452/matrix"}, "edited": false, "score": 0, "creation_date": 1457947590, "post_id": 35983028, "comment_id": 59620381, "body": ".... i check the serde_json souce code, it use self not &amp;self.... so i just change &amp;self to self should be ok..."}], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 1, "last_activity_date": 1458010724, "creation_date": 1458010724, "answer_id": 36001893, "question_id": 35983028, "link": "https://stackoverflow.com/questions/35983028/how-does-rusts-struct-hold-and-use-a-object/36001893#36001893", "title": "How does Rust&#39;s struct hold and use a object?", "body": "<p>The methods in <a href=\"https://serde-rs.github.io/json/serde_json/builder/struct.ObjectBuilder.html\" rel=\"nofollow\"><code>ObjectBuilder</code></a> take <code>self</code> by value. Since you can't move something out of a borrowed pointer, the easy solution is to make your methods on <code>MyStruct</code> take <code>self</code> by value as well.</p>\n\n<p>Also, <code>ObjectBuilder</code>'s methods return a new <code>ObjectBuilder</code> with the changes. You can wrap that return value into a new <code>MyStruct</code>, which you can return from your methods.</p>\n\n<pre><code>extern crate serde_json;\n\nuse serde_json::builder::ObjectBuilder;\n\nstruct MyStruct {\n    builder: ObjectBuilder,\n}\n\nimpl MyStruct {\n    fn new() -&gt; MyStruct {\n        MyStruct { builder: ObjectBuilder::new() }\n    }\n\n    fn add_string_member(self, name: &amp;str, value: &amp;str) -&gt; MyStruct {\n        MyStruct { builder: self.builder.insert(name, value) }\n    }\n}\n\nfn main() {\n    let s = MyStruct::new();\n    let s = s.add_string_member(\"name\", \"value\");\n}\n</code></pre>\n\n<p>If <code>MyStruct</code> also contains other members that you'd like to carry on into the new <code>MyStruct</code>, you can use a shortcut syntax to initialize the remaining fields of <code>MyStruct</code> from an existing instance:</p>\n\n<pre><code>fn add_string_member(self, name: &amp;str, value: &amp;str) -&gt; MyStruct {\n    MyStruct { builder: self.builder.insert(name, value), ..self }\n}\n</code></pre>\n\n<p>Here, the <code>builder</code> field of the new <code>MyStruct</code> will be set to the specified expression, and all other fields will be moved from <code>self</code>. (The <code>..</code> syntax accepts any expression of the proper type, not just <code>self</code>.)</p>\n"}], "owner": {"reputation": 152, "user_id": 5974452, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh4.googleusercontent.com/-QVXEmZ-6WJc/AAAAAAAAAAI/AAAAAAAAABI/nZqax0SHiMY/photo.jpg?sz=128", "display_name": "Matrix", "link": "https://stackoverflow.com/users/5974452/matrix"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 113, "favorite_count": 0, "accepted_answer_id": 36001893, "answer_count": 1, "score": 0, "last_activity_date": 1458010724, "creation_date": 1457945417, "last_edit_date": 1457959558, "question_id": 35983028, "link": "https://stackoverflow.com/questions/35983028/how-does-rusts-struct-hold-and-use-a-object", "title": "How does Rust&#39;s struct hold and use a object?", "body": "<p>I need to use a struct to hold a serde_json object, and use it later.</p>\n\n<pre><code>extern crate serde_json;\n\nuse serde_json::builder::ObjectBuilder;\n\nstruct MyStruct {\n    builder: ObjectBuilder,\n}\n\nimpl MyStruct {\n    fn new() -&gt; MyStruct {\n        MyStruct { builder: ObjectBuilder::new() }\n    }\n\n    fn add_string_member(&amp;self, name: &amp;str,  value: &amp;str) {\n        self.builder.insert(name, value); //here compile error\n    }\n}\n\nfn main() {\n    let s = MyStruct::new();\n    s.add_string_member(\"name\", \"value\");\n}\n</code></pre>\n\n<p>But I get the error</p>\n\n<pre><code>error: cannot move out of borrowed content [E0507]\n</code></pre>\n"}, {"tags": ["rust", "atexit"], "comments": [{"owner": {"reputation": 9105, "user_id": 119861, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/O2tUa.png?s=128&g=1", "display_name": "hansaplast", "link": "https://stackoverflow.com/users/119861/hansaplast"}, "edited": false, "score": 0, "creation_date": 1480920688, "post_id": 35980148, "comment_id": 69146297, "body": "I ran into the same problem, although my error code was <code>pointer being freed was not allocated</code>. When replacing <code>println!</code> with <code>libc::printf</code> it works though. I agree: it seems that the rust destruction runs too early"}], "answers": [{"tags": [], "owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "is_accepted": true, "score": 8, "last_activity_date": 1457942481, "creation_date": 1457942481, "answer_id": 35982254, "question_id": 35980148, "link": "https://stackoverflow.com/questions/35980148/why-does-an-atexit-handler-panic-when-it-accesses-stdout/35982254#35982254", "title": "Why does an atexit handler panic when it accesses stdout?", "body": "<p>You're confusing <code>libc::atexit</code>, which you call, and <code>sys_common::at_exit</code> (in src/libstd/sys/common/mod.rs) which your link points to and which Rust calls during early cleanup.</p>\n\n<p>Those are two different cleanup queues, and I wouldn't want to rely on them being executed in a specific order.</p>\n"}], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 970, "favorite_count": 0, "accepted_answer_id": 35982254, "answer_count": 1, "score": 5, "last_activity_date": 1457942481, "creation_date": 1457933354, "last_edit_date": 1457941428, "question_id": 35980148, "link": "https://stackoverflow.com/questions/35980148/why-does-an-atexit-handler-panic-when-it-accesses-stdout", "title": "Why does an atexit handler panic when it accesses stdout?", "body": "<p>The Rust program below panics when it accesses <code>stdout</code> in the <code>atexit</code> handler.</p>\n\n<pre><code>extern crate libc;\n\nextern \"C\" fn bye() {\n    println!(\"bye\");\n}\n\nfn main() {\n    println!(\"hello\");\n    unsafe { libc::atexit(bye) };\n}\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>hello\nthread '&lt;main&gt;' panicked at 'cannot access stdout during shutdown', ../src/libcore/option.rs:298\nfatal runtime error: Could not unwind stack, error = 5\nAn unknown error occurred\n</code></pre>\n\n<p>It seems to me that <a href=\"https://github.com/rust-lang/rust/blob/211296ddabb6a307a0f60af1cb93f39b85ba5bbd/src/libstd/io/lazy.rs#L54\" rel=\"noreferrer\">this registration</a> should run before our <code>atexit</code> registration, so <a href=\"https://github.com/rust-lang/rust/blob/211296ddabb6a307a0f60af1cb93f39b85ba5bbd/src/libstd/io/lazy.rs#L57\" rel=\"noreferrer\">this line</a> in the handler should run only after our custom handler. Thus it should not panic.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 1406, "user_id": 701211, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/bc08db90032b212b492536d31464550e?s=128&d=identicon&r=PG&f=1", "display_name": "JasonN", "link": "https://stackoverflow.com/users/701211/jasonn"}, "edited": false, "score": 0, "creation_date": 1457954705, "post_id": 35979218, "comment_id": 59624893, "body": "What happened to bytes! macro? That seems to be what i want."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 1406, "user_id": 701211, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/bc08db90032b212b492536d31464550e?s=128&d=identicon&r=PG&f=1", "display_name": "JasonN", "link": "https://stackoverflow.com/users/701211/jasonn"}, "edited": false, "score": 0, "creation_date": 1457957241, "post_id": 35979218, "comment_id": 59626606, "body": "@JasonN It got removed, and at least <a href=\"https://github.com/rust-lang/rfcs/pull/566\" rel=\"nofollow noreferrer\">two</a> <a href=\"https://github.com/rust-lang/rust/pull/18702\" rel=\"nofollow noreferrer\">proposals</a> to bring it back were knocked back."}, {"owner": {"reputation": 1406, "user_id": 701211, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/bc08db90032b212b492536d31464550e?s=128&d=identicon&r=PG&f=1", "display_name": "JasonN", "link": "https://stackoverflow.com/users/701211/jasonn"}, "edited": false, "score": 0, "creation_date": 1457957365, "post_id": 35979218, "comment_id": 59626683, "body": "That&#39;s strange. It is the same as stringify!() but for bytes. Why not remove stringify too? Same arguments apply. I&#39;m going to start another proposal but with my use case (differenr from the other two). There seems to be quite a few use cases that the devs didn&#39;t think of."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 5, "last_activity_date": 1457927215, "creation_date": 1457927215, "answer_id": 35979218, "question_id": 35979098, "link": "https://stackoverflow.com/questions/35979098/turn-a-number-into-a-byte-string-literal-similar-to-stringify/35979218#35979218", "title": "Turn a number into a byte string literal, similar to stringify!()", "body": "<p>You can't; at least, not without writing a compiler plugin, which is far beyond the scope of a simple Stack Overflow response.</p>\n\n<p>There's some basic documentation on the subject in the <a href=\"http://doc.rust-lang.org/book/compiler-plugins.html\">Compiler Plugins</a> chapter of the Rust Book, though do keep in mind that compiler plugins <em>only</em> work on nightly Rust; they do not work in any stable or beta release, thus also locking any crate that uses them to nightly Rust.</p>\n\n<p>Sorry about that.</p>\n"}], "owner": {"reputation": 1406, "user_id": 701211, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/bc08db90032b212b492536d31464550e?s=128&d=identicon&r=PG&f=1", "display_name": "JasonN", "link": "https://stackoverflow.com/users/701211/jasonn"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 214, "favorite_count": 1, "accepted_answer_id": 35979218, "answer_count": 1, "score": 4, "last_activity_date": 1457948421, "creation_date": 1457926196, "last_edit_date": 1457948421, "question_id": 35979098, "link": "https://stackoverflow.com/questions/35979098/turn-a-number-into-a-byte-string-literal-similar-to-stringify", "title": "Turn a number into a byte string literal, similar to stringify!()", "body": "<p>I'm trying to write a macro that would turn a number into a byte string literal, similar to how the <code>stringify!</code> macro can turn its argument into a <code>&amp;str</code>.</p>\n\n<p>More concretely, how would I write this:</p>\n\n<p><code>byte_stringify!(10) -&gt; b\"10\"</code></p>\n\n<p>I will be using this to create a large number of <code>const</code> structs, so I can't really rely on calling a method on <code>str</code>.</p>\n\n<p>More ambitiously, I'm actually trying to prepend and append some text before turning the argument into a byte string:</p>\n\n<p><code>make_arg!(10) -&gt; b\"x10y\"</code></p>\n\n<p><strong>Update:</strong></p>\n\n<p>Where did the old <code>bytes!</code> macro go? I think I want:\n<code>bytes!(stringify!(10))</code></p>\n"}, {"tags": ["type-conversion", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1457898365, "post_id": 35974890, "comment_id": 59604300, "body": "<i>I should use a trait for conversion which can fail</i> \u2014 see <a href=\"http://stackoverflow.com/q/30315099/155423\">previous question</a>."}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 3, "creation_date": 1457942981, "post_id": 35979485, "comment_id": 59617835, "body": "<i>(as of 10 minutes ago)</i> =&gt; talk about speedy resolution!"}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 11, "last_activity_date": 1457929209, "creation_date": 1457929209, "answer_id": 35979485, "question_id": 35974890, "link": "https://stackoverflow.com/questions/35974890/from-and-into-traits-and-conversion-of-usize-to-f64/35979485#35979485", "title": "From and Into traits and conversion of usize to f64", "body": "<p>The problem is that integer \u2192 floating point conversions, where the float type is the same size or smaller than the integer, <em>cannot</em> preserve all values.  So <code>usize</code> \u2192 <code>f64</code> loses precision on 64-bit.</p>\n\n<p>These sorts of conversions are basically the raison d'\u00eatre for the <a href=\"https://crates.io/crates/conv\" rel=\"noreferrer\"><code>conv</code></a> crate, which defines numerous fallible conversions between types (mostly built-in numeric ones).  This (as of 10 minutes ago) includes <code>isize</code>/<code>usize</code> \u2192 <code>f32</code>/<code>f64</code>.</p>\n\n<p>Using <code>conv</code>, you can do this:</p>\n\n<pre><code>use conv::prelude::*;\n\n...\n\nwhere T: ValueFrom&lt;usize&gt; + ...\n\n...\nans[k] = ans[k - 1] / (k + 1).value_as::&lt;T&gt;().unwrap();\n...\n</code></pre>\n\n<p><strong>Disclaimer</strong>: I am the author of the crate in question.</p>\n"}, {"tags": [], "owner": {"reputation": 111, "user_id": 7712578, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-hLcm8yBFA0w/AAAAAAAAAAI/AAAAAAAACz0/M6SAzQfKSvQ/photo.jpg?sz=128", "display_name": "Shaurya", "link": "https://stackoverflow.com/users/7712578/shaurya"}, "is_accepted": false, "score": 5, "last_activity_date": 1580654959, "last_edit_date": 1580654959, "creation_date": 1580646077, "answer_id": 60026040, "question_id": 35974890, "link": "https://stackoverflow.com/questions/35974890/from-and-into-traits-and-conversion-of-usize-to-f64/60026040#60026040", "title": "From and Into traits and conversion of usize to f64", "body": "<p>You can do it using <code>as</code>: </p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let num: f64 = 12 as f64 ;\n</code></pre>\n"}], "owner": {"reputation": 295, "user_id": 6057925, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1ea07abedba9c4fe8c636bebb801b21e?s=128&d=identicon&r=PG", "display_name": "Sidious Lord", "link": "https://stackoverflow.com/users/6057925/sidious-lord"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4350, "favorite_count": 1, "accepted_answer_id": 35979485, "answer_count": 2, "score": 8, "last_activity_date": 1580654959, "creation_date": 1457898118, "question_id": 35974890, "link": "https://stackoverflow.com/questions/35974890/from-and-into-traits-and-conversion-of-usize-to-f64", "title": "From and Into traits and conversion of usize to f64", "body": "<p>I've been trying to write some Rust code in a very generic way, without specifying the types explicitly.  However, I arrived at a point where I need to convert a <code>usize</code> to a <code>f64</code> and this doesn't work.  Presumably, <code>f64</code> does not have enough precision to hold a an arbitrary <code>usize</code> value.  When compiling on the nightly channel I get an error message: <code>error: the trait `core::convert::From&lt;usize&gt;` is not implemented for the type `f64` [E0277]</code>.</p>\n\n<p>What is the alternative, then, if I want to write the code as generic as possible?  Clearly I should use a trait for conversion which can fail (unlike <code>Into</code> or <code>From</code>).  Is there something like that already?  Is there a trait for implementing the conversion by <code>as</code>?</p>\n\n<p>Here is the code below.</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>#![feature(zero_one)]\nuse std::num::{Zero, One};\nuse std::ops::{Add, Mul, Div, Neg};\nuse std::convert::{From, Into};\n\n/// Computes the reciprocal of a polynomial or of a truncation of a\n/// series.\n///\n/// If the input is of length `n`, then this performs `n^2`\n/// multiplications.  Therefore the complexity is `n^2` when the type\n/// of the entries is bounded, but it can be larger if the type is\n/// unbounded, as for BigInt's.\n///\nfn series_reciprocal&lt;T&gt;(a: &amp;Vec&lt;T&gt;) -&gt; Vec&lt;T&gt;\n    where T: Zero + One + Add&lt;Output=T&gt; + Mul&lt;Output=T&gt; +\n             Div&lt;Output=T&gt; + Neg&lt;Output=T&gt; + Copy {\n\n    let mut res: Vec&lt;T&gt; = vec![T::zero(); a.len()];\n    res[0] = T::one() / a[0];\n\n    for i in 1..a.len() {\n        res[i] = a.iter()\n                  .skip(1)\n                  .zip(res.iter())\n                  .map(|(&amp;a, &amp;b)| a * b)\n                  .fold(T::zero(), |a, b| a + b) / (-a[0]);\n    }\n    res\n}\n\n/// This computes the ratios `B_n/n!` for a range of values of `n`\n/// where `B_n` are the Bernoulli numbers.  We use the formula\n///\n///    z/(e^z - 1) = \\sum_{k=1}^\\infty \\frac {B_k}{k!} z^k.\n///\n/// To find the ratios we truncate the series\n///\n///    (e^z-1)/z = 1 + 1/(2!) z + 1/(3!) z^2 + ...\n///\n/// to the desired length and then compute the inverse.\n///\nfn bernoulli_over_factorial&lt;T, U&gt;(n: U) -&gt; Vec&lt;T&gt;\n    where\n        U: Into&lt;usize&gt; + Copy,\n        T: Zero + One + Add&lt;Output=T&gt; + Mul&lt;Output=T&gt; +\n           Add&lt;Output=T&gt; + Div&lt;Output=T&gt; + Neg&lt;Output=T&gt; +\n           Copy + From&lt;usize&gt; {\n    let mut ans: Vec&lt;T&gt; = vec![T::zero(); n.into()];\n    ans[0] = T::one();\n    for k in 1..n.into() {\n        ans[k] = ans[k - 1] / (k + 1).into();\n    }\n    series_reciprocal(&amp;ans)\n}\n\nfn main() {\n    let v = vec![1.0f32, 1.0f32];\n    let inv = series_reciprocal(&amp;v);\n    println!(\"v = {:?}\", v);\n    println!(\"v^-1 = {:?}\", inv);\n    let bf = bernoulli_over_factorial::&lt;f64,i8&gt;(30i8);\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457887631, "post_id": 35972852, "comment_id": 59600078, "body": "Isn&#39;t <code>c</code> supposed to be a copy of <code>a</code> or <code>b</code>?"}, {"owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457887877, "post_id": 35972852, "comment_id": 59600164, "body": "@MatthieuM. It can&#39;t literally be a copy because this is Rust and that would be unsafe (if I understand correctly). Instead, access to the copies <code>a</code> and <code>b</code> are &quot;protected&quot; through a <code>RefCell</code> with the promise that they won&#39;t be accessed except when switching <code>c</code>. If you were to attempt to access <code>a</code> directly, that (should) cause a panic."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457888732, "post_id": 35972852, "comment_id": 59600468, "body": "Actually, it can be literally a copy, if using raw pointers. Of course, this will require unsafe code, but cross-attributes borrow are just not a thing in Rust."}, {"owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457889359, "post_id": 35972852, "comment_id": 59600723, "body": "@MatthieuM. True, of course. I&#39;m just hoping there is a way to do this without explicitly using unsafe code, since it seems to be safe at first glance (and your answer indeed shows that it is operationally equivalent to a safe solution)."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457889650, "post_id": 35972852, "comment_id": 59600845, "body": "I do not know any solution that do not use <code>unsafe</code>."}, {"owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457890457, "post_id": 35972852, "comment_id": 59601140, "body": "@MatthieuM. The idea behind using <code>RefCell</code> here is that there is probably no way to check it at compile time so I want to just punt the issue and rely on runtime checking, which I know I can satisfy. Only, I&#39;m probably not using it right and I am still getting compile errors."}], "answers": [{"comments": [{"owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "edited": false, "score": 0, "creation_date": 1457889155, "post_id": 35973140, "comment_id": 59600641, "body": "This is not an option in my use case. I have simplified the MCVE so that it seems as though this is reasonable, but I really am looking for something that compiles down to the equivalent of C <code>B* a; B* b; B* c;</code> with <code>c=a</code> and <code>c=b</code> methods."}, {"owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "edited": false, "score": 0, "creation_date": 1457889660, "post_id": 35973140, "comment_id": 59600850, "body": "To be more specific, the real problem has <code>c</code> switching between <code>a</code> and <code>f(a,b)</code>, where <code>f</code> consumes its arguments and doesn&#39;t give them back (so I have to store <code>a</code> on the side so I can switch back)."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "edited": false, "score": 0, "creation_date": 1457890333, "post_id": 35973140, "comment_id": 59601096, "body": "@MarioCarneiro: I have created a solution with the exact structure layout you requested; it&#39;s <code>unsafe</code>, obviously. I can&#39;t do much more, because the C in MCVE stands for complete, and apparently you are not quite exposing all requirements :)"}, {"owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "edited": false, "score": 0, "creation_date": 1457890868, "post_id": 35973140, "comment_id": 59601301, "body": "What is the <code>PhantomData</code> for? And why did you not opt for <code>a,b: Box&lt;B&gt;</code> directly?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "edited": false, "score": 0, "creation_date": 1457896101, "post_id": 35973140, "comment_id": 59603437, "body": "@MarioCarneiro: I suggest you read the documentation for PhantomData; and I am not using <code>a: Box&lt;B&gt;</code> because I want to call out the unsafety. If a maintainer were to accidentally suppose that my using <code>a: Box&lt;B&gt;</code> meant that <code>a</code> is the only pointer to that instance of <code>B</code>, then it would mean trouble down the line."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 2, "last_activity_date": 1457890290, "last_edit_date": 1457890290, "creation_date": 1457888937, "answer_id": 35973140, "question_id": 35972852, "link": "https://stackoverflow.com/questions/35972852/how-to-switch-between-two-pointers-in-a-struct/35973140#35973140", "title": "How to switch between two pointers in a struct", "body": "<p>A simple solution:</p>\n\n<pre><code>struct A {\n    a: B,\n    b: B,\n    c: u32,\n}\n\nimpl A {\n    pub fn new(a: B, b: B) -&gt; A { A { a: a, b: b, c: 0 } }\n\n    pub fn switch(&amp;mut self) { self.c += 1; self.c %= 2; }\n\n    pub fn get(&amp;self) -&gt; &amp;B {\n        match self.c {\n            0 =&gt; self.a,\n            1 =&gt; self.b,\n            _ =&gt; unreachable!(),\n        }\n    }\n}\n</code></pre>\n\n<p>We simply side-step the issue by NOT having multiple references to the same object; this allows us to be safe. There is a small sacrifice to syntax, but otherwise it should be unnoticeable performance-wise.</p>\n\n<hr>\n\n<p>An <code>unsafe</code> solution:</p>\n\n<pre><code>struct A {\n    a: *mut B,\n    b: *mut B,\n    c: *mut B,\n    _marker: PhantomData&lt;B&gt;,\n}\n\nimpl A {\n    pub fn new(a: B, b: B) -&gt; A {\n        A {\n            a: Box::new(a).into_raw(),\n            b: Box::new(b).into_raw(),\n            c: a,\n            _marker: PhantomData,\n        }\n    }\n\n    pub fn switch(&amp;mut self) {\n        self.c =\n            if self.a == self.c { self.b } else { self.a }\n    }\n\n    pub fn get(&amp;self) -&gt; &amp;B { unsafe { *self.c } }\n\n    pub fn get_mut(&amp;mut self) -&gt; &amp;mut B { unsafe { *self.c  } }\n}\n\nimpl Drop for A {\n    fn drop(&amp;mut self) {\n        unsafe {\n            Box::from_raw(self.a);\n            Box::from_raw(self.b);\n        }\n    }\n}\n</code></pre>\n\n<p>I would not make <code>c</code> public though, given it's unsafe to use.</p>\n"}], "owner": {"reputation": 1115, "user_id": 890016, "user_type": "registered", "accept_rate": 73, "profile_image": "https://i.stack.imgur.com/BO6bH.png?s=128&g=1", "display_name": "Mario Carneiro", "link": "https://stackoverflow.com/users/890016/mario-carneiro"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 143, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1457890290, "creation_date": 1457887264, "question_id": 35972852, "link": "https://stackoverflow.com/questions/35972852/how-to-switch-between-two-pointers-in-a-struct", "title": "How to switch between two pointers in a struct", "body": "<p>Here is a snippet of Rust pseudocode defining a struct:</p>\n\n<pre><code>struct A {\n    a : *B;\n    b : *B;\n    pub c : *B;\n}\n</code></pre>\n\n<p>(The pointers are C pointers, not sure if they should be <code>Box</code> or something else yet.) Here <code>c</code> will always be set to <code>a</code> or <code>b</code>, and all access will be through <code>c</code>; auxiliary methods defined for <code>A</code> will set <code>c = a</code> or <code>c = b</code>.</p>\n\n<p>What is the Rust-y way to do this? My first attempt used <code>a,b: RefCell&lt;Box&lt;B&gt;&gt;</code> and <code>c:Box&lt;B&gt;</code>, with <code>c</code> always <code>borrow</code>ed out to one or the other. But then I hit a snag in defining <code>new</code>:</p>\n\n<pre><code>new(b1: B, b2: B) -&gt; A {\n    let acell = RefCell::new(Box::new(b1)),\n    A { a: acell,\n        b: RefCell::new(Box::new(b2)),\n        c: *acell.borrow() }\n}\n</code></pre>\n\n<p>This doesn't work because <code>acell</code> \"does not live long enough\" (dies at the end of <code>new()</code> instead of escaping with the return).</p>\n"}, {"tags": ["rust", "standard-library", "idioms"], "comments": [{"owner": {"reputation": 1106, "user_id": 161659, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/jKJ7J.jpg?s=128&g=1", "display_name": "Sebastian Ullrich", "link": "https://stackoverflow.com/users/161659/sebastian-ullrich"}, "edited": false, "score": 0, "creation_date": 1457884633, "post_id": 35970238, "comment_id": 59598930, "body": "Note that <code>while let Some(u) = unprocessed.iter().next()</code> is equivalent to <code>for u in &amp;unprocessed</code>"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457886969, "post_id": 35970238, "comment_id": 59599831, "body": "You have another issue here: you cannot borrow <code>unprocessed</code> mutably while iterating over it/holding references into it. Why not simply have the loop <i>consume</i> <code>unprocessed</code> and simplify your program logic?"}], "answers": [{"comments": [{"owner": {"reputation": 2379, "user_id": 5045375, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/17ed0af705e0449fe49b74d8814a8ce2?s=128&d=identicon&r=PG", "display_name": "Filip Allberg", "link": "https://stackoverflow.com/users/5045375/filip-allberg"}, "edited": false, "score": 0, "creation_date": 1457872840, "post_id": 35970285, "comment_id": 59594758, "body": "How would you suggest to replace a <code>HashSet</code> with another collection. I just need <code>contains</code>, <code>remove</code> and <code>insert</code>. A vector with a home-brew <code>contains</code>? And a way to <code>remove</code> a specific object, either by looking up its index or some other approach."}, {"owner": {"reputation": 14973, "user_id": 128186, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/46c330659979615fe50c46f5f553b39f?s=128&d=identicon&r=PG", "display_name": "Arjan", "link": "https://stackoverflow.com/users/128186/arjan"}, "reply_to_user": {"reputation": 2379, "user_id": 5045375, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/17ed0af705e0449fe49b74d8814a8ce2?s=128&d=identicon&r=PG", "display_name": "Filip Allberg", "link": "https://stackoverflow.com/users/5045375/filip-allberg"}, "edited": false, "score": 0, "creation_date": 1457874346, "post_id": 35970285, "comment_id": 59595220, "body": "@FilipAllberg Can you give a code sample of what are you actually trying to do?"}, {"owner": {"reputation": 2379, "user_id": 5045375, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/17ed0af705e0449fe49b74d8814a8ce2?s=128&d=identicon&r=PG", "display_name": "Filip Allberg", "link": "https://stackoverflow.com/users/5045375/filip-allberg"}, "edited": false, "score": 0, "creation_date": 1457876987, "post_id": 35970285, "comment_id": 59596114, "body": "Provided a condensed example in the original post"}], "tags": [], "owner": {"reputation": 14973, "user_id": 128186, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/46c330659979615fe50c46f5f553b39f?s=128&d=identicon&r=PG", "display_name": "Arjan", "link": "https://stackoverflow.com/users/128186/arjan"}, "is_accepted": false, "score": 10, "last_activity_date": 1457872769, "last_edit_date": 1457872769, "creation_date": 1457872323, "answer_id": 35970285, "question_id": 35970238, "link": "https://stackoverflow.com/questions/35970238/why-does-hashmap-have-iter-mut-but-hashset-doesnt/35970285#35970285", "title": "Why does HashMap have iter_mut() but HashSet doesn&#39;t?", "body": "<p>You have to think about what <a href=\"http://doc.rust-lang.org/std/collections/struct.HashSet.html\" rel=\"noreferrer\"><code>HashSet</code></a> actually is. The <a href=\"https://doc.rust-lang.org/std/collections/hash_map/struct.IterMut.html\" rel=\"noreferrer\"><code>IterMut</code></a> that you get from <a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.iter_mut\" rel=\"noreferrer\"><code>HashMap::iter_mut()</code></a> is only mutable on the value part: <code>(&amp;key, &amp;mut val)</code>, (<code>(&amp;'a K, &amp;'a mut V)</code>)</p>\n\n<p><code>HashSet</code> is basically a <code>HashMap&lt;T, ()&gt;</code>, so the actual values are the keys, and if you would modify the keys the hash of them would have to be updated or you get an invalid <code>HashMap</code>.</p>\n"}, {"comments": [{"owner": {"reputation": 1106, "user_id": 161659, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/jKJ7J.jpg?s=128&g=1", "display_name": "Sebastian Ullrich", "link": "https://stackoverflow.com/users/161659/sebastian-ullrich"}, "edited": false, "score": 0, "creation_date": 1457884860, "post_id": 35972396, "comment_id": 59599018, "body": "If the type is not copyable, it might be easier to let the loop consume the set and let <code>derp</code> instead insert the items into a new <code>HashSet</code>"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 1106, "user_id": 161659, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/jKJ7J.jpg?s=128&g=1", "display_name": "Sebastian Ullrich", "link": "https://stackoverflow.com/users/161659/sebastian-ullrich"}, "edited": false, "score": 0, "creation_date": 1457891391, "post_id": 35972396, "comment_id": 59601508, "body": "True, but that wouldn&#39;t work if <code>derp</code> uses the set for other purposes than removing the current item, e.g. if the processing of an item depends on what other items are left to process (the implementation of <code>derp</code> in the question is just for demonstration purposes, as I understand it)."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 3, "last_activity_date": 1457884509, "creation_date": 1457884509, "answer_id": 35972396, "question_id": 35970238, "link": "https://stackoverflow.com/questions/35970238/why-does-hashmap-have-iter-mut-but-hashset-doesnt/35972396#35972396", "title": "Why does HashMap have iter_mut() but HashSet doesn&#39;t?", "body": "<p>If your <code>HashSet</code> contains a <code>Copy</code> type, such as <code>i32</code>, you can work on a copy of the value to release the borrow on the <code>HashSet</code> early. To do this, you need to eliminate all borrows from the bindings in the <code>while let</code> expression. In your original code, <code>u</code> is of type <code>&amp;i32</code>, and it keeps borrowing from <code>unprocessed</code> until the end of the loop. If we change the pattern to <code>Some(&amp;u)</code>, then <code>u</code> is of type <code>i32</code>, which doesn't borrow from anything, so we're free to use <code>unprocessed</code> as we like.</p>\n\n<pre><code>fn herp(v: i32) {\n    let mut unprocessed: HashSet&lt;i32&gt; = HashSet::new();\n    unprocessed.insert(v);\n\n    while let Some(&amp;u) = unprocessed.iter().next() {\n        derp(u, &amp;mut unprocessed);\n    }   \n}\n</code></pre>\n\n<p>If the type is not <code>Copy</code> or is too expensive to copy/clone, you can wrap them in <a href=\"http://doc.rust-lang.org/stable/std/rc/struct.Rc.html\" rel=\"nofollow\"><code>Rc</code></a> or <a href=\"http://doc.rust-lang.org/stable/std/sync/struct.Arc.html\" rel=\"nofollow\"><code>Arc</code></a>, and clone them as you iterate on them using <a href=\"http://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.cloned\" rel=\"nofollow\"><code>cloned()</code></a> (cloning an <code>Rc</code> or <code>Arc</code> doesn't clone the underlying value, it just clones the <code>Rc</code> pointer and increments the reference counter).</p>\n\n<pre><code>use std::collections::HashSet;\nuse std::rc::Rc;\n\nfn derp(v: &amp;i32, unprocessed: &amp;mut HashSet&lt;Rc&lt;i32&gt;&gt;) {\n    if unprocessed.contains(v) {\n        unprocessed.remove(v);\n    }   \n}\n\nfn herp(v: Rc&lt;i32&gt;) {\n    let mut unprocessed: HashSet&lt;Rc&lt;i32&gt;&gt; = HashSet::new();\n    unprocessed.insert(v);\n\n    while let Some(u) = unprocessed.iter().cloned().next() {\n        // If you don't use u afterwards,\n        // you could also pass if by value to derp.\n        derp(&amp;u, &amp;mut unprocessed);\n    }   \n}\n\nfn main() {\n    println!(\"Hello, world!\");\n    herp(Rc::new(10));\n}\n</code></pre>\n"}], "owner": {"reputation": 2379, "user_id": 5045375, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/17ed0af705e0449fe49b74d8814a8ce2?s=128&d=identicon&r=PG", "display_name": "Filip Allberg", "link": "https://stackoverflow.com/users/5045375/filip-allberg"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2052, "favorite_count": 0, "accepted_answer_id": 35972396, "answer_count": 2, "score": 3, "last_activity_date": 1457896617, "creation_date": 1457872070, "last_edit_date": 1457896617, "question_id": 35970238, "link": "https://stackoverflow.com/questions/35970238/why-does-hashmap-have-iter-mut-but-hashset-doesnt", "title": "Why does HashMap have iter_mut() but HashSet doesn&#39;t?", "body": "<p>What is the design rationale for supplying an <code>iter_mut</code> function for <a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.iter_mut\" rel=\"nofollow\"><code>HashMap</code></a> but not <a href=\"http://doc.rust-lang.org/std/collections/struct.HashSet.html\" rel=\"nofollow\"><code>HashSet</code></a> in Rust? </p>\n\n<p>Would it be a faux pas to roll one's own (assuming that can even be done)?</p>\n\n<p>Having one could alleviate situations that give rise to</p>\n\n<blockquote>\n  <p>previous borrow of <code>X</code> occurs here; the immutable borrow prevents \n  subsequent moves or mutable borrows of <code>X</code> until the borrow ends</p>\n</blockquote>\n\n<h1>Example</h1>\n\n<p><a href=\"https://play.rust-lang.org/?gist=be2ab19dda2d479dc715&amp;version=stable\" rel=\"nofollow\">An extremely convoluted example (Gist)</a> that does not show-case why the parameter passing is the way that it is. Has a short comment explaining the pain-point:</p>\n\n<pre><code>use std::collections::HashSet;\n\nfn derp(v: i32, unprocessed: &amp;mut HashSet&lt;i32&gt;) {\n    if unprocessed.contains(&amp;v) {\n\n        // Pretend that v has been processed\n        unprocessed.remove(&amp;v);\n    }   \n}\n\nfn herp(v: i32) {\n    let mut unprocessed: HashSet&lt;i32&gt; = HashSet::new();\n    unprocessed.insert(v);\n\n    // I need to iterate over the unprocessed values\n    while let Some(u) = unprocessed.iter().next() {\n\n        // And them pass them mutably to another function\n        // as I will process the values inside derp and\n        // remove them from the set.\n        //\n        // This is an extremely convoluted example but\n        // I need for derp to be a separate function\n        // as I will employ recursion there, as it is\n        // much more succinct than an iterative version.\n        derp(*u, &amp;mut unprocessed);\n    }   \n}\n\nfn main() {\n    println!(\"Hello, world!\");\n    herp(10);\n}\n</code></pre>\n\n<p>The statement</p>\n\n<pre><code>while let Some(u) = unprocessed.iter().next() {\n</code></pre>\n\n<p>is an immutable borrow, hence</p>\n\n<pre><code>derp(*u, &amp;mut unprocessed);\n</code></pre>\n\n<p>is impossible as unprocessed cannot be borrowed mutably. The immutable borrow does not end until the end of the while-loop.</p>\n\n<p>I have tried to use <a href=\"http://blog.ezyang.com/2013/12/two-bugs-in-the-borrow-checker-every-rust-developer-should-know-about/\" rel=\"nofollow\">this as reference</a> and essentially ended up with trying to fool the borrow checker through various permutations of assignments, enclosing braces, but due to the coupling of the intended expressions the problem remains.</p>\n"}, {"tags": ["tcp", "rust"], "answers": [{"tags": [], "owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "is_accepted": true, "score": 3, "last_activity_date": 1457872355, "creation_date": 1457872355, "answer_id": 35970297, "question_id": 35969943, "link": "https://stackoverflow.com/questions/35969943/how-to-read-and-write-to-a-tcpstream-simultaneously/35970297#35970297", "title": "How to read and write to a TCPStream simultaneously?", "body": "<p>You can use <a href=\"https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.try_clone\" rel=\"nofollow\"><code>try_clone</code></a> to get multiple handles for the stream.</p>\n"}], "owner": {"reputation": 2289, "user_id": 1454653, "user_type": "registered", "accept_rate": 87, "profile_image": "https://i.stack.imgur.com/FvI1V.jpg?s=128&g=1", "display_name": "dragostis", "link": "https://stackoverflow.com/users/1454653/dragostis"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 742, "favorite_count": 0, "accepted_answer_id": 35970297, "answer_count": 1, "score": 2, "last_activity_date": 1457896434, "creation_date": 1457870421, "last_edit_date": 1495541732, "question_id": 35969943, "link": "https://stackoverflow.com/questions/35969943/how-to-read-and-write-to-a-tcpstream-simultaneously", "title": "How to read and write to a TCPStream simultaneously?", "body": "<p><a href=\"https://stackoverflow.com/questions/26621746/in-rust-how-do-i-handle-parallel-read-writes-on-a-tcpstream\">This previous answer</a> does not work anymore since <code>TCPStream</code> does not have <code>clone()</code> anymore.</p>\n"}, {"tags": ["rust", "raw-pointer"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 6, "last_activity_date": 1457815798, "last_edit_date": 1457815798, "creation_date": 1457786159, "answer_id": 35957711, "question_id": 35957467, "link": "https://stackoverflow.com/questions/35957467/is-there-a-clearer-way-of-representing-dereferencing-raw-pointers-and-applying-t/35957711#35957711", "title": "Is there a clearer way of representing dereferencing raw pointers and applying their functions in Rust?", "body": "<p>No.  Raw pointers in Rust <strong>must</strong> be dereferenced manually, because doing so in an unsafe operation.</p>\n\n<p>If you're repeatedly dereferencing the same pointer over and over again, you can just convert it into a reference (<code>let block = &amp;*block;</code>).  Sadly, there is no postfix dereference operator, so there's not much you can do about the result of <code>next</code> being a pointer.</p>\n"}], "owner": {"reputation": 688, "user_id": 4157647, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/82e77ab7941218ff6733d668b8049185?s=128&d=identicon&r=PG&f=1", "display_name": "Harvey Adcock", "link": "https://stackoverflow.com/users/4157647/harvey-adcock"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 196, "favorite_count": 0, "accepted_answer_id": 35957711, "answer_count": 1, "score": 3, "last_activity_date": 1457815798, "creation_date": 1457784621, "question_id": 35957467, "link": "https://stackoverflow.com/questions/35957467/is-there-a-clearer-way-of-representing-dereferencing-raw-pointers-and-applying-t", "title": "Is there a clearer way of representing dereferencing raw pointers and applying their functions in Rust?", "body": "<p>I'm working with raw pointers in Rust and I've got a couple of lines which are really hard to read because I can't find an operator in Rust that has a similar function to <code>-&gt;</code> in C++. Does one exist?</p>\n\n<p>Here's a snippet of my code in its currently hard to read state:</p>\n\n<pre><code>(*(*block).next().unwrap()).split(ExcHeader(30));\n</code></pre>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457758385, "post_id": 35952391, "comment_id": 59563916, "body": "<i>where it won&#39;t compile for any <code>T</code> which contains references which don&#39;t outlive the <code>LuaState</code></i> \u2014 maybe I&#39;m tired, but this seems to have one too many negative conditions. You only want it to compile if all the references stored in <code>LuaState</code> outlive the state (&quot;all references in the state are valid while the state exists&quot;), no?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457767425, "post_id": 35952391, "comment_id": 59565707, "body": "Yes, that sounds right."}], "answers": [{"comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1457795738, "post_id": 35958776, "comment_id": 59574102, "body": "That looks pretty hopeful and simpler than I&#39;d been fearing! I&#39;ll have a play later. I hadn&#39;t realized that <code>T: &#39;a</code> is legal. Thanks!"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1457801145, "post_id": 35958776, "comment_id": 59576059, "body": "I couldn&#39;t find any mention of <code>T: &#39;a</code> in the Rust Book or reference; it seems to have been defined in this RFC: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0192-bounds-on-object-and-generic-types.md\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/blob/master/text/&hellip;</a>"}], "tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "is_accepted": true, "score": 3, "last_activity_date": 1457792498, "creation_date": 1457792498, "answer_id": 35958776, "question_id": 35952391, "link": "https://stackoverflow.com/questions/35952391/how-to-require-generic-moved-parameters-to-a-rust-method-live-as-long-as-the-obj/35958776#35958776", "title": "How to require generic moved parameters to a Rust method live as long as the object?", "body": "<p>You could embed a fake lifetime <code>'a</code> in <code>LuaState&lt;'a&gt;</code> and require <code>T: 'a</code> in <code>hide()</code>:</p>\n\n<pre><code>struct LuaState&lt;'a&gt; {\n    _foo: PhantomData&lt;&amp;'a ()&gt;,\n}\n\nimpl&lt;'a&gt; LuaState&lt;'a&gt; {\n    fn hide&lt;T: 'a&gt;(&amp;mut self, foo: T) {}\n}\n</code></pre>\n\n<p>I am not 100% sure that this is correct, but it seems to work with the example you've given. <a href=\"https://play.rust-lang.org/?gist=1183e0d34ab1ad560b84&amp;version=stable\" rel=\"nofollow\">(full playpen)</a></p>\n\n<p>Eliminating the <code>PhantomData</code> has the downside that the compiler no longer understands that <code>LuaState</code> logically owns an <code>Rc&lt;T&gt;</code> for various <code>T</code>. This could cause soundness issues if (as it appears to be) dropping a <code>LuaState</code> might drop <code>T</code> values.</p>\n"}], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 101, "favorite_count": 0, "accepted_answer_id": 35958776, "answer_count": 1, "score": 1, "last_activity_date": 1457792498, "creation_date": 1457743666, "last_edit_date": 1457758737, "question_id": 35952391, "link": "https://stackoverflow.com/questions/35952391/how-to-require-generic-moved-parameters-to-a-rust-method-live-as-long-as-the-obj", "title": "How to require generic moved parameters to a Rust method live as long as the object?", "body": "<p>I'm writing a Rust program which includes a Lua interpreter, and I need to save away objects of several types into Lua-managed memory (userdata), so that Lua will call methods on them. Typically they'll be something like <code>Rc&lt;T&gt;</code>, and appropriate method wrappers which know the right type will be registered.</p>\n\n<p>If I were only going to accept one type at a time, I can pass objects to the Lua state safely:</p>\n\n<pre><code>struct Foo&lt;'a&gt; {\n    badref: &amp;'a u32,\n}\n\nstruct LuaState&lt;T&gt; {\n    /* ... */\n    _foo: PhantomData&lt;T&gt;,\n}\n\nimpl&lt;T&gt; LuaState&lt;T&gt; {\n    fn hide(&amp;mut self, foo: T) {}\n}\n\nfn main() {\n    let mut l = LuaState{_foo: PhantomData};\n    {\n        let n = 7u32;\n        let foo = Foo { badref: &amp;n };\n        /* Correctly fails to compile, since l can keep a (hidden)\n         * reference to n after its scope ends */\n        l.hide(foo);\n    }\n}\n</code></pre>\n\n<p>I really want <code>LuaState</code> to not need the type parameter, but instead have a generic <code>hide</code> method:</p>\n\n<pre><code>struct LuaState {\n    /* ... */\n}\nimpl LuaState {\n    fn hide&lt;T&gt;(&amp;mut self, foo: T) {}\n}\n</code></pre>\n\n<p>...where it won't compile for any <code>T</code> which contains references which don't outlive the <code>LuaState</code>, just like I could for a single type at a time above.  I came close with:</p>\n\n<pre><code>trait LuaAble&lt;'a&gt; {}\nimpl&lt;'a&gt; LuaAble&lt;'a&gt; for Foo&lt;'a&gt; {}\n\nstruct LuaState&lt;'a&gt; {\n    marker: PhantomData&lt;LuaAble&lt;'a&gt;&gt;,\n}\n\nimpl&lt;'a&gt; LuaState&lt;'a&gt; {\n    fn hide&lt;T: LuaAble&lt;'a&gt;&gt;(&amp;mut self, foo: T) {}\n}\n</code></pre>\n\n<p>This nearly works; it stops the dangling reference example above, but it's also possible to implement the trait incorrectly:</p>\n\n<pre><code>impl&lt;'a, 'b&gt; LuaAble&lt;'b&gt; for Foo&lt;'a&gt; {}\n</code></pre>\n\n<p>This again lets the hidden dangling reference case compile since the lifetimes aren't bound together anymore.</p>\n\n<p>Is there any way to prevent passing into a method by value something which can't live as long as <code>&amp;self</code>?  I'm open to any ideas, whether they do something clever and/or terrible with traits, lifetimes, <code>for&lt;'a&gt;</code>, restructuring my code, etc.</p>\n"}, {"tags": ["generics", "rust", "traits", "associated-types"], "comments": [{"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 1, "creation_date": 1457739287, "post_id": 35951153, "comment_id": 59559822, "body": "Did you <i>try</i> what you thought might be in the right direction? It looks correct to me."}, {"owner": {"reputation": 2379, "user_id": 5045375, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/17ed0af705e0449fe49b74d8814a8ce2?s=128&d=identicon&r=PG", "display_name": "Filip Allberg", "link": "https://stackoverflow.com/users/5045375/filip-allberg"}, "reply_to_user": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1457739400, "post_id": 35951153, "comment_id": 59559857, "body": "Yes, did not work. On a cell now. I can follow up with the related error later"}, {"owner": {"reputation": 2379, "user_id": 5045375, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/17ed0af705e0449fe49b74d8814a8ce2?s=128&d=identicon&r=PG", "display_name": "Filip Allberg", "link": "https://stackoverflow.com/users/5045375/filip-allberg"}, "reply_to_user": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1457779950, "post_id": 35951153, "comment_id": 59568885, "body": "Thanks, now it works. I had missed adding the <code>Output =</code> at a particular implementer of the trait which caused a lot of errors in the compiler output so I simply missed it."}], "answers": [{"tags": [], "owner": {"reputation": 2379, "user_id": 5045375, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/17ed0af705e0449fe49b74d8814a8ce2?s=128&d=identicon&r=PG", "display_name": "Filip Allberg", "link": "https://stackoverflow.com/users/5045375/filip-allberg"}, "is_accepted": true, "score": 0, "last_activity_date": 1457815755, "last_edit_date": 1457815755, "creation_date": 1457815593, "answer_id": 35963109, "question_id": 35951153, "link": "https://stackoverflow.com/questions/35951153/is-it-possible-to-use-self-referential-associated-types-when-using-generics/35963109#35963109", "title": "Is it possible to use self-referential associated types when using generics?", "body": "<p>This ended up being a case of a programming error. As @ChrisMorgan pointed out <a href=\"http://is.gd/9qyS95\" rel=\"nofollow\">in his example</a>, the expression <code>Add&lt;Output = V&gt;</code> does compile. The reason the compiler wailed was that in one location in the production source-code <code>Output = V</code> had not been consistently added.</p>\n\n<p>Regrettably I must have also made some error when compiling the condensed MWE.</p>\n\n<p>So, the take-away for posterity is that</p>\n\n<pre><code>trait DirectedAcyclicGraph&lt;V, E&gt; where V: Add&lt;Output = V&gt;, E: Add&lt;Output = E&gt;\n</code></pre>\n\n<p>works.</p>\n"}], "owner": {"reputation": 2379, "user_id": 5045375, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/17ed0af705e0449fe49b74d8814a8ce2?s=128&d=identicon&r=PG", "display_name": "Filip Allberg", "link": "https://stackoverflow.com/users/5045375/filip-allberg"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 92, "favorite_count": 0, "accepted_answer_id": 35963109, "answer_count": 1, "score": 0, "last_activity_date": 1457815755, "creation_date": 1457735663, "last_edit_date": 1457736420, "question_id": 35951153, "link": "https://stackoverflow.com/questions/35951153/is-it-possible-to-use-self-referential-associated-types-when-using-generics", "title": "Is it possible to use self-referential associated types when using generics?", "body": "<p>Example: given the following trait,</p>\n\n<pre><code>trait DirectedAcyclicGraph&lt;V, E&gt; where V: Add, E: Add\n</code></pre>\n\n<p>I would like for whenever a value of the type <code>V</code> to a value of the same type that another value of type <code>V</code> is returned. Whenever a value of type <code>E</code> is added to another value of the same type I want another <code>E</code> to be returned.</p>\n\n<p>Naively, I thought that this might be in the right direction,</p>\n\n<pre><code>trait DirectedAcyclicGraph&lt;V, E&gt; where V: Add&lt;Output = V&gt;, E: Add&lt;Output = E&gt;\n</code></pre>\n\n<p>but that was just a shot in the dark.</p>\n\n<p>The documentation for <code>Add</code> supplies the following example,</p>\n\n<pre><code>use std::ops::Add;\n\nstruct Foo;\n\nimpl Add for Foo {\n    type Output = Foo;\n\n    fn add(self, _rhs: Foo) -&gt; Foo {\n        println!(\"Adding!\");\n        self\n    }\n}\n\nfn main() {\n    Foo + Foo;\n}\n</code></pre>\n\n<p>but I cannot understand how to provide an implementation for a generic type in the same way, if that is even possible.</p>\n"}, {"tags": ["rust", "standard-library"], "answers": [{"comments": [{"owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 1, "creation_date": 1457739623, "post_id": 35951141, "comment_id": 59559922, "body": "What if I&#39;m creating a library that doesn&#39;t need to use <code>std</code> stuff. Should I always mark it as <code>#![no_std]</code> in order for other no-std-crates to use it? What if I don&#39;t mark it <code>#![no_std]</code> and use <code>std::ops::Add</code>: can other no-std-crates use my crate?"}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "reply_to_user": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "edited": false, "score": 3, "creation_date": 1457740668, "post_id": 35951141, "comment_id": 59560275, "body": "@LukasKalbertodt The conventions about this are still unclear. You can&#39;t use a <code>std</code> crate from <code>no_std</code> even if it happens to use the subset of <code>std</code> that is also in <code>core</code>, which would be a reason to apply it liberally. But if a <code>no_std</code> crate later finds a reason to start depending on <code>std</code>, this would be a breaking change, so some people are wary of being too <code>no_std</code>-happy."}], "tags": [], "owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "is_accepted": true, "score": 22, "last_activity_date": 1457735600, "creation_date": 1457735600, "answer_id": 35951141, "question_id": 35951024, "link": "https://stackoverflow.com/questions/35951024/stdopsadd-or-coreopsadd/35951141#35951141", "title": "std::ops::Add or core::ops::Add?", "body": "<p>There aren't two traits. There is one trait which is exported under several interchangeable names. <em>This is far from unique</em>. Virtually everything in <code>core</code> is also exported from <code>std</code>, and virtually always under exactly the same path (i.e., you can just replace the \"core\" prefix with \"std\").</p>\n\n<p>As for which one you should use: If you have a reason to not link to the standard library (<code>#![no_std]</code>), then the <code>std::*</code> one isn't available so obviously you use <code>core::*</code>. If on the other hand you <em>do</em> use the standard library, you should use the <code>std::*</code> re-export. It is more customary and requires less typing.</p>\n"}, {"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": false, "score": 22, "last_activity_date": 1457735637, "creation_date": 1457735637, "answer_id": 35951147, "question_id": 35951024, "link": "https://stackoverflow.com/questions/35951024/stdopsadd-or-coreopsadd/35951147#35951147", "title": "std::ops::Add or core::ops::Add?", "body": "<p>They're in fact exactly the same, despite the set of implementors being listed as slightly different.</p>\n\n<p>The <code>core</code> library is designed for bare-metal/low-level tasks, and is thus more barebones than what <code>std</code> can provide by assuming an operating system exists. However, people using <code>std</code> will want the stuff that's in <code>core</code> too (e.g. <code>Add</code> or <code>Option</code> or whatever), and so to avoid having to load both <code>std</code> and <code>core</code>, <code>std</code> reexports everything from <code>core</code>, <a href=\"https://github.com/rust-lang/rust/blob/5807fbbfde3ad04820f6fa0269711c81538057ec/src/libstd/lib.rs#L332-L333\" rel=\"noreferrer\">via <code>pub use</code></a>. That is, <code>std</code> provides aliases/import paths for the things in <code>core</code>.</p>\n\n<p>There are <a href=\"https://github.com/rust-lang/rust/issues/21934\" rel=\"noreferrer\">some unfortunate error messages</a> where the compiler points to the original source of an item, not the reexport, which might not be in a crate you're <code>extern crate</code>ing.</p>\n"}], "owner": {"reputation": 2379, "user_id": 5045375, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/17ed0af705e0449fe49b74d8814a8ce2?s=128&d=identicon&r=PG", "display_name": "Filip Allberg", "link": "https://stackoverflow.com/users/5045375/filip-allberg"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3160, "favorite_count": 1, "accepted_answer_id": 35951141, "answer_count": 2, "score": 20, "last_activity_date": 1457736278, "creation_date": 1457734986, "last_edit_date": 1457736278, "question_id": 35951024, "link": "https://stackoverflow.com/questions/35951024/stdopsadd-or-coreopsadd", "title": "std::ops::Add or core::ops::Add?", "body": "<p>These two traits (<a href=\"https://doc.rust-lang.org/std/ops/trait.Add.html\" rel=\"noreferrer\">std::ops::Add</a>, <a href=\"https://doc.rust-lang.org/core/ops/trait.Add.html\" rel=\"noreferrer\">core::ops::Add</a>) provide the same functionality, and they both use the same example (both utilize <code>std::ops::Add</code>). Their set of implementors differ somewhat.</p>\n\n<p>Should one default to using <code>std::ops::Add</code>? Why do both, as opposed to one, of them exist?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "is_accepted": false, "score": 5, "last_activity_date": 1457735595, "creation_date": 1457735595, "answer_id": 35951137, "question_id": 35948420, "link": "https://stackoverflow.com/questions/35948420/error-closure-requires-unique-access-to-self-but-self-is-already-borrowed/35951137#35951137", "title": "Error: closure requires unique access to `self` but `self` is already borrowed", "body": "<p>It's just like the error message tells you. The problem is that you have overlapping mutable borrows of self. </p>\n\n<pre><code>    match self.buf_iter {\n        Some(ref mut iter) =&gt; { /// self.buf_iter is mutably borrowed here\n            iter.next()\n                .or_else(|| {\n                    self.piece_iter.next().and_then(|p| { /// which is why you can't mutably borrow self here again\n                        let mut buf = self.table.piece_buf(p)[p.start..(p.start + p.length)]\n                                          .iter();\n                        let item = buf.next();\n                        self.buf_iter = Some(buf);\n                        item\n                    })\n                })\n                .map(|b| *b)\n        }\n        None =&gt; None,\n    }\n</code></pre>\n\n<p>The solution is to make the first borrow end before the second one occurs.</p>\n\n<p>It's also possible to simplify the code a bit by writing more idiomatic Rust.</p>\n\n<pre><code>impl&lt;'a&gt; Iterator for PieceTableIterator&lt;'a&gt; {\n    type Item = u8;\n\n    fn next(&amp;mut self) -&gt; Option&lt;u8&gt; {\n        if self.buf_iter.is_none() {\n            return None;\n        }\n\n        self.buf_iter\n            .as_mut()\n            .and_then(Iterator::next)\n            .cloned()\n            .or_else(|| {\n                self.piece_iter.next().and_then(|p| {\n                    let mut buf = self.table.piece_buf(p)[p.start..(p.start + p.length)]\n                                      .iter();\n                    let item = buf.next().cloned();\n                    self.buf_iter = Some(buf);\n                    item\n                })\n            })\n    }\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 0, "last_activity_date": 1592838624, "creation_date": 1592838624, "answer_id": 62517597, "question_id": 35948420, "link": "https://stackoverflow.com/questions/35948420/error-closure-requires-unique-access-to-self-but-self-is-already-borrowed/62517597#62517597", "title": "Error: closure requires unique access to `self` but `self` is already borrowed", "body": "<p>The original code compiles as-is in modern Rust, presumably thanks to changes from <a href=\"https://stackoverflow.com/q/50251487/155423\">non-lexical lifetimes</a>. Some small idiomatic changes can be made as well:</p>\n<pre><code>#[derive(Debug)]\npub struct PieceTable {\n    // original file data: never changes\n    orig_buffer: Vec&lt;u8&gt;,\n    // all new data is pushed onto this buffer\n    add_buffer: Vec&lt;u8&gt;,\n    // the pieces that currently make up the file\n    pieces: Vec&lt;Piece&gt;,\n}\n\n#[derive(Debug, Copy, Clone)]\nenum Location {\n    Orig,\n    Add,\n}\n\n#[derive(Debug, Copy, Clone)]\nstruct Piece {\n    // which buffer is this piece located at?\n    buf: Location,\n    // starting offset\n    start: usize,\n    // size of piece\n    length: usize,\n}\n\nimpl PieceTable {\n    pub fn iter(&amp;self) -&gt; PieceTableIterator {\n        PieceTableIterator::new(self)\n    }\n\n    fn piece_buf(&amp;self, piece: &amp;Piece) -&gt; &amp;Vec&lt;u8&gt; {\n        match piece.buf {\n            Location::Orig =&gt; &amp;self.orig_buffer,\n            Location::Add =&gt; &amp;self.add_buffer,\n        }\n    }\n}\n\npub struct PieceTableIterator&lt;'a&gt; {\n    table: &amp;'a PieceTable,\n    buf_iter: Option&lt;std::slice::Iter&lt;'a, u8&gt;&gt;,\n    piece_iter: std::slice::Iter&lt;'a, Piece&gt;,\n}\n\nimpl&lt;'a&gt; PieceTableIterator&lt;'a&gt; {\n    fn new(table: &amp;PieceTable) -&gt; PieceTableIterator {\n        let mut piece_iter = table.pieces.iter();\n        let piece = piece_iter.next();\n        let buf_iter = piece.map(|p| table.piece_buf(p).iter());\n        PieceTableIterator {\n            table,\n            buf_iter,\n            piece_iter,\n        }\n    }\n}\n\nimpl&lt;'a&gt; Iterator for PieceTableIterator&lt;'a&gt; {\n    type Item = u8;\n\n    fn next(&amp;mut self) -&gt; Option&lt;u8&gt; {\n        let iter = self.buf_iter.as_mut()?;\n\n        iter.next()\n            .or_else(|| {\n                self.piece_iter.next().and_then(|p| {\n                    let mut buf = self.table.piece_buf(p)[p.start..(p.start + p.length)].iter();\n                    let item = buf.next();\n                    self.buf_iter = Some(buf);\n                    item\n                })\n            })\n            .copied()\n    }\n}\n\nfn main() {\n    let table = PieceTable {\n        orig_buffer: vec![1, 2, 3],\n        add_buffer: vec![4, 5, 6],\n        pieces: vec![\n            Piece {\n                buf: Location::Orig,\n                start: 0,\n                length: 2,\n            },\n            Piece {\n                buf: Location::Add,\n                start: 0,\n                length: 3,\n            },\n            Piece {\n                buf: Location::Orig,\n                start: 2,\n                length: 1,\n            },\n        ],\n    };\n    // shoud print 1, 2, 4, 5, 6, 3\n    for i in table.iter() {\n        println!(&quot;{}&quot;, i);\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 276, "user_id": 1063164, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/4ed48e2f79004bfacfb32a3ac5eb0fdf?s=128&d=identicon&r=PG", "display_name": "maxpolun", "link": "https://stackoverflow.com/users/1063164/maxpolun"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2888, "favorite_count": 0, "answer_count": 2, "score": 6, "last_activity_date": 1592838624, "creation_date": 1457724663, "last_edit_date": 1457815884, "question_id": 35948420, "link": "https://stackoverflow.com/questions/35948420/error-closure-requires-unique-access-to-self-but-self-is-already-borrowed", "title": "Error: closure requires unique access to `self` but `self` is already borrowed", "body": "<p>I'm learning Rust, and have decided to implement a piece table (described in section 6.4 of <a href=\"https://www.cs.unm.edu/~crowley/papers/sds.pdf\" rel=\"noreferrer\">this pdf</a>) since it's fairly simple, but non-trivial.</p>\n\n<p>It's mostly been pretty straightforward, but I've run into one issue I'm not really able to figure out. Here's a simplified version of my code, for reference:</p>\n\n<pre><code>use std::ops::Index;\n\n#[derive(Debug)]\npub struct PieceTable {\n    // original file data: never changes\n    orig_buffer: Vec&lt;u8&gt;,\n    // all new data is pushed onto this buffer\n    add_buffer: Vec&lt;u8&gt;,\n    // the pieces that currently make up the file\n    pieces: Vec&lt;Piece&gt;,\n}\n\n#[derive(Debug, Copy, Clone)]\nenum Location {\n    Orig,\n    Add,\n}\n\n#[derive(Debug, Copy, Clone)]\nstruct Piece {\n    // which buffer is this piece located at?\n    buf: Location,\n    // starting offset\n    start: usize,\n    // size of piece\n    length: usize,\n}\n\nimpl PieceTable {\n    pub fn iter(&amp;self) -&gt; PieceTableIterator {\n        PieceTableIterator::new(self)\n    }\n\n    fn piece_buf(&amp;self, piece: &amp;Piece) -&gt; &amp;Vec&lt;u8&gt; {\n        match piece.buf {\n            Location::Orig =&gt; &amp;self.orig_buffer,\n            Location::Add =&gt; &amp;self.add_buffer,\n        }\n    }\n\n    fn piece_value(&amp;self, piece: &amp;Piece, index: usize) -&gt; &amp;u8 {\n        &amp;self.piece_buf(piece)[index]\n    }\n}\n\npub struct PieceTableIterator&lt;'a&gt; {\n    table: &amp;'a PieceTable,\n    buf_iter: Option&lt;std::slice::Iter&lt;'a, u8&gt;&gt;,\n    piece_iter: std::slice::Iter&lt;'a, Piece&gt;,\n}\n\nimpl&lt;'a&gt; PieceTableIterator&lt;'a&gt; {\n    fn new(table: &amp;PieceTable) -&gt; PieceTableIterator {\n        let mut iter = table.pieces.iter();\n        let piece = iter.next();\n        let buf_iter = piece.map(|p| table.piece_buf(p).iter());\n        PieceTableIterator {\n            table: table,\n            buf_iter: buf_iter,\n            piece_iter: iter,\n        }\n    }\n}\n\nimpl&lt;'a&gt; Iterator for PieceTableIterator&lt;'a&gt; {\n    type Item = u8;\n\n    fn next(&amp;mut self) -&gt; Option&lt;u8&gt; {\n        if self.buf_iter.is_none() {\n\n            return None;\n        }\n        match self.buf_iter {\n            Some(ref mut iter) =&gt; {\n                iter.next()\n                    .or_else(|| {\n                        self.piece_iter.next().and_then(|p| {\n                            let mut buf = self.table.piece_buf(p)[p.start..(p.start + p.length)]\n                                              .iter();\n                            let item = buf.next();\n                            self.buf_iter = Some(buf);\n                            item\n                        })\n                    })\n                    .map(|b| *b)\n            }\n            None =&gt; None,\n        }\n    }\n}\n\nfn main() {\n    let table = PieceTable {\n        orig_buffer: vec![1, 2, 3],\n        add_buffer: vec![4, 5, 6],\n        pieces: vec![Piece {\n                         buf: Location::Orig,\n                         start: 0,\n                         length: 2,\n                     },\n                     Piece {\n                         buf: Location::Add,\n                         start: 0,\n                         length: 3,\n                     },\n                     Piece {\n                         buf: Location::Orig,\n                         start: 2,\n                         length: 1,\n                     }],\n    };\n    // shoud print 1, 2, 4, 5, 6, 3\n    for i in table.iter() {\n        println!(\"{}\", i);\n    }\n\n}\n</code></pre>\n\n<p>(<a href=\"https://play.rust-lang.org/?gist=084f377d1996a9b68752&amp;version=stable\" rel=\"noreferrer\">Playground</a>)</p>\n\n<p>I'm trying to build an iterator for this structure. I could do it very inefficiently by just keeping an index in the iterator, but then for each <code>.next()</code> call, I'd have to iterate over all of the pieces. Instead I'd rather have my iterator store an iterator for the pieces and an iterator for the slice of the buffer for the current piece. My problem (and I've tried a couple different approaches) is that I keep hitting lifetime issues. My current code give me the error:</p>\n\n<pre><code>:76:30: 84:22 error: closure requires unique access to `self` but `self.buf_iter.0` is already borrowed [E0500]\n</code></pre>\n\n<p>which I think I understand, but I'm not sure how to fix. I've tried a few variants of the current code, and they all run into similar problems. </p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "edited": false, "score": 1, "creation_date": 1457706340, "post_id": 35941697, "comment_id": 59541551, "body": "This is rather too vague to say what&#39;s idiomatic. Why do you need to overwrite the data this way, and why do you need to keep the data source (<code>s2</code> in your example) around?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457706499, "post_id": 35941697, "comment_id": 59541686, "body": "I agree with Sebastian Redl \u2014 if you <i>have</i> to transfer ownership but also still maintain ownership, then your only solution is to clone (or copy when possible) the item. Maybe you don&#39;t need to transfer ownership and could use a reference. Maybe you could use shared ownership like an <code>Rc</code> or <code>Arc</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457706532, "post_id": 35941697, "comment_id": 59541713, "body": "The <code>let mut s</code> doesn&#39;t seem to add anything to the example... maybe something got lost in copy-paste?"}, {"owner": {"reputation": 221, "user_id": 4481876, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/dedc3f9101eaa933cec2ab03a546d0ed?s=128&d=identicon&r=PG&f=1", "display_name": "estw272", "link": "https://stackoverflow.com/users/4481876/estw272"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457711038, "post_id": 35941697, "comment_id": 59545105, "body": "@Shepmaster my question is purely theoretical, this example is here just to illustrate what I mean. I was checking my code and noticed that I have a lot of structs which cant implement copy and sometimes I have to call a lot of methods that consume the struct on the same struct. Having like 20 lines of code cloning the same struct just seemed a bit ugly. Maybe you are right and my question <i>is</i> too vague."}], "answers": [{"comments": [{"owner": {"reputation": 221, "user_id": 4481876, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/dedc3f9101eaa933cec2ab03a546d0ed?s=128&d=identicon&r=PG&f=1", "display_name": "estw272", "link": "https://stackoverflow.com/users/4481876/estw272"}, "edited": false, "score": 0, "creation_date": 1457713398, "post_id": 35944439, "comment_id": 59546758, "body": "Thanks. I&#39;ve read the book, still getting confused sometimes. Btw the code as you wrote it still gives the borrowed content error @ <code>self.field = strt.field</code>"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 221, "user_id": 4481876, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/dedc3f9101eaa933cec2ab03a546d0ed?s=128&d=identicon&r=PG&f=1", "display_name": "estw272", "link": "https://stackoverflow.com/users/4481876/estw272"}, "edited": false, "score": 0, "creation_date": 1457717878, "post_id": 35944439, "comment_id": 59549645, "body": "@ehsisthatsweird: oopsie, the <code>field</code> itself has to be cloned of course :)"}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 5, "last_activity_date": 1457717858, "last_edit_date": 1457717858, "creation_date": 1457711211, "answer_id": 35944439, "question_id": 35941697, "link": "https://stackoverflow.com/questions/35941697/is-cloning-a-custom-struct-that-cant-implement-copy-every-time-you-want-to-use/35944439#35944439", "title": "Is cloning a custom struct that can&#39;t implement Copy every time you want to use it the best way to do it?", "body": "<p>Let's review our data handling story:</p>\n\n<ul>\n<li><strong>moving</strong> is about transferring ownership, because the original variable is no longer necessary</li>\n<li><strong>cloning</strong> is about creating a duplicate, so as to be able to use both the original and the new value independently</li>\n<li><strong>borrowing</strong> is about temporarily lending a reference for a controlled amount of time, so as to be able to use the original variable before and after (and possibly, if borrowed with <code>&amp;</code> and not <code>&amp;mut</code>, in a limited manner during)</li>\n</ul>\n\n<p>In your case, you should be using <em>borrowing</em> here.</p>\n\n<pre><code>fn overwrite(&amp;mut self, strt: &amp;MyStruct) {\n//                            ^\n    self.field = strt.field.clone();\n}\n\nfn main() {\n    let mut s = MyStruct::new();\n    let s2 = MyStruct::new();\n\n    s.overwrite(&amp;s2);\n    //          ^\n\n    println!(\"{:?}\", s2);\n}\n</code></pre>\n\n<p>For an in-depth treatment of the concept, read <a href=\"https://doc.rust-lang.org/book/ownership.html\" rel=\"nofollow\">the Rust Book</a>. And if you come from a garbage collected language background, the chapters 4.7 to 4.10 are REALLY a must read.</p>\n"}], "owner": {"reputation": 221, "user_id": 4481876, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/dedc3f9101eaa933cec2ab03a546d0ed?s=128&d=identicon&r=PG&f=1", "display_name": "estw272", "link": "https://stackoverflow.com/users/4481876/estw272"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 826, "favorite_count": 0, "accepted_answer_id": 35944439, "answer_count": 1, "score": 2, "last_activity_date": 1457717858, "creation_date": 1457703447, "last_edit_date": 1457706279, "question_id": 35941697, "link": "https://stackoverflow.com/questions/35941697/is-cloning-a-custom-struct-that-cant-implement-copy-every-time-you-want-to-use", "title": "Is cloning a custom struct that can&#39;t implement Copy every time you want to use it the best way to do it?", "body": "<p>I have a struct that has a <code>Vec</code> field and cannot implement <code>Copy</code>:</p>\n\n<pre><code>#[derive(Clone, Debug)]\nstruct MyStruct {\n    field: Vec&lt;i32&gt;,\n}\n\nimpl MyStruct {\n    fn new () -&gt; MyStruct {\n        MyStruct {\n            field: vec![1, 2],\n        }\n    }\n\n    fn overwrite(&amp;mut self, strt: MyStruct) {\n        self.field = strt.field;\n    }\n}\n</code></pre>\n\n<p>If I want to use it multiple times later in my code, I have to <code>clone()</code> it every time:</p>\n\n<pre><code>fn main() {\n    let mut s = MyStruct::new();\n    let s2 = MyStruct::new();\n\n    s.overwrite(s2.clone());\n\n    println!(\"{:?}\", s2);\n}\n</code></pre>\n\n<p>This works fine, but is this the best way to accomplish this task? Are there any other, more idiomatic ways?</p>\n"}, {"tags": ["generics", "iterator", "rust", "lifetime"], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 14, "last_activity_date": 1551274137, "last_edit_date": 1551274137, "creation_date": 1457704363, "answer_id": 35942023, "question_id": 35940068, "link": "https://stackoverflow.com/questions/35940068/writing-a-generic-function-that-takes-an-iterable-container-as-parameter-in-rust/35942023#35942023", "title": "Writing a generic function that takes an iterable container as parameter in Rust", "body": "<p>This is a case for Higher Ranked Trait Bounds (HRTB).</p>\n\n<p>The point is that you do not want <code>&amp;L</code> to implement <code>IntoIterator&lt;Item = &amp;T&gt;</code> for <em>one</em> lifetime but for <em>all</em> potential lifetimes that <code>L</code> may happen to have.</p>\n\n<p>In this case, you need to use a Higher Ranked Trait Bound: <code>for&lt;'a&gt;</code> will take care of introducing the lifetime name whilst simultaneously signaling to the compiler that the clause using it should be valid for all possible values of <code>'a</code>.</p>\n\n<p>This means:</p>\n\n<pre><code>impl&lt;T, L&gt; Observer&lt;L&gt; for SumObserver&lt;T&gt;\nwhere\n    for&lt;'a&gt; &amp;'a L: IntoIterator&lt;Item = &amp;'a T&gt;,\n{\n    fn update(&amp;self, observable: &amp;Observable&lt;L&gt;) {\n        let mut sum: i64 = 0;\n        for item in observable.get() {\n            sum += (self.get_value)(item);\n        }\n        *self.current_sum.borrow_mut() = sum;\n    }\n}\n</code></pre>\n\n<p>which compiles (at least in isolation).</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/35592750/155423\">How does for&lt;&gt; syntax differ from a regular lifetime bound?</a></li>\n</ul>\n"}], "owner": {"reputation": 143, "user_id": 6049607, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/eae2b51da499f0ca31c80d0a816c5d06?s=128&d=identicon&r=PG&f=1", "display_name": "Zoidberg", "link": "https://stackoverflow.com/users/6049607/zoidberg"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4415, "favorite_count": 3, "accepted_answer_id": 35942023, "answer_count": 1, "score": 14, "last_activity_date": 1551274398, "creation_date": 1457698569, "last_edit_date": 1551274398, "question_id": 35940068, "link": "https://stackoverflow.com/questions/35940068/writing-a-generic-function-that-takes-an-iterable-container-as-parameter-in-rust", "title": "Writing a generic function that takes an iterable container as parameter in Rust", "body": "<p>I want to write a generic function that takes any immutably borrowed iterable container such as an array, <code>Vec</code>, <code>BTreeSet</code>, etc. Since this function is part of a trait that I am implementing, I am not able to change the signature of it, so it's not possible to directly take an iterator as parameter and I also can't introduce any lifetime parameters to the function signature.</p>\n\n<h2>Context</h2>\n\n<p>I tried to implement the observer pattern in Rust. The observable and the observer look as follows:</p>\n\n<pre><code>struct Observable&lt;T&gt; {\n    value: T,\n}\n\nimpl&lt;T&gt; Observable&lt;T&gt; {\n    pub fn get(&amp;self) -&gt; &amp;T {\n        &amp;self.value\n    }\n}\n\ntrait Observer&lt;T&gt; {\n    fn update(&amp;self, &amp;Observable&lt;T&gt;);\n}\n</code></pre>\n\n<p>(Some functions that were irrelevant to my problem are omitted)</p>\n\n<p>It is now my objective to write an observer that can be used with arbitrary iterable containers which hold items that can be assigned a value. It is supposed to keep track of the sum of values of the items in the container and therefore holds the current sum and a function that calculates the value of any item. It should implement the <code>Observer</code> trait so the sum can be updated each time the container changes.</p>\n\n<pre><code>use std::cell::RefCell;\n\nstruct SumObserver&lt;T&gt; {\n    current_sum: RefCell&lt;i64&gt;,\n    get_value: Fn(&amp;T) -&gt; i64,\n}\n</code></pre>\n\n<h2>Approaches so far</h2>\n\n<p>I have unsuccessfully tried to get the <code>update</code> function to compile for quite some time. The following is one of the versions of the function that I tried:</p>\n\n<pre><code>impl&lt;'a, T, L&gt; Observer&lt;L&gt; for SumObserver&lt;T&gt;\nwhere\n    &amp;'a L: IntoIterator&lt;Item = &amp;'a T&gt;,\n{\n    fn update(&amp;self, observable: &amp;Observable&lt;L&gt;) {\n        let mut sum: i64 = 0;\n        for item in observable.get() {\n            sum += (self.get_value)(item);\n        }\n        *self.current_sum.borrow_mut() = sum;\n    }\n}\n</code></pre>\n\n<p>However, the compiler complains that both parameter types <code>T</code> and <code>L</code> might not live long enough:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0309]: the parameter type `T` may not live long enough\n  --&gt; src/lib.rs:22:1\n   |\n22 |   impl&lt;'a, T, L&gt; Observer&lt;L&gt; for SumObserver&lt;T&gt;\n   |   ^        - help: consider adding an explicit lifetime bound `T: 'a`...\n   |  _|\n   | |\n23 | | where\n24 | |     &amp;'a L: IntoIterator&lt;Item = &amp;'a T&gt;,\n25 | | {\n...  |\n32 | |     }\n33 | | }\n   | |_^\n   |\nnote: ...so that the reference type `&amp;'a T` does not outlive the data it points at\n  --&gt; src/lib.rs:22:1\n   |\n22 | / impl&lt;'a, T, L&gt; Observer&lt;L&gt; for SumObserver&lt;T&gt;\n23 | | where\n24 | |     &amp;'a L: IntoIterator&lt;Item = &amp;'a T&gt;,\n25 | | {\n...  |\n32 | |     }\n33 | | }\n   | |_^\n</code></pre>\n\n<p>The error message even stays the same if the whole function body is commented out. If I also remove the <code>where</code>-clause, the compilation works.</p>\n\n<p>If I follow the compiler's suggestion to add explicit lifetime bounds to the parameter types:</p>\n\n<pre><code>impl&lt;'a, T: 'a, L: 'a&gt; Observer&lt;L&gt; for SumObserver&lt;T&gt;\n</code></pre>\n\n<p>The compiler gives the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements\n  --&gt; src/lib.rs:28:32\n   |\n28 |         for item in observable.get() {\n   |                                ^^^\n   |\nnote: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the method body at 26:5...\n  --&gt; src/lib.rs:26:5\n   |\n26 | /     fn update(&amp;self, observable: &amp;Observable&lt;L&gt;) {\n27 | |         let mut sum: i64 = 0;\n28 | |         for item in observable.get() {\n29 | |             sum += (self.get_value)(item);\n30 | |         }\n31 | |         *self.current_sum.borrow_mut() = sum;\n32 | |     }\n   | |_____^\nnote: ...so that reference does not outlive borrowed content\n  --&gt; src/lib.rs:28:21\n   |\n28 |         for item in observable.get() {\n   |                     ^^^^^^^^^^\nnote: but, the lifetime must be valid for the lifetime 'a as defined on the impl at 22:6...\n  --&gt; src/lib.rs:22:6\n   |\n22 | impl&lt;'a, T: 'a, L: 'a&gt; Observer&lt;L&gt; for SumObserver&lt;T&gt;\n   |      ^^\n   = note: ...so that the types are compatible:\n           expected std::iter::IntoIterator\n              found std::iter::IntoIterator\n</code></pre>\n\n<p>I don't understand the problem with lifetimes in this function. At any point where this function is called, the compiler should make sure that the borrow of <code>observable</code> lasts at least until the function returns. At that time, any borrow of <code>observable</code> has gone out of scope.</p>\n"}, {"tags": ["pointers", "rust", "unsafe"], "comments": [{"owner": {"reputation": 30739, "user_id": 1804599, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/v91P3.jpg?s=128&g=1", "display_name": "rightfold", "link": "https://stackoverflow.com/users/1804599/rightfold"}, "edited": false, "score": 1, "creation_date": 1457694260, "post_id": 35938561, "comment_id": 59533360, "body": "LLVM (rustc&#39;s backend) will certainly detect such loops and optimise them to the fastest code possible."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 9, "creation_date": 1457695535, "post_id": 35938561, "comment_id": 59534150, "body": "you can use <a href=\"https://doc.rust-lang.org/std/ptr/fn.copy.html\" rel=\"nofollow noreferrer\">std::ptr::copy</a> or <a href=\"https://doc.rust-lang.org/std/ptr/fn.copy_nonoverlapping.html\" rel=\"nofollow noreferrer\">std::ptr::copy_nonoverlapping</a> (the latter probably, as you memory locations probably don&#39;t overlap (you need to guarantee this))"}, {"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 4, "creation_date": 1457703176, "post_id": 35938561, "comment_id": 59539155, "body": "@ker You should make that into an answer."}], "answers": [{"tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 6, "last_activity_date": 1457886580, "creation_date": 1457886580, "answer_id": 35972736, "question_id": 35938561, "link": "https://stackoverflow.com/questions/35938561/writing-to-multiple-bytes-efficiently-in-rust/35972736#35972736", "title": "Writing to multiple bytes efficiently in Rust", "body": "<p>As @ker mentioned in the comments, this is actually built in the standard library:</p>\n\n<ul>\n<li><a href=\"https://doc.rust-lang.org/std/ptr/fn.copy.html\"><code>std::ptr::copy</code></a> is equivalent to C's <code>memmove</code></li>\n<li><a href=\"https://doc.rust-lang.org/std/ptr/fn.copy_nonoverlapping.html\"><code>std::ptr::copy_nonoverlapping</code></a> is equivalent to C's <code>memcpy</code></li>\n</ul>\n\n<p>Note that while in Rust's way of moving objects (and thus transferring ownership) is just copying bits, unless an object is <code>Copy</code>, you need to ensure that only one of <code>src</code> or <code>dst</code> is used (and dropped) after the copy.</p>\n"}], "owner": {"reputation": 688, "user_id": 4157647, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/82e77ab7941218ff6733d668b8049185?s=128&d=identicon&r=PG&f=1", "display_name": "Harvey Adcock", "link": "https://stackoverflow.com/users/4157647/harvey-adcock"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 800, "favorite_count": 0, "accepted_answer_id": 35972736, "answer_count": 1, "score": 4, "last_activity_date": 1457886580, "creation_date": 1457694171, "last_edit_date": 1457703980, "question_id": 35938561, "link": "https://stackoverflow.com/questions/35938561/writing-to-multiple-bytes-efficiently-in-rust", "title": "Writing to multiple bytes efficiently in Rust", "body": "<p>I'm working with raw pointers in Rust and am trying to copy an area of memory from one place to another. I've got it successfully copying memory over, but only using a for loop and copying each byte individually using an offset of the pointer. I can't figure out how to do this more efficiently, i.e. as a single copy of a string of bytes, can anyone point me in the right direction?</p>\n\n<pre><code>fn copy_block_memory&lt;T&gt;(src: *const T, dst: *mut u8) {\n    let src = src as *const u8;\n    let size = mem::size_of::&lt;T&gt;();\n    unsafe {\n        let bytes = slice::from_raw_parts(src, size);\n        for i in 0..size as isize {\n            ptr::write(dst.offset(i), bytes[i as usize]);\n        }\n    }\n}\n</code></pre>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 5, "last_activity_date": 1457696705, "creation_date": 1457696705, "answer_id": 35939457, "question_id": 35938335, "link": "https://stackoverflow.com/questions/35938335/modifying-a-mutexoption/35939457#35939457", "title": "Modifying a Mutex&lt;Option&lt;&gt;&gt;", "body": "<p>Sure, there is:</p>\n\n<pre><code>*string = string.as_ref()\n    .map(|x| x.to_uppercase())\n    .unwrap_or_else(|| \"Empty\".to_owned())\n</code></pre>\n\n<p>This in fact is not specific to <code>Mutex</code>; the same problem and solution apply to <code>&amp;mut Option&lt;String&gt;</code>, for example. That said, the solution with <code>*string = match *string { ... }</code> is absolutely fine as well. BTW, you don't need <code>mut</code> in <code>Some(ref mut x)</code>, just <code>Some(ref x)</code> is fine - <code>to_uppercase()</code> only needs a shared reference to the string.</p>\n"}], "owner": {"reputation": 37324, "user_id": 513198, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/edf7f2190e60b6470bb6e4aab30152e7?s=128&d=identicon&r=PG", "display_name": "Xavier T.", "link": "https://stackoverflow.com/users/513198/xavier-t"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 607, "favorite_count": 0, "accepted_answer_id": 35939457, "answer_count": 1, "score": 6, "last_activity_date": 1457704655, "creation_date": 1457693569, "last_edit_date": 1457704655, "question_id": 35938335, "link": "https://stackoverflow.com/questions/35938335/modifying-a-mutexoption", "title": "Modifying a Mutex&lt;Option&lt;&gt;&gt;", "body": "<p>I have a quick stylistic or idiomatic question about <code>Mutex</code>.</p>\n\n<p>Is there a more elegant way to modify the data in <code>fn upper()</code> than using <code>*string = match *string</code>. It seems odd to dereference on both side, but if I don't, I don't know how to handle the <code>&lt;MutexGuard&gt;</code> part of string.</p>\n\n<p>Link to <a href=\"https://play.rust-lang.org/?gist=77ba93584f224e799b51&amp;version=stable\" rel=\"nofollow\">playground</a></p>\n\n<pre><code>use std::sync::{Mutex};\n\n#[derive(Debug)]\nstruct SharedFile{\n    file: Mutex&lt;Option&lt;String&gt;&gt;\n}\n\nimpl SharedFile{\n    fn new()-&gt; SharedFile{\n       SharedFile{\n           file: Mutex::new(Some(\"test\".to_owned())),\n           //file: Mutex::new(None),\n       }\n    }\n\n    fn upper(&amp;self){\n      let mut string  = self.file.lock().unwrap();\n\n      *string= match *string{\n         Some(ref mut x) =&gt; Some(x.to_uppercase()),\n         None =&gt; Some(\"Empty\".to_owned()),\n      };\n\n      println!(\"{:?}\", *string);\n    }\n}\n\nfn main() {\n        let shared = SharedFile::new();\n        shared.upper();\n        println!(\"{:?}\", shared);\n}\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "edited": false, "score": 0, "creation_date": 1458648282, "post_id": 35936995, "comment_id": 59944798, "body": "For anyone coming across this later, I believe this RFC addresses the problem in this question: <a href=\"https://github.com/rust-lang/rfcs/pull/1546\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/pull/1546</a>"}], "answers": [{"comments": [{"owner": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "edited": false, "score": 0, "creation_date": 1457694977, "post_id": 35937316, "comment_id": 59533804, "body": "Do you have a personal preference on how you would proceed? Use <code>RefCell</code>? Split the immutable data and the output string into two separate objects? Get rid of the trait and just handle it all in one type?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "edited": false, "score": 0, "creation_date": 1457702648, "post_id": 35937316, "comment_id": 59538747, "body": "@JimmyCuadra: For this particular example, I would say two traits and two structs... but I assume it&#39;s a reduced example, which is why I proposed multiple solutions and left it up to you to pick which seemed best in your case."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 4, "last_activity_date": 1457690930, "creation_date": 1457690930, "answer_id": 35937316, "question_id": 35936995, "link": "https://stackoverflow.com/questions/35936995/mutating-one-field-while-iterating-over-another-immutable-field/35937316#35937316", "title": "Mutating one field while iterating over another immutable field", "body": "<blockquote>\n  <p>Assume the indirection through the <code>Generator</code> trait is being used to share similar logic with other structs, so accessing <code>MyStruct</code>'s fields from the trait's default method implementations need to be done through accessor methods like this.</p>\n</blockquote>\n\n<p>Then it's impossible.</p>\n\n<hr>\n\n<p>The compiler recognizes access to different fields when it sees such fields <em>directly</em>; it does not break abstraction boundaries to peek inside the functions called.</p>\n\n<p>There have been discussions about adding attributes on the methods to specifically mention which field is accessed by which method:</p>\n\n<ul>\n<li>the compiler would enforce that a method does not touch any field NOT mentioned in the attribute</li>\n<li>the compiler could then use the knowledge that said method only operates on a subset of the fields</li>\n</ul>\n\n<p>however... this is for non-virtual methods.</p>\n\n<p>For a <em>trait</em> this gets significantly more complicated because a trait does not have fields, and each implementer may have a different set of fields!</p>\n\n<hr>\n\n<p>So now what?</p>\n\n<p>You will need to change your code:</p>\n\n<ul>\n<li>you can split the trait in two, and require two objects (one to iterate, one to mutate)</li>\n<li>you can \"hide\" the mutability of the <code>append</code> method, forcing users to use interior mutability</li>\n<li>...</li>\n</ul>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457702495, "post_id": 35937354, "comment_id": 59538634, "body": "On the one hand this requires changing the definition of <code>data</code> to <code>fn data(&amp;mut self) -&gt; &amp;mut Data</code> (note that it was constant up until now). On the other hand, I find it quite elegant!"}], "tags": [], "owner": {"reputation": 60956, "user_id": 8922, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/f1634a09333f7b391db92e1d2bea6253?s=128&d=identicon&r=PG", "display_name": "Sebastian Redl", "link": "https://stackoverflow.com/users/8922/sebastian-redl"}, "is_accepted": false, "score": 7, "last_activity_date": 1526488053, "last_edit_date": 1526488053, "creation_date": 1457691081, "answer_id": 35937354, "question_id": 35936995, "link": "https://stackoverflow.com/questions/35936995/mutating-one-field-while-iterating-over-another-immutable-field/35937354#35937354", "title": "Mutating one field while iterating over another immutable field", "body": "<p>This is a common issue in Rust; the typical way of solving it is the replace dance. This involves making more of the data and methods use mutable references:</p>\n\n<pre><code>struct Data {\n    pub items: Vec&lt;&amp;'static str&gt;,\n}\n\ntrait Generator {\n    fn append(&amp;mut self, s: &amp;str) {\n        self.output().push_str(s);\n    }\n\n    fn data(&amp;mut self) -&gt; &amp;mut Data;\n\n    fn generate_items(&amp;mut self) {\n        // Take the data. The borrow on self ends after this statement.\n        let data = std::mem::replace(self.data(), Data { items: vec![] });\n        // Iterate over the local version. Now append can borrow all it wants.\n        for item in data.items.iter() {\n            match *item {\n                \"foo\" =&gt; self.append(\"it was foo\\n\"),\n                _ =&gt; self.append(\"it was something else\\n\"),\n            }\n        }\n        // Put the data back where it belongs.\n        std::mem::replace(self.data(), data);\n    }\n    fn output(&amp;mut self) -&gt; &amp;mut String;\n}\n\nstruct MyGenerator&lt;'a&gt; {\n    data: &amp;'a mut Data,\n    output: String,\n}\n\nimpl&lt;'a&gt; MyGenerator&lt;'a&gt; {\n    fn generate(mut self) -&gt; String {\n        self.generate_items();\n\n        self.output\n    }\n}\n\nimpl&lt;'a&gt; Generator for MyGenerator&lt;'a&gt; {\n    fn data(&amp;mut self) -&gt; &amp;mut Data {\n        self.data\n    }\n\n    fn output(&amp;mut self) -&gt; &amp;mut String {\n        &amp;mut self.output\n    }\n}\n\nfn main() {\n    let mut data = Data {\n        items: vec![\"foo\", \"bar\", \"baz\"],\n    };\n\n    let generator = MyGenerator {\n        data: &amp;mut data,\n        output: String::new(),\n    };\n\n    let output = generator.generate();\n\n    println!(\"{}\", output);\n}\n</code></pre>\n\n<p>The thing to realize is that the compiler is <em>right</em> to complain. Imagine if calling <code>output()</code> had the side effect of mutating the thing that is referenced by the return value of <code>data()</code>  Then the iterator you're using in the loop could get invalidated. Your trait functions have the implicit contract that they don't do anything like that, but there is no way of checking this. So the only thing you can do is temporarily assume full control over the data, by taking it out.</p>\n\n<p>Of course, this pattern breaks unwind safety; a panic in the loop will leave the data moved out.</p>\n"}, {"tags": [], "owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "is_accepted": false, "score": 3, "last_activity_date": 1526488118, "last_edit_date": 1526488118, "creation_date": 1457692469, "answer_id": 35937900, "question_id": 35936995, "link": "https://stackoverflow.com/questions/35936995/mutating-one-field-while-iterating-over-another-immutable-field/35937900#35937900", "title": "Mutating one field while iterating over another immutable field", "body": "<p>You can use <a href=\"http://doc.rust-lang.org/std/cell/struct.RefCell.html\" rel=\"nofollow noreferrer\"><code>RefCell</code></a>:</p>\n\n<blockquote>\n  <p>RefCell uses Rust's lifetimes to implement 'dynamic borrowing', a\n  process whereby one can claim temporary, exclusive, mutable access to\n  the inner value. Borrows for RefCells are tracked 'at runtime',\n  unlike Rust's native reference types which are entirely tracked\n  statically, at compile time. Because RefCell borrows are dynamic it\n  is possible to attempt to borrow a value that is already mutably\n  borrowed; when this happens it results in thread panic.</p>\n</blockquote>\n\n<pre><code>use std::cell::{RefCell, RefMut};\n\nstruct Data {\n    pub items: Vec&lt;&amp;'static str&gt;,\n}\n\ntrait Generator {\n    fn append(&amp;self, s: &amp;str) {\n        self.output().push_str(s);\n    }\n\n    fn data(&amp;self) -&gt; &amp;Data;\n\n    fn generate_items(&amp;self) {\n        for item in self.data().items.iter() {\n            match *item {\n                \"foo\" =&gt; self.append(\"it was foo\\n\"),\n                _ =&gt; self.append(\"it was something else\\n\"),\n            }\n        }\n    }\n\n    fn output(&amp;self) -&gt; RefMut&lt;String&gt;;\n}\n\nstruct MyGenerator&lt;'a&gt; {\n    data: &amp;'a Data,\n    output: RefCell&lt;String&gt;,\n}\n\nimpl&lt;'a&gt; MyGenerator&lt;'a&gt; {\n    fn generate(self) -&gt; String {\n        self.generate_items();\n\n        self.output.into_inner()\n    }\n}\n\nimpl&lt;'a&gt; Generator for MyGenerator&lt;'a&gt; {\n    fn data(&amp;self) -&gt; &amp;Data {\n        self.data\n    }\n\n    fn output(&amp;self) -&gt; RefMut&lt;String&gt; {\n        self.output.borrow_mut()\n    }\n}\n\nfn main() {\n    let data = Data {\n        items: vec![\"foo\", \"bar\", \"baz\"],\n    };\n\n    let generator = MyGenerator {\n        data: &amp;data,\n        output: RefCell::new(String::new()),\n    };\n\n    let output = generator.generate();\n\n    println!(\"{}\", output);\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=a45573bbb23e60cdfe13&amp;version=stable\" rel=\"nofollow noreferrer\">Rust playground</a></p>\n"}], "owner": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1132, "favorite_count": 2, "accepted_answer_id": 35937316, "answer_count": 3, "score": 7, "last_activity_date": 1526488118, "creation_date": 1457690077, "last_edit_date": 1526487761, "question_id": 35936995, "link": "https://stackoverflow.com/questions/35936995/mutating-one-field-while-iterating-over-another-immutable-field", "title": "Mutating one field while iterating over another immutable field", "body": "<p>Given the following program:</p>\n\n<pre><code>struct Data {\n    pub items: Vec&lt;&amp;'static str&gt;,\n}\n\ntrait Generator {\n    fn append(&amp;mut self, s: &amp;str) {\n        self.output().push_str(s);\n    }\n\n    fn data(&amp;self) -&gt; &amp;Data;\n\n    fn generate_items(&amp;mut self) {\n        for item in self.data().items.iter() {\n            match *item {\n                \"foo\" =&gt; self.append(\"it was foo\\n\"),\n                _ =&gt; self.append(\"it was something else\\n\"),\n            }\n        }\n    }\n\n    fn output(&amp;mut self) -&gt; &amp;mut String;\n}\n\nstruct MyGenerator&lt;'a&gt; {\n    data: &amp;'a Data,\n    output: String,\n}\n\nimpl&lt;'a&gt; MyGenerator&lt;'a&gt; {\n    fn generate(mut self) -&gt; String {\n        self.generate_items();\n\n        self.output\n    }\n}\n\nimpl&lt;'a&gt; Generator for MyGenerator&lt;'a&gt; {\n    fn data(&amp;self) -&gt; &amp;Data {\n        self.data\n    }\n\n    fn output(&amp;mut self) -&gt; &amp;mut String {\n        &amp;mut self.output\n    }\n}\n\nfn main() {\n    let data = Data {\n        items: vec![\"foo\", \"bar\", \"baz\"],\n    };\n\n    let generator = MyGenerator {\n        data: &amp;data,\n        output: String::new(),\n    };\n\n    let output = generator.generate();\n\n    println!(\"{}\", output);\n}\n</code></pre>\n\n<p>The following errors are produced trying to compile it:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n  --&gt; src/main.rs:15:26\n   |\n13 |         for item in self.data().items.iter() {\n   |                     ----                   - immutable borrow ends here\n   |                     |\n   |                     immutable borrow occurs here\n14 |             match *item {\n15 |                 \"foo\" =&gt; self.append(\"it was foo\\n\"),\n   |                          ^^^^ mutable borrow occurs here\n\nerror[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n  --&gt; src/main.rs:16:22\n   |\n13 |         for item in self.data().items.iter() {\n   |                     ----                   - immutable borrow ends here\n   |                     |\n   |                     immutable borrow occurs here\n...\n16 |                 _ =&gt; self.append(\"it was something else\\n\"),\n   |                      ^^^^ mutable borrow occurs here\n</code></pre>\n\n<p>What is the proper way to structure the code so that the mutable field <code>output</code> can be written to while iterating over the immutable field <code>data</code>? Assume the indirection through the <code>Generator</code> trait is being used to share similar logic with other structs, so accessing <code>MyStruct</code>'s fields from the trait's default method implementations need to be done through accessor methods like this.</p>\n"}, {"tags": ["rust", "unsafe", "lifetime"], "comments": [{"owner": {"reputation": 11927, "user_id": 2301531, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/0e05b25685a72ab6268dce396da1b76f?s=128&d=identicon&r=PG", "display_name": "A.B.", "link": "https://stackoverflow.com/users/2301531/a-b"}, "edited": false, "score": 2, "creation_date": 1457648037, "post_id": 35928234, "comment_id": 59515352, "body": "This compiles because in unsafe code, it&#39;s up to the programmer to make sure that dereferencing a pointer is actually safe."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1457648223, "post_id": 35928234, "comment_id": 59515445, "body": "100% agree with A.B. here. An <code>unsafe</code> block tells the compiler &quot;I will uphold all the memory-safety guarantees myself because the compiler cannot verify them for me&quot; and then you go and violate all the memory-safety guarantees."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1457648689, "post_id": 35928234, "comment_id": 59515658, "body": "But the <code>unsafe</code> code is hidden inside functions - I was under the impression that type checking stopped at the prototype, rather than peeking inside - and <code>Vec</code> surely has unsafe code under the hood too."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 1, "creation_date": 1457657785, "post_id": 35928234, "comment_id": 59518745, "body": "You must call <code>std::mem::forget(foo)</code> in <code>stash</code>, otherwise <code>foo</code>&#39;s destructor will run at the end of <code>stash</code>."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1457678198, "post_id": 35928234, "comment_id": 59524449, "body": "I don&#39;t think <code>mem::forget</code> is needed. <code>foo</code> is moved into <code>ptr::write</code>."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 1, "creation_date": 1458660173, "post_id": 35928234, "comment_id": 59954127, "body": "@ChrisEmerson: You&#39;re right, for some reason I thought it took the value by reference, but it should be obvious from usage (if not from looking at the documentation) that it doesn&#39;t. :|"}], "answers": [{"comments": [{"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1457650619, "post_id": 35928745, "comment_id": 59516519, "body": "I literally read this part of the Rustonomicon this morning on the train to work and I was struggling to picture where that might be useful outside of the example in Vec. Thanks for this!"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1457651074, "post_id": 35928745, "comment_id": 59516683, "body": "Thanks, I&#39;ll go back and read The Rustonomicon again now it&#39;s more immediately relevant!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1458660269, "last_edit_date": 1458660269, "creation_date": 1457649417, "answer_id": 35928745, "question_id": 35928234, "link": "https://stackoverflow.com/questions/35928234/why-does-unsafe-code-compile-but-similar-code-that-pushes-to-a-vector-complains/35928745#35928745", "title": "Why does unsafe code compile, but similar code that pushes to a vector complains that a reference doesn&#39;t live long enough?", "body": "<blockquote>\n  <p>But the <code>unsafe</code> code is hidden inside functions - I was under the impression that type checking stopped at the prototype, rather than peeking inside - and <code>Vec</code> surely has unsafe code under the hood too.</p>\n</blockquote>\n\n<p>You are correct that type checking stops at the prototype. The difference here is that a <code>Vec</code> includes the type you are storing in it's own type - it's a <code>Vec&lt;T&gt;</code>!</p>\n\n<p>Before I get too far into an answer, I'd encourage you to read <a href=\"https://doc.rust-lang.org/nomicon/\" rel=\"nofollow\"><em>The Rustonomicon</em></a>, which talks about how <code>Vec</code> is implemented and how <code>unsafe</code> can be used judiciously.</p>\n\n<p>To make your code fail in the same way as a vector, you can encode the stored type with <a href=\"http://doc.rust-lang.org/std/marker/struct.PhantomData.html\" rel=\"nofollow\"><code>PhantomData</code></a>:</p>\n\n<pre><code>use std::marker::PhantomData;\n\nstruct State&lt;T&gt; {\n    buf: [u8; 100],\n    marker: PhantomData&lt;T&gt;\n}\n\nfn stash&lt;T&gt;(state: &amp;mut State&lt;T&gt;, foo: T) { ... }\nfn fetch&lt;T&gt;(state: &amp;mut State&lt;T&gt;) -&gt; &amp;mut T { ... }\n</code></pre>\n\n<p>Now, when you <code>stash</code> the reference in the inner block, the type of the <code>State</code> is inferred to hold a reference and that reference has a lifetime. Then the normal lifetime mechanics prevent using it outside of the block.</p>\n\n<p>If you want to see the code in a working state, note that you'd have to move <code>let bar = Bar(7);</code> before the creation of <code>State</code> as well:</p>\n\n<pre><code>fn main() {\n    let bar = Bar(7);\n\n    let mut state = State {\n        buf: [0;100],\n        marker: PhantomData,\n    };\n\n    let foo = Foo { subobj: &amp;bar };\n    stash(&amp;mut state, foo);\n\n    let foo2: &amp;mut Foo = fetch(&amp;mut state);\n\n    println!(\"{}\", foo2.subobj.0 + 3);\n}\n</code></pre>\n\n<hr>\n\n<p>I won't say that the code I've written here is actually safe - that takes more thinking and verification!</p>\n"}], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 90, "favorite_count": 0, "accepted_answer_id": 35928745, "answer_count": 1, "score": 1, "last_activity_date": 1458660269, "creation_date": 1457647382, "last_edit_date": 1457650561, "question_id": 35928234, "link": "https://stackoverflow.com/questions/35928234/why-does-unsafe-code-compile-but-similar-code-that-pushes-to-a-vector-complains", "title": "Why does unsafe code compile, but similar code that pushes to a vector complains that a reference doesn&#39;t live long enough?", "body": "<p>I have something like the following Rust code, which can store a Rust object somewhere (in the real application it's stored in a Lua userdata) and retrieve it later (when calling methods from Lua).</p>\n\n<pre><code>use std::ptr;\n\nstruct Bar(u32);\n\nstruct Foo&lt;'a&gt; {\n    subobj: &amp;'a Bar,\n}\n\nstruct State {\n    buf: [u8;100],\n}\n\nfn stash&lt;T&gt;(state: &amp;mut State, foo: T) {\n    let p : *mut T = state.buf.as_ptr() as *mut T;\n    unsafe { ptr::write(p, foo); };\n}\n\nfn fetch&lt;T&gt;(state: &amp;mut State) -&gt; &amp;mut T {\n    let p : *mut T = state.buf.as_ptr() as *mut T;\n    unsafe { &amp;mut *p }\n}\n\nfn main() {\n    let mut state = State{buf: [0;100]};\n    // let mut v: Vec&lt;Foo&gt; = Vec::new();\n    {\n        let bar = Bar(7);\n        let foo = Foo { subobj: &amp;bar };\n\n        // v.push(foo); // *does* complain that bar doesn't live long enough\n        stash(&amp;mut state, foo);\n    }  // bar's lifetime ends here!\n    let foo2: &amp;mut Foo = fetch(&amp;mut state); // Boom!\n\n    println!(\"{}\", foo2.subobj.0 + 3);\n}\n</code></pre>\n\n<p>The example above is clearly wrong, since it allows me to get a dangling reference to <code>bar</code> after its scope has ended.  However it would seem fine with any type not containing any references (or only <code>'static</code> ones), or something like <code>Rc&lt;T&gt;</code>.</p>\n\n<p>Why does that compile, but a very similar program (push to a vector instead) complains (as desired) that the reference to <code>bar</code> doesn't live long enough?  I don't really understand what's different with <code>Vec::push</code>.</p>\n\n<p>My understanding is that typechecking only looks at function signatures and not function bodies. For these purposes, the <code>unsafe</code> code shouldn't be relevant; the point is that I'm trying to figure out how to wrap the <code>unsafe</code> code into a safe interface.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457637898, "post_id": 35925259, "comment_id": 59509242, "body": "Short version: No, you cannot return a reference based on <code>self</code> as part of the <code>Iterator</code> trait. <a href=\"http://stackoverflow.com/q/30422177/155423\">Another question with good answers</a>."}, {"owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457639305, "post_id": 35925259, "comment_id": 59510088, "body": "@Shepmaster, okay, thanks for the links!"}], "owner": {"reputation": 6531, "user_id": 1614607, "user_type": "registered", "accept_rate": 59, "profile_image": "https://i.stack.imgur.com/j5OdR.jpg?s=128&g=1", "display_name": "Jacob Brown", "link": "https://stackoverflow.com/users/1614607/jacob-brown"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 33, "favorite_count": 0, "closed_date": 1457637677, "answer_count": 0, "score": 0, "last_activity_date": 1457637239, "creation_date": 1457637239, "question_id": 35925259, "link": "https://stackoverflow.com/questions/35925259/using-self-in-iterator", "closed_reason": "Duplicate", "title": "Using self in Iterator", "body": "<p>Suppose I have the following structs:</p>\n\n<pre><code>pub struct Foo {\n    pub i: i32\n}\n\npub struct Bar&lt;'a&gt; {\n    pub foo: &amp;'a Foo\n}\n\nimpl&lt;'a&gt; Bar&lt;'a&gt; {\n    fn make_baz(&amp;self) -&gt; Baz {\n        Baz { bar: self }\n    }\n}\n\npub struct Baz&lt;'a, 'b: 'a&gt; {\n    pub bar: &amp;'a Bar&lt;'b&gt;\n}\n</code></pre>\n\n<p>Is it possible to impl an Iterator like:</p>\n\n<pre><code>impl&lt;'a&gt; Iterator for Bar&lt;'a&gt; {\n\n    // how do I get this lifetime in here?\n    type Item = Baz&lt;_, 'a&gt;;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        Some(self.make_baz())\n    }\n}\n</code></pre>\n"}, {"tags": ["pattern-matching", "rust", "dereference"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1457624767, "post_id": 35921015, "comment_id": 59500402, "body": "I&#39;ve been told to dereference the match argument (your approach #2) as it&#39;s more idiomatic because it has less clutter. I hope someone can chime in with a more authoritative answer. :-)"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457625464, "post_id": 35921015, "comment_id": 59500944, "body": "Just to make sure: <code>Color</code> is not <code>Copy</code>, right?"}, {"owner": {"reputation": 3589, "user_id": 303940, "user_type": "registered", "accept_rate": 98, "profile_image": "https://www.gravatar.com/avatar/ce7dcd1712b04217df9da2e3c26b94f2?s=128&d=identicon&r=PG", "display_name": "KChaloux", "link": "https://stackoverflow.com/users/303940/kchaloux"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457625503, "post_id": 35921015, "comment_id": 59500963, "body": "@Matthieu Nope, it&#39;s defined as seen above, with no attributes. But if that makes a significant difference as to the behavior, I&#39;d love to hear about it."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1457627079, "post_id": 35921015, "comment_id": 59502146, "body": "Yep, I&#39;m also pretty sure that the second approach is the idiomatic one, but I can&#39;t give any links supporting this claim as well :) And whether the matched value is <code>Copy</code> or not also does not make difference, I believe."}, {"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457627715, "post_id": 35921015, "comment_id": 59502549, "body": "@Shepmaster Is the style guide authoritative enough? <a href=\"https://doc.rust-lang.org/style/features/match.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/style/features/match.html</a> (OK, not quite the same, but still ...)"}, {"owner": {"reputation": 3589, "user_id": 303940, "user_type": "registered", "accept_rate": 98, "profile_image": "https://www.gravatar.com/avatar/ce7dcd1712b04217df9da2e3c26b94f2?s=128&d=identicon&r=PG", "display_name": "KChaloux", "link": "https://stackoverflow.com/users/303940/kchaloux"}, "reply_to_user": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 0, "creation_date": 1457630749, "post_id": 35921015, "comment_id": 59504677, "body": "@starblue I think that would be a fine answer. It&#39;s at least an opinion that comes from the creators of Rust, who ought to know how to use their language. I&#39;d still love to know if there&#39;s a real functional difference between the two approaches, however, or if it really is just a style thing."}], "answers": [{"tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 1, "last_activity_date": 1457627529, "creation_date": 1457627529, "answer_id": 35922102, "question_id": 35921015, "link": "https://stackoverflow.com/questions/35921015/should-a-reference-to-an-enum-be-dereferenced-before-it-is-matched/35922102#35922102", "title": "Should a reference to an enum be dereferenced before it is matched?", "body": "<p>I personally prefer the second. It conveys the intent better, in my opinion.</p>\n"}, {"comments": [{"owner": {"reputation": 3589, "user_id": 303940, "user_type": "registered", "accept_rate": 98, "profile_image": "https://www.gravatar.com/avatar/ce7dcd1712b04217df9da2e3c26b94f2?s=128&d=identicon&r=PG", "display_name": "KChaloux", "link": "https://stackoverflow.com/users/303940/kchaloux"}, "edited": false, "score": 1, "creation_date": 1457633969, "post_id": 35923983, "comment_id": 59506803, "body": "That helps clear things up a lot. Knowing that a move cannot occur when using something as an lvalue makes a lot of sense."}], "tags": [], "owner": {"reputation": 50347, "user_id": 1763356, "user_type": "registered", "accept_rate": 79, "profile_image": "https://i.stack.imgur.com/zGWG9.png?s=128&g=1", "display_name": "Veedrac", "link": "https://stackoverflow.com/users/1763356/veedrac"}, "is_accepted": true, "score": 8, "last_activity_date": 1457632973, "creation_date": 1457632973, "answer_id": 35923983, "question_id": 35921015, "link": "https://stackoverflow.com/questions/35921015/should-a-reference-to-an-enum-be-dereferenced-before-it-is-matched/35923983#35923983", "title": "Should a reference to an enum be dereferenced before it is matched?", "body": "<p>You can't move out of an immutable reference, so you don't have to worry about that being the case.</p>\n\n<p>It's worth considering that one would expect matches to work <em>somewhat</em> akin to (<code>Partial</code>)<code>Eq</code>, and that takes <code>&amp;self</code>. In other words, one would expect it to take a reference implicitly unless forced. This is easily confirmed with a little experimentation.</p>\n\n<p>It's worth noting that <code>*self</code> is <em>not</em> a move - it's a reference to a memory location. <a href=\"https://doc.rust-lang.org/reference.html#lvalues-rvalues-and-temporaries\">It is thus an lvalue.</a> Ergo,</p>\n\n<blockquote>\n  <p>When the head expression is an lvalue, the match does not allocate a temporary location (however, a by-value binding may copy or move from the lvalue).</p>\n</blockquote>\n\n<p><a href=\"https://doc.rust-lang.org/reference.html#match-expressions\">https://doc.rust-lang.org/reference.html#match-expressions</a></p>\n\n<p>If a temporary location is not allocated, a move cannot occur. Thus the behaviour is guaranteed. As the parenthetical notes, internal data can still get moved out from destructuring pattern, which would cause a problem. This, however, is true regardless of whether you are matching on <code>self</code> or <code>*self</code>.</p>\n\n<p>Using <code>*self</code> seems to be an informal idiom, and should be preferred.</p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1530326917, "creation_date": 1530326917, "answer_id": 51111314, "question_id": 35921015, "link": "https://stackoverflow.com/questions/35921015/should-a-reference-to-an-enum-be-dereferenced-before-it-is-matched/51111314#51111314", "title": "Should a reference to an enum be dereferenced before it is matched?", "body": "<p>As of Rust 1.26, the idiomatic solution is <em>neither</em>; you don't have to dereference the value <em>or</em> add <code>&amp;</code> to the patterns:</p>\n\n<pre><code>fn contains_blue(&amp;self) -&gt; bool {\n    match self {\n        Color::Blue =&gt; true,\n        Color::Teal =&gt; true,\n        Color::Purple =&gt; true,\n        _ =&gt; false,\n    }\n}\n</code></pre>\n\n<p>This is thanks to improved match ergonomics.</p>\n\n<p>You can also use pattern alternation in this case:</p>\n\n<pre><code>match self {\n    Color::Blue | Color::Teal | Color::Purple =&gt; true,\n    _ =&gt; false,\n}\n</code></pre>\n"}], "owner": {"reputation": 3589, "user_id": 303940, "user_type": "registered", "accept_rate": 98, "profile_image": "https://www.gravatar.com/avatar/ce7dcd1712b04217df9da2e3c26b94f2?s=128&d=identicon&r=PG", "display_name": "KChaloux", "link": "https://stackoverflow.com/users/303940/kchaloux"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 588, "favorite_count": 0, "accepted_answer_id": 35923983, "answer_count": 3, "score": 6, "last_activity_date": 1530326917, "creation_date": 1457624562, "last_edit_date": 1530326782, "question_id": 35921015, "link": "https://stackoverflow.com/questions/35921015/should-a-reference-to-an-enum-be-dereferenced-before-it-is-matched", "title": "Should a reference to an enum be dereferenced before it is matched?", "body": "<p>As a newcomer to Rust, I've stumbled upon two apparently valid ways of running a <code>match</code> on a reference type.</p>\n\n<p>I've defined an enum:</p>\n\n<pre><code>enum Color {\n    Red,\n    Yellow,\n    Green,\n    Teal,\n    Blue,\n    Purple,\n}\n</code></pre>\n\n<p>I want to implement a function that works on a <code>&amp;self</code> reference of an instance of this enum.</p>\n\n<p>I can see two ways to write such a function:</p>\n\n<pre><code>impl Color {\n    // Approach #1: Match the reference, using references in each pattern\n    fn contains_red(&amp;self) -&gt; bool {\n        match self {\n            &amp;Color::Red =&gt; true,\n            &amp;Color::Yellow =&gt; true,\n            &amp;Color::Purple =&gt; true,\n            _ =&gt; false,\n        }\n    }\n\n    // Approach #2: Dereference &amp;self and match the patterns directly\n    fn contains_blue(&amp;self) -&gt; bool {\n        match *self {\n            Color::Blue =&gt; true,\n            Color::Teal =&gt; true,\n            Color::Purple =&gt; true,\n            _ =&gt; false,\n        }\n    }\n}\n</code></pre>\n\n<p>I expected that dereferencing <code>&amp;self</code> would be counted as a move, and would cause errors if I called <code>color.contains_blue()</code> on the same instance twice in a row, but this doesn't seem to be the case.</p>\n\n<p>Are these approaches functionally identical? Would one of them break down if I were matching more complex objects? </p>\n"}, {"tags": ["rust", "ffi"], "answers": [{"comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1457615249, "post_id": 35917152, "comment_id": 59493074, "body": "Thanks, that&#39;s helpful. So am I right in saying that <code>ptr::drop_in_place(p);</code> is logically the same as if you ignore the result of <code>ptr::read(p)</code>, except for copying a few bits in the latter case?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1457615522, "post_id": 35917152, "comment_id": 59493261, "body": "Agreed about <code>new_userdata_typed</code>, which is what I&#39;m actually using, but I tried (possibly misguidedly) to use a simpler interface to simplify the question..."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1457615827, "post_id": 35917152, "comment_id": 59493502, "body": "yep, <code>drop_in_place</code> and <code>read</code> have the same semantics if <code>read</code>&#39;s return value is ignored."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 5, "last_activity_date": 1457617841, "last_edit_date": 1457617841, "creation_date": 1457614588, "answer_id": 35917152, "question_id": 35916738, "link": "https://stackoverflow.com/questions/35916738/correctly-storing-a-rust-rct-in-c-managed-memory/35917152#35917152", "title": "Correctly storing a Rust Rc&lt;T&gt; in C-managed memory", "body": "<blockquote>\n  <p>Now this seems to work (as briefly tested by adding a println!() to the drop method). But is it correct and safe (as long as I make sure it's not accessed after finalisation)? I don't feel confident enough in unsafe Rust to be sure that it's ok to ptr::write an <code>Rc&lt;T&gt;</code>.</p>\n</blockquote>\n\n<p>Yes, you may <code>ptr::write</code> any Rust type to any memory location. This \"leaks\" the <code>Rc&lt;T&gt;</code> object, but writes a bit-equivalent to the target location.</p>\n\n<p>When using it, you need to guarantee that no one modified it outside of Rust code and that you are still in the same thread as the one where it was created. If you want to be able to move across threads, you need to use <code>Arc</code>.</p>\n\n<p>Rust's thread safety cannot protect you here, because you are using raw pointers.</p>\n\n<hr>\n\n<blockquote>\n  <p>I'm also wondering about, rather than storing an <code>Rc&lt;T&gt;</code> directly, storing an <code>Option&lt;Rc&lt;T&gt;&gt;</code>; then instead of drop_in_place() I would ptr::swap() it with None. This would make it easy to handle any use after finalisation.</p>\n</blockquote>\n\n<p>The pendant to <code>ptr::write</code> is <code>ptr::read</code>. So if you can guarantee that no one ever tries to <code>ptr::read</code> or <code>drop_in_place()</code> the object, then you can just call <code>ptr::read</code> (which returns the object) and use that object as you would use any other <code>Rc&lt;T&gt;</code> object. You don't need to care about dropping or anything, because now it's back in Rust's control.</p>\n\n<hr>\n\n<p>You should also be using <code>new_userdata_typed</code> instead of <code>new_userdata</code>, since that takes the memory handling off your hands. There are other convenience wrapper functions ending with the postfix <code>_typed</code> for most userdata needs.</p>\n"}, {"comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1457619967, "post_id": 35918014, "comment_id": 59496605, "body": "isn&#39;t this more of a comment/edit to the question? @Chris Emerson noted that it&#39;s not his actual code, but he&#39;s using the generic method <code>new_userdata_typed</code>, which prevents such C-ish mistakes"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1457620627, "post_id": 35918014, "comment_id": 59497129, "body": "@ker: I would say it&#39;s an answer (though not as elaborate as yours), in that it answers the <i>But is it correct and safe (as long as I make sure it&#39;s not accessed after finalization)?</i> question. Or is the issue that I actually start by fixing the code before answering the question so the last part is not that visible?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1457633991, "post_id": 35918014, "comment_id": 59506817, "body": "Thanks for the correction - I&#39;ll edit and fix the question."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 1, "last_activity_date": 1457634303, "last_edit_date": 1457634303, "creation_date": 1457616828, "answer_id": 35918014, "question_id": 35916738, "link": "https://stackoverflow.com/questions/35916738/correctly-storing-a-rust-rct-in-c-managed-memory/35918014#35918014", "title": "Correctly storing a Rust Rc&lt;T&gt; in C-managed memory", "body": "<p>Your code will work; of course, note that the <code>drop_in_place(p)</code> will just decrease the counter of the <code>Rc</code> and only drop the contained <code>T</code> if and only if it was the last reference, which is the correct action.</p>\n"}], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 389, "favorite_count": 1, "accepted_answer_id": 35917152, "answer_count": 2, "score": 5, "last_activity_date": 1457634303, "creation_date": 1457613511, "last_edit_date": 1457634031, "question_id": 35916738, "link": "https://stackoverflow.com/questions/35916738/correctly-storing-a-rust-rct-in-c-managed-memory", "title": "Correctly storing a Rust Rc&lt;T&gt; in C-managed memory", "body": "<p>I'm wrapping a Rust object to be used from Lua.  I need the object to be destroyed when neither Rust code nor Lua still has a reference to it, so the obvious (to me) solution is to use <code>Rc&lt;T&gt;</code>, stored in Lua-managed memory.</p>\n\n<p>The Lua API (I'm using <a href=\"https://github.com/jcmoyer/rust-lua53\" rel=\"nofollow\">rust-lua53</a> for now) lets you allocate a chunk of memory and attach methods and a finalizer to it, so I want to store an <code>Rc&lt;T&gt;</code> into that chunk of memory.</p>\n\n<p>My current attempt looks like.  First, creating an object:</p>\n\n<pre><code>/* Allocate a block of uninitialized memory to use */\nlet p = state.new_userdata(mem::size_of::&lt;Rc&lt;T&gt;&gt;() as size_t) as *mut Rc&lt;T&gt;;\n/* Make a ref-counted pointer to a Rust object */\nlet rc = Rc::&lt;T&gt;::new(...);\n/* Store the Rc */\nunsafe { ptr::write(p, rc) };\n</code></pre>\n\n<p>And in the finaliser:</p>\n\n<pre><code>let p: *mut Rc&lt;T&gt; = ...; /* Get a pointer to the item to finalize */\nunsafe { ptr::drop_in_place(p) };  /* Release the object */\n</code></pre>\n\n<p>Now this seems to work (as briefly tested by adding a println!() to the <code>drop</code> method).  But is it correct and safe (as long as I make sure it's not accessed after finalization)?  I don't feel confident enough in unsafe Rust to be sure that it's ok to ptr::write an <code>Rc&lt;T&gt;</code>.</p>\n\n<p>I'm also wondering about, rather than storing an <code>Rc&lt;T&gt;</code> directly, storing an <code>Option&lt;Rc&lt;T&gt;&gt;</code>; then instead of <code>drop_in_place()</code> I would <code>ptr::swap()</code> it with <code>None</code>.  This would make it easy to handle any use after finalization.</p>\n"}, {"tags": ["iterator", "rust"], "answers": [{"comments": [{"owner": {"reputation": 11705, "user_id": 2765603, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/WkhcQ.jpg?s=128&g=1", "display_name": "llogiq", "link": "https://stackoverflow.com/users/2765603/llogiq"}, "edited": false, "score": 0, "creation_date": 1457591326, "post_id": 35908789, "comment_id": 59477683, "body": "This should be wrapped in a crate, documented and submitted as TWiR&#39;s Crate of the Week."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457594683, "post_id": 35908789, "comment_id": 59479269, "body": "I am wondering if it would not be easier to take <code>F: FnMut(&amp;mut T)</code> instead of using the <code>take</code> dance."}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 2, "creation_date": 1457604743, "post_id": 35908789, "comment_id": 59485709, "body": "Does the itertools crate already have this? Seems like it should."}, {"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "edited": false, "score": 0, "creation_date": 1457607844, "post_id": 35908789, "comment_id": 59487969, "body": "It looks much neater with <code>F: FnMut(&amp;mut T)</code> and <code>Option</code> removed from <code>value</code>, and <code>fn next(&amp;mut self) -&gt; Option&lt;T&gt; { let new_value = (self.calc_next)(&amp;self.value); Some(mem::replace(&amp;mut self.value, new_value)) }</code>."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 7, "last_activity_date": 1457589785, "creation_date": 1457589785, "answer_id": 35908789, "question_id": 35908398, "link": "https://stackoverflow.com/questions/35908398/is-there-a-function-in-rust-equivalent-to-javas-stream-iterate/35908789#35908789", "title": "Is there a function in Rust equivalent to Java&#39;s Stream.Iterate?", "body": "<p>As of Rust 1.7, there's nothing in Rust's standard library that does the equivalent of <code>Stream.iterate</code> (or I couldn't find it!).</p>\n\n<p>I just whipped up the following implementation in Rust. It's not as straightforward as the Java implementation might be, because we have to take care of ownership (hence the requirement for <code>Clone</code> and the <code>Option</code> dance with the <code>value</code> field).</p>\n\n<pre><code>struct SequenceGenerator&lt;T, F&gt; {\n    value: Option&lt;T&gt;,\n    calc_next: F,\n}\n\nimpl&lt;T, F&gt; SequenceGenerator&lt;T, F&gt;\n    where T: Clone,\n          F: FnMut(T) -&gt; T\n{\n    fn new(value: T, calc_next: F) -&gt; SequenceGenerator&lt;T, F&gt; {\n        SequenceGenerator {\n            value: Some(value),\n            calc_next: calc_next,\n        }\n    }\n}\n\nimpl&lt;T, F&gt; Iterator for SequenceGenerator&lt;T, F&gt;\n    where T: Clone,\n          F: FnMut(T) -&gt; T\n{\n    type Item = T;\n\n    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {\n        let result = self.value.as_ref().unwrap().clone();\n        self.value = Some((self.calc_next)(self.value.take().unwrap()));\n        Some(result)\n    }\n}\n\nfn main() {\n    let seq_gen = SequenceGenerator::new(1, |x| 2 * x);\n    for i in seq_gen.take(10) {\n        println!(\"{}\", i);\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1457594525, "post_id": 35909586, "comment_id": 59479184, "body": "Nice; however with <code>String</code> it would not work as is because you are unwittingly relying on the fact that <code>1</code> is <code>Copy</code> for <code>let out = r.0</code> to work I am afraid. The issue with <code>scan</code> is that it&#39;s not really meant for such a trick; the state remains the property of <code>scan</code> while you need to yield <i>values</i>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457618835, "post_id": 35909586, "comment_id": 59495746, "body": "@MatthieuM. but you could declare the <code>String</code> before the iterator and then use a <code>&amp;mut String</code> as the state value, right?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457619065, "post_id": 35909586, "comment_id": 59495897, "body": "@Shepmaster: possibly... I&#39;ve played with something like a <code>&amp;mut Option&lt;T&gt;</code> as state in a previous answer. It&#39;s not very elegant, but I think it can be made to work."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457619382, "post_id": 35909586, "comment_id": 59496131, "body": "@MatthieuM. something like <a href=\"http://is.gd/EvF5Kb\" rel=\"nofollow noreferrer\">this</a>. Also note the use of <code>iter::repeat</code> instead of the <code>Option</code> iter / cycle."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1457619484, "post_id": 35909586, "comment_id": 59496205, "body": "@Shepmaster: don&#39;t use integers, they&#39;re <code>Copy</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1457621993, "post_id": 35909586, "comment_id": 59498266, "body": "@MatthieuM. well, OP does want Java semantics, so you could always wrap the <code>String</code> in an <code>Rc</code> and/or <code>RefCell</code> so you can return them <i>and</i> keep them as state ;-)"}, {"owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1457642457, "post_id": 35909586, "comment_id": 59512038, "body": "Completely forgot about <code>iter::repeat</code>. @Shepmaster, thank you for reminding. Updated."}], "tags": [], "owner": {"reputation": 3566, "user_id": 5138648, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1fdbc41d6ae88135845b5d965dac0b13?s=128&d=identicon&r=PG", "display_name": "aSpex", "link": "https://stackoverflow.com/users/5138648/aspex"}, "is_accepted": false, "score": 2, "last_activity_date": 1457642571, "last_edit_date": 1457642571, "creation_date": 1457592897, "answer_id": 35909586, "question_id": 35908398, "link": "https://stackoverflow.com/questions/35908398/is-there-a-function-in-rust-equivalent-to-javas-stream-iterate/35909586#35909586", "title": "Is there a function in Rust equivalent to Java&#39;s Stream.Iterate?", "body": "<p>You can use standard <a href=\"http://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan\" rel=\"nofollow\"><code>scan</code></a> iterator:</p>\n\n<pre><code>let seq_gen = iter::repeat(())\n                      .scan(1, |r,_|{\n                          let out = *r; *r = out * 2 ; Some(out)\n                      });\n</code></pre>\n\n<p>or with explicit closure definition:</p>\n\n<pre><code>let seq_gen = iter::repeat(())\n                      .scan((1, |x| x*2), |r,_|{\n                          let out = r.0; r.0 = r.1(r.0); Some(out)\n                      });\n</code></pre>\n\n<p>For <em>noncopyable</em> types things looks worse:</p>\n\n<pre><code>let seq_gen = iter::repeat(())\n                      .scan(Some(\"Hello world\".to_owned()), |r,_|{\n                          let out = r.clone(); *r = r.take().map(|x| x+\"!\") ; out\n                      });\n</code></pre>\n\n<p>For these types it is better to use functions that modify the value in place: </p>\n\n<pre><code>let seq_gen = iter::repeat(())\n                      .scan(\"Hello world\".to_owned(), |r,_|{\n                          let out = r.clone(); r.push_str(\"!\") ; Some(out)\n                      });\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 7, "last_activity_date": 1457618750, "last_edit_date": 1457618750, "creation_date": 1457618294, "answer_id": 35918544, "question_id": 35908398, "link": "https://stackoverflow.com/questions/35908398/is-there-a-function-in-rust-equivalent-to-javas-stream-iterate/35918544#35918544", "title": "Is there a function in Rust equivalent to Java&#39;s Stream.Iterate?", "body": "<p>The Rust standard library <a href=\"https://github.com/rust-lang/rust/commit/8d90d3f36871a00023cc1f313f91e351c287ca15\"><em>used</em></a> to have similar functionality under the name <code>unfold</code>, but it was never made stable and was eventually removed. It now lives in the <a href=\"http://bluss.github.io/rust-itertools/doc/itertools/struct.Unfold.html\">itertools crate</a>:</p>\n\n<pre><code>extern crate itertools;\n\nuse itertools::Unfold;\n\nfn main() {\n    let x = Unfold::new(1, |x| {\n        *x *= 2;\n        Some(*x)\n    });\n\n    for val in x.take(10) {\n        println!(\"{}\", val);\n    }\n}\n</code></pre>\n\n<p>Note that it's a bit more complicated because the state doesn't have to exactly match with what the iterator returns and you can control when the iterator <strong>stops</strong>. It's possible that the crate would accept a PR for a thin layer on top that gives your exact implementation.</p>\n"}, {"tags": [], "owner": {"reputation": 1907, "user_id": 995935, "user_type": "registered", "accept_rate": 55, "profile_image": "https://i.stack.imgur.com/uO0in.gif?s=128&g=1", "display_name": "Mutant Bob", "link": "https://stackoverflow.com/users/995935/mutant-bob"}, "is_accepted": false, "score": 0, "last_activity_date": 1595604202, "creation_date": 1595604202, "answer_id": 63076626, "question_id": 35908398, "link": "https://stackoverflow.com/questions/35908398/is-there-a-function-in-rust-equivalent-to-javas-stream-iterate/63076626#63076626", "title": "Is there a function in Rust equivalent to Java&#39;s Stream.Iterate?", "body": "<p>I wonder if</p>\n<pre><code>fn main() {\n    let x = (1..std::i32::MAX) .map(|x| x*2);\n\n    for i in x {\n        println!(&quot;{}&quot;, i);\n    }\n}\n</code></pre>\n<p>would be a satisfactory option for you.</p>\n"}], "owner": {"reputation": 404, "user_id": 2540904, "user_type": "registered", "accept_rate": 100, "profile_image": "https://graph.facebook.com/100005700121024/picture?type=large", "display_name": "MAG", "link": "https://stackoverflow.com/users/2540904/mag"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 991, "favorite_count": 1, "accepted_answer_id": 35918544, "answer_count": 4, "score": 9, "last_activity_date": 1595604202, "creation_date": 1457588125, "last_edit_date": 1457617901, "question_id": 35908398, "link": "https://stackoverflow.com/questions/35908398/is-there-a-function-in-rust-equivalent-to-javas-stream-iterate", "title": "Is there a function in Rust equivalent to Java&#39;s Stream.Iterate?", "body": "<p>Does the Rust standard library have a function that generates an infinite iterator given a seed and a lambda, as the Java 8 Streams provide? If not, what is a similar alternative in Rust?</p>\n\n<pre><code>Stream.iterate(1, x -&gt; 2 * x);\n</code></pre>\n"}]