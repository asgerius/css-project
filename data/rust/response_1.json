[{"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 4, "last_activity_date": 1493509279, "last_edit_date": 1493509279, "creation_date": 1421268416, "answer_id": 27952112, "question_id": 27952003, "link": "https://stackoverflow.com/questions/27952003/cannot-create-a-generic-function-that-uses-a-literal-zero/27952112#27952112", "title": "Cannot create a generic function that uses a literal zero", "body": "<p>The problem is <code>0</code>.  I'm unclear on the exact rules right now, but let's be general: <code>0</code> is of some specific integer type, which may or may not be the same thing as whatever <code>T</code> is.  Thus, the compiler can't work out what the type parameter to <code>range</code> is supposed to be.</p>\n\n<p>You can resolve this by using <a href=\"https://docs.rs/num/0.1.37/num/trait.Zero.html\" rel=\"nofollow noreferrer\"><code>Zero::zero</code></a>:</p>\n\n<pre><code>fn positions&lt;T: Integer&gt;(start: T, step: T, len: T) -&gt; Vec&lt;T&gt; {\n    (T::zero()..len).map(|i| start + step * i).collect()\n}\n</code></pre>\n\n<p>This gives the compiler enough leeway to infer that the two arguments to <code>range</code> are of the same type. However, that's still not enough to use <code>Range</code> as an iterator:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: no method named `map` found for type `std::ops::Range&lt;T&gt;` in the current scope\n --&gt; src/main.rs:8:22\n  |\n8 |     (T::zero()..len).map(|i| start + step * i).collect()\n  |                      ^^^\n  |\n  = note: the method `map` exists but the following trait bounds were not satisfied: `T : std::iter::Step`, `&amp;'a T : std::ops::Add`, `std::ops::Range&lt;T&gt; : std::iter::Iterator`\n</code></pre>\n\n<p>Unfortunately, as of Rust 1.17, the <a href=\"https://doc.rust-lang.org/std/iter/trait.Step.html\" rel=\"nofollow noreferrer\"><code>Step</code> trait</a> is unstable, so there's currently no good way to solve this problem using stable Rust.</p>\n\n<p>Using unstable Rust, you can require implementations of <code>Step</code>:</p>\n\n<pre><code>#![feature(step_trait)]\n\nextern crate num;\n\nuse num::Integer;\n\nfn positions&lt;T&gt;(start: T, step: T, len: T) -&gt; Vec&lt;T&gt;\n    where T: Integer + std::iter::Step + Copy,\n          for&lt;'a&gt; &amp;'a T: std::ops::Add&lt;Output = T&gt;\n{\n    (T::zero()..len).map(|i| start + step * i).collect()\n}\n\nfn main() {\n    println!(\"{:?}\", positions(10, 2, 10));\n}\n</code></pre>\n\n<p>You <em>also</em> need to require that <code>T</code> can be copied (or cloned, if you like) because the implementation of <code>Add</code> and <code>Mul</code> consumes the operands by value, which would mean that <code>start + step * i</code> could only be called once, except it needs to be called multiple times.</p>\n"}], "owner": {"reputation": 48136, "user_id": 161922, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/16e12e337f6edc3750681492656097ed?s=128&d=identicon&r=PG", "display_name": "Rory", "link": "https://stackoverflow.com/users/161922/rory"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 491, "favorite_count": 0, "accepted_answer_id": 27952112, "answer_count": 1, "score": 1, "last_activity_date": 1493509279, "creation_date": 1421268003, "last_edit_date": 1493508682, "question_id": 27952003, "link": "https://stackoverflow.com/questions/27952003/cannot-create-a-generic-function-that-uses-a-literal-zero", "title": "Cannot create a generic function that uses a literal zero", "body": "<p>I am trying to write a Rust function that is similar to the built-in <code>Range</code>, but I want something that will return only X numbers, and return it as a list, which is why I'm trying to make this function:\n    extern crate num;</p>\n\n<pre><code>use num::Integer;\n\nfn positions&lt;T: Integer&gt;(start: T, step: T, len: T) -&gt; Vec&lt;T&gt; {\n    (0..len).map(|i| start + step * i).collect()\n}\n\nfn main() {\n    println!(\"{:?}\", positions(10, 2, 10));\n}\n</code></pre>\n\n<p>Except I am getting a compiler error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; src/main.rs:6:9\n  |\n6 |     (0..len).map(|i| start + step * i).collect()\n  |         ^^^ expected integral variable, found type parameter\n  |\n  = note: expected type `{integer}`\n             found type `T`\n  = help: here are some functions which might fulfill your needs:\n          - .div_floor(...)\n          - .gcd(...)\n          - .lcm(...)\n          - .mod_floor(...)\n\nerror[E0308]: mismatched types\n --&gt; src/main.rs:6:37\n  |\n6 |     (0..len).map(|i| start + step * i).collect()\n  |                                     ^ expected type parameter, found integral variable\n  |\n  = note: expected type `T`\n             found type `{integer}`\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 1574, "user_id": 1240825, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/54627be67b42424f6642a709a23b244d?s=128&d=identicon&r=PG", "display_name": "maxywb", "link": "https://stackoverflow.com/users/1240825/maxywb"}, "edited": false, "score": 0, "creation_date": 1421260215, "post_id": 27949929, "comment_id": 44294959, "body": "You might be able to put the operation inside and &quot;unsafe&quot; block. See here: <a href=\"http://huonw.github.io/blog/2014/07/what-does-rusts-unsafe-mean/\" rel=\"nofollow noreferrer\">huonw.github.io/blog/2014/07/what-does-rusts-unsafe-mean</a>"}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1421260811, "post_id": 27950119, "comment_id": 44295254, "body": "I ran into a <a href=\"https://github.com/rust-lang/rust/issues/18549\" rel=\"nofollow noreferrer\">similar problem myself</a>, and suggested Rust add a lint to protect against it."}, {"owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "edited": false, "score": 0, "creation_date": 1421263684, "post_id": 27950119, "comment_id": 44296832, "body": "Thank you for explanation, it really works for that testcase. But I actually need to parameterize the Handler struct: it has more than one method, where I need to have the same T type. Is there any solution to explicitly provide lifetime without removing struct parameter?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "edited": false, "score": 0, "creation_date": 1421264239, "post_id": 27950119, "comment_id": 44297138, "body": "That&#39;s not how it works :-) You have to add <code>&lt;T&gt;</code> and <code>where</code> clauses to <i>every function</i>. Rust will specialize each function as appropriate. You only want to parameterize the struct when the struct <b>itself</b> uses the type parameter in a field. It&#39;s not just a way of DRYing up the parameter."}, {"owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "edited": false, "score": 1, "creation_date": 1421265965, "post_id": 27950119, "comment_id": 44298087, "body": "But what is the right way then for me to prevent providing u64 arg to <i>handler_str</i>? If I parametrize the function instead of struct I will be able to do such things easily."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "edited": false, "score": 0, "creation_date": 1421273825, "post_id": 27950119, "comment_id": 44301991, "body": "That&#39;s a tough one. You want to be able to say &quot;I will only ever accept strings, but I don&#39;t care about the lifetime of the string, so long as it&#39;s longer than the function call&quot; with the additional complexity of &quot;string&quot; being a parameterized type."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "edited": false, "score": 0, "creation_date": 1421275345, "post_id": 27950119, "comment_id": 44302693, "body": "@swizard Updated with an answer. I dunno if it&#39;s the <i>best answer</i>, but it works for your example."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1421275321, "last_edit_date": 1421275321, "creation_date": 1421260720, "answer_id": 27950119, "question_id": 27949929, "link": "https://stackoverflow.com/questions/27949929/error-line-does-not-live-long-enough-but-i-know-it-does/27950119#27950119", "title": "error: `line` does not live long enough (but I know it does)", "body": "<p>The problem is that you are incorrectly parameterizing your struct, when you really want to do it for the function. When you create your current <code>Handler</code>, the struct will be specialized with a type that includes a lifetime. However, the lifetime of <code>line</code> is only for the block, so there <em>can be no lifetime for Handler</em> that lasts multiple loop iterations.</p>\n\n<p>What you want is for the lifetime to be tied to the function call, not the life of the struct. As you noted, if you put the lifetime on the struct, then the struct is able to store references of that length. You don't need that, so put the generic type on the function instead:</p>\n\n<pre><code>impl Handler {\n    pub fn new() -&gt; Handler { Handler{obj: std::ptr::null_mut(),} }\n\n    pub fn invoke_external_proc&lt;T&gt;(&amp;mut self, value: T) where T: MemoryArea {\n        let (area, area_len) = value.get_memory_area();\n        unsafe {\n            some_external_proc(self.obj, area as *const c_void,\n                               area_len as size_t)\n        };\n    }\n}\n</code></pre>\n\n<h3>Amended answer</h3>\n\n<p>Since you want to specialize the struct on a type, but don't care too much about the lifetime of the type, let's try this:</p>\n\n<pre><code>#[allow(missing_copy_implementations)]\npub struct Handler&lt;T: ?Sized&gt; {\n    obj: *mut c_void,\n}\n\nimpl&lt;T: ?Sized&gt; Handler&lt;T&gt; {\n    pub fn new() -&gt; Handler&lt;T&gt; { Handler{ obj: std::ptr::null_mut() } }\n\n    pub fn invoke_external_proc(&amp;mut self, value: &amp;T) where T: MemoryArea {\n        let (area, area_len) = value.get_memory_area();\n        unsafe {\n            some_external_proc(self.obj, area as *const c_void,\n                               area_len as size_t)\n        };\n    }\n}\n</code></pre>\n\n<p>Here, we allow the type to be <em>unsized</em>. Since you can't pass an unsized value as a parameter, we now have to take a reference instead. We also have to change the <code>impl</code>:</p>\n\n<pre><code>impl MemoryArea for str {\n    fn get_memory_area(&amp;self) -&gt; (*const u8, usize) {\n        let bytes = self.as_bytes();\n        (bytes.as_ptr(), bytes.len())\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 2156, "user_id": 4347341, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/OUTXT.jpg?s=128&g=1", "display_name": "swizard", "link": "https://stackoverflow.com/users/4347341/swizard"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 229, "favorite_count": 0, "accepted_answer_id": 27950119, "answer_count": 1, "score": 1, "last_activity_date": 1421275321, "creation_date": 1421260023, "question_id": 27949929, "link": "https://stackoverflow.com/questions/27949929/error-line-does-not-live-long-enough-but-i-know-it-does", "title": "error: `line` does not live long enough (but I know it does)", "body": "<p>I am trying to make some kind of ffi to a library written in C, but got stuck. Here is a test case:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>extern crate libc;\nuse libc::{c_void, size_t};\n\n// this is C library api call\nunsafe fn some_external_proc(_handler: *mut c_void, value: *const c_void,\n                             value_len: size_t) {\n    println!(\"received: {:?}\" , std::slice::from_raw_buf(\n             &amp;(value as *const u8), value_len as usize));\n}\n\n// this is Rust wrapper for C library api\npub trait MemoryArea {\n    fn get_memory_area(&amp;self) -&gt; (*const u8, usize);\n}\n\nimpl MemoryArea for u64 {\n    fn get_memory_area(&amp;self) -&gt; (*const u8, usize) {\n        (unsafe { std::mem::transmute(self) }, std::mem::size_of_val(self))\n    }\n}\n\nimpl &lt;'a&gt; MemoryArea for &amp;'a str {\n    fn get_memory_area(&amp;self) -&gt; (*const u8, usize) {\n        let bytes = self.as_bytes();\n        (bytes.as_ptr(), bytes.len())\n    }\n}\n\n#[allow(missing_copy_implementations)]\npub struct Handler&lt;T&gt; {\n    obj: *mut c_void,\n}\n\nimpl &lt;T&gt; Handler&lt;T&gt; {\n    pub fn new() -&gt; Handler&lt;T&gt; { Handler{obj: std::ptr::null_mut(),} }\n\n    pub fn invoke_external_proc(&amp;mut self, value: T) where T: MemoryArea {\n        let (area, area_len) = value.get_memory_area();\n        unsafe {\n            some_external_proc(self.obj, area as *const c_void,\n                               area_len as size_t)\n        };\n    }\n}\n\n// this is Rust wrapper user code\nfn main() {\n    let mut handler_u64 = Handler::new();\n    let mut handler_str = Handler::new();\n\n    handler_u64.invoke_external_proc(1u64); // OK\n    handler_str.invoke_external_proc(\"Hello\"); // also OK\n    loop  {\n        match std::io::stdin().read_line() {\n            Ok(line) =&gt; {\n                let key =\n                    line.trim_right_matches(|&amp;: c: char| c.is_whitespace());\n\n                //// error: `line` does not live long enough\n                // handler_str.invoke_external_proc(key)\n            }\n            Err(std::io::IoError { kind: std::io::EndOfFile, .. }) =&gt; break ,\n            Err(error) =&gt; panic!(\"io error: {}\" , error),\n        }\n    }\n}\n</code></pre>\n\n<p><a href=\"http://is.gd/dxtuOv\" rel=\"nofollow\">Rust playpen</a></p>\n\n<p>I get \"line does not live long enough\" error if I uncomment line inside the loop. In fact, I realize that Rust is afraid that I could store short-living reference to a slice somewhere inside <em>Handler</em> object, but I quite sure that I wouldn't, and I also know, that it is safe to pass pointers to the external proc (actually, memory is immidiately copied at the C library side).</p>\n\n<p>Is there any way for me to bypass this check?</p>\n"}, {"tags": ["module", "rust", "rust-cargo"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1421275966, "post_id": 27947424, "comment_id": 44302960, "body": "You may want to brush up on the terminology here. I know it&#39;s confusing when you first start with it, but there&#39;s an important difference between a <i>crate</i> and a <i>module</i>. You created a new crate when you ran <code>cargo new</code>."}], "answers": [{"comments": [{"owner": {"reputation": 1238, "user_id": 759901, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/56175c4faa3db6d594ed7a0688b0c296?s=128&d=identicon&r=PG", "display_name": "leshow", "link": "https://stackoverflow.com/users/759901/leshow"}, "edited": false, "score": 0, "creation_date": 1421253182, "post_id": 27947586, "comment_id": 44290602, "body": "I did what you suggested, put my code mnemonic/src/lib.rs. ran cargo build in the mnemonic dir. then in src/main.rs i put extern crate mnemonic; use mnemonic;. I get the error &#39;can&#39;t find crate for mnemonic&#39;"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1238, "user_id": 759901, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/56175c4faa3db6d594ed7a0688b0c296?s=128&d=identicon&r=PG", "display_name": "leshow", "link": "https://stackoverflow.com/users/759901/leshow"}, "edited": false, "score": 0, "creation_date": 1421253786, "post_id": 27947586, "comment_id": 44291016, "body": "@leshow I think we got crossed (your question is a bit ambiguous). I&#39;ve reformatted my answer to show you the 3 possibilities better. I think you are combining #1 and #2, which doesn&#39;t make sense."}, {"owner": {"reputation": 1238, "user_id": 759901, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/56175c4faa3db6d594ed7a0688b0c296?s=128&d=identicon&r=PG", "display_name": "leshow", "link": "https://stackoverflow.com/users/759901/leshow"}, "edited": false, "score": 0, "creation_date": 1421255623, "post_id": 27947586, "comment_id": 44292154, "body": "I think we are still not fully understanding each other, I tried the suggestions and wasn&#39;t able to get it working, I edited my original post to better show the project directory structure."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1421259210, "last_edit_date": 1421259210, "creation_date": 1421252315, "answer_id": 27947586, "question_id": 27947424, "link": "https://stackoverflow.com/questions/27947424/how-do-i-use-a-new-local-module/27947586#27947586", "title": "How do I use a new local module?", "body": "<h2>Updated Answer</h2>\n\n<p>Yes, you need to tell Cargo where to find your crate. In your binaries <code>Cargo.toml</code>, add something like:</p>\n\n<pre><code>[dependencies.mnemonic]\npath = \"./mnemonic\"\n</code></pre>\n\n<h2>Original Answer</h2>\n\n<p>When you create a new crate, it automatically has one layer of namespacing: the name of the crate itself. In addition, you don't need to <code>extern use</code> a crate if it is your current crate!</p>\n\n<h3>Using crate <code>mnemonic</code> from other crates</h3>\n\n<p>This is probably what you want to do: Create a new crate called <code>mnemonic</code>, then you will have a <code>src/lib.rs</code>. Put your code in there, and you can then use it from <em>other crates</em> with</p>\n\n<pre><code>extern crate mnemonic;\nuse mnemonic::ItemInLibDotRs; // Make sure this item is marked as `pub`!\n</code></pre>\n\n<h3>Using a nested module <code>mnemonic</code> from the crate <code>mnemonic</code></h3>\n\n<p>Say you have some implementation detail you want to hide from the end user. We will put it in a module within the crate, and use it <em>only from within the same crate</em>.</p>\n\n<p>Put your code in <code>src/mnemonic.rs</code>. In <code>src/lib.rs</code>, you will reference that module and items:</p>\n\n<pre><code>use mnemonic::ItemInMnemonic; // Make sure this is `pub`!\nmod mnemonic;\n</code></pre>\n\n<h3>Using a nested module <code>mnemonic</code> from the crate <code>mnemonic</code> in other crates</h3>\n\n<p>Export the module from your crate, and then reference it from <em>other crates</em>:</p>\n\n<pre><code>// src/lib.rs\npub mod mnemonic; // Note the module is now public\n\n// In the crate that consumes mnemonic\nextern crate mnemonic;\nuse mnemonic::mnemonic::ItemInMnemonic;\n</code></pre>\n\n<p>This last option is kind of ugly though, you probably don't want to make your users type <code>mnemonic::mnemonic</code>, which is why I suggest just putting it in <code>src/lib.rs</code>.</p>\n"}], "owner": {"reputation": 1238, "user_id": 759901, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/56175c4faa3db6d594ed7a0688b0c296?s=128&d=identicon&r=PG", "display_name": "leshow", "link": "https://stackoverflow.com/users/759901/leshow"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1492, "favorite_count": 1, "accepted_answer_id": 27947586, "answer_count": 1, "score": 0, "last_activity_date": 1421369223, "creation_date": 1421251816, "last_edit_date": 1421369223, "question_id": 27947424, "link": "https://stackoverflow.com/questions/27947424/how-do-i-use-a-new-local-module", "title": "How do I use a new local module?", "body": "<p>I'm unable to import and use a module I've written, not sure where I went wrong.</p>\n\n<p>My starting directory structure is:</p>\n\n<pre><code>/src/main.rs &lt;- contains fn main()\n/Cargo.toml\n</code></pre>\n\n<p>I wanted to refactor some code out of one big main file I had, so I ran</p>\n\n<pre><code>cargo new mnemonic\n</code></pre>\n\n<p>leaving me with:</p>\n\n<pre><code>/src/main.rs &lt;- contains fn main()\n/Cargo.toml\n/mnemonic/src/lib.rs\n/mnemonic/Cargo.toml\n</code></pre>\n\n<p>in the <code>/mnemonic/src/lib.rs</code> that was created I put:</p>\n\n<pre><code>pub mod mnemonic;\n</code></pre>\n\n<p>then put my code in <code>/mnemonic/src/mnemonic.rs</code> (has 2 public functions I want to use from <code>main</code>). I ran <code>cargo build</code> from <code>mnemonic/</code> and back in my main src, I tried</p>\n\n<pre><code>extern crate mnemonic;\n</code></pre>\n\n<p>and</p>\n\n<pre><code>use mnemonic;\n</code></pre>\n\n<p>I also tried <code>use mnemonic::mnemonic</code>;</p>\n\n<p>In all instances, it was unable to find the crate or gave an unresolved import error.</p>\n\n<p>I've also tried putting my code containing the 2 pub functions in <code>/src/mnemonic.rs</code></p>\n\n<p>and in <code>/src/main.rs</code> putting:</p>\n\n<pre><code>use mnemonic;\n</code></pre>\n\n<p>I also tried just putting my code in <code>mnemonic/src/lib.rs</code> and trying <code>extern crate mnemonic; use mnemonic;</code> from <code>src/main.rs</code></p>\n\n<p>Am I supposed to edit <code>Cargo.toml</code> in any of the instances you proposed?</p>\n"}, {"tags": ["rust", "unit-type"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 20, "last_activity_date": 1421247928, "creation_date": 1421247928, "answer_id": 27946002, "question_id": 27945858, "link": "https://stackoverflow.com/questions/27945858/how-to-return-ok-unit-type-of-stdresult-e/27946002#27946002", "title": "How to return Ok unit type of std::result&lt;(), E&gt;?", "body": "<p>The only value of type <code>()</code> is <code>()</code>, so just put that inside the <code>Ok</code> constructor:</p>\n\n<pre><code>fn f() -&gt; Result&lt;(), E&gt; {\n    Ok(())\n}\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "is_accepted": false, "score": 5, "last_activity_date": 1421247966, "creation_date": 1421247966, "answer_id": 27946020, "question_id": 27945858, "link": "https://stackoverflow.com/questions/27945858/how-to-return-ok-unit-type-of-stdresult-e/27946020#27946020", "title": "How to return Ok unit type of std::result&lt;(), E&gt;?", "body": "<p>Use <code>Ok(())</code> as in</p>\n\n<pre><code>fn f() -&gt; Result&lt;(), E&gt; {\n    Ok(())\n}\n</code></pre>\n"}], "owner": {"reputation": 41983, "user_id": 866732, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG", "display_name": "WiSaGaN", "link": "https://stackoverflow.com/users/866732/wisagan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5172, "favorite_count": 2, "accepted_answer_id": 27946002, "answer_count": 2, "score": 14, "last_activity_date": 1421276011, "creation_date": 1421247500, "last_edit_date": 1421276011, "question_id": 27945858, "link": "https://stackoverflow.com/questions/27945858/how-to-return-ok-unit-type-of-stdresult-e", "title": "How to return Ok unit type of std::result&lt;(), E&gt;?", "body": "<p>If I define a function:</p>\n\n<pre><code>fn f() -&gt; Result&lt;(), E&gt; {\n    // How to return Ok()?\n}\n</code></pre>\n\n<p>How can I return the <code>Ok</code> in <code>std::result</code> with the unit type <code>()</code>?</p>\n"}, {"tags": ["rust", "lifetime", "borrow-checker"], "comments": [{"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 0, "creation_date": 1421228678, "post_id": 27939355, "comment_id": 44275906, "body": "Are you intentionally storing the value as <code>*mut T</code> instead of <code>&amp;&#39;a mut T</code>?"}, {"owner": {"reputation": 13772, "user_id": 944430, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/4d2b181af01c96927ac05eb864d6b7b6?s=128&d=identicon&r=PG", "display_name": "Maik Klein", "link": "https://stackoverflow.com/users/944430/maik-klein"}, "reply_to_user": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 0, "creation_date": 1421228780, "post_id": 27939355, "comment_id": 44275972, "body": "@Dogbert yes because I want multiple mutable pointers in the same scope.(For experimentation only)"}], "answers": [{"comments": [{"owner": {"reputation": 13772, "user_id": 944430, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/4d2b181af01c96927ac05eb864d6b7b6?s=128&d=identicon&r=PG", "display_name": "Maik Klein", "link": "https://stackoverflow.com/users/944430/maik-klein"}, "edited": false, "score": 0, "creation_date": 1421238561, "post_id": 27940991, "comment_id": 44281363, "body": "I have done the same thing a few minutes ago. The problem with this is that <code>b.v</code> won&#39;t work anymore once I have done <code>MutPtr::new(&amp;mut b)</code>. I assume <code>ContravariantLifetime</code> saves that a variable was mutably borrowed? The error is <code>cannot use b.v because it was mutably borrowed</code>"}, {"owner": {"reputation": 1479, "user_id": 4450817, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/566922fb80a38c57d6a0db0be0f42f3b?s=128&d=identicon&r=PG&f=1", "display_name": "Vaelden", "link": "https://stackoverflow.com/users/4450817/vaelden"}, "reply_to_user": {"reputation": 13772, "user_id": 944430, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/4d2b181af01c96927ac05eb864d6b7b6?s=128&d=identicon&r=PG", "display_name": "Maik Klein", "link": "https://stackoverflow.com/users/944430/maik-klein"}, "edited": false, "score": 0, "creation_date": 1421245477, "post_id": 27940991, "comment_id": 44285513, "body": "I guess the issue is because what you are trying to do (creating two mutable references to the same content) is explicitly marked as <a href=\"http://doc.rust-lang.org/book/unsafe.html#references\" rel=\"nofollow noreferrer\">undefined behaviour</a>. Thus, maybe there is no way for you to provide a safe interface implementing this kind of behaviour, or at least I don&#39;t know it."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 13772, "user_id": 944430, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/4d2b181af01c96927ac05eb864d6b7b6?s=128&d=identicon&r=PG", "display_name": "Maik Klein", "link": "https://stackoverflow.com/users/944430/maik-klein"}, "edited": false, "score": 0, "creation_date": 1421285674, "post_id": 27940991, "comment_id": 44305915, "body": "@MaikKlein: You should take a look at <a href=\"http://doc.rust-lang.org/std/cell/struct.RefCell.html\" rel=\"nofollow noreferrer\"><code>RefCell</code></a>, which lets you, for example, have many immutable references to a <code>RefCell</code> from which you can obtain a mutable reference to the interior, as long as there is only one active mutable borrow at a time."}, {"owner": {"reputation": 5007, "user_id": 23059, "user_type": "registered", "accept_rate": 47, "profile_image": "https://www.gravatar.com/avatar/28d1534c68a23bb158022f3d5f0985ad?s=128&d=identicon&r=PG", "display_name": "Cameron Taggart", "link": "https://stackoverflow.com/users/23059/cameron-taggart"}, "edited": false, "score": 0, "creation_date": 1506424008, "post_id": 27940991, "comment_id": 79806589, "body": "I want to try ContravariantLifetime? Where can I find it? Do I need to use unstable rust with a feature enabled? Do I need to use a library? <code>use std::marker::ContravariantLifetime;</code> errors with <code>no </code>ContravariantLifetime` in <code>marker</code>."}, {"owner": {"reputation": 732, "user_id": 1007605, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/2007453909aa470a1a681c5959d50a90?s=128&d=identicon&r=PG", "display_name": "purefanatic", "link": "https://stackoverflow.com/users/1007605/purefanatic"}, "edited": false, "score": 0, "creation_date": 1616880475, "post_id": 27940991, "comment_id": 118143402, "body": "<code>ContravariantLifetime</code> was replaced by <code>std::marker::PhantomData</code> some time ago."}], "tags": [], "owner": {"reputation": 1479, "user_id": 4450817, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/566922fb80a38c57d6a0db0be0f42f3b?s=128&d=identicon&r=PG&f=1", "display_name": "Vaelden", "link": "https://stackoverflow.com/users/4450817/vaelden"}, "is_accepted": true, "score": 5, "last_activity_date": 1616884065, "last_edit_date": 1616884065, "creation_date": 1421232115, "answer_id": 27940991, "question_id": 27939355, "link": "https://stackoverflow.com/questions/27939355/how-can-i-enforce-lifetimes-for-a-struct-that-contains-a-raw-pointer/27940991#27940991", "title": "How can I enforce lifetimes for a struct that contains a raw pointer?", "body": "<p>I think what you are looking for is <code>core::marker::PhantomData</code> (also available in <code>std::marker::PhantomData</code>).\nWhat happens is that the compiler does not assign any lifetime to a pointer variable, so the compiler doesn't know how to constrain the lifetime of the structure.</p>\n<p>The way to do it is to add a marker <code>PhantomData&lt;&amp;'a ()&gt;</code> to your structure, which tells the compiler the lifetime of the entire structure may not outlive <code>'a</code> (in effect, pretending that <code>MutPtr&lt;'a, T&gt;</code> has a <code>&amp;'a ()</code> field in it, even though it does not).</p>\n<p>So in the end your struct should look like this:</p>\n<pre><code>struct MutPtr&lt;'a, T&gt; {\n    ptr: *mut T,\n    _covariant: PhantomData&lt;&amp;'a ()&gt;,\n}\n\nimpl&lt;'a, T&gt; MutPtr&lt;'a, T&gt; {\n    fn new(value: &amp;'a mut T) -&gt; MutPtr&lt;'a, T&gt; {\n        MutPtr {\n            ptr: value,\n            _covariant: PhantomData,\n        }\n    }\n}\n</code></pre>\n<p>With this you get the expected error <code>b does not live long enough</code>.</p>\n"}], "owner": {"reputation": 13772, "user_id": 944430, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/4d2b181af01c96927ac05eb864d6b7b6?s=128&d=identicon&r=PG", "display_name": "Maik Klein", "link": "https://stackoverflow.com/users/944430/maik-klein"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 618, "favorite_count": 1, "accepted_answer_id": 27940991, "answer_count": 1, "score": 3, "last_activity_date": 1616884402, "creation_date": 1421227112, "last_edit_date": 1616884402, "question_id": 27939355, "link": "https://stackoverflow.com/questions/27939355/how-can-i-enforce-lifetimes-for-a-struct-that-contains-a-raw-pointer", "title": "How can I enforce lifetimes for a struct that contains a raw pointer?", "body": "<blockquote>\n<p><strong>Editor's note:</strong> This code no longer compiles in Rust 1.0 with the error <code>parameter `'a` is never used</code>. The reason for this error is exactly because of the problem demonstrated below, so the (updated) solution remains applicable.</p>\n</blockquote>\n<pre><code>extern crate core;\nuse core::ops::{Deref, DerefMut};\n\nstruct MutPtr&lt;'a, T&gt; {\n    ptr: *mut T,\n}\nimpl&lt;'a, T&gt; MutPtr&lt;'a, T&gt; {\n    fn new&lt;'b&gt;(value: &amp;'b mut T) -&gt; MutPtr&lt;'b, T&gt; {\n        MutPtr { ptr: value }\n    }\n}\nimpl&lt;'a, T&gt; Deref for MutPtr&lt;'a, T&gt; {\n    type Target = T;\n    fn deref(&amp;self) -&gt; &amp;T {\n        unsafe { &amp;(*self.ptr) }\n    }\n}\nimpl&lt;'a, T&gt; DerefMut for MutPtr&lt;'a, T&gt; {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {\n        unsafe { &amp;mut (*self.ptr) }\n    }\n}\nstruct Bar {\n    v: i32,\n}\n\nfn err&lt;'a&gt;() -&gt; MutPtr&lt;'a, Bar&gt; {\n    let mut b = Bar { v: 42 };\n    MutPtr::new(&amp;mut b) // Shouldn't this throw an error?\n}\n\nfn main() {\n    let mut b = Bar { v: 42 };\n    let mut ptr_b = MutPtr::new(&amp;mut b);\n    let mut ptr_b1 = MutPtr::new(&amp;mut b);\n\n    ptr_b.v = 10;\n    println!(&quot;{}&quot;, b.v);\n    ptr_b1.v = 21;\n    println!(&quot;{}&quot;, b.v);\n}\n</code></pre>\n<p>This code block is causing some confusion:</p>\n<pre><code>fn err&lt;'a&gt;() -&gt; MutPtr&lt;'a, Bar&gt; {\n    let mut b = Bar { v: 42 };\n    MutPtr::new(&amp;mut b) // Shouldn't this throw an error?\n}\n</code></pre>\n<p>Why does this compile?</p>\n<p>When I call</p>\n<pre><code>MutPtr::new(&amp;mut b)\n</code></pre>\n<p>Shouldn't it have the lifetime of <code>b</code>? I expected a compile error because the lifetime <code>'a</code> is longer than the lifetime of <code>MutPtr&lt;'b, Bar&gt;</code>.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1421235553, "post_id": 27938260, "comment_id": 44279753, "body": "changing err.v works in the playpen... <a href=\"http://is.gd/CehSEO\" rel=\"nofollow noreferrer\">is.gd/CehSEO</a> and yes, you just got lucky. if you run this without optimizations, nothing changes. since you set the pointer to some place in the stack inside a function, you probably didn&#39;t modify any memory that isn&#39;t overwritten before the next use. What you did was create undefined behavior which is very bad as you noted. Rust does not protect any memory from unsafe meddling."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1421235903, "post_id": 27938260, "comment_id": 44279937, "body": "also if you are interested in what&#39;s actually happening, you can generate LLVM-IR or asm code and analyze step by step."}], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 3, "last_activity_date": 1421236584, "last_edit_date": 1421236584, "creation_date": 1421236214, "answer_id": 27942290, "question_id": 27938260, "link": "https://stackoverflow.com/questions/27938260/what-happens-when-i-write-to-a-random-memory-address/27942290#27942290", "title": "What happens when I write to a random memory address?", "body": "<blockquote>\n  <p>Was I just \"lucky\" that the write didn't change anything? </p>\n</blockquote>\n\n<p>Yes, just lucky.</p>\n\n<p>Writing to random memory is <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behaviour</a>: the compiler assumes it never happens and optimises assuming this. If it does occur there's no limit or guarantees one can make about the resulting behaviour. E.g. it could <a href=\"https://en.wikipedia.org/wiki/Return-oriented_programming\" rel=\"nofollow\">change the return address</a> used at the end of the next function call, making the CPU jump to some \"random\" piece of memory. It's generally really bad and such things are likely to be an exploitable security hole.</p>\n\n<p>In the case, you've written, the lack of horrible program death is likely because <code>err</code> points lower down the stack, which the program isn't using at the point that the write happens. If the write happens while that area of the stack is being used, things like modifying pointers to point to nonsense can easily happen:</p>\n\n<pre><code>use std::mem;\n\n#[inline(never)]\nfn bad() -&gt; &amp;'static mut u32 {\n    let mut x = 0u32;\n    unsafe { mem::transmute(&amp;mut x) }\n}\n\n#[inline(never)]\nfn innocent(x: &amp;mut u32) {\n    println!(\"{:p}\", &amp;*x);\n    *x = 0xDEADBEEF;\n\n    println!(\"{:p}\", x);\n    *x = 0;\n}\n\nfn main() {\n    let ptr = bad();\n    innocent(ptr);\n}\n</code></pre>\n\n<p>On <a href=\"http://play.rust-lang.org/?run=1&amp;code=use%20std%3A%3Amem%3B%0A%0A%23%5Binline%28never%29%5D%0Afn%20bad%28%29%20-%3E%20%26%27static%20mut%20u32%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200u32%3B%0A%20%20%20%20unsafe%20%7B%20mem%3A%3Atransmute%28%26mut%20x%29%20%7D%0A%7D%0A%0A%23%5Binline%28never%29%5D%0Afn%20innocent%28x%3A%20%26mut%20u32%29%20%7B%0A%20%20%20%20println!%28%22%7B%3Ap%7D%22%2C%20%26*x%29%3B%0A%20%20%20%20*x%20%3D%200xDEADBEEF%3B%0A%0A%20%20%20%20println!%28%22%7B%3Ap%7D%22%2C%20x%29%3B%0A%20%20%20%20*x%20%3D%200%3B%0A%7D%0A%0Afn%20main%28%29%20%7B%0A%20%20%20%20let%20ptr%20%3D%20bad%28%29%3B%0A%20%20%20%20innocent%28ptr%29%3B%0A%7D\" rel=\"nofollow\">playpen</a> with <code>-O2</code>, at the moment, it prints:</p>\n\n<pre><code>0x7fff03dbae84\n0xdeadbeef03dbae84\nplaypen: application terminated abnormally with signal 4 (Illegal instruction)\n</code></pre>\n\n<p>The first line is <code>x</code>s real value. The next line is <code>x</code> after <code>*x = 0xDEADBEEF;</code>... that is, that write was directly to the part of stack that was storing <code>x</code> itself, changing the upper half to <code>0xDEADBEEF</code>. At this point, <code>x</code> is a nonsense value, so the <code>*x = 0</code> causes a segfault (which manifests as an abort, due to Rust overriding some signal handlers by default).</p>\n\n<p>I say \"at the moment\" because the behaviour of the program is very sensitive to the exact compiler versions/optimisation levels/source code, e.g. changing the first <code>print</code> to remove the <code>&amp;*</code> makes the program print <code>0x7fff03dbae84</code> twice and then abort (likely because the return address is being modified rather than <code>x</code>).</p>\n\n<p>If an attacker has any control over what gets written to an invalid pointer, they may/are likely to be able to modify the write pointer to cause the program to jump to a <a href=\"http://en.wikipedia.org/wiki/Shellcode\" rel=\"nofollow\">piece of shellcode</a> and pwn your application. I saw likely because <a href=\"http://googleprojectzero.blogspot.com.au/2014/08/the-poisoned-nul-byte-2014-edition.html\" rel=\"nofollow\">even the smallest \"unexploitable\" problems</a> have been proved to be exploitable.</p>\n"}], "owner": {"reputation": 13772, "user_id": 944430, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/4d2b181af01c96927ac05eb864d6b7b6?s=128&d=identicon&r=PG", "display_name": "Maik Klein", "link": "https://stackoverflow.com/users/944430/maik-klein"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 266, "favorite_count": 0, "accepted_answer_id": 27942290, "answer_count": 1, "score": 1, "last_activity_date": 1421236584, "creation_date": 1421222556, "last_edit_date": 1421222857, "question_id": 27938260, "link": "https://stackoverflow.com/questions/27938260/what-happens-when-i-write-to-a-random-memory-address", "title": "What happens when I write to a random memory address?", "body": "<pre><code>extern crate core;\nuse core::ops::{Deref, DerefMut};\n\nstruct MutPtr&lt;T&gt;{\n    ptr: *mut T\n}\nimpl&lt;T&gt; MutPtr&lt;T&gt;{\n    fn new(value: &amp;mut T) -&gt; MutPtr&lt;T&gt;{\n        MutPtr{ptr: value} \n    }\n}\nimpl&lt;T&gt; Deref for MutPtr&lt;T&gt;{\n    type Target = T;\n    fn deref(&amp;self) -&gt; &amp;T{\n        unsafe{\n            &amp;(*self.ptr)\n        }\n    }\n}\nimpl&lt;T&gt; DerefMut for MutPtr&lt;T&gt;{\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut T{\n        unsafe{\n            &amp;mut (*self.ptr)\n        }\n    }\n}\nstruct Bar{\n    v: i32\n}\n\nfn error()-&gt; MutPtr&lt;Bar&gt; {\n    let mut b = Bar{v:42};\n    let ptr_b =  MutPtr::new(&amp;mut b);\n    ptr_b\n}\n\nfn main(){\n    let mut b      = Bar{v:42};\n    let mut ptr_b  = MutPtr::new(&amp;mut b);\n    let mut ptr_b1 = MutPtr::new(&amp;mut b);\n\n    ptr_b.v = 10;\n    println!(\"{}\",b.v);\n    ptr_b1.v = 21;\n    println!(\"{}\",b.v);\n\n    let mut err = error();\n    println!(\"{}\",err.v);\n    err.v = 42; // what happens here?\n    println!(\"{}\",err.v);\n}\n</code></pre>\n\n<p>On line 49 I am going to write to some memory address </p>\n\n<pre><code>err.v = 42;\n</code></pre>\n\n<p>I know that this is very bad, but I am wondering what actually happens? At first I expected it would crash but then I expected that I would be able to change the value at the address of err.v. But the write didn't do anything. </p>\n\n<p>The memory seems to be write protected? </p>\n\n<p>Was I just \"lucky\" that the write didn't change anything? </p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 79096, "user_id": 865874, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ACMnN.png?s=128&g=1", "display_name": "rodrigo", "link": "https://stackoverflow.com/users/865874/rodrigo"}, "edited": false, "score": 4, "creation_date": 1421189429, "post_id": 27932840, "comment_id": 44263558, "body": "I think that at this moment there is no stable alternative! We will just have to bear the wasrnings until the compiler goes into beta. Or you can disable the warning, if you prefer."}, {"owner": {"user_type": "does_not_exist", "display_name": "user289841"}, "edited": false, "score": 1, "creation_date": 1421193675, "post_id": 27932840, "comment_id": 44265095, "body": "There&#39;s a similar warning for <code>range_step</code> at the moment. No actual replacement here as well. I guess there will be a couple of changes till beta version."}, {"owner": {"reputation": 14956, "user_id": 544557, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ad1df76ef4fab96ec67b2afa080b3a0c?s=128&d=identicon&r=PG", "display_name": "Jim Balter", "link": "https://stackoverflow.com/users/544557/jim-balter"}, "edited": false, "score": 0, "creation_date": 1421221190, "post_id": 27932840, "comment_id": 44272386, "body": "It&#39;s an Alpha release, which implies that the whole thing is unstable, warnings or no."}], "answers": [{"tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 3, "last_activity_date": 1421214235, "creation_date": 1421214235, "answer_id": 27936543, "question_id": 27932840, "link": "https://stackoverflow.com/questions/27932840/what-is-the-stable-alternative-of-to-string/27936543#27936543", "title": "What is the stable alternative of to_string()", "body": "<p>You can <em>work around</em> these things, e.g. <code>format!(\"Hello\")</code>, but I really wouldn\u2019t bother for the moment.</p>\n"}], "owner": {"reputation": 1048, "user_id": 96030, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/0c17ac1dc90f2a6e94c5801369aa7099?s=128&d=identicon&r=PG", "display_name": "Ben", "link": "https://stackoverflow.com/users/96030/ben"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 644, "favorite_count": 0, "accepted_answer_id": 27936543, "answer_count": 1, "score": 1, "last_activity_date": 1421214235, "creation_date": 1421188910, "last_edit_date": 1495535305, "question_id": 27932840, "link": "https://stackoverflow.com/questions/27932840/what-is-the-stable-alternative-of-to-string", "title": "What is the stable alternative of to_string()", "body": "<p>I'm working my way through the <a href=\"http://doc.rust-lang.org/1.0.0-alpha/book\" rel=\"nofollow noreferrer\">rust book</a>.  In the Strings chapter a lot of the examples use to_string() which my version of the compiler(rustc 1.0.0-dev) gives the following warning</p>\n\n<pre><code>strings.rs:3:23: 3:34 warning: use of unstable item, #[warn(unstable)] on by default\nstrings.rs:3   let mut s = \"Hello\".to_string();\n</code></pre>\n\n<p>Code:</p>\n\n<pre><code>fn main() {\n  let mut s = \"Hello\".to_string();\n  println!(\"{}\", s);\n}\n</code></pre>\n\n<p>I understand from <a href=\"https://stackoverflow.com/questions/27872753/what-is-warnunstable-about-in-rust\">this question</a> that this is because the API is likely to change, but I would like to know what I should use instead if I want to convert a string slice (str&amp;) to a String</p>\n"}, {"tags": ["rust", "traits"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1421188133, "post_id": 27932655, "comment_id": 44263006, "body": "I&#39;m curious to know what this ability will allow you to do."}, {"owner": {"reputation": 2731, "user_id": 1115659, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/e07a4201601ad4298203b843ab64b9e4?s=128&d=identicon&r=PG", "display_name": "aldanor", "link": "https://stackoverflow.com/users/1115659/aldanor"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1421188326, "post_id": 27932655, "comment_id": 44263080, "body": "@Shepmaster edited the post for clarity. Thanks"}, {"owner": {"reputation": 15257, "user_id": 1409312, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/4TCzB.jpg?s=128&g=1", "display_name": "Syntactic Fructose", "link": "https://stackoverflow.com/users/1409312/syntactic-fructose"}, "edited": false, "score": 0, "creation_date": 1421188421, "post_id": 27932655, "comment_id": 44263120, "body": "Note that <code>std::Int</code> is deprecated in 1.0, and replace by <a href=\"http://doc.rust-lang.org/std/primitive.isize.html\" rel=\"nofollow noreferrer\">isize</a>"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1421188671, "post_id": 27932655, "comment_id": 44263226, "body": "@aldanor thanks for the info, but I still feel like something is missing. If you have a <code>i32</code>, then you already know it&#39;s signed. Do you want to create some kind of overloaded method that would automatically check the appropriate error code? Like <code>wrap_error(c_fn_that_returns_signed())</code> and <code>wrap_error(c_fn_that_returns_unsigned())</code>?"}, {"owner": {"reputation": 2731, "user_id": 1115659, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/e07a4201601ad4298203b843ab64b9e4?s=128&d=identicon&r=PG", "display_name": "aldanor", "link": "https://stackoverflow.com/users/1115659/aldanor"}, "edited": false, "score": 1, "creation_date": 1421188680, "post_id": 27932655, "comment_id": 44263229, "body": "If I understand correctly, it&#39;s not the <code>std::Int</code> trait that&#39;s being deprecated, but rather <code>int</code>/<code>uint</code> types. The <code>Int</code>, <code>SignedInt</code> and <code>UnsignedInt</code> traits are still implemented for <code>isize</code> and <code>usize</code>."}, {"owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "reply_to_user": {"reputation": 15257, "user_id": 1409312, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/4TCzB.jpg?s=128&g=1", "display_name": "Syntactic Fructose", "link": "https://stackoverflow.com/users/1409312/syntactic-fructose"}, "edited": false, "score": 0, "creation_date": 1421188712, "post_id": 27932655, "comment_id": 44263248, "body": "@SyntacticFructose Are you sure? It looks like <code>std::Int</code> is implemented for <code>isize</code>. Note that <code>std:Int</code> != <code>int</code>."}, {"owner": {"reputation": 2731, "user_id": 1115659, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/e07a4201601ad4298203b843ab64b9e4?s=128&d=identicon&r=PG", "display_name": "aldanor", "link": "https://stackoverflow.com/users/1115659/aldanor"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1421188831, "post_id": 27932655, "comment_id": 44263309, "body": "@Shepmaster Yep, that&#39;s exactly the idea! When there&#39;s hundreds of such functions, half of them returning ints and the other half uints (of all possible sizes), it&#39;d be nice to have a single wrapper to check for  errors so it begs for a generic. I know how to do this in other languages e.g. D, but not in Rust"}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1421189684, "post_id": 27932959, "comment_id": 44263658, "body": "I was trying to do the same as your latter idea (it seems cleaner), but can you somehow implement it for <code>SignedInt</code> and <code>UnsignedInt</code> instead of concrete types?"}, {"owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1421189944, "post_id": 27932959, "comment_id": 44263767, "body": "@Shepmaster If you try, the compiler complains about conflicting impls. Which is valid, nothing prevents you from implementing both <code>SignedInt</code> and <code>UnsignedInt</code> on a type. I think this is the best we can do."}, {"owner": {"reputation": 2731, "user_id": 1115659, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/e07a4201601ad4298203b843ab64b9e4?s=128&d=identicon&r=PG", "display_name": "aldanor", "link": "https://stackoverflow.com/users/1115659/aldanor"}, "edited": false, "score": 0, "creation_date": 1421190033, "post_id": 27932959, "comment_id": 44263801, "body": "@wingedsubmariner That&#39;s the first thing I naturally tried to do, using <code>SignedInt</code> and <code>UnsignedInt</code> directly until realizing just what you mentioned."}, {"owner": {"reputation": 2731, "user_id": 1115659, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/e07a4201601ad4298203b843ab64b9e4?s=128&d=identicon&r=PG", "display_name": "aldanor", "link": "https://stackoverflow.com/users/1115659/aldanor"}, "edited": false, "score": 0, "creation_date": 1421190071, "post_id": 27932959, "comment_id": 44263821, "body": "It also looks like <code>min_value()</code> and <code>zero()</code> are <code>#[unstable]</code> in the <code>Int</code> trait, oh well."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1421190093, "post_id": 27932959, "comment_id": 44263827, "body": "Ah, I hadn&#39;t thought about implementing both traits on one type. That would be strange in this example! We could create a macro to make it easier to wrap up all the signed types and unsigned though."}, {"owner": {"reputation": 2731, "user_id": 1115659, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/e07a4201601ad4298203b843ab64b9e4?s=128&d=identicon&r=PG", "display_name": "aldanor", "link": "https://stackoverflow.com/users/1115659/aldanor"}, "edited": false, "score": 0, "creation_date": 1421190180, "post_id": 27932959, "comment_id": 44263860, "body": "@wingedsubmariner Thanks for the answer! Just wonder what you meant by &quot;if you remove the unneeded parameter from is_signed: is_signed&lt;int32&gt;&quot;&gt;?"}, {"owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "reply_to_user": {"reputation": 2731, "user_id": 1115659, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/e07a4201601ad4298203b843ab64b9e4?s=128&d=identicon&r=PG", "display_name": "aldanor", "link": "https://stackoverflow.com/users/1115659/aldanor"}, "edited": false, "score": 0, "creation_date": 1421190280, "post_id": 27932959, "comment_id": 44263902, "body": "@aldanor I was referring to the <code>(x: T)</code>, which isn&#39;t needed but might help drive type inference."}], "tags": [], "owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "is_accepted": true, "score": 5, "last_activity_date": 1421190293, "last_edit_date": 1421190293, "creation_date": 1421189432, "answer_id": 27932959, "question_id": 27932655, "link": "https://stackoverflow.com/questions/27932655/how-can-i-write-a-generic-function-that-discriminates-between-signed-and-unsigne/27932959#27932959", "title": "How can I write a generic function that discriminates between signed and unsigned int?", "body": "<p>You can take advantage of the methods on <code>Int</code> to implement <code>is_signed</code>:</p>\n\n<pre><code>fn is_signed&lt;T: Int&gt;(x: T) -&gt; bool {\n    let mv: T = Int::min_value();\n    let z: T = Int::zero();\n    mv &lt; z\n}\n</code></pre>\n\n<p>And then use it like:</p>\n\n<pre><code>is_signed(5i)\n</code></pre>\n\n<p>Or if you remove the unneeded parameter <code>x</code> from <code>is_signed</code>:</p>\n\n<pre><code>is_signed&lt;i32&gt;\n</code></pre>\n\n<p>However, this would not be very efficient or idiomatic. In your case of checking error codes, it would be better to define a trait with the behavior you want, and implement it for each possible type:</p>\n\n<pre><code>trait IsError {\n    fn is_error(self) -&gt; bool;\n}\n\nimpl IsError for isize {\n    fn is_error(self) -&gt; bool { self &lt; 0 }\n}\n\nimpl IsError for usize {\n    fn is_error(self) -&gt; bool { self == 0 }\n}\n</code></pre>\n"}], "owner": {"reputation": 2731, "user_id": 1115659, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/e07a4201601ad4298203b843ab64b9e4?s=128&d=identicon&r=PG", "display_name": "aldanor", "link": "https://stackoverflow.com/users/1115659/aldanor"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 961, "favorite_count": 1, "accepted_answer_id": 27932959, "answer_count": 1, "score": 5, "last_activity_date": 1421276120, "creation_date": 1421188032, "last_edit_date": 1421276120, "question_id": 27932655, "link": "https://stackoverflow.com/questions/27932655/how-can-i-write-a-generic-function-that-discriminates-between-signed-and-unsigne", "title": "How can I write a generic function that discriminates between signed and unsigned int?", "body": "<p>I was wondering if it was possible to discriminate between a signed and unsigned int in Rust. In <code>std::num</code> we have <code>Int</code>, <code>UnsignedInt : Int</code> and <code>SignedInt : Int + Neg</code>, so those two are not mutually exclusive.</p>\n\n<p>In the simplest case, would it be possible to write a simple function <code>fn&lt;T: Int&gt;is_signed(value: T) -&gt; bool</code> that would return true when a signed value is passed (e.g. <code>i32</code>)? Is there a better way of doing this?</p>\n\n<p>Edit in response to a comment below: a real-world example is wrapping a C FFI where functions that return signed integer types indicate an error by returning a <code>-1</code> whereas functions returning uints indicate error by returning <code>0</code> (this, plus it got me interested in what's an idiomatic way of doing it in Rust).</p>\n"}, {"tags": ["string", "vector", "rust"], "answers": [{"comments": [{"owner": {"reputation": 3892, "user_id": 1236045, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9cdfcff173a4487d2a73a29e177930ec?s=128&d=identicon&r=PG&f=1", "display_name": "Micha\u0142 Politowski", "link": "https://stackoverflow.com/users/1236045/micha%c5%82-politowski"}, "edited": false, "score": 1, "creation_date": 1421233953, "post_id": 27931977, "comment_id": 44278895, "body": "@leshow Some motivation/explanation of the <code>{:?}</code> specifier is available in the <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0504-show-stabilization.md\" rel=\"nofollow noreferrer\">Show stabilization RFC</a>."}, {"owner": {"reputation": 1238, "user_id": 759901, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/56175c4faa3db6d594ed7a0688b0c296?s=128&d=identicon&r=PG", "display_name": "leshow", "link": "https://stackoverflow.com/users/759901/leshow"}, "edited": false, "score": 0, "creation_date": 1421246910, "post_id": 27931977, "comment_id": 44286405, "body": "how about to actually convert a Vec&lt;u8&gt; to a string?"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1432476505, "last_edit_date": 1432476505, "creation_date": 1421185090, "answer_id": 27931977, "question_id": 27931605, "link": "https://stackoverflow.com/questions/27931605/what-is-the-idiomatic-way-to-print-a-vec-as-a-string/27931977#27931977", "title": "What is the idiomatic way to print a Vec as a string?", "body": "<p>You can use the <code>:?</code> specifier, which uses the <code>Debug</code> trait.</p>\n\n<pre><code>fn main() {\n    let v = vec![0u8, 1, 2, 3, 4, 5];\n    println!(\"{:?}\", v);\n}\n</code></pre>\n\n<p>If you want it as a <code>String</code>, then you can use <a href=\"http://doc.rust-lang.org/std/macro.format!.html\" rel=\"nofollow\"><code>format!</code></a>:</p>\n\n<pre><code>fn main() {\n    let v = vec![0u8, 1, 2, 3, 4, 5];\n    let s = format!(\"{:?}\", v);\n    println!(\"--&gt;{}&lt;--\", s);\n}\n</code></pre>\n"}], "owner": {"reputation": 1238, "user_id": 759901, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/56175c4faa3db6d594ed7a0688b0c296?s=128&d=identicon&r=PG", "display_name": "leshow", "link": "https://stackoverflow.com/users/759901/leshow"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 209, "favorite_count": 0, "accepted_answer_id": 27931977, "answer_count": 1, "score": 1, "last_activity_date": 1432476505, "creation_date": 1421183583, "last_edit_date": 1421190632, "question_id": 27931605, "link": "https://stackoverflow.com/questions/27931605/what-is-the-idiomatic-way-to-print-a-vec-as-a-string", "title": "What is the idiomatic way to print a Vec as a string?", "body": "<p>Updating my code to the new nightlies and it seems like they've gotten rid of to_string() for std::Vec</p>\n\n<pre><code>src/rust_mnemonic.rs:100:39: 100:50 error: type `collections::vec::Vec&lt;&amp;str&gt;` does not implement any method in scope named `to_string`\nrc/rust_mnemonic.rs:100     println!(\"mnemonic: {}\", mnemonic.to_string());\n</code></pre>\n"}, {"tags": ["rust", "borrow-checker"], "answers": [{"tags": [], "owner": {"reputation": 24277, "user_id": 667984, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/0425d6234a21e166e8cc37878d0e87cd?s=128&d=identicon&r=PG", "display_name": "Renato Zannon", "link": "https://stackoverflow.com/users/667984/renato-zannon"}, "is_accepted": true, "score": 3, "last_activity_date": 1421183233, "creation_date": 1421183233, "answer_id": 27931519, "question_id": 27931098, "link": "https://stackoverflow.com/questions/27931098/borrow-checker-failing-when-using-traits-as-type-parameter/27931519#27931519", "title": "Borrow checker failing when using traits as type parameter", "body": "<p>The problem here is that the borrow checker is forcing the lifetime of the <code>&amp;mut Trait</code> reference to be the same as the whole <code>GenericStruct</code>. I believe this is because the reference  is a type parameter of the struct itself.</p>\n\n<p>Since your struct has no fields that store the reference (if you need to do this in your original code, please update your question), then you can move the type parameter to the method itself, instead of the struct:</p>\n\n<pre><code>trait Trait{}\n\nstruct FooBar;\nimpl Trait for FooBar{}\n\nstruct GenericStruct;\n\nimpl GenericStruct {\n    fn bar&lt;T&gt;(&amp;self, _: T) {}\n}\n\nfn main() {\n    let mut foobar = FooBar;\n\n    {\n        let foo = GenericStruct;\n        foo.bar(&amp;mut foobar);\n        foo.bar(&amp;mut foobar);\n    }\n}\n</code></pre>\n\n<p>This will make the borrow last only as long as the call to <code>foo.bar()</code>.</p>\n"}], "owner": {"reputation": 1479, "user_id": 4450817, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/566922fb80a38c57d6a0db0be0f42f3b?s=128&d=identicon&r=PG&f=1", "display_name": "Vaelden", "link": "https://stackoverflow.com/users/4450817/vaelden"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 100, "favorite_count": 0, "accepted_answer_id": 27931519, "answer_count": 1, "score": 5, "last_activity_date": 1421197122, "creation_date": 1421181616, "last_edit_date": 1421197122, "question_id": 27931098, "link": "https://stackoverflow.com/questions/27931098/borrow-checker-failing-when-using-traits-as-type-parameter", "title": "Borrow checker failing when using traits as type parameter", "body": "<p>I have a problem with the borrow checker when using traits as type parameter in a structure:</p>\n\n<pre><code>trait Trait {}\n\nstruct FooBar;\nimpl Trait for FooBar{}\n\nstruct Observer&lt;Arg&gt; {\n    action: Box&lt;Fn(Arg) + Send&gt;,\n    // Other fields\n}\n\nimpl &lt;Arg&gt; Observer&lt;Arg&gt; {\n    fn new(action: Box&lt;Fn(Arg) + Send&gt;) -&gt; Observer&lt;Arg&gt; {\n        Observer{action: action}\n    }\n\n    fn execute(&amp;self, arg: Arg) {\n        (*self.action)(arg);\n    }\n}\n\nfn test() {\n    let mut foobar = FooBar;\n    {\n        let mut observer = Observer::new(Box::new(|&amp;: param: &amp;mut Trait| {\n            // do something with param here\n        }));\n        observer.execute(&amp;mut foobar);   // First borrow passes ...\n        observer.execute(&amp;mut foobar);   // This fails as \"foobar\" is already borrowed\n    }   // The previous borrow ends here (lifetime of \"observer\")\n}\n</code></pre>\n\n<p>The output is:</p>\n\n<pre><code>error: cannot borrow `foobar` as mutable more than once at a time\n    observer.execute(&amp;mut foobar);   // This fails as \"foobar\" is already borrowed\n                          ^~~~~~\nnote: previous borrow of `foobar` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `foobar` until the borrow ends\n    observer.execute(&amp;mut foobar);   // First borrow passes ...\n                          ^~~~~~\nnote: previous borrow ends here\n {\n...\n }   // The previous borrow ends here (lifetime of \"observer\")\n ^\n</code></pre>\n\n<p>Yet the following example works:</p>\n\n<pre><code>trait Trait {}\n\nstruct FooBar;\nimpl Trait for FooBar{}\n\nstruct Observer {\n    action: Box&lt;Fn(&amp;mut Trait) + Send&gt;,\n    // Other fields\n}\n\nimpl Observer {\n    fn new(action: Box&lt;Fn(&amp;mut Trait) + Send&gt;) -&gt; Observer {\n        Observer{action: action}\n    }\n\n    fn execute(&amp;self, arg: &amp;mut Trait) {\n        (*self.action)(arg);\n    }\n}\n\nfn test() {\n    let mut foobar = FooBar;\n    {\n        let mut observer = Observer::new(Box::new(|&amp;: param: &amp;mut Trait| {\n            // do something with param here\n        }));\n        observer.execute(&amp;mut foobar);\n        observer.execute(&amp;mut foobar);\n    }\n}\n</code></pre>\n\n<p>This looks really weird to me, as the second example is just an instantiation of the first example, and I could probably (painfully) implement the same thing with macros.  </p>\n\n<p>I guess this is quite tricky, as I need to know the type of the parameter taken by the closure, but I don't need to store this reference ...  </p>\n\n<p>Is this a bug in the borrow checker? Or am I doing something wrong?  </p>\n\n<pre><code>rustc 1.0.0-nightly (44a287e6e 2015-01-08 17:03:40 -0800)\n</code></pre>\n\n<p>EDIT 1: Precised the use case</p>\n\n<p>EDIT 2: As explained in the answer below, the issue is that the borrow checker forces the lifetime of <code>Observer&lt;&amp;mut Type&gt;</code> to be the same as the <code>&amp;mut Type</code>, so in fact the issue is not related to the fact that we use a trait as a type parameter (it does the same with an actual structure).<br>\nSo in my case, I can have a workaround by defining <code>Observer&lt;Arg&gt;</code> like this:</p>\n\n<pre><code>struct Observer&lt;Arg&gt; {\n    action: Box&lt;Fn(&amp;mut Arg) + Send&gt;,\n}\n</code></pre>\n\n<p>so the type parameter Arg itself is not a reference, but this makes the code less generic. Anybody has a better solution?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 20407, "user_id": 1017941, "user_type": "registered", "accept_rate": 97, "profile_image": "https://i.stack.imgur.com/yocPw.jpg?s=128&g=1", "display_name": "Hauleth", "link": "https://stackoverflow.com/users/1017941/hauleth"}, "edited": false, "score": 0, "creation_date": 1421207650, "post_id": 27934610, "comment_id": 44268339, "body": "Probably because <code>println</code> is macro, and this is evaluated on compile time. So if some value should be used with 2 different types, then it is natural, that there will be error."}, {"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1421241794, "post_id": 27934610, "comment_id": 44283214, "body": "@steve I can do <code>&quot;{0} {0:#X}&quot;.format(10)</code> in Python"}, {"owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "edited": false, "score": 0, "creation_date": 1421241930, "post_id": 27934610, "comment_id": 44283303, "body": "@steve I should have mentioned that I&#39;m aware that what you do is legal, sorry."}], "tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 0, "last_activity_date": 1421200232, "creation_date": 1421200232, "answer_id": 27934610, "question_id": 27929560, "link": "https://stackoverflow.com/questions/27929560/why-disallow-re-using-the-same-value-in-a-format-macro/27934610#27934610", "title": "Why disallow re-using the same value in a format! macro", "body": "<p>It's not disallowing you from re-using the same value:</p>\n\n<pre><code>fn main() {\n    println!(\"{0} {0}\", 10);\n}\n</code></pre>\n\n<p>works just fine.</p>\n\n<p>The issue is what the error message says:</p>\n\n<pre><code>argument redeclared with type `?` when it was previously ``\n</code></pre>\n\n<p>You're trying to use the same argument as two different types, and that's not cool. I'm not 100% sure why it's not, but it's not.</p>\n"}, {"tags": [], "owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "is_accepted": false, "score": 6, "last_activity_date": 1603781341, "last_edit_date": 1603781341, "creation_date": 1421881937, "answer_id": 28078634, "question_id": 27929560, "link": "https://stackoverflow.com/questions/27929560/why-disallow-re-using-the-same-value-in-a-format-macro/28078634#28078634", "title": "Why disallow re-using the same value in a format! macro", "body": "<p>It's due to a limitation in the formatting system.</p>\n<p>Internally, <code>println!</code> (more accurately, <a href=\"http://doc.rust-lang.org/std/fmt/#format_args!\" rel=\"nofollow noreferrer\"><code>format_args!</code></a>) packs its arguments into an array, pairing each argument with its formatting type. For example, the following expression:</p>\n<pre><code>println!(&quot;{2} {0:?} {1:x}&quot;, 1, 2, 3);\n</code></pre>\n<p>produces this argument array:</p>\n<pre><code>match (&amp;1, &amp;2, &amp;3) {\n    (__arg0, __arg1, __arg2) =&gt; [\n        ::std::fmt::argument(::std::fmt::Debug::fmt, __arg0),\n        ::std::fmt::argument(::std::fmt::LowerHex::fmt, __arg1),\n        ::std::fmt::argument(::std::fmt::Display::fmt, __arg2)\n        ]\n}\n</code></pre>\n<p>(By the way, you can see the full expansion using <code>rustc -Z unstable-options --pretty=expanded main.rs</code>)</p>\n<p>This explains why your example doesn't work: if you wanted the first argument (<code>__arg0</code>) to be <em>both</em> <code>Debug</code> and <code>Display</code>, then where would you put the second type?</p>\n<p>There's no way of lifting this restriction without complicating the system too much, so sadly we'll just have to work around it.</p>\n"}], "owner": {"reputation": 10672, "user_id": 321731, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/88e60659e997d36af3ff348b3251e1a6?s=128&d=identicon&r=PG", "display_name": "tshepang", "link": "https://stackoverflow.com/users/321731/tshepang"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 219, "favorite_count": 0, "answer_count": 2, "score": 9, "last_activity_date": 1603781341, "creation_date": 1421175732, "last_edit_date": 1421176032, "question_id": 27929560, "link": "https://stackoverflow.com/questions/27929560/why-disallow-re-using-the-same-value-in-a-format-macro", "title": "Why disallow re-using the same value in a format! macro", "body": "<p>Given:</p>\n\n<pre><code>fn main() {\n    println!(\"{0} {0:?}\", 10);\n}\n</code></pre>\n\n<p>I get:</p>\n\n<pre><code>main.rs:2:27: 2:29 error: argument redeclared with type `?` when it was previously ``\nmain.rs:2     println!(\"{0} {1:?}\", 10);\n                                    ^~\nerror: aborting due to previous error\n</code></pre>\n\n<p>I am forced to do:</p>\n\n<pre><code>println!(\"{0} {1:?}\", 10, 10);\n// OR\nprintln!(\"{} {:?}\", 10, 10);\n</code></pre>\n\n<p>Why is such a limit imposed upon me?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 15257, "user_id": 1409312, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/4TCzB.jpg?s=128&g=1", "display_name": "Syntactic Fructose", "link": "https://stackoverflow.com/users/1409312/syntactic-fructose"}, "edited": false, "score": 0, "creation_date": 1421188046, "post_id": 27927656, "comment_id": 44262957, "body": "Might be important to note that the entire crate <code>num</code> has been deprecated from rust in 1.0 for some odd reason. Anyone know why?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1421189844, "post_id": 27927656, "comment_id": 44263731, "body": "Probably not truly deprecated, but <a href=\"https://github.com/rust-lang/num\" rel=\"nofollow noreferrer\">extracted to a library not in the standard library</a>. The one in the standard library is deprecated so you start using the external library. This is a common pattern right now."}, {"owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "edited": false, "score": 1, "creation_date": 1421201253, "post_id": 27927656, "comment_id": 44266939, "body": "<a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0369-num-reform.md\" rel=\"nofollow noreferrer\">github.com/rust-lang/rfcs/blob/master/text/0369-num-reform.m&zwnj;&#8203;d</a>"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1421277590, "creation_date": 1421277590, "answer_id": 27954285, "question_id": 27927656, "link": "https://stackoverflow.com/questions/27927656/how-do-i-convert-a-numrational-to-a-decimal-number/27954285#27954285", "title": "How do I convert a num::Rational to a decimal number?", "body": "<p>I think that printing out <em>arbitrary precision decimals</em> is simply a hard problem. I don't see that <a href=\"https://gmplib.org/manual/Rational-Number-Functions.html#Rational-Number-Functions\" rel=\"nofollow\">the GNU Multiple Precision (GMP)\nArithmetic Library</a> supports this functionality. While Rust isn't built on top of GMP, if GMP doesn't have it I wouldn't expect Rust to have it.</p>\n\n<p>The best you may be able to do is divide the numerator by the denominator yourself...</p>\n"}], "owner": {"reputation": 1609, "user_id": 4233606, "user_type": "registered", "accept_rate": 62, "profile_image": "https://i.stack.imgur.com/rh3M0.jpg?s=128&g=1", "display_name": "Vikaton", "link": "https://stackoverflow.com/users/4233606/vikaton"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 713, "favorite_count": 0, "answer_count": 1, "score": 5, "last_activity_date": 1421277590, "creation_date": 1421168994, "last_edit_date": 1421186574, "question_id": 27927656, "link": "https://stackoverflow.com/questions/27927656/how-do-i-convert-a-numrational-to-a-decimal-number", "title": "How do I convert a num::Rational to a decimal number?", "body": "<p>I'm trying to use the external library <a href=\"http://doc.rust-lang.org/num/num/index.html\" rel=\"noreferrer\">num</a> with the goal to convert fractions to arbitrarily long decimal points, however, by reading the docs, I cannot find some clarifying example to convert a fraction to a decimal number. Anyone know how?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 12, "last_activity_date": 1421104503, "last_edit_date": 1421104503, "creation_date": 1421101898, "answer_id": 27911864, "question_id": 27911656, "link": "https://stackoverflow.com/questions/27911656/rust-by-example-the-ref-pattern/27911864#27911864", "title": "Rust by example: The ref pattern", "body": "<p><code>ref</code> creates a pointer into the piece of memory that is being matched on, in this case, <code>ref_to_x</code> is pointing directly to the memory that stores <code>point.x</code>, it is the same as writing <code>let ref_to_x = &amp;point.x</code> in this case.</p>\n\n<p>The pattern is extremely important, as it allows one to reach deep inside complicated data-structures without disturbing the ownership hierarchy. For example, if one has <code>val: &amp;Option&lt;String&gt;</code>, writing</p>\n\n<pre><code>match *val {\n    Some(s) =&gt; println!(\"the string is {}\", s),\n    None =&gt; println!(\"no string\"\n}\n</code></pre>\n\n<p>is not legal, it gives an error like:</p>\n\n<pre><code>&lt;anon&gt;:3:11: 3:15 error: cannot move out of borrowed content\n&lt;anon&gt;:3     match *val {\n                   ^~~~\n&lt;anon&gt;:4:14: 4:15 note: attempting to move value to here\n&lt;anon&gt;:4         Some(s) =&gt; {}\n                      ^\n&lt;anon&gt;:4:14: 4:15 help: to prevent the move, use `ref s` or `ref mut s` to capture value by reference\n&lt;anon&gt;:4         Some(s) =&gt; {}\n                      ^\n</code></pre>\n\n<p>It is not legal to take ownership (move) out of a borrowed value, because that would possibly damage the thing from which the value was borrowed (violating its invariants, causing data to disappear unexpectedly, etc.).</p>\n\n<p>So, one can instead use a reference to just point in the memory with a borrowing <code>&amp;</code> reference.</p>\n\n<hr>\n\n<p>There's a slight subtlety here because (a) <code>point</code> isn't borrowed, so it is OK to move out of <code>point</code> (which consumes ownership of <code>point</code> too, meaning it can't be used later unless reinitialised), and (b) the type <code>int</code> is <code>Copy</code>, so doesn't move ownership when used by value. This is why using <code>myx</code> instead works fine. If the type of <code>x</code> was, say, <code>String</code> (which isn't <code>Copy</code>) and <code>point</code> was borrowed, then the <code>ref</code> will be necessary.</p>\n"}, {"tags": [], "owner": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "is_accepted": false, "score": 19, "last_activity_date": 1515867319, "last_edit_date": 1515867319, "creation_date": 1432496601, "answer_id": 30427618, "question_id": 27911656, "link": "https://stackoverflow.com/questions/27911656/rust-by-example-the-ref-pattern/30427618#30427618", "title": "Rust by example: The ref pattern", "body": "<p>A reference created with <code>ref</code> is exactly the same as reference taken with <code>&amp;</code>.</p>\n\n<p>The difference is where they're allowed in the syntax. <code>ref</code> on the left side of an assignment is like adding <code>&amp;</code> on the right side.</p>\n\n<p>These expressions are equivalent:</p>\n\n<pre><code>let ref x1 = y;\nlet x2 = &amp;y;\n</code></pre>\n\n<p>This redundancy exists because in pattern matching <code>&amp;</code> is used to require that a reference exists already, rather than to make a new one:</p>\n\n<pre><code>let foo = 1;\nmatch foo {\n   ref x =&gt; {\n       /* x == &amp;1 */ \n       match x {\n           &amp;y =&gt; /* y == 1 */\n       }\n   },  \n}\n</code></pre>\n\n<p>(<a href=\"https://github.com/rust-lang/rust-by-example/issues/390\" rel=\"noreferrer\">discussion</a>)</p>\n"}], "owner": {"reputation": 1189, "user_id": 348201, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/1b5c1cb1e1615645078717836ffc3eaf?s=128&d=identicon&r=PG", "display_name": "somesoaccount", "link": "https://stackoverflow.com/users/348201/somesoaccount"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2646, "favorite_count": 1, "accepted_answer_id": 27911864, "answer_count": 2, "score": 6, "last_activity_date": 1516788669, "creation_date": 1421100827, "last_edit_date": 1516788669, "question_id": 27911656, "link": "https://stackoverflow.com/questions/27911656/rust-by-example-the-ref-pattern", "title": "Rust by example: The ref pattern", "body": "<p>I have problems understanding the <code>ref</code> pattern in Rust. I am referring to <a href=\"https://rustbyexample.com/scope/borrow/ref.html\" rel=\"nofollow noreferrer\">https://rustbyexample.com/scope/borrow/ref.html</a></p>\n\n<p>Here is the code I don't understand:</p>\n\n<pre><code>let point = Point { x: 0, y: 0 };\n\nlet _copy_of_x = {\n    // `ref_to_x` is a reference to the `x` field of `point`\n    let Point { x: ref ref_to_x, y: _ } = point;\n\n    // Return a copy of the `x` field of `point`\n    *ref_to_x\n};\n</code></pre>\n\n<p>I get that the last <code>let</code> expression(?) is some sort of pattern matching. So it's my understanding <code>ref ref_to_x</code> should be equal to <code>0</code>, the <code>x</code> value of the original <code>point</code>.</p>\n\n<p>But I don't understand what the <code>ref</code> actually does. When I add some code like this:</p>\n\n<pre><code>println!(\"x: {}\", point.x);\nprintln!(\"ref_to_x: {}\", ref_to_x);\nprintln!(\"*ref_to_x: {}\", *ref_to_x);\n</code></pre>\n\n<p>I always get <code>0</code>, so there doesn't seem to be a difference. Somehow I'd expect a memory address for <code>ref_to_x</code> while <code>*ref_to_x</code> might be the dereferenced value again.</p>\n\n<p>I can replace both <code>ref ref_to_x</code> and <code>*ref_to_x</code> with <code>myx</code> and the code still works. What's the difference? What does <code>ref</code> do exactly?</p>\n\n<p>edit: after reading dbaupps answer and doing some addition with <code>ref_to_x</code> and <code>*ref_to_x</code> things got a bit clearer; you cannot add an integer to <code>ref_to_x</code> because it's a reference. I guess I got confused because there is no indication of a reference when you print one.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 8, "creation_date": 1421091904, "post_id": 27909064, "comment_id": 44218470, "body": "Try <code>file.lines().map(|x| x.unwrap()).collect::&lt;Vec&lt;_&gt;&gt;()</code>."}, {"owner": {"reputation": 4348, "user_id": 173787, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/0d59a32fa490017d6457aec0e917aced?s=128&d=identicon&r=PG", "display_name": "Davide Aversa", "link": "https://stackoverflow.com/users/173787/davide-aversa"}, "reply_to_user": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "edited": false, "score": 0, "creation_date": 1421092598, "post_id": 27909064, "comment_id": 44218835, "body": "Thanks. It works perfectly. :)"}], "answers": [{"comments": [{"owner": {"reputation": 4348, "user_id": 173787, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/0d59a32fa490017d6457aec0e917aced?s=128&d=identicon&r=PG", "display_name": "Davide Aversa", "link": "https://stackoverflow.com/users/173787/davide-aversa"}, "edited": false, "score": 0, "creation_date": 1421108318, "post_id": 27909870, "comment_id": 44225393, "body": "Thank you for your answer. Also if this is not the &quot;correct&quot; solution to my specific problem. I was really looking for the syntax for specifying type annotation in function calls. This will be useful in the future for sure. ;)"}], "tags": [], "owner": {"reputation": 653, "user_id": 2051092, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/6eabdb0f0b8be9a8fef78646df1a392a?s=128&d=identicon&r=PG", "display_name": "GGalizzi", "link": "https://stackoverflow.com/users/2051092/ggalizzi"}, "is_accepted": false, "score": 27, "last_activity_date": 1526155719, "last_edit_date": 1526155719, "creation_date": 1421093088, "answer_id": 27909870, "question_id": 27909064, "link": "https://stackoverflow.com/questions/27909064/how-to-put-a-type-annotation-in-an-iterators-collect-statement/27909870#27909870", "title": "How to put a type annotation in an iterator&#39;s collect statement?", "body": "<p><a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect\" rel=\"noreferrer\"><code>Iterator::collect</code>'s signature</a> looks like this:</p>\n\n<pre><code>fn collect&lt;B&gt;(self) -&gt; B\nwhere\n    B: FromIterator&lt;Self::Item&gt;, \n</code></pre>\n\n<p>In your case, you need to tell it what <code>B</code> is. To specify the types of a generic function, you use syntax called the <em>turbofish</em>, which looks like <code>func::&lt;T, U, ...&gt;()</code></p>\n\n<p>Your <code>load_file</code> function should look like this:</p>\n\n<pre><code>fn load_file() -&gt; Vec&lt;String&gt; {\n    let file = BufReader::new(File::open(\"foo.txt\").unwrap());\n    file.lines().map(|x| x.unwrap()).collect::&lt;Vec&lt;String&gt;&gt;()\n}\n</code></pre>\n\n<p>You can also allow some type inference to continue by specifying some types as the placeholder <code>_</code>:</p>\n\n<pre><code>fn load_file() -&gt; Vec&lt;String&gt; {\n    let file = BufReader::new(File::open(\"foo.txt\").unwrap());\n    file.lines().map(|x| x.unwrap()).collect::&lt;Vec&lt;_&gt;&gt;()\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 4348, "user_id": 173787, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/0d59a32fa490017d6457aec0e917aced?s=128&d=identicon&r=PG", "display_name": "Davide Aversa", "link": "https://stackoverflow.com/users/173787/davide-aversa"}, "edited": false, "score": 1, "creation_date": 1421107672, "post_id": 27910385, "comment_id": 44225203, "body": "Oh, my, god. I knew the semantic of semicolon in Rust and I used it correctly all along the code. But this time I really don&#39;t notice it! :O Yes, I think the error message really brought me down the wrong road."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 13, "last_activity_date": 1526155567, "last_edit_date": 1526155567, "creation_date": 1421095181, "answer_id": 27910385, "question_id": 27909064, "link": "https://stackoverflow.com/questions/27909064/how-to-put-a-type-annotation-in-an-iterators-collect-statement/27910385#27910385", "title": "How to put a type annotation in an iterator&#39;s collect statement?", "body": "<p>In fact your problem was slightly less noticeable. This does not compile (your initial piece of code):</p>\n\n<pre><code>use std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn load_file() -&gt; Vec&lt;String&gt; {\n    let file = BufReader::new(File::open(\"foo.txt\").unwrap());\n    file.lines().map(|x| x.unwrap()).collect();\n}\n\nfn main() {\n    let data = load_file();\n    println!(\"DATA: {}\", data[0]);\n}\n</code></pre>\n\n<p>But this does:</p>\n\n<pre><code>use std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn load_file() -&gt; Vec&lt;String&gt; {\n    let file = BufReader::new(File::open(\"foo.txt\").unwrap());\n    file.lines().map(|x| x.unwrap()).collect()\n}\n\nfn main() {\n    let data = load_file();\n    println!(\"DATA: {}\", data[0]);\n}\n</code></pre>\n\n<p>Can you notice the subtle difference? It's just a semicolon in the last line of <code>load_file()</code>.</p>\n\n<p>Type inference in Rust is strong enough not to need an annotation here. Your problem was in that you was ignoring the result of <code>collect()</code>! The semicolon acted like a \"barrier\" for the type inference, because with it <code>collect()</code>'s return type and <code>load_file()</code>'s return type are not connected. The error message is somewhat misleading, however; it seems that this phase of type checking ran earlier than the check for return types (which would rightly fail because <code>()</code> is not compatible with <code>Vec&lt;String&gt;</code>).</p>\n"}], "owner": {"reputation": 4348, "user_id": 173787, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/0d59a32fa490017d6457aec0e917aced?s=128&d=identicon&r=PG", "display_name": "Davide Aversa", "link": "https://stackoverflow.com/users/173787/davide-aversa"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 11106, "favorite_count": 4, "accepted_answer_id": 27910385, "answer_count": 2, "score": 13, "last_activity_date": 1526155811, "creation_date": 1421089903, "last_edit_date": 1526155811, "question_id": 27909064, "link": "https://stackoverflow.com/questions/27909064/how-to-put-a-type-annotation-in-an-iterators-collect-statement", "title": "How to put a type annotation in an iterator&#39;s collect statement?", "body": "<p>I have this code:</p>\n\n<pre><code>use std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn load_file() -&gt; Vec&lt;String&gt; {\n    let file = BufReader::new(File::open(\"foo.txt\").unwrap());\n    file.lines().map(|x| x.unwrap()).collect();\n}\n\nfn main() {\n    let data = load_file();\n    println!(\"DATA: {}\", data[0]);\n}\n</code></pre>\n\n<p>When I try to compile it, I get this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0283]: type annotations required: cannot resolve `_: std::iter::FromIterator&lt;std::string::String&gt;`\n --&gt; src/main.rs:6:38\n  |\n6 |     file.lines().map(|x| x.unwrap()).collect();\n  |                                      ^^^^^^^\n</code></pre>\n\n<p>In fact, if I change the <code>load_file</code> function in this way, the code compiles smoothly:</p>\n\n<pre><code>fn load_file() -&gt; Vec&lt;String&gt; {\n    let file = BufReader::new(File::open(\"foo.txt\").unwrap());\n    let lines: Vec&lt;String&gt; = file.lines().map(|x| x.unwrap()).collect();\n    return lines;\n}\n</code></pre>\n\n<p>This solution is not \"Rusty\" enough because ending a function with a return is not encouraged.</p>\n\n<p>Is there a way to put the type annotation directly into the <code>file.lines().map(|x| x.unwrap()).collect();</code> statement?</p>\n"}, {"tags": ["closures", "rust"], "answers": [{"comments": [{"owner": {"reputation": 279, "user_id": 170976, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a206c9e290a5ef53d4cdeaa9f1ef5979?s=128&d=identicon&r=PG", "display_name": "jfager", "link": "https://stackoverflow.com/users/170976/jfager"}, "edited": false, "score": 1, "creation_date": 1421087196, "post_id": 27908150, "comment_id": 44216061, "body": "Just the type hint on the closure arg seems to do it for the first-attempt code: <a href=\"http://is.gd/RU3bL1\" rel=\"nofollow noreferrer\">is.gd/RU3bL1</a>"}, {"owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "reply_to_user": {"reputation": 279, "user_id": 170976, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a206c9e290a5ef53d4cdeaa9f1ef5979?s=128&d=identicon&r=PG", "display_name": "jfager", "link": "https://stackoverflow.com/users/170976/jfager"}, "edited": false, "score": 0, "creation_date": 1421087956, "post_id": 27908150, "comment_id": 44216434, "body": "@jfager in the first attempt you are doing the same thing: inserting a trait Object in the hashmap."}, {"owner": {"reputation": 279, "user_id": 170976, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a206c9e290a5ef53d4cdeaa9f1ef5979?s=128&d=identicon&r=PG", "display_name": "jfager", "link": "https://stackoverflow.com/users/170976/jfager"}, "edited": false, "score": 0, "creation_date": 1421088434, "post_id": 27908150, "comment_id": 44216653, "body": "Not sure I follow what you mean.  I was always trying to insert a trait object, that&#39;s what the Box was for.  The fact that the closure arg needed the type hint wasn&#39;t obvious, like you said."}, {"owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "reply_to_user": {"reputation": 279, "user_id": 170976, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a206c9e290a5ef53d4cdeaa9f1ef5979?s=128&d=identicon&r=PG", "display_name": "jfager", "link": "https://stackoverflow.com/users/170976/jfager"}, "edited": false, "score": 0, "creation_date": 1421093750, "post_id": 27908150, "comment_id": 44219447, "body": "@jfager in your attempt with mk_map, your signature says that for any concrete type F implementing the trait in your where clause, the function will be able to return a Box with that concrete type. This is different from a trait object and a very hard signature to fulfill."}, {"owner": {"reputation": 279, "user_id": 170976, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a206c9e290a5ef53d4cdeaa9f1ef5979?s=128&d=identicon&r=PG", "display_name": "jfager", "link": "https://stackoverflow.com/users/170976/jfager"}, "edited": false, "score": 0, "creation_date": 1421108425, "post_id": 27908150, "comment_id": 44225427, "body": "Ah, ok, I don&#39;t actually care about mk_map, it was a half-hearted attempt to work around the actual issue.  I don&#39;t fully understand why it&#39;s a difficult signature to fill, though - it&#39;s a concrete type, but it isn&#39;t a <i>named</i> concrete type, which is what I understood to be the thing you couldn&#39;t do w/ closures b/c the types were one-offs.  Thanks."}, {"owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "reply_to_user": {"reputation": 279, "user_id": 170976, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a206c9e290a5ef53d4cdeaa9f1ef5979?s=128&d=identicon&r=PG", "display_name": "jfager", "link": "https://stackoverflow.com/users/170976/jfager"}, "edited": false, "score": 0, "creation_date": 1421154732, "post_id": 27908150, "comment_id": 44242821, "body": "@jfager I tried to address your comment directly in my answer, as it was hard to do in a comment"}], "tags": [], "owner": {"reputation": 22050, "user_id": 497364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d8fd4eb2ae966a16e698b3e61217a7e1?s=128&d=identicon&r=PG", "display_name": "Paolo Falabella", "link": "https://stackoverflow.com/users/497364/paolo-falabella"}, "is_accepted": true, "score": 3, "last_activity_date": 1421154684, "last_edit_date": 1421154684, "creation_date": 1421086000, "answer_id": 27908150, "question_id": 27906885, "link": "https://stackoverflow.com/questions/27906885/storing-an-unboxed-closure-with-a-reference-arg-in-a-hashmap/27908150#27908150", "title": "Storing an unboxed closure with a reference arg in a HashMap", "body": "<p>My solution:</p>\n\n<pre><code>#![allow(unstable)]\nuse std::collections::hash_map::HashMap;\n\n// #1 returning a trait object   \nfn mk_map&lt;'a&gt;() -&gt; HashMap&lt;String, (String, Box&lt;FnMut(&amp;str) + 'a&gt;)&gt; {\n    let mut cmds : HashMap&lt;_, (_, Box&lt;FnMut(&amp;str)&gt;)&gt; = HashMap::new();\n\n    cmds.insert(\"ping\".to_string(), (\"ping\".to_string(), \n        Box::new(|&amp;mut: s: &amp;str| { println!(\"{}\", s); })));\n    // #2                  ^-- give a little help to the compiler here\n    cmds\n}   \n\nfn main() {\n    let mut cmds = mk_map();\n    // minor change: cmds needs to be mutable\n    match cmds.get_mut(\"ping\") {\n        Some(&amp;mut (_, ref mut f)) =&gt; f(\"pong\"),\n        _ =&gt; println!(\"invalid command\")\n    }\n}\n</code></pre>\n\n<p>Ingredients:</p>\n\n<ol>\n<li>return a trait object </li>\n<li>give some help to the compiler on the type of the closure's parameter: <code>Box::new(|&amp;mut: s: &amp;str|</code></li>\n</ol>\n\n<p>To be honest, I'm not 100% sure about the reason for #2 (I mean, at least leaving it out should give a more intelligible error message). Probably an issue with rustc.</p>\n\n<p>On #1, I'm almost sure it's required because you can't name a concrete return type for a closure returned from a function (it's an anonymous type created on the fly by the compiler), so Trait objects for now should be the only way to return a closure.</p>\n\n<p><strong>Appendix</strong>\nresponding to comment:</p>\n\n<p>imagine you have a <code>trait Foo {}</code> implemented by a few types:</p>\n\n<pre><code>trait Foo {}\nimpl Foo for u32 {}\nimpl Foo for Vec&lt;f32&gt; {}\n</code></pre>\n\n<p>if you write a function like you did with mk_map (let's call it make_foo) I commented that it's going to be hard to implement it. Let's see:</p>\n\n<pre><code>fn mk_foo&lt;F&gt;() -&gt; Box&lt;F&gt; where F: Foo {\n    unimplemented!()\n}\n</code></pre>\n\n<p>the signature of mk_foo says that I should be able to call the function with any type that implements Foo. So this should all be valid:</p>\n\n<pre><code>   let a: Box&lt;Vec&lt;f32&gt;&gt; = mk_foo::&lt;Vec&lt;f32&gt;&gt;();\n   let b: Box&lt;u32&gt; = mk_foo::&lt;u32&gt;();\n</code></pre>\n\n<p>i.e. the function, as written, is not returning a trait object. It's promising to return a Box with any concrete type the caller chooses. That's why it's not easy to actually implement the function. It should know how to create several types from nothing.</p>\n"}], "owner": {"reputation": 279, "user_id": 170976, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a206c9e290a5ef53d4cdeaa9f1ef5979?s=128&d=identicon&r=PG", "display_name": "jfager", "link": "https://stackoverflow.com/users/170976/jfager"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1008, "favorite_count": 1, "accepted_answer_id": 27908150, "answer_count": 1, "score": 3, "last_activity_date": 1421154684, "creation_date": 1421081441, "last_edit_date": 1495542140, "question_id": 27906885, "link": "https://stackoverflow.com/questions/27906885/storing-an-unboxed-closure-with-a-reference-arg-in-a-hashmap", "title": "Storing an unboxed closure with a reference arg in a HashMap", "body": "<p>I'm trying to store a closure as a HashMap value.  If I pass the closure arg by value, everything works great:</p>\n\n<pre><code>use std::collections::hash_map::HashMap;\n\nfn main() {\n    let mut cmds: HashMap&lt;String, Box&lt;FnMut(String)-&gt;()&gt;&gt;\n        = HashMap::new();\n\n    cmds.insert(\"ping\".to_string(), Box::new(|&amp;mut:s| { println!(\"{}\", s); }));\n\n    match cmds.get_mut(\"ping\") {\n        Some(f) =&gt; f(\"pong\".to_string()),\n        _ =&gt; ()\n    }\n}\n</code></pre>\n\n<p>(<a href=\"http://is.gd/4ySUke\" rel=\"nofollow noreferrer\">playpen</a>)</p>\n\n<p>But if I want a closure that takes a reference arg, things go south:</p>\n\n<pre><code>use std::collections::hash_map::HashMap;\n\nfn main() {\n    let mut cmds: HashMap&lt;String, Box&lt;FnMut(&amp;str)-&gt;()&gt;&gt;\n        = HashMap::new();\n\n    cmds.insert(\"ping\".to_string(), Box::new(|&amp;mut:s| { println!(\"{}\", s); }));\n\n    match cmds.get_mut(\"ping\") {\n        Some(f) =&gt; f(\"pong\"),\n        _ =&gt; ()\n    }\n}\n\n\n&lt;anon&gt;:8:37: 8:78 error: type mismatch: the type `closure[&lt;anon&gt;:8:46: 8:77]` implements the trait `core::ops::FnMut(_)`, but the trait `for&lt;'r&gt; core::ops::FnMut(&amp;'r str)` is required (expected concrete lifetime, found bound lifetime parameter )\n&lt;anon&gt;:8     cmds.insert(\"ping\".to_string(), Box::new(|&amp;mut:s| { println!(\"{}\", s); }));\n                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n&lt;anon&gt;:8:37: 8:78 note: required for the cast to the object type `for&lt;'r&gt; core::ops::FnMut(&amp;'r str)`\n&lt;anon&gt;:8     cmds.insert(\"ping\".to_string(), Box::new(|&amp;mut:s| { println!(\"{}\", s); }));\n                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\n</code></pre>\n\n<p>(<a href=\"http://is.gd/AKoJJv\" rel=\"nofollow noreferrer\">playpen</a>)</p>\n\n<p>I read the answer to <a href=\"https://stackoverflow.com/questions/27815315/how-to-rewrite-code-to-new-unboxed-closures\">How to rewrite code to new unboxed closures</a>, and tried breaking out the map building into its own function in order to have a place to hang the <code>where</code> clause, but no dice:</p>\n\n<pre><code>use std::collections::hash_map::HashMap;\n\nfn mk_map&lt;F&gt;() -&gt; HashMap&lt;String, (String, Box&lt;F&gt;)&gt;\n    where F: for&lt;'a&gt; FnMut(&amp;'a str) -&gt; ()\n{\n    let mut cmds: HashMap&lt;String, (String, Box&lt;F&gt;)&gt; = HashMap::new();\n    cmds.insert(\"ping\".to_string(), (\"ping\".to_string(), Box::new(|&amp;mut:s| { println!(\"{}\", s); })));\n    cmds\n}   \n\nfn main() {\n    let cmds = mk_map();\n    match cmds.get_mut(\"ping\") {\n        Some(&amp;mut (_, ref mut f)) =&gt; f(\"pong\"),\n        _ =&gt; println!(\"invalid command\")\n    }\n}\n\n\n&lt;anon&gt;:8:58: 8:99 error: mismatched types: expected `Box&lt;F&gt;`, found `Box&lt;closure[&lt;anon&gt;:8:67: 8:98]&gt;` (expected type parameter, found closure)\n&lt;anon&gt;:8     cmds.insert(\"ping\".to_string(), (\"ping\".to_string(), Box::new(|&amp;mut:s| { println!(\"{}\", s); })));\n                                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre>\n\n<p>(<a href=\"http://is.gd/Lau7C9\" rel=\"nofollow noreferrer\">playpen</a>)</p>\n\n<p>What's the right way to do this?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 5869, "user_id": 2543666, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/4e7c6887ce958029525412ab297b5895?s=128&d=identicon&r=PG", "display_name": "Thayne", "link": "https://stackoverflow.com/users/2543666/thayne"}, "edited": false, "score": 4, "creation_date": 1486183828, "post_id": 27905403, "comment_id": 71247309, "body": "What if I own the array, and want to take ownership of a single value in the array (and consume ownership of the array)?"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 3, "creation_date": 1486377863, "post_id": 27905403, "comment_id": 71302983, "body": "if it&#39;s a <code>Vec</code> you can use the <code>remove</code> method, otherwise you can <code>mem::replace</code> the value with a dummy value."}, {"owner": {"reputation": 1350, "user_id": 3220468, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/8bcd5a0e9fc3018d76dd96371281a891?s=128&d=identicon&r=PG", "display_name": "Tom&#225;\u0161 Dvo\u0159&#225;k", "link": "https://stackoverflow.com/users/3220468/tom%c3%a1%c5%a1-dvo%c5%99%c3%a1k"}, "edited": false, "score": 0, "creation_date": 1522437719, "post_id": 27905403, "comment_id": 86168234, "body": "<code>vec.into_iter().nth(1).expect(&quot;Missing element&quot;)</code> works"}, {"owner": {"reputation": 4970, "user_id": 1726797, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a76b9e0b9a393201d9897082bf70bf07?s=128&d=identicon&r=PG", "display_name": "nnnmmm", "link": "https://stackoverflow.com/users/1726797/nnnmmm"}, "edited": false, "score": 0, "creation_date": 1532430324, "post_id": 27905403, "comment_id": 89961835, "body": "A remark: the Index trait looks like it should return a reference, but as this answer states, it does not. See also <a href=\"https://stackoverflow.com/questions/27879161/what-is-the-return-type-of-the-indexing-operation\" title=\"what is the return type of the indexing operation\">stackoverflow.com/questions/27879161/&hellip;</a>"}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": true, "score": 68, "last_activity_date": 1571839668, "last_edit_date": 1571839668, "creation_date": 1421076519, "answer_id": 27905403, "question_id": 27904864, "link": "https://stackoverflow.com/questions/27904864/what-does-cannot-move-out-of-index-of-mean/27905403#27905403", "title": "What does &quot;cannot move out of index of&quot; mean?", "body": "<p>When you use an index operator (<code>[]</code>) you get the actual object at index location. You do not get a reference, pointer or copy. Since you try to bind that object with a <code>let</code> binding, Rust immediately tries to move (or copy, if the <code>Copy</code> trait is implemented).</p>\n\n<p>In your example, <code>env::args()</code> is an iterator of <code>String</code>s which is then collected into a <code>Vec&lt;String&gt;</code>. This is an owned vector of owned strings, and owned strings are not automatically copyable. </p>\n\n<p>You can use a <code>let ref</code> binding, but the more idiomatic alternative is to take a reference to the indexed object (note the <code>&amp;</code> symbol):</p>\n\n<pre><code>use std::env;\n\nfn main() {\n    let args: Vec&lt;_&gt; = env::args().collect();\n    let ref dir = &amp;args[1];\n    //            ^\n}\n</code></pre>\n\n<p>Implicitly moving out of a <code>Vec</code> is not allowed as it would leave it in an invalid state \u2014 one element is moved out, the others are not. If you have a mutable <code>Vec</code>, you can use a method like <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.remove\" rel=\"noreferrer\"><code>Vec::remove</code></a> to take a single value out:</p>\n\n<pre><code>use std::env;\n\nfn main() {\n    let mut args: Vec&lt;_&gt; = env::args().collect();\n    let dir = args.remove(1);\n}\n</code></pre>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/27879161/what-is-the-return-type-of-the-indexing-operation\">What is the return type of the indexing operation?</a></li>\n</ul>\n\n<hr>\n\n<p>For your particular problem, you can also just use <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.nth\" rel=\"noreferrer\"><code>Iterator::nth</code></a>:</p>\n\n<pre><code>use std::env;\n\nfn main() {\n    let dir = env::args().nth(1).expect(\"Missing argument\");\n}\n</code></pre>\n"}], "owner": {"reputation": 48136, "user_id": 161922, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/16e12e337f6edc3750681492656097ed?s=128&d=identicon&r=PG", "display_name": "Rory", "link": "https://stackoverflow.com/users/161922/rory"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 20706, "favorite_count": 6, "accepted_answer_id": 27905403, "answer_count": 1, "score": 67, "last_activity_date": 1571839668, "creation_date": 1421074769, "last_edit_date": 1571839477, "question_id": 27904864, "link": "https://stackoverflow.com/questions/27904864/what-does-cannot-move-out-of-index-of-mean", "title": "What does &quot;cannot move out of index of&quot; mean?", "body": "<p>I am playing with <a href=\"http://www.rust-lang.org/\" rel=\"noreferrer\">Rust</a>, and I'm trying to access the first command line argument with this code:</p>\n\n<pre><code>use std::env;\n\nfn main() {\n    let args: Vec&lt;_&gt; = env::args().collect();\n    let dir = args[1];\n}\n</code></pre>\n\n<p>And I get this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of indexed content\n --&gt; src/main.rs:5:15\n  |\n5 |     let dir = args[1];\n  |         ---   ^^^^^^^ cannot move out of indexed content\n  |         |\n  |         hint: to prevent move, use `ref dir` or `ref mut dir`\n</code></pre>\n\n<p>Or in later versions of Rust:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of index of `std::vec::Vec&lt;std::string::String&gt;`\n --&gt; src/main.rs:5:15\n  |\n5 |     let dir = args[1];\n  |               ^^^^^^^\n  |               |\n  |               move occurs because value has type `std::string::String`, which does not implement the `Copy` trait\n  |               help: consider borrowing here: `&amp;args[1]`\n</code></pre>\n\n<p>If I change it to <code>let ref dir</code>, it compiles, but I don't grok what's going on. Could someone explain what \"indexed content\" means?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 17, "last_activity_date": 1549884428, "last_edit_date": 1549884428, "creation_date": 1421041683, "answer_id": 27896014, "question_id": 27895946, "link": "https://stackoverflow.com/questions/27895946/expected-fn-item-found-a-different-fn-item-when-working-with-function-pointer/27896014#27896014", "title": "&quot;Expected fn item, found a different fn item&quot; when working with function pointers", "body": "<p>Each named function has a distinct type since <a href=\"https://github.com/rust-lang/rust/pull/19891\" rel=\"noreferrer\">Rust PR #19891</a> was merged. You can, however, cast the functions to the corresponding function pointer type with the <code>as</code> operator.</p>\n\n<pre><code>call_both(foo as fn(u32) -&gt; bool, bar as fn(u32) -&gt; bool);\n</code></pre>\n\n<p>It's also valid to cast only the first of the functions: the cast will be inferred on the second, because both functions must have the same type.</p>\n\n<pre><code>call_both(foo as fn(u32) -&gt; bool, bar);\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 53952, "user_id": 2408867, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/994y9.jpg?s=128&g=1", "display_name": "Lukas Kalbertodt", "link": "https://stackoverflow.com/users/2408867/lukas-kalbertodt"}, "is_accepted": false, "score": 13, "last_activity_date": 1549899272, "last_edit_date": 1549899272, "creation_date": 1549885704, "answer_id": 54629954, "question_id": 27895946, "link": "https://stackoverflow.com/questions/27895946/expected-fn-item-found-a-different-fn-item-when-working-with-function-pointer/54629954#54629954", "title": "&quot;Expected fn item, found a different fn item&quot; when working with function pointers", "body": "<h1>Function item vs. function pointer</h1>\n\n<p>When you refer to a function by its name, the type you get is not a function pointer (e.g. <code>fn(u32) -&gt; bool</code>). Instead, you get an a zero-sized value of the function's <em>item type</em> (e.g. <code>fn(u32) -&gt; bool {foo}</code>).</p>\n\n<p>The value is zero-sized because it doesn't store the actual function pointer. The type perfectly identifies the function, so there is no need to store actual data in the type. This has several advantages, mostly about easier optimizations. A function pointer is like you would expect from other languages: it stores an address to the function. </p>\n\n<p><strong>A <em>function pointer</em> refers to the function via stored address; a <em>function item</em> refers to the function via type information.</strong></p>\n\n<p>A function item can be coerced to a function pointer in many situations, for example: as argument to a function and in <code>let _: fn(u32) -&gt; bool = foo;</code> statements. Additionally, you can explicitly cast a function item to a function pointer: <code>foo as fn(u32) -&gt; bool</code>.</p>\n\n<p>You can read more about this topic in the reference on <a href=\"https://doc.rust-lang.org/beta/reference/types/function-item.html\" rel=\"noreferrer\">function items</a>, <a href=\"https://doc.rust-lang.org/beta/reference/types/function-pointer.html\" rel=\"noreferrer\">function pointers</a> and <a href=\"https://doc.rust-lang.org/beta/reference/type-coercions.html\" rel=\"noreferrer\">coercion</a>.</p>\n\n<p><br /></p>\n\n<hr>\n\n<h1>Solution to your problem</h1>\n\n<p>In your case, the compiler isn't smart enough to figure out that you want the function pointers from your <code>foo</code> and <code>bar</code> instead of function items. When you call <code>call_both(foo, bar)</code> the compiler sets the generic type <code>F</code> to be <code>fn(u32) -&gt; bool {foo}</code>, because that's the type of the first argument. And then it complains that the second argument doesn't have the same type.</p>\n\n<p>You can fix that by <strong>explicitly specifying the <code>F</code> parameter</strong>:</p>\n\n<pre><code>call_both::&lt;fn(u32) -&gt; bool&gt;(foo, bar);\ncall_both::&lt;fn(_) -&gt; _&gt;(foo, bar);       // &lt;-- even this works\n</code></pre>\n\n<p>After specifying the type, the compiler can correctly coerce the arguments to a function pointer. You could also <code>as</code>-cast the first argument to <code>fn(u32) -&gt; bool</code> explicitly.</p>\n\n<p>You can fix your second example by explicitly stating the function pointer type, too:</p>\n\n<pre><code>let mut x: fn(u32) -&gt; bool = foo;\nx = bar;\n</code></pre>\n\n<p>In general: <strong>specifying the function pointer type somewhere to trigger the coercion will work</strong>.</p>\n"}], "owner": {"reputation": 435, "user_id": 1606142, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/837e585e17c9927f0bb14ddcc3e67a11?s=128&d=identicon&r=PG", "display_name": "JONNALAGADDA Srinivas", "link": "https://stackoverflow.com/users/1606142/jonnalagadda-srinivas"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3050, "favorite_count": 5, "accepted_answer_id": 27896014, "answer_count": 2, "score": 20, "last_activity_date": 1549899272, "creation_date": 1421041310, "last_edit_date": 1549884272, "question_id": 27895946, "link": "https://stackoverflow.com/questions/27895946/expected-fn-item-found-a-different-fn-item-when-working-with-function-pointer", "title": "&quot;Expected fn item, found a different fn item&quot; when working with function pointers", "body": "<p>I have the following code (<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ab5a19f3ea31260a0e140b3f4e9a315c\" rel=\"noreferrer\">Playground</a>):</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>// Two dummy functions, both with the signature `fn(u32) -&gt; bool`\nfn foo(x: u32) -&gt; bool {\n    x % 2 == 0\n}\nfn bar(x: u32) -&gt; bool {\n    x == 27\n}\n\n\nfn call_both&lt;F&gt;(a: F, b: F)\nwhere\n    F: Fn(u32) -&gt; bool,\n{\n    a(5);\n    b(5);\n}\n\nfn main() {\n    call_both(foo, bar);  // &lt;-- error\n}\n</code></pre>\n\n<p>To me, it seems like this should compile as <code>foo</code> and <code>bar</code> have the same signature: <code>fn(u32) -&gt; bool</code>. Yet, I get the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:20:20\n   |\n20 |     call_both(foo, bar);\n   |                    ^^^ expected fn item, found a different fn item\n   |\n   = note: expected type `fn(u32) -&gt; bool {foo}`\n              found type `fn(u32) -&gt; bool {bar}`\n</code></pre>\n\n<p>The same error can be triggered with this code:</p>\n\n<pre><code>let mut x = foo;\nx = bar;  // &lt;-- error\n</code></pre>\n\n<p>I also tried to cast <code>bar</code> to the function pointer type again:</p>\n\n<pre><code>let mut x = foo;\nx = bar as fn(u32) -&gt; bool;  // &lt;-- error\n</code></pre>\n\n<p>This resulted in a slightly different error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:20:9\n   |\n20 |     x = bar as fn(u32) -&gt; bool;\n   |         ^^^^^^^^^^^^^^^^^^^^^^ expected fn item, found fn pointer\n   |\n   = note: expected type `fn(u32) -&gt; bool {foo}`\n              found type `fn(u32) -&gt; bool`\n</code></pre>\n\n<p>I don't understand these errors at all. <strong>What are fn items vs. fn pointers and why are <code>foo</code> and <code>bar</code> different fn items?</strong></p>\n"}, {"tags": ["string", "rust"], "comments": [{"owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "edited": false, "score": 0, "creation_date": 1421043045, "post_id": 27895150, "comment_id": 44193178, "body": "I think there&#39;s a mistake in your code -- if I read it correctly, it pushes the characters at <code>i</code> and <code>i - 1</code> twice."}], "answers": [{"comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1421127839, "post_id": 27895929, "comment_id": 44229979, "body": "I don&#39;t believe this is correct: you&#39;re dealing with codepoints, not graphemes, which is what you <i>should</i> be.  That is, if you have combining code points, they won&#39;t get swapped with the code point you&#39;re swapping."}, {"owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1421138554, "post_id": 27895929, "comment_id": 44233991, "body": "@DK Good point. I was going to say the standard library doesn&#39;t have a grapheme splitter, but it turns out it does. Noted and edited."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 3, "creation_date": 1421138806, "post_id": 27895929, "comment_id": 44234118, "body": "Impressive edit.  The <i>real</i> problem here is that the original question is completely wrong-headed: if you&#39;re ever doing anything that relies on a concrete concept of a &quot;character&quot;, you&#39;re probably just causing trouble for yourself.  Getting it right is incredibly difficult."}], "tags": [], "owner": {"reputation": 11412, "user_id": 617159, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fc43cf2d76ce0981a21c0e5a817f96f5?s=128&d=identicon&r=PG", "display_name": "Lambda Fairy", "link": "https://stackoverflow.com/users/617159/lambda-fairy"}, "is_accepted": true, "score": 5, "last_activity_date": 1421138303, "last_edit_date": 1421138303, "creation_date": 1421041153, "answer_id": 27895929, "question_id": 27895150, "link": "https://stackoverflow.com/questions/27895150/how-to-swap-two-characters-in-a-string/27895929#27895929", "title": "How to swap two characters in a string?", "body": "<p>Here's a pretty solution:</p>\n\n<pre><code>use std::str::CharRange;\n\nfn swap_chars_at(input_str: &amp;str, i: usize) -&gt; String {\n    // Pre-allocate a string of the correct size\n    let mut swapped = String::with_capacity(input_str.len());\n    // Pluck the previous character\n    let CharRange { ch: prev_ch, next: prev } = input_str.char_range_at_reverse(i);\n    // Pluck the current character\n    let CharRange { ch, next } = input_str.char_range_at(i);\n    // Put them back\n    swapped.push_str(&amp;input_str[..prev]);\n    swapped.push(ch);\n    swapped.push(prev_ch);\n    swapped.push_str(&amp;input_str[next..]);\n    // Done!\n    swapped\n}\n\n#[test]\nfn smoke_test() {\n    let s = swap_chars_at(\"lyra\", 2);\n    assert_eq!(s, \"lrya\");\n}\n\n#[test]\nfn unicode() {\n    // '\u00e7' takes up 2 bytes in UTF-8\n    let s = swap_chars_at(\"\u00e7a va?\", 2);\n    assert_eq!(s, \"a\u00e7 va?\");\n}\n</code></pre>\n\n<p>From the <a href=\"http://doc.rust-lang.org/std/str/trait.StrExt.html#tymethod.char_range_at\" rel=\"nofollow\">documentation</a>:</p>\n\n<ul>\n<li><code>fn char_range_at(&amp;self, start: usize) -&gt; CharRange</code>\n<ul>\n<li>Pluck a character out of a string and return the index of the next character.</li>\n</ul></li>\n<li><code>fn char_range_at_reverse(&amp;self, start: usize) -&gt; CharRange</code>\n<ul>\n<li>Given a byte position and a str, return the previous char and its position.</li>\n</ul></li>\n</ul>\n\n<p>Together, these two methods let us peek backwards and forwards in the string&mdash;which is exactly what we want.</p>\n\n<hr>\n\n<p>But wait, there's more! DK pointed out a corner case with the above code. If the input contains any <a href=\"https://en.wikipedia.org/wiki/Combining_character\" rel=\"nofollow\"><em>combining characters</em></a>, they may become separated from the characters they combine with.</p>\n\n<p>Now, this question is about Rust, not Unicode, so I won't go into the details of <a href=\"http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\" rel=\"nofollow\">how exactly that works</a>. All you need to know for now is that Rust provides <a href=\"http://doc.rust-lang.org/std/str/trait.StrExt.html#tymethod.grapheme_indices\" rel=\"nofollow\">this method</a>:</p>\n\n<ul>\n<li><code>fn grapheme_indices(&amp;self, is_extended: bool) -&gt; GraphemeIndices</code>\n<ul>\n<li>Returns an iterator over the <a href=\"http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\" rel=\"nofollow\">grapheme clusters</a> of self and their byte offsets.</li>\n</ul></li>\n</ul>\n\n<p>With a healthy application of <code>.find()</code> and <code>.rev()</code>, we arrive at this (hopefully) correct solution:</p>\n\n<pre><code>#![allow(unstable)]  // `GraphemeIndices` is unstable\n\nfn swap_graphemes_at(input_str: &amp;str, i: usize) -&gt; String {\n    // Pre-allocate a string of the correct size\n    let mut swapped = String::with_capacity(input_str.len());\n    // Find the grapheme at index i\n    let (_, gr) = input_str.grapheme_indices(true)\n        .find(|&amp;(index, _)| index == i)\n        .expect(\"index does not point to a valid grapheme\");\n    // Find the grapheme just before it\n    let (prev, prev_gr) = input_str.grapheme_indices(true).rev()\n        .find(|&amp;(index, _)| index &lt; i)\n        .expect(\"no graphemes to swap with\");\n    // Put it all back together\n    swapped.push_str(&amp;input_str[..prev]);\n    swapped.push_str(gr);\n    swapped.push_str(prev_gr);\n    swapped.push_str(&amp;input_str[i+gr.len()..]);\n    // Done!\n    swapped\n}\n\n#[test]\nfn combining() {\n    // Ensure that \"c\\u{327}\" is treated as a single unit\n    let s = swap_graphemes_at(\"c\\u{327}a va?\", 3);\n    assert_eq!(s, \"ac\\u{327} va?\");\n}\n</code></pre>\n\n<p>Admittedly it's a bit convoluted. First it iterates through the input, plucking out the grapheme cluster at <code>i</code>. Then it iterates <em>backward</em> (<a href=\"http://doc.rust-lang.org/std/iter/trait.IteratorExt.html#tymethod.rev\" rel=\"nofollow\"><code>.rev()</code></a>) through the input, picking the rightmost cluster with index <code>&lt; i</code> (i.e. the previous cluster). Finally it goes and puts everything back together.</p>\n\n<p>If you're being <em>really</em> pedantic, there are still more special cases to deal with. For example, if the string contains Windows newlines (<code>\"\\r\\n\"</code>), then we probably don't want to swap them around. And in Greek, the letter sigma (\u03c3) is written differently when it's at the end of a word (\u03c2), so a better algorithm should translate between them as necessary. And don't forget those <a href=\"https://en.wikipedia.org/wiki/Bi-directional_text#Unicode\" rel=\"nofollow\">bidirectional control characters</a>...</p>\n\n<p>But for the sake of our sanity, we'll stop here.</p>\n"}], "owner": {"reputation": 299, "user_id": 1944675, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/ac61f7d80e3a86a74f7f963a817b8003?s=128&d=identicon&r=PG", "display_name": "Advecticity", "link": "https://stackoverflow.com/users/1944675/advecticity"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1644, "favorite_count": 0, "accepted_answer_id": 27895929, "answer_count": 1, "score": 7, "last_activity_date": 1421138303, "creation_date": 1421035542, "last_edit_date": 1421108791, "question_id": 27895150, "link": "https://stackoverflow.com/questions/27895150/how-to-swap-two-characters-in-a-string", "title": "How to swap two characters in a string?", "body": "<p>I want to write a function as follows:</p>\n\n<ul>\n<li>Input: String A, int i, 0 &lt; i &lt; len(A)</li>\n<li>Output: String A with character at (i - 1) swapped with character at i.</li>\n</ul>\n\n<p>What is a <em>clean</em> solution that will achieve this? My current solution is:</p>\n\n<pre><code>let mut swapped = input_str[0..i].to_string();\nswapped.push(input_str.char_at(i));\nswapped.push(input_str.char_at(i - 1));\nswapped.push_str(&amp;query[i..input_str.len()]);\n</code></pre>\n\n<p>But that only works for ASCII strings. I can think of other solutions as converting to a vector in UTF-32, swapping there and converting back to a string, but it seems like a lot of extra work.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 85, "user_id": 668968, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cfcd29e23c9e12dc73d368e05176e53b?s=128&d=identicon&r=PG", "display_name": "Antiartificial", "link": "https://stackoverflow.com/users/668968/antiartificial"}, "edited": false, "score": 0, "creation_date": 1421032235, "post_id": 27894657, "comment_id": 44190577, "body": "Thank you very much! This helped clear up a few things in the process. I&#39;m sure I&#39;ll have more questions in the future :)"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 3, "last_activity_date": 1421031066, "creation_date": 1421031066, "answer_id": 27894657, "question_id": 27894600, "link": "https://stackoverflow.com/questions/27894600/how-do-i-return-a-struct-or-anything-more-complicated-than-a-primitive/27894657#27894657", "title": "How do I return a struct or anything more complicated than a primitive?", "body": "<p>The <code>if</code> in <code>challenges3</code> has no <code>else</code> block, so if the condition isn't met, execution continues after the <code>if</code> block. There's nothing there, so the function implicitly returns <code>()</code> at this point. You must also return a <code>Challenger</code> after the <code>if</code> block, or <a href=\"http://doc.rust-lang.org/std/macro.panic!.html\" rel=\"nofollow\"><code>panic!</code></a> to abort the program.</p>\n\n<p>Alternatively, you could change the return type of your function to <code>Option&lt;Challenger&gt;</code>. Return <code>Some(mychallenger)</code> in the <code>if</code> block, and <code>None</code> after the <code>if</code> block:</p>\n\n<pre><code>fn challenges3(text: String) -&gt; Option&lt;Challenger&gt; {\n    let s: String = text;\n    let split: Vec&lt;&amp;str&gt; = s.as_slice().split(' ').collect();\n    if split[4] == \"has\" &amp;&amp; split[5] == \"challenged\" {\n        let mychallenger = Challenger { challenger: split[2].to_string(), defender: split[6].to_string()};\n        return Some(mychallenger);\n    }\n\n    None\n}\n</code></pre>\n\n<p>You can also use <a href=\"http://doc.rust-lang.org/std/result/enum.Result.html\" rel=\"nofollow\"><code>Result</code></a> instead of <a href=\"http://doc.rust-lang.org/std/option/enum.Option.html\" rel=\"nofollow\"><code>Option</code></a> if you want to return some information about the error.</p>\n"}], "owner": {"reputation": 85, "user_id": 668968, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cfcd29e23c9e12dc73d368e05176e53b?s=128&d=identicon&r=PG", "display_name": "Antiartificial", "link": "https://stackoverflow.com/users/668968/antiartificial"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 155, "favorite_count": 0, "accepted_answer_id": 27894657, "answer_count": 1, "score": 2, "last_activity_date": 1421108883, "creation_date": 1421030506, "last_edit_date": 1421108883, "question_id": 27894600, "link": "https://stackoverflow.com/questions/27894600/how-do-i-return-a-struct-or-anything-more-complicated-than-a-primitive", "title": "How do I return a struct or anything more complicated than a primitive?", "body": "<p>I've been tinkering with Rust and I'm a little confused with function return types. As an experiment I'm writing an IRC log parser. I'm familiar with the primitive types, and having functions return those. What about more complex types when returning multiple pieces of data?</p>\n\n<pre><code>/* Log line example from log.txt */\n/* [17:35] &lt;@botname&gt; name1 [460/702] has challenged name2 [224/739] and taken them in combat! */\n\n#[derive(Show)]\nstruct Challenger {\n  challenger: String,\n  defender: String\n}\n\n\nfn main() {\n  let path = Path::new(\"log.txt\");\n  let mut file = BufferedReader::new(File::open(&amp;path));\n  for line in file.lines() {\n      let mut unwrapped_line = line.unwrap();\n      let mut chal = challenges3(unwrapped_line);\n      println!(\"Challenger: {}\", chal.challenger);\n      println!(\"Defender: {}\", chal.defender);\n  }\n}\n\nfn challenges3(text: String)-&gt; Challenger {\n  let s: String = text;\n  let split: Vec&lt;&amp;str&gt; = s.as_slice().split(' ').collect();\n  if(split[4] == \"has\" &amp;&amp; split[5] == \"challenged\") {\n    let mychallenger = Challenger { challenger: split[2].to_string(), defender: split[6].to_string()};\n    return mychallenger;\n  }\n}\n</code></pre>\n\n<p>I realize this code isn't very idiomatic, I'm getting familiar with the language.</p>\n\n<p>I get an error with this code:</p>\n\n<pre><code>\"mismatched types: expected `Challenger`, found `()` (expected struct Challenger, found ())\"\n</code></pre>\n\n<p>How can I return a Struct or a HashMap? Is there a better way to return multiple fields of data?</p>\n"}, {"tags": ["macos", "rust"], "comments": [{"owner": {"reputation": 1187, "user_id": 1137004, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5ebaa8eb2711795cbf1c9cdda773328?s=128&d=identicon&r=PG", "display_name": "kiyomi", "link": "https://stackoverflow.com/users/1137004/kiyomi"}, "edited": false, "score": 5, "creation_date": 1421023385, "post_id": 27893617, "comment_id": 44188849, "body": "<a href=\"https://github.com/servo/rust-cocoa\" rel=\"nofollow noreferrer\">github.com/servo/rust-cocoa</a>"}], "answers": [{"comments": [{"owner": {"reputation": 2589, "user_id": 1186291, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/LlKBe.jpg?s=128&g=1", "display_name": "alfonsodev", "link": "https://stackoverflow.com/users/1186291/alfonsodev"}, "edited": false, "score": 0, "creation_date": 1598443942, "post_id": 28467427, "comment_id": 112459915, "body": "this sounds great! can you point to some examples, articles repositories?  Thank you!"}], "tags": [], "owner": {"reputation": 90851, "user_id": 27009, "user_type": "registered", "accept_rate": 85, "profile_image": "https://www.gravatar.com/avatar/f0a29af415477aa8c498a4f41ffe6640?s=128&d=identicon&r=PG", "display_name": "Kornel", "link": "https://stackoverflow.com/users/27009/kornel"}, "is_accepted": false, "score": 8, "last_activity_date": 1483816000, "last_edit_date": 1483816000, "creation_date": 1423702456, "answer_id": 28467427, "question_id": 27893617, "link": "https://stackoverflow.com/questions/27893617/how-to-write-a-native-mac-os-x-gui-with-rust/28467427#28467427", "title": "How to write a native Mac OS X GUI with Rust?", "body": "<p>GUIs designed in Interface Builder work best if you use bindings, but bindings assume Objective-C. For this reason I'm writing GUI part in Objective-C and core part in Rust.</p>\n\n<p>The two can communicate via an <a href=\"https://github.com/SSheldon/rust-objc\" rel=\"noreferrer\">obj-c library</a> (<a href=\"https://blog.bugsnag.com/building-macos-apps-with-rust/\" rel=\"noreferrer\">article about this</a>), but the languages are quite different, so it's a bit awkward.</p>\n\n<p>Rust can easily generate C-compatible static library which can be linked to an Objective-C program. You can even add Makefile target in Xcode to build the whole thing without leaving Xcode.</p>\n"}], "owner": {"reputation": 3562, "user_id": 207352, "user_type": "registered", "accept_rate": 51, "profile_image": "https://www.gravatar.com/avatar/fa8609ca62438a65a86bcebe95dccbb6?s=128&d=identicon&r=PG", "display_name": "Pavel Vlasov", "link": "https://stackoverflow.com/users/207352/pavel-vlasov"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 5282, "favorite_count": 3, "answer_count": 1, "score": 14, "last_activity_date": 1483816000, "creation_date": 1421021528, "last_edit_date": 1421124891, "question_id": 27893617, "link": "https://stackoverflow.com/questions/27893617/how-to-write-a-native-mac-os-x-gui-with-rust", "title": "How to write a native Mac OS X GUI with Rust?", "body": "<p>I'm going to write a software using Rust:</p>\n\n<ul>\n<li>core written in Rust</li>\n<li>native Mac OS GUI written in Rust (preferably) or other language</li>\n</ul>\n\n<p>Which setup allows that? Is it possible at all?</p>\n\n<p>P.S. I never programmed nor with Rust nor with Cocoa/etc before.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": false, "score": 1, "last_activity_date": 1421021515, "creation_date": 1421021515, "answer_id": 27893614, "question_id": 27893501, "link": "https://stackoverflow.com/questions/27893501/how-to-constrain-the-element-type-of-an-iterator/27893614#27893614", "title": "How to constrain the element type of an iterator?", "body": "<p>You can write <code>I: Iterator&lt;Item = char&gt;</code>. At some point in the future, a <code>where</code> clause like <code>where I::Item == char</code> may work too, but not now.</p>\n"}, {"tags": [], "owner": {"reputation": 389, "user_id": 627303, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c1d80cf5fc097b20250baa26d06c5331?s=128&d=identicon&r=PG", "display_name": "rieux", "link": "https://stackoverflow.com/users/627303/rieux"}, "is_accepted": false, "score": 3, "last_activity_date": 1421021572, "creation_date": 1421021572, "answer_id": 27893622, "question_id": 27893501, "link": "https://stackoverflow.com/questions/27893501/how-to-constrain-the-element-type-of-an-iterator/27893622#27893622", "title": "How to constrain the element type of an iterator?", "body": "<p>Okay, I was able to figure this out from reading some RFC discussions, and the answer is that you can instantiate associated types in the trait (like signature fibration in ML):</p>\n\n<pre><code>fn f&lt;I: Iterator&lt;Item = char&gt;&gt;(char_iter: I)\n</code></pre>\n\n<p>Soon it should be possible to use equality constraints in <code>where</code> clauses, but this doesn\u2019t work in 1.0.0-alpha:</p>\n\n<pre><code>fn f&lt;I: Iterator&gt;(char_iter: I) where I::Item == char\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 6, "last_activity_date": 1421021594, "creation_date": 1421021594, "answer_id": 27893624, "question_id": 27893501, "link": "https://stackoverflow.com/questions/27893501/how-to-constrain-the-element-type-of-an-iterator/27893624#27893624", "title": "How to constrain the element type of an iterator?", "body": "<pre><code>fn f&lt;I: Iterator&lt;Item = char&gt;&gt;(char_iter: I)\n</code></pre>\n\n<p>Associated types were recently added to the language, and many library types were updated to take advantage of them. For example, <a href=\"http://doc.rust-lang.org/std/iter/trait.Iterator.html\" rel=\"noreferrer\"><code>Iterator</code></a> defines one associated type, named <code>Item</code>. You can add a constraint on the associated type by writing the name of the associated type, an equals sign, and the type you need.</p>\n"}], "owner": {"reputation": 389, "user_id": 627303, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c1d80cf5fc097b20250baa26d06c5331?s=128&d=identicon&r=PG", "display_name": "rieux", "link": "https://stackoverflow.com/users/627303/rieux"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 552, "favorite_count": 0, "answer_count": 3, "score": 4, "last_activity_date": 1421108917, "creation_date": 1421020401, "last_edit_date": 1421108917, "question_id": 27893501, "link": "https://stackoverflow.com/questions/27893501/how-to-constrain-the-element-type-of-an-iterator", "title": "How to constrain the element type of an iterator?", "body": "<p>I\u2019m converting some older Rust code to work on 1.0.0. I need to convert a function that takes an iterator over characters, which used to be written like this:</p>\n\n<pre><code> fn f&lt;I: Iterator&lt;char&gt;&gt;(char_iter: I)\n</code></pre>\n\n<p>Now that <code>Iterator</code> doesn\u2019t take a parameter, the constraint on <code>I</code> can only be <code>I: Iterator</code>. The element type is then <code>I::Item</code>. Is there a way to express the constraint that <code>I::Item</code> = <code>char</code>? (Or should I be doing this another way entirely?)</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 27199, "user_id": 427158, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/f706984800b6d136b9331a6ee20c676f?s=128&d=identicon&r=PG", "display_name": "maxschlepzig", "link": "https://stackoverflow.com/users/427158/maxschlepzig"}, "edited": false, "score": 1, "creation_date": 1494152210, "post_id": 32841532, "comment_id": 74697807, "body": "cf. <a href=\"https://doc.rust-lang.org/core/ops/struct.Range.html#method.step_by\" rel=\"nofollow noreferrer\">doc.rust-lang.org/core/ops/struct.Range.html#method.step_by</a> and <a href=\"https://github.com/rust-lang/rust/issues/27741\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/27741</a>"}, {"owner": {"reputation": 2287, "user_id": 5267751, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/bd62e8fd8fbb37abc7e2a39d23828047?s=128&d=identicon&r=PG&f=1", "display_name": "user202729", "link": "https://stackoverflow.com/users/5267751/user202729"}, "edited": false, "score": 0, "creation_date": 1591165770, "post_id": 32841532, "comment_id": 109947872, "body": "Note that this method will not support 64 bit step on machines with 32 bit size type."}], "tags": [], "owner": {"reputation": 3387, "user_id": 816943, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/4bddf57fc73cf2994b85fff9c2ebdcd5?s=128&d=identicon&r=PG", "display_name": "Pill", "link": "https://stackoverflow.com/users/816943/pill"}, "is_accepted": true, "score": 164, "last_activity_date": 1533225414, "last_edit_date": 1533225414, "creation_date": 1443522115, "answer_id": 32841532, "question_id": 27893223, "link": "https://stackoverflow.com/questions/27893223/how-do-i-iterate-over-a-range-with-a-custom-step/32841532#32841532", "title": "How do I iterate over a range with a custom step?", "body": "<p><code>range_step_inclusive</code> and <code>range_step</code> are long gone. </p>\n\n<p>As of Rust 1.28, <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by\" rel=\"noreferrer\"><code>Iterator::step_by</code></a> is stable:</p>\n\n<pre><code>fn main() {\n    for x in (1..10).step_by(2) {\n        println!(\"{}\", x);\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 209014, "user_id": 125816, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f5aa40b1e7a95599c7a19451f88ff3a?s=128&d=identicon&r=PG", "display_name": "Sergio Tulentsev", "link": "https://stackoverflow.com/users/125816/sergio-tulentsev"}, "edited": false, "score": 0, "creation_date": 1614615464, "post_id": 38801170, "comment_id": 117432598, "body": "Why use this over <code>for</code> and <code>step_by</code>?"}], "tags": [], "owner": {"reputation": 1626, "user_id": 159762, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/03896e8a1ac27618c696edb9bb150365?s=128&d=identicon&r=PG", "display_name": "Leigh  McCulloch", "link": "https://stackoverflow.com/users/159762/leigh-mcculloch"}, "is_accepted": false, "score": 2, "last_activity_date": 1470464795, "last_edit_date": 1470464795, "creation_date": 1470464180, "answer_id": 38801170, "question_id": 27893223, "link": "https://stackoverflow.com/questions/27893223/how-do-i-iterate-over-a-range-with-a-custom-step/38801170#38801170", "title": "How do I iterate over a range with a custom step?", "body": "<p>If you are stepping by something predefined, and small like 2, you may wish to use the iterator to step manually. e.g.:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let mut iter = 1..10;\nloop {\n    match iter.next() {\n        Some(x) =&gt; {\n            println!(\"{}\", x);\n        },\n        None =&gt; break,\n    }\n    iter.next();\n}\n</code></pre>\n\n<p>You could even use this to step by an arbitrary amount (although this is definitely getting longer and harder to digest):</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let mut iter = 1..10;\nlet step = 4;\nloop {\n    match iter.next() {\n        Some(x) =&gt; {\n            println!(\"{}\", x);\n        },\n        None =&gt; break,\n    }\n    for _ in 0..step-1 {\n        iter.next();\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 916, "user_id": 2005204, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/477b229d748952ddd7c36c08b6f86dd5?s=128&d=identicon&r=PG&f=1", "display_name": "WDS", "link": "https://stackoverflow.com/users/2005204/wds"}, "edited": false, "score": 0, "creation_date": 1520188666, "post_id": 38988285, "comment_id": 85203129, "body": "Re: inserting &quot;continue&quot; in the loop, one would only do this inside a conditional branch even in the for structure, I think.  If so, then I think it would be OK to increment inside the conditional branch in the while structure before &quot;continue&quot;-ing, and that it would then work as intended.  Or am I overlooking something?"}, {"owner": {"reputation": 2638, "user_id": 7208029, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/QxbAJ.png?s=128&g=1", "display_name": "Chai T. Rex", "link": "https://stackoverflow.com/users/7208029/chai-t-rex"}, "reply_to_user": {"reputation": 916, "user_id": 2005204, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/477b229d748952ddd7c36c08b6f86dd5?s=128&d=identicon&r=PG&f=1", "display_name": "WDS", "link": "https://stackoverflow.com/users/2005204/wds"}, "edited": false, "score": 1, "creation_date": 1570847520, "post_id": 38988285, "comment_id": 103055410, "body": "@WDS that&#39;s counterintuitive busywork to get a basic feature of the language, <code>continue</code>, to work properly. Though it can be done, this design encourages bugs."}], "tags": [], "owner": {"reputation": 647, "user_id": 4037231, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/fe12602a9e9ca343dc477b81e1244b1b?s=128&d=identicon&r=PG&f=1", "display_name": "kmky", "link": "https://stackoverflow.com/users/4037231/kmky"}, "is_accepted": false, "score": 4, "last_activity_date": 1471504532, "last_edit_date": 1471504532, "creation_date": 1471409210, "answer_id": 38988285, "question_id": 27893223, "link": "https://stackoverflow.com/questions/27893223/how-do-i-iterate-over-a-range-with-a-custom-step/38988285#38988285", "title": "How do I iterate over a range with a custom step?", "body": "<p>You'd write your C++ code:</p>\n\n<pre><code>for (auto i = 0; i &lt;= n; i += 2) {\n    //...\n}\n</code></pre>\n\n<p>...in Rust like so:</p>\n\n<pre><code>let mut i = 0;\nwhile i &lt;= n {\n    // ...\n    i += 2;\n}\n</code></pre>\n\n<p>I think the Rust version is more readable too.</p>\n"}, {"comments": [{"owner": {"reputation": 397, "user_id": 4131596, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh4.googleusercontent.com/-dUHeMDfE0xw/AAAAAAAAAAI/AAAAAAAAANE/y-2iUXIrmU4/photo.jpg?sz=128", "display_name": "Ryan", "link": "https://stackoverflow.com/users/4131596/ryan"}, "edited": false, "score": 0, "creation_date": 1494781115, "post_id": 40168843, "comment_id": 74963058, "body": "By adding another type, <code>U</code> to your second option you could use types that support addition with a different type and still yield a <code>T</code>. For instance time and duration come to mind."}, {"owner": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "reply_to_user": {"reputation": 397, "user_id": 4131596, "user_type": "registered", "accept_rate": 100, "profile_image": "https://lh4.googleusercontent.com/-dUHeMDfE0xw/AAAAAAAAAAI/AAAAAAAAANE/y-2iUXIrmU4/photo.jpg?sz=128", "display_name": "Ryan", "link": "https://stackoverflow.com/users/4131596/ryan"}, "edited": false, "score": 0, "creation_date": 1494814934, "post_id": 40168843, "comment_id": 74971342, "body": "@Ryan, that seems like a good idea and should work, with the struct defined as follows:     struct StepRange&lt;T&gt;(T, T, U)     where for&lt;&#39;a, &#39;b&gt; &amp;&#39;a T: Add&lt;&amp;&#39;b U, Output = T&gt;,           T: PartialOrd,           T: Clone; which should allow different lifetimes for the input T and U types."}], "tags": [], "owner": {"reputation": 2987, "user_id": 549617, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/LkpMK.jpg?s=128&g=1", "display_name": "GordonBGood", "link": "https://stackoverflow.com/users/549617/gordonbgood"}, "is_accepted": false, "score": 14, "last_activity_date": 1477228296, "last_edit_date": 1477228296, "creation_date": 1477026616, "answer_id": 40168843, "question_id": 27893223, "link": "https://stackoverflow.com/questions/27893223/how-do-i-iterate-over-a-range-with-a-custom-step/40168843#40168843", "title": "How do I iterate over a range with a custom step?", "body": "<p>It seems to me that until the <code>.step_by</code> method is made stable, one can easily accomplish what you want with an <code>Iterator</code> (which is what <code>Range</code>s really are anyway):</p>\n\n<pre><code>struct SimpleStepRange(isize, isize, isize);  // start, end, and step\n\nimpl Iterator for SimpleStepRange {\n    type Item = isize;\n\n    #[inline]\n    fn next(&amp;mut self) -&gt; Option&lt;isize&gt; {\n        if self.0 &lt; self.1 {\n            let v = self.0;\n            self.0 = v + self.2;\n            Some(v)\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    for i in SimpleStepRange(0, 10, 2) {\n        println!(\"{}\", i);\n    }\n}\n</code></pre>\n\n<p>If one needs to iterate multiple ranges of different types, the code can be made generic as follows:</p>\n\n<pre><code>use std::ops::Add;\n\nstruct StepRange&lt;T&gt;(T, T, T)\n    where for&lt;'a&gt; &amp;'a T: Add&lt;&amp;'a T, Output = T&gt;,\n          T: PartialOrd,\n          T: Clone;\n\nimpl&lt;T&gt; Iterator for StepRange&lt;T&gt;\n    where for&lt;'a&gt; &amp;'a T: Add&lt;&amp;'a T, Output = T&gt;,\n          T: PartialOrd,\n          T: Clone\n{\n    type Item = T;\n\n    #[inline]\n    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {\n        if self.0 &lt; self.1 {\n            let v = self.0.clone();\n            self.0 = &amp;v + &amp;self.2;\n            Some(v)\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    for i in StepRange(0u64, 10u64, 2u64) {\n        println!(\"{}\", i);\n    }\n}\n</code></pre>\n\n<p>I'll leave it to you to eliminate the upper bounds check to create an open ended structure if an infinite loop is required...</p>\n\n<p>Advantages of this approach is that is works with <code>for</code> sugaring and will continue to work even when unstable features become usable; also, unlike the de-sugared approach using the standard <code>Range</code>s, it doesn't lose efficiency by multiple <code>.next()</code> calls. Disadvantages are that it takes a few lines of code to set up the iterator so may only be worth it for code that has a lot of loops.</p>\n"}, {"tags": [], "owner": {"reputation": 4690, "user_id": 2019549, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/900a3735d55a0473c975ba9266bf0c68?s=128&d=identicon&r=PG", "display_name": "cambunctious", "link": "https://stackoverflow.com/users/2019549/cambunctious"}, "is_accepted": false, "score": 4, "last_activity_date": 1491624945, "last_edit_date": 1491624945, "creation_date": 1491618532, "answer_id": 43289519, "question_id": 27893223, "link": "https://stackoverflow.com/questions/27893223/how-do-i-iterate-over-a-range-with-a-custom-step/43289519#43289519", "title": "How do I iterate over a range with a custom step?", "body": "<p>Use the <a href=\"https://crates.io/crates/num\" rel=\"nofollow noreferrer\">num</a> crate with <a href=\"http://rust-num.github.io/num/num_iter/fn.range_step.html\" rel=\"nofollow noreferrer\">range_step</a></p>\n"}], "owner": {"reputation": 15257, "user_id": 1409312, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/4TCzB.jpg?s=128&g=1", "display_name": "Syntactic Fructose", "link": "https://stackoverflow.com/users/1409312/syntactic-fructose"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 47682, "favorite_count": 12, "accepted_answer_id": 32841532, "answer_count": 5, "score": 115, "last_activity_date": 1533225414, "creation_date": 1421018098, "last_edit_date": 1511028280, "question_id": 27893223, "link": "https://stackoverflow.com/questions/27893223/how-do-i-iterate-over-a-range-with-a-custom-step", "title": "How do I iterate over a range with a custom step?", "body": "<p>How can I iterate over a range in Rust with a step other than 1? I'm coming from a C++ background so I'd like to do something like</p>\n\n<pre><code>for(auto i = 0; i &lt;= n; i+=2) {\n    //...\n}\n</code></pre>\n\n<p>In Rust I need to use the <code>range</code> function, and it doesn't seem like there is a third argument available for having a custom step. How can I accomplish this?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1421155200, "post_id": 27892375, "comment_id": 44243129, "body": "Are you sure that you need downcasting (it should be avoided as much as possible)? If you control either <code>Trait</code> or <code>Foo</code>, you could most probably avoid it."}, {"owner": {"reputation": 1743, "user_id": 398021, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a5a39b5f9de50200406c7a209ff7a121?s=128&d=identicon&r=PG", "display_name": "goertzenator", "link": "https://stackoverflow.com/users/398021/goertzenator"}, "edited": false, "score": 0, "creation_date": 1462457693, "post_id": 27892375, "comment_id": 61653002, "body": "This seems like the scenario that <code>Enum</code>s where made for."}, {"owner": {"reputation": 725, "user_id": 156459, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/e944b56331602c572d23b47243dca582?s=128&d=identicon&r=PG", "display_name": "thamurath", "link": "https://stackoverflow.com/users/156459/thamurath"}, "reply_to_user": {"reputation": 1743, "user_id": 398021, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/a5a39b5f9de50200406c7a209ff7a121?s=128&d=identicon&r=PG", "display_name": "goertzenator", "link": "https://stackoverflow.com/users/398021/goertzenator"}, "edited": false, "score": 0, "creation_date": 1501703900, "post_id": 27892375, "comment_id": 77900807, "body": "@goertzenator would you please provide an example? I am facing almost the same problem and do not understand how to use enums properly to solve this problem. Thanks in advance"}], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 9, "last_activity_date": 1421013568, "creation_date": 1421013568, "answer_id": 27892569, "question_id": 27892375, "link": "https://stackoverflow.com/questions/27892375/can-i-do-type-introspection-with-trait-objects-and-then-downcast-it/27892569#27892569", "title": "Can I do type introspection with trait objects and then downcast it?", "body": "<p>As you have noticed, downcasting only works with <code>Any</code> trait, and yes, it only supports <code>'static</code> data. You can find a recent discussion on why it is so <a href=\"http://www.reddit.com/r/rust/comments/2r25rf/why_does_any_only_work_for_t_static/\">here</a>. Basically, implementing reflection for references of arbitrary lifetimes is difficult.</p>\n\n<p>It is also impossible (as of now, at least) to combine <code>Any</code> with your custom trait easily. However, a <a href=\"https://github.com/chris-morgan/mopa\">macro library</a> for automatic implementation of <code>Any</code> for your trait has recently been created. You can also find some discussion on it <a href=\"http://www.reddit.com/r/rust/comments/2ricdw/mopa_my_own_personal_any_a_macro_to_implement_all/\">here</a>.</p>\n"}, {"tags": [], "owner": {"reputation": 17608, "user_id": 3650362, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Fqdi1.jpg?s=128&g=1", "display_name": "trentcl", "link": "https://stackoverflow.com/users/3650362/trentcl"}, "is_accepted": false, "score": 4, "last_activity_date": 1512440246, "last_edit_date": 1512440246, "creation_date": 1512423114, "answer_id": 47642317, "question_id": 27892375, "link": "https://stackoverflow.com/questions/27892375/can-i-do-type-introspection-with-trait-objects-and-then-downcast-it/47642317#47642317", "title": "Can I do type introspection with trait objects and then downcast it?", "body": "<p>This isn't a Rust-specific problem, although the vocabulary may be a little different. The ideal way to solve a problem like this, not just with traits in Rust but in any language, is to add the desired behavior (<code>foo_method</code> in your example) to the abstract interface (<code>Trait</code>):</p>\n\n<pre><code>trait Trait {\n    fn trait_method(&amp;self);\n    fn foo_method(&amp;self) {} // does nothing by default\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn trait_method(&amp;self) {\n        println!(\"In trait_method of Foo\");\n    }\n\n    fn foo_method(&amp;self) { // override default behavior\n        println!(\"In foo_method\");\n    }\n}\n\nstruct Bar;\n\nimpl Trait for Bar {\n    fn trait_method(&amp;self) {\n        println!(\"In trait_method of Bar\");\n    }\n}\n\nfn main() {\n    let vec: Vec&lt;Box&lt;Trait&gt;&gt; = vec![Box::new(Foo), Box::new(Bar)];\n\n    for e in &amp;vec {\n        e.trait_method();\n        e.foo_method();\n    }\n}\n</code></pre>\n\n<p>In this example, I have put a default implementation of <code>foo_method</code> in <code>Trait</code> which does nothing, so that you don't have to define it in every <code>impl</code> but only the one(s) where it applies. You should <em>really</em> attempt to make the above work before you resort to downcasting to a concrete type, which has serious drawbacks that all but erase the advantages of having trait objects in the first place.</p>\n\n<p>That said, there are cases where downcasting may be necessary, and Rust does support it -- although the interface is a little clunky. You can downcast <code>&amp;Trait</code> to <code>&amp;Foo</code> by adding an intermediate <em>up</em>cast to <code>&amp;Any</code>:</p>\n\n<pre><code>use std::any::Any;\n\ntrait Trait {\n    fn as_any(&amp;self) -&gt; &amp;Any;\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn as_any(&amp;self) -&gt; &amp;Any {\n        self\n    }\n}\n\nfn downcast&lt;T: Trait + 'static&gt;(this: &amp;Trait) -&gt; Option&lt;&amp;T&gt; {\n    this.as_any().downcast_ref()\n}\n</code></pre>\n\n<p><code>as_any</code> has to be a method in <code>Trait</code> because it needs access to the concrete type. Now you can attempt to call <code>Foo</code> methods on a <code>Trait</code> trait object like this (<a href=\"https://play.rust-lang.org/?gist=0e8e91cf4f167a968832c0230cf8d14c&amp;version=stable\" rel=\"nofollow noreferrer\">complete playground example</a>):</p>\n\n<pre><code>if let Some(r) = downcast::&lt;Foo&gt;(trait_object_ref) {\n    r.foo_method();\n}\n</code></pre>\n\n<p>To make this work, you have to specify what type you expect (<code>::&lt;Foo&gt;</code>) and use <code>if let</code> to handle what happens when the referenced object is not an instance of <code>Foo</code>. You can't downcast a trait object to a concrete type unless you know exactly <em>what</em> concrete type it is.</p>\n\n<p>But if you ever need to know the concrete type, trait objects are almost useless anyway! You probably should use an <code>enum</code> instead, so that you will get compile-time errors if you omit to handle a variant somewhere. Furthermore, you can't use <code>Any</code> with non-<code>'static</code> structs, so if any <code>Foo</code> might need to contain a reference, this design is a dead end. The best solution, if you can do it, is to add <code>foo_method</code> to the trait itself.</p>\n"}], "owner": {"reputation": 653, "user_id": 2051092, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/6eabdb0f0b8be9a8fef78646df1a392a?s=128&d=identicon&r=PG", "display_name": "GGalizzi", "link": "https://stackoverflow.com/users/2051092/ggalizzi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3792, "favorite_count": 1, "accepted_answer_id": 27892569, "answer_count": 2, "score": 13, "last_activity_date": 1512440246, "creation_date": 1421012100, "question_id": 27892375, "link": "https://stackoverflow.com/questions/27892375/can-i-do-type-introspection-with-trait-objects-and-then-downcast-it", "title": "Can I do type introspection with trait objects and then downcast it?", "body": "<p>I have a collection of <code>Trait</code>, a function that iterates over it and does something, and then I would like to check the implementor type and if it is of type <code>Foo</code> then downcast it and call some Foo method.</p>\n\n<p>Basically, something similar to Go's <a href=\"https://golang.org/doc/effective_go.html#type_switch\" rel=\"noreferrer\">type-switch</a> and <a href=\"https://golang.org/doc/effective_go.html#interface_conversions\" rel=\"noreferrer\">interface conversion</a>.</p>\n\n<p>Searching around I found about the <a href=\"http://doc.rust-lang.org/core/any/index.html\" rel=\"noreferrer\">Any trait</a> but it can only be implemented on <code>'static</code> types.</p>\n\n<p>To help demonstrate what I want:</p>\n\n<pre><code>let vec: Vec&lt;Box&lt;Trait&gt;&gt; = //\n\nfor e in vec.iter() {\n    e.trait_method();\n\n    // if typeof e == Foo {\n    // let f = e as Foo;\n    // f.foo_method();\n    //}\n}\n</code></pre>\n"}, {"tags": ["rust", "lifetime"], "answers": [{"comments": [{"owner": {"reputation": 26058, "user_id": 1385039, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/0acb8a6c848d39aa53d94bd81239b034?s=128&d=identicon&r=PG", "display_name": "Michael Ekstrand", "link": "https://stackoverflow.com/users/1385039/michael-ekstrand"}, "edited": false, "score": 0, "creation_date": 1421033407, "post_id": 27892178, "comment_id": 44190785, "body": "Thanks! With this design, the test function I wrote with bad lifetime is now correctly rejected by the compiler."}, {"owner": {"reputation": 1079, "user_id": 1078465, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c39968962a7062a69d24cdd78236a12b?s=128&d=identicon&r=PG", "display_name": "cbarrick", "link": "https://stackoverflow.com/users/1078465/cbarrick"}, "edited": false, "score": 1, "creation_date": 1542930768, "post_id": 27892178, "comment_id": 93751945, "body": "This is outdated, but the general pattern works. Now <code>&amp;&#39;a T</code> and <code>&amp;&#39;a mut T</code> are always covariant over <code>&#39;a</code>, so <code>std::marker::ContravariantLifetime</code> no longer exists. But you must use any type parameters you declare, so you now need to use <code>std::marker::PhantomData</code>."}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 7, "last_activity_date": 1616885200, "last_edit_date": 1616885200, "creation_date": 1421010838, "answer_id": 27892178, "question_id": 27891795, "link": "https://stackoverflow.com/questions/27891795/how-can-i-constrain-the-lifetime-of-a-struct-to-that-of-a-parent-struct/27892178#27892178", "title": "How can I constrain the lifetime of a struct to that of a &#39;parent&#39; struct?", "body": "<p>When you want to bind the lifetime of an input parameter to the lifetime of the return value, you need to define a lifetime parameter on your function and reference it in the types of your input parameter and return value. You can give any name you want to this lifetime parameter; often, when there are few parameters, we just name them <code>'a</code>, <code>'b</code>, <code>'c</code>, etc.</p>\n<p>Your <code>Db</code> type takes a lifetime parameter, but it shouldn't: a <code>Db</code> doesn't reference an existing object, so it has no lifetime constraints.</p>\n<p>To correctly force the <code>Db</code> to outlive the <code>Query</code>, we must write <code>'a</code> on the borrowed pointer, rather than on the lifetime parameter on <code>Db</code> that we just removed.</p>\n<pre><code>pub fn create_query&lt;'a&gt;(db: &amp;'a Db, query_string: &amp;str) -&gt; Query&lt;'a&gt;\n</code></pre>\n<p>However, that's not enough. If your newtypes don't reference their <code>'a</code> parameter at all, you'll find that a <code>Query</code> can actually outlive a <code>Db</code>:</p>\n<blockquote>\n<p><strong>Editor's note:</strong> This code no longer compiles since Rust 1.0. You must use <code>'a</code> in some way in the body of <code>Query</code>.</p>\n<pre><code>struct Db(*mut ());\nstruct Query&lt;'a&gt;(*mut ());  // '\n\nfn create_query&lt;'a&gt;(db: &amp;'a Db, query_string: &amp;str) -&gt; Query&lt;'a&gt; {  // '\n    Query(0 as *mut ())\n}\n\nfn main() {\n    let query;\n    {\n        let db = Db(0 as *mut ());\n        let q = create_query(&amp;db, &quot;&quot;);\n        query = q; // shouldn't compile!\n    }\n}\n</code></pre>\n</blockquote>\n<p>That's because, before Rust 1.0, lifetime parameters are <strong>bivariant</strong>, i.e. the compiler may substitute the parameter with a longer <em>or</em> a shorter lifetime in order to meet the caller's requirements.</p>\n<p>When you store a borrowed pointer in a struct, the lifetime parameter is treated as <strong>covariant</strong>: that means the compiler may substitute the parameter with a shorter lifetime, but not with a longer lifetime.</p>\n<p>We can ask the compiler to treat your lifetime parameter as covariant manually by adding a <code>PhantomData</code> marker to our struct:</p>\n<pre><code>use std::marker::PhantomData;\n\nstruct Db(*mut ());\nstruct Query&lt;'a&gt;(*mut (), PhantomData&lt;&amp;'a ()&gt;);\n\nfn create_query&lt;'a&gt;(db: &amp;'a Db, query_string: &amp;str) -&gt; Query&lt;'a&gt; {    // '\n    Query(0 as *mut (), PhantomData)\n}\n\nfn main() {\n    let query;\n    {\n        let db = Db(0 as *mut ());\n        let q = create_query(&amp;db, &quot;&quot;); // error: `db` does not live long enough\n        query = q;\n    }\n}\n</code></pre>\n<p>Now, the compiler correctly rejects the assignment to <code>query</code>, which outlives <code>db</code>.</p>\n<hr />\n<p><em>Bonus:</em> If we change <code>create_query</code> to be a method of <code>Db</code>, rather than a free function, we can take advantage of the compiler's lifetime inference rules and not write <code>'a</code> at all on <code>create_query</code>:</p>\n<pre><code>use std::marker::PhantomData;\n\nstruct Db(*mut ());\nstruct Query&lt;'a&gt;(*mut (), PhantomData&lt;&amp;'a ()&gt;);\n\nimpl Db {\n    //fn create_query&lt;'a&gt;(&amp;'a self, query_string: &amp;str) -&gt; Query&lt;'a&gt;\n    fn create_query(&amp;self, query_string: &amp;str) -&gt; Query {\n        Query(0 as *mut (), PhantomData)\n    }\n}\n\nfn main() {\n    let query;\n    {\n        let db = Db(0 as *mut ());\n        let q = db.create_query(&quot;&quot;); // error: `db` does not live long enough\n        query = q;\n    }\n}\n</code></pre>\n<p>When a method has a <code>self</code> parameter, the compiler will prefer linking the lifetime of that parameter with the result, even if there are other parameters with lifetimes. For free functions though, inference is only possible if only one parameter has a lifetime. Here, because of the <code>query_string</code> parameter, which is of type <code>&amp;'a str</code>, there are 2 parameters with a lifetime, so the compiler cannot infer which parameter we want to link the result with.</p>\n"}], "owner": {"reputation": 26058, "user_id": 1385039, "user_type": "registered", "accept_rate": 74, "profile_image": "https://www.gravatar.com/avatar/0acb8a6c848d39aa53d94bd81239b034?s=128&d=identicon&r=PG", "display_name": "Michael Ekstrand", "link": "https://stackoverflow.com/users/1385039/michael-ekstrand"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 934, "favorite_count": 1, "accepted_answer_id": 27892178, "answer_count": 1, "score": 7, "last_activity_date": 1616885200, "creation_date": 1421008533, "question_id": 27891795, "link": "https://stackoverflow.com/questions/27891795/how-can-i-constrain-the-lifetime-of-a-struct-to-that-of-a-parent-struct", "title": "How can I constrain the lifetime of a struct to that of a &#39;parent&#39; struct?", "body": "<p>I am using the FFI to write some Rust code against a C API with strong notions of ownership (the <a href=\"http://notmuchmail.org/\" rel=\"noreferrer\">libnotmuch</a> API, if that matters).</p>\n\n<p>The main entry point to the API is a Database; I can create Query objects from the Database.  It provides destructor functions for databases and queries (and a lot of other objects).</p>\n\n<p>However, a Query cannot outlive the Database from which it was created.  The database destructor function will destroy any undestroyed queries, etc., after which the query destructors don't work.</p>\n\n<p>So far, I have the basic pieces working - I can create databases and queries, and do operations on them.  But I am having difficulty encoding the lifetime bounds.</p>\n\n<p>I'm trying to do something like this:</p>\n\n<pre><code>struct Db&lt;'a&gt;(...) // newtype wrapping an opaque DB pointer\nstruct Query&lt;'a&gt;(...) // newtype wrapping an opaque query pointer\n</code></pre>\n\n<p>I have implementations of <code>Drop</code> for each of these that call the underlying C destructor functions.</p>\n\n<p>And then have a function that creates a query:</p>\n\n<pre><code>pub fun create_query&lt;?&gt;(db: &amp;Db&lt;?&gt;, query_string: &amp;str) -&gt; Query&lt;?&gt;\n</code></pre>\n\n<p>I do not know what to put in place of the <code>?</code>s so that the Query returned is not allowed to outlive the Db.</p>\n\n<p>How can I model the lifetime constraints for this API?</p>\n"}, {"tags": ["types", "closures", "rust"], "answers": [{"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1421002329, "post_id": 27890763, "comment_id": 44182423, "body": "BTW, to lessen the boilerplate you can write <code>Box&lt;FnMut() -&gt; IoResult&lt;u32&gt;&gt;</code> only once: <code>let mut fun: Box&lt;FnMut() -&gt; IoRsult&lt;u32&gt;&gt; = ...</code> and then omit <code>as</code> casts."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1421002462, "post_id": 27890763, "comment_id": 44182464, "body": "Ideally such thing wouldn&#39;t require boxing and heap allocation. Stack-based closures would be more than enough, as old closures demonstrate it. However, I couldn&#39;t find a proper way to conditionally construct different <code>&amp;mut</code>-based trait objects :("}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1421002496, "post_id": 27890763, "comment_id": 44182474, "body": "@VladimirMatveev thanks! I got bit by a compiler bug before where that <a href=\"https://github.com/rust-lang/rust/issues/20097\" rel=\"nofollow noreferrer\">caused an ICE</a>. Maybe it&#39;s fixed now!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1421002538, "post_id": 27890763, "comment_id": 44182483, "body": "@VladimirMatveev I was trying the exact same thing... <code>file</code> gets borrowed multiple times."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1421002606, "post_id": 27890763, "comment_id": 44182520, "body": "Yeah, and if they are created in branches themselves they are destroyed too soon..."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 0, "last_activity_date": 1421002138, "creation_date": 1421002138, "answer_id": 27890763, "question_id": 27890435, "link": "https://stackoverflow.com/questions/27890435/assigning-an-unboxed-closure-from-an-if-statement/27890763#27890763", "title": "Assigning an unboxed closure from an if statement", "body": "<p>Previously, closures would be automatically <em>boxed</em>, but now we have <em>unboxed closures</em>. This is a good thing from an efficiency perspective!</p>\n\n<p>However, in your case, you want to have a binding that implements a trait but we don't care about the actual type of the variable. In this case, the trait is <code>FnMut</code>, and the concrete types are automatically generated types, unique to each closure. To do this, we need to have a <em>trait object</em> (like <code>&amp;Trait</code> or <code>Box&lt;Trait&gt;</code>). Here's an example where we re-box the unboxed closures, creating trait objects:</p>\n\n<pre><code>use std::io::{File,IoResult};\nuse std::iter::range_step;\n\nfn main() {\n    let path = Path::new(\"fid\");\n    let mut file = File::open(&amp;path);\n    let big = true;\n    let mut fun: Box&lt;FnMut() -&gt; IoResult&lt;u32&gt;&gt; = if big {\n        Box::new(|&amp;mut:| file.read_be_u32())\n    } else {\n        Box::new(|&amp;mut:| file.read_le_u32())\n    };\n\n    println!(\"{:?}\", fun())\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1421010313, "post_id": 27891887, "comment_id": 44185245, "body": "Nice! My train of though stopped on one uninitialized variable (which obviously won&#39;t work) and refused to go further :)"}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1421010916, "post_id": 27891887, "comment_id": 44185463, "body": "Yeah, we need 2 different variables, because we have 2 closures with 2 different types! This trick can also be used with other traits in general, not just with closures."}, {"owner": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "edited": false, "score": 0, "creation_date": 1421012631, "post_id": 27891887, "comment_id": 44186022, "body": "Nice, but since I don&#39;t see any negative side effects from the boxed version, I&#39;ll stick with that."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "edited": false, "score": 1, "creation_date": 1421037419, "post_id": 27891887, "comment_id": 44191643, "body": "@CamdenNarzt: this is a slightly more efficient form as it doesn\u2019t involve a dynamic allocation. It takes a little more stack space, but avoids an allocation. When it comes to micro-optimisation, this is the place to be \u263a"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 4, "last_activity_date": 1421009124, "last_edit_date": 1495539824, "creation_date": 1421009124, "answer_id": 27891887, "question_id": 27890435, "link": "https://stackoverflow.com/questions/27890435/assigning-an-unboxed-closure-from-an-if-statement/27891887#27891887", "title": "Assigning an unboxed closure from an if statement", "body": "<p>Here's <a href=\"https://stackoverflow.com/a/27890763/234590\">Shepmaster's answer</a> without <code>Box</code>:</p>\n\n<pre><code>use std::io::{File,IoResult};\nuse std::iter::range_step;\n\nfn main() {\n    let path = Path::new(\"fid\");\n    let mut file = File::open(&amp;path);\n    let big = true;\n    let mut fun_be;\n    let mut fun_le;\n    let mut fun: &amp;mut FnMut() -&gt; IoResult&lt;u32&gt; = if big {\n        fun_be = |&amp;mut:| file.read_be_u32();\n        &amp;mut fun_be as &amp;mut FnMut() -&gt; _\n    } else {\n        fun_le = |&amp;mut:| file.read_le_u32();\n        &amp;mut fun_le as &amp;mut FnMut() -&gt; _\n    };\n\n    println!(\"{:?}\", fun())\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "edited": false, "score": 0, "creation_date": 1421118922, "post_id": 27895499, "comment_id": 44227936, "body": "For anyone who like me misses it the first time: as shown in the answer snippet you can pass the object a method is targeting to the method in this manner, and that&#39;s why the closure isn&#39;t necessary."}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 2, "last_activity_date": 1421043898, "last_edit_date": 1421043898, "creation_date": 1421038418, "answer_id": 27895499, "question_id": 27890435, "link": "https://stackoverflow.com/questions/27890435/assigning-an-unboxed-closure-from-an-if-statement/27895499#27895499", "title": "Assigning an unboxed closure from an if statement", "body": "<p>Where you are dealing with pre-existing functions, you don\u2019t actually need closures at all; you can work directly with the functions, like this:</p>\n\n<pre><code>use std::io::{File,IoResult};\nuse std::iter::range_step;\n\nfn main() {\n    let path = Path::new(\"fid\");\n    let mut file = File::open(&amp;path);\n    let big = true;\n    let fun: fn(_) -&gt; _ = if big {\n        Reader::read_be_u32\n    } else {\n        Reader::read_le_u32\n    };\n\n    println!(\"{:?}\", fun(&amp;mut file))\n}\n</code></pre>\n\n<p>(The <code>: fn(_) -&gt; _</code> is, alas, necessary. I\u2019m not sure whether it will become unnecessary at some point or not.)</p>\n"}], "owner": {"reputation": 2340, "user_id": 2250791, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/e72d4f734d39c777f543025d36d4de4e?s=128&d=identicon&r=PG", "display_name": "Camden Narzt", "link": "https://stackoverflow.com/users/2250791/camden-narzt"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 334, "favorite_count": 0, "accepted_answer_id": 27895499, "answer_count": 3, "score": 1, "last_activity_date": 1421043898, "creation_date": 1421000156, "last_edit_date": 1495541667, "question_id": 27890435, "link": "https://stackoverflow.com/questions/27890435/assigning-an-unboxed-closure-from-an-if-statement", "title": "Assigning an unboxed closure from an if statement", "body": "<p>I'm trying to update my code for Rust 1.0.alpha, and one section I am having trouble with can be reduced to the below example. I already annotated the closure type, and switched to unboxed closures. However I can't find the correct type for fun. I tried <code>fun : FnMut() -&gt; IoResult&lt;u32&gt;</code> but even though the whole point of FnMut, FnOnce, and friends is to provide traits for closures to fulfill; the compiler can't seem to match the types properly.</p>\n\n<p>I've read the following:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/27874683/types-of-unboxed-closures-being-unique-to-each\">Types of unboxed closures being unique to each</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27867765/error-message-with-unboxed-closures\">Error message with unboxed closures</a></li>\n<li><a href=\"http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/\" rel=\"nofollow noreferrer\">http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/</a></li>\n</ul>\n\n<p>but they don't explain clearly how to deal with this issue</p>\n\n<pre><code>use std::io::File;\nuse std::io::IoResult;\nuse std::io::fs::PathExtensions;\nuse std::iter::range_step;\n\nfn main() {\n    let path = Path::new(\"fid\");\n    let mut file = File::open(&amp;path);\n    let big = true;\n    let mut v = vec![];\n    let fun = if big {\n        |&amp;mut:| file.read_be_u32()\n    } else {\n        |&amp;mut:| file.read_le_u32()\n    };\n    for _ in range_step(0u64, path.stat().unwrap().size,4u64){\n        v.push(fun().unwrap());\n    }\n    println!(\"{}\",v);\n}\n</code></pre>\n\n<p>This gives:</p>\n\n<pre><code>scratch.rs:11:15: 15:6 error: if and else have incompatible types: expected `closure[scratch.rs:12:9: 12:35]`, found `closure[scratch.rs:14:9: 14:35]` (expected closure, found a different closure)\n</code></pre>\n\n<p>and using <code>fun : FnMut() -&gt; IoResult&lt;u32&gt;</code> or <code>fun : FnMut&lt;(),IoResult&lt;u32&gt;&gt;</code> gives:</p>\n\n<pre><code>scratch.rs:12:9: 12:35 error: mismatched types: expected `core::ops::FnMut() -&gt; core::result::Result&lt;u32, std::io::IoError&gt;`, found `closure[scratch.rs:12:9: 12:35]` (expected trait core::ops::FnMut, found closure)\nscratch.rs:12         |&amp;mut:| file.read_be_u32()\n                      ^~~~~~~~~~~~~~~~~~~~~~~~~~\nscratch.rs:14:9: 14:35 error: mismatched types: expected `core::ops::FnMut() -&gt; core::result::Result&lt;u32, std::io::IoError&gt;`, found `closure[scratch.rs:14:9: 14:35]` (expected trait core::ops::FnMut, found closure)\nscratch.rs:14         |&amp;mut:| file.read_le_u32()\n                      ^~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1420988016, "post_id": 27888069, "comment_id": 44177643, "body": "possible duplicate of <a href=\"http://stackoverflow.com/questions/20342436/rust-invoke-trait-method-on-generic-type-parameter\">Rust invoke trait method on generic type parameter</a>"}], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1420987991, "post_id": 27888168, "comment_id": 44177636, "body": "AH, I had missed part of the solution; well, let&#39;s vote to close this one then :x"}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": false, "score": 1, "last_activity_date": 1420986628, "creation_date": 1420986628, "answer_id": 27888168, "question_id": 27888069, "link": "https://stackoverflow.com/questions/27888069/working-around-the-lack-of-associated-method-on-parametric-traits/27888168#27888168", "title": "Working around the lack of associated method on parametric traits?", "body": "<p>The work-around with a dummy parameter to specify <code>Self</code>, given in your first link seems to work; adjusting to:</p>\n\n<pre><code>fn static_call&lt;'a&gt;(t: &amp;'a T, _unused: Option&lt;Self&gt;) -&gt; &amp;'a T;\n\n// ...\n\n    Parameterized::static_call(t, None::&lt;P&gt;)\n</code></pre>\n\n<p>compiles fines for me.</p>\n\n<p>(Incidentally this looks like a situation where associated types, <code>trait Parameterized { type T;</code> may be useful, but it doesn't resolve this problem and may be completely different from your real, non-reduced code.)</p>\n"}], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 266, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1420986628, "creation_date": 1420985884, "last_edit_date": 1495540664, "question_id": 27888069, "link": "https://stackoverflow.com/questions/27888069/working-around-the-lack-of-associated-method-on-parametric-traits", "title": "Working around the lack of associated method on parametric traits?", "body": "<p>Note: I am aware of <a href=\"https://stackoverflow.com/questions/20342436/rust-invoke-trait-method-on-generic-type-parameter\">Rust invoke trait method on generic type parameter</a>, unfortunately the work around described there does not seem to work for me, probably because my trait is parametric.</p>\n\n<hr>\n\n<p>I tried to implement a <em>parameterized</em> trait with an associated method:</p>\n\n<pre><code>trait Parameterized&lt;T&gt; {\n    fn static_call&lt;'a&gt;(t: &amp;'a T) -&gt; &amp;'a T;\n}\n\nstruct Foo;\n\nimpl Parameterized&lt;u32&gt; for Foo {\n    fn static_call&lt;'a&gt;(t: &amp;'a u32) -&gt; &amp;'a u32 { t }\n}\n</code></pre>\n\n<p>The goal of course is afterward to use such method:</p>\n\n<pre><code>struct PP&lt;T, P: Parameterized&lt;T&gt;&gt; {\n    p: P\n}\n\nimpl&lt;T, P&gt; PP&lt;T, P&gt;\n    where P: Parameterized&lt;T&gt;\n{\n    fn call_it&lt;'a&gt;(t: &amp;'a T) -&gt; &amp;'a T {\n        P::static_call(t)\n    }\n}\n</code></pre>\n\n<p>But unfortunately things go down hill from here. The syntax here presented is the most obvious, however associated methods are not implemented yet and therefore the compiler rejects the code (with a baffling error message):</p>\n\n<pre><code>error: failed to resolve. Use of undeclared type or module `P`\n              P::static_call(t)\n              ^~~~~~~~~~~~~~\n</code></pre>\n\n<p>Okay, fine, let's try the work-around described in the previous question then!</p>\n\n<pre><code>impl&lt;T, P&gt; PP&lt;T, P&gt;\n    where P: Parameterized&lt;T&gt;\n{\n    fn call_it&lt;'a&gt;(t: &amp;'a T) -&gt; &amp;'a T {\n        Parameterized::&lt;T&gt;::static_call(t)\n    }\n}\n</code></pre>\n\n<p>which results in:</p>\n\n<pre><code>error: type annotations required: cannot resolve `_ : Parameterized&lt;T&gt;`\n              Parameterized::&lt;T&gt;::static_call(t)\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre>\n\n<p>That's fair enough, as there are indeed no way for the compiler to infer that I meant the particular implementation of <code>Parameterized&lt;T&gt;</code> for <code>P</code>. Let's pick up the syntax used for associated types then:</p>\n\n<pre><code>impl&lt;T, P&gt; PP&lt;T, P&gt;\n    where P: Parameterized&lt;T&gt;\n{\n    fn call_it&lt;'a&gt;(t: &amp;'a T) -&gt; &amp;'a T {\n        &lt;P as Parameterized&lt;T&gt;&gt;::static_call(t)\n    }\n}\n</code></pre>\n\n<p>Nope, not working either:</p>\n\n<pre><code>error: unexpected token: `&lt;`\n              &lt;P as Parameterized&lt;T&gt;&gt;::static_call(t)\n              ^\n</code></pre>\n\n<p>So that is not the way to annotate then.</p>\n\n<p>I am open to suggestions of work-arounds, beyond adding <code>&amp;self</code> obviously.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 333, "user_id": 866447, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/63d54bc246b9f959bcb98da8cb3ccf13?s=128&d=identicon&r=PG", "display_name": "phil-opp", "link": "https://stackoverflow.com/users/866447/phil-opp"}, "edited": false, "score": 0, "creation_date": 1424162608, "post_id": 27886745, "comment_id": 45427532, "body": "Fn places the most restrictions on the caller (must not mutate the environment) and FnOnce can even consume/move the environment. FnOnce is implemented for FnMut and FnMut is implemented for Fn. I think FnOnce fits best here."}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "reply_to_user": {"reputation": 333, "user_id": 866447, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/63d54bc246b9f959bcb98da8cb3ccf13?s=128&d=identicon&r=PG", "display_name": "phil-opp", "link": "https://stackoverflow.com/users/866447/phil-opp"}, "edited": false, "score": 1, "creation_date": 1424169903, "post_id": 27886745, "comment_id": 45431743, "body": "No, the <i>caller</i> has the least restrictions for <code>Fn</code>: e.g. they can call it through a <code>&amp;Fn()</code>, but neither <code>FnMut</code> or <code>FnOnce</code> can be called there, while <code>FnOnce</code> has to be called by-value and can only be called once (which is much more restrictive). On the otherhand, <code>Fn</code> places the most restrictions on the <i>callee</i> (the closure itself), while <code>FnOnce</code> is the least restrictive for the closure (that is the body of a <code>FnOnce</code> closure has the most flexibility). As the answer describes, <code>FnOnce</code> is the best, but there&#39;s some subtleties around trait objects that mean it doesn&#39;t work directly."}, {"owner": {"reputation": 333, "user_id": 866447, "user_type": "registered", "accept_rate": 40, "profile_image": "https://www.gravatar.com/avatar/63d54bc246b9f959bcb98da8cb3ccf13?s=128&d=identicon&r=PG", "display_name": "phil-opp", "link": "https://stackoverflow.com/users/866447/phil-opp"}, "edited": false, "score": 0, "creation_date": 1424188092, "post_id": 27886745, "comment_id": 45441065, "body": "Yep, you&#39;re right. I thought of a function that takes a FnOnce/FnMut/Fn as argument."}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 15, "last_activity_date": 1424131830, "last_edit_date": 1424131830, "creation_date": 1420977350, "answer_id": 27886745, "question_id": 27886474, "link": "https://stackoverflow.com/questions/27886474/recursive-function-type/27886745#27886745", "title": "Recursive function type", "body": "<p>You can wrap the function type in a nominal type (i.e. a struct or enum). This is actually what the Go code is doing: <code>type T U</code> defines a new, distinct type <code>T</code> that's not directly interchangable with <code>U</code>, while Rust's <code>type</code> is just an alias, like <code>type</code> in Haskell and <code>typedef</code> in C.</p>\n\n<p>So, one might write:</p>\n\n<pre><code>struct StateFn(fn() -&gt; Option&lt;StateFn&gt;);\n</code></pre>\n\n<p>or</p>\n\n<pre><code>struct StateFn {\n    f: fn() -&gt; Option&lt;StateFn&gt;\n}\n</code></pre>\n\n<p>(I've had to add the <code>Option</code> because Go's <code>func</code> can be nil, while Rust removes nullability by default, making it opt-in.)</p>\n\n<p>That said, I suspect that <code>func</code> is a closure in Go (can store some internal state), while <code>fn</code> in Rust is just a function pointer (no state at all), so you may wish to use a closure in Rust too. One might do this by replacing <code>fn() -&gt; Option&lt;StateFn&gt;</code> with a <code>Box&lt;<a href=\"http://doc.rust-lang.org/nightly/std/ops/trait.Fn.html\">Fn</a>() -> Option&lt;StateFn>></code>, and creating it with <code>Box::new(move || { /* code here */ })</code>. </p>\n\n<p>One might also use <a href=\"http://doc.rust-lang.org/nightly/std/ops/trait.FnMut.html\"><code>FnMut</code></a> instead of <code>Fn</code> which gives you more flexibility, or even <a href=\"http://doc.rust-lang.org/nightly/std/ops/trait.FnOnce.html\"><code>FnOnce</code></a> which represents a closure that can only be called once. Each of these places successively more restrictions on the caller, but gives the closure itself successively more flexibility. (However, \"object safety\" concerns mean that <code>Box&lt;FnOnce&gt;</code> doesn't work at the moment, <a href=\"http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/\">\"Purging proc\"</a> has more details and a work-around.)</p>\n\n<pre><code>struct StateFn {\n    f: Box&lt;FnMut() -&gt; Option&lt;StateFn&gt;&gt;\n}\n</code></pre>\n\n<p>The parsing loop for any of these situations might look like:</p>\n\n<pre><code>let mut state_fn = Some(initial_fn);\nwhile let Some(mut f) = state_fn {\n    state_fn = (*f.f)()\n}\n</code></pre>\n"}], "owner": {"reputation": 113, "user_id": 1615082, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/2cb444b8254e24304d3a1bb4bc192cbd?s=128&d=identicon&r=PG", "display_name": "James", "link": "https://stackoverflow.com/users/1615082/james"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2082, "favorite_count": 3, "accepted_answer_id": 27886745, "answer_count": 1, "score": 10, "last_activity_date": 1424131830, "creation_date": 1420975390, "question_id": 27886474, "link": "https://stackoverflow.com/questions/27886474/recursive-function-type", "title": "Recursive function type", "body": "<p>In <a href=\"https://www.youtube.com/watch?v=HxaD_trXwRE#t=855\">Rob Pike's talk</a> on lexical scanning in Go, he defines a function type <code>stateFn</code> which returns another <code>stateFn</code>, like so:</p>\n\n<pre><code>type stateFn func() stateFn\n</code></pre>\n\n<p>In an attempt to do something similar in Rust, I tried this:</p>\n\n<pre><code>type stateFn = fn() -&gt; stateFn;\n</code></pre>\n\n<p>but the compiler complains \"illegal recursive type; insert an enum or struct in the cycle, if this is desired\".</p>\n\n<p>Can I do this in Rust, and if so, how?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 208003, "user_id": 841108, "user_type": "registered", "accept_rate": 61, "profile_image": "https://i.stack.imgur.com/Fm52y.png?s=128&g=1", "display_name": "Basile Starynkevitch", "link": "https://stackoverflow.com/users/841108/basile-starynkevitch"}, "edited": false, "score": 0, "creation_date": 1420970525, "post_id": 27885793, "comment_id": 44172798, "body": "Use <code>strace</code> or <code>ltrace</code> to find out what is happenning"}, {"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 5, "creation_date": 1420971384, "post_id": 27885793, "comment_id": 44173002, "body": "Did you compile with optimizations on (<code>rustc -O foo.rs</code>)?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1420971757, "post_id": 27885793, "comment_id": 44173087, "body": "Yes, it is likely that you are not using optimizations. If you&#39;re using Cargo, run <code>cargo build --release</code>."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "edited": false, "score": 0, "creation_date": 1420972034, "post_id": 27885793, "comment_id": 44173160, "body": "FWIW, compiling your program with optimizations brings the time down to the python version: <code>.&#47;rust  0,06s user 0,01s system 98% cpu 0,065 total</code>."}, {"owner": {"reputation": 22429, "user_id": 430254, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/V6PGq.png?s=128&g=1", "display_name": "Valentin V", "link": "https://stackoverflow.com/users/430254/valentin-v"}, "edited": false, "score": 0, "creation_date": 1420995569, "post_id": 27885793, "comment_id": 44180245, "body": "<a href=\"http://stackoverflow.com/questions/26570773/why-is-my-rust-program-slower-than-ruby-equivalent\" title=\"why is my rust program slower than ruby equivalent\">stackoverflow.com/questions/26570773/&hellip;</a> This might help, just compile with optimizations"}, {"owner": {"reputation": 194, "user_id": 3288364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/54c0be3d73e07e481be1f4902a84ff3c?s=128&d=identicon&r=PG", "display_name": "rts", "link": "https://stackoverflow.com/users/3288364/rts"}, "edited": false, "score": 2, "creation_date": 1421011684, "post_id": 27885793, "comment_id": 44185725, "body": "Compiling with optimizations is definitely the answer. Thanks, all. <code>.&#47;test  0.03s user 0.02s system 88% cpu 0.054 total</code>"}, {"owner": {"reputation": 2891, "user_id": 135889, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/6660983655e40c381d6c93a2fffd42dd?s=128&d=identicon&r=PG", "display_name": "Ruud", "link": "https://stackoverflow.com/users/135889/ruud"}, "edited": false, "score": 3, "creation_date": 1429521354, "post_id": 27885793, "comment_id": 47620149, "body": "You should answer your own question, so that other users don\u2019t have to seek through the comments."}], "answers": [{"tags": [], "owner": {"reputation": 6139, "user_id": 4144667, "user_type": "registered", "accept_rate": 74, "profile_image": "https://i.stack.imgur.com/rNMgl.png?s=128&g=1", "display_name": "geckob", "link": "https://stackoverflow.com/users/4144667/geckob"}, "is_accepted": true, "score": 11, "last_activity_date": 1430008713, "creation_date": 1430008713, "answer_id": 29872367, "question_id": 27885793, "link": "https://stackoverflow.com/questions/27885793/why-is-this-rust-slower-than-my-similar-python/29872367#29872367", "title": "Why is this Rust slower than my similar Python?", "body": "<p>Build it with optimization flags.</p>\n\n<pre><code>cargo run --release\n</code></pre>\n"}], "owner": {"reputation": 194, "user_id": 3288364, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/54c0be3d73e07e481be1f4902a84ff3c?s=128&d=identicon&r=PG", "display_name": "rts", "link": "https://stackoverflow.com/users/3288364/rts"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 911, "favorite_count": 2, "closed_date": 1488696795, "accepted_answer_id": 29872367, "answer_count": 1, "score": 8, "last_activity_date": 1430008713, "creation_date": 1420970156, "last_edit_date": 1425133343, "question_id": 27885793, "link": "https://stackoverflow.com/questions/27885793/why-is-this-rust-slower-than-my-similar-python", "closed_reason": "Duplicate", "title": "Why is this Rust slower than my similar Python?", "body": "<p>I have the following Rust program (rustc 1.0.0-nightly (44a287e6e 2015-01-08 17:03:40 -0800)):</p>\n\n<pre><code>use std::io::BufferedReader;\nuse std::io::File;\n\nfn main() {\n    let path = Path::new(\"nc.txt\");\n    let mut file = BufferedReader::new(File::open(&amp;path));\n    let lines: Vec&lt;String&gt; = file.lines().map(|x| x.unwrap()).collect();\n    println!(\"{}\", lines[500]);\n}\n</code></pre>\n\n<p>According to the example at <a href=\"http://doc.rust-lang.org/std/io/\" rel=\"noreferrer\">http://doc.rust-lang.org/std/io/</a> the above is the way to pull the lines of a file into a vector of strings. I've thrown in the output of the 500th line.</p>\n\n<p>To solve the same task in Python I've written the following:</p>\n\n<pre><code>#!/usr/local/bin/python3\n\ndef main():\n    with open('nc.txt', 'r') as nc:\n        lines = nc.read().split('\\n')\n    print(\"{}\".format(lines[500]))\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n\n<p>When I run the compiled Rust and time it I get this:</p>\n\n<pre><code>rts@testbed $ time ./test\nA declaration of independence by Kosovo will likely bring a similar declaration from Georgia's breakaway Abkhazia region, which Russia could well recognize.\n\n./test  1.09s user 0.02s system 99% cpu 1.120 total\n</code></pre>\n\n<p>Running the Python gives:</p>\n\n<pre><code>rts@testbed $ time ./test.py \nA declaration of independence by Kosovo will likely bring a similar declaration from Georgia's breakaway Abkhazia region, which Russia could well recognize.\n./test.py  0.05s user 0.03s system 90% cpu 0.092 total\n</code></pre>\n\n<p>I know that <code>println!</code> is a macro which expands to the more complex</p>\n\n<pre><code>::std::io::stdio::println_args(::std::fmt::Arguments::new({\n    #[inline]\n    #[allow(dead_code)]\n    static __STATIC_FMTSTR: &amp;'static [&amp;'static str] = &amp;[\"\"];\n    __STATIC_FMTSTR\n},\n&amp;match (&amp;lines[500],) {\n    (__arg0,) =&gt; [::std::fmt::argument(::std::fmt::String::fmt, __arg0)],\n}));\n</code></pre>\n\n<p>Still, that doesn't seem like the sort of thing that would cause more than a second of additional execution time. Are these snippets of code not, in fact, similar? Have I misinterpreted the most efficient way to read lines into a vector and output one of them?</p>\n\n<p>For reference <code>nc.txt</code> has the following properties:</p>\n\n<pre><code>rts@testbed $ du -hs nc.txt \n7.5M    nc.txt\nrts@testbed $ wc -l nc.txt\n   60219 nc.txt\n</code></pre>\n"}, {"tags": ["closures", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420944910, "post_id": 27883509, "comment_id": 44168715, "body": "What would you like to do with the cloned closure?"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1420945597, "post_id": 27883509, "comment_id": 44168834, "body": "What&#39;s your full code?"}, {"owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420948622, "post_id": 27883509, "comment_id": 44169339, "body": "@shepmaster I specifically want to clone a closure without mutable state to move it into multiple tasks at the same time. See the example I&#39;ve attached."}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 1, "creation_date": 1420949886, "post_id": 27883509, "comment_id": 44169531, "body": "&quot;you can&#39;t clone a &amp;Fn&lt;...&gt;&quot;. You <a href=\"https://github.com/rust-lang/rust/blob/431105a70acaf6e0a1d64b6dd3f69563d6694287/src/libcore/clone.rs#L46\" rel=\"nofollow noreferrer\">can</a>, specifically the <code>?Sized</code> there means it works with trait objects."}, {"owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "reply_to_user": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1420950522, "post_id": 27883509, "comment_id": 44169594, "body": "@dbaupp Box::new(*(&amp;(*self.fp)).clone()) -&gt; error: the trait <code>core::marker::Sized</code> is not implemented for the type <code>core::ops::Fn(i8, i8) -&gt; i8 + Send</code>"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1420950663, "post_id": 27883509, "comment_id": 44169611, "body": "That&#39;s due to all the dereferencing that is happening, not the <code>&amp;Fn()</code> clone directly. I expect the same error message will occur without the <code>.clone()</code>."}], "answers": [{"comments": [{"owner": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "edited": false, "score": 0, "creation_date": 1542812349, "post_id": 27883569, "comment_id": 93704027, "body": "Shep, <code>WithCall</code> doesn&#39;t actually do anything; <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=e4c25b0514959a406be2a37a348da6a7\" rel=\"nofollow noreferrer\">you can clone without it</a>. There is nothing stopping <code>F: Fn(i8) -&gt; i8</code> supporting <code>Clone</code>. But trying cloning a <code>Box&lt;Fn(i8) -&gt; i8&gt;</code>; I <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=079dd5feef12c99932f65bc4b852c712\" rel=\"nofollow noreferrer\">don&#39;t think</a> it&#39;s (safely) possible!"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "edited": false, "score": 1, "creation_date": 1542812628, "post_id": 27883569, "comment_id": 93704207, "body": "@dhardy yes, it&#39;s not <i>needed</i>, but it exists to mirror OPs original structure where they had a type containing a closure, not just a closure. The fact that you can <code>derive(Clone)</code> on it shows that closures are clonable, which is also what my first sentence tries to convey: <i>Closures implement both <code>Copy</code> and <code>Clone</code> if all of the captured variables do</i>. And no, <a href=\"https://stackoverflow.com/q/30353462/155423\">you cannot clone a boxed trait object because <code>Clone</code> is not object safe</a>."}, {"owner": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "edited": false, "score": 0, "creation_date": 1542813208, "post_id": 27883569, "comment_id": 93704598, "body": "So there is simply no way to copy an <code>Fn(...)</code> trait object? Of course <code>&amp;Fn(...)</code> is <code>Copy</code> but this comes with lifetime restrictions."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 8, "last_activity_date": 1526847549, "last_edit_date": 1526847549, "creation_date": 1420945420, "answer_id": 27883569, "question_id": 27883509, "link": "https://stackoverflow.com/questions/27883509/can-you-clone-a-closure/27883569#27883569", "title": "Can you clone a closure?", "body": "<h3>Rust 1.26</h3>\n\n<p>Closures implement both <code>Copy</code> and <code>Clone</code> if all of the captured variables do. You can rewrite your code to use generics instead of a boxed trait object to be able to clone it:</p>\n\n<pre><code>use std::thread;\n\n#[derive(Clone)]\nstruct WithCall&lt;F&gt; {\n    fp: F,\n}\n\nimpl&lt;F&gt; WithCall&lt;F&gt;\nwhere\n    F: Fn(i8, i8) -&gt; i8,\n{\n    pub fn new(fp: F) -&gt; Self {\n        WithCall { fp }\n    }\n\n    pub fn run(&amp;self, a: i8, b: i8) -&gt; i8 {\n        (self.fp)(a, b)\n    }\n}\n\nfn main() {\n    let adder = WithCall::new(|a, b| a + b);\n    println!(\"{}\", adder.run(1, 2));\n\n    let add_a = adder.clone();\n    let add_b = adder;\n\n    let a = thread::spawn(move || {\n        println!(\"In remote thread: {}\", add_a.run(10, 10));\n    });\n\n    let b = thread::spawn(move || {\n        println!(\"In remote thread: {}\", add_b.run(10, 10));\n    });\n\n    a.join().expect(\"Thread A panicked\");\n    b.join().expect(\"Thread B panicked\");\n}\n</code></pre>\n\n<h3>Before Rust 1.26</h3>\n\n<p>Remember that closures capture their environment, so they have a lifetime of their own, based on the environment. However, you can take references to the <code>Fn*</code> and pass those around further, or store them in a struct:</p>\n\n<pre><code>fn do_more&lt;F&gt;(f: &amp;F) -&gt; u8\nwhere\n    F: Fn(u8) -&gt; u8,\n{\n    f(0)\n}\n\nfn do_things&lt;F&gt;(f: F) -&gt; u8\nwhere\n    F: Fn(u8) -&gt; u8,\n{\n    // We can pass the reference to our closure around,\n    // effectively allowing us to use it multiple times.\n    f(do_more(&amp;f))\n}\n\nfn main() {\n    let val = 2;\n    // The closure captures `val`, so it cannot live beyond that.\n    println!(\"{:?}\", do_things(|x| (x + 1) * val));\n}\n</code></pre>\n\n<p>I would say that it is not universally safe to convert the <code>Fn*</code> to a raw pointer and pass it around, due to the lifetime concerns.</p>\n"}, {"comments": [{"owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "edited": false, "score": 0, "creation_date": 1420948715, "post_id": 27883612, "comment_id": 44169358, "body": "Sorry, that was a bit of a rubbish question. I&#39;ve updated it with an example of what I&#39;m trying to do. Closing over a closure might be a solution, but I&#39;m not sure on how you&#39;d do it."}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "reply_to_user": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "edited": false, "score": 0, "creation_date": 1420950690, "post_id": 27883612, "comment_id": 44169617, "body": "@Doug, yes, questions without the actual source are extremely difficult to answer in a useful way. Updated."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "edited": false, "score": 0, "creation_date": 1542812819, "post_id": 27883612, "comment_id": 93704320, "body": "@dhardy huon isn&#39;t saying that you can clone a <code>&amp;mut T</code> but that you can clone a struct that has a <i>function</i> that accepts a <code>&amp;mut T</code>: <i>and a <b>method</b> that takes <code>&amp;mut self</code></i>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "edited": false, "score": 0, "creation_date": 1542812860, "post_id": 27883612, "comment_id": 93704352, "body": "@dhardy <i>there&#39;s no reason an <code>Arc</code> should be necessary</i> \u2014 that&#39;s covered by  <a href=\"https://stackoverflow.com/q/32750829/155423\">How can I pass a reference to a stack variable to a thread?</a>. An <code>Arc</code> is indeed needed for <code>std::thread</code> because ownership is given to the thread."}, {"owner": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1542815150, "post_id": 27883612, "comment_id": 93705758, "body": "@Shepmaster I was assuming the cloned function might be called on the <i>same</i> data, but of course cloning an <code>FnMut</code> clones the data too so huon is correct. (I deleted my previous comment because SO won&#39;t let me correct it now, and there&#39;s no need to leave incorrect information here.)"}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": false, "score": 11, "last_activity_date": 1521929813, "last_edit_date": 1592644375, "creation_date": 1420945907, "answer_id": 27883612, "question_id": 27883509, "link": "https://stackoverflow.com/questions/27883509/can-you-clone-a-closure/27883612#27883612", "title": "Can you clone a closure?", "body": "<p>What you are trying to do is call a closure from multiple threads. That is, share the closure across multiple threads. As soon as the phrase &quot;share across multiple threads&quot; crosses my mind, my first thought is <a href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html\" rel=\"noreferrer\">to reach for <code>Arc</code></a> (at least until <a href=\"https://github.com/rust-lang/rfcs/pull/458\" rel=\"noreferrer\">RFC 458</a> is implemented in some form, when <code>&amp;</code> will become usable across threads).</p>\n<p>This allows for safe shared memory (it implements <code>Clone</code> without requiring its internal type to be <code>Clone</code>, since <code>Clone</code> just creates a new pointer to the same memory), and so you can have a single <code>Fn</code> object that gets used in multiple threads, no need to duplicate it.</p>\n<p>In summary, put your <code>WithCall</code> in an <code>Arc</code> and clone that.</p>\n<pre><code>use std::sync::Arc;\nuse std::thread;\n\ntype Fp = Box&lt;Fn(i8, i8) -&gt; i8 + Send + Sync&gt;;\n\nstruct WithCall {\n    fp: Fp,\n}\n\nimpl WithCall {\n    pub fn new(fp: Fp) -&gt; WithCall {\n        WithCall { fp }\n    }\n\n    pub fn run(&amp;self, a: i8, b: i8) -&gt; i8 {\n        (self.fp)(a, b)\n    }\n}\n\nfn main() {\n    let adder = WithCall::new(Box::new(|a, b| a + b));\n    println!(&quot;{}&quot;, adder.run(1, 2));\n\n    let add_a = Arc::new(adder);\n    let add_b = add_a.clone();\n\n    let a = thread::spawn(move || {\n        println!(&quot;In remote thread: {}&quot;, add_a.run(10, 10));\n    });\n    let b = thread::spawn(move || {\n        println!(&quot;In remote thread: {}&quot;, add_b.run(10, 10));\n    });\n\n    a.join().expect(&quot;thread a panicked&quot;);\n    b.join().expect(&quot;thread b panicked&quot;);\n}\n</code></pre>\n<p><a href=\"https://play.rust-lang.org/?gist=77a4a018e1595bac7146de7f1f18287a&amp;version=stable\" rel=\"noreferrer\">playground</a></p>\n<hr />\n<p>Old answer (this is still relevant): It is quite unusual to have a <code>&amp;mut Fn</code> trait object, since <a href=\"https://doc.rust-lang.org/std/ops/trait.Fn.html#tymethod.call\" rel=\"noreferrer\"><code>Fn::call</code></a> takes <code>&amp;self</code>. The <code>mut</code> is not necessary, and I think it adds literally zero extra functionality. Having a <code>&amp;mut Box&lt;Fn()&gt;</code> does add some functionality, but it is also unusual.</p>\n<p>If you change to a <code>&amp;</code> pointer instead of an <code>&amp;mut</code> things will work more naturally (with both <code>&amp;Fn</code> and <code>&amp;Box&lt;Fn&gt;</code>). Without seeing the actual code you're using, it's extremely hard to tell exactly what you're doing, but</p>\n<pre><code>fn call_it(f: &amp;Fn()) {\n    (*f)();\n    (*f)();\n}\n\nfn use_closure(f: &amp;Fn()) {\n    call_it(f);\n    call_it(f);\n}\n\nfn main() {\n    let x = 1i32;\n    use_closure(&amp;|| println!(&quot;x is {}&quot;, x));\n}\n</code></pre>\n<p>(This is partly due to <code>&amp;T</code> being <code>Copy</code> and also partly due to reborrowing; it works with <code>&amp;mut</code> as well.)</p>\n<p>Alternatively, you can close-over the closure, which likely works in more situations:</p>\n<pre><code>fn foo(f: &amp;Fn()) {\n    something_else(|| f())\n}\n</code></pre>\n<blockquote>\n<p>A <code>FnMut</code> closure cannot be cloned, for obvious reasons.</p>\n</blockquote>\n<p>There's no inherent reason a <code>FnMut</code> can't be cloned, it's just a struct with some fields (and a method that takes <code>&amp;mut self</code>, rather than <code>&amp;self</code> or <code>self</code> as for <code>Fn</code> and <code>FnOnce</code> respectively). If you create a struct and implement <code>FnMut</code> manually, you can still implement <code>Clone</code> for it.</p>\n<blockquote>\n<p>Or is it safe to somehow pass a raw pointer to a Fn around, like:</p>\n<pre><code>let func_pnt = &amp;mut Box&lt;Fn&lt;...&gt; + Send&gt; as *mut Box&lt;Fn&lt;...&gt;&gt;\n</code></pre>\n<p>Technically the above works, but it seems quite weird.</p>\n</blockquote>\n<p>Technically it works if you're careful to ensure the aliasing and lifetime requirements of Rust are satisfied... but by opting in to unsafe pointers you're putting that burden on yourself, not letting the compiler help you. It is relatively rare that the correct response to a compiler error is to use <code>unsafe</code> code, rather than delving in to the error and tweaking the code to make it make more sense (to the compiler, which often results in it making more sense to humans).</p>\n"}, {"tags": [], "owner": {"reputation": 11, "user_id": 6652188, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-m2L0cAUS31Q/AAAAAAAAAAI/AAAAAAAAAH4/DRNv0SNGUSs/photo.jpg?sz=128", "display_name": "Kishorekumar Neelamegam", "link": "https://stackoverflow.com/users/6652188/kishorekumar-neelamegam"}, "is_accepted": false, "score": 0, "last_activity_date": 1514544919, "creation_date": 1514544919, "answer_id": 48021479, "question_id": 27883509, "link": "https://stackoverflow.com/questions/27883509/can-you-clone-a-closure/48021479#48021479", "title": "Can you clone a closure?", "body": "<p>Here is the working code in 1.22.1</p>\n\n<p>The intent is to make this work.</p>\n\n<pre><code>let x = |x| { println!(\"----{}\",x)};\n\nlet mut y = Box::new(x);\n\ny.clone();\n</code></pre>\n\n<p>The original code as suggested at the top was used. </p>\n\n<p>I started with cloning a <code>Fn</code> closure.</p>\n\n<pre><code>type Fp = Box&lt;Fn(i8, i8) -&gt; i8 + Send + Sync&gt;;\n</code></pre>\n\n<p>Ended up adding <code>Arc</code> around <code>Fp</code> in the struct <code>WithCall</code></p>\n\n<p><a href=\"https://play.rust-lang.org/?gist=a7d71f9f8f21bf144ba458aab8811098&amp;version=undefined\" rel=\"nofollow noreferrer\">Play rust : working code</a>\n<a href=\"https://gist.github.com/indykish/a7d71f9f8f21bf144ba458aab8811098\" rel=\"nofollow noreferrer\">Gist : working code in 1.22.1</a></p>\n"}], "owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6529, "favorite_count": 4, "answer_count": 3, "score": 18, "last_activity_date": 1526847549, "creation_date": 1420944753, "last_edit_date": 1521929967, "question_id": 27883509, "link": "https://stackoverflow.com/questions/27883509/can-you-clone-a-closure", "title": "Can you clone a closure?", "body": "<p>A <code>FnMut</code> closure cannot be cloned, for obvious reasons, but a <code>Fn</code> closure has an immutable scope; is there some way to create a \"duplicate\" of a <code>Fn</code> closure?</p>\n\n<p>Trying to clone it results in:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0599]: no method named `clone` found for type `std::boxed::Box&lt;std::ops::Fn(i8, i8) -&gt; i8 + std::marker::Send + 'static&gt;` in the current scope\n  --&gt; src/main.rs:22:25\n   |\n22 |             fp: self.fp.clone(),\n   |                         ^^^^^\n   |\n   = note: self.fp is a function, perhaps you wish to call it\n   = note: the method `clone` exists but the following trait bounds were not satisfied:\n           `std::boxed::Box&lt;std::ops::Fn(i8, i8) -&gt; i8 + std::marker::Send&gt; : std::clone::Clone`\n</code></pre>\n\n<p>Is it safe to somehow pass a raw pointer to a <code>Fn</code> around, like:</p>\n\n<pre><code>let func_pnt = &amp;mut Box&lt;Fn&lt;...&gt; + Send&gt; as *mut Box&lt;Fn&lt;...&gt;&gt;\n</code></pre>\n\n<p>Technically, the above works, but it seems quite weird.</p>\n\n<p>Here's an example of what I'm trying to do:</p>\n\n<pre><code>use std::thread;\n\nstruct WithCall {\n    fp: Box&lt;Fn(i8, i8) -&gt; i8 + Send&gt;,\n}\n\nimpl WithCall {\n    pub fn new(fp: Box&lt;Fn(i8, i8) -&gt; i8 + Send&gt;) -&gt; WithCall {\n        WithCall { fp: fp }\n    }\n\n    pub fn run(&amp;self, a: i8, b: i8) -&gt; i8 {\n        (self.fp)(a, b)\n    }\n}\n\nimpl Clone for WithCall {\n    fn clone(&amp;self) -&gt; WithCall {\n        WithCall {\n            fp: self.fp.clone(),\n        }\n    }\n}\n\nfn main() {\n    let adder = WithCall::new(Box::new(|a, b| a + b));\n    println!(\"{}\", adder.run(1, 2));\n\n    let add_a = adder.clone();\n    let add_b = adder.clone();\n\n    let a = thread::spawn(move || {\n        println!(\"In remote thread: {}\", add_a.run(10, 10));\n    });\n\n    let b = thread::spawn(move || {\n        println!(\"In remote thread: {}\", add_b.run(10, 10));\n    });\n\n    a.join().expect(\"Thread A panicked\");\n    b.join().expect(\"Thread B panicked\");\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=e79470785a64f9f432b22f23bdf6557b&amp;version=stable\" rel=\"noreferrer\">playground</a></p>\n\n<p>I have a struct with a boxed closure in it, and I need to pass that struct to a number of threads. I can't, but I also can't clone it, because you can't clone a <code>Box&lt;Fn&lt;&gt;&gt;</code> and you can't clone a <code>&amp;Fn&lt;...&gt;</code>.</p>\n"}, {"tags": ["iterator", "rust"], "answers": [{"comments": [{"owner": {"reputation": 63855, "user_id": 124486, "user_type": "registered", "accept_rate": 46, "profile_image": "https://www.gravatar.com/avatar/605442f85418d858e2ce1e1aea2092bb?s=128&d=identicon&r=PG", "display_name": "Evan Carroll", "link": "https://stackoverflow.com/users/124486/evan-carroll"}, "edited": false, "score": 0, "creation_date": 1570455759, "post_id": 27882886, "comment_id": 102908597, "body": "It seems <code>.drain</code> for HashMap results in clearing the originating structure, and it can&#39;t work on a subset of the structure. So effectively what&#39;s the difference? <code>drain</code> doesn&#39;t take ownership but results in the original structure being cleared, and <code>.into_iter</code> takes ownership so the original structure can not be used and is left as an empty husk?"}, {"owner": {"reputation": 2715, "user_id": 612512, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/bb7101e3af8cd635dbbb891055675534?s=128&d=identicon&r=PG", "display_name": "Christopher Stevenson", "link": "https://stackoverflow.com/users/612512/christopher-stevenson"}, "edited": false, "score": 1, "creation_date": 1580264831, "post_id": 27882886, "comment_id": 106037629, "body": "If the vector is in a struct, you can&#39;t simply convert the vec into an iterator it; you would need to either implement IntoIterator for the struct, or drain the vector."}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 21, "last_activity_date": 1501180965, "last_edit_date": 1501180965, "creation_date": 1420938092, "answer_id": 27882886, "question_id": 27882800, "link": "https://stackoverflow.com/questions/27882800/when-should-i-use-drain-vs-into-iter/27882886#27882886", "title": "When should I use `drain` vs `into_iter`?", "body": "<p>They are somewhat redundant with each other. However, as you say, <code>Drain</code> just borrows the vector, in particular, it has a lifetime connected with the vector. If one is wishing to return an iterator, or otherwise munge iterators in the most flexible way possible, using <code>into_iter</code> is better, since it's not chained to the owner of the originating <code>Vec</code>. If one is wishing to reuse the data structure (e.g. reuse the allocation) then <code>drain</code> is the most direct way of doing this.</p>\n\n<p>Also, a (somewhat) theoretical concern is that <code>Drain</code> <em>needs</em> to result in the originating structure being a valid instance of whatever type it is, that is, either preserve invariants, or fix them up at the end, while <code>IntoIter</code> can mangle the structure as much as it likes, since it has complete control of the value.</p>\n\n<p>I say only \"somewhat\" theoretical because there is a small, real world example of this in <code>std</code> already: <code>HashMap</code> exposes <code>.drain</code> and <code>.into_iter</code> via its internal <code>RawTable</code> type, which also has those methods. <code>into_iter</code> can just <a href=\"https://github.com/rust-lang/rust/blob/099b411e080d302ec0dc5f3aebe53d76c50acfc7/src/libstd/collections/hash/table.rs#L898\" rel=\"noreferrer\">read the hash of the value being moved directly</a> and that's that, but <code>drain</code> has to be careful <a href=\"https://github.com/rust-lang/rust/blob/099b411e080d302ec0dc5f3aebe53d76c50acfc7/src/libstd/collections/hash/table.rs#L898\" rel=\"noreferrer\">to update the hash to indicate that the cell is then empty</a>, not just read it. Obviously this is absolutely tiny in this instance (probably only one or two additional instructions) but for more complicated data structures like trees there may be some non-trivial gains to be had from breaking the invariants of the data structure.</p>\n"}, {"comments": [{"owner": {"reputation": 63855, "user_id": 124486, "user_type": "registered", "accept_rate": 46, "profile_image": "https://www.gravatar.com/avatar/605442f85418d858e2ce1e1aea2092bb?s=128&d=identicon&r=PG", "display_name": "Evan Carroll", "link": "https://stackoverflow.com/users/124486/evan-carroll"}, "edited": false, "score": 0, "creation_date": 1570457244, "post_id": 27882895, "comment_id": 102909487, "body": "Would you say that the <i>only</i> reason to use <code>.drain(..)</code> is to prseerve the memory allocation of the original structure: <a href=\"https://stackoverflow.com/q/58262920/124486\">stackoverflow.com/q/58262920/124486</a>"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": false, "score": 14, "last_activity_date": 1420938122, "creation_date": 1420938122, "answer_id": 27882895, "question_id": 27882800, "link": "https://stackoverflow.com/questions/27882800/when-should-i-use-drain-vs-into-iter/27882895#27882895", "title": "When should I use `drain` vs `into_iter`?", "body": "<p>After using <a href=\"http://doc.rust-lang.org/collections/vec/struct.Vec.html#method.drain\" rel=\"noreferrer\"><code>drain</code></a>, the <code>Vec</code> is empty but the storage previously allocated for its elements remains allocated. This means that you can insert new elements in the <code>Vec</code> without having to allocate storage for them until you reach the <code>Vec</code>'s <a href=\"http://doc.rust-lang.org/collections/vec/struct.Vec.html#capacity-and-reallocation\" rel=\"noreferrer\">capacity</a>.</p>\n\n<p>Note that before you can use the <code>Vec</code> again, you must drop all references to the <a href=\"http://doc.rust-lang.org/collections/vec/struct.Drain.html\" rel=\"noreferrer\"><code>Drain</code></a> iterator. <code>Drain</code>'s implementation of <code>Drop</code> will remove all elements that hadn't been removed from the <code>Vec</code> yet, so the <code>Vec</code> will be empty even if you didn't finish the iteration.</p>\n"}, {"tags": [], "owner": {"reputation": 5076, "user_id": 264177, "user_type": "registered", "accept_rate": 32, "profile_image": "https://www.gravatar.com/avatar/4bec61fe6165806be5ec752ba87245dd?s=128&d=identicon&r=PG", "display_name": "JanKanis", "link": "https://stackoverflow.com/users/264177/jankanis"}, "is_accepted": false, "score": 0, "last_activity_date": 1618178492, "creation_date": 1618178492, "answer_id": 67050577, "question_id": 27882800, "link": "https://stackoverflow.com/questions/27882800/when-should-i-use-drain-vs-into-iter/67050577#67050577", "title": "When should I use `drain` vs `into_iter`?", "body": "<p>For the 2018 edition of Rust:</p>\n<p><code>into_iter</code> consumes the collection itself, <code>drain</code> only consumes the values in the collection.</p>\n<p>Therefore <code>drain</code> allows draining of only a part of the collection, and now in fact requires specifying a range. (This appears to have changed since when the question was asked.)</p>\n<p>So use <code>into_iter</code> if you want to consume the entire collection, and use <code>drain</code> if you only want to consume part of the collection or if you want to reuse the emptied collection later.</p>\n"}], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6515, "favorite_count": 3, "accepted_answer_id": 27882886, "answer_count": 3, "score": 26, "last_activity_date": 1618178492, "creation_date": 1420937094, "last_edit_date": 1491929812, "question_id": 27882800, "link": "https://stackoverflow.com/questions/27882800/when-should-i-use-drain-vs-into-iter", "title": "When should I use `drain` vs `into_iter`?", "body": "<p>On the surface, it looks like both <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.drain\" rel=\"noreferrer\"><code>drain</code></a> and <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter\" rel=\"noreferrer\"><code>into_iter</code></a> provide similar iterators, namely over the values of the collection. However, they are different:</p>\n\n<pre><code>fn main() {\n    let mut items1 = vec![0u8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let items2 = items1.clone();\n\n    println!(\"{:?}\", items1.drain().count());\n    println!(\"{:?}\", items2.into_iter().count());\n\n    println!(\"{:?}\", items1);\n    // println!(\"{:?}\", items2); Moved\n}\n</code></pre>\n\n<p><code>drain</code> takes a <code>&amp;mut</code> to the collection and the collection is available afterwards. <code>into_iter</code> consumes the collection. What are the appropriate uses for each iterator?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420920695, "post_id": 27880570, "comment_id": 44162985, "body": "I assume that you are asking this to explore how it would be implemented. If you wanted to do this in The Real World, you can just use <a href=\"http://doc.rust-lang.org/std/slice/trait.SliceExt.html#tymethod.iter_mut\" rel=\"nofollow noreferrer\"><code>iter_mut</code></a> from the standard library."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1420920405, "last_edit_date": 1495542041, "creation_date": 1420920405, "answer_id": 27880686, "question_id": 27880570, "link": "https://stackoverflow.com/questions/27880570/cant-use-mutable-slice-where-immutable-slice-is-fine/27880686#27880686", "title": "Can&#39;t use mutable slice where immutable slice is fine", "body": "<p>Really, what you want to do is to create an iterator of mutable references. That has been <a href=\"https://stackoverflow.com/a/25748645/155423\">answered before</a>, with at least one <a href=\"https://stackoverflow.com/q/27118398/155423\">example of how to do it</a>.</p>\n\n<p>The summary is that Rust cannot tell that you are not returning the <em>same</em> mutable reference more than once. If you did so, then you would have <em>aliasing</em>, which breaks Rust's rules. As an aside, your iterator as shown <strong>is unsafe</strong> because it will always return the first item! As a human smarter than Rust, you have to manually verify that you aren't breaking the safety rules and then use <code>unsafe</code> code to ignore the warnings. Something like <code>mem::transmute</code> is often used.</p>\n"}], "owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 519, "favorite_count": 0, "closed_date": 1546103067, "accepted_answer_id": 27880686, "answer_count": 1, "score": 2, "last_activity_date": 1546103083, "creation_date": 1420919743, "last_edit_date": 1546103032, "question_id": 27880570, "link": "https://stackoverflow.com/questions/27880570/cant-use-mutable-slice-where-immutable-slice-is-fine", "closed_reason": "Duplicate", "title": "Can&#39;t use mutable slice where immutable slice is fine", "body": "<p>I'd like to create a struct that holds a slice, and can return references to items in that slice. So far, I've been able to do this:</p>\n\n<pre><code>pub struct Stride&lt;'a&gt; {\n    items: &amp;'a [f32],\n}\n\nimpl&lt;'a&gt; Iterator for Stride&lt;'a&gt; {\n    type Item = &amp;'a f32;\n    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a f32&gt; {\n        Some(&amp;self.items[0])\n    }\n}\n</code></pre>\n\n<p>However, when I change the slice to be a mutable slice:</p>\n\n<pre><code>pub struct Stride&lt;'a&gt; {\n    items: &amp;'a mut [f32],\n}\n\nimpl&lt;'a&gt; Iterator for Stride&lt;'a&gt; {\n    type Item = &amp;'a f32;\n    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a f32&gt; {\n        Some(&amp;self.items[0])\n    }\n}\n</code></pre>\n\n<p>I get a compiler error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0495]: cannot infer an appropriate lifetime for lifetime parameter in function call due to conflicting requirements\n --&gt; src/lib.rs:8:15\n  |\n8 |         Some(&amp;self.items[0])\n  |               ^^^^^^^^^^^^^\n  |\nnote: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 7:5...\n --&gt; src/lib.rs:7:5\n  |\n7 | /     fn next(&amp;mut self) -&gt; Option&lt;&amp;'a f32&gt; {\n8 | |         Some(&amp;self.items[0])\n9 | |     }\n  | |_____^\nnote: ...so that reference does not outlive borrowed content\n --&gt; src/lib.rs:8:15\n  |\n8 |         Some(&amp;self.items[0])\n  |               ^^^^^^^^^^\nnote: but, the lifetime must be valid for the lifetime 'a as defined on the impl at 5:6...\n --&gt; src/lib.rs:5:6\n  |\n5 | impl&lt;'a&gt; Iterator for Stride&lt;'a&gt; {\n  |      ^^\n  = note: ...so that the expression is assignable:\n          expected std::option::Option&lt;&amp;'a f32&gt;\n             found std::option::Option&lt;&amp;f32&gt;\n</code></pre>\n\n<p>Why can't I hold this mutable slice and return references to the elements in that slice? I would like to go even further: returning mutable references to elements in this slice. Is this even possible?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 6, "last_activity_date": 1420912007, "creation_date": 1420912007, "answer_id": 27879234, "question_id": 27879161, "link": "https://stackoverflow.com/questions/27879161/what-is-the-return-type-of-the-indexing-operation/27879234#27879234", "title": "What is the return type of the indexing operation?", "body": "<p>No, you're doing everything correctly. While <code>index()</code> method does return a reference, when it is invoked in an indexing operation its result is dereferenced automatically. This is done so the indexing is more natural: in every language where some kind of indexing operator exists (mainly C and C++), it returns values themselves, not the references into containers.</p>\n\n<p>In order to obtain a reference into the collection you have to either apply a reference operator explicitly (like in your first \"workaround\") or to use reference pattern (like in the second one).</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1420912789, "post_id": 27879283, "comment_id": 44160378, "body": "Ah! I see, so I got caught by the sugar of <code>[]</code>! I had not thought about calling <code>index</code> directly as I did not expect a difference, even though I had already noticed the difference that calling <code>[]</code> with <code>T</code> would desugar into calling <code>index</code> with <code>&amp;T</code>. Thanks for the illustration, it really helps visualizing things."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 13, "last_activity_date": 1474470407, "last_edit_date": 1474470407, "creation_date": 1420912260, "answer_id": 27879283, "question_id": 27879161, "link": "https://stackoverflow.com/questions/27879161/what-is-the-return-type-of-the-indexing-operation/27879283#27879283", "title": "What is the return type of the indexing operation?", "body": "<p>This is a bit of helpful ergonomics that the compiler does for you in order to make the code look a bit nicer.</p>\n\n<p>The return value of the <code>Index</code> trait <em>is</em> a reference, but the compiler automatically inserts a dereference for you <em>when you use the sugared syntax</em> <code>[]</code>. Most other languages would just return the item from the array (copying it or returning another reference to the object, whatever is appropriate).</p>\n\n<p>Due to Rust's importance of move / copy semantics, you can't always make a copy a value, so in those cases, you will usually use a <code>&amp;</code>:</p>\n\n<pre><code>let items = &amp;[1u8, 2, 3, 4];\n\nlet a: u8 = items[0];\nlet a: u8 = *items.index(&amp;0); // Equivalent of above\n\nlet b: &amp;u8 = &amp;items[0];\nlet b: &amp;u8 = &amp;*items.index(&amp;0); // Equivalent of above\n</code></pre>\n\n<p>Note that the indexing value is also automatically taken by reference, similar to the automatic dereference.</p>\n"}], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1445, "favorite_count": 2, "accepted_answer_id": 27879283, "answer_count": 2, "score": 14, "last_activity_date": 1521319262, "creation_date": 1420911601, "last_edit_date": 1521319262, "question_id": 27879161, "link": "https://stackoverflow.com/questions/27879161/what-is-the-return-type-of-the-indexing-operation", "title": "What is the return type of the indexing operation?", "body": "<p>I am trying, quite unsuccessfully, to play around with slices.</p>\n\n<p>I have reduced my first issue to:</p>\n\n<pre><code>fn at&lt;'a, T&gt;(slice: &amp;'a [T], index: usize) -&gt; &amp;'a T {\n    let item = slice[index];\n    item\n}\n</code></pre>\n\n<p>It is my expectation that the return type of <code>slice[index]</code> be a reference, given the <a href=\"http://doc.rust-lang.org/std/ops/trait.Index.html\" rel=\"noreferrer\">documentation</a>:</p>\n\n<pre><code>pub trait Index&lt;Index&gt; {\n    type Output;\n    fn index(&amp;'a self, index: &amp;Index) -&gt; &amp;'a &lt;Self as Index&lt;Index&gt;&gt;::Output;\n//                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n}\n</code></pre>\n\n<p>However, the compiler gives me an error:</p>\n\n<blockquote>\n  <pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n --&gt; src/main.rs:3:5\n  |\n3 |     item\n  |     ^^^^ expected reference, found type parameter\n  |\n  = note: expected type `&amp;'a T`\n             found type `T`\n</code></pre>\n</blockquote>\n\n<p>Which I interpret as meaning that the type of <code>item</code> does not match the return type of the function (I introduced <code>item</code> solely for debugging purpose, to split expression evaluation from return).</p>\n\n<p>If I switch the return type to <code>T</code>, which is the type of <code>item</code>, I get another error message:</p>\n\n<blockquote>\n  <pre class=\"lang-none prettyprint-override\"><code>error[E0508]: cannot move out of type `[T]`, a non-copy slice\n --&gt; src/main.rs:2:16\n  |\n2 |     let item = slice[index];\n  |                ^^^^^^^^^^^^\n  |                |\n  |                cannot move out of here\n  |                help: consider using a reference instead: `&amp;slice[index]`\n</code></pre>\n</blockquote>\n\n<p>After tinkering a bit, I found two work-arounds:</p>\n\n<pre><code>fn at&lt;'a, T&gt;(slice: &amp;'a [T], index: usize) -&gt; &amp;'a T {\n    &amp;slice[index]\n//  ^\n}\n\nfn at&lt;'a, T&gt;(slice: &amp;'a [T], index: usize) -&gt; &amp;'a T {\n    let ref item = slice[index];\n//      ^~~\n    item\n}\n</code></pre>\n\n<p>forcing the type to be a reference does the trick.</p>\n\n<p><em>Why are these shenanigans necessary in the first place?</em> Am I doing something wrong?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420914954, "post_id": 27878955, "comment_id": 44161089, "body": "Also note that the docs currently don&#39;t show the required traits for the predicate. For <code>find</code> it is <code>P: FnMut(&amp;Self::Item) -&gt; bool</code> and for <code>position</code> it is <code>P: FnMut(Self::Item) -&gt; bool</code>."}, {"owner": {"reputation": 4503, "user_id": 98460, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/bCJzr.jpg?s=128&g=1", "display_name": "OderWat", "link": "https://stackoverflow.com/users/98460/oderwat"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420925803, "post_id": 27878955, "comment_id": 44164506, "body": "Well this means you can&#39;t deduce it from the docs and need to &quot;experiment&quot; or look at the source of the methods. Thats just bad in my opinion."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1420925913, "post_id": 27878955, "comment_id": 44164544, "body": "Agreed! It&#39;s a bug in the doc generation, and is tracked in <a href=\"https://github.com/rust-lang/rust/issues/20534\" rel=\"nofollow noreferrer\">20534</a> or maybe <a href=\"https://github.com/rust-lang/rust/issues/20203\" rel=\"nofollow noreferrer\">20203</a>."}], "answers": [{"comments": [{"owner": {"reputation": 4503, "user_id": 98460, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/bCJzr.jpg?s=128&g=1", "display_name": "OderWat", "link": "https://stackoverflow.com/users/98460/oderwat"}, "edited": false, "score": 1, "creation_date": 1420925937, "post_id": 27879541, "comment_id": 44164556, "body": "This explains the why. I am not satisfied. But thats not your fault I guess."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 4503, "user_id": 98460, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/bCJzr.jpg?s=128&g=1", "display_name": "OderWat", "link": "https://stackoverflow.com/users/98460/oderwat"}, "edited": false, "score": 1, "creation_date": 1420926088, "post_id": 27879541, "comment_id": 44164602, "body": "For what it&#39;s worth, I&#39;m very happy that Rust ensures that I don&#39;t use use a value after it&#39;s been moved! ^_^ I could see two solutions to unify the problems: Both could take a reference, or there could be a <code>find_copyable</code> that has an additional <code>T: Copy</code> bound. Neither seem that great to me."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 6, "last_activity_date": 1527897978, "last_edit_date": 1527897978, "creation_date": 1420913680, "answer_id": 27879541, "question_id": 27878955, "link": "https://stackoverflow.com/questions/27878955/why-do-the-predicates-for-find-and-position-require-different-types/27879541#27879541", "title": "Why do the predicates for find() and position() require different types?", "body": "<p>Let's try it out!</p>\n\n<pre><code>#[derive(Debug)]\nstruct MyNum(u8);\n\ntrait MyExt: Iterator + Sized {\n    fn my_find&lt;P&gt;(&amp;mut self, mut predicate: P) -&gt; Option&lt;Self::Item&gt;\n    // Changed to take the item directly, not a reference\n    where\n        P: FnMut(Self::Item) -&gt; bool,\n    {\n        for x in *self {\n            if predicate(x) {\n                return Some(x);\n            }\n        }\n        None\n    }\n}\n\nimpl&lt;I&gt; MyExt for I\nwhere\n    I: Iterator,\n{\n}\n\nfn main() {\n    let mut vec = vec![0u8, 1, 2, 3, 4, 5, 6];\n    let vec: Vec&lt;MyNum&gt; = vec.drain(..).map(|x| MyNum(x)).collect();\n    // find the first element &gt; 3\n    println!(\"{:?}\", vec.iter().my_find(|x| x.0 &gt; 3).unwrap());\n}\n</code></pre>\n\n<p>This compiles with the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n  --&gt; src/main.rs:10:18\n   |\n10 |         for x in *self {\n   |                  ^^^^^ cannot move out of borrowed content\n\nerror[E0382]: use of moved value: `x`\n  --&gt; src/main.rs:12:29\n   |\n11 |             if predicate(x) {\n   |                          - value moved here\n12 |                 return Some(x);\n   |                             ^ value used here after move\n   |\n   = note: move occurs because `x` has type `&lt;Self as std::iter::Iterator&gt;::Item`, which does not implement the `Copy` trait\n</code></pre>\n\n<p>The problem is that we can iterate over <strong>non-copyable values</strong>. When we use <code>position</code>, we don't need the value after calling the predicate, so it's safe to just pass the value in, consuming it in the process. When we call <code>find</code>, however, we need to pass the value to the predicate and <em>then</em> pass it as the return value. This means that the predicate must not consume the value!</p>\n"}], "owner": {"reputation": 4503, "user_id": 98460, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/bCJzr.jpg?s=128&g=1", "display_name": "OderWat", "link": "https://stackoverflow.com/users/98460/oderwat"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 631, "favorite_count": 0, "accepted_answer_id": 27879541, "answer_count": 1, "score": 4, "last_activity_date": 1527897978, "creation_date": 1420910393, "last_edit_date": 1527897882, "question_id": 27878955, "link": "https://stackoverflow.com/questions/27878955/why-do-the-predicates-for-find-and-position-require-different-types", "title": "Why do the predicates for find() and position() require different types?", "body": "<p>Given the following code:</p>\n\n<pre><code>fn main() {\n    let vec = vec![0u8, 1, 2, 3, 4, 5, 6];\n    // find the first element &gt; 3\n    println!(\"{}\", vec.iter().find(|&amp;x| *x &gt; 3).unwrap());\n    // find the position of the first element &gt; 3\n    println!(\"{}\", vec.iter().position(|&amp;x| x &gt; 3).unwrap());\n}\n</code></pre>\n\n<p>and looking at the docs:</p>\n\n<pre><code>fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;&lt;Self as Iterator&gt;::Item&gt;\n\nfn position&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;\n</code></pre>\n\n<p>I find it hard to understand why <code>find()</code> needs the <code>*x</code> and <code>position()</code> needs just <code>x</code>. Both have <code>&amp;mut self</code> and it looks to me as if both do the same work in the predicate.</p>\n\n<p>I guess this can be deduced by the different return types, but what is the exact rule with that?</p>\n"}, {"tags": ["struct", "rust", "traits"], "answers": [{"comments": [{"owner": {"reputation": 21663, "user_id": 9305398, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cqJvE.png?s=128&g=1", "display_name": "Acorn", "link": "https://stackoverflow.com/users/9305398/acorn"}, "edited": false, "score": 0, "creation_date": 1610517458, "post_id": 27876930, "comment_id": 116155552, "body": "&quot;<i>Contrary to C/C++, Rust has very explicit distinction between types which are copied and which are moved.</i>&quot; What do you mean? C does not have those concepts to begin with. C++ has them, but they are explicit and part of the type system."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 21663, "user_id": 9305398, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cqJvE.png?s=128&g=1", "display_name": "Acorn", "link": "https://stackoverflow.com/users/9305398/acorn"}, "edited": false, "score": 0, "creation_date": 1611097246, "post_id": 27876930, "comment_id": 116340192, "body": "The question is semantics. In C, everything is copied, even those types which should logically be moved, and there is no support from language to enforce or simplify it (i.e. you have to write the move logic explicitly). C++ is similar, except that in it, there are move-related tools in the language (move constructor, <code>std::move</code>, etc). However, these tools are very explicit and error-prone, i.e. you need to not forget to call <code>std::move</code>, and you need to implement the move constructor correctly. Also, I&#39;m not quite sure how move is visible in the type system in C++?"}, {"owner": {"reputation": 21663, "user_id": 9305398, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cqJvE.png?s=128&g=1", "display_name": "Acorn", "link": "https://stackoverflow.com/users/9305398/acorn"}, "edited": false, "score": 0, "creation_date": 1611138661, "post_id": 27876930, "comment_id": 116351962, "body": "&quot;<i>C++ is similar ... However, these tools are very explicit and error-prone</i>&quot; That&#39;s false. C++ types are statically copyable, moveable, both or none. You can&#39;t &quot;<i>forget to call <code>std::move</code></i>&quot; if the type requires it. <i>you need to implement the move constructor correctly</i> The compiler does it for you for the equivalent semantics in Rust. The actual advantage Rust has here is affine types."}, {"owner": {"reputation": 21663, "user_id": 9305398, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cqJvE.png?s=128&g=1", "display_name": "Acorn", "link": "https://stackoverflow.com/users/9305398/acorn"}, "edited": false, "score": 0, "creation_date": 1611139065, "post_id": 27876930, "comment_id": 116352161, "body": "&quot;<i>how move is visible in the type system in C++?</i>&quot; It is baked into the type system. You can even query the compiler for those traits at compile-time (like a subset of static reflection) and tweak generated code accordingly (including static branching etc.). Rust will get this too with the const eval efforts, but it&#39;s a hard feature to specify and to implement and thus it is less powerful than C++ in this case at the moment."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 21663, "user_id": 9305398, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cqJvE.png?s=128&g=1", "display_name": "Acorn", "link": "https://stackoverflow.com/users/9305398/acorn"}, "edited": false, "score": 0, "creation_date": 1611622708, "post_id": 27876930, "comment_id": 116506398, "body": "Okay, then probably my knowledge of C++ is not enough. Thanks for the explanation!"}, {"owner": {"reputation": 21663, "user_id": 9305398, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/cqJvE.png?s=128&g=1", "display_name": "Acorn", "link": "https://stackoverflow.com/users/9305398/acorn"}, "edited": false, "score": 0, "creation_date": 1611664904, "post_id": 27876930, "comment_id": 116518623, "body": "Don&#39;t mention it!"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 22, "last_activity_date": 1434037840, "last_edit_date": 1434037840, "creation_date": 1420897934, "answer_id": 27876930, "question_id": 27876588, "link": "https://stackoverflow.com/questions/27876588/why-is-the-copy-trait-needed-for-default-struct-valued-array-initialization/27876930#27876930", "title": "Why is the Copy trait needed for default (struct valued) array initialization?", "body": "<p>Contrary to C/C++, Rust has very explicit distinction between types which are copied and which are moved. Note that this is only a semantic distinction; on the implementation level move <em>is</em> a shallow bytewise copy, however, the compiler places certain restrictions on what you can do with variables you moved from.</p>\n\n<p>By default <em>every</em> type is only moveable (non-copyable). It means that values of such types are moved around:</p>\n\n<pre><code>let x = SomeNonCopyableType::new();\nlet y = x;\nx.do_something();      // error!\ndo_something_else(x);  // error!\n</code></pre>\n\n<p>You see, the value which was stored in <code>x</code> has been moved to <code>y</code>, and so you can't do anything with <code>x</code>.</p>\n\n<p>Move semantics is a very important part of ownership concept in Rust. You can read more on it <a href=\"http://doc.rust-lang.org/book/ownership.html\">in the official guide</a>.</p>\n\n<p>Some types, however, are simple enough so their bytewise copy is also their semantic copy: if you copy a value byte-by-byte, you will get a new completely independent value. For example, primitive numbers are such types. Such property is designated by <code>Copy</code> trait in Rust, i.e. if a type implements <code>Copy</code>, then values of this type are implicitly copyable. <code>Copy</code> does not contain methods; it exists solely to mark that implementing types have certain property and so it is usually called a marker trait (as well as few other traits which do similar things).</p>\n\n<p>However, it does not work for all types. For example, structures like dynamically allocated vectors cannot be automatically copyable: if they were, the address of the allocation contained in them would be byte-copied too, and then the destructor of such vector will be run twice over the same allocation, causing this pointer to be freed twice, which is a memory error.</p>\n\n<p>So by default custom types in Rust are not copyable. But you can opt-in for it using <code>#[derive(Copy, Clone)]</code> (or, as you noticed, using direct <code>impl</code>; they are equivalent, but <code>derive</code> usually reads better):</p>\n\n<pre><code>#[derive(Copy, Clone)]\nstruct MyType {\n    member: u16\n}\n</code></pre>\n\n<p>(deriving <code>Clone</code> is necessary because <code>Copy</code> inherits <code>Clone</code>, so everything which is <code>Copy</code> must also be <code>Clone</code>)</p>\n\n<p>If your type can be automatically copyable in principle, that is, it doesn't have an associated destructor and all of its members are <code>Copy</code>, then with <code>derive</code> your type will also be <code>Copy</code>.</p>\n\n<p>You can use <code>Copy</code> types in array initializer precisely because the array will be initialized with bytewise copies of the value used in this initializer, so your type has to implement <code>Copy</code> to designate that it indeed <em>can</em> be automatically copied.</p>\n\n<p>The above was the answer to 1 and 2. As for 3, yes, you are absolutely correct. It does work precisely because the value is moved into the function. If you tried to use a variable of <code>MyType</code> type after you passed it into the function, you would quickly notice an error about using a moved value.</p>\n"}, {"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": false, "score": 5, "last_activity_date": 1518646554, "last_edit_date": 1518646554, "creation_date": 1420898061, "answer_id": 27876953, "question_id": 27876588, "link": "https://stackoverflow.com/questions/27876588/why-is-the-copy-trait-needed-for-default-struct-valued-array-initialization/27876953#27876953", "title": "Why is the Copy trait needed for default (struct valued) array initialization?", "body": "<blockquote>\n  <p>Why do I need to specify an empty Copy trait implementation?</p>\n</blockquote>\n\n<p><code>Copy</code> is a special built-in trait such that <code>T</code> implementing <code>Copy</code> represents that it is safe to duplicate a value of type <code>T</code> with a shallow byte copy.</p>\n\n<p>This simple definition mean that one just needs to tell the compiler those semantics are correct, since there's no fundamental change in run-time behaviour: both a move (a non-<code>Copy</code> type) and a \"copy\" are shallow byte copies, it's just a question of if the source is usable later. See <a href=\"https://stackoverflow.com/a/24253573/1256624\">an older answer for more details</a>.</p>\n\n<p>(The compiler will complain if the contents of <code>MyType</code> isn't <code>Copy</code> itself; previously it would be automatically implemented, but that all changed <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\" rel=\"nofollow noreferrer\">with opt-in built-in traits</a>.)</p>\n\n<p>Creating an array is duplicating the value via shallow copies, and this is guaranteed to be safe if <code>T</code> is <code>Copy</code>. It is safe in more general situations, <a href=\"https://github.com/rust-lang/rust/issues/5244\" rel=\"nofollow noreferrer\">#5244</a> covers some of them, but at the core, a non-<code>Copy</code> struct won't be able to be used to create a fixed-length array automatically because the compiler can't tell that the duplication is safe/correct.</p>\n\n<blockquote>\n  <p>Is there a simpler way to do this or do I have to re-think something (I'm coming from C)?</p>\n</blockquote>\n\n<pre><code>#[derive(Copy)]\nstruct MyType {\n    member: u16\n}\n</code></pre>\n\n<p>will insert the appropriate empty implementation (<code>#[derive]</code> works with several other traits, e.g. one often sees <code>#[derive(Copy, Clone, PartialEq, Eq)]</code>.)</p>\n\n<blockquote>\n  <p>Why does it work when passing an instance of <code>MyType</code> to the function by value? My guess is that it is being moved, so there is no copy in the first place.</p>\n</blockquote>\n\n<p>Well, without calling the function one doesn't see the move vs. copy behaviour (if you were to call it twice the same non-<code>Copy</code> value, the compiler would emit an error about moved values). But, a \"move\" and a \"copy\" are essentially the same on the machine. All by-value uses of a value are shallow copies semantically in Rust, just like in C.</p>\n"}], "owner": {"reputation": 197, "user_id": 892819, "user_type": "registered", "accept_rate": 43, "profile_image": "https://www.gravatar.com/avatar/dbc0dbd753950bf17954902cc92d5529?s=128&d=identicon&r=PG", "display_name": "Daniel", "link": "https://stackoverflow.com/users/892819/daniel"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 6605, "favorite_count": 3, "accepted_answer_id": 27876930, "answer_count": 2, "score": 10, "last_activity_date": 1518646554, "creation_date": 1420895538, "last_edit_date": 1518634227, "question_id": 27876588, "link": "https://stackoverflow.com/questions/27876588/why-is-the-copy-trait-needed-for-default-struct-valued-array-initialization", "title": "Why is the Copy trait needed for default (struct valued) array initialization?", "body": "<p>When I define a struct like this, I can pass it to a function by value without adding anything specific:</p>\n\n<pre><code>#[derive(Debug)]\nstruct MyType {\n    member: u16,\n}\n\nfn my_function(param: MyType) {\n    println!(\"param.member: {}\", param.member);\n}\n</code></pre>\n\n<p>When I want to create an array of <code>MyType</code> instances with a default value</p>\n\n<pre><code>fn main() {\n    let array = [MyType { member: 1234 }; 100];\n    println!(\"array[42].member: \", array[42].member);\n}\n</code></pre>\n\n<p>The Rust compiler tells me:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `MyType: std::marker::Copy` is not satisfied\n  --&gt; src/main.rs:11:17\n   |\n11 |     let array = [MyType { member: 1234 }; 100];\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `MyType`\n   |\n   = note: the `Copy` trait is required because the repeated element will be copied\n</code></pre>\n\n<p>When I implement <code>Copy</code> and <code>Clone</code>, everything works:</p>\n\n<pre><code>impl Copy for MyType {}\nimpl Clone for MyType {\n    fn clone(&amp;self) -&gt; Self {\n        MyType {\n            member: self.member.clone(),\n        }\n    }\n}\n</code></pre>\n\n<ol>\n<li><p>Why do I need to specify an empty <code>Copy</code> trait implementation?</p></li>\n<li><p>Is there a simpler way to do this or do I have to re-think something?</p></li>\n<li><p>Why does it work when passing an instance of <code>MyType</code> to the function by value? My guess is that it is being moved, so there is no copy in the first place.</p></li>\n</ol>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 188064, "user_id": 635608, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/oIJia.png?s=128&g=1", "display_name": "Mat", "link": "https://stackoverflow.com/users/635608/mat"}, "edited": false, "score": 0, "creation_date": 1420895843, "post_id": 27876561, "comment_id": 44154634, "body": "Those <code>;</code> are required in C/C++/Java/Perl and probably a few more."}, {"owner": {"reputation": 17680, "user_id": 200322, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/LSTRN.png?s=128&g=1", "display_name": "TheCloudlessSky", "link": "https://stackoverflow.com/users/200322/thecloudlesssky"}, "reply_to_user": {"reputation": 188064, "user_id": 635608, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/oIJia.png?s=128&g=1", "display_name": "Mat", "link": "https://stackoverflow.com/users/635608/mat"}, "edited": false, "score": 1, "creation_date": 1420896400, "post_id": 27876561, "comment_id": 44154828, "body": "@Mat - Of course! But, in Rust, you can use the last line to return a value <i>without</i> an explicit <code>return</code>... and you don&#39;t use a semicolon because it would evaluate the expression and return <code>()</code>. Check out the <a href=\"http://doc.rust-lang.org/book/functions.html\" rel=\"nofollow noreferrer\">official book</a> to see what I mean. It just seems inconsistent..."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1420897140, "post_id": 27876561, "comment_id": 44155050, "body": "What seems inconsistent? That there is no semicolon when just writing the return value, but (by convention) a semicolon when using <code>return</code>?"}, {"owner": {"reputation": 17680, "user_id": 200322, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/LSTRN.png?s=128&g=1", "display_name": "TheCloudlessSky", "link": "https://stackoverflow.com/users/200322/thecloudlesssky"}, "edited": false, "score": 1, "creation_date": 1420897867, "post_id": 27876561, "comment_id": 44155258, "body": "@delnan - Yes. It&#39;s confusing when learning that <code>;</code> causes the function to return <code>()</code>... except where you&#39;ve used <code>return expr;</code>."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 0, "creation_date": 1420898251, "post_id": 27876561, "comment_id": 44155365, "body": "@TheCloudlessSky <code>;</code> doesn&#39;t cause functions to return <code>()</code>, it delimits statements. Although it&#39;s technically an expression, I consider <code>return</code> a statement (the only difference to just writing the return value is the effect on control flow), so of course it&#39;s going to get a semicolon."}, {"owner": {"reputation": 17680, "user_id": 200322, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/LSTRN.png?s=128&g=1", "display_name": "TheCloudlessSky", "link": "https://stackoverflow.com/users/200322/thecloudlesssky"}, "edited": false, "score": 1, "creation_date": 1420898729, "post_id": 27876561, "comment_id": 44155508, "body": "@delnan The <a href=\"http://doc.rust-lang.org/book/functions.html\" rel=\"nofollow noreferrer\">official book</a> disagrees with you: &quot;Our function claims to return an i32, but with a semicolon, it would return () instead.&quot; Also, there are plenty of uses where the semicolon is omitted (e.g. <a href=\"https://github.com/rust-lang/time/blob/7f105d4dd2bde23d4b8516dc02566cfc46b60b22/src/lib.rs#L241\" rel=\"nofollow noreferrer\">the official time crate</a>)."}, {"owner": {"reputation": 17680, "user_id": 200322, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/LSTRN.png?s=128&g=1", "display_name": "TheCloudlessSky", "link": "https://stackoverflow.com/users/200322/thecloudlesssky"}, "edited": false, "score": 0, "creation_date": 1420899003, "post_id": 27876561, "comment_id": 44155588, "body": "In fact, <code>fn foo() -&gt; () { ; }</code> compiles and runs as expected."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 1, "creation_date": 1420899335, "post_id": 27876561, "comment_id": 44155700, "body": "@TheCloudlessSky The semicolon turns <code>x + 1</code> into a statement, and statements evaluate to <code>()</code>. So in that sense, a semicolon turns what would be a return value into <code>()</code>, but IMHO that&#39;s not the best way to think about it, certainly not <i>for all semicolons everywhere</i>. As for the <code>time</code> crate: The AFAIK more common <a href=\"http://aturon.github.io/style/braces.html\" rel=\"nofollow noreferrer\">convention</a>, though not officially blessed by an RFC, are semicolons on <code>return</code>s."}], "answers": [{"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 5, "last_activity_date": 1420897108, "creation_date": 1420897108, "answer_id": 27876812, "question_id": 27876561, "link": "https://stackoverflow.com/questions/27876561/why-do-return-expressions-use-semicolons-when-theyre-unnecessary/27876812#27876812", "title": "Why do return expressions use semicolons when they&#39;re unnecessary?", "body": "<blockquote>\n  <p>Is it just an idiom from other languages that has carried over?</p>\n</blockquote>\n\n<p>Yes, I think that's it, just habit and possibly a general sense of aesthetics about what feels weird and what doesn't (which is of course influenced by someone's previous languages).</p>\n\n<p>AFAICT, the only difference it can make is for something like</p>\n\n<pre><code>fn foo() {\n    return;\n    println!(\"hi\");\n}\n</code></pre>\n\n<p>where <code>return</code> needs to be a statement... but the code after the <code>return</code> is unreachable (which the compiler will tell you), so this likely doesn't occur that much in real code.</p>\n"}], "owner": {"reputation": 17680, "user_id": 200322, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/LSTRN.png?s=128&g=1", "display_name": "TheCloudlessSky", "link": "https://stackoverflow.com/users/200322/thecloudlesssky"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1531, "favorite_count": 0, "accepted_answer_id": 27876812, "answer_count": 1, "score": 5, "last_activity_date": 1544527105, "creation_date": 1420895376, "last_edit_date": 1544527105, "question_id": 27876561, "link": "https://stackoverflow.com/questions/27876561/why-do-return-expressions-use-semicolons-when-theyre-unnecessary", "title": "Why do return expressions use semicolons when they&#39;re unnecessary?", "body": "<p>I'm learning Rust and I've found something confusing with functions. According to <a href=\"https://doc.rust-lang.org/stable/reference/expressions/return-expr.html\" rel=\"nofollow noreferrer\">the official reference</a>, a return expression:</p>\n\n<blockquote>\n  <p>.. [is] denoted with the keyword return. Evaluating a return expression moves its \n  argument into the output slot of the current function, destroys the current function activation \n  frame, and transfers control to the caller frame.</p>\n</blockquote>\n\n<p>So, this program works:</p>\n\n<pre><code>fn main() {\n    let current_hour = 10;\n    let message = get_message(current_hour);\n\n    println!(\"Good {0}\", message);\n}\n\nfn get_message(current_hour: i32) -&gt; &amp;'static str {\n\n    if current_hour &lt; 11 {\n        return \"Morning\"\n    }\n    else if current_hour &lt; 17 {\n        return \"Afternoon\"\n    }\n    else {\n        return \"Evening\"\n    }\n\n}\n</code></pre>\n\n<p>And when I add semi-colons to the \"return\" expressions, it still works:</p>\n\n<pre><code>fn main() {\n    let current_hour = 10;\n    let message = get_message(current_hour);\n\n    println!(\"Good {0}\", message);\n}\n\nfn get_message(current_hour: i32) -&gt; &amp;'static str {\n\n    if current_hour &lt; 11 {\n        return \"Morning\";\n    }\n    else if current_hour &lt; 17 {\n        return \"Afternoon\";\n    }\n    else {\n        return \"Evening\";\n    }\n\n}\n</code></pre>\n\n<p>My <a href=\"https://doc.rust-lang.org/stable/reference/statements.html#expression-statements\" rel=\"nofollow noreferrer\">understanding of expression statements (e.g. <code>expr;</code>)</a> is that it will evaluate the <code>expr</code> expression, and ignore the result (instead it will use <code>()</code>). In the case of using <code>return expr;</code>, there doesn't seem to be a <em>reason</em> for using <code>;</code> since <code>return expr</code> destroys the current function activation frame (and would then ignore the <code>;</code>).</p>\n\n<p>So, why does a lot of Rust code that I've seen use the semi-colon if it's not necessary (and in fact makes <a href=\"http://doc.rust-lang.org/book/functions.html\" rel=\"nofollow noreferrer\">learning about Rust's functions</a> very confusing... since it feels like it's contradictory). Is it just an idiom from other languages that has carried over?</p>\n"}, {"tags": ["vector", "rust", "traits"], "answers": [{"tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 3, "last_activity_date": 1420894342, "creation_date": 1420894342, "answer_id": 27876419, "question_id": 27876328, "link": "https://stackoverflow.com/questions/27876328/how-do-i-create-a-new-vector-of-trait-from-vectors-of-types-that-implement-trait/27876419#27876419", "title": "How do I create a new vector of Trait from vectors of types that implement Trait?", "body": "<p>Well, if you have a <code>Bar</code>, and you need a <code>Box&lt;Foo&gt;</code>, then you need to first box the value, then cast it to a trait object, which looks like this:</p>\n\n<pre><code>v_all.extend(v1.into_iter().map(|e| Box::new(e) as Box&lt;Foo&gt;));\nv_all.extend(v2.into_iter().map(|e| Box::new(e) as Box&lt;Foo&gt;));\n</code></pre>\n"}], "owner": {"reputation": 653, "user_id": 2051092, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/6eabdb0f0b8be9a8fef78646df1a392a?s=128&d=identicon&r=PG", "display_name": "GGalizzi", "link": "https://stackoverflow.com/users/2051092/ggalizzi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 300, "favorite_count": 0, "accepted_answer_id": 27876419, "answer_count": 1, "score": 1, "last_activity_date": 1420915027, "creation_date": 1420893697, "last_edit_date": 1420915027, "question_id": 27876328, "link": "https://stackoverflow.com/questions/27876328/how-do-i-create-a-new-vector-of-trait-from-vectors-of-types-that-implement-trait", "title": "How do I create a new vector of Trait from vectors of types that implement Trait?", "body": "<p>I would like to create a new vector that contains objects that implement <code>Trait</code>, from some vectors I already have which contain those objects.</p>\n\n<pre><code>trait Foo {\n    //\n}\n\n\nstruct Bar {\n    i: i32,\n}\n\n\nstruct Baz {\n    c: char,\n}\n\nimpl Foo for Bar {\n    //\n}\n\nimpl Foo for Baz {\n    //\n}\nfn main() {\n    let v1 = vec![Bar{i: 2},Bar{i: 4}];\n    let v2 = vec![Baz{c: '2'},Baz{c: '4'}];\n\n    let mut v_all: Vec&lt;Box&lt;Foo&gt;&gt; = Vec::new();\n\n    v_all.extend(v1.into_iter());\n    v_all.extend(v2.into_iter());\n\n}\n</code></pre>\n\n<p>This of course gets me</p>\n\n<pre><code>&lt;anon&gt;:34:11: 34:33 error: type mismatch resolving `&lt;collections::vec::IntoIter&lt;Bar&gt; as core::iter::Iterator&gt;::Item == Box&lt;Foo&gt;`: expected struct Bar, found box\n&lt;anon&gt;:34     v_all.extend(v1.into_iter());\n</code></pre>\n\n<p>How could I achieve this, if possible?</p>\n"}, {"tags": ["rust", "rust-obsolete"], "answers": [{"tags": [], "owner": {"reputation": 3753, "user_id": 4936, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/a4852818d512c2ed472bdb0ec3e21102?s=128&d=identicon&r=PG", "display_name": "ujh", "link": "https://stackoverflow.com/users/4936/ujh"}, "is_accepted": false, "score": 5, "last_activity_date": 1545775655, "last_edit_date": 1545775655, "creation_date": 1420885967, "answer_id": 27875191, "question_id": 27874987, "link": "https://stackoverflow.com/questions/27874987/why-does-deriveshow-not-work-anymore/27875191#27875191", "title": "Why does #[derive(Show)] not work anymore?", "body": "<p>The answer is to use <code>{:?}</code> instead of <code>{}</code> in <code>format!</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 35, "last_activity_date": 1466302024, "last_edit_date": 1466302024, "creation_date": 1420898918, "answer_id": 27877089, "question_id": 27874987, "link": "https://stackoverflow.com/questions/27874987/why-does-deriveshow-not-work-anymore/27877089#27877089", "title": "Why does #[derive(Show)] not work anymore?", "body": "<p>The old <code>Show</code> trait was split into <code>Display</code> and <code>Debug</code>. </p>\n\n<ul>\n<li><p><code>Display</code> is designed for user-facing output, and uses the blank/default format specifier (e.g. <code>{}</code>, <code>{:.10}</code> <code>{foo:}</code> are all using <code>Display</code>)</p></li>\n<li><p><code>Debug</code> is designed for debugging/internal output and uses the <code>?</code> format specifier (e.g. <code>{:?}</code>, <code>{:.10?}</code>, <code>{foo:?}</code> are all using <code>Debug</code>)</p></li>\n</ul>\n\n<p>Hence, to use the implementation created by <code>#[derive(Debug)]</code> one should write <code>println!(\"{:?}\", ...)</code>, instead of the old <code>println!(\"{}\", ...)</code>.</p>\n\n<p>Only <code>Debug</code> can be <code>#[derive]</code>d since output like <code>Foo { x: 1, y: 2 }</code> is unlikely to be the correct user-facing output, for most situations (I'm sure it is for some, but then the programmer can write the implementation of <code>Display</code> to do that themselves, or even call directly into the <code>#[derive]</code>d <code>Debug</code> implementation).</p>\n\n<p>This was originally described in <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0504-show-stabilization.md\" rel=\"noreferrer\">RFC 504</a> and there is ongoing discussion in <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0565-show-string-guidelines.md\" rel=\"noreferrer\">RFC 565</a>, making the guidelines stated above more concrete.</p>\n"}], "owner": {"reputation": 3753, "user_id": 4936, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/a4852818d512c2ed472bdb0ec3e21102?s=128&d=identicon&r=PG", "display_name": "ujh", "link": "https://stackoverflow.com/users/4936/ujh"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 4703, "favorite_count": 1, "accepted_answer_id": 27877089, "answer_count": 2, "score": 17, "last_activity_date": 1545775655, "creation_date": 1420884423, "last_edit_date": 1533123746, "question_id": 27874987, "link": "https://stackoverflow.com/questions/27874987/why-does-deriveshow-not-work-anymore", "title": "Why does #[derive(Show)] not work anymore?", "body": "<p>With today's Rust nightly the following code doesn't compile anymore:</p>\n\n<pre><code>#[derive(Show)]\nenum S {\n    A,\n    B\n}\n\nfn main() {\n    println!(\"{}\", S::A);\n}\n</code></pre>\n\n<p>Instead it gives me the following error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: the trait `core::fmt::String` is not implemented for the type `S`\n</code></pre>\n\n<p>Is there a way to get the old behaviour? Surely it can't be required to implement this by hand for each type.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 435, "user_id": 1606142, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/837e585e17c9927f0bb14ddcc3e67a11?s=128&d=identicon&r=PG", "display_name": "JONNALAGADDA Srinivas", "link": "https://stackoverflow.com/users/1606142/jonnalagadda-srinivas"}, "edited": false, "score": 0, "creation_date": 1420885852, "post_id": 27874998, "comment_id": 44151923, "body": "In which case, both those closures clearly satisfy the type <code>Fn(i64) -&gt; bool</code>.  Why should we create another type parameter with exactly the same constraint?  [Also addressing @DK.]  Thanks."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 435, "user_id": 1606142, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/837e585e17c9927f0bb14ddcc3e67a11?s=128&d=identicon&r=PG", "display_name": "JONNALAGADDA Srinivas", "link": "https://stackoverflow.com/users/1606142/jonnalagadda-srinivas"}, "edited": false, "score": 1, "creation_date": 1420894898, "post_id": 27874998, "comment_id": 44154372, "body": "It is by far the simplest model to implement to produce a unique type for each closure, and given the nature of unboxed closures it is the only really sensible model. Even though it would be possible to merge <i>some</i> of them, for cases with the same signatures and captured variables and types, to do so would lead to a great deal more confusion in the significant majority of cases."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "reply_to_user": {"reputation": 435, "user_id": 1606142, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/837e585e17c9927f0bb14ddcc3e67a11?s=128&d=identicon&r=PG", "display_name": "JONNALAGADDA Srinivas", "link": "https://stackoverflow.com/users/1606142/jonnalagadda-srinivas"}, "edited": false, "score": 1, "creation_date": 1420895489, "post_id": 27874998, "comment_id": 44154517, "body": "As I said, each closure is of a unique type, and each generic type binds to exactly one type, so it follows from that that if you want to pass two different closures you will need two generic parameters."}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": false, "score": 2, "last_activity_date": 1420884534, "creation_date": 1420884534, "answer_id": 27874998, "question_id": 27874683, "link": "https://stackoverflow.com/questions/27874683/types-of-unboxed-closures-being-unique-to-each/27874998#27874998", "title": "Types of unboxed closures being unique to each", "body": "<p>Every single closure that is written has a unique type. The compiler basically turns it into a structure with fields to store each variable that is closed over, and implements one of the <code>Fn*</code> traits (<a href=\"http://doc.rust-lang.org/std/ops/trait.Fn.html\" rel=\"nofollow\"><code>Fn</code></a>, <a href=\"http://doc.rust-lang.org/std/ops/trait.FnMut.html\" rel=\"nofollow\"><code>FnMut</code></a> and <a href=\"http://doc.rust-lang.org/std/ops/trait.FnOnce.html\" rel=\"nofollow\"><code>FnOnce</code></a>) for it with an appropriate signature, e.g. <code>Fn(i64) -&gt; bool</code>, a.k.a. <code>Fn&lt;(i64,), bool&gt;</code>.</p>\n\n<p>This is why it is using the regular generic constraint syntax, because that is exactly what is going on.</p>\n"}, {"comments": [{"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 0, "creation_date": 1420938650, "post_id": 27875000, "comment_id": 44167703, "body": "We must write <code>Fn(X) -&gt; Y</code> rather than <code>Fn&lt;(X,), Y&gt;</code> (which is considered unstable, and therefore will be unusable in stable releases of Rust) because the Rust team wants to retain the option of switching <code>Fn</code> and friends to have a variable number of type parameters, in case this feature gets implemented in Rust eventually (it&#39;s not planned for 1.0, anyway)."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 1, "last_activity_date": 1420884545, "creation_date": 1420884545, "answer_id": 27875000, "question_id": 27874683, "link": "https://stackoverflow.com/questions/27874683/types-of-unboxed-closures-being-unique-to-each/27875000#27875000", "title": "Types of unboxed closures being unique to each", "body": "<p>The word \"signature\" implies that the two closure types are the same, but they aren't.  It's more useful to look at them as constraints.  For reference:</p>\n\n<pre><code>fn fizzbuzz&lt;F1, F2&gt;(n: i64, f: F1, fs: &amp;str, b: F2, bs: &amp;str)\n    where F1: Fn(i64) -&gt; bool,\n          F2: Fn(i64) -&gt; bool\n</code></pre>\n\n<p>This doesn't say \"<code>F1</code> is the type <code>Fn(i64) -&gt; bool</code>\", it says: \"<code>F1</code> must be a type which implements the <code>Fn(i64) -&gt; bool</code> signature\".  It's like how there are many different types which implement the <code>Iterator</code> trait, but which all implement the same interface.</p>\n\n<p>In fact, things like <code>Fn(i64) -&gt; bool</code> are actually just traits in disguise, but (if I recall correctly), the syntax for this isn't quite ready yet.  In earlier versions, you could write this as <code>Fn&lt;(i64,), bool&gt;</code>.</p>\n"}, {"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 3, "last_activity_date": 1420888277, "last_edit_date": 1420888277, "creation_date": 1420887908, "answer_id": 27875501, "question_id": 27874683, "link": "https://stackoverflow.com/questions/27874683/types-of-unboxed-closures-being-unique-to-each/27875501#27875501", "title": "Types of unboxed closures being unique to each", "body": "<p>Again, I want to start with the same example as in that answer. Compare this:</p>\n\n<pre><code>fn show_both_1&lt;S: Show&gt;(x: S, y: S) {\n    println!(\"{:?} {:?}\", x, y);\n}\n</code></pre>\n\n<p>and this:</p>\n\n<pre><code>fn show_both_2&lt;S1: Show, S2: Show&gt;(x: S1, y: S2) {\n    println!(\"{:?} {:?}\", x, y);\n}\n</code></pre>\n\n<p>(now using <code>{:?}</code> instead of <code>{}</code> because of the recent changes)</p>\n\n<p>The first function requires that <em>both arguments must have the same type</em>, even though this type can be arbitrary as long as it implements <code>Show</code>:</p>\n\n<pre><code>show_both_1::&lt;i32&gt;(1i32, 2i32);      // ok\nshow_both_1::&lt;f64&gt;(1.0f64, 2.0f64);  // ok\nshow_both_1::&lt;???&gt;(1i32, 2.0f64);    // not ok!\n</code></pre>\n\n<p>Obviously the last function call does not make sense, because types of the arguments are different, but the function wants them to have the same type. You can't even write the type parameter explicitly - should it be <code>i32</code> or <code>f64</code>?</p>\n\n<p>The second function allows different types, so all of these calls are ok:</p>\n\n<pre><code>show_both_2::&lt;i32, i32&gt;(1, 2);\nshow_both_2::&lt;f64, f64&gt;(1.0, 2.0);\nshow_both_2::&lt;i32, f64&gt;(1, 2.0);\n</code></pre>\n\n<p>Now for each argument a different type parameter is used, so it is perfectly fine to pass values of different types, as long as both of these types implement <code>Show</code>.</p>\n\n<p>Absolutely the same thing happens with closures. For each closure the compiler generates <em>a new unique type</em> which implements one of <code>Fn*</code> traits. These types are anonymous, so you can't name them:</p>\n\n<pre><code>let f: ??? = |&amp;: x: i32, y: i32| x + y;\n</code></pre>\n\n<p>There is nothing you can write instead of <code>???</code> above, but there is no need to because the compiler knows which type it has generated for the closure and so it can infer <code>f</code>'s type. What really <em>does</em> matter is that this anonymous type will always implement one of special traits: <a href=\"http://doc.rust-lang.org/std/ops/trait.Fn.html\" rel=\"nofollow\"><code>Fn</code></a>, <a href=\"http://doc.rust-lang.org/std/ops/trait.FnMut.html\" rel=\"nofollow\"><code>FnMut</code></a> or <a href=\"http://doc.rust-lang.org/std/ops/trait.FnOnce.html\" rel=\"nofollow\"><code>FnOnce</code></a>. Consequently if you want your function to accept a closure, you need to pass it an instance of some type which implements one of these traits.</p>\n\n<p>But this is natural job for generics! They are usually used when you want your function to accept some arbitrary type which implements some known trait, and situation with closures is absolutely the same. So you have this:</p>\n\n<pre><code>fn call_closure&lt;F: FnMut(i64) -&gt; bool&gt;(f: F) -&gt; bool {\n    f(10)\n}\n</code></pre>\n\n<p>Because this function argument has generic type, this function can be used with any type which implements <code>FnMut(i64) -&gt; bool</code> trait (which is just a shorthand for <code>FnMut&lt;(i64,), bool&gt;</code>, including anonymous types for closures generated by the compiler:</p>\n\n<pre><code>call_closure(|x| x &gt; 10);\ncall_closure(|x| x == 42);\n</code></pre>\n\n<p>The compiler will generate a unique type for each of these closures, but since these generated types will implement <code>FnMut(i64) -&gt; bool</code> trait, <code>call_closure</code> will happily accept both of them.</p>\n\n<p>The situation with different type parameters which I described in the beginning naturally extends to closures because the same mechanism is used here, that is, traits.</p>\n\n<pre><code>fn call_closures_2&lt;F: FnMut(i64) -&gt; bool&gt;(f1: F, f2: F) -&gt; bool {\n    f1(10) &amp;&amp; f2(20)\n}\n</code></pre>\n\n<p>This function accepts two arguments which must be <em>of the same type</em> as long as this type implements <code>FnMut(i64) -&gt; bool</code> trait. And this means that this invocation won't work:</p>\n\n<pre><code>call_closures_2(|x| x &gt; 9, |x| x == 20)\n</code></pre>\n\n<p>It won't work because these closures have <em>unique</em>, i.e. different types, but the function requires that the types must be the same. For example, this does work:</p>\n\n<pre><code>fn call_closures_3&lt;F: Fn(i64) -&gt; bool&gt;(f1: &amp;F, f2: &amp;F) -&gt; bool {\n    f1(10) &amp;&amp; f2(20)\n}\n\nlet f = |&amp;: x: i64| x == 10;\ncall_closures_3(&amp;f, &amp;f);\n</code></pre>\n\n<p>Note that the function arguments must still be of the same type (now references for the convenience of the example), but since we call it with references to the same closure, their type <em>is</em> the same, and everything works fine. This is not very useful though because it is very limiting - usually you want to provide different closures to functions which takes several ones.</p>\n\n<p>For this reason the function needs <em>separate</em> type parameters in order to accept different closures:</p>\n\n<pre><code>fn call_closures_4&lt;F1, F2&gt;(f1: F1, f2: F2) -&gt; bool\n        where F1: FnMut(i64) -&gt; bool,\n              F2: FnMut(i64) -&gt; bool {\n    f1(10) &amp;&amp; f2(20)\n}\n\ncall_closures_4(|x| x &gt;= 9, |x| x &lt;= 42)\n</code></pre>\n\n<p>Now type parameters are independent, and even though closures have different anonymous types, it is ok to call this function with them: <code>F1</code> will become the generated type of the first closure and <code>F2</code> will become the generated type of the second closure.</p>\n"}], "owner": {"reputation": 435, "user_id": 1606142, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/837e585e17c9927f0bb14ddcc3e67a11?s=128&d=identicon&r=PG", "display_name": "JONNALAGADDA Srinivas", "link": "https://stackoverflow.com/users/1606142/jonnalagadda-srinivas"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 393, "favorite_count": 0, "accepted_answer_id": 27875501, "answer_count": 3, "score": 0, "last_activity_date": 1420888277, "creation_date": 1420881898, "last_edit_date": 1495542308, "question_id": 27874683, "link": "https://stackoverflow.com/questions/27874683/types-of-unboxed-closures-being-unique-to-each", "title": "Types of unboxed closures being unique to each", "body": "<p>This is in the context of the question at <a href=\"https://stackoverflow.com/questions/27867765/error-message-with-unboxed-closures\">Error message with unboxed closures</a>.  The answers point out that Rust generates a type each that is unique to each closure, since each of them can potentially capture a different set of variables from the enclosing scope(s).</p>\n\n<p>Here is my question.  The two different closure types in that FizzBuzz example are labelled differently, but look identical.  How does the compiler resolve the closure type differences while still looking at the identical signatures of the type parameters?</p>\n\n<p>This gap between what the compiler sees and what the programmer sees is confusing.</p>\n\n<p>Thanks.</p>\n\n<p>Edit: By the way, Rust Reference document Section 8.1.10 does not yet say anything about this.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 15641, "user_id": 1567738, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1065193e064ef75f6278754f7f02abb6?s=128&d=identicon&r=PG", "display_name": "Intermernet", "link": "https://stackoverflow.com/users/1567738/intermernet"}, "edited": false, "score": 0, "creation_date": 1420882194, "post_id": 27874680, "comment_id": 44151151, "body": "I think you&#39;ll need to pipe the output of <code>rustdoc</code> into an HTML parser, and then grep that for the function. You could probably set up a simple shell script to do this, or even a shell alias. Have a look at <a href=\"http://www.w3.org/Tools/HTML-XML-utils/\" rel=\"nofollow noreferrer\">w3.org/Tools/HTML-XML-utils</a> (should be available on most Unices), in particular <code>hxextract</code>."}, {"owner": {"reputation": 1365, "user_id": 2397446, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/a17ea754d407238ea83415d1b6145f79?s=128&d=identicon&r=PG", "display_name": "Piyush Chauhan", "link": "https://stackoverflow.com/users/2397446/piyush-chauhan"}, "reply_to_user": {"reputation": 15641, "user_id": 1567738, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1065193e064ef75f6278754f7f02abb6?s=128&d=identicon&r=PG", "display_name": "Intermernet", "link": "https://stackoverflow.com/users/1567738/intermernet"}, "edited": false, "score": 0, "creation_date": 1420882392, "post_id": 27874680, "comment_id": 44151191, "body": "I&#39;m not much of sysadmin guy, maybe if you can elaborate because when I type <code>rustdoc vec::each</code>, I get error. Piping the output of error won&#39;t do much good."}, {"owner": {"reputation": 15641, "user_id": 1567738, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1065193e064ef75f6278754f7f02abb6?s=128&d=identicon&r=PG", "display_name": "Intermernet", "link": "https://stackoverflow.com/users/1567738/intermernet"}, "edited": false, "score": 1, "creation_date": 1420882538, "post_id": 27874680, "comment_id": 44151215, "body": "I don&#39;t think you can do that yet. See <a href=\"https://github.com/rust-lang/rust/issues/2207\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/2207</a> . It&#39;s probably not too far off though, they&#39;re moving very quickly at the moment!"}, {"owner": {"reputation": 1365, "user_id": 2397446, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/a17ea754d407238ea83415d1b6145f79?s=128&d=identicon&r=PG", "display_name": "Piyush Chauhan", "link": "https://stackoverflow.com/users/2397446/piyush-chauhan"}, "reply_to_user": {"reputation": 15641, "user_id": 1567738, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/1065193e064ef75f6278754f7f02abb6?s=128&d=identicon&r=PG", "display_name": "Intermernet", "link": "https://stackoverflow.com/users/1567738/intermernet"}, "edited": false, "score": 0, "creation_date": 1420882737, "post_id": 27874680, "comment_id": 44151262, "body": "I will leave this question open then, in future if any answers arrive, Thanks :)"}], "answers": [{"tags": [], "owner": {"reputation": 11388, "user_id": 220485, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/bTrsL.jpg?s=128&g=1", "display_name": "Daniel Fath", "link": "https://stackoverflow.com/users/220485/daniel-fath"}, "is_accepted": false, "score": 1, "last_activity_date": 1420949822, "creation_date": 1420949822, "answer_id": 27883911, "question_id": 27874680, "link": "https://stackoverflow.com/questions/27874680/how-do-i-access-the-api-documentation-from-the-command-line-on-linux/27883911#27883911", "title": "How do I access the API documentation from the command line on Linux?", "body": "<p>The only solution so far would be to use command line browser like lynx and go to  <a href=\"http://doc.rust-lang.org/std/index.html\" rel=\"nofollow\">http://doc.rust-lang.org/std/index.html</a>.</p>\n\n<p>Or as Intermernet noted you could pipe HTML docs into grep function. If I'm not mistaken, the nightlies should come with complied docs, if you require API docs.</p>\n"}, {"tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": false, "score": 9, "last_activity_date": 1440645114, "last_edit_date": 1440645114, "creation_date": 1420994940, "answer_id": 27889556, "question_id": 27874680, "link": "https://stackoverflow.com/questions/27874680/how-do-i-access-the-api-documentation-from-the-command-line-on-linux/27889556#27889556", "title": "How do I access the API documentation from the command line on Linux?", "body": "<p>We don't have a tool like this yet, but would like one. <a href=\"https://github.com/rust-lang/rfcs/issues/650\" rel=\"noreferrer\">https://github.com/rust-lang/rfcs/issues/650</a> is tracking this issue.  </p>\n\n<p>( Formerly tracked as <a href=\"https://github.com/rust-lang/rust/issues/6160\" rel=\"noreferrer\">https://github.com/rust-lang/rust/issues/6160</a> )</p>\n"}, {"tags": [], "owner": {"reputation": 46350, "user_id": 246616, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/deb5db496ae1d5e7dbdcaa38f3c9b31b?s=128&d=identicon&r=PG", "display_name": "mVChr", "link": "https://stackoverflow.com/users/246616/mvchr"}, "is_accepted": false, "score": 1, "last_activity_date": 1484007194, "creation_date": 1484007194, "answer_id": 41559175, "question_id": 27874680, "link": "https://stackoverflow.com/questions/27874680/how-do-i-access-the-api-documentation-from-the-command-line-on-linux/41559175#41559175", "title": "How do I access the API documentation from the command line on Linux?", "body": "<p>I created a small shell function to generate and open the docs within a project in the terminal using <a href=\"http://pandoc.org/\" rel=\"nofollow noreferrer\">pandoc</a> and <a href=\"http://lynx.invisible-island.net/\" rel=\"nofollow noreferrer\">lynx</a>:</p>\n\n<pre><code>cli-rustdoc () {\n    cargo doc -p \"$1\"; pandoc \"target/doc/$1/index.html\" | lynx -stdin\n}\n</code></pre>\n\n<p>Usage example: <code>$ cli-rustdoc rand</code></p>\n\n<p>Not perfect, but it does the trick for the most part.</p>\n"}], "owner": {"reputation": 1365, "user_id": 2397446, "user_type": "registered", "accept_rate": 69, "profile_image": "https://www.gravatar.com/avatar/a17ea754d407238ea83415d1b6145f79?s=128&d=identicon&r=PG", "display_name": "Piyush Chauhan", "link": "https://stackoverflow.com/users/2397446/piyush-chauhan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2354, "favorite_count": 1, "answer_count": 3, "score": 10, "last_activity_date": 1518569905, "creation_date": 1420881870, "last_edit_date": 1518569905, "question_id": 27874680, "link": "https://stackoverflow.com/questions/27874680/how-do-i-access-the-api-documentation-from-the-command-line-on-linux", "title": "How do I access the API documentation from the command line on Linux?", "body": "<p>Is there a command to access rust-lang api documentation from the linux command line?</p>\n\n<p>I'm after something similar to this example for golang documentation:</p>\n\n<p><code>godoc strings Contains</code></p>\n\n<p>which gives the output:</p>\n\n<blockquote>\n  <p>PACKAGE DOCUMENTATION</p>\n  \n  <p>package strings\n      import \"strings\"</p>\n  \n  <p>FUNCTIONS</p>\n  \n  <p>func Contains(s, substr string) bool\n      Contains returns true if substr is within s.</p>\n</blockquote>\n\n<p>I know there is a <code>rustdoc</code> command, but it only generates documentation, it doesn't display it.</p>\n"}, {"tags": ["io", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1420863309, "post_id": 27872753, "comment_id": 44147874, "body": "It&#39;s not, it&#39;s due to your code. :-)"}, {"owner": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "edited": false, "score": 1, "creation_date": 1421082323, "post_id": 27872753, "comment_id": 44213516, "body": "This equates to a potential deprecation warning, but where the replacement is not yet implemented. How do I squelch such warnings?"}, {"owner": {"reputation": 8176, "user_id": 314345, "user_type": "registered", "accept_rate": 67, "profile_image": "https://www.gravatar.com/avatar/d2c8b7c25f4cd87a65001a2f952c0008?s=128&d=identicon&r=PG", "display_name": "dhardy", "link": "https://stackoverflow.com/users/314345/dhardy"}, "edited": false, "score": 7, "creation_date": 1421165912, "post_id": 27872753, "comment_id": 44250249, "body": "To answer my question: <code>#![allow(unstable)]</code> does the trick."}], "answers": [{"comments": [{"owner": {"reputation": 4877, "user_id": 1924257, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/31d8a68147c1d5a6b07b9c0743903ea2?s=128&d=identicon&r=PG", "display_name": "wegry", "link": "https://stackoverflow.com/users/1924257/wegry"}, "edited": false, "score": 0, "creation_date": 1420863600, "post_id": 27872801, "comment_id": 44147921, "body": "Is there a roadmap for IO anywhere? Maybe in the rust repo?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 4877, "user_id": 1924257, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/31d8a68147c1d5a6b07b9c0743903ea2?s=128&d=identicon&r=PG", "display_name": "wegry", "link": "https://stackoverflow.com/users/1924257/wegry"}, "edited": false, "score": 6, "creation_date": 1420863782, "post_id": 27872801, "comment_id": 44147949, "body": "The two I know of would be the <a href=\"https://github.com/rust-lang/rust/issues/20761\" rel=\"nofollow noreferrer\">beta stabilization metabug</a> and the <a href=\"https://github.com/rust-lang/rfcs/pull/517/\" rel=\"nofollow noreferrer\">IO reform RFC</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 14, "last_activity_date": 1422113242, "last_edit_date": 1422113242, "creation_date": 1420863430, "answer_id": 27872801, "question_id": 27872753, "link": "https://stackoverflow.com/questions/27872753/what-is-warnunstable-about-in-rust/27872801#27872801", "title": "What is #[warn(unstable)] about in Rust?", "body": "<p>For the 1.0 release, Rust wants to provide a very strong guarantee about what features of the language and standard library will be available for the <em>entire life of the language</em>. This is not an easy feat!</p>\n\n<p>New, untested, or just not-fully-cooked features will be marked with a stability attribute, and you <a href=\"http://blog.rust-lang.org/2014/12/12/1.0-Timeline.html\" rel=\"nofollow\">won't be able to use unstable features in the beta or release</a>. You will only be able to use them in the nightly builds.</p>\n\n<p>During the <em>alpha</em> however, they are simply warnings. If you need to use a feature in the alpha and it's marked as <code>unstable</code>, then you will want to make sure it becomes stable (or you find an alternate solution) before the beta!</p>\n\n<p>In this case, the entire IO subsystem is undergoing last-minute changes, so it's marked as unstable.</p>\n\n<p><strong>Edit 1</strong></p>\n\n<p>When <a href=\"https://github.com/rust-lang/rust/pull/21543\" rel=\"nofollow\">PR 21543</a> lands, the current world known as <code>std::io</code> will be renamed as <code>std::old_io</code>. Newly-written code will go into <code>std::io</code> and the old version will be deprecated.</p>\n"}], "owner": {"reputation": 4877, "user_id": 1924257, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/31d8a68147c1d5a6b07b9c0743903ea2?s=128&d=identicon&r=PG", "display_name": "wegry", "link": "https://stackoverflow.com/users/1924257/wegry"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3513, "favorite_count": 0, "accepted_answer_id": 27872801, "answer_count": 1, "score": 13, "last_activity_date": 1422113242, "creation_date": 1420862716, "last_edit_date": 1420863465, "question_id": 27872753, "link": "https://stackoverflow.com/questions/27872753/what-is-warnunstable-about-in-rust", "title": "What is #[warn(unstable)] about in Rust?", "body": "<p>I have a really simple cat function written in the Rust 1.0 alpha.</p>\n\n<pre><code>use std::io;\n\nfn main(){\n    let mut reader = io::stdin();\n    loop {\n        let input = reader.read_line().ok().expect(\"Failed to read line\");\n        print!(\"{}\", input);\n    }\n}\n</code></pre>\n\n<p>When I compile it, I get the following warnings:</p>\n\n<pre><code>bindings.rs:5:26: 5:35 warning: use of unstable item, #[warn(unstable)] on by default\nbindings.rs:5         let mut reader = io::stdin();\n                                       ^~~~~~~~~\nbindings.rs:6:28: 6:39 warning: use of unstable item, #[warn(unstable)] on by default\nbindings.rs:6         let input = reader.read_line().ok().expect(\"Failed to read line\");\n                                         ^~~~~~~~~~~\n</code></pre>\n\n<p>Is there a way to remedy these warnings? </p>\n"}, {"tags": ["testing", "rust", "rust-cargo"], "answers": [{"comments": [{"owner": {"reputation": 813, "user_id": 1453453, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/24d7111ef96c9534289fa27d069594e2?s=128&d=identicon&r=PG", "display_name": "aepsil0n", "link": "https://stackoverflow.com/users/1453453/aepsil0n"}, "edited": false, "score": 0, "creation_date": 1420889499, "post_id": 27872918, "comment_id": 44152936, "body": "So in my case quickcheck is itself a dev-dependency, but also a dependency of a feature of my dependency. In particular, I <a href=\"https://github.com/sebcrozet/nalgebra/pull/74\" rel=\"nofollow noreferrer\">implemented <code>Arbitrary</code> for the types in nalgebra</a>. However, the compiler does not see the optional impls, when I try to depend on the feature as you suggested. I feel like I&#39;m still missing something here."}, {"owner": {"reputation": 813, "user_id": 1453453, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/24d7111ef96c9534289fa27d069594e2?s=128&d=identicon&r=PG", "display_name": "aepsil0n", "link": "https://stackoverflow.com/users/1453453/aepsil0n"}, "edited": false, "score": 0, "creation_date": 1420893187, "post_id": 27872918, "comment_id": 44153931, "body": "Never mind, my problem was that I was mixing a github dep on quickcheck with nalgebra&#39;s crates.io dep on it. Too subtle\u2026"}, {"owner": {"reputation": 765, "user_id": 7246614, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/83eccd212e4687fc66e13aad21796b0b?s=128&d=identicon&r=PG", "display_name": "timotree", "link": "https://stackoverflow.com/users/7246614/timotree"}, "edited": false, "score": 0, "creation_date": 1584648819, "post_id": 27872918, "comment_id": 107508883, "body": "In the case that the normal dependency isn&#39;t a semver-dependency (<code>version = &quot;...&quot;</code>), it works just to put the same path or the same Git repository URL."}], "tags": [], "owner": {"reputation": 10100, "user_id": 619216, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/c07104de771c3b6f6c30be8f592ef8f7?s=128&d=identicon&r=PG", "display_name": "BurntSushi5", "link": "https://stackoverflow.com/users/619216/burntsushi5"}, "is_accepted": true, "score": 10, "last_activity_date": 1420864847, "creation_date": 1420864847, "answer_id": 27872918, "question_id": 27872009, "link": "https://stackoverflow.com/questions/27872009/how-do-i-use-a-feature-of-a-dependency-only-for-testing/27872918#27872918", "title": "How do I use a feature of a dependency only for testing?", "body": "<p>You can <a href=\"http://doc.crates.io/manifest.html#the-[features]-section\">use a feature</a> for a <a href=\"http://doc.crates.io/manifest.html#the-[dev-dependencies.*]-sections\">development dependency</a> just like you would for regular dependencies. In the case of <code>quickcheck</code>, its only feature is <code>collect_impls</code>, so you can add this to your <code>Cargo.toml</code>:</p>\n\n<pre><code>[dev-dependencies.quickcheck]\nversion = \"*\"\nfeatures = [\"collect_impls\"]\n</code></pre>\n\n<p>N.B. This was actually done wrong inside of <code>quickcheck</code>. I <a href=\"https://github.com/BurntSushi/quickcheck/commit/fa1c6e969965debcd9e2dfbcc199a71e33cd73ea\">just fixed it</a> in <code>0.1.29</code>.</p>\n"}], "owner": {"reputation": 813, "user_id": 1453453, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/24d7111ef96c9534289fa27d069594e2?s=128&d=identicon&r=PG", "display_name": "aepsil0n", "link": "https://stackoverflow.com/users/1453453/aepsil0n"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2224, "favorite_count": 0, "accepted_answer_id": 27872918, "answer_count": 1, "score": 12, "last_activity_date": 1487042344, "creation_date": 1420854434, "last_edit_date": 1487042344, "question_id": 27872009, "link": "https://stackoverflow.com/questions/27872009/how-do-i-use-a-feature-of-a-dependency-only-for-testing", "title": "How do I use a feature of a dependency only for testing?", "body": "<p>Say, I have a crate with a dependency that has an optional feature. Now this feature is mostly useful for testing, but the crate itself is a dependency for the whole code. Is it possible to instruct cargo to use the feature only for testing?</p>\n\n<p>In my concrete example the optional feature depends on <a href=\"https://github.com/BurntSushi/quickcheck\">quickcheck</a>, which I do not necessarily want to make a mandatory dependency for users of my crate.</p>\n"}, {"tags": ["rust", "traits"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420863555, "post_id": 27871755, "comment_id": 44147913, "body": "I assume this is an artifact of how you are asking the question, but your <code>f32</code> case isn&#39;t different from your <code>T</code> case... is it?"}], "answers": [{"tags": [], "owner": {"reputation": 6718, "user_id": 2455707, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/768bc63471394edee20bcd4131186118?s=128&d=identicon&r=PG", "display_name": "reem", "link": "https://stackoverflow.com/users/2455707/reem"}, "is_accepted": true, "score": 5, "last_activity_date": 1420854955, "creation_date": 1420854955, "answer_id": 27872073, "question_id": 27871755, "link": "https://stackoverflow.com/questions/27871755/how-do-i-create-a-custom-implementation-for-a-specific-type/27872073#27872073", "title": "How do I create a custom implementation for a specific type?", "body": "<p>You can't do this, since Rust doesn't currently have impl specialization - there can only be one implementation of any trait (and set of input parameters) for any type, any conflicting implementations yield compiler errors.</p>\n"}], "owner": {"reputation": 152, "user_id": 4438849, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/4b0bf9fca9321e872f166c4205b8437d?s=128&d=identicon&r=PG&f=1", "display_name": "qRoC", "link": "https://stackoverflow.com/users/4438849/qroc"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 169, "favorite_count": 0, "accepted_answer_id": 27872073, "answer_count": 1, "score": 2, "last_activity_date": 1420916571, "creation_date": 1420851927, "last_edit_date": 1420916571, "question_id": 27871755, "link": "https://stackoverflow.com/questions/27871755/how-do-i-create-a-custom-implementation-for-a-specific-type", "title": "How do I create a custom implementation for a specific type?", "body": "<p>I have this code:</p>\n\n<pre><code>pub struct Tuple2&lt;T&gt;(pub T, pub T);\n\n// default realization\nimpl&lt;T: Mul&lt;Output = T&gt;&gt; Mul&lt;Tuple2&lt;T&gt;&gt; for Tuple2&lt;T&gt;\n{\n    type Output = Tuple2&lt;T&gt;;\n\n    fn mul(self, rhs: Tuple2&lt;T&gt;) -&gt; Tuple2&lt;T&gt; \n    {\n        Tuple2(self.0 * rhs.0, self.1 * rhs.1)\n    }\n}\n</code></pre>\n\n<p>Now I want to override the method for <code>Tuple2&lt;f32&gt;</code>:</p>\n\n<pre><code>// specific realization for f32\nimpl Mul&lt;Tuple2&lt;f32&gt;&gt; for Tuple2&lt;f32&gt;\n{\n    type Output = Tuple2&lt;f32&gt;;\n\n    fn mul(self, rhs: Tuple2&lt;f32&gt;) -&gt; Tuple2&lt;f32&gt; \n    {\n        // custom code\n        Tuple2(self.0 * rhs.0, self.1 * rhs.1)\n    }\n}\n</code></pre>\n\n<p>Error:\n    conflicting implementations for trait <code>core::ops::Mul</code> [E0119]</p>\n"}, {"tags": ["string", "pattern-matching", "rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420862725, "post_id": 27872487, "comment_id": 44147779, "body": "As a minor optimization, you could use <code>let first_args = &amp;args[1];</code> This prevents making a new allocated string. You would then need to use <code>match &amp;**first_args</code>."}, {"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420937031, "post_id": 27872487, "comment_id": 44167346, "body": "@Shepmaster: Even better: <code>let first_args = &amp;*args[1]; match first_args { ...</code>"}, {"owner": {"reputation": 127, "user_id": 4467214, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/I35OW.png?s=128&g=1", "display_name": "Abrar Khan", "link": "https://stackoverflow.com/users/4467214/abrar-khan"}, "edited": false, "score": 0, "creation_date": 1575821084, "post_id": 27872487, "comment_id": 104685957, "body": "use <code>first_args.as_str()</code> or <code>first_args.as_ref()</code>."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 7, "last_activity_date": 1420862894, "last_edit_date": 1420862894, "creation_date": 1420859355, "answer_id": 27872487, "question_id": 27871633, "link": "https://stackoverflow.com/questions/27871633/matching-a-string/27872487#27872487", "title": "Matching a string", "body": "<p>There are two kinds of strings in Rust, as explained by the <a href=\"http://doc.rust-lang.org/book/strings.html\">Strings section of the Rust Book</a>.  Short version: there's strings that <em>own</em> their contents (<code>String</code>), and strings that don't (<code>&amp;str</code>).</p>\n\n<p><code>first_args</code> is <code>String</code>, but string literals are <code>&amp;str</code>s (as noted by the error).  To do this, you need to turn <code>first_args</code> back into a borrowed string, like so:</p>\n\n<pre><code>fn main() {\n    let args = os::args();\n    let first_args = args[1].to_string();\n    match &amp;*first_args {\n        \"test\" =&gt; println!(\"Good!\"),\n        _      =&gt; println!(\"No test ?!\"),\n    }\n}\n</code></pre>\n\n<p>To just clarify what <code>&amp;*</code> does: owning containers (like <code>String</code> and <code>Vec</code>) can \"decay\" into borrowed references to their contents.  <code>*</code> is used to \"dereference\" the container into its contents (<em>i.e.</em> <code>*first_args</code> takes the <code>String</code> and provides access to the underlying <code>str</code>), whilst the <code>&amp;</code> re-borrows that value, turning it back into a regular reference.</p>\n"}], "owner": {"reputation": 6831, "user_id": 501800, "user_type": "registered", "accept_rate": 55, "profile_image": "https://www.gravatar.com/avatar/5fc72638da7598b350733c5a51fce596?s=128&d=identicon&r=PG", "display_name": "Muhammad Lukman Low", "link": "https://stackoverflow.com/users/501800/muhammad-lukman-low"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 610, "favorite_count": 0, "closed_date": 1482413161, "accepted_answer_id": 27872487, "answer_count": 1, "score": 1, "last_activity_date": 1420862894, "creation_date": 1420850868, "last_edit_date": 1420862851, "question_id": 27871633, "link": "https://stackoverflow.com/questions/27871633/matching-a-string", "closed_reason": "Duplicate", "title": "Matching a string", "body": "<p>I have this</p>\n\n<pre><code>fn main() {\n    let args = os::args();\n    let first_args = args[1].to_string();\n    match first_args {\n        \"test\" =&gt; println!(\"Good!\"),\n        _      =&gt; println!(\"No test ?!\"),\n    }\n}\n</code></pre>\n\n<p>but during compilation, I get this error:</p>\n\n<pre><code>error: mismatched types: expected `collections::string::String`, found `&amp;'static str` (expected struct collections::string::String, found &amp;-ptr)\nsrc/command_line_arguments.rs:7         \"test\" =&gt; println!(\"Good!\"),\n                                        ^~~~~~\n</code></pre>\n\n<p>Can someone please help me to understand this better? What would be a better way of doing this?</p>\n"}, {"tags": ["string", "file", "rust", "duplicate-removal"], "comments": [{"owner": {"reputation": 1556, "user_id": 4430998, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7c720a12ccc8a8aef8204eb794be8c1a?s=128&d=identicon&r=PG&f=1", "display_name": "Jarlax", "link": "https://stackoverflow.com/users/4430998/jarlax"}, "edited": false, "score": 0, "creation_date": 1420850023, "post_id": 27871299, "comment_id": 44145490, "body": "Are you interested in algorithm how to do this general or question is about rust specifically?"}, {"owner": {"reputation": 1776, "user_id": 4435175, "user_type": "registered", "accept_rate": 68, "profile_image": "https://i.stack.imgur.com/UCpoD.gif?s=128&g=1", "display_name": "Vega", "link": "https://stackoverflow.com/users/4435175/vega"}, "reply_to_user": {"reputation": 1556, "user_id": 4430998, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/7c720a12ccc8a8aef8204eb794be8c1a?s=128&d=identicon&r=PG&f=1", "display_name": "Jarlax", "link": "https://stackoverflow.com/users/4430998/jarlax"}, "edited": false, "score": 0, "creation_date": 1420851040, "post_id": 27871299, "comment_id": 44145783, "body": "Both ;). I want to improve my Rust abilites and my regular programer skillset and so I try some real life scripts for fun."}], "answers": [{"comments": [{"owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "edited": false, "score": 1, "creation_date": 1420936504, "post_id": 27871542, "comment_id": 44167222, "body": "Using <code>BTreeSet</code> instead of <code>HashSet</code> (and <code>.into_iter()</code> instead of <code>.drain()</code>) will have the lines sorted."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 3, "last_activity_date": 1594064259, "last_edit_date": 1594064259, "creation_date": 1420850090, "answer_id": 27871542, "question_id": 27871299, "link": "https://stackoverflow.com/questions/27871299/how-can-i-read-a-file-line-by-line-eliminate-duplicates-then-write-back-to-the/27871542#27871542", "title": "How can I read a file line-by-line, eliminate duplicates, then write back to the same file?", "body": "<p>Ultimately, you are going to run into a problem: you are trying to write to the same file you are reading from. In <em>this</em> case, it's safe because you are going to read the entire file, so you don't need it after that. However, if you <em>did</em> try to write to the file, you'd see that opening a file for reading doesn't allow writing! Here's the code to do that:</p>\n<pre><code>use std::{\n    fs::File,\n    io::{BufRead, BufReader, Write},\n};\n\nfn main() {\n    let mut file = File::open(&quot;test.txt&quot;).expect(&quot;file error&quot;);\n    let reader = BufReader::new(&amp;mut file);\n\n    let mut lines: Vec&lt;_&gt; = reader\n        .lines()\n        .map(|l| l.expect(&quot;Couldn't read a line&quot;))\n        .collect();\n\n    lines.sort();\n    lines.dedup();\n\n    for line in lines {\n        file.write_all(line.as_bytes())\n            .expect(&quot;Couldn't write to file&quot;);\n    }\n}\n</code></pre>\n<p>Here's the output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>% cat test.txt\n    a\n    a\n    b\n    a\n                                                                                                                                                                                                                                     % cargo run\nthread 'main' panicked at 'Couldn't write to file: Os { code: 9, kind: Other, message: &quot;Bad file descriptor&quot; }', src/main.rs:12:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre>\n<p>You could open the file for both reading and writing:</p>\n<pre><code>use std::{\n    fs::OpenOptions,\n    io::{BufRead, BufReader, Write},\n};\n\nfn main() {\n    let mut file = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .open(&quot;test.txt&quot;)\n        .expect(&quot;file error&quot;);\n\n    // Remaining code unchanged\n}\n</code></pre>\n<p>But then you'd see that (a) the output is <em>appended</em> and (b) all the newlines are lost on the new lines because <code>BufRead</code> doesn't include them.</p>\n<p>We <em>could</em> reset the file pointer back to the beginning, but then you'd probably leave trailing stuff at the end (deduplicating is likely to have less bytes written than read). It's easier to just reopen the file for writing, which will truncate the file. Also, let's use a set data structure to do the deduplication for us!</p>\n<pre><code>use std::{\n    collections::BTreeSet,\n    fs::File,\n    io::{BufRead, BufReader, Write},\n};\n\nfn main() {\n    let file = File::open(&quot;test.txt&quot;).expect(&quot;file error&quot;);\n    let reader = BufReader::new(file);\n\n    let lines: BTreeSet&lt;_&gt; = reader\n        .lines()\n        .map(|l| l.expect(&quot;Couldn't read a line&quot;))\n        .collect();\n\n    let mut file = File::create(&quot;test.txt&quot;).expect(&quot;file error&quot;);\n\n    for line in lines {\n        file.write_all(line.as_bytes())\n            .expect(&quot;Couldn't write to file&quot;);\n\n        file.write_all(b&quot;\\n&quot;).expect(&quot;Couldn't write to file&quot;);\n    }\n}\n</code></pre>\n<p>And the output:</p>\n<pre><code>% cat test.txt\na\na\nb\na\na\nb\na\nb\n\n% cargo run\n% cat test.txt\na\nb\n</code></pre>\n<p>The less-efficient but shorter solution is to read the entire file as one string and use <code>str::lines</code>:</p>\n<pre><code>use std::{\n    collections::BTreeSet,\n    fs::{self, File},\n    io::Write,\n};\n\nfn main() {\n    let contents = fs::read_to_string(&quot;test.txt&quot;).expect(&quot;can't read&quot;);\n    let lines: BTreeSet&lt;_&gt; = contents.lines().collect();\n\n    let mut file = File::open(&quot;test.txt&quot;).expect(&quot;can't create&quot;);\n    for line in lines {\n        writeln!(file, &quot;{}&quot;, line).expect(&quot;can't write&quot;);\n    }\n}\n</code></pre>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/31192956/155423\">What&#39;s the de-facto way of reading and writing files in Rust 1.x?</a></li>\n<li><a href=\"https://stackoverflow.com/q/30684624/155423\">What is the best variant for appending a new line in a text file?</a></li>\n</ul>\n"}], "owner": {"reputation": 1776, "user_id": 4435175, "user_type": "registered", "accept_rate": 68, "profile_image": "https://i.stack.imgur.com/UCpoD.gif?s=128&g=1", "display_name": "Vega", "link": "https://stackoverflow.com/users/4435175/vega"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1395, "favorite_count": 0, "accepted_answer_id": 27871542, "answer_count": 1, "score": 1, "last_activity_date": 1594064259, "creation_date": 1420848454, "last_edit_date": 1420848858, "question_id": 27871299, "link": "https://stackoverflow.com/questions/27871299/how-can-i-read-a-file-line-by-line-eliminate-duplicates-then-write-back-to-the", "title": "How can I read a file line-by-line, eliminate duplicates, then write back to the same file?", "body": "<p>I want to read a file, eliminate all duplicates and write the rest back into the file - like a duplicate cleaner.\nVec because a normal array has a fixed size but my .txt is flexible (am I doing this right?).</p>\n\n<p>Read, lines in Vec + delete duplices:\nMissing write back to file.</p>\n\n<pre><code>use std::io;\n\nfn main() {\n    let path = Path::new(\"test.txt\");\n    let mut file = io::BufferedReader::new(io::File::open(&amp;path, R));\n\n    let mut lines: Vec&lt;String&gt; = file.lines().map(|x| x.unwrap()).collect();\n    // dedup() deletes all duplicates if sort() before\n    lines.sort();\n    lines.dedup();\n\n    for e in lines.iter() {\n        print!(\"{}\", e.as_slice());\n    }\n}\n</code></pre>\n\n<p>Read + write to file (untested but should work I guess).\nMissing lines to Vec because it doesn't work without BufferedReader as it seems (or I'm doing something else wrong, also a good chance).</p>\n\n<pre><code>use std::io;\n\nfn main() {\n    let path = Path::new(\"test.txt\");\n    let mut file = match io::File::open_mode(&amp;path, io::Open, io::ReadWrite) {\n        Ok(f) =&gt; f,\n        Err(e) =&gt; panic!(\"file error: {}\", e),\n    };  \n    let mut lines: Vec&lt;String&gt; = file.lines().map(|x| x.unwrap()).collect();\n    lines.sort();\n    // dedup() deletes all duplicates if sort() before\n    lines.dedup();\n\n    for e in lines.iter() {\n        file.write(\"{}\", e);\n    }\n} \n</code></pre>\n\n<p>So .... how do I get those 2 together? :)</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 1, "user_id": 1114, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/FFE8V.gif?s=128&g=1", "display_name": "Jeremy", "link": "https://stackoverflow.com/users/1114/jeremy"}, "edited": false, "score": 0, "creation_date": 1420831916, "post_id": 27867765, "comment_id": 44138057, "body": "Please include all details necessary to answer your question (i.e. the code) in the question body itself. Questions should not depend on an external link, because they tend to break in the long term, and we&#39;re trying to build a long-term resource. Cheers."}, {"owner": {"reputation": 4670, "user_id": 731240, "user_type": "registered", "accept_rate": 83, "profile_image": "https://i.stack.imgur.com/BZhQx.jpg?s=128&g=1", "display_name": "dg99", "link": "https://stackoverflow.com/users/731240/dg99"}, "edited": false, "score": 0, "creation_date": 1420831926, "post_id": 27867765, "comment_id": 44138062, "body": "Please include the relevant (and only the relevant) code and the error message directly in your question, rather than asking people to click on potentially untrustworthy links."}], "answers": [{"tags": [], "owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "is_accepted": false, "score": 4, "last_activity_date": 1420832874, "creation_date": 1420832874, "answer_id": 27868080, "question_id": 27867765, "link": "https://stackoverflow.com/questions/27867765/error-message-with-unboxed-closures/27868080#27868080", "title": "Error message with unboxed closures", "body": "<p>Each unboxed closure definition creates a completely different type. This makes each of the closures defined in <code>main</code> a different type. Your <code>fizzbuz</code> function, on the other hand, requires each of the closures passed to it to be the same type, <code>F</code>. If you change <code>fizzbuzz</code>'s signature to:</p>\n\n<pre><code>fn fizzbuzz&lt;F: Fn(i64) -&gt; bool, G: Fn(i64) -&gt; bool&gt;(n: i64, f: F, fs: &amp;str, b: G, bs: &amp;str)\n</code></pre>\n\n<p>your code will typecheck.</p>\n\n<p>Basically, the <code>&lt;F: Fn(i64) -&gt; bool&gt;</code> syntax doesn't create a wildcard for types that implement the trait parameter (<code>Fn(i64) -&gt; bool</code>), but declares a single type which must satisfy the trait parameter and be the same type everywhere it is used. Unboxed closure definitions must be different types both because the may wrap different environments but also because they dispatch to different functions (that is, each has a different body). As a result, <code>fizzbuzz</code> needs two different type parameters to accommodate the two closure types.</p>\n"}, {"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 4, "last_activity_date": 1420879966, "last_edit_date": 1420879966, "creation_date": 1420833029, "answer_id": 27868114, "question_id": 27867765, "link": "https://stackoverflow.com/questions/27867765/error-message-with-unboxed-closures/27868114#27868114", "title": "Error message with unboxed closures", "body": "<p>This piece of code demonstrates the essence of the problem:</p>\n\n<pre><code>fn show_both&lt;S: Show&gt;(x: S, y: S) {\n    println!(\"{} {}\", x, y);\n}\n</code></pre>\n\n<p>You can only call it with both arguments <em>of the same type</em>, i.e. this is allowed:</p>\n\n<pre><code>let x: i32 = 10;\nlet y: i32 = 20;\nshow_both(x, y);\n</code></pre>\n\n<p>But this is not:</p>\n\n<pre><code>let x: i32 = 10;\nlet y: f64 = 20.0;\nshow_both(x, y);\n</code></pre>\n\n<p>This is fairly natural: you specified that <em>both of the parameters</em> must be of the same type, even though this type can be arbitrary as long as it implements <code>Show</code>.</p>\n\n<p>You have essentially the same thing in your code:</p>\n\n<pre><code>fn fizzbuzz&lt;F: Fn(i64) -&gt; bool&gt;(n: i64, f: F, fs: &amp;str, b: F, bs: &amp;str)\n</code></pre>\n\n<p>You declared that both <code>f</code> and <code>b</code> must have <em>the same type</em>. However, for each unboxed closure the compiler generates a <em>different</em> type - this is quite natural as well, given that different closures can capture different variables.</p>\n\n<p>You need to specify different type parameters in order to be able to pass different closures:</p>\n\n<pre><code>fn fizzbuzz&lt;F1, F2&gt;(n: i64, f: F1, fs: &amp;str, b: F2, bs: &amp;str)\n    where F1: Fn(i64) -&gt; bool,\n          F2: Fn(i64) -&gt; bool\n</code></pre>\n"}], "owner": {"reputation": 435, "user_id": 1606142, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/837e585e17c9927f0bb14ddcc3e67a11?s=128&d=identicon&r=PG", "display_name": "JONNALAGADDA Srinivas", "link": "https://stackoverflow.com/users/1606142/jonnalagadda-srinivas"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 170, "favorite_count": 0, "accepted_answer_id": 27868114, "answer_count": 2, "score": 0, "last_activity_date": 1420879966, "creation_date": 1420831649, "last_edit_date": 1420832141, "question_id": 27867765, "link": "https://stackoverflow.com/questions/27867765/error-message-with-unboxed-closures", "title": "Error message with unboxed closures", "body": "<p>This small FizzBuzz program using unboxed closures gives a rather mysterious error message.</p>\n\n<pre><code>fn fizzbuzz&lt;F: Fn(i64) -&gt; bool&gt;(n: i64, f: F, fs: &amp;str, b: F, bs: &amp;str) {\n    for i in range(1i64, n+1) {\n        match (f(i), b(i)) {\n            (true, true) =&gt; println!(\"{:3}: {}{}\", i, fs, bs),\n            (true, _)    =&gt; println!(\"{:3}: {}\", i, fs),\n            (_, true)    =&gt; println!(\"{:3}: {}\", i, bs),\n            _            =&gt; (),\n        }\n    }\n}\n\nfn main() {\n    fizzbuzz(30,\n             |&amp;: i: i64| { i % 3 == 0 }, \"fizz\",\n             |&amp;: j: i64| { j % 5 == 0 }, \"buzz\");\n}\n</code></pre>\n\n<p>Error message:</p>\n\n<pre><code>&lt;anon&gt;:15:14: 15:40 error: mismatched types: expected `closure[&lt;anon&gt;:14:14: 14:40]`, found `closure[&lt;anon&gt;:15:14: 15:40]` (expected closure, found a different closure)\n&lt;anon&gt;:15              |&amp;: j: i64| { j % 5 == 0 }, \"buzz\");\n                   ^~~~~~~~~~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\n</code></pre>\n\n<p>Could someone describe the error please?  Thanks.</p>\n"}, {"tags": ["arrays", "enums", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420826978, "post_id": 27865837, "comment_id": 44135657, "body": "<code>enum</code>s don&#39;t semantically correspond to a numeric value, like you might expect if you come from C. Could you explain a bit more about what code you&#39;d really like to have?"}], "answers": [{"comments": [{"owner": {"reputation": 9281, "user_id": 569183, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/7a5501609561c72703bb74bbf88ca800?s=128&d=identicon&r=PG", "display_name": "tekknolagi", "link": "https://stackoverflow.com/users/569183/tekknolagi"}, "edited": false, "score": 0, "creation_date": 1420836448, "post_id": 27866823, "comment_id": 44140313, "body": "Hi! I&#39;m trying to make an array of registers that are indexable by enum so that I can do a simple reverse lookup by a string. Basically I don&#39;t want anything special about how I address a register. Not sure if that makes sense."}, {"owner": {"reputation": 9281, "user_id": 569183, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/7a5501609561c72703bb74bbf88ca800?s=128&d=identicon&r=PG", "display_name": "tekknolagi", "link": "https://stackoverflow.com/users/569183/tekknolagi"}, "edited": false, "score": 0, "creation_date": 1420836507, "post_id": 27866823, "comment_id": 44140340, "body": "You can take a look at github.com/tekknolagi/carp/tree/master/src/ if you want. Similar design but perhaps there&#39;s a more idiomatic."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 9281, "user_id": 569183, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/7a5501609561c72703bb74bbf88ca800?s=128&d=identicon&r=PG", "display_name": "tekknolagi", "link": "https://stackoverflow.com/users/569183/tekknolagi"}, "edited": false, "score": 0, "creation_date": 1420840057, "post_id": 27866823, "comment_id": 44141963, "body": "@tekknolagi, I&#39;ve updated my answer to show how I would use strings to identify and then provide access to a specific register."}, {"owner": {"reputation": 9281, "user_id": 569183, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/7a5501609561c72703bb74bbf88ca800?s=128&d=identicon&r=PG", "display_name": "tekknolagi", "link": "https://stackoverflow.com/users/569183/tekknolagi"}, "edited": false, "score": 0, "creation_date": 1420853279, "post_id": 27866823, "comment_id": 44146250, "body": "thank you for taking the time to reply. If I&#39;m going to make a simple VM, is there any cleaner way to go about it? This seems a tiny bit clunky to me. Ignoring Carp for a second \u2014 what&#39;s the way you would create a small bytecode interpreter (at least this section of it)?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 9281, "user_id": 569183, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/7a5501609561c72703bb74bbf88ca800?s=128&d=identicon&r=PG", "display_name": "tekknolagi", "link": "https://stackoverflow.com/users/569183/tekknolagi"}, "edited": false, "score": 0, "creation_date": 1420916782, "post_id": 27866823, "comment_id": 44161718, "body": "I don&#39;t really have any experience in the area of interpreters. Perhaps you can expand on what you find clunky? The big one I see is the duplication between <code>by_name</code> and <code>by_name_mut</code>, but it&#39;s possible a macro could help out there."}, {"owner": {"reputation": 9281, "user_id": 569183, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/7a5501609561c72703bb74bbf88ca800?s=128&d=identicon&r=PG", "display_name": "tekknolagi", "link": "https://stackoverflow.com/users/569183/tekknolagi"}, "edited": false, "score": 0, "creation_date": 1420920445, "post_id": 27866823, "comment_id": 44162871, "body": "it&#39;s alright \u2014 I&#39;ve decided to try and learn Rust better before trying again. Thank you for answering!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1432474396, "last_edit_date": 1432474396, "creation_date": 1420827846, "answer_id": 27866823, "question_id": 27865837, "link": "https://stackoverflow.com/questions/27865837/create-an-array-with-enum-element-size/27866823#27866823", "title": "Create an array with enum element size", "body": "<p>Currently, I don't think Rust is capable of seeing that <code>Enum::Variant</code> is effectively a constant (I don't actually know that it <em>is</em>, either), so it cannot be used as the array length. More than that, I would say that it's strange to add an enum variant that isn't actually intended to be used.</p>\n\n<p>For how I see your problem, I'd probably try to represent your registers as a struct:</p>\n\n<pre><code>struct Registers {\n    ip: u8,\n    sp: u8,\n}\n\nstruct State {\n    val: u8,\n    regs: Registers,\n    running: bool,\n}\n\nfn main() {\n    let s = State {\n        val: 0,\n        regs: Registers { ip: 0, sp: 0 },\n        running: false,\n    };\n}\n</code></pre>\n\n<p><strong>Edit</strong></p>\n\n<p>If you'd like to get a register by name, how about we do that directly:</p>\n\n<pre><code>struct Registers {\n    ip: u8,\n    sp: u8,\n}\n\nimpl Registers {\n    fn by_name(&amp;self, name: &amp;str) -&gt; u8 {\n        match name {\n            \"ip\" =&gt; self.ip,\n            \"sp\" =&gt; self.sp,\n            _ =&gt; panic!(\"Unknown register '{}'\", name),\n        }\n    }\n\n    fn by_name_mut(&amp;mut self, name: &amp;str) -&gt; &amp;mut u8 {\n        match name {\n            \"ip\" =&gt; &amp;mut self.ip,\n            \"sp\" =&gt; &amp;mut self.sp,\n            _ =&gt; panic!(\"Unknown register '{}'\", name),\n        }\n    }\n}\n\nfn main() {\n    let mut r = Registers { ip: 0, sp: 0 };\n\n    println!(\"Instruction pointer: 0x{:02x}\", r.by_name(\"ip\"));\n    *r.by_name_mut(\"ip\") += 1;\n    println!(\"Instruction pointer: 0x{:02x}\", r.by_name(\"ip\"));\n}\n</code></pre>\n\n<p>Although that <code>panic!</code> right there is pretty ugly... I'd rather use an enum for that purpose. Let's do both the enum and the string:</p>\n\n<pre><code>use std::str::FromStr;\n\n#[derive(Debug,Copy,Clone,PartialEq)]\nenum Register {\n    Ip,\n    Sp,\n}\n\nimpl FromStr for Register {\n    type Err = ();\n\n    fn from_str(s: &amp;str) -&gt; Result&lt;Self, ()&gt; {\n        match s {\n            \"ip\" =&gt; Ok(Register::Ip),\n            \"sp\" =&gt; Ok(Register::Sp),\n            _ =&gt; Err(()),\n        }\n    }\n}\n\nstruct Registers {\n    ip: u8,\n    sp: u8,\n}\n\nimpl Registers {\n    fn by_name(&amp;self, name: Register) -&gt; u8 {\n        match name {\n            Register::Ip =&gt; self.ip,\n            Register::Sp =&gt; self.sp,\n        }\n    }\n\n    fn by_name_mut(&amp;mut self, name: Register) -&gt; &amp;mut u8 {\n        match name {\n            Register::Ip =&gt; &amp;mut self.ip,\n            Register::Sp =&gt; &amp;mut self.sp,\n        }\n    }\n}\n\nfn main() {\n    let mut rs = Registers { ip: 0, sp: 0 };\n\n    let r: Register = \"ip\".parse().unwrap();\n\n    println!(\"Instruction pointer: 0x{:02x}\", rs.by_name(r));\n    *rs.by_name_mut(r) += 1;\n    println!(\"Instruction pointer: 0x{:02x}\", rs.by_name(r));\n}\n</code></pre>\n\n<p>Now we have a nice clear separation between transitioning a string to our <code>Register</code> type, which means that only one part of our code has to deal with invalid register names (the call to <code>unwrap</code>).</p>\n"}], "owner": {"reputation": 9281, "user_id": 569183, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/7a5501609561c72703bb74bbf88ca800?s=128&d=identicon&r=PG", "display_name": "tekknolagi", "link": "https://stackoverflow.com/users/569183/tekknolagi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 516, "favorite_count": 0, "accepted_answer_id": 27866823, "answer_count": 1, "score": 0, "last_activity_date": 1432474396, "creation_date": 1420823998, "question_id": 27865837, "link": "https://stackoverflow.com/questions/27865837/create-an-array-with-enum-element-size", "title": "Create an array with enum element size", "body": "<p>I want to create an array of a size specified by an element in an enum, like so:</p>\n\n<pre><code>pub use self::Register::*;\n\nenum Register {\n    Ip,\n    Sp,\n    NumRegs,\n}\n\nstruct State {\n    val: int,\n    regs: [int; NumRegs as int],\n    running: bool,\n}\n</code></pre>\n\n<p>But I get:</p>\n\n<pre><code>src/main.rs:19:11: 19:32 error: expected constant expr for array length: non-constant path in constant expr\nsrc/main.rs:19     regs: [int; NumRegs as int],\n</code></pre>\n\n<p>I've tried using <code>as int</code>, among other solutions, and Googled around for some time, but have not found a solution. Incidentally, is this bad form in Rust?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1420804153, "post_id": 27859822, "comment_id": 44122194, "body": "you could always import the alloca function from c. if you add some kind of overflow checking you might even get it to be safe."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 4, "creation_date": 1420808349, "post_id": 27859822, "comment_id": 44124490, "body": "@ker: That&#39;s unlikely.  <code>alloca</code> isn&#39;t really a function, it&#39;s more a compiler intrinsic.  At least with LLVM, it&#39;s an actual IR instructions, so there&#39;s no direct way of &quot;importing&quot; it.  You&#39;d need to be able to write inline IR, which you currently can&#39;t."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 0, "creation_date": 1420810710, "post_id": 27859822, "comment_id": 44125823, "body": "that makes me wonder what those guys imported: <a href=\"https://github.com/tomaka/cpal/blob/master/alsa-sys/src/lib.rs#L2135\" rel=\"nofollow noreferrer\">github.com/tomaka/cpal/blob/master/alsa-sys/src/lib.rs#L2135</a> ... i was pretty sure it&#39;s a c standard function nowadays (<a href=\"http://man7.org/linux/man-pages/man3/alloca.3.html\" rel=\"nofollow noreferrer\">man7.org/linux/man-pages/man3/alloca.3.html</a>)"}], "answers": [{"comments": [{"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 16, "creation_date": 1420805651, "post_id": 27859911, "comment_id": 44122959, "body": "LLVM is, first and foremost, a C/C++ optimiser, so it likely supports it relatively well."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 1, "creation_date": 1420807785, "post_id": 27859911, "comment_id": 44124131, "body": "Every time I&#39;ve seen it brought up, someone states that dynamically resizing the stack within a block seriously impairs LLVM&#39;s ability to do optimisations.  I&#39;ve never found any solid evidence to either support or refute that, so I&#39;m more or less going with what little I <i>have</i> heard.  Though I&#39;d <i>love</i> to be wrong on this one: stack DSTs would be rather nifty. :)"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1420813932, "post_id": 27859911, "comment_id": 44127641, "body": "I&#39;d guess &quot;interfere with optimisers&quot; it&#39;s a somewhat inherent property of dynamic stack allocations. (That said, it&#39;s could easily be something that the LLVM devs haven&#39;t put much effort in to handling well.)"}, {"owner": {"reputation": 4056, "user_id": 1500501, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/6e52030b5f0d55f0ee00c4e29afa4ce5?s=128&d=identicon&r=PG", "display_name": "Michael Tang", "link": "https://stackoverflow.com/users/1500501/michael-tang"}, "edited": false, "score": 3, "creation_date": 1420838694, "post_id": 27859911, "comment_id": 44141361, "body": "Rust now supports DSTs as a part of the Rust 1.0 alpha! <a href=\"http://blog.rust-lang.org/2015/01/09/Rust-1.0-alpha.html\" rel=\"nofollow noreferrer\">blog.rust-lang.org/2015/01/09/Rust-1.0-alpha.html</a>"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 4056, "user_id": 1500501, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/6e52030b5f0d55f0ee00c4e29afa4ce5?s=128&d=identicon&r=PG", "display_name": "Michael Tang", "link": "https://stackoverflow.com/users/1500501/michael-tang"}, "edited": false, "score": 3, "creation_date": 1420851764, "post_id": 27859911, "comment_id": 44145962, "body": "@MichaelTang: Rust has supported DSTs for a while.  Unless I&#39;m missing something, it <i>doesn&#39;t</i> support storing DSTs in variables, or returning them from functions."}, {"owner": {"reputation": 4056, "user_id": 1500501, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/6e52030b5f0d55f0ee00c4e29afa4ce5?s=128&d=identicon&r=PG", "display_name": "Michael Tang", "link": "https://stackoverflow.com/users/1500501/michael-tang"}, "edited": false, "score": 1, "creation_date": 1420962680, "post_id": 27859911, "comment_id": 44171467, "body": "@DK: You&#39;re very right. I&#39;m ashamed to admit I spent too much time yesterday trying to make it work before realizing just DST support != what the asker wanted."}, {"owner": {"reputation": 19090, "user_id": 138772, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/32504cb73cc05b26335a43219fff3a79?s=128&d=identicon&r=PG", "display_name": "JAB", "link": "https://stackoverflow.com/users/138772/jab"}, "edited": false, "score": 1, "creation_date": 1436907840, "post_id": 27859911, "comment_id": 50807216, "body": "Efficiency aspect aside, LLVM definitely supports stack-allocated VLAs. You just use <code>%vla = alloca &lt;type&gt;, &lt;ty&gt; &lt;NumElements&gt;</code> rather than <code>%sla = alloca [&lt;NumElements&gt; x &lt;type&gt;]</code> (and the equivalent programmatic <code>AllocaInst</code> calls)."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": false, "score": 3, "last_activity_date": 1529547837, "last_edit_date": 1529547837, "creation_date": 1420804151, "answer_id": 27859911, "question_id": 27859822, "link": "https://stackoverflow.com/questions/27859822/is-it-possible-to-have-stack-allocated-arrays-with-the-size-determined-at-runtim/27859911#27859911", "title": "Is it possible to have stack allocated arrays with the size determined at runtime in Rust?", "body": "<p>No.</p>\n\n<p>Doing that in Rust would entail the ability to store Dynamically Sized Types (DSTs) like <code>[i32]</code> on the stack, which the language doesn't support.</p>\n\n<p>A deeper reason is that LLVM, to my knowledge, doesn't really support this.  I'm given to believe that you <em>can</em> do it, but it <em>significantly</em> interferes with optimisations.  As such, I'm not aware of any near-terms plans to allow this.</p>\n"}, {"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 9123, "user_id": 5189607, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/b9b485f6efee3ce1b78dea5fe45c96f6?s=128&d=identicon&r=PG", "display_name": "malbarbo", "link": "https://stackoverflow.com/users/5189607/malbarbo"}, "edited": false, "score": 0, "creation_date": 1462542087, "post_id": 27891122, "comment_id": 61692408, "body": "@malbarbo: Indeed, and it goes about the issue of not having type level integers smartly too! I had not thought about asking for an <i>array</i> type to the user to let her specify the size."}, {"owner": {"reputation": 5189, "user_id": 5223757, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/FdOvO.png?s=128&g=1", "display_name": "wizzwizz4", "link": "https://stackoverflow.com/users/5223757/wizzwizz4"}, "edited": false, "score": 0, "creation_date": 1591125760, "post_id": 27891122, "comment_id": 109936074, "body": "The <a href=\"https://docs.rs/smallvec/1.4.0/smallvec/\" rel=\"nofollow noreferrer\"><code>smallvec</code></a> crate provides this."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 5189, "user_id": 5223757, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/FdOvO.png?s=128&g=1", "display_name": "wizzwizz4", "link": "https://stackoverflow.com/users/5223757/wizzwizz4"}, "edited": false, "score": 0, "creation_date": 1591184448, "post_id": 27891122, "comment_id": 109957444, "body": "@wizzwizz4 Partly. The <code>Array</code> trait is only implemented for a subset of sizes, and is a tad cumbersome to use. Better than nothing, but clearly a work-around for the lack of const generics."}, {"owner": {"reputation": 4454, "user_id": 272427, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/10f0f1452979307efc4583ba099ba801?s=128&d=identicon&r=PG", "display_name": "dubiousjim", "link": "https://stackoverflow.com/users/272427/dubiousjim"}, "edited": false, "score": 0, "creation_date": 1611401587, "post_id": 27891122, "comment_id": 116442557, "body": "Shouldn&#39;t the slice implementations for the <code>Inline</code> variant use that variant&#39;s size as a bound? The sample code here makes a slice of the whole len 64 array. So the slice will have the wrong length."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 4454, "user_id": 272427, "user_type": "registered", "accept_rate": 83, "profile_image": "https://www.gravatar.com/avatar/10f0f1452979307efc4583ba099ba801?s=128&d=identicon&r=PG", "display_name": "dubiousjim", "link": "https://stackoverflow.com/users/272427/dubiousjim"}, "edited": false, "score": 0, "creation_date": 1611402149, "post_id": 27891122, "comment_id": 116442698, "body": "@dubiousjim: Indeed, fixed. Also, if you want to attempt it without having to actually build 64 Ts, you&#39;ll want to use <code>[MaybeUninit&lt;T&gt;; 64]</code>, but I&#39;ll leave that out for now. Finally, there&#39;s work ongoing to be able to pass inline storage to rustc&#39;s std structures, but that&#39;s very much at prototype stage at the moment."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 26, "last_activity_date": 1611402042, "last_edit_date": 1611402042, "creation_date": 1421004301, "answer_id": 27891122, "question_id": 27859822, "link": "https://stackoverflow.com/questions/27859822/is-it-possible-to-have-stack-allocated-arrays-with-the-size-determined-at-runtim/27891122#27891122", "title": "Is it possible to have stack allocated arrays with the size determined at runtime in Rust?", "body": "<p>It is not possible <em>directly</em>, as in there is not direct syntax in the language supporting it.</p>\n<p>That being said, this particular feature of C99 is debatable, it has certain advantages (cache locality &amp; bypassing <code>malloc</code>) but it also has disadvantages (easy to blow-up the stack, stumps a number of optimizations, may turn static offsets into dynamic offsets, ...).</p>\n<p>For now, I would advise you to use <code>Vec</code> instead. If you have performance issues, then you may look into the so-called &quot;Small Vector Optimization&quot;. I have regularly seen the following pattern in C code where performance is required:</p>\n<pre class=\"lang-c prettyprint-override\"><code>SomeType array[64] = {};\nSomeType* pointer, *dynamic_pointer;\nif (n &lt;= 64) {\n    pointer = array;\n} else {\n    pointer = dynamic_pointer = malloc(sizeof(SomeType) * n);\n}\n\n// ...\n\nif (dynamic_pointer) { free(dynamic_pointer); }\n</code></pre>\n<p>Now, this is something that Rust supports easily (and better, in a way):</p>\n<pre><code>enum InlineVector&lt;T&gt; {\n    Inline(usize, [T; 64]),\n    Dynamic(Vec&lt;T&gt;),\n}\n</code></pre>\n<p>You can see an example simplistic implementation below.</p>\n<p>What matters, however, is that you now have a type which:</p>\n<ul>\n<li>uses the stack when less than 64 elements are required</li>\n<li>moves off to the heap otherwise, to avoid blowing up the stack</li>\n</ul>\n<p>Of course, it also <em>always</em> reserves enough space for 64 elements on the stack even if you only use 2; however in exchange there is no call to <code>alloca</code> so you avoid the issue of having dynamic offsets to your variants.</p>\n<p>And contrary to C, you still benefit from lifetime tracking so that you cannot accidentally return a reference to your stack-allocated array outside the function.</p>\n<p><em>Note: a full-blown implementation would require non-type parameters so that you could customize the <code>64</code>... but Rust is not there yet.</em></p>\n<hr />\n<p>I will show off the most &quot;obvious&quot; methods:</p>\n<pre><code>enum InlineVector&lt;T&gt; {\n    Inline(usize, [T; 64]),\n    Dynamic(Vec&lt;T&gt;),\n}\n\nimpl&lt;T: Copy + Clone&gt; InlineVector&lt;T&gt; {\n    fn new(v: T, n: usize) -&gt; InlineVector&lt;T&gt; {\n        if n &lt;= 64 {\n            InlineVector::Inline(n, [v; 64])\n        } else {\n            InlineVector::Dynamic(vec![v; n])\n        }\n    }\n}\n\nimpl&lt;T&gt; InlineVector&lt;T&gt; {\n    fn as_slice(&amp;self) -&gt; &amp;[T] {\n        match self {\n            InlineVector::Inline(n, array) =&gt; &amp;array[0..*n],\n            InlineVector::Dynamic(vec) =&gt; vec,\n        }\n    }\n\n    fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {\n        match self {\n            InlineVector::Inline(n, array) =&gt; &amp;mut array[0..*n],\n            InlineVector::Dynamic(vec) =&gt; vec,\n        }\n    }\n}\n\nuse std::ops::{Deref, DerefMut};\n\nimpl&lt;T&gt; Deref for InlineVector&lt;T&gt; {\n    type Target = [T];\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        self.as_slice()\n    }\n}\n\nimpl&lt;T&gt; DerefMut for InlineVector&lt;T&gt; {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {\n        self.as_mut_slice()\n    }\n}\n</code></pre>\n<p>Usage:</p>\n<pre><code>fn main() {\n    let mut v = InlineVector::new(1u32, 4);\n    v[2] = 3;\n    println!(&quot;{}: {}&quot;, v.len(), v[2])\n}\n</code></pre>\n<p>Which prints <code>4: 3</code> as expected.</p>\n"}], "owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 10179, "favorite_count": 13, "accepted_answer_id": 27891122, "answer_count": 2, "score": 34, "last_activity_date": 1611402042, "creation_date": 1420803819, "last_edit_date": 1529547196, "question_id": 27859822, "link": "https://stackoverflow.com/questions/27859822/is-it-possible-to-have-stack-allocated-arrays-with-the-size-determined-at-runtim", "title": "Is it possible to have stack allocated arrays with the size determined at runtime in Rust?", "body": "<p>Is there an equivalent of <code>alloca</code> to create variable length arrays in Rust?</p>\n\n<p>I'm looking for the equivalent of the following C99 code:</p>\n\n<pre class=\"lang-c prettyprint-override\"><code>void go(int n) {\n    int array[n];\n    // ...\n}\n</code></pre>\n"}, {"tags": ["copy", "operator-overloading", "rust", "pass-by-value", "ownership"], "answers": [{"comments": [{"owner": {"reputation": 1327, "user_id": 200945, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d37d856c0e31745604bb9873fdb40d0f?s=128&d=identicon&r=PG", "display_name": "SirVer", "link": "https://stackoverflow.com/users/200945/sirver"}, "edited": false, "score": 1, "creation_date": 1421315004, "post_id": 27858526, "comment_id": 44314654, "body": "The problem with this is that <code>let pp = &amp;p + &amp;p + &amp;p</code> is not working."}, {"owner": {"reputation": 3892, "user_id": 1236045, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9cdfcff173a4487d2a73a29e177930ec?s=128&d=identicon&r=PG&f=1", "display_name": "Micha\u0142 Politowski", "link": "https://stackoverflow.com/users/1236045/micha%c5%82-politowski"}, "reply_to_user": {"reputation": 1327, "user_id": 200945, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d37d856c0e31745604bb9873fdb40d0f?s=128&d=identicon&r=PG", "display_name": "SirVer", "link": "https://stackoverflow.com/users/200945/sirver"}, "edited": false, "score": 0, "creation_date": 1421321480, "post_id": 27858526, "comment_id": 44318045, "body": "@SirVer yes, you would have to write something like <code>let pp = &amp;(&amp;p + &amp;p) + &amp;p</code>. I guess that the practical thing to do would be to create several implementations, like the answer by Vladimir Matveev suggests (or just derive <code>Copy</code> and be done with it)."}], "tags": [], "owner": {"reputation": 3892, "user_id": 1236045, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9cdfcff173a4487d2a73a29e177930ec?s=128&d=identicon&r=PG&f=1", "display_name": "Micha\u0142 Politowski", "link": "https://stackoverflow.com/users/1236045/micha%c5%82-politowski"}, "is_accepted": true, "score": 5, "last_activity_date": 1421364960, "last_edit_date": 1421364960, "creation_date": 1420799231, "answer_id": 27858526, "question_id": 27856991, "link": "https://stackoverflow.com/questions/27856991/operator-overloading-by-value-results-in-use-of-moved-value/27858526#27858526", "title": "Operator overloading by value results in use of moved value", "body": "<p>If you don't want to copy then, as far as my newbie understanding goes, you need to implement <code>Add</code> on references to <code>Point</code>.</p>\n\n<p>This would be supported by the RFC:</p>\n\n<blockquote>\n  <p>Fortunately, there is no loss in expressiveness, since you can always implement the trait on reference types. However, for types that do need to be taken by reference, there is a slight loss in ergonomics since you may need to explicitly borrow the operands with &amp;. The upside is that the ownership semantics become clearer: they more closely resemble normal function arguments.</p>\n</blockquote>\n\n<p>And indeed it seems to work:</p>\n\n<pre><code>use std::ops::{Add};\n\n#[derive(Show)]\nstruct Point {\n    x: i32,\n    y: i32\n}\n\nimpl&lt;'a&gt; Add for &amp;'a Point {\n    type Output = Point;\n\n    fn add(self, other: &amp;'a Point) -&gt; Point { //'\n        Point {x: self.x + other.x, y: self.y + other.y}\n    }\n}\n\nfn main() {\n    let p: Point = Point {x: 1, y: 0};\n    let pp = &amp;p + &amp;p;\n    println!(\"{:?}\", pp);\n}\n</code></pre>\n\n<p>(<a href=\"http://is.gd/HG0knM\" rel=\"nofollow\">playpen</a>)</p>\n\n<p>To make <code>Point</code> copyable instead, just replace <code>#[derive(Show)]</code> with <code>#[derive(Show,Copy)]</code>. Such structs used to be copyable by default, but it <a href=\"http://discuss.rust-lang.org/t/psa-copy-is-becoming-opt-in/982\" rel=\"nofollow\">changed</a>.</p>\n"}, {"comments": [{"owner": {"reputation": 1327, "user_id": 200945, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d37d856c0e31745604bb9873fdb40d0f?s=128&d=identicon&r=PG", "display_name": "SirVer", "link": "https://stackoverflow.com/users/200945/sirver"}, "edited": false, "score": 0, "creation_date": 1421431925, "post_id": 27866502, "comment_id": 44371212, "body": "Vladimir, thanks for your reply. What if my type is easy, but expensive to copy, say a <code>Matrix1000x1000</code> type? Is the compiler smart enough to avoid copying in chained operations or do I need to write the trivially forwards to the 4 implementations you mentioned?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 1327, "user_id": 200945, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/d37d856c0e31745604bb9873fdb40d0f?s=128&d=identicon&r=PG", "display_name": "SirVer", "link": "https://stackoverflow.com/users/200945/sirver"}, "edited": false, "score": 1, "creation_date": 1421432732, "post_id": 27866502, "comment_id": 44371611, "body": "I&#39;m not sure I understand your question. If your type is expensive to copy, don&#39;t make it <code>Copy</code> and implement operation traits for four variants (self+self, &amp;self+self, self+&amp;self, &amp;self+&amp;self). If your type is that large, you will need to put the data on the heap anyway, so move semantics will make sure that only the structure itself is copied."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 4, "last_activity_date": 1420826568, "creation_date": 1420826568, "answer_id": 27866502, "question_id": 27856991, "link": "https://stackoverflow.com/questions/27856991/operator-overloading-by-value-results-in-use-of-moved-value/27866502#27866502", "title": "Operator overloading by value results in use of moved value", "body": "<p>If your structure can't be copied (e.g. it has <code>Drop</code> implementation, either itself or for one of its fields), then it may make sense to create several implementations: value+value, value+reference, reference+value and reference+reference. The first three can reuse the storage of one of the operands, and the last one can clone one of the operands and then just delegate to the already existing implementations. This way the user of your library can easily decide whether they want to reuse existing values for optimization or not.</p>\n\n<p>In fact, that's how e.g. <a href=\"https://github.com/rust-lang/num/blob/master/src/bigint.rs\" rel=\"nofollow\"><code>BigInt</code></a> or <a href=\"https://github.com/rust-lang/num/blob/master/src/complex.rs\" rel=\"nofollow\"><code>Complex</code></a> types are handled.</p>\n\n<p>Your <code>Point</code>, however, can just be made <code>Copy</code> as it is cheap to copy it.</p>\n"}], "owner": {"reputation": 875, "user_id": 2496267, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/aa482a249f322fea06a8f0cc3f8e39bf?s=128&d=identicon&r=PG", "display_name": "zgerd", "link": "https://stackoverflow.com/users/2496267/zgerd"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 808, "favorite_count": 2, "accepted_answer_id": 27858526, "answer_count": 2, "score": 7, "last_activity_date": 1421423897, "creation_date": 1420794270, "last_edit_date": 1421423897, "question_id": 27856991, "link": "https://stackoverflow.com/questions/27856991/operator-overloading-by-value-results-in-use-of-moved-value", "title": "Operator overloading by value results in use of moved value", "body": "<p>Compiling the following Rust code that uses operator overloading</p>\n\n<pre><code>use std::ops::{Add};\n\n#[derive(Show)]\nstruct Point {\n    x: int,\n    y: int\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {x: self.x + other.x, y: self.y + other.y}\n    }\n}\n\nfn main() {\n    let p: Point = Point {x: 1, y: 0};\n    let pp = p + p;\n}\n</code></pre>\n\n<p>Results in compiler errors due to ownership of p:</p>\n\n<pre><code>&lt;anon&gt;:21:18: 21:19 error: use of moved value: `p`\n&lt;anon&gt;:21     let pp = p + p;\n                           ^\n&lt;anon&gt;:21:14: 21:15 note: `p` moved here because it has type `Point`, which is non-copyable\n&lt;anon&gt;:21     let pp = p + p;\n                       ^\n</code></pre>\n\n<p>The rationale behind it is explained <a href=\"https://mail.mozilla.org/pipermail/rust-dev/2014-June/010280.html\" rel=\"nofollow\">here</a> and led to an <a href=\"https://github.com/rust-lang/rfcs/pull/118\" rel=\"nofollow\">RFC</a> that was not accepted (part of due to reasons of the above example). However, later the following <a href=\"https://github.com/rust-lang/rfcs/pull/439\" rel=\"nofollow\">RFC</a> still introduced the by-value type signatures for operators.</p>\n\n<p>While I understand the rationale behind the decision. Due to my lack of experience in rust, I'm not sure what the \"proper\" way would be to allow the above code to work (a) if I do not want to copy or (b) how to make the struct copyable?</p>\n"}, {"tags": ["macos", "rust"], "comments": [{"owner": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "edited": false, "score": 0, "creation_date": 1420783555, "post_id": 27854721, "comment_id": 44113015, "body": "Not sure it&#39;s indeed the case. Maybe it&#39;s just that because of the crash, the standard output is not flushed, and it&#39;s only the first few thousand lines that are printed. Did you try flushing the standard output fully, after each call to println?"}, {"owner": {"reputation": 1187, "user_id": 1137004, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5ebaa8eb2711795cbf1c9cdda773328?s=128&d=identicon&r=PG", "display_name": "kiyomi", "link": "https://stackoverflow.com/users/1137004/kiyomi"}, "reply_to_user": {"reputation": 8617, "user_id": 3477950, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/mC5xL.jpg?s=128&g=1", "display_name": "The Paramagnetic Croissant", "link": "https://stackoverflow.com/users/3477950/the-paramagnetic-croissant"}, "edited": false, "score": 0, "creation_date": 1420783927, "post_id": 27854721, "comment_id": 44113135, "body": "@TheParamagneticCroissant I modified program, add <code>use std::io::stdio::flush;</code>, and flush in each recursion, but output remain (2687)."}, {"owner": {"reputation": 767718, "user_id": 14860, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/vXG1F.png?s=128&g=1", "display_name": "paxdiablo", "link": "https://stackoverflow.com/users/14860/paxdiablo"}, "edited": false, "score": 1, "creation_date": 1420787249, "post_id": 27854721, "comment_id": 44114255, "body": "Any recursive algorithm that uses thousands of stack levels is the <i>exact wrong</i> use case for recursion."}, {"owner": {"reputation": 10840, "user_id": 1198729, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/0a3069491bfded90cdf623341cadc1d1?s=128&d=identicon&r=PG", "display_name": "Manishearth", "link": "https://stackoverflow.com/users/1198729/manishearth"}, "edited": false, "score": 0, "creation_date": 1420788142, "post_id": 27854721, "comment_id": 44114622, "body": "IIRC you can change the recursion depth with <code>#[recursion_depth(...)]</code> or something"}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "reply_to_user": {"reputation": 10840, "user_id": 1198729, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/0a3069491bfded90cdf623341cadc1d1?s=128&d=identicon&r=PG", "display_name": "Manishearth", "link": "https://stackoverflow.com/users/1198729/manishearth"}, "edited": false, "score": 0, "creation_date": 1420803224, "post_id": 27854721, "comment_id": 44121715, "body": "@Manishearth, that&#39;s just the compiler&#39;s internal type-checking recursion limit. The runtime recursion depth is directly proportional to the size of the stack."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 1, "creation_date": 1420811247, "post_id": 27854721, "comment_id": 44126118, "body": "Is there a question here?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1420811252, "post_id": 27854721, "comment_id": 44126123, "body": "This sounds more like a bug report, and not a question we can answer definitively here."}, {"owner": {"reputation": 10840, "user_id": 1198729, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/0a3069491bfded90cdf623341cadc1d1?s=128&d=identicon&r=PG", "display_name": "Manishearth", "link": "https://stackoverflow.com/users/1198729/manishearth"}, "reply_to_user": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1420820211, "post_id": 27854721, "comment_id": 44131888, "body": "@dbaupp d&#39;oh, right."}, {"owner": {"reputation": 1187, "user_id": 1137004, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5ebaa8eb2711795cbf1c9cdda773328?s=128&d=identicon&r=PG", "display_name": "kiyomi", "link": "https://stackoverflow.com/users/1137004/kiyomi"}, "edited": false, "score": 0, "creation_date": 1420821312, "post_id": 27854721, "comment_id": 44132546, "body": "okey, I created an issue."}], "answers": [{"tags": [], "owner": {"reputation": 12420, "user_id": 1224627, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/011b3ee0350155b8827cdc9918d2907c?s=128&d=identicon&r=PG", "display_name": "wingedsubmariner", "link": "https://stackoverflow.com/users/1224627/wingedsubmariner"}, "is_accepted": true, "score": 3, "last_activity_date": 1420835190, "last_edit_date": 1420835190, "creation_date": 1420834039, "answer_id": 27868372, "question_id": 27854721, "link": "https://stackoverflow.com/questions/27854721/recursion-depth-too-shallow-in-rust-on-mac-os-x/27868372#27868372", "title": "Recursion depth too shallow in Rust on Mac OS X", "body": "<p>Notice how 11670/2931 equals almost exactly 4 - that is, the number of stack frames on Linux is almost four times as many as on OS X. Apparently, your Mac OS X has 1/4 the default stack size of your Linux. This has nothing to do with Rust, an equivalent C program would produce roughly equal results. You can run <code>ulimit -s</code> from the command line to confirm the stack size difference between the OSes.</p>\n\n<p>LLVM should be able to tail-call optimize this specific program however. Try running <code>rustc</code> with the <code>-O</code> flag. If this works, this will allow infinite recursion. LLVM will produce a <code>recu</code> function that instead of calling itself will loop back to its own start after setting <code>n</code>, allowing it to recurse without consuming stack space.</p>\n\n<p>In my own tests, I had to modify the program to this in order to get it to recursive forever, probably because the <code>println!</code> macro hides destructors:</p>\n\n<pre><code>fn recu(n: int) {\n    printint(n);\n    recu(n+1)\n}\n\n#[inline(never)]\nfn printint(n: int) {\n    println!(\"{}\", n);\n}\n\nfn main() {\n    recu(0)\n}\n</code></pre>\n"}], "owner": {"reputation": 1187, "user_id": 1137004, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/b5ebaa8eb2711795cbf1c9cdda773328?s=128&d=identicon&r=PG", "display_name": "kiyomi", "link": "https://stackoverflow.com/users/1137004/kiyomi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 338, "favorite_count": 0, "accepted_answer_id": 27868372, "answer_count": 1, "score": -1, "last_activity_date": 1420835190, "creation_date": 1420783358, "last_edit_date": 1420785719, "question_id": 27854721, "link": "https://stackoverflow.com/questions/27854721/recursion-depth-too-shallow-in-rust-on-mac-os-x", "title": "Recursion depth too shallow in Rust on Mac OS X", "body": "<pre><code>fn recu(n: int) {\n    println!(\"{}\", n);\n    recu(n+1)\n}\n\nfn main() {\n    recu(0)\n}\n</code></pre>\n\n<p>Output :</p>\n\n<pre><code>...\n2924\n2925\n2926\n2927\n2928\n2929\n2930\n2931\n\nthread '&lt;main&gt;' has overflowed its stack\n[1]    23873 illegal hardware instruction  ./test\n</code></pre>\n\n<p>Infomation:</p>\n\n<blockquote>\n  <p>rustc 1.0.0-nightly (ea6f65c5f 2015-01-06 19:47:08 +0000)</p>\n  \n  <p>MacBook Pro</p>\n  \n  <p>2.2 GHz Intel Core i7</p>\n</blockquote>\n\n<p>In other machine(Linux 64):</p>\n\n<pre><code>11668\n11669\n11670\n\nthread '&lt;main&gt;' has overflowed its stack\n[1]    18070 illegal hardware instruction (core dumped)  ./test\n</code></pre>\n"}, {"tags": ["pointers", "rust", "dereference"], "answers": [{"comments": [{"owner": {"reputation": 1776, "user_id": 4435175, "user_type": "registered", "accept_rate": 68, "profile_image": "https://i.stack.imgur.com/UCpoD.gif?s=128&g=1", "display_name": "Vega", "link": "https://stackoverflow.com/users/4435175/vega"}, "edited": false, "score": 2, "creation_date": 1420770928, "post_id": 27852760, "comment_id": 44109963, "body": "I read at the Rust guide about pointers a bit after your posting and they just use &quot;{:p}, ptr_y&quot; because &quot;println! will automatically dereference it for us&quot;.  A short question: I usually use something like &quot;Type name = value&quot; or &quot;int test = 1&quot;. It seems I can&#39;t have that in Rust as an option, &quot;let int test = 1&quot; gives compiler error? I know the compiler gets the type automatically but for the sake of my syntax I would like to write it in my code when declaring :(.  Anyway, thanks for your answer even when I have no clue what the macro is doing exactly :)."}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "reply_to_user": {"reputation": 1776, "user_id": 4435175, "user_type": "registered", "accept_rate": 68, "profile_image": "https://i.stack.imgur.com/UCpoD.gif?s=128&g=1", "display_name": "Vega", "link": "https://stackoverflow.com/users/4435175/vega"}, "edited": false, "score": 3, "creation_date": 1420778741, "post_id": 27852760, "comment_id": 44111745, "body": "Oh, yes,<code>{:p}</code> also works, the <code>p</code> <a href=\"http://doc.rust-lang.org/nightly/std/fmt/#formatting-traits\" rel=\"nofollow noreferrer\">format specifier</a> is <a href=\"http://doc.rust-lang.org/nightly/std/fmt/trait.Pointer.html\" rel=\"nofollow noreferrer\">implemented for various kinds of pointers</a> to just print the address."}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "reply_to_user": {"reputation": 1776, "user_id": 4435175, "user_type": "registered", "accept_rate": 68, "profile_image": "https://i.stack.imgur.com/UCpoD.gif?s=128&g=1", "display_name": "Vega", "link": "https://stackoverflow.com/users/4435175/vega"}, "edited": false, "score": 4, "creation_date": 1420778783, "post_id": 27852760, "comment_id": 44111752, "body": "<a href=\"http://doc.rust-lang.org/nightly/guide.html#variable-bindings\" rel=\"nofollow noreferrer\">Types are specified as <code>let x: Type = 1;</code></a>."}, {"owner": {"reputation": 1776, "user_id": 4435175, "user_type": "registered", "accept_rate": 68, "profile_image": "https://i.stack.imgur.com/UCpoD.gif?s=128&g=1", "display_name": "Vega", "link": "https://stackoverflow.com/users/4435175/vega"}, "edited": false, "score": 0, "creation_date": 1420818572, "post_id": 27852760, "comment_id": 44130732, "body": "Nice, that&#39;s all I need to know :). Now I need to get a hang on the bigger stuff, I&#39;m only used to OO and have no clue about anything that comes after this (<a href=\"http://doc.rust-lang.org/book/intermediate.html\" rel=\"nofollow noreferrer\">doc.rust-lang.org/book/intermediate.html</a>), especially Templates and Generic stuff. Thx for your help."}], "tags": [], "owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "is_accepted": true, "score": 55, "last_activity_date": 1500125843, "last_edit_date": 1500125843, "creation_date": 1420769093, "answer_id": 27852760, "question_id": 27852613, "link": "https://stackoverflow.com/questions/27852613/why-does-printing-a-pointer-print-the-same-thing-as-printing-the-dereferenced-po/27852760#27852760", "title": "Why does printing a pointer print the same thing as printing the dereferenced pointer?", "body": "<p>Rust usually focuses on object value (i.e. the interesting part of the contents) rather than object identity (memory addresses). The <a href=\"https://github.com/rust-lang/rust/blob/1.18.0/src/libcore/fmt/mod.rs#L1470-L1485\" rel=\"noreferrer\">implementation of <code>Display</code></a> for <code>&amp;T</code> where <code>T</code> implements <code>Display</code> defers directly to the contents. Expanding that macro manually for the <code>String</code> implementation of <code>Display</code>:</p>\n\n<pre><code>impl&lt;'a&gt; Display for &amp;'a String {\n    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result {\n        Display::fmt(&amp;**self, f)\n    }\n}\n</code></pre>\n\n<p>That is, it is just printing its contents directly.</p>\n\n<p>If you care about object identity/the memory address, you can use the <a href=\"https://doc.rust-lang.org/std/fmt/trait.Pointer.html\" rel=\"noreferrer\"><code>Pointer</code> formatter</a>, <code>{:p}</code>:</p>\n\n<pre><code>fn main() {\n    let x = 1;\n    let ptr_y = &amp;x;\n    println!(\"x: {}, ptr_y: {}, address: {:p}\", x, ptr_y, ptr_y);\n}\n</code></pre>\n\n<p>Output:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>x: 1, ptr_y: 1, address: 0x7fff4eda6a24\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=e82055a3b0a0b2aa8bf01c2154f2d294&amp;version=stable\" rel=\"noreferrer\">playground</a></p>\n"}, {"tags": [], "owner": {"reputation": 394, "user_id": 4228257, "user_type": "registered", "profile_image": "https://lh6.googleusercontent.com/-d6X-UaktgH4/AAAAAAAAAAI/AAAAAAAAAQ4/fJ0efBOlRHA/photo.jpg?sz=128", "display_name": "Deepak G", "link": "https://stackoverflow.com/users/4228257/deepak-g"}, "is_accepted": false, "score": 4, "last_activity_date": 1548406094, "creation_date": 1548406094, "answer_id": 54361766, "question_id": 27852613, "link": "https://stackoverflow.com/questions/27852613/why-does-printing-a-pointer-print-the-same-thing-as-printing-the-dereferenced-po/54361766#54361766", "title": "Why does printing a pointer print the same thing as printing the dereferenced pointer?", "body": "<pre><code>fn main() {\n let x = &amp;42;\n let address = format!(\"{:p}\", x); // this produces something like '0x7f06092ac6d0'\n println!(\"{}\", address);\n}\n</code></pre>\n"}], "owner": {"reputation": 1776, "user_id": 4435175, "user_type": "registered", "accept_rate": 68, "profile_image": "https://i.stack.imgur.com/UCpoD.gif?s=128&g=1", "display_name": "Vega", "link": "https://stackoverflow.com/users/4435175/vega"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 12284, "favorite_count": 4, "accepted_answer_id": 27852760, "answer_count": 2, "score": 38, "last_activity_date": 1548406094, "creation_date": 1420767803, "last_edit_date": 1500125464, "question_id": 27852613, "link": "https://stackoverflow.com/questions/27852613/why-does-printing-a-pointer-print-the-same-thing-as-printing-the-dereferenced-po", "title": "Why does printing a pointer print the same thing as printing the dereferenced pointer?", "body": "<p>From the Rust guide:</p>\n\n<blockquote>\n  <p>To dereference (get the value being referred to rather than the reference itself) <code>y</code>, we use the asterisk (<code>*</code>)</p>\n</blockquote>\n\n<p>So I did it:</p>\n\n<pre><code>fn main() {\n    let x = 1;\n    let ptr_y = &amp;x;\n    println!(\"x: {}, ptr_y: {}\", x, *ptr_y);\n}\n</code></pre>\n\n<p>This gives me the same results (x=1; y=1) even without an explicit dereference:</p>\n\n<pre><code>fn main() {\n    let x = 1;\n    let ptr_y = &amp;x;\n    println!(\"x: {}, ptr_y: {}\", x, ptr_y);\n}\n</code></pre>\n\n<p>Why? Shouldn't <code>ptr_y</code> print the memory address and <code>*ptr_y</code> print 1? Is there some kind of auto-dereference or did I miss something?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 653, "user_id": 2051092, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/6eabdb0f0b8be9a8fef78646df1a392a?s=128&d=identicon&r=PG", "display_name": "GGalizzi", "link": "https://stackoverflow.com/users/2051092/ggalizzi"}, "edited": false, "score": 0, "creation_date": 1420805313, "post_id": 27853380, "comment_id": 44122801, "body": "Thanks, I think I&#39;ll be going with a static method.  If I&#39;m understanding the second choice correctly, making a newtype still feels a bit too redundant when looking at my code, since I&#39;d have the <code>Bar</code> struct with all its data, and then some <code>BarRef</code> newtype, and I&#39;d have to impl on one or the other depending on how some method works.  In any case would you mind expanding a bit on when it may (or not) be a good idea to do this?"}, {"owner": {"reputation": 15065, "user_id": 723090, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/ML1tj.png?s=128&g=1", "display_name": "Mark", "link": "https://stackoverflow.com/users/723090/mark"}, "edited": false, "score": 0, "creation_date": 1525941361, "post_id": 27853380, "comment_id": 87555122, "body": "The second way also works fairly well, more concise for users. But it feels like quite some extra code for a simple problem."}], "tags": [], "owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "is_accepted": true, "score": 5, "last_activity_date": 1420774079, "creation_date": 1420774079, "answer_id": 27853380, "question_id": 27849622, "link": "https://stackoverflow.com/questions/27849622/is-there-any-way-i-could-use-self-from-a-method-as-an-rcrefcellt/27853380#27853380", "title": "Is there any way I could use self from a method as an Rc&lt;RefCell&lt;T&gt;&gt;?", "body": "<p>There are two main choices here:</p>\n\n<ul>\n<li><p>Use a static method:</p>\n\n<pre><code>impl Bar {\n    pub fn something(self_: Rc&lt;RefCell&lt;Bar&gt;&gt;) {\n        \u2026\n    }\n}\n\nBar::something(my_bar)\n</code></pre></li>\n<li><p>Conceal the fact that you\u2019re using <code>Rc&lt;RefCell&lt;X&gt;&gt;</code>, wrapping it in a new type with the single field <code>Rc&lt;RefCell&lt;X&gt;&gt;</code>; then other types can use this new type rather than <code>Rc&lt;RefCell&lt;Bar&gt;&gt;</code> and you can make this <code>something</code> method work with <code>self</code>. This may or may not be a good idea, depending on how you use it. Without further details it\u2019s hard to say.</p></li>\n</ul>\n"}], "owner": {"reputation": 653, "user_id": 2051092, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/6eabdb0f0b8be9a8fef78646df1a392a?s=128&d=identicon&r=PG", "display_name": "GGalizzi", "link": "https://stackoverflow.com/users/2051092/ggalizzi"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1547, "favorite_count": 2, "accepted_answer_id": 27853380, "answer_count": 1, "score": 9, "last_activity_date": 1420774079, "creation_date": 1420751660, "question_id": 27849622, "link": "https://stackoverflow.com/questions/27849622/is-there-any-way-i-could-use-self-from-a-method-as-an-rcrefcellt", "title": "Is there any way I could use self from a method as an Rc&lt;RefCell&lt;T&gt;&gt;?", "body": "<p>I have a struct (Foo) that has an <code>Rc&lt;RefCell&lt;Bar&gt;&gt;</code> field, Bar has a method that gets called by a <code>Rc&lt;RefCell&lt;Bar&gt;&gt;</code>, in that method it gets a reference to a Foo and I would like to set that <code>Rc&lt;RefCell&lt;Bar&gt;&gt;</code> in in that Foo to the Bar that called the method.</p>\n\n<p>Consider the following code:</p>\n\n<pre><code>struct Foo {\n    thing: Rc&lt;RefCell&lt;Bar&gt;&gt;,\n}\n\nstruct Bar;\n\nimpl Foo {\n    pub fn set_thing(&amp;mut self, thing: Rc&lt;RefCell&lt;Bar&gt;&gt;) {\n       self.thing = thing;\n    }\n}\n\nimpl Bar {\n    pub fn something(&amp;mut self) {\n        // Things happen, I get a &amp;mut to a Foo, and here I would like to use this Bar reference\n        // as the argument needed in Foo::set_thing            \n    }\n}\n\n// Somewhere else\n// Bar::something is called from something like this:\nlet my_bar : Rc&lt;RefCell&lt;Bar&gt;&gt; = Rc::new(RefCell::new(Bar{}));\nmy_bar.borrow_mut().something();\n// ^--- I'd like my_bar.clone() to be \"thing\" in the foo I get at Bar::something\n</code></pre>\n\n<p>Is the only way to do what I want to add another parameter to <code>Bar::something</code> accepting an <code>Rc&lt;RefCell&lt;Bar&gt;&gt;</code>? It feels redudant, when I'm already calling it from one.</p>\n\n<pre><code>    pub fn something(&amp;mut self, rcSelf: Rc&lt;RefCell&lt;Bar&gt;&gt;) {\n        foo.set_thing(rcSelf);\n</code></pre>\n"}, {"tags": ["sockets", "rust"], "answers": [{"tags": [], "owner": {"reputation": 34083, "user_id": 1287251, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/IQkBy.png?s=128&g=1", "display_name": "Cornstalks", "link": "https://stackoverflow.com/users/1287251/cornstalks"}, "is_accepted": true, "score": 9, "last_activity_date": 1420734491, "creation_date": 1420734491, "answer_id": 27844913, "question_id": 27844778, "link": "https://stackoverflow.com/questions/27844778/what-can-cause-rusts-tcpsocketwrite-to-return-invalid-input/27844913#27844913", "title": "What can cause Rust&#39;s TcpSocket::write() to return &quot;invalid input&quot;?", "body": "<p>The <code>\"invalid input\"</code> error isn't coming from the socket. It's coming from <code>String</code>. If the <code>read_to_string()</code> call is changed to <code>read_to_end()</code>, then the response is successful. Apparently the response isn't valid UTF-8.</p>\n\n<p>More explicitly, the code:</p>\n\n<pre><code>println!(\"Reading response...\");\nlet response = stream.read_to_end().unwrap();\n\nprintln!(\"Printing response:\");\nprintln!(\"{}\", String::from_utf8(response));\n</code></pre>\n\n<p>returns:</p>\n\n<pre><code>Err(invalid utf-8: invalid byte at index 14787)\n</code></pre>\n\n<p>So the HTTP response is bad. Looking at the web page, the error is here (the <code>\ufffd</code> characters are the problem):</p>\n\n<pre><code>Lang.Next'14 Keynote: What \ufffd if anything \ufffd have we learned from C++?\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 11, "user_id": 4438716, "user_type": "unregistered", "profile_image": "https://www.gravatar.com/avatar/03c57ae611e3919142afc54e9943a9a6?s=128&d=identicon&r=PG", "display_name": "Assembler", "link": "https://stackoverflow.com/users/4438716/assembler"}, "is_accepted": false, "score": 1, "last_activity_date": 1420845514, "creation_date": 1420845514, "answer_id": 27870850, "question_id": 27844778, "link": "https://stackoverflow.com/questions/27844778/what-can-cause-rusts-tcpsocketwrite-to-return-invalid-input/27870850#27870850", "title": "What can cause Rust&#39;s TcpSocket::write() to return &quot;invalid input&quot;?", "body": "<p>The offending characters are 0x96, indeed invalid utf-8. It should be U+2013 &ndash;\nThe document is either iso-8859-1 or windows 1252. There are a number of other problems with that HTML, such as unescaped &amp;'s.</p>\n"}], "owner": {"reputation": 34083, "user_id": 1287251, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/IQkBy.png?s=128&g=1", "display_name": "Cornstalks", "link": "https://stackoverflow.com/users/1287251/cornstalks"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1060, "favorite_count": 0, "accepted_answer_id": 27844913, "answer_count": 2, "score": 7, "last_activity_date": 1420845514, "creation_date": 1420734110, "last_edit_date": 1492087139, "question_id": 27844778, "link": "https://stackoverflow.com/questions/27844778/what-can-cause-rusts-tcpsocketwrite-to-return-invalid-input", "title": "What can cause Rust&#39;s TcpSocket::write() to return &quot;invalid input&quot;?", "body": "<p><a href=\"https://codegolf.stackexchange.com/questions/44278/debunking-stroustrups-debunking-of-the-myth-c-is-for-large-complicated-pro\">For a little fun</a> I wanted to make a simple HTTP request in Rust. I threw this together and it works great:</p>\n\n<pre><code>use std::io::TcpStream;\n\nfn main() {\n    // This just does a \"GET /\" to www.stroustrup.com\n    println!(\"Establishing connection...\");\n    let mut stream = TcpStream::connect(\"www.stroustrup.com:80\").unwrap();\n\n    println!(\"Writing HTTP request...\");\n    // unwrap() the result to make sure it succeeded, at least\n    let _ = stream.write(b\"GET / HTTP/1.1\\r\\n\\\n                           Host: www.stroustrup.com\\r\\n\\\n                           Accept: */*\\r\\n\\\n                           Connection: close\\r\\n\\r\\n\").unwrap();\n\n    println!(\"Reading response...\");\n    let response = stream.read_to_string().unwrap();\n\n    println!(\"Printing response:\");\n    println!(\"{}\", response);\n}\n</code></pre>\n\n<p>Response is:</p>\n\n<pre><code>Establishing connection...\nWriting HTTP request...\nReading response...\nPrinting response:\nHTTP/1.1 200 OK\n...and the rest of the long HTTP response with all the HTML as I'd expect...\n</code></pre>\n\n<p>However, if I change the request to be <code>/C++.html</code> instead of <code>/</code>:</p>\n\n<pre><code>use std::io::TcpStream;\n\nfn main() {\n    // The only change is to \"GET /C++.html\" instead of \"GET /\"\n    println!(\"Establishing connection...\");\n    let mut stream = TcpStream::connect(\"www.stroustrup.com:80\").unwrap();\n\n    println!(\"Writing HTTP request...\");\n    // unwrap() the result to make sure it succeeded, at least\n    let _ = stream.write(b\"GET /C++.html HTTP/1.1\\r\\n\\\n                           Host: www.stroustrup.com\\r\\n\\\n                           Accept: */*\\r\\n\\\n                           Connection: close\\r\\n\\r\\n\").unwrap();\n\n    println!(\"Reading response...\");\n    let response = stream.read_to_string().unwrap();\n\n    println!(\"Printing response:\");\n    println!(\"{}\", response);\n}\n</code></pre>\n\n<p>The socket returns <code>\"invalid input\"</code>:</p>\n\n<pre><code>Establishing connection...\nWriting HTTP request...\nReading response...\nthread '&lt;main&gt;' panicked at 'called `Result::unwrap()` on an `Err` value: invalid input', /Users/rustbuild/src/rust-buildbot/slave/nightly-dist-rustc-mac/build/src/libcore/result.rs:746\n</code></pre>\n\n<p>Why does the socket return <code>\"invalid input\"</code>? The TCP socket isn't aware of the HTTP protocol (and I've tested my request with telnet and netcat: it's correct), so it can't be complaining about HTTP request/response.</p>\n\n<p>What does <code>\"invalid input\"</code> even mean here? Why doesn't this work?</p>\n\n<p>My rust version (I'm on OS X 10.10.1):</p>\n\n<pre><code>$ rustc --version\nrustc 1.0.0-nightly (ea6f65c5f 2015-01-06 19:47:08 +0000)\n</code></pre>\n"}, {"tags": ["rust", "borrow-checker"], "comments": [{"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1420725487, "post_id": 27841657, "comment_id": 44087351, "body": "You say returning a reference to the <code>Vec</code> is &quot;obviously not effective&quot;, but I don&#39;t understand <i>why</i> it&#39;s not effective.  Why don&#39;t you want to do that, and why can&#39;t you just return the <code>Node</code> by value?"}, {"owner": {"reputation": 24085, "user_id": 284947, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/01326d0a524154e0407e4270904e314c?s=128&d=identicon&r=PG", "display_name": "defuz", "link": "https://stackoverflow.com/users/284947/defuz"}, "reply_to_user": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1420726138, "post_id": 27841657, "comment_id": 44087788, "body": "@DK. I can&#39;t return <code>Node</code> by value because I previously pushed it into vector"}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "edited": false, "score": 0, "creation_date": 1420726221, "post_id": 27841657, "comment_id": 44087840, "body": "As Vladimir says in his edit, just auto-derive a <code>Copy</code> implementation."}], "answers": [{"comments": [{"owner": {"reputation": 24085, "user_id": 284947, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/01326d0a524154e0407e4270904e314c?s=128&d=identicon&r=PG", "display_name": "defuz", "link": "https://stackoverflow.com/users/284947/defuz"}, "edited": false, "score": 0, "creation_date": 1420726616, "post_id": 27841972, "comment_id": 44088110, "body": "In my case, <code>node</code> lives as long as the <code>Graph</code>. Can I return a pointer to the value with the same lifetime as <code>&amp;self</code>?"}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 24085, "user_id": 284947, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/01326d0a524154e0407e4270904e314c?s=128&d=identicon&r=PG", "display_name": "defuz", "link": "https://stackoverflow.com/users/284947/defuz"}, "edited": false, "score": 0, "creation_date": 1420726787, "post_id": 27841972, "comment_id": 44088229, "body": "No, you can&#39;t, unless this value already has the same lifetime as <code>self</code>. That&#39;s why it&#39;s ok to return a reference into a vector (I don&#39;t really understand why you don&#39;t want to do it), but not ok to return a reference to a local variable. This really is a fundamental thing - it is not correct to say that <code>node</code> lives as long as <code>Graph</code> because it <i>does not</i>. It lives only for the duration of the function call and you can&#39;t change this fact without moving this value somewhere else (e.g. into <code>self</code>) - but then the original <code>node</code> will be unavailable because it is moved, ..."}, {"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 24085, "user_id": 284947, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/01326d0a524154e0407e4270904e314c?s=128&d=identicon&r=PG", "display_name": "defuz", "link": "https://stackoverflow.com/users/284947/defuz"}, "edited": false, "score": 0, "creation_date": 1420726962, "post_id": 27841972, "comment_id": 44088342, "body": "... so you need to take a reference to the <i>new</i> place, not the old one."}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 2, "last_activity_date": 1420726158, "last_edit_date": 1420726158, "creation_date": 1420725857, "answer_id": 27841972, "question_id": 27841657, "link": "https://stackoverflow.com/questions/27841657/how-to-return-a-pointer-to-owned-value-that-does-not-live-long-enough/27841972#27841972", "title": "How to return a pointer to owned value that &quot;does not live long enough&quot;?", "body": "<blockquote>\n  <p>But I can not figure out how to return a reference to the newly\n  created structure.</p>\n</blockquote>\n\n<p>You can't. This is one of the basic errors which are ruled out by the ownership system.</p>\n\n<p>Suppose you could. Then when your function returns such reference will point to destroyed memory.</p>\n\n<p>You can read more on ownership in the <a href=\"http://doc.rust-lang.org/guide-ownership.html\" rel=\"nofollow\">official guide on ownership</a>. It explains how ownership and borrowing work, including why your program is incorrect.</p>\n\n<p>BTW, unless you have <code>#[derive(Copy)]</code> on your <code>Node</code>, taking a reference to <code>node</code> won't work also because <code>node</code> is moved into the vector. Ownership guide explains move semantics as well.</p>\n"}, {"tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 2, "last_activity_date": 1420777703, "creation_date": 1420777703, "answer_id": 27853826, "question_id": 27841657, "link": "https://stackoverflow.com/questions/27841657/how-to-return-a-pointer-to-owned-value-that-does-not-live-long-enough/27853826#27853826", "title": "How to return a pointer to owned value that &quot;does not live long enough&quot;?", "body": "<p>Here's why you can't return <code>&amp;node</code>:</p>\n\n<pre><code>fn create_node(&amp;mut self) -&gt; &amp;Node {\n    let index = self.nodes.len();\n    let node = Node { id: index };\n    println!(\"{}\", &amp;node as *const Node);\n    self.nodes.push(node);\n    println!(\"{}\", &amp;self.nodes[index] as *const Node);\n    return &amp;self.nodes[index];\n}\n</code></pre>\n\n<p>Here's a sample output:</p>\n\n<pre><code>0x7fffc36a3418\n0x7f4c96c2d000\n</code></pre>\n\n<p>As you can see, <code>&amp;node</code> and <code>&amp;self.nodes[index]</code> return completely different values. Moreover, <code>&amp;node</code> (0x7fffc36a3418) will be invalid as soon as <code>create_node</code> returns, because this address points to <code>create_node</code> call frame, and a call frame is freed when a function returns.</p>\n"}], "owner": {"reputation": 24085, "user_id": 284947, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/01326d0a524154e0407e4270904e314c?s=128&d=identicon&r=PG", "display_name": "defuz", "link": "https://stackoverflow.com/users/284947/defuz"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 669, "favorite_count": 0, "accepted_answer_id": 27853826, "answer_count": 2, "score": 0, "last_activity_date": 1420777703, "creation_date": 1420724909, "question_id": 27841657, "link": "https://stackoverflow.com/questions/27841657/how-to-return-a-pointer-to-owned-value-that-does-not-live-long-enough", "title": "How to return a pointer to owned value that &quot;does not live long enough&quot;?", "body": "<p>I have the following code:</p>\n\n<pre><code>struct Node {\n    id: uint\n}\n\nstruct Graph {\n    nodes: Vec&lt;Node&gt;\n}\n\nimpl Graph {\n\n    fn new() -&gt; Graph {\n        return Graph { nodes: Vec::new() };\n    }\n\n    fn create_node(&amp;mut self) -&gt; &amp;Node {\n        let index = self.nodes.len();\n        let node = Node { id: index };\n        self.nodes.push(node);\n        // return &amp;node;           // error: `node` does not live long enough\n        return &amp;self.nodes[index]; // ...but this work fine\n    }\n\n}\n</code></pre>\n\n<p>The idea is that the graph creates a new node and \"lends\" it to someone who calls the method. But I can not figure out how to return a reference to the newly created structure. The second return is working fine, but obviously not effective. </p>\n\n<p>How to return a node without taking it back from the vector?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 51929, "user_id": 1524450, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/BSzDV.png?s=128&g=1", "display_name": "Michael", "link": "https://stackoverflow.com/users/1524450/michael"}, "edited": false, "score": 0, "creation_date": 1420724714, "post_id": 27841475, "comment_id": 44086828, "body": "Hopefully their installer can cope with spaces in paths, but nonetheless, have you tried installing to a path that doesn&#39;t have spaces in it (e.g. <code>C:\\Rust</code>)?"}, {"owner": {"reputation": 23, "user_id": 4433079, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cdcbcff63776c07b47b7b2abd56cd27f?s=128&d=identicon&r=PG&f=1", "display_name": "Pepe Juan", "link": "https://stackoverflow.com/users/4433079/pepe-juan"}, "reply_to_user": {"reputation": 51929, "user_id": 1524450, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/BSzDV.png?s=128&g=1", "display_name": "Michael", "link": "https://stackoverflow.com/users/1524450/michael"}, "edited": false, "score": 0, "creation_date": 1420724779, "post_id": 27841475, "comment_id": 44086883, "body": "Yes, I&#39;ve tried and I get the same problem."}, {"owner": {"reputation": 5071, "user_id": 1124744, "user_type": "registered", "accept_rate": 68, "profile_image": "https://www.gravatar.com/avatar/2f7980bcb4c6b1c604cd0f3424f06f84?s=128&d=identicon&r=PG", "display_name": "paulm", "link": "https://stackoverflow.com/users/1124744/paulm"}, "edited": false, "score": 0, "creation_date": 1420736867, "post_id": 27841475, "comment_id": 44095225, "body": "Error 2 is file not found, use procmon to find out which file"}, {"owner": {"reputation": 23, "user_id": 4433079, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cdcbcff63776c07b47b7b2abd56cd27f?s=128&d=identicon&r=PG&f=1", "display_name": "Pepe Juan", "link": "https://stackoverflow.com/users/4433079/pepe-juan"}, "edited": false, "score": 0, "creation_date": 1420745265, "post_id": 27841475, "comment_id": 44099711, "body": "I thought it was a problem easier to fix."}, {"owner": {"reputation": 72538, "user_id": 497043, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/16a138ff3b9c8f1663f8a0613c47b60a?s=128&d=identicon&r=PG", "display_name": "Chris Morgan", "link": "https://stackoverflow.com/users/497043/chris-morgan"}, "edited": false, "score": 0, "creation_date": 1420769018, "post_id": 27841475, "comment_id": 44109494, "body": "You have enough free space on your disk?"}], "answers": [{"comments": [{"owner": {"reputation": 23, "user_id": 4433079, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cdcbcff63776c07b47b7b2abd56cd27f?s=128&d=identicon&r=PG&f=1", "display_name": "Pepe Juan", "link": "https://stackoverflow.com/users/4433079/pepe-juan"}, "edited": false, "score": 0, "creation_date": 1421080338, "post_id": 27853920, "comment_id": 44212366, "body": "I&#39;ll see if I can disable avast"}], "tags": [], "owner": {"reputation": 46065, "user_id": 234590, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/463c0219a51a5d1fd08e1fa280811b57?s=128&d=identicon&r=PG", "display_name": "Francis Gagn&#233;", "link": "https://stackoverflow.com/users/234590/francis-gagn%c3%a9"}, "is_accepted": true, "score": 0, "last_activity_date": 1420778339, "creation_date": 1420778339, "answer_id": 27853920, "question_id": 27841475, "link": "https://stackoverflow.com/questions/27841475/error-while-installing-rust-on-windows-x64/27853920#27853920", "title": "Error while installing Rust on Windows x64", "body": "<p>Your anti-virus software may have deleted or quarantined the file.</p>\n\n<p>On my system, avast! detected malware in rustc.exe a few weeks ago (which I reported, haven't checked back to see if the false positive was addressed).</p>\n"}], "owner": {"reputation": 23, "user_id": 4433079, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/cdcbcff63776c07b47b7b2abd56cd27f?s=128&d=identicon&r=PG&f=1", "display_name": "Pepe Juan", "link": "https://stackoverflow.com/users/4433079/pepe-juan"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 146, "favorite_count": 0, "accepted_answer_id": 27853920, "answer_count": 1, "score": 1, "last_activity_date": 1420778339, "creation_date": 1420724351, "last_edit_date": 1420736763, "question_id": 27841475, "link": "https://stackoverflow.com/questions/27841475/error-while-installing-rust-on-windows-x64", "title": "Error while installing Rust on Windows x64", "body": "<p>When I install Rust (even with admin permission) I get this error:</p>\n\n<p><img src=\"https://i.stack.imgur.com/OWIQ9.png\" alt=\"enter image description here\"></p>\n\n<p>Any idea how to fix it?</p>\n"}, {"tags": ["rust", "rust-cargo"], "answers": [{"comments": [{"owner": {"reputation": 517, "user_id": 219355, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a0e5c3547561a5db7e51f53a188fca5e?s=128&d=identicon&r=PG", "display_name": "debuti", "link": "https://stackoverflow.com/users/219355/debuti"}, "edited": false, "score": 0, "creation_date": 1596041555, "post_id": 27841363, "comment_id": 111685136, "body": "Is this runtime or compile time?"}, {"owner": {"reputation": 147, "user_id": 1619594, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/90eca0e491c69d81b1770497f985b4ba?s=128&d=identicon&r=PG", "display_name": "tamasfe", "link": "https://stackoverflow.com/users/1619594/tamasfe"}, "reply_to_user": {"reputation": 517, "user_id": 219355, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a0e5c3547561a5db7e51f53a188fca5e?s=128&d=identicon&r=PG", "display_name": "debuti", "link": "https://stackoverflow.com/users/219355/debuti"}, "edited": false, "score": 1, "creation_date": 1598022762, "post_id": 27841363, "comment_id": 112331915, "body": "@debuti compile time, as stated <a href=\"https://doc.rust-lang.org/std/macro.env.html\" rel=\"nofollow noreferrer\">in the documentation</a>"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 259, "last_activity_date": 1598875463, "last_edit_date": 1598875463, "creation_date": 1420723949, "answer_id": 27841363, "question_id": 27840394, "link": "https://stackoverflow.com/questions/27840394/how-can-a-rust-program-access-metadata-from-its-cargo-package/27841363#27841363", "title": "How can a Rust program access metadata from its Cargo package?", "body": "<p>Cargo passes some metadata to the compiler through environment variables, a list of which can be found in the <a href=\"http://doc.crates.io/environment-variables.html\" rel=\"noreferrer\">Cargo documentation pages</a>.</p>\n<p>The compiler environment is populated by <a href=\"https://github.com/rust-lang/cargo/blob/0.33.0/src/cargo/core/compiler/compilation.rs#L171-L239\" rel=\"noreferrer\"><code>fill_env</code></a> in Cargo's code. This code has become more complex since earlier versions, and the entire list of variables is no longer obvious from it because it can be dynamic. However, at least the following variables are set there (from <a href=\"https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates\" rel=\"noreferrer\">the list in the docs</a>):</p>\n<pre class=\"lang-none prettyprint-override\"><code>CARGO_MANIFEST_DIR\nCARGO_PKG_AUTHORS\nCARGO_PKG_DESCRIPTION\nCARGO_PKG_HOMEPAGE\nCARGO_PKG_NAME\nCARGO_PKG_REPOSITORY\nCARGO_PKG_VERSION\nCARGO_PKG_VERSION_MAJOR\nCARGO_PKG_VERSION_MINOR\nCARGO_PKG_VERSION_PATCH\nCARGO_PKG_VERSION_PRE\n</code></pre>\n<p>You can access environment variables using the <a href=\"https://doc.rust-lang.org/std/macro.env.html\" rel=\"noreferrer\"><code>env!()</code></a> macro. To insert the version number of your program you can do this:</p>\n<pre><code>const VERSION: &amp;'static str = env!(&quot;CARGO_PKG_VERSION&quot;);\n\n// ...\n\nprintln!(&quot;MyProgram v{}&quot;, VERSION);\n</code></pre>\n<p>If you want your program to compile even without Cargo, you can use <a href=\"https://doc.rust-lang.org/std/macro.option_env.html\" rel=\"noreferrer\"><code>option_env!()</code></a>:</p>\n<pre><code>const VERSION: Option&lt;&amp;'static str&gt; = option_env!(&quot;CARGO_PKG_VERSION&quot;);\n\n// ...\n\nprintln!(&quot;MyProgram v{}&quot;, VERSION.unwrap_or(&quot;unknown&quot;));\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 5380, "user_id": 146620, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f4ba0c9119010302832e1d129b38228b?s=128&d=identicon&r=PG", "display_name": "Graham King", "link": "https://stackoverflow.com/users/146620/graham-king"}, "edited": false, "score": 0, "creation_date": 1597194564, "post_id": 43559237, "comment_id": 112052107, "body": "<code>built</code> also adds the git sha-1 (and lots of other useful things)"}], "tags": [], "owner": {"reputation": 7882, "user_id": 2722968, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/d0a9ce812892f03b8342c5a60be24632?s=128&d=identicon&r=PG&f=1", "display_name": "user2722968", "link": "https://stackoverflow.com/users/2722968/user2722968"}, "is_accepted": false, "score": 15, "last_activity_date": 1492864282, "creation_date": 1492864282, "answer_id": 43559237, "question_id": 27840394, "link": "https://stackoverflow.com/questions/27840394/how-can-a-rust-program-access-metadata-from-its-cargo-package/43559237#43559237", "title": "How can a Rust program access metadata from its Cargo package?", "body": "<p>The <a href=\"https://docs.rs/built\" rel=\"noreferrer\">built</a>-crate helps with serializing a lot of Cargo's environment without all the boilerplate.</p>\n"}], "owner": {"reputation": 31241, "user_id": 242493, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/8893e2e206c0377ff776d2535887d23f?s=128&d=identicon&r=PG", "display_name": "Jimmy Cuadra", "link": "https://stackoverflow.com/users/242493/jimmy-cuadra"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 19577, "favorite_count": 37, "accepted_answer_id": 27841363, "answer_count": 2, "score": 180, "last_activity_date": 1598875463, "creation_date": 1420720919, "question_id": 27840394, "link": "https://stackoverflow.com/questions/27840394/how-can-a-rust-program-access-metadata-from-its-cargo-package", "title": "How can a Rust program access metadata from its Cargo package?", "body": "<p>How do you access a Cargo package's metadata (e.g. version) from the Rust code in the package? In my case, I am building a command line tool that I'd like to have a standard <code>--version</code> flag, and I'd like the implementation to read the version of the package from <code>Cargo.toml</code> so I don't have to maintain it in two places. I can imagine there are other reasons someone might want to access Cargo metadata from the program as well.</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": true, "score": 1, "last_activity_date": 1420711742, "last_edit_date": 1420711742, "creation_date": 1420711279, "answer_id": 27837353, "question_id": 27836444, "link": "https://stackoverflow.com/questions/27836444/how-do-you-implement-deref-on-a-generic-type-containing-a-trait-in-rust/27837353#27837353", "title": "How do you implement deref on a generic type containing a trait in rust?", "body": "<p>This works:</p>\n\n<pre><code>use std::ops::Deref;\n\nstruct HasTrait&lt;T: ?Sized&gt; {\n    data: Box&lt;T&gt;\n}\n\nimpl&lt;T: ?Sized&gt; HasTrait&lt;T&gt; {\n    fn as_ref(&amp;self) -&gt; &amp;T {\n        &amp;*self.data\n    }\n}\n\nimpl&lt;T: ?Sized&gt; Deref for HasTrait&lt;T&gt; {\n    type Target = T;\n\n    fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a T {  // '\n        self.as_ref()\n    }\n}\n\ntrait Foo {}\nstruct IsFoo;\nimpl Foo for IsFoo {}\n\nfn main() {\n    let is_foo = IsFoo;\n    let foo: Box&lt;Foo&gt; = box is_foo as Box&lt;Foo&gt;;\n    let has_foo = HasTrait { data: foo };\n    let foo_ref: &amp;Foo = &amp;*has_foo; \n}\n</code></pre>\n\n<p>Basically, your problem wasn't really connected with sizedness. It's just that <code>HasTrait&lt;T + Send&gt;</code> here:</p>\n\n<pre><code>impl&lt;T&gt; Deref&lt;T&gt; for HasTrait&lt;T + Send&gt;\n</code></pre>\n\n<p>is meaningless. <code>T</code> can be arbitrary type, and something like <code>u64 + Send</code> does not make sense. Consequently, I'm afraid, you won't be able to constrain <code>HasTrait</code> to contain <em>only</em> traits and <em>only</em> for those types which are <code>Send</code>. There is just no syntax for that, and I'm pretty sure the type system does not support it.</p>\n"}], "owner": {"reputation": 25893, "user_id": 353820, "user_type": "registered", "accept_rate": 94, "profile_image": "https://www.gravatar.com/avatar/32b29e1dc23c2c5abe0283ab7b9541d3?s=128&d=identicon&r=PG", "display_name": "Doug", "link": "https://stackoverflow.com/users/353820/doug"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 994, "favorite_count": 0, "accepted_answer_id": 27837353, "answer_count": 1, "score": 1, "last_activity_date": 1433527546, "creation_date": 1420708140, "last_edit_date": 1433527546, "question_id": 27836444, "link": "https://stackoverflow.com/questions/27836444/how-do-you-implement-deref-on-a-generic-type-containing-a-trait-in-rust", "title": "How do you implement deref on a generic type containing a trait in rust?", "body": "<p>It would be rather convenient to be able to use Deref to generate a &amp;TraitType from a generic container, rather than calling instance.as_ref(). ie:</p>\n\n<pre><code>(*my_container).do_thing();\n</code></pre>\n\n<p>vs.</p>\n\n<pre><code>my_container.as_ref().do_thing();\n</code></pre>\n\n<p>To do this I tried to implement Deref on the container type, but I get this error:</p>\n\n<pre><code>&lt;anon&gt;:9:28: 9:29 error: expected a reference to a trait [E0172]\n&lt;anon&gt;:9 impl&lt;T&gt; Deref for HasTrait&lt;T + Send&gt; {\n</code></pre>\n\n<p>From:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>use std::ops::Deref;\n\ntrait Foo {}\n\nstruct HasTrait&lt;T&gt; {\n  data:Box&lt;T&gt;\n}\n\nimpl&lt;T&gt; Deref for HasTrait&lt;T + Send&gt; {\n  type Target = T;\n  fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a T {\n    return self.as_ref();\n  }\n}\n\nstruct IsFoo;\nunsafe impl Send for IsFoo {}\nimpl Foo for IsFoo {}\n\n\nfn main() {\n  let is_foo = IsFoo;\n  let foo:Box&lt;Foo&gt; = box is_foo as Box&lt;Foo&gt;;\n  let has_foo = HasTrait { data: foo };\n  let foo_ref:&amp;Foo = *has_foo; \n}\n</code></pre>\n\n<p>I've tried using ?Sized to increase the bounds of T to allow traits, but it didn't seem to help?</p>\n\n<p>What's the right way to do this?</p>\n"}, {"tags": ["optimization", "rust", "return-value-optimization"], "comments": [{"owner": {"reputation": 51929, "user_id": 1524450, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/BSzDV.png?s=128&g=1", "display_name": "Michael", "link": "https://stackoverflow.com/users/1524450/michael"}, "edited": false, "score": 0, "creation_date": 1420704728, "post_id": 27835375, "comment_id": 44075775, "body": "<a href=\"http://discuss.rust-lang.org/t/implementation-details/948/5\" rel=\"nofollow noreferrer\">This discussion</a> suggests that RVO triggers for anything larger than a pointer. But there&#39;s also <a href=\"https://github.com/rust-lang/rust/issues/18363\" rel=\"nofollow noreferrer\">this open issue</a> regarding NRVO. So I guess it depends on exactly how you implement <code>initialize</code>."}], "answers": [{"comments": [{"owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "reply_to_user": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 0, "creation_date": 1420719449, "post_id": 27837182, "comment_id": 44083511, "body": "Probably, but I find LLVM IR read much harder than the assembly for some reason :("}, {"owner": {"reputation": 74030, "user_id": 1256624, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/EdJaa.jpg?s=128&g=1", "display_name": "huon", "link": "https://stackoverflow.com/users/1256624/huon"}, "edited": false, "score": 2, "creation_date": 1420725908, "post_id": 27837182, "comment_id": 44087642, "body": "For this we just need the signature: <code>define internal fastcc void @initialize(%&quot;struct.collections::vec::Vec&lt;[i32]&gt;[#3]&quot;* noalias nocapture sret dereferenceable(24)) unnamed_addr #0</code>. LLVM IR is similar C for declarations, so that function returns <code>void</code> and takes a pointer (<code>*</code>) to a <code>struct.collections::vec::Vec&lt;[i32]&gt;</code>. (I used <code>#[no_mangle]</code> to make it clearer.)"}, {"owner": {"reputation": 1406, "user_id": 701211, "user_type": "registered", "accept_rate": 92, "profile_image": "https://www.gravatar.com/avatar/bc08db90032b212b492536d31464550e?s=128&d=identicon&r=PG&f=1", "display_name": "JasonN", "link": "https://stackoverflow.com/users/701211/jasonn"}, "edited": false, "score": 1, "creation_date": 1436336350, "post_id": 27837182, "comment_id": 50562005, "body": "That might show passing a pointer, but if you look at the end of the LLVM IR, you might see a memcpy into that block of memory or similar. I have a piece of code I wrote that allocates a 256 int array to return and if you look at the bottom of the IR, you see the copy from one object to another. Looking at the generated ASM (both beta and nightly on play.r-l.org), you see the call to mempcy@PLT at the bottom of the function call. <a href=\"http://is.gd/u9GVx6\" rel=\"nofollow noreferrer\">is.gd/u9GVx6</a>"}], "tags": [], "owner": {"reputation": 96489, "user_id": 788207, "user_type": "registered", "accept_rate": 84, "profile_image": "https://i.stack.imgur.com/KQmlY.jpg?s=128&g=1", "display_name": "Vladimir Matveev", "link": "https://stackoverflow.com/users/788207/vladimir-matveev"}, "is_accepted": false, "score": 17, "last_activity_date": 1527341168, "last_edit_date": 1527341168, "creation_date": 1420710709, "answer_id": 27837182, "question_id": 27835375, "link": "https://stackoverflow.com/questions/27835375/can-i-efficiently-return-an-object-by-value-in-rust/27837182#27837182", "title": "Can I efficiently return an object by value in Rust?", "body": "<p>Yes, by all means, you should write</p>\n\n<pre><code>fn initialize() -&gt; Vec&lt;Vec&lt;MyStruct&gt;&gt; { ... }\n</code></pre>\n\n<p>(By the way, a <code>Vec</code> is not that large - it's only 3 pointer-sized integers)</p>\n\n<p>Rust has RVO, and this <a href=\"https://web.archive.org/web/20141225073722/https://doc.rust-lang.org/guide-pointers.html#returning-pointers\" rel=\"nofollow noreferrer\">is advertised in guides</a>. You can see it yourself with this code:</p>\n\n<pre><code>#[inline(never)]\nfn initialize() -&gt; Vec&lt;i32&gt; {\n    Vec::new()\n}\n\nfn main() {\n    let v = initialize();\n}\n</code></pre>\n\n<p>If you compile this program in release mode <a href=\"https://play.rust-lang.org/?gist=994e26e3f0a38e52a6473b9bf8656cc1&amp;version=stable&amp;mode=release\" rel=\"nofollow noreferrer\">on the playground</a>, outputting assembly, among everything else you will see this:</p>\n\n<pre><code>playground::initialize:\n    movq    $4, (%rdi)\n    xorps   %xmm0, %xmm0\n    movups  %xmm0, 8(%rdi)\n    retq\n</code></pre>\n\n<p><code>Vec::new()</code> was inlined, but you can see the idea - the address for the fresh <code>Vec</code> instance is passed into the function in <code>%rdi</code>, and the function stores <code>Vec</code> fields directly into this memory, avoiding unnecessary copying through the stack. This is how it is called:</p>\n\n<pre><code>playground::main:\n    subq    $24, %rsp\n    movq    %rsp, %rdi\n    callq   playground::initialize\n</code></pre>\n\n<p>You can see that eventually the <code>Vec</code> instance will be put directly into the stack memory.</p>\n"}], "owner": {"reputation": 2295, "user_id": 1099089, "user_type": "registered", "accept_rate": 11, "profile_image": "https://www.gravatar.com/avatar/a0bf49f333363ebd26ae2d0df3be9533?s=128&d=identicon&r=PG", "display_name": "stevenkucera", "link": "https://stackoverflow.com/users/1099089/stevenkucera"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3232, "favorite_count": 3, "answer_count": 1, "score": 10, "last_activity_date": 1527341168, "creation_date": 1420703729, "last_edit_date": 1527340709, "question_id": 27835375, "link": "https://stackoverflow.com/questions/27835375/can-i-efficiently-return-an-object-by-value-in-rust", "title": "Can I efficiently return an object by value in Rust?", "body": "<p>I would like to initialize a large object with a function. Currently I have:</p>\n\n<pre><code>fn initialize(mydata: &amp;mut Vec&lt;Vec&lt;MyStruct&gt;&gt;) { /* ... */ }\n</code></pre>\n\n<p>I would prefer to have:</p>\n\n<pre><code>fn initialize() -&gt; Vec&lt;Vec&lt;MyStruct&gt;&gt; { /* ... */ }\n</code></pre>\n\n<p>I've heard that C++ often implements return value optimization (RVO), if you are lucky and have a good compiler. Can we disable copying here and have it returned by a hidden pointer that is passed into the function? Is RVO part of the language or an optional optimization?</p>\n"}, {"tags": ["closures", "rust"], "answers": [{"comments": [{"owner": {"reputation": 5359, "user_id": 582917, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/98a347823cd1db90af884b227a29c29e?s=128&d=identicon&r=PG", "display_name": "CMCDragonkai", "link": "https://stackoverflow.com/users/582917/cmcdragonkai"}, "edited": false, "score": 0, "creation_date": 1459337040, "post_id": 27832320, "comment_id": 60238269, "body": "Is it possible to create functions like <code>compose</code> or <code>apply</code> that work generically over the 3 different traits <code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code>? I find myself having to create 3 different versions of <code>compose</code> or <code>apply</code> to satisfy the 3 traits of closures."}, {"owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "reply_to_user": {"reputation": 5359, "user_id": 582917, "user_type": "registered", "accept_rate": 81, "profile_image": "https://www.gravatar.com/avatar/98a347823cd1db90af884b227a29c29e?s=128&d=identicon&r=PG", "display_name": "CMCDragonkai", "link": "https://stackoverflow.com/users/582917/cmcdragonkai"}, "edited": false, "score": 0, "creation_date": 1459339318, "post_id": 27832320, "comment_id": 60239847, "body": "@CMCDragonkai If you need more details, you should ask a new question, but no, I don&#39;t believe it is.  Keep in mind, however, that all <code>Fn</code>s can be used as <code>FnMut</code>s, and all <code>Fn</code>s and <code>FnMut</code>s can be used as <code>FnOnce</code>s."}], "tags": [], "owner": {"reputation": 44438, "user_id": 42353, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f05e802879a805c03a55645dfcc0d4ea?s=128&d=identicon&r=PG", "display_name": "DK.", "link": "https://stackoverflow.com/users/42353/dk"}, "is_accepted": true, "score": 54, "last_activity_date": 1582730460, "last_edit_date": 1582730460, "creation_date": 1420686781, "answer_id": 27832320, "question_id": 27831944, "link": "https://stackoverflow.com/questions/27831944/how-do-i-store-a-closure-in-a-struct-in-rust/27832320#27832320", "title": "How do I store a closure in a struct in Rust?", "body": "<p>For what type you'd use in your third code snippet, there <em>isn't</em> one; closure types are anonymous and cannot be directly named.  Instead, you'd write:</p>\n\n<pre><code>let foo = Foo { foo: |x| x + 1 };\n</code></pre>\n\n<p>If you're writing code in a context where you <em>need</em> to specify that you want a <code>Foo</code>, you'd write:</p>\n\n<pre><code>let foo: Foo&lt;_&gt; = Foo { foo: |x| x + 1 };\n</code></pre>\n\n<p>The <code>_</code> tells the type system to infer the actual generic type for you.</p>\n\n<p>The general rule of thumb as to <em>which</em> to use, in descending order:</p>\n\n<ul>\n<li>Generic parameters: <code>struct Foo&lt;F: FnMut(usize) -&gt; usize&gt;</code>.  This is the most efficient, but it does mean that a specific <code>Foo</code> instance can only ever store <em>one</em> closure, since every closure has a different concrete type.</li>\n<li>Trait references: <code>&amp;'a mut dyn FnMut(usize) -&gt; usize</code>.  There's a pointer indirection, but now you can store a reference to any closure that has a compatible call signature.</li>\n<li>Boxed closures: <code>Box&lt;dyn FnMut(usize) -&gt; usize&gt;</code>.  This involves allocating the closure on the heap, but you don't have to worry about lifetimes.  As with a reference, you can store any closure with a compatible signature.</li>\n</ul>\n\n<h1>Before Rust 1.0</h1>\n\n<p>Closures that used the <code>||</code> syntax were references to closures stored on the stack, making them equivalent to <code>&amp;'a mut FnMut(usize) -&gt; usize</code>.  Old-style <code>proc</code>s were heap-allocated and were equivalent to <code>Box&lt;dyn FnOnce(usize) -&gt; usize&gt;</code> (you can only call a <code>proc</code> once). </p>\n"}, {"comments": [{"owner": {"reputation": 570, "user_id": 2780630, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/57f6fdc404f5a270e608f3df85f40dfb?s=128&d=identicon&r=PG&f=1", "display_name": "DanielV", "link": "https://stackoverflow.com/users/2780630/danielv"}, "edited": false, "score": 0, "creation_date": 1570485992, "post_id": 52934680, "comment_id": 102921771, "body": "Are any of these choices known to be speedier than the others?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 570, "user_id": 2780630, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/57f6fdc404f5a270e608f3df85f40dfb?s=128&d=identicon&r=PG&f=1", "display_name": "DanielV", "link": "https://stackoverflow.com/users/2780630/danielv"}, "edited": false, "score": 1, "creation_date": 1570498630, "post_id": 52934680, "comment_id": 102924201, "body": "@DanielV yes, and no. If one of them was guaranteed to be universally better than the others, we wouldn&#39;t need the rest. The unboxed closure is probably the default choice and is likely to be the most performant, but the other ones can generate smaller code which might lead to them being more performant."}, {"owner": {"reputation": 32321, "user_id": 173397, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/pqKT8.jpg?s=128&g=1", "display_name": "pm100", "link": "https://stackoverflow.com/users/173397/pm100"}, "edited": false, "score": 1, "creation_date": 1595698107, "post_id": 52934680, "comment_id": 111567227, "body": "rust really needs something like std::function, c++ uniform container for anything invokable."}, {"owner": {"reputation": 32321, "user_id": 173397, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/pqKT8.jpg?s=128&g=1", "display_name": "pm100", "link": "https://stackoverflow.com/users/173397/pm100"}, "edited": false, "score": 0, "creation_date": 1595699424, "post_id": 52934680, "comment_id": 111567628, "body": "what does that &quot;+ &#39;static&quot; mean in the boxed trait one"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 32321, "user_id": 173397, "user_type": "registered", "accept_rate": 78, "profile_image": "https://i.stack.imgur.com/pqKT8.jpg?s=128&g=1", "display_name": "pm100", "link": "https://stackoverflow.com/users/173397/pm100"}, "edited": false, "score": 0, "creation_date": 1595850942, "post_id": 52934680, "comment_id": 111607551, "body": "@pm100 <a href=\"https://stackoverflow.com/q/42028470/155423\">Why is adding a lifetime to a trait with the plus operator (Iterator&lt;Item = &amp;Foo&gt; + &#39;a) needed?</a>; <a href=\"https://stackoverflow.com/q/40053550/155423\">The compiler suggests I add a &#39;static lifetime because the parameter type may not live long enough, but I don&#39;t think that&#39;s what I want</a>;"}, {"owner": {"reputation": 421, "user_id": 6945542, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/ae7260fb1617d777f4535bf4736e6599?s=128&d=identicon&r=PG", "display_name": "Ali Somay", "link": "https://stackoverflow.com/users/6945542/ali-somay"}, "edited": false, "score": 0, "creation_date": 1603525672, "post_id": 52934680, "comment_id": 114070027, "body": "In the <code>Unboxed Closure</code> strategy is it possible to capture the struct which the closure is a member of ?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 421, "user_id": 6945542, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/ae7260fb1617d777f4535bf4736e6599?s=128&d=identicon&r=PG", "display_name": "Ali Somay", "link": "https://stackoverflow.com/users/6945542/ali-somay"}, "edited": false, "score": 2, "creation_date": 1603726030, "post_id": 52934680, "comment_id": 114120152, "body": "@AliSomay Not to capture it, no, but you can pass it as an argument to the the closure itself in certain cases. See <a href=\"https://stackoverflow.com/q/48717833/155423\">How to use struct self in member method closure</a>; <a href=\"https://stackoverflow.com/q/28597380/155423\">How can I modify self in a closure called from a member function?</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 63, "last_activity_date": 1570476823, "last_edit_date": 1570476823, "creation_date": 1540229206, "answer_id": 52934680, "question_id": 27831944, "link": "https://stackoverflow.com/questions/27831944/how-do-i-store-a-closure-in-a-struct-in-rust/52934680#52934680", "title": "How do I store a closure in a struct in Rust?", "body": "<p>Complementing the existing answer with some more code for demonstration purposes:</p>\n\n<h2>Unboxed closure</h2>\n\n<p>Use a generic type:</p>\n\n<pre><code>struct Foo&lt;F&gt;\nwhere\n    F: Fn(usize) -&gt; usize,\n{\n    pub foo: F,\n}\n\nimpl&lt;F&gt; Foo&lt;F&gt;\nwhere\n    F: Fn(usize) -&gt; usize,\n{\n    fn new(foo: F) -&gt; Self {\n        Self { foo }\n    }\n}\n\nfn main() {\n    let foo = Foo { foo: |a| a + 1 };\n    (foo.foo)(42);\n\n    (Foo::new(|a| a + 1).foo)(42);\n}\n</code></pre>\n\n<h2>Boxed trait object</h2>\n\n<pre><code>struct Foo {\n    pub foo: Box&lt;dyn Fn(usize) -&gt; usize&gt;,\n}\n\nimpl Foo {\n    fn new(foo: impl Fn(usize) -&gt; usize + 'static) -&gt; Self {\n        Self { foo: Box::new(foo) }\n    }\n}\n\nfn main() {\n    let foo = Foo {\n        foo: Box::new(|a| a + 1),\n    };\n    (foo.foo)(42);\n\n    (Foo::new(|a| a + 1).foo)(42);\n}\n</code></pre>\n\n<h2>Trait object reference</h2>\n\n<pre><code>struct Foo&lt;'a&gt; {\n    pub foo: &amp;'a dyn Fn(usize) -&gt; usize,\n}\n\nimpl&lt;'a&gt; Foo&lt;'a&gt; {\n    fn new(foo: &amp;'a dyn Fn(usize) -&gt; usize) -&gt; Self {\n        Self { foo }\n    }\n}\n\nfn main() {\n    let foo = Foo { foo: &amp;|a| a + 1 };\n    (foo.foo)(42);\n\n    (Foo::new(&amp;|a| a + 1).foo)(42);\n}\n</code></pre>\n\n<h2>Function pointer</h2>\n\n<pre><code>struct Foo {\n    pub foo: fn(usize) -&gt; usize,\n}\n\nimpl Foo {\n    fn new(foo: fn(usize) -&gt; usize) -&gt; Self {\n        Self { foo }\n    }\n}\n\nfn main() {\n    let foo = Foo { foo: |a| a + 1 };\n    (foo.foo)(42);\n\n    (Foo::new(|a| a + 1).foo)(42);\n}\n</code></pre>\n\n<hr>\n\n<blockquote>\n  <p>what's the type of a <code>Foo</code> object I create?</p>\n</blockquote>\n\n<p>It's an unnameable, automatically generated type. </p>\n\n<blockquote>\n  <p>I could also use a reference [...] slower because [...] the pointer deref [...] no specialization </p>\n</blockquote>\n\n<p>Perhaps, but it can be much easier on the caller.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/27994509/155423\">How do I call a function through a member variable?</a></li>\n<li><a href=\"https://stackoverflow.com/q/25445761/155423\">Returning a closure from a function</a></li>\n<li><a href=\"https://stackoverflow.com/q/49980850/155423\">How to return an anonymous type from a trait method without using Box?</a></li>\n<li><a href=\"https://stackoverflow.com/q/41082409/155423\">Closures as a type in a Rust struct</a></li>\n<li><a href=\"https://stackoverflow.com/q/27874683/155423\">Types of unboxed closures being unique to each</a></li>\n<li><a href=\"https://stackoverflow.com/q/52696907/155423\">Why does passing a closure to function which accepts a function pointer not work?</a></li>\n<li><a href=\"https://stackoverflow.com/q/50650070/155423\">What does &quot;dyn&quot; mean in a type?</a></li>\n</ul>\n"}], "owner": {"reputation": 4398, "user_id": 417803, "user_type": "registered", "accept_rate": 82, "profile_image": "https://www.gravatar.com/avatar/78bce6b348f3c186e4830cf1dde37382?s=128&d=identicon&r=PG", "display_name": "bfops", "link": "https://stackoverflow.com/users/417803/bfops"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 24215, "favorite_count": 13, "accepted_answer_id": 27832320, "answer_count": 2, "score": 54, "last_activity_date": 1582730460, "creation_date": 1420683513, "last_edit_date": 1559131523, "question_id": 27831944, "link": "https://stackoverflow.com/questions/27831944/how-do-i-store-a-closure-in-a-struct-in-rust", "title": "How do I store a closure in a struct in Rust?", "body": "<p>Before Rust 1.0, I could write a structure using this obsolete closure syntax:</p>\n\n<pre><code>struct Foo {\n    pub foo: |usize| -&gt; usize,\n}\n</code></pre>\n\n<p>Now I can do something like:</p>\n\n<pre><code>struct Foo&lt;F: FnMut(usize) -&gt; usize&gt; {\n    pub foo: F,\n}\n</code></pre>\n\n<p>But then what's the type of a <code>Foo</code> object I create?</p>\n\n<pre><code>let foo: Foo&lt;???&gt; = Foo { foo: |x| x + 1 };\n</code></pre>\n\n<p>I could also use a reference:</p>\n\n<pre><code>struct Foo&lt;'a&gt; {\n    pub foo: &amp;'a mut FnMut(usize) -&gt; usize,\n}\n</code></pre>\n\n<p>I think this is slower because</p>\n\n<ol>\n<li>the pointer dereference</li>\n<li>there's no specialization for the type of <code>FnMut</code> that actually ends up being used</li>\n</ol>\n"}]