[{"tags": ["rust"], "comments": [{"owner": {"reputation": 148712, "user_id": 19750, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/13b41b2620da0b1e630715e0c91a0b03?s=128&d=identicon&r=PG", "display_name": "Josh Lee", "link": "https://stackoverflow.com/users/19750/josh-lee"}, "edited": false, "score": 1, "creation_date": 1480537247, "post_id": 40897157, "comment_id": 69008597, "body": "<a href=\"https://stackoverflow.com/questions/30411594/moving-a-boxed-function\" title=\"moving a boxed function\">stackoverflow.com/questions/30411594/moving-a-boxed-function</a>"}, {"owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "reply_to_user": {"reputation": 148712, "user_id": 19750, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/13b41b2620da0b1e630715e0c91a0b03?s=128&d=identicon&r=PG", "display_name": "Josh Lee", "link": "https://stackoverflow.com/users/19750/josh-lee"}, "edited": false, "score": 0, "creation_date": 1482087086, "post_id": 40897157, "comment_id": 69622265, "body": "It looks like what I really want is the <code>&amp;move</code> pointer as specified in <a href=\"https://github.com/rust-lang/rfcs/pull/1646\" rel=\"nofollow noreferrer\">this RFC</a>"}], "answers": [{"comments": [{"owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "edited": false, "score": 0, "creation_date": 1480594308, "post_id": 40904140, "comment_id": 69032918, "body": "Yeah, this is probably what I&#39;ll do if I can&#39;t get it to work without heap allocation"}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 2, "last_activity_date": 1480574473, "creation_date": 1480574473, "answer_id": 40904140, "question_id": 40897157, "link": "https://stackoverflow.com/questions/40897157/can-i-create-an-owned-pointer-to-a-stack-object/40904140#40904140", "title": "Can I create an owned pointer to a stack object", "body": "<p>As stated, the answer to the question is \"no\".</p>\n\n<p>If you pass ownership of the closure, you have to by definition move it into the owner (otherwise what you've got is a reference).  You can do that if you've only got one callback using a generic type:</p>\n\n<pre><code>pub struct NoHeapScheduler&lt;F:FnOnce()&gt; {\n    f: Option&lt;F&gt;,\n}\n\nimpl&lt;F:FnOnce()&gt; NoHeapScheduler&lt;F&gt; {\n    pub fn add_task(&amp;mut self, f: F) {\n        self.f = Some(f);\n    }\n    pub fn run(&amp;mut self) {\n        let f = self.f.take().unwrap();\n        f()\n    }\n}\n\nfn main() {\n    let mut scheduler = NoHeapScheduler{ f: None };\n\n    let task = move || {};\n\n    scheduler.add_task(task);\n\n    scheduler.run();\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=2eb657b8a524eb6807bd34d39fd467c1&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a></p>\n\n<p>However you'd run into problems adding more than one closure, since they all have different types.</p>\n\n<p>If you're willing to allow allocations <em>and</em> an unstable feature on the nightly compiler, you could use <code>FnBox</code>.  This is <a href=\"https://stackoverflow.com/questions/30411594/moving-a-boxed-function\">like <code>FnOnce</code> but works with <code>Box</code></a>:</p>\n\n<pre><code>#![feature(fnbox)]\nuse std::boxed::FnBox;\n\npub struct NoHeapScheduler {\n    v: Vec&lt;Box&lt;FnBox()&gt;&gt;,\n}\n\nimpl NoHeapScheduler {\n    pub fn add_task(&amp;mut self, f: Box&lt;FnBox()&gt;) {\n        self.v.push(f);\n    }\n    pub fn run(&amp;mut self) {\n        for f in self.v.drain(0..) {\n            f();\n        }\n    }\n}\n\nfn main() {\n    let mut scheduler = NoHeapScheduler{ v: Vec::new() };\n\n    let task = move || {println!(\"Hello,\"); };\n    let other_task = move || {println!(\"world!\"); };\n\n    scheduler.add_task(Box::new(task));\n    scheduler.add_task(Box::new(other_task));\n\n    scheduler.run();\n}\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=4c68422b823dad59c0275fe24c0b5865&amp;version=nightly&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a></p>\n"}, {"comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480588118, "post_id": 40905437, "comment_id": 69028789, "body": "I wonder about the nonsensical part. The object can remain on the stack, but not <a href=\"https://doc.rust-lang.org/nomicon/references.html#liveness\" rel=\"nofollow noreferrer\">&quot;live&quot;</a>, as in <code>let mut foo = 1; { let foo_ref = &amp;mut foo; *foo_ref = 2 }; foo = 3</code>. Inside the inner block an owning reference to the stack object is created, and <code>foo</code> is no longer live. Once the reference is dropped, <code>foo</code> is live again. If we don&#39;t need <code>foo</code> later, it should be safe to pass the reference to the scheduler, as long as Rust could prove that the scheduler&#39;s use of the reference wouldn&#39;t outlive the object."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480588257, "post_id": 40905437, "comment_id": 69028874, "body": "@user4815162342: there is no notion of <i>owning reference</i> in Rust. An owner is in control of the lifetime of the object, while a reference only <i>borrows</i> the object and guarantees that the object will be alive (with all its invariants in place) after the borrow ends."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480588696, "post_id": 40905437, "comment_id": 69029223, "body": "Point taken, but I suspect the OP was referring to <i>mutable reference</i>."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 1, "creation_date": 1480592510, "post_id": 40905437, "comment_id": 69031739, "body": "@user4815162342: Given that he is talking about <code>FnOnce</code>, a mutable reference is not sufficient."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 4, "last_activity_date": 1480579456, "creation_date": 1480579456, "answer_id": 40905437, "question_id": 40897157, "link": "https://stackoverflow.com/questions/40897157/can-i-create-an-owned-pointer-to-a-stack-object/40905437#40905437", "title": "Can I create an owned pointer to a stack object", "body": "<blockquote>\n  <p>Can I create an owned pointer to a stack object?</p>\n</blockquote>\n\n<p>No. This is non-sensical actually, since by definition a stack object is owned by the stack, so it cannot <em>also</em> be owned by something else.</p>\n\n<blockquote>\n  <p>So I need to pass an owned pointer (e.g. Box) without heap allocation.</p>\n</blockquote>\n\n<p>There are other owned pointers than <code>Box</code>.</p>\n\n<p>At the moment, I know of none without a heap allocation, but there is little reason it cannot be done.</p>\n\n<p>I envision a <code>InlineFnOnceBox&lt;S: Default, R, A&gt;</code> used as <code>InlineFnOnceBox&lt;[u8; 48], (), ()&gt;</code> in this case, which would contain both the array itself, used as backing storage, plus a virtual pointer to the <code>FnOnce&lt;A -&gt; R&gt;</code> v-table for the type instantiated.</p>\n\n<p>It requires some care (and <code>unsafe</code> code) to instantiate, but otherwise seems feasible.</p>\n"}, {"comments": [{"owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "edited": false, "score": 0, "creation_date": 1480594442, "post_id": 40906151, "comment_id": 69033007, "body": "This is clever. It seems like it might not be very ergonomic for some tasks (like running tasks out of order), but I&#39;ll give it a shot."}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "reply_to_user": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "edited": false, "score": 2, "creation_date": 1480594744, "post_id": 40906151, "comment_id": 69033177, "body": "@awelkie: You can write any algorithm you could write on a linked list. So if you can write an algorithm for linked list reordering, then you can write it for this setup. But it&#39;s all happening at compile-time. Once you go into runtime-decisions it might end up requiring some allocations, I&#39;m not sure. Open another question when you hit that ;)"}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 3, "last_activity_date": 1480582211, "creation_date": 1480582211, "answer_id": 40906151, "question_id": 40897157, "link": "https://stackoverflow.com/questions/40897157/can-i-create-an-owned-pointer-to-a-stack-object/40906151#40906151", "title": "Can I create an owned pointer to a stack object", "body": "<blockquote>\n  <p>Can I create an owned pointer to a stack object?</p>\n</blockquote>\n\n<p>No, but you can simply move the stack object into your scheduler. Your scheduler will increase in size with every closure you schedule, but it will be completely self contained an can even be moved around.</p>\n\n<p>The basic idea is that your Scheduler becomes a kind of singly linked list:</p>\n\n<pre><code>pub trait Scheduler: Sized {\n    fn run(self);\n}\npub struct NoHeapScheduler&lt;F: FnOnce(), T: Scheduler&gt; {\n    inner: T,\n    f: F,\n}\nimpl&lt;F: FnOnce(), T: Scheduler&gt; Scheduler for NoHeapScheduler&lt;F, T&gt; {\n    fn run(self) {\n        self.inner.run();\n        (self.f)()\n    }\n}\n</code></pre>\n\n<p>The <code>Scheduler</code> trait is here to break the recursion chain in the <code>NoHeapScheduler</code> (Otherwise we'd need a feature like variadic generics).</p>\n\n<p>To terminate the chain we also implement <code>Scheduler</code> for some no-op type, e.g. <code>()</code>:</p>\n\n<pre><code>impl Scheduler for () {\n    fn run(self) {}\n}\n</code></pre>\n\n<p>Now the only thing left is a way to add new closures.</p>\n\n<pre><code>impl&lt;F: FnOnce(), T: Scheduler&gt; NoHeapScheduler&lt;F, T&gt; {\n    fn add_task&lt;F2: FnOnce()&gt;(self, f: F2) -&gt; NoHeapScheduler&lt;F2, Self&gt; {\n        NoHeapScheduler {\n            inner: self,\n            f: f,\n        }\n    }\n}\n</code></pre>\n\n<p>This method moves The current scheduler into a new scheduler and adds the scheduled closure.</p>\n\n<p>You can use this function like so:</p>\n\n<pre><code>let scheduler = scheduler.add_task(task);\n</code></pre>\n\n<p>Fully working example in the <a href=\"https://play.rust-lang.org/?gist=3da286297dfb8cce026846a3982f90b4&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">playground</a></p>\n"}, {"comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480723370, "post_id": 40934796, "comment_id": 69096820, "body": "Can you show what <code>add_task</code> would look like? I understand how to implement <code>add_task()</code> that accepts <code>&amp;mut Callable</code>, but it only works for closures created before the creation of the scheduler. <a href=\"https://play.rust-lang.org/?gist=26177963f40b7337bcab93c547fe2493&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground</a>"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480725944, "post_id": 40934796, "comment_id": 69097452, "body": "OK, I think I got it: the variables holding the options must be declared above the <code>scheduler</code> initialization, otherwise the scheduler&#39;s scope technically doesn&#39;t contain the options&#39; scope. The option variables can even be uninitialized at the time the scope is created. (The scheduler&#39;s array itself uses an <code>Option</code> to enable the tasks to reside in the stack-allocated array of <code>Callable</code> trait objects.) <a href=\"https://play.rust-lang.org/?gist=703d95a7b9dfff9338cba8f7dd649889&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Playground link</a>"}, {"owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480732883, "post_id": 40934796, "comment_id": 69098550, "body": "I ended up just passing all of the tasks as a list to the scheduler. So it would be something like <code>scheduler.run(&amp;[&amp;mut Some(move ||) as &amp;mut Callable, ...]);</code>"}], "tags": [], "owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "is_accepted": true, "score": 0, "last_activity_date": 1480689798, "creation_date": 1480689798, "answer_id": 40934796, "question_id": 40897157, "link": "https://stackoverflow.com/questions/40897157/can-i-create-an-owned-pointer-to-a-stack-object/40934796#40934796", "title": "Can I create an owned pointer to a stack object", "body": "<p>I can use an <code>Option</code> to do this. I can keep the <code>Option</code> on the stack and pass a mutable reference around, and then when I'm ready to consume the closure I can use <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html#method.take\" rel=\"nofollow noreferrer\"><code>Option::take</code></a> to take ownership of the closure and consume it.</p>\n\n<p>To handle different implementations of <code>FnOnce</code>, I can lift this out into a trait and use trait objects:</p>\n\n<pre><code>trait Callable {\n    fn call(&amp;mut self);\n}\n\nimpl&lt;F: FnOnce()&gt; Callable for Option&lt;F&gt; {\n    fn call(&amp;mut self) {\n        if let Some(func) = self.take() {\n            func();\n        }\n    }\n}\n</code></pre>\n\n<p>Then I can pass around trait objects that live on the stack but can be consumed by having the reference.</p>\n"}], "owner": {"reputation": 1992, "user_id": 1486074, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/3997074174cc14081602e4f3c76091a5?s=128&d=identicon&r=PG", "display_name": "awelkie", "link": "https://stackoverflow.com/users/1486074/awelkie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 173, "favorite_count": 0, "accepted_answer_id": 40934796, "answer_count": 4, "score": 6, "last_activity_date": 1480689798, "creation_date": 1480536215, "question_id": 40897157, "link": "https://stackoverflow.com/questions/40897157/can-i-create-an-owned-pointer-to-a-stack-object", "title": "Can I create an owned pointer to a stack object", "body": "<p>I would like to pass a <code>FnOnce</code> closure to an object to be used later, but I would like to avoid any heap allocation. I can avoid heap allocation by keeping the closure on the stack. But the problem is that I can't pass a reference to the object because the <code>FnOnce</code> <code>call_once</code> consumes the closure. So I need to pass an owned pointer (e.g. <code>Box</code>) without heap allocation.</p>\n\n<p>Is this possible? What I'd like to do is this:</p>\n\n<pre><code>fn main() {\n    let mut scheduler = NoHeapScheduler();\n\n    // allocate the task on the stack\n    let task = move ||;\n\n    // somehow pass ownership of the closure, while keeping it allocated on the stack.\n    scheduler.add_task(StaticBox::new(task));\n\n    schedule.run();\n}\n</code></pre>\n\n<p>As far as I know this should be safe as long as the scheduler doesn't outlive the task. Is there any way to make this happen?</p>\n"}, {"tags": ["reference", "rust", "operator-overloading"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480534151, "post_id": 40896419, "comment_id": 69007043, "body": "Why not just do what the error message tells you and use a <code>let</code> binding? <code>let f = &amp;a + &amp;a; let f2 = &amp;f + &amp;a;</code>. Why do you store references to <code>Node</code>s in the first place, instead of just storing them directly? Why not implement <code>Add</code> for non-references?"}, {"owner": {"reputation": 615, "user_id": 4176597, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/4f118d3068ac55ffc44752d308d50ee7?s=128&d=identicon&r=PG&f=1", "display_name": "ethanabrooks", "link": "https://stackoverflow.com/users/4176597/ethanabrooks"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480539965, "post_id": 40896419, "comment_id": 69010112, "body": "Thanks for the suggestion @Shepmaster. So I am currently using <code>f1 = ...; f2 =  ...</code>. It just makes the code difficult to read when you&#39;re dealing with a large complicated equation. The reason for storing references is that using add-for non-references would require a copy and that is problematic for performance (I&#39;ve simplified the code a little, but in the real version, graph Nodes can contain large matrices)."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1480546147, "post_id": 40896419, "comment_id": 69013131, "body": "What went wrong when using <code>Rc</code>?"}, {"owner": {"reputation": 615, "user_id": 4176597, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/4f118d3068ac55ffc44752d308d50ee7?s=128&d=identicon&r=PG&f=1", "display_name": "ethanabrooks", "link": "https://stackoverflow.com/users/4176597/ethanabrooks"}, "edited": false, "score": 0, "creation_date": 1480555771, "post_id": 40896419, "comment_id": 69016026, "body": "I wasn&#39;t able to overload operators with Rc. I edited the original post with more details."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1480606883, "post_id": 40896419, "comment_id": 69041628, "body": "@ethanabrooks <code>Rc</code> implements <code>Deref</code> and <code>Clone</code>, so with <code>Rc</code> you should be able to write <code>&amp;foo + &amp;bar</code> or <code>foo.clone() + bar.clone()</code>, depending on whether you implement <code>Add</code> for reference or the value."}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1480602029, "creation_date": 1480602029, "answer_id": 40913002, "question_id": 40896419, "link": "https://stackoverflow.com/questions/40896419/how-to-overload-add-for-computational-graph-nodes-in-rust/40913002#40913002", "title": "How to overload Add for computational graph nodes in Rust", "body": "<p>Let's start by recognizing that <code>Node</code> and <code>Expr</code> are redundant:</p>\n\n<pre><code>use std::ops::Add;\n\n#[derive(Debug)]\npub enum Expr&lt;'a&gt; {\n    Constant(f32),\n    Add(&amp;'a Expr&lt;'a&gt;, &amp;'a Expr&lt;'a&gt;),\n}\n\nimpl&lt;'a&gt; Add for &amp;'a Expr&lt;'a&gt; {\n    type Output = Expr&lt;'a&gt;;\n    fn add(self, other: &amp;'a Expr&lt;'a&gt;) -&gt; Expr&lt;'a&gt; {\n        Expr::Add(self, other)\n    }\n}\n\nfn main() {\n    let a = Expr::Constant(1.);\n    let f = &amp;(&amp;a + &amp;a) + &amp;a;\n    println!(\"f: {:#?}\", f);\n}\n</code></pre>\n\n<blockquote>\n  <p>I am using references because I want to avoid copying <code>Node</code> structs. The code here is slightly simplified; in the version I'm working with, these can hold a lot of data.</p>\n</blockquote>\n\n<p>This is why your code doesn't work. Consider the following perfectly valid implementation of <code>Add</code>:</p>\n\n<pre><code>fn add(self, other: &amp;'a Expr&lt;'a&gt;) -&gt; Expr&lt;'a&gt; {\n    Expr::Constant(42.0)\n}\n</code></pre>\n\n<p>Then we call that and return it as the first half of this expression:</p>\n\n<pre><code>let f = &amp;(&amp;a + &amp;a) + &amp;a;\n//       ^-------- here\n</code></pre>\n\n<p>Where is that <code>Constant</code> stored? There's just a temporary value without an owner. When you do the <em>second</em> addition, you are trying to take a reference to that that has to live for the entire time that <code>f</code> is valid. Except the value will be dropped as soon as that expression is over, because there is nothing to own it. Thus you are prevented from doing anything of the sort.</p>\n\n<p>Additionally, <code>&amp;'a Expr&lt;'a&gt;</code> means that the lifetime <code>'a</code> has to be the unification of the references lifetime and the contained data's lifetime. This means that <code>'a</code> will be shortened to the the life of the <code>Expr</code> passed in, which in this case again ends at the end of the statement.</p>\n\n<p>Normally, whenever I see <code>&amp;'a Foo&lt;'a&gt;</code>, I think one of two things:</p>\n\n<ol>\n<li>That should be <code>Foo&lt;'a&gt;</code> \u2014 <code>Foo</code> is just a wrapper around other types of references and doesn't need to have another reference.</li>\n<li>That should be <code>&amp;'a Foo&lt;'b&gt;</code> \u2014 we have references to something which has references, and they have differing lifetimes.</li>\n</ol>\n\n<p>The latter doesn't work here - it's complicated to explain, but ultimately you end up with something like</p>\n\n<pre><code>#[derive(Debug)]\npub enum Expr&lt;'e, 'd&gt; {\n    Constant(f32),\n    Add(&amp;'e Expr&lt;'e, 'd&gt;, &amp;'e Expr&lt;'e, 'd&gt;),\n}\n</code></pre>\n\n<p>Which <em>never actually uses the <code>'d</code> parameter</em>!</p>\n\n<p>Doing the first option is fine if you can own the large data outside of your expression hierarchy:</p>\n\n<pre><code>use std::ops::Add;\n\ntype LargeMatrix = Vec&lt;u8&gt;;\n\n#[derive(Clone, Debug)]\npub enum Expr&lt;'a&gt; {\n    Constant(&amp;'a LargeMatrix),\n    Add(Box&lt;Expr&lt;'a&gt;&gt;, Box&lt;Expr&lt;'a&gt;&gt;),\n}\n\nimpl&lt;'a&gt; Add for Expr&lt;'a&gt; {\n    type Output = Expr&lt;'a&gt;;\n    fn add(self, other: Expr&lt;'a&gt;) -&gt; Expr&lt;'a&gt; {\n        Expr::Add(Box::new(self), Box::new(other))\n    }\n}\n\nfn main() {\n    let m = LargeMatrix::new();\n\n    let a = Expr::Constant(&amp;m);\n    let f = (a.clone() + a.clone()) + a;\n    println!(\"f: {:#?}\", f);\n}\n</code></pre>\n\n<p>If you want the expression tree to own the large data as well as references to subtrees, then you can use <code>Rc</code>, as suggested in the comments. Whenever the data is cloned, only the reference counters are incremented, so no large copies will be made:</p>\n\n<pre><code>use std::ops::Add;\nuse std::rc::Rc;\n\ntype LargeMatrix = Vec&lt;u8&gt;;\n\n#[derive(Clone, Debug)]\npub enum Expr {\n    Constant(Rc&lt;LargeMatrix&gt;),\n    Add(Rc&lt;Expr&gt;, Rc&lt;Expr&gt;),\n}\n\nimpl Add for Expr {\n    type Output = Expr;\n    fn add(self, other: Expr) -&gt; Expr {\n        Expr::Add(Rc::new(self), Rc::new(other))\n    }\n}\n\nfn main() {\n    let a = Expr::Constant(Rc::new(LargeMatrix::new()));\n    let f = (a.clone() + a.clone()) + a;\n    println!(\"f: {:#?}\", f);\n}\n</code></pre>\n\n<p>You could then choose to implement addition for references:</p>\n\n<pre><code>impl&lt;'a&gt; Add for &amp;'a Expr {\n    type Output = Expr;\n    fn add(self, other: &amp;'a Expr) -&gt; Expr {\n        Expr::Add(Rc::new(self.clone()), Rc::new(other.clone()))\n    }\n}\n</code></pre>\n\n<p>And the other two variants (<code>&amp;Expr + Expr</code>, <code>Expr + &amp;Expr</code>) if you need.</p>\n"}, {"tags": [], "owner": {"reputation": 615, "user_id": 4176597, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/4f118d3068ac55ffc44752d308d50ee7?s=128&d=identicon&r=PG&f=1", "display_name": "ethanabrooks", "link": "https://stackoverflow.com/users/4176597/ethanabrooks"}, "is_accepted": false, "score": 0, "last_activity_date": 1480625217, "creation_date": 1480625217, "answer_id": 40920059, "question_id": 40896419, "link": "https://stackoverflow.com/questions/40896419/how-to-overload-add-for-computational-graph-nodes-in-rust/40920059#40920059", "title": "How to overload Add for computational graph nodes in Rust", "body": "<p>Thank you all for your help and suggestions. I didn't realize that cloning an <code>Rc</code> didn't clone the inner values. So I was able to reimplement my code as follows:</p>\n\n<pre><code>use std::ops::Add;\nuse std::rc::Rc;\n\n#[derive(Debug)]\npub enum Expr {\n    Constant(f32),\n    //       ^^^--this is a simplified version. In the real version,\n    //            Constant holds large matrices and I would like to \n    //            avoid copying it. \n    Add(Node, Node),  // USED TO BE ADD(&amp;NODE, &amp;NODE)\n}\n\n#[derive(Debug, Clone)] // CLONE IS NEW\npub struct Node {      \n    pub body: Rc&lt;Expr&gt; // CHANGED TO RC\n}\n\n// THIS IS NEW\nimpl Add for Node {\n    type Output = Node;\n    fn add(self, other: Node) -&gt; Node { &amp;self + &amp;other }\n}\n\nimpl&lt;'a&gt; Add for &amp;'a Node {\n    type Output = Node;\n    fn add(self, other: &amp;Node) -&gt; Node {\n        Node { \n          body: Rc::new(Expr::Add(self.clone(), other.clone()))\n      }\n    }\n}\n\nfn main() {\n    let a = Node { body: Rc::new(Expr::Constant(1.)) };\n    let f: Node = &amp;a + &amp;a + a; // &lt;-- basically, the desired outcome\n    println!(\"f: {:#?}\", f);\n}\n</code></pre>\n\n<p>It would be nice if I could somehow get rid of the <code>&amp;</code>s in the definition of <code>f</code>, but the only way seems to be to implement <code>Copy</code>. Unfortunately, this is not possible in the real version because <code>Node</code> has an additional field, <code>output</code>, with type <code>Rc&lt;RefCell&lt;Option&lt;Constant&gt;</code> where <code>Constant</code> is an enum \ud83d\ude2c. I know, not the best, but unfortunately I need aliased mutability and that seems to be the only way. Anyway, this monster of a type can't implement <code>Copy</code>. Any ideas on that front are welcome, but otherwise, thanks for your help!</p>\n"}], "owner": {"reputation": 615, "user_id": 4176597, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/4f118d3068ac55ffc44752d308d50ee7?s=128&d=identicon&r=PG&f=1", "display_name": "ethanabrooks", "link": "https://stackoverflow.com/users/4176597/ethanabrooks"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 158, "favorite_count": 0, "accepted_answer_id": 40913002, "answer_count": 2, "score": 1, "last_activity_date": 1480625217, "creation_date": 1480533400, "last_edit_date": 1480599559, "question_id": 40896419, "link": "https://stackoverflow.com/questions/40896419/how-to-overload-add-for-computational-graph-nodes-in-rust", "title": "How to overload Add for computational graph nodes in Rust", "body": "<p>I am creating a computational graph, a program that models equations as graphs so they can be differentiated, for example. I have overloaded operators so that adding graph nodes creates new graph nodes. However, I find myself fighting the borrow checker. Here's the code:</p>\n\n<pre><code>use std::ops::Add;\n\n#[derive(Debug)]\npub enum Expr&lt;'a&gt; {\n    Constant(f32),\n    //       ^^^--this is a simplified version. In the real version,\n    //            Constant holds large matrices and I would like to \n    //            avoid copying it. \n    Add(&amp;'a Node&lt;'a&gt;, &amp;'a Node&lt;'a&gt;),\n}\n\n#[derive(Debug)]\npub struct Node&lt;'a&gt; {\n    pub body: Expr&lt;'a&gt;\n}\n\nimpl&lt;'a&gt; Add for &amp;'a Node&lt;'a&gt; {\n    type Output = Node&lt;'a&gt;;\n    fn add(self, other: &amp;'a Node&lt;'a&gt;) -&gt; Node&lt;'a&gt; {\n        Node { body: Expr::Add(self, other) }\n    }\n}\n\nfn main() {\n    let a = Node { body: Expr::Constant(1.) };\n    let f: Node = &amp;(&amp;a + &amp;a) + &amp;a;\n    println!(\"f: {:#?}\", f);\n}\n</code></pre>\n\n<p>As you can see, <code>+</code> needs to take two <code>graph::Node</code> struct references and return a <code>graph::Node</code> struct. Because <code>&amp;(&amp;a + &amp;a)</code> gets created and dies in the same line, I get this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: borrowed value does not live long enough\n  --&gt; src/main.rs:25:20\n   |\n25 |     let f: Node = &amp;(&amp;a + &amp;a) + &amp;a;\n   |                    ^^^^^^^^^     - temporary value only lives until here\n   |                    |\n   |                    temporary value created here\n26 | }\n   | - temporary value needs to live until here\n   |\n   = note: consider using a `let` binding to increase its lifetime\n</code></pre>\n\n<p>I am using references because I want to avoid copying <code>Node</code> structs. The code here is slightly simplified; in the version I'm working with, these can hold a lot of data. </p>\n\n<p>I've tried static references and <code>Rc</code> pointers and had no success. When I try to use <code>Rc</code> pointers, the compiler complains about overloading <code>Add</code>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n  --&gt; function.rs:86:1\n   |\n86 | impl Add for Rc&lt;Function&gt; {\n   | ^ impl doesn't use types inside crate\n   |\n   = note: the impl does not reference any types defined in this crate\n</code></pre>\n\n<p>Currently I'm just defining new variables for every operation which is really messy:</p>\n\n<pre><code>let f1 = &amp;a + &amp;a;\n...\nlet f = &amp;a + f1\n</code></pre>\n\n<p>What would be ideal is if I could avoid using references altogether (that would make the code a lot cleaner). At the very least, I need some way to generate new nodes from the addition of existing nodes.</p>\n"}, {"tags": ["rust", "lifetime", "borrow-checker"], "comments": [{"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 1, "creation_date": 1480459837, "post_id": 40877109, "comment_id": 68969566, "body": "If the <code>Edge</code> contains a reference to a <code>Node</code>, you need a place to &quot;store&quot; the <code>Node</code>. The <code>Node</code> needs an owner. Your data structure does not look able to do that."}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1480460030, "post_id": 40877109, "comment_id": 68969645, "body": "You could <a href=\"https://play.rust-lang.org/?gist=26407a3243e4bb68167b547339af1fc5&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">try reference counting instead if that is suitable for you</a>. I never know if this is idiomatic though because I haven&#39;t actually implemented any sort of custom, self-referential data structure in Rust yet."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "edited": false, "score": 0, "creation_date": 1480462397, "post_id": 40877109, "comment_id": 68970533, "body": "@SimonWhitehead why do you say self-referential? I don&#39;t think there&#39;s any loops in the references; said another way, it&#39;s a tree, not a graph."}, {"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "edited": false, "score": 0, "creation_date": 1480462914, "post_id": 40877109, "comment_id": 68970709, "body": "Whoever downvoted here, care to explain? And how would you approach this problem instead, if you think this question is pointless and the answer is so self-evident?"}, {"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480464037, "post_id": 40877109, "comment_id": 68971013, "body": "@Shepmaster Right. Is that because of the property of tries (only one incoming edge for a node)? If there are multiple edges that can point to the same node, surely I&#39;ll need some sort of reference then?"}, {"owner": {"reputation": 57021, "user_id": 1517578, "user_type": "registered", "accept_rate": 60, "profile_image": "https://i.stack.imgur.com/gd070.png?s=128&g=1", "display_name": "Simon Whitehead", "link": "https://stackoverflow.com/users/1517578/simon-whitehead"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480464532, "post_id": 40877109, "comment_id": 68971110, "body": "@Shepmaster Heh.. off to a great start today :| Honestly I thought it was self referential on my initial pass, which is why I went the <code>Rc</code> route. I need more coffee I think."}], "answers": [{"comments": [{"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480513690, "post_id": 40888439, "comment_id": 68993642, "body": "@Shepmaster You are right, I missed the part where node refers to edges through vector. I&#39;ve modified the answer accordingly."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480513959, "post_id": 40888439, "comment_id": 68993835, "body": "I would discourage using an <code>Rc</code> here because it adds overhead that isn&#39;t needed - there will never be a node owned by more than one thing."}, {"owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480515614, "post_id": 40888439, "comment_id": 68995093, "body": "@Shepmaster Just talked to my lecturer and he suggested that one could still use <code>Box</code>, since then Rust can know the size of the structure inside precisely and thus save a bit memory. If we store it directly inside, we would probably need to <code>shrink</code> from time to time because Rust might overallocate. Not a big saving but still. Does that make sense?"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480515680, "post_id": 40888439, "comment_id": 68995132, "body": "@Shepmaster I offered <code>Rc</code> as an option because the OP hinted at sharing of nodes in a comment: <i>If there are multiple edges that can point to the same node, surely I&#39;ll need some sort of reference then</i>"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "edited": false, "score": 2, "creation_date": 1480515786, "post_id": 40888439, "comment_id": 68995202, "body": "@JIXiang Using a box instead of inline storage can save memory when uised inside an <code>enum</code> where inline storage can needlessly enlarge the whole <code>enum</code>. (This might have been the use case your lecturer referred to.) Using a box inside a <code>struct</code> would end up requiring <i>more</i> memory (because you need the space for the pointer and the separate space for the allocated block), more fragmentation and less memory locality to boot."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "edited": false, "score": 0, "creation_date": 1480515815, "post_id": 40888439, "comment_id": 68995227, "body": "@JIXiang no, that doesn&#39;t really make sense. The compiler <i>always</i> knows the exact size of <code>Node</code>, and it doesn&#39;t change during the program execution. A <code>Box&lt;Node&gt;</code> might be <i>smaller</i> than <code>Node</code>, but the overall memory requirements would go up (still need to allocate the <code>Node</code> and now store the pointer) and then there&#39;s extra indirection (and access time) to get to the actual details inside the <code>Node</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480515929, "post_id": 40888439, "comment_id": 68995317, "body": "@user4815162342 pedantically, it could reduce the <i>size</i> of either the enum or a struct, but in both cases the memory usage would go up (always for a struct, only when that variant is used for the enum)."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1480516661, "post_id": 40888439, "comment_id": 68995849, "body": "@Shepmaster Yes, you get a net savings from boxing only provided that the larger variant is sufficiently rare. The book <i>Programming Rust</i> by Blandy and Orendorff gives an example of this when discussing an enum that describes JSON data, most variants of which are primitive types, and one variant is a <code>HashMap</code>. It makes sense to box the hashmap to reduce the size of the whole enum."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 2, "last_activity_date": 1480525368, "last_edit_date": 1480525368, "creation_date": 1480509061, "answer_id": 40888439, "question_id": 40877109, "link": "https://stackoverflow.com/questions/40877109/borrowed-value-does-not-live-long-enough-error-in-trie-insertion/40888439#40888439", "title": "&quot;borrowed value does not live long enough&quot; error in trie insertion", "body": "<p>This data structure can't work as designed. The red flag is the following sentence:</p>\n\n<blockquote>\n  <p>I think the return value should be a reference to a <code>Node</code>: if the character is already in one of the edges, then we directly return the existing <code>Node</code>; if not, we return the newly created <code>Node</code>.</p>\n</blockquote>\n\n<p>The code doesn't return the newly created node, it attempts to return a <em>reference</em> to the newly created node. Returning a reference to an object is only safe if the object is stored in a place where it will outlive the reference. Otherwise the reference would end up pointing to the location on the stack where the object used to reside, resulting in a crash when used. Mistakes like this one were a frequent source of crashes in C and C++ and are precisely the kind of bug that Rust's borrow checker was designed to prevent.</p>\n\n<p>Rust tracks reference lifetimes using the lifetime parameter on functions and data. To prove that the reference will not outlive the object, Rust prohibits the lifetime of the reference to extend beyond the lifetime of the object. Since the new node is dropped at the end of the function and the reference is returned from the function, the object's lifetime is too short and the code is correctly rejected as invalid.</p>\n\n<p>There are several possible fixes:</p>\n\n<ul>\n<li><p>Store the <code>Node</code> directly inside <code>Edge</code>. This was <a href=\"http://play.integer32.com/?gist=63851321357d79f2d902ad303e5d51e0&amp;version=stable\" rel=\"nofollow noreferrer\">shown to compile</a>.</p></li>\n<li><p>Change <code>&amp;Node</code> to <code>Rc&lt;Node&gt;</code>. This allows shared ownership of a single node by more than one edge, and automatic deallocation.</p></li>\n</ul>\n\n<p>In both cases explicit lifetime management will no longer be necessary, and ownership will \"just work\". If you know C++11, an <code>Rc&lt;&gt;</code> is roughly equivalent to a <code>std::shared_ptr</code>.</p>\n"}], "owner": {"reputation": 4455, "user_id": 1460448, "user_type": "registered", "accept_rate": 71, "profile_image": "https://www.gravatar.com/avatar/0dd5a0fbb2b5d5592a49d2e60ef98f0a?s=128&d=identicon&r=PG&f=1", "display_name": "xji", "link": "https://stackoverflow.com/users/1460448/xji"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 134, "favorite_count": 0, "accepted_answer_id": 40888439, "answer_count": 1, "score": 2, "last_activity_date": 1480525368, "creation_date": 1480459242, "last_edit_date": 1480462243, "question_id": 40877109, "link": "https://stackoverflow.com/questions/40877109/borrowed-value-does-not-live-long-enough-error-in-trie-insertion", "title": "&quot;borrowed value does not live long enough&quot; error in trie insertion", "body": "<p>I have a simple trie implementation where an <code>Edge</code> contains a character and a reference to another <code>Node</code>:</p>\n\n<pre><code>struct Edge&lt;'a&gt; {\n    ch: char,\n    to: &amp;'a Node&lt;'a&gt;,\n}\n</code></pre>\n\n<p>A <code>Node</code> contains a vector of edges:</p>\n\n<pre><code>pub struct Node&lt;'a&gt; {\n    edges: Vec&lt;Edge&lt;'a&gt;&gt;,\n}\n</code></pre>\n\n<p>I'm trying to implement the method to insert/get a character into a node. I think the return value should be a reference to a <code>Node</code>: if the character is already in one of the edges, then we directly return the existing <code>Node</code>; if not, we return the newly created <code>Node</code>. This is where I get into trouble:</p>\n\n<pre><code>impl&lt;'a&gt; Node&lt;'a&gt; {\n    fn get_or_create(&amp;mut self, ch: char) -&gt; &amp;Node&lt;'a&gt; {\n        match self.edges.binary_search_by(|e| e.ch.cmp(&amp;ch)) {\n            Ok(idx) =&gt; {\n                return &amp;self.edges.get(idx).unwrap().to;\n            }\n            Err(idx) =&gt; {\n                let to = &amp;Node { edges: Vec::new() };\n                let e = Edge { ch: ch, to: to };\n                self.edges.insert(idx, e);\n                return to;\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>The <code>to</code> is said to not live long enough.</p>\n\n<p>I'm quite sure what I wrote is far from idiomatic Rust. Initially when I included the reference to <code>Node</code> in <code>Edge</code>, I didn't add the lifetime parameter, and was prompted to do so, then I had to add it everywhere. However it looks quite weird. I wonder what would be the correct way to do it?</p>\n\n<p>Maybe what I should really have used is some other wrapper type abstraction in <code>Edge</code> to refer to heap-allocated <code>Node</code>, e.g. <code>Box</code>? I shall read the section on this topic in <em>The Rust Programming Language</em> carefully.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480451571, "post_id": 40875152, "comment_id": 68965579, "body": "Do you have a good understanding of what references (or pointers) are, specifically what a <i>dangling reference</i> (or pointer) is? What would happen if you gave a friend a piece of paper with your address on it (123 Main St.) and then <b>you moved</b>? How would the new owners of the house feel if your friend just showed up and started talking to the people in the house you used to live in as if they were you?"}, {"owner": {"reputation": 461, "user_id": 2715982, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1303a32ea5bdfdeb1e32200f7d9c1d2b?s=128&d=identicon&r=PG", "display_name": "Dooskington", "link": "https://stackoverflow.com/users/2715982/dooskington"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480452441, "post_id": 40875152, "comment_id": 68966024, "body": "@Shepmaster I know what a dangling pointer is. I guess I just didn&#39;t realize that this solution could allow for one. How would I obtain the same result, then? Is what I am trying to do possible?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 2, "creation_date": 1480453827, "post_id": 40875152, "comment_id": 68966727, "body": "<i>I just didn&#39;t realize that this solution could allow for one</i> \u2014 and that&#39;s why Rust is a wonderful language, IMO. When you move <code>cells</code> from the local variable into the <code>Game</code> struct, you&#39;ve invalidated any references into the vector, such as the one you&#39;ve given to <code>player</code>. Languages such as C or C++ would let you do that, AFAIK, and let the code crash at runtime. It&#39;s hard to tell what you really want to do, as <code>player</code> is never used."}, {"owner": {"reputation": 461, "user_id": 2715982, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1303a32ea5bdfdeb1e32200f7d9c1d2b?s=128&d=identicon&r=PG", "display_name": "Dooskington", "link": "https://stackoverflow.com/users/2715982/dooskington"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480454185, "post_id": 40875152, "comment_id": 68966875, "body": "@Shepmaster Well, right now, I want to add a function to the Player that just prints out the name of the Cell that they are currently in. My Cell struct has a name String and that works fine, but I need to actually get the Player to know what room it is currently in first. My instinct was to just give the player a reference. Also, after I create the cells array and return it, doesn&#39;t it move the ownership to the Game?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480454973, "post_id": 40875152, "comment_id": 68967292, "body": "<i>just give the player a reference</i> \u2014 why? Said another way: why not just put the player inside the <code>Cell</code>? You may want to search here on Stack Overflow for things along the lines of &quot;parent / child relationships&quot;. If you want your code as it currently is written to compile, just add <code>{}</code> around <code>let player = Player::new(&amp;cells[0])</code>."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 2, "creation_date": 1480540481, "post_id": 40875152, "comment_id": 69010384, "body": "There can be good reasons not to put <code>Player</code> inside <code>Cell</code> - for example, a player may be required to switch to a different cell. Also, separation of concerns and implementation details of <code>Player</code> may require it to be defined separately. Either way, Rust is flexible enough to allow one to choose the tradeoff that makes sense in a particular program. I&#39;ve now edited the answer to show both the index approach and the vector-of-boxes approach, both of which can be used to implement the kind of data structure you need."}], "answers": [{"comments": [{"owner": {"reputation": 28156, "user_id": 1026, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/ea331e778d54effc15b5fbc694bc8232?s=128&d=identicon&r=PG", "display_name": "Nickolay", "link": "https://stackoverflow.com/users/1026/nickolay"}, "edited": false, "score": 4, "creation_date": 1552099196, "post_id": 40897053, "comment_id": 96894505, "body": "One thing that wasn&#39;t immediately obvious to me: storing a &quot;true&quot; (not index-based) reference to a vector&#39;s item requires borrowing the entire vector, making it impossible to mutate the vector (e.g. clearing it thus invalidating the reference) or any of its items."}, {"owner": {"reputation": 1042, "user_id": 4228052, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3b1f0a7b2f3f9b37086e0f241b3a5379?s=128&d=identicon&r=PG&f=1", "display_name": "Oliver Evans", "link": "https://stackoverflow.com/users/4228052/oliver-evans"}, "edited": false, "score": 0, "creation_date": 1613449083, "post_id": 40897053, "comment_id": 117071848, "body": "I&#39;m not sure why this answer mentions mutable vectors - OP doesn&#39;t have a mutable vector. The second solution works not because of the <code>Box</code>es (they&#39;re irrelevant - <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=0406d7009c5bf924771bf5231f8f04d4\" rel=\"nofollow noreferrer\">It also compiles without them</a>), but because you give <code>player</code> a reference to the <code>Cell</code> after they&#39;ve already been moved into <code>Game</code>, where as OP gives <code>player</code> a reference first, then tries to move <code>cells</code>."}, {"owner": {"reputation": 1042, "user_id": 4228052, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3b1f0a7b2f3f9b37086e0f241b3a5379?s=128&d=identicon&r=PG&f=1", "display_name": "Oliver Evans", "link": "https://stackoverflow.com/users/4228052/oliver-evans"}, "edited": false, "score": 0, "creation_date": 1613450539, "post_id": 40897053, "comment_id": 117072095, "body": "Although I&#39;m also very curious about how share references to elements of a mutable vector. However, <code>Box</code>es don&#39;t seem to help with that either. If we 1. create a mutable <code>Game</code>, 2. give the <code>Player</code> a reference to one if its cells, 3. Borrow a mutable reference to the <code>Game</code>, 4. Try to use the <code>Player</code>&#39;s cell reference, then <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=0f3d3992c3fdbd773e557cf435291e0b\" rel=\"nofollow noreferrer\">the code fails to compile</a>, even with <code>Box</code>es. Does anyone know how to fix this?"}, {"owner": {"reputation": 1042, "user_id": 4228052, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3b1f0a7b2f3f9b37086e0f241b3a5379?s=128&d=identicon&r=PG&f=1", "display_name": "Oliver Evans", "link": "https://stackoverflow.com/users/4228052/oliver-evans"}, "edited": false, "score": 0, "creation_date": 1613454340, "post_id": 40897053, "comment_id": 117072859, "body": "I&#39;ve opened a new question <a href=\"https://stackoverflow.com/q/66219238/4228052\">here</a>."}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "reply_to_user": {"reputation": 1042, "user_id": 4228052, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3b1f0a7b2f3f9b37086e0f241b3a5379?s=128&d=identicon&r=PG&f=1", "display_name": "Oliver Evans", "link": "https://stackoverflow.com/users/4228052/oliver-evans"}, "edited": false, "score": 0, "creation_date": 1613474242, "post_id": 40897053, "comment_id": 117080036, "body": "@OliverEvans Good questions. The answer covers mutable vector because otherwise the OP&#39;s initial error could be easily fixed by passing <code>&amp;cells[0]</code> instead of <code>cells[0]</code>, which the OP documents as having tried, but gotten yelled at by the borrow checker. The OP didn&#39;t provide actual code, but the above strongly indicates that the problem comes from a mutable vector. However, you are completely right that the <code>Box</code> doesn&#39;t fix the problem and that the second example compiles without it. I&#39;ve now switched the second example to <code>Rc</code>, which is the way to make such references work in safe Rust."}], "tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 28, "last_activity_date": 1613472254, "last_edit_date": 1613472254, "creation_date": 1480535803, "answer_id": 40897053, "question_id": 40875152, "link": "https://stackoverflow.com/questions/40875152/reference-to-element-in-vector/40897053#40897053", "title": "Reference to element in vector", "body": "<p>Despite appearances, storing the reference to an object stored in a mutable vector is <em>not</em> safe. Vectors can grow; once a vector's length matches its capacity, it can only grow by allocating a larger array and <em>moving</em> all objects inside it to the new location. Existing references to its elements would be left dangling, so Rust doesn't allow that. (Also, a vector can be shrunk or cleared, in which case any references to its elements will obviously point to deallocated memory.) The same problem would exist with a C++ <code>std::vector</code>.</p>\n<p>There are several ways around it. One is to switch from a direct reference to <code>Cell</code> to a safe back-reference that consists of a back-pointer to the <code>Game</code> and an index to the vector element:</p>\n<pre><code>struct Player&lt;'a&gt; {\n    game: &amp;'a Game,\n    cell_idx: usize,\n}\n\nimpl&lt;'a&gt; Player&lt;'a&gt; {\n    pub fn new(game: &amp;'a Game, cell_idx: usize) -&gt; Player&lt;'a&gt; {\n        Player { game, cell_idx }\n    }\n    pub fn current_cell_name(&amp;self) -&gt; &amp;str {\n        &amp;self.game.cells[self.cell_idx].name\n    }\n}\n</code></pre>\n<p>Compilable example <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=4d357510e6796a7c0755b0d78a660f8b\" rel=\"nofollow noreferrer\">at the playground</a>.</p>\n<p>That has the downside that it doesn't allow adding cells except by appending them, because it would invalidate players' indices. It also requires bounds-checking on every access to a cell property by <code>Player</code>. But Rust is a systems language that has references and smart pointers - can we do better?</p>\n<p>The alternative is to invest a bit of additional effort to make sure that <code>Cell</code> objects aren't affected by vector reallocations. In C++ one would achieve that by using a vector of pointers-to-cell instead of a vector of cells, which in Rust one would use by storing <code>Box&lt;Cell&gt;</code> in the vector. But that wouldn't be enough to satisfy the borrow checker because <em>shrinking</em> or dropping the vector would still invalidate the cells.</p>\n<p>This can be fixed using a reference-counted pointer, which will allow the cell to both survive the vector growing (because it is allocated on the heap) and shrinking so it no longer inclues it (because it is not owned exclusively by the vector):</p>\n<pre><code>struct Game {\n    is_running: bool,\n    cells: Vec&lt;Rc&lt;Cell&gt;&gt;,\n}\n\nimpl Game {\n    fn construct_cells() -&gt; Vec&lt;Rc&lt;Cell&gt;&gt; {\n        [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n            .iter()\n            .map(|n| {\n                Rc::new(Cell {\n                    name: n.to_string(),\n                })\n            })\n            .collect()\n    }\n\n    pub fn new() -&gt; Game {\n        let cells = Game::construct_cells();\n\n        Game {\n            is_running: false,\n            cells,\n        }\n    }\n\n    // we could also have methods that remove cells, etc.\n    fn add_cell(&amp;mut self, cell: Cell) {\n        self.cells.push(Rc::new(cell));\n    }\n}\n</code></pre>\n<p>At the cost of an additional allocation for each <code>Cell</code> (and an additional pointer dereference from <code>Game</code> to each cell), this allows an implementation of <code>Player</code> more efficient than index:</p>\n<pre><code>struct Player {\n    cell: Rc&lt;Cell&gt;,\n}\n\nimpl Player {\n    pub fn new(cell: &amp;Rc&lt;Cell&gt;) -&gt; Player {\n        Player {\n            cell: Rc::clone(cell),\n        }\n    }\n    pub fn current_cell_name(&amp;self) -&gt; &amp;str {\n        &amp;self.cell.name\n    }\n}\n</code></pre>\n<p>Again, compilable example <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=6fb4002d6aa8eb927d3ed42f00e2729e\" rel=\"nofollow noreferrer\">at the playground</a>.</p>\n"}], "owner": {"reputation": 461, "user_id": 2715982, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/1303a32ea5bdfdeb1e32200f7d9c1d2b?s=128&d=identicon&r=PG", "display_name": "Dooskington", "link": "https://stackoverflow.com/users/2715982/dooskington"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 9178, "favorite_count": 3, "accepted_answer_id": 40897053, "answer_count": 1, "score": 14, "last_activity_date": 1613472254, "creation_date": 1480451074, "last_edit_date": 1480451148, "question_id": 40875152, "link": "https://stackoverflow.com/questions/40875152/reference-to-element-in-vector", "title": "Reference to element in vector", "body": "<p>I'm having trouble giving a struct a member variable that is a reference to another type. Here is my struct and implementation:</p>\n\n<pre><code>struct Player&lt;'a&gt; {\n    current_cell: &amp;'a Cell,\n}\n\nimpl&lt;'a&gt; Player&lt;'a&gt; {\n    pub fn new(starting_cell: &amp;'a Cell) -&gt; Player&lt;'a&gt; {\n        Player { current_cell: starting_cell }\n    }\n}\n</code></pre>\n\n<p>The player has a reference to the current <code>Cell</code> that they are in. Here is my <code>Game</code> struct and its implementation:</p>\n\n<pre><code>struct Game {\n    is_running: bool,\n    cells: Vec&lt;Cell&gt;,\n}\n\nimpl Game {\n    pub fn new() -&gt; Game {\n        let cells = construct_cells();\n        let player = Player::new(cells[0]);\n\n        Game {\n            is_running: false,\n            cells: cells,\n        }\n    }\n}\n</code></pre>\n\n<p><code>cells</code> is a vector of <code>Cell</code>s. When I create the game, I create a vector of cells in <code>construct_cells()</code> and then I start the player at the first cell. The error I am getting is: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>expected &amp;Cell, found struct `Cell`\n</code></pre>\n\n<p>I can see that I'm not passing a reference when I create the <code>Player</code>, but if I change the parameter to <code>&amp;cells[0]</code> then it yells at me for borrowing the entire vector and then trying to use it again when I create the <code>Game</code> struct. So what's going on? How do I just give the player a reference to a <code>Cell</code>?</p>\n"}, {"tags": ["rust", "pattern-matching", "borrow-checker"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 3, "creation_date": 1480433053, "post_id": 40869345, "comment_id": 68954508, "body": "Why wouldn&#39;t you be able to use a pointer/reference?"}, {"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 1, "creation_date": 1480433058, "post_id": 40869345, "comment_id": 68954513, "body": "You can also use <code>match &amp;self.a</code> combined with <code>&amp;E::Foo(a) =&gt; ...</code>."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 1, "creation_date": 1480433433, "post_id": 40869345, "comment_id": 68954795, "body": "@wimh that only works in <i>this</i> case because <code>a</code> has the type <code>u32</code> which implements <code>Copy</code>."}, {"owner": {"reputation": 375, "user_id": 3150550, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/aec1172df116b59824119f1d72080c0c?s=128&d=identicon&r=PG", "display_name": "cderwin", "link": "https://stackoverflow.com/users/3150550/cderwin"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1480433647, "post_id": 40869345, "comment_id": 68954944, "body": "@ChrisEmerson say if you wanted to return a boxed e at the end of the function that will outlive self"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 2, "creation_date": 1480433831, "post_id": 40869345, "comment_id": 68955079, "body": "@cderwin Then copy it (if needed) at the point you return or <code>Box</code> it, rather than when matching."}, {"owner": {"reputation": 375, "user_id": 3150550, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/aec1172df116b59824119f1d72080c0c?s=128&d=identicon&r=PG", "display_name": "cderwin", "link": "https://stackoverflow.com/users/3150550/cderwin"}, "reply_to_user": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1480434826, "post_id": 40869345, "comment_id": 68955817, "body": "@ChrisEmerson if I do that then I can&#39;t call any mutable methods on self (for good reason).  I think the way I need to do this is through something like <code>match self.a { ref e =&gt; e.clone() }</code>.  Thanks for the suggestion of just cloning it."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1480438554, "post_id": 40869345, "comment_id": 68958429, "body": "This was in a &amp;self method so you couldn&#39;t call mutable methods anyway.  :-)"}, {"owner": {"reputation": 1540, "user_id": 2606171, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/F4ncy.png?s=128&g=1", "display_name": "belst", "link": "https://stackoverflow.com/users/2606171/belst"}, "edited": false, "score": 0, "creation_date": 1480713839, "post_id": 40869345, "comment_id": 69093634, "body": "You can also match on <code>E::Foo(ref a) =&gt; ...</code> which will also work for non copy types"}], "owner": {"reputation": 375, "user_id": 3150550, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/aec1172df116b59824119f1d72080c0c?s=128&d=identicon&r=PG", "display_name": "cderwin", "link": "https://stackoverflow.com/users/3150550/cderwin"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 146, "favorite_count": 0, "answer_count": 0, "score": 0, "last_activity_date": 1480433344, "creation_date": 1480432565, "last_edit_date": 1480433344, "question_id": 40869345, "link": "https://stackoverflow.com/questions/40869345/rust-match-struct-attribute-in-method-fails-borrow-checker", "title": "Rust Match Struct Attribute in Method Fails Borrow Checker", "body": "<pre><code>#[derive(Debug)]\nenum E {\n    Foo(u32),\n    Bar,\n    Baz\n}\n\nstruct S { a: E }\n\nimpl S {\n    fn print(&amp;self) {\n        match self.a {\n            E::Foo(a) =&gt; println!(\"{}\", a),\n            e =&gt; println!(\"{:?}\", e)\n        }\n    }\n}\n\n\nfn main() {\n    let a = S { a: E::Bar };\n    a.print();\n}\n</code></pre>\n\n<p>This clip fails to compile:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n  --&gt; main.rs:11:15\n   |\n11 |         match self.a {\n   |               ^^^^ cannot move out of borrowed content\n12 |            E::Foo(a) =&gt; println!(\"{}\", a),\n13 |            e =&gt; println!(\"{:?}\", e)\n   |            - hint: to prevent move, use `ref e` or `ref mut e`\n</code></pre>\n\n<p>and I more or less understand why: <code>self</code> owns <code>self.a</code>, and because I only borrowed <code>self</code> in the method declaration, I can't move <code>self.a</code> out of <code>self</code>.  But I can't figure out what the best approach to fix this is.  Obviously I could use <code>ref e =&gt; println!(\"{:?}\", e)</code> in this contrived example, but I'm looking for a more general description where I can't use a pointer.  Do I have to copy <code>self.a</code> in the match statement?  This would seem wasteful if there was a separate case for <code>E::Baz</code>.</p>\n"}, {"tags": ["arrays", "struct", "rust"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 2, "creation_date": 1480412729, "post_id": 40862191, "comment_id": 68940524, "body": "Please post an <a href=\"http://stackoverflow.com/help/mcve\">MCVE</a>."}, {"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 0, "creation_date": 1480412800, "post_id": 40862191, "comment_id": 68940583, "body": "Did you copy/paste something wrong? In particular the <code>i</code> in this line seems wrong: <code>for i in arg_tbl.iter()</code>."}, {"owner": {"reputation": 21, "user_id": 4186073, "user_type": "registered", "profile_image": "https://graph.facebook.com/100002091297989/picture?type=large", "display_name": "Arny", "link": "https://stackoverflow.com/users/4186073/arny"}, "reply_to_user": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 2, "creation_date": 1480413541, "post_id": 40862191, "comment_id": 68941128, "body": "Damn! I&#39;m stupid)) thanx @wimh . should change it by <code>arg</code> . But also I  cloned <code>arg.dv</code> like this: <code>arg.dv.clone()</code> and now it works"}, {"owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "edited": false, "score": 1, "creation_date": 1480415548, "post_id": 40862191, "comment_id": 68942571, "body": "Have you had a look at all the other <a href=\"http://stackoverflow.com/search?q=%5Brust%5D+cannot+move+out+of+borrowed+content\">cannot move out of borrowed content</a> questions?"}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480427511, "post_id": 40864158, "comment_id": 68950504, "body": "And you should use <code>arg_tbl.into_iter().map(|arg| ArgsTable { dv: arg.dv }).collect()</code> instead of manually <code>push</code>ing into the result vector."}], "tags": [], "owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "is_accepted": true, "score": 5, "last_activity_date": 1539745939, "last_edit_date": 1539745939, "creation_date": 1480417145, "answer_id": 40864158, "question_id": 40862191, "link": "https://stackoverflow.com/questions/40862191/cannot-move-out-of-borrowed-content-when-iterating-the-loop/40864158#40864158", "title": "cannot move out of borrowed content when iterating the loop", "body": "<p>Although you already have an answer, I will explain the problem and provide a different solution too. I also recommend reading <a href=\"http://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html\" rel=\"nofollow noreferrer\">Effectively Using Iterators In Rust</a>.</p>\n\n<p>I'll start with a <a href=\"/help/mcve\">MCVE</a>, which you can test on <a href=\"https://play.rust-lang.org/\" rel=\"nofollow noreferrer\">the playground</a> too:</p>\n\n<pre><code>struct ArgsTable {\n    dv: String,\n}\n\nfn check_args() -&gt; Vec&lt;ArgsTable&gt; {\n    let arg_tbl: [ArgsTable; 2] = [\n        ArgsTable {\n            dv: \"4\".to_string(),\n        },\n        ArgsTable {\n            dv: \"out.txt\".to_string(),\n        },\n    ];\n    let mut arguments: Vec&lt;ArgsTable&gt; = Vec::new();\n    for arg in arg_tbl.iter() {\n        arguments.push(ArgsTable { dv: arg.dv });\n    }\n    arguments\n}\n\nfn main() {\n    check_args();\n    println!(\"Hello, world!\");\n}\n</code></pre>\n\n<p>This uses <code>arg_tbl.iter()</code>, which will borrow from <code>arg_tbl</code>. <code>String</code> does not implement the <code>Copy</code> trait, so it can't be copied into <code>arguments</code>. Because it is borrowed, it can also not be moved. That causes the error message <code>cannot move out of borrowed content</code>. Because <code>String</code> does implement <code>Clone</code>, you can clone it to get a copy. That is why adding a <code>clone()</code> on line 13 fixes the problem.</p>\n\n<p>It is also possible to fix this using an iterator which does not borrow; <a href=\"https://doc.rust-lang.org/beta/std/iter/trait.IntoIterator.html\" rel=\"nofollow noreferrer\"><code>into_iter</code></a>. But by-value iterators for arrays are not available at the moment. If you use <code>arg_tbl.into_iter()</code>, the array will dereference into a slice, and you will still iterate by reference! But if you change the array into a <code>Vec</code>, it will work without having to clone:</p>\n\n<pre><code>let arg_tbl = vec![\n    ArgsTable {\n        dv: \"4\".to_string(),\n    },\n    ArgsTable {\n        dv: \"out.txt\".to_string(),\n    },\n];\nlet mut arguments: Vec&lt;ArgsTable&gt; = Vec::new();\nfor arg in arg_tbl.into_iter() {\n    arguments.push(ArgsTable { dv: arg.dv });\n}\n</code></pre>\n\n<p>You can now also simplify the for loop like this:</p>\n\n<pre><code>for arg in arg_tbl {\n</code></pre>\n"}], "owner": {"reputation": 21, "user_id": 4186073, "user_type": "registered", "profile_image": "https://graph.facebook.com/100002091297989/picture?type=large", "display_name": "Arny", "link": "https://stackoverflow.com/users/4186073/arny"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3396, "favorite_count": 0, "accepted_answer_id": 40864158, "answer_count": 1, "score": 1, "last_activity_date": 1539745939, "creation_date": 1480411814, "last_edit_date": 1480427273, "question_id": 40862191, "link": "https://stackoverflow.com/questions/40862191/cannot-move-out-of-borrowed-content-when-iterating-the-loop", "title": "cannot move out of borrowed content when iterating the loop", "body": "<p>I'm trying to get field from my structure in rust</p>\n\n<pre><code>fn check_args(command: i32, args: Vec&lt;String&gt;) -&gt; Vec&lt;Argument&gt; {\n    let arg_tbl: [ArgsTable; 5] = [\n        ArgsTable { cc: 0, ac: 1, dv: \"4\".to_string() },\n        ArgsTable { cc: 1, ac: 1, dv: \"4\".to_string() },\n        ArgsTable { cc: 1, ac: 2, dv: \"in.txt\".to_string() },\n        ArgsTable { cc: 4, ac: 3, dv: \"1\".to_string() },\n        ArgsTable { cc: 6, ac: 2, dv: \"out.txt\".to_string() },\n    ];\n    let mut arguments: Vec&lt;Argument&gt; = Vec::new();\n    if args.len() == 0 {\n        for arg in arg_tbl.iter() {\n            if arg.cc == command {\n                arguments.push(Argument {\n                    code: arg.ac,\n                    value: arg.dv,\n                });\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>but get this error</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>    |\n151 |                     value: arg.dv\n    |                            ^^^ cannot move out of borrowed content\n</code></pre>\n\n<p>How can I get the <code>arg.dv</code> field? </p>\n"}, {"tags": ["enums", "rust", "pattern-matching", "match"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480427874, "post_id": 40858256, "comment_id": 68950765, "body": "<b>I&#39;ve looked everywhere</b> - <a href=\"https://doc.rust-lang.org/stable/book/match.html\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i> chapter about <code>match</code></a>: &quot;The <code>_</code> acts as a &#39;catch-all&#39;, and will catch all possible values that aren&#39;t specified in an arm of <code>match</code>&quot;; this is directly after the intro example, which uses <code>_</code>."}], "answers": [{"comments": [{"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1480430196, "post_id": 40858814, "comment_id": 68952496, "body": "This answer doesn&#39;t compile, because the enum has four variants and only two are matched."}, {"owner": {"reputation": 131, "user_id": 5928016, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/d4421e2cf8807f9be273f99fd5ff9490?s=128&d=identicon&r=PG&f=1", "display_name": "davis", "link": "https://stackoverflow.com/users/5928016/davis"}, "reply_to_user": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1480470109, "post_id": 40858814, "comment_id": 68972574, "body": "@bluss that&#39;s the problem I&#39;m working on. How can I include the rest to make it exhaustive but where match does nothing for the other two variants."}], "tags": [], "owner": {"reputation": 366, "user_id": 3412986, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Z7SMm.png?s=128&g=1", "display_name": "SpaceManiac", "link": "https://stackoverflow.com/users/3412986/spacemaniac"}, "is_accepted": false, "score": 2, "last_activity_date": 1602779862, "last_edit_date": 1602779862, "creation_date": 1480399367, "answer_id": 40858814, "question_id": 40858256, "link": "https://stackoverflow.com/questions/40858256/how-do-i-match-only-some-not-all-variants-of-an-enum/40858814#40858814", "title": "How do I match only some, not all variants of an enum?", "body": "<p>You can use <code>_</code> in patterns to discard a value: <code>InfixToken::Operand(_) =&gt; branch</code>. If the whole pattern is <code>_</code>, it will match anything.</p>\n<p>To only perform code if specific variants are matched, put that code in the match branch for those variants:</p>\n<pre><code>match token {\n    &amp;InfixToken::Operand(_) |\n    &amp;InfixToken::LeftParen =&gt; {\n        if tokens[count - 1] == token {\n            return None;\n        }\n    }\n    _ =&gt; {}\n}\n</code></pre>\n<p>The bar (<code>|</code>) is syntax for taking that branch if either pattern is satisfied.</p>\n"}], "owner": {"reputation": 131, "user_id": 5928016, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/d4421e2cf8807f9be273f99fd5ff9490?s=128&d=identicon&r=PG&f=1", "display_name": "davis", "link": "https://stackoverflow.com/users/5928016/davis"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 512, "favorite_count": 0, "answer_count": 1, "score": 1, "last_activity_date": 1602779862, "creation_date": 1480396296, "last_edit_date": 1480424744, "question_id": 40858256, "link": "https://stackoverflow.com/questions/40858256/how-do-i-match-only-some-not-all-variants-of-an-enum", "title": "How do I match only some, not all variants of an enum?", "body": "<p>I've looked everywhere and cannot find a clear cut example. I want to be able to only match some, not all variants of an enum. </p>\n\n<pre><code>pub enum InfixToken {\n    Operator(Operator),\n    Operand(isize),\n    LeftParen,\n    RightParen,\n}\n</code></pre>\n\n<p>So I can perform this in a for loop of tokens:</p>\n\n<pre><code>let x = match token {\n    &amp;InfixToken::Operand(c) =&gt; InfixToken::Operand(c),\n    &amp;InfixToken::LeftParen =&gt; InfixToken::LeftParen,\n};\n\nif tokens[count - 1] == x {\n    return None;\n}\n</code></pre>\n\n<p>How do I compare if the preceding token matches the only two variants of an enum without comparing it to every variant of the enum? <code>x</code> also has to be the same type of the preceding token.</p>\n\n<p>Also, and probably more important, how can I match an operand where <code>isize</code> value doesn't matter, just as long as it is an operand?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1480405131, "post_id": 40857359, "comment_id": 68936047, "body": "What kind of action do you want to take on overflow etc., and can you point to an example of that in C?"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1480426883, "creation_date": 1480426883, "answer_id": 40867397, "question_id": 40857359, "link": "https://stackoverflow.com/questions/40857359/how-to-handle-floating-point-exceptions-fpe-with-rust/40867397#40867397", "title": "How to handle floating point exceptions (fpe) with Rust?", "body": "<p>Rust does not support signals as part of the standard library. I believe this is because they are highly platform-specific and pretty terribly designed for most multithreaded programs. </p>\n\n<p>There are a handful of crates available to deal with signals; <a href=\"https://crates.io/crates/chan-signal\" rel=\"nofollow noreferrer\">chan-signal</a> is the one I've used before. Here is the example code from that library, changed to report a <code>SIGFPE</code>:</p>\n\n<pre><code>#[macro_use]\nextern crate chan;\nextern crate chan_signal;\n\nuse chan_signal::Signal;\nuse std::thread;\n\nfn main() {\n    let signal = chan_signal::notify(&amp;[Signal::FPE]);\n    let (sdone, rdone) = chan::sync(0);\n\n    thread::spawn(move || run(sdone));\n\n    chan_select! {\n        signal.recv() -&gt; signal =&gt; {\n            println!(\"received signal: {:?}\", signal)\n        },\n        rdone.recv() =&gt; {\n            println!(\"Program completed normally.\");\n        }\n    }\n}\n\nfn run(_sdone: chan::Sender&lt;()&gt;) {\n    thread::sleep_ms(100_000);\n}\n</code></pre>\n\n<p>On macOS, running this in one window and <code>kill -s FPE $THE_RUNNING_PID</code> in another generates the output</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>received signal: Some(FPE)\n</code></pre>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 252, "favorite_count": 0, "answer_count": 1, "score": 2, "last_activity_date": 1480426883, "creation_date": 1480390679, "last_edit_date": 1480426411, "question_id": 40857359, "link": "https://stackoverflow.com/questions/40857359/how-to-handle-floating-point-exceptions-fpe-with-rust", "title": "How to handle floating point exceptions (fpe) with Rust?", "body": "<p>In C you can use <code>SIGFPE</code> to define a handler for floating point exceptions.</p>\n\n<p>How would you use Rust to define a function that handles overflow, for example?</p>\n\n<p>See <a href=\"https://developer.blender.org/diffusion/B/browse/master/source/creator/creator_signals.c;3b467b35a85153e9435a1fbcba2e9c1770c1192a$305-326\" rel=\"nofollow noreferrer\">this function</a> for an example that sets up a callback to run in C.</p>\n"}, {"tags": ["arrays", "rust"], "answers": [{"comments": [{"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 1, "creation_date": 1480404999, "post_id": 40857207, "comment_id": 68935979, "body": "Worth emphasizing that the outer layer is indexed with 0 in <code>y</code> after the split. It&#39;s an easy error to make."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 2, "last_activity_date": 1480427004, "last_edit_date": 1480427004, "creation_date": 1480389528, "answer_id": 40857207, "question_id": 40856862, "link": "https://stackoverflow.com/questions/40856862/how-to-swap-values-from-a-multidimensional-array-in-rust/40857207#40857207", "title": "How to swap values from a multidimensional array in Rust?", "body": "<p>You will need to split the outside layers using <code>split_at_mut</code>. This creates two disjoint mutable references which can then be individually swapped:</p>\n\n<pre><code>use std::mem;\n\nfn main() {\n    let mut matrix = [[42.0f64; 4]; 4];\n\n    // instead of \n    // mem::swap(&amp;mut matrix[0][1], &amp;mut b[2][3]);\n\n    let (x, y) = matrix.split_at_mut(2);\n    mem::swap(&amp;mut x[0][1], &amp;mut y[0][3]);\n    //                             ^-- Note that this value is now `0`!\n}\n</code></pre>\n\n<p>In the most general case, you'll likely need to add some code to figure out where to split and in which order.</p>\n"}], "owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 292, "favorite_count": 0, "answer_count": 1, "score": 5, "last_activity_date": 1480427004, "creation_date": 1480386823, "last_edit_date": 1480388939, "question_id": 40856862, "link": "https://stackoverflow.com/questions/40856862/how-to-swap-values-from-a-multidimensional-array-in-rust", "title": "How to swap values from a multidimensional array in Rust?", "body": "<p>Using a matrix (multidimensional fixed sized array) defined as <code>[[f64; 4]; 4]</code>, is it possible to swap two values?</p>\n\n<pre><code>std::mem::swap(&amp;mut matrix[i][k], &amp;mut matrix[k][l]);\n</code></pre>\n\n<p>Gives the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0499]: cannot borrow `matrix[..][..]` as mutable more than once at a time\n   --&gt; math_matrix.rs:100\n    |\n100 | std::mem::swap(&amp;mut matrix[i][j], &amp;mut matrix[k][l]);\n    |                     ------------       ^^^^^^^^^^^^^^^- first borrow ends here\n    |                     |                  |\n    |                     |                  second mutable borrow occurs here\n    |                     first mutable borrow occurs here\n</code></pre>\n\n<hr>\n\n<p>The only way I could figure out how to accomplish this was to use a temp value, e.g.:</p>\n\n<pre><code>macro_rules! swap_value {\n    ($a_ref:expr, $b_ref:expr) =&gt; {\n        {\n            let t = *$a_ref;\n            *$a_ref = *$b_ref;\n            *$b_ref = t;\n        }\n    }\n}\n</code></pre>\n\n<p>Then use:</p>\n\n<pre><code>swap_value!(&amp;mut matrix[i][k], &amp;mut matrix[maxj][k]);\n</code></pre>\n\n<p>Is there a better alternative?</p>\n"}, {"tags": ["rust", "rust-cargo"], "comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1480370841, "post_id": 40853090, "comment_id": 68925293, "body": "The joys of markdown\u2026"}], "answers": [{"tags": [], "owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "is_accepted": true, "score": 5, "last_activity_date": 1480433534, "creation_date": 1480433534, "answer_id": 40869697, "question_id": 40853090, "link": "https://stackoverflow.com/questions/40853090/cannot-ignore-failures-to-compile-example-code-in-documentation/40869697#40869697", "title": "Cannot ignore failures to compile example code in documentation", "body": "<p>You have hit a <a href=\"https://github.com/rust-lang/rust/issues/32556\" rel=\"nofollow noreferrer\"><strong>known issue</strong></a> in Rust's documentation parser. The Markdown parser used by Rust (Hoedown) does not seem to recognise a fenced code block (the three backticks) properly unless there is a blank line before it. There is <a href=\"https://github.com/rust-lang/rust/issues/28712#issuecomment-144434318\" rel=\"nofollow noreferrer\">some dispute</a> whether this is desired behaviour or not, but either way the problem can be solved by revising your example as follows:</p>\n\n<pre><code>//! ## How to use\n//! Validator usage:\n//!\n//! ```ignore\n//! fn validate(values: &amp;Map) -&gt; ValidateResults {\n//!    ValidateResults(vec!(\n//!        Validator::&lt;String&gt;::new(btreemap! {\n//!            \"requiered\".to_string() =&gt; true.to_json(),\n//!            \"vtype\".to_string() =&gt; \"string\".to_json(),\n//!        }).validate(\"title\".to_string(), values.find(&amp;[\"pages\", \"title\"]$\n//!\n//!        Validator::&lt;bool&gt;::new(btreemap! {\n//!            \"default\".to_string() =&gt; false.to_json(),\n//!        }).validate(\"published\".to_string(), values.find(&amp;[\"published\"])$\n//!    ))\n//! }\n//! ```\npub fn main() {\n    println!(\"Hello, world!\");\n}\n</code></pre>\n\n<p>Notice the leading <code>//!</code> line before the code block, which allows Hoedown to successfully identify the code block and ignore it appropriately.</p>\n"}], "owner": {"reputation": 620, "user_id": 2576287, "user_type": "registered", "accept_rate": 56, "profile_image": "https://lh5.googleusercontent.com/-VegFz4P9Ovc/AAAAAAAAAAI/AAAAAAAAATo/Z-69W9rBCno/photo.jpg?sz=128", "display_name": "mrLSD", "link": "https://stackoverflow.com/users/2576287/mrlsd"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 277, "favorite_count": 0, "accepted_answer_id": 40869697, "answer_count": 1, "score": 3, "last_activity_date": 1480439245, "creation_date": 1480365739, "last_edit_date": 1480439245, "question_id": 40853090, "link": "https://stackoverflow.com/questions/40853090/cannot-ignore-failures-to-compile-example-code-in-documentation", "title": "Cannot ignore failures to compile example code in documentation", "body": "<p>I am trying to write example code for my Rust library, but I don't need the sample code to be compiled.</p>\n\n<p>Steps to reproduce:</p>\n\n<ol>\n<li><p><code>cargo new</code></p></li>\n<li><p>Add this to <code>src/lib.rs</code></p>\n\n<pre><code>//! ## How to use\n//! Validator usage:\n//! ```ignore\n//! fn validate(values: &amp;Map) -&gt; ValidateResults {\n//!    ValidateResults(vec!(\n//!        Validator::&lt;String&gt;::new(btreemap! {\n//!            \"requiered\".to_string() =&gt; true.to_json(),\n//!            \"vtype\".to_string() =&gt; \"string\".to_json(),\n//!        }).validate(\"title\".to_string(), values.find(&amp;[\"pages\", \"title\"]$\n//!\n//!        Validator::&lt;bool&gt;::new(btreemap! {\n//!            \"default\".to_string() =&gt; false.to_json(),\n//!        }).validate(\"published\".to_string(), values.find(&amp;[\"published\"])$\n//!    ))\n//! }\n//! ```\npub fn main() {\n    println!(\"Hello, world!\");\n}\n</code></pre></li>\n<li><p><code>cargo test</code></p></li>\n</ol>\n\n<p>I get an error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ cargo test\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running target/debug/deps/sample-661c50cdfb6a999f\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests sample\n\nrunning 1 test\ntest _0 ... FAILED\n\nfailures:\n\n---- _0 stdout ----\n    error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n --&gt; &lt;anon&gt;:4:69\n  |\n4 |    }).validate(\"published\".to_string(), values.find(&amp;[\"published\"])),\n  |                                                                     ^\n\nerror: macro undefined: 'btreemap!'\n --&gt; &lt;anon&gt;:2:31\n  |\n2 |        Validator::&lt;bool&gt;::new(btreemap! {\n  |                               ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nthread '_0' panicked at 'Box&lt;Any&gt;', ../src/librustc_errors/lib.rs:694\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\nthread '_0' panicked at 'couldn't compile the test', ../src/librustdoc/test.rs:283\n\n\nfailures:\n    _0\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n\nerror: test failed\n</code></pre>\n\n<p>How do I ignore failures to compile this example code? I'm using Rust 1.13.0 and Cargo 0.13.0.</p>\n"}, {"tags": ["iterator", "rust"], "comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 2, "creation_date": 1480355595, "post_id": 40850104, "comment_id": 68917590, "body": "You do realize <code>next</code> is creating a whole new iterator every time it&#39;s called right?"}], "answers": [{"comments": [{"owner": {"reputation": 124, "user_id": 3027481, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/cf8b75b33c22ba0eb02095ac444db569?s=128&d=identicon&r=PG", "display_name": "svdc", "link": "https://stackoverflow.com/users/3027481/svdc"}, "edited": false, "score": 0, "creation_date": 1480362102, "post_id": 40850885, "comment_id": 68921053, "body": "Thank you so much for your elaborate answer. It&#39;s clear now. Thanks for the comment on <code>PartialEq</code> as well."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 5, "last_activity_date": 1480358535, "last_edit_date": 1495540798, "creation_date": 1480356912, "answer_id": 40850885, "question_id": 40850104, "link": "https://stackoverflow.com/questions/40850104/infinite-loop-when-implementing-custom-iterator-in-rust/40850885#40850885", "title": "Infinite loop when implementing custom iterator in Rust", "body": "<p>As mentioned in the comments, your iterator is lacking a crucial piece of state: <em>how far along in the iteration it is</em>. Every time you call <code>next</code>, it constructs another iterator completely from scratch and gets the first element.</p>\n\n<p>Here's a reduced example:</p>\n\n<pre><code>struct ListZipper {\n    focus: Option&lt;u8&gt;,\n}\n\nimpl Iterator for ListZipper {\n    type Item = u8;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.focus.iter().next().cloned()\n    }\n}\n\nfn main() {\n    let lz = ListZipper { focus: Some(42) };\n    let head: Vec&lt;_&gt; = lz.take(5).collect();\n    println!(\"{:?}\", head); // [42, 42, 42, 42, 42]\n}\n</code></pre>\n\n<blockquote>\n  <p>I realize I may not want <code>ListZipper</code> itself to be an iterator, but that is another discussion.</p>\n</blockquote>\n\n<p>No, it's really not ^_^. You need to somehow mutate the thing being iterated on so that it can change and have different values for each subsequent call.</p>\n\n<p>If you want to return a combination of existing iterators and iterator adapters, refer to <a href=\"https://stackoverflow.com/q/27535289/155423\">Correct way to return an Iterator?</a> for instructions.</p>\n\n<p>Otherwise, you need to somehow change <code>ListZipper</code> during the call to <code>next</code>:</p>\n\n<pre><code>impl Iterator for ListZipper {\n    type Item = Tile;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        if let Some(v) = self.left.pop_front() {\n            return Some(v);\n        }\n\n        if let Some(v) = self.focus.take() {\n            return Some(v);\n        }\n\n        if let Some(v) = self.right.pop_front() {\n            return Some(v);\n        }\n\n        None\n    }\n}\n</code></pre>\n\n<p>More succinctly:</p>\n\n<pre><code>impl Iterator for ListZipper {\n    type Item = Tile;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.left.pop_front()\n            .or_else(|| self.focus.take())\n            .or_else(|| self.right.pop_front())\n    }\n}\n</code></pre>\n\n<hr>\n\n<p>Note that your <code>PartialEq</code> implementation seems to be the same as the automatically-derived one...</p>\n\n<pre><code>use std::collections::VecDeque;\n\ntype Tile = u8;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ListZipper {\n    pub focus: Option&lt;Tile&gt;,\n    pub left: VecDeque&lt;Tile&gt;,\n    pub right: VecDeque&lt;Tile&gt;,\n}\n\nimpl Iterator for ListZipper {\n    type Item = Tile;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.left.pop_front()\n            .or_else(|| self.focus.take())\n            .or_else(|| self.right.pop_front())\n    }\n}\n\nfn main() {\n    let lz = ListZipper {\n        focus: Some(42),\n        left: vec![1, 2, 3].into(),\n        right: vec![97, 98, 99].into(),\n    };\n\n    let head: Vec&lt;_&gt; = lz.take(5).collect();\n\n    println!(\"{:?}\", head);\n}\n</code></pre>\n"}], "owner": {"reputation": 124, "user_id": 3027481, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/cf8b75b33c22ba0eb02095ac444db569?s=128&d=identicon&r=PG", "display_name": "svdc", "link": "https://stackoverflow.com/users/3027481/svdc"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 380, "favorite_count": 0, "accepted_answer_id": 40850885, "answer_count": 1, "score": 1, "last_activity_date": 1480358535, "creation_date": 1480353963, "last_edit_date": 1480356573, "question_id": 40850104, "link": "https://stackoverflow.com/questions/40850104/infinite-loop-when-implementing-custom-iterator-in-rust", "title": "Infinite loop when implementing custom iterator in Rust", "body": "<p>I am trying to implement a list <a href=\"https://en.wikipedia.org/wiki/Zipper_(data_structure)\" rel=\"nofollow noreferrer\">zipper</a>. So far I have:</p>\n\n<pre><code>#[derive(RustcDecodable, RustcEncodable, Debug, Clone)]\npub struct ListZipper {\n    pub focus: Option&lt;Tile&gt;,\n    pub left: VecDeque&lt;Tile&gt;,\n    pub right: VecDeque&lt;Tile&gt;,\n}\n\nimpl PartialEq for ListZipper {\n    fn eq(&amp;self, other: &amp;ListZipper) -&gt; bool {\n        self.left == other.left &amp;&amp; self.focus == other.focus &amp;&amp; self.right == other.right\n    }\n}\n</code></pre>\n\n<p>I am now trying to implement an iterator</p>\n\n<pre><code>impl Iterator for ListZipper {\n    type Item = Tile;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Tile&gt; {\n        self.left.iter().chain(self.focus.iter()).chain(self.right.iter()).next().map(|w| *w)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n    }\n}\n</code></pre>\n\n<p>In my head this makes sense. When iterating over <code>ListZipper</code>, I want to iterate over <code>left</code>, then <code>focus</code> and then <code>right</code>. So I chain those iterators and just return <code>next()</code>.</p>\n\n<p>This works fine if all fields in <code>ListZipper</code> are empty. As soon as one is not empty iterating over <code>ListZipper</code> results in an infinite loop. </p>\n\n<p>The problem is not the chain. If I replace that by e.g. <code>self.left.iter()</code>, and <code>left</code> is not empty, the problem is the same. Likewise for <code>focus</code> and <code>right</code>. </p>\n\n<p>I tried printing all elements in the iterator and it appears to go through the <code>VecDeque</code> from front to back, and then gets stuck. I.e. <code>next()</code> does not advance the cursor when it reaches the back.</p>\n\n<p>Why?</p>\n\n<p>I realize I may not want <code>ListZipper</code> itself to be an iterator, but that is another discussion.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "edited": false, "score": 1, "creation_date": 1480350361, "post_id": 40849017, "comment_id": 68914486, "body": "Humm thanks, I searched for the magic keywords <code>FIFO</code> and <code>LIFO</code> and had nothing significant. Maybe it is a documentation problem."}, {"owner": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "edited": false, "score": 0, "creation_date": 1480350504, "post_id": 40849017, "comment_id": 68914579, "body": "I saw std::Vec is a good choice for a stack, but what is the more efficient for a queue?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "edited": false, "score": 0, "creation_date": 1480350934, "post_id": 40849017, "comment_id": 68914846, "body": "It depends on your use case.  I would guess that <code>LinkedList</code> would be more predictable, but <code>VecDeque</code> on average more efficient in some ways, but really you&#39;d have to measure it yourself."}, {"owner": {"reputation": 25596, "user_id": 3140, "user_type": "registered", "accept_rate": 57, "profile_image": "https://www.gravatar.com/avatar/84dbc773c808111cc4ce138bff33f482?s=128&d=identicon&r=PG", "display_name": "Jacob Krall", "link": "https://stackoverflow.com/users/3140/jacob-krall"}, "reply_to_user": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "edited": false, "score": 1, "creation_date": 1480351074, "post_id": 40849017, "comment_id": 68914932, "body": "@Boiethios: use the mentioned <code>VecDeque</code> for queues. <code>LinkedList</code> is O(1) on the front, but not at the back, so it is more appropriate for a stack."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1480351500, "post_id": 40849017, "comment_id": 68915228, "body": "LInkedList is O(1) to push/pop to either end."}, {"owner": {"user_type": "does_not_exist", "display_name": "user395760"}, "edited": false, "score": 5, "creation_date": 1480354900, "post_id": 40849017, "comment_id": 68917223, "body": "A <code>LinkedList</code> is a pretty terrible stack, <code>Vec</code> is virtually always faster. Same goes for <code>LinkedList</code> vs. <code>VecDeque</code> as queue."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": false, "score": 11, "last_activity_date": 1480350738, "last_edit_date": 1480350738, "creation_date": 1480350178, "answer_id": 40849017, "question_id": 40848918, "link": "https://stackoverflow.com/questions/40848918/are-there-queue-and-stack-collections-in-rust/40849017#40849017", "title": "Are there queue and stack collections in Rust?", "body": "<p>Both <a href=\"https://doc.rust-lang.org/std/collections/struct.VecDeque.html\" rel=\"noreferrer\"><code>VecDeque</code></a> and <a href=\"https://doc.rust-lang.org/std/collections/struct.LinkedList.html\" rel=\"noreferrer\"><code>LinkedList</code></a> have <code>push</code>/<code>pop</code>_<code>front</code>/<code>back</code>.</p>\n"}, {"comments": [{"owner": {"reputation": 4733, "user_id": 922445, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/a469120d35647d9aa50646cb4d778c71?s=128&d=identicon&r=PG&f=1", "display_name": "Nulik", "link": "https://stackoverflow.com/users/922445/nulik"}, "edited": false, "score": 0, "creation_date": 1559577380, "post_id": 40851723, "comment_id": 99456017, "body": "can&#39;t <code>VecDeque</code> be used as a stack too ?"}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 4733, "user_id": 922445, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/a469120d35647d9aa50646cb4d778c71?s=128&d=identicon&r=PG&f=1", "display_name": "Nulik", "link": "https://stackoverflow.com/users/922445/nulik"}, "edited": false, "score": 2, "creation_date": 1559579096, "post_id": 40851723, "comment_id": 99456869, "body": "@Nulik: By the law of &quot;who can the most, can the least&quot;, yes. However, since <code>VecDeque</code> supports additional functionality, it is not as lean as a <code>Vec</code> which may lead to performance overhead when used as a <code>Vec</code>, thus my advice."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": true, "score": 40, "last_activity_date": 1480360321, "creation_date": 1480360321, "answer_id": 40851723, "question_id": 40848918, "link": "https://stackoverflow.com/questions/40848918/are-there-queue-and-stack-collections-in-rust/40851723#40851723", "title": "Are there queue and stack collections in Rust?", "body": "<p>First of all, Rust does not offer (in the Standard library) any library with guaranteed latency for <em>adding</em> elements: Rust collections may generally allocate memory when adding new elements, and allocating memory may take an unbounded amount of time in the worst case.</p>\n\n<p>That being said, there are two contenders for each case:</p>\n\n<ul>\n<li>a stack may be implemented either on top of <code>Vec</code> or <code>LinkedList</code> (both feature <code>pop_back</code> and <code>push_back</code>)</li>\n<li>a queue may be implemented either on top of <code>VecDeque</code> or <code>LinkedList</code> (both feature <code>pop_front</code> and <code>push_back</code>)</li>\n</ul>\n\n<p>The difference between <code>Vec*</code> and <code>LinkedList</code> is that the latter is simplistic: for each call to <code>push_back</code> a memory allocation is made. On the one hand, this is great because it means that the cost of <code>push_back</code> is independent of the number of elements already in the collection, on the other hand... well, a memory allocation may take a really long time.</p>\n\n<p>The former is a bit more complicated:</p>\n\n<ul>\n<li>it has better throughput, thanks to being more cache-friendly</li>\n<li>it has additional capacity, guaranteeing non-allocating <code>push_back</code> as long as there is excess capacity</li>\n<li>it still maintains <em>amortized</em> O(1) <code>push_back</code> even when not reserving excess capacity ahead of time</li>\n</ul>\n\n<p>In general, I would advise to use <code>Vec</code> for a stack and <code>VecDeque</code> for a queue.</p>\n"}, {"tags": [], "owner": {"reputation": 171, "user_id": 8286242, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f93895e66f9dd59dc80608b7ec94bbd0?s=128&d=identicon&r=PG&f=1", "display_name": "Chris Rudd", "link": "https://stackoverflow.com/users/8286242/chris-rudd"}, "is_accepted": false, "score": 7, "last_activity_date": 1560434774, "last_edit_date": 1560434774, "creation_date": 1532387639, "answer_id": 51488345, "question_id": 40848918, "link": "https://stackoverflow.com/questions/40848918/are-there-queue-and-stack-collections-in-rust/51488345#51488345", "title": "Are there queue and stack collections in Rust?", "body": "<p>Matthieu M. has it just about perfect.  <a href=\"https://doc.rust-lang.org/stable/std/vec/struct.Vec.html\" rel=\"noreferrer\"><code>Vec</code></a> is your stack (LIFO) and <a href=\"https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html\" rel=\"noreferrer\"><code>VecDeque</code></a> is a double ended queue that supports all 4 variants (FIFO, FILO, LIFO, and LILO) using:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>.push_front(x) | .front() | .pop_front()\n.push_back(x)  | .back()  | .pop_back()\n</code></pre>\n\n<p>If you're looking to maximize your efficiency, I recommend checking out <a href=\"http://markusjais.com/unterstanding-rusts-vec-and-its-capacity-for-fast-and-efficient-programs/\" rel=\"noreferrer\">\"Unterstanding  Rust\u2019s Vec and its capacity for fast and efficient programs\"</a>. It goes into a lot more detail about how allocation and reallocation occurs in <code>Vec</code> and <code>VecDeque</code>, but the biggest take away is that if you can predict the maximum number of elements you're going to need in the queue you can use <code>VecDeque::with_capacity(x)</code> if you know when you initialize it, or <code>.reserve_exact(x)</code> if at some point you know exactly how many <em>more</em> slots you're going to need</p>\n\n<p>I strongly recommend checking out the Rust docs on <a href=\"https://doc.rust-lang.org/stable/std/collections/index.html\" rel=\"noreferrer\"><code>std::collections</code></a>, it has an excellent list of the most common collections used in Rust, along with suggestions on when to pick each</p>\n\n<p>One last thing, <code>VecDeque</code> isn't part of the default prelude in Rust so if you want to use it you need to include this:</p>\n\n<pre><code>use std::collections::VecDeque;\n</code></pre>\n\n"}], "owner": {"reputation": 25137, "user_id": 4498831, "user_type": "registered", "accept_rate": 92, "profile_image": "https://i.stack.imgur.com/jDBV2.png?s=128&g=1", "display_name": "Boiethios", "link": "https://stackoverflow.com/users/4498831/boiethios"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 13422, "favorite_count": 5, "accepted_answer_id": 40851723, "answer_count": 3, "score": 30, "last_activity_date": 1581815057, "creation_date": 1480349877, "last_edit_date": 1581815057, "question_id": 40848918, "link": "https://stackoverflow.com/questions/40848918/are-there-queue-and-stack-collections-in-rust", "title": "Are there queue and stack collections in Rust?", "body": "<p>If we need FIFO or LIFO collections (with basically <code>push</code>, <code>pop</code> and <code>front</code>/<code>back</code>) what should we use in Rust? Something like <code>std::queue</code> or <code>std::stack</code> from C++.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 3, "creation_date": 1480342252, "post_id": 40846232, "comment_id": 68909366, "body": "<code>A: Parameterisable + ?Sized</code>?"}, {"owner": {"reputation": 447, "user_id": 595309, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/1939c75d4c2f5ebfdd9901ef2db98b88?s=128&d=identicon&r=PG", "display_name": "John McCrae", "link": "https://stackoverflow.com/users/595309/john-mccrae"}, "reply_to_user": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 0, "creation_date": 1480342379, "post_id": 40846232, "comment_id": 68909439, "body": "Thanks, that seems to work... I tried: <code>pub struct Parameter&lt;A: Parameterisable&gt;(&amp;&#39;static str,Box&lt;A&gt;) where A: Sized</code> But that did not work"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480342975, "post_id": 40846232, "comment_id": 68909864, "body": "You should update your version of Rust to get more readable error messages."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "reply_to_user": {"reputation": 187800, "user_id": 320615, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/65c80e12b6a33913538653f6d4ef1277?s=128&d=identicon&r=PG", "display_name": "Dogbert", "link": "https://stackoverflow.com/users/320615/dogbert"}, "edited": false, "score": 1, "creation_date": 1480343839, "post_id": 40846232, "comment_id": 68910374, "body": "@Dogbert: Shouldn&#39;t <code>Box</code> accepts Unsized parameters?"}], "answers": [{"tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 3, "last_activity_date": 1480345985, "creation_date": 1480345985, "answer_id": 40847616, "question_id": 40846232, "link": "https://stackoverflow.com/questions/40846232/rust-compiler-does-not-see-structure-as-sized/40847616#40847616", "title": "Rust compiler does not see structure as Sized", "body": "<p>Type parameters in Rust have an <a href=\"http://huonw.github.io/blog/2015/01/the-sized-trait/\" rel=\"nofollow noreferrer\">implicit <code>Sized</code> bound</a> unless otherwise specified (by adding a <code>?Sized</code> bound).</p>\n\n<p>So the <code>Parameter</code> struct declaration is effectively:</p>\n\n<pre><code>pub struct Parameter&lt;A: Parameterisable+Sized&gt;(&amp;'static str, Box&lt;A&gt;);\n</code></pre>\n\n<p>Note that <code>Parameter&lt;T&gt;</code> is always itself sized, since <code>&amp;'static str</code> and <code>Box&lt;A&gt;</code> are always sized; the bound just says that <code>T</code> must also be sized.</p>\n\n<p>The error message backs this up; it's saying that <code>Parameterisable</code> is not <code>Sized</code>, not that <code>Parameter&lt;Parametrerisable&gt;</code> is not <code>Sized</code>.</p>\n\n<p>So the correct change is to add the <code>?Sized</code> bound:</p>\n\n<pre><code>pub struct Parameter&lt;A: Parameterisable+?Sized&gt;(&amp;'static str, Box&lt;A&gt;);\n</code></pre>\n"}], "owner": {"reputation": 447, "user_id": 595309, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/1939c75d4c2f5ebfdd9901ef2db98b88?s=128&d=identicon&r=PG", "display_name": "John McCrae", "link": "https://stackoverflow.com/users/595309/john-mccrae"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 209, "favorite_count": 2, "accepted_answer_id": 40847616, "answer_count": 1, "score": 2, "last_activity_date": 1480345985, "creation_date": 1480341953, "last_edit_date": 1495540409, "question_id": 40846232, "link": "https://stackoverflow.com/questions/40846232/rust-compiler-does-not-see-structure-as-sized", "title": "Rust compiler does not see structure as Sized", "body": "<p>I am trying to define a trait as follows:</p>\n\n<pre><code>pub struct Parameter&lt;A: Parameterisable&gt;(&amp;'static str, Box&lt;A&gt;);\n\npub trait Parameterisable {\n    // Some functions\n}\n\nimpl Parameterisable for i32 {}\nimpl Parameterisable for f64 {}\n\npub struct ParameterCollection(Vec&lt;Parameter&lt;Parameterisable&gt;&gt;);\n</code></pre>\n\n<p>That is, the parameter collection is a mixture of parameters of different types. However compiling gives the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0277]: the trait bound `Parameterisable + 'static: std::marker::Sized` is not satisfied\n  --&gt; src/main.rs:10:32\n   |\n10 | pub struct ParameterCollection(Vec&lt;Parameter&lt;Parameterisable&gt;&gt;);\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trait `Parameterisable + 'static: std::marker::Sized` not satisfied\n   |\n   = note: `Parameterisable + 'static` does not have a constant size known at compile-time\n   = note: required by `Parameter`\n</code></pre>\n\n<p>I am aware from <a href=\"https://stackoverflow.com/questions/25818082/vector-of-objects-belonging-to-a-trait\">this post</a> that <code>Vec</code> must be <code>Sized</code>, but it seems that <code>Parameter</code> should be sized (because of the <code>Box</code>) so how do I convince the Rust compiler that <code>Parameter</code> is a <code>Sized</code> type?</p>\n"}, {"tags": ["rust"], "answers": [{"tags": [], "owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "is_accepted": true, "score": 12, "last_activity_date": 1523774275, "last_edit_date": 1523774275, "creation_date": 1480368508, "answer_id": 40853817, "question_id": 40844243, "link": "https://stackoverflow.com/questions/40844243/in-memory-database-design/40853817#40853817", "title": "In memory database design", "body": "<p>The compiler rejects your code because it violates the correctness model enforced by Rust and could cause crashes. For one, if <code>get_person()</code> were allowed to compile, one might call it from two threads and modify the underlying object without the protection of the mutex, causing data races on the <code>String</code> object inside. Worse, one could wreak havoc even in a single-threaded scenario by doing something like:</p>\n\n<pre><code>let mut ref1 = db.get_person(1).unwrap();\nlet mut ref2 = db.get_person(1).unwrap();\n// ERROR - two mutable references to the same object!\n\nlet vec: Vec&lt;Person&gt; = vec![];\nvec.push(*ref1);  // move referenced object to the vector\nprintln!(*ref2);  // CRASH - object already moved\n</code></pre>\n\n<p>To correct the code, you need to adjust your design to satisfy the following constraints:</p>\n\n<ul>\n<li>No reference can be allowed to outlive the referred-to object;</li>\n<li>During the lifetime of a mutable reference, no other reference (mutable or immutable) to the object may exist..</li>\n</ul>\n\n<p>The <code>add_person</code> method already complies with both rules because it eats the object you pass it, moving it to the database.</p>\n\n<p>What if we modified <code>get_person()</code> to return an immutable reference?</p>\n\n<pre><code>pub fn get_person(&amp;self, id: i64) -&gt; Option&lt;&amp;Person&gt; {\n    self.db.lock().unwrap().get(&amp;id)\n}\n</code></pre>\n\n<p>Even this seemingly innocent version still doesn't compile! That is because it violates the first rule. Rust cannot statically prove that the reference will not outlive the database itself, since the database is allocated on the heap and reference-counted, so it can be dropped at any time. But even if it were possible to somehow explicitly declare the lifetime of the reference to one that provably couldn't outlive the database, retaining the reference after unlocking the mutex would allow data races. There is simply no way to implement <code>get_person()</code> and still retain thread safety.</p>\n\n<p>A thread-safe implementation of a read can opt to return a copy of the data. <code>Person</code> can implement the <code>clone()</code> method and <code>get_person()</code> can invoke it like this:</p>\n\n<pre><code>#[derive(Clone)]\nstruct Person {\n    id: i64,\n    name: String\n}\n// ...\n\npub fn get_person(&amp;self, id: i64) -&gt; Option&lt;Person&gt; {\n    self.db.lock().unwrap().get(&amp;id).cloned()\n}\n</code></pre>\n\n<p>This kind of change won't work for the other use case of <code>get_person()</code>, where the method is used for the express purpose of obtaining a mutable reference to change the person in the database. Obtaining a mutable reference to a shared resource violates the second rule and could lead to crashes as shown above. There are several ways to make it safe. One is by providing a proxy in the database for setting each <code>Person</code> field:</p>\n\n<pre><code>pub fn set_person_name(&amp;self, id: i64, new_name: String) -&gt; bool {\n    match self.db.lock().unwrap().get_mut(&amp;id) {\n        Some(mut person) =&gt; {\n            person.name = new_name;\n            true\n        }\n        None =&gt; false\n    }\n}\n</code></pre>\n\n<p>As the number of fields on <code>Person</code> grows, this would quickly get tedious. It could also get slow, as a separate mutex lock would have to be acquired for each access.</p>\n\n<p>There is fortunately a better way to implement modification of the entry. Remember that using a mutable reference violates the rules <em>unless</em> Rust can prove that the reference won't \"escape\" the block where it is being used. This can be ensured by inverting the control - instead of a <code>get_person()</code> that returns the mutable reference, we can introduce a <code>modify_person()</code> that <em>passes</em> the mutable reference to a callable, which can do whatever it likes with it. For example:</p>\n\n<pre><code>pub fn modify_person&lt;F&gt;(&amp;self, id: i64, f: F) where F: FnOnce(Option&lt;&amp;mut Person&gt;) {\n    f(self.db.lock().unwrap().get_mut(&amp;id))\n}\n</code></pre>\n\n<p>The usage would look like this:</p>\n\n<pre><code>fn main() {\n    let mut db = Database::new();\n\n    db.add_person(1, Person::new(1, \"Bob\"));\n    assert!(db.get_person(1).unwrap().name == \"Bob\");\n\n    db.modify_person(1, |person| {\n        person.unwrap().set_name(\"Bill\");\n    });\n}\n</code></pre>\n\n<p>Finally, if you're worried about the performance of <code>get_person()</code> cloning <code>Person</code> for the sole reason of inspecting it, it is trivial to create an immutable version of <code>modify_person</code> that serves as a non-copying alternative to <code>get_person()</code>:</p>\n\n<pre><code>pub fn read_person&lt;F, R&gt;(&amp;self, id: i64, f: F) -&gt; R\n    where F: FnOnce(Option&lt;&amp;Person&gt;) -&gt; R {\n    f(self.db.lock().unwrap().get(&amp;id))\n}\n</code></pre>\n\n<p>Besides taking a shared reference to <code>Person</code>, <code>read_person</code> is also allowing the closure to return a value if it chooses, typically something it picks up from the object it receives. Its usage would be similar to the usage of <code>modify_person</code>, with the added possibility of returning a value:</p>\n\n<pre><code>// if Person had an \"age\" field, we could obtain it like this:\nlet person_age = db.read_person(1, |person| person.unwrap().age);\n\n// equivalent to the copying definition of db.get_person():\nlet person_copy = db.read_person(1, |person| person.cloned());\n</code></pre>\n"}, {"tags": [], "owner": {"reputation": 11723, "user_id": 3356777, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/1c7bee1f2c7ba7f81ddb902b83626558?s=128&d=identicon&r=PG&f=1", "display_name": "attdona", "link": "https://stackoverflow.com/users/3356777/attdona"}, "is_accepted": false, "score": 2, "last_activity_date": 1523799298, "creation_date": 1523799298, "answer_id": 49842528, "question_id": 40844243, "link": "https://stackoverflow.com/questions/40844243/in-memory-database-design/49842528#49842528", "title": "In memory database design", "body": "<p>This post use the pattern cited as \"inversion of control\" in the <a href=\"https://stackoverflow.com/a/40853817/3356777\">well explained answer</a> and just add <strong>only</strong> sugar for demonstrating another api for an in-memory db.</p>\n\n<p>With a macro rule it is possible to expose a db client api like that:</p>\n\n<pre><code>fn main() {\n    let db = Database::new();\n\n    let person_id = 1234;\n\n    // probably not the best design choice to duplicate the person_id,\n    // for the purpose here is not important \n    db.add_person(person_id, Person::new(person_id, \"Bob\"));\n\n    db_update!(db #person_id =&gt; set_name(\"Gambadilegno\"));\n\n    println!(\"your new name is {}\",  db.get_person(person_id).unwrap().name);\n}\n</code></pre>\n\n<p>My opinionated macro has the format:</p>\n\n<pre><code>&lt;database_instance&gt; #&lt;object_key&gt; =&gt; &lt;method_name&gt;(&lt;args&gt;)\n</code></pre>\n\n<p>Below the macro implementation and the full demo code:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::sync::Arc;\nuse std::sync::Mutex;\n\nmacro_rules! db_update {\n    ($db:ident # $id:expr =&gt; $meth:tt($($args:tt)*)) =&gt; {\n        $db.modify_person($id, |person| {\n            person.unwrap().$meth($($args)*);\n        });\n    };\n}\n\n#[derive(Clone)]\nstruct Person {\n    id: u64,\n    name: String,\n}\n\nimpl Person {\n    pub fn new(id: u64, name: &amp;str) -&gt; Person {\n        Person {\n            id: id,\n            name: name.to_string(),\n        }\n    }\n\n    fn set_name(&amp;mut self, value: &amp;str) {\n        self.name = value.to_string();\n    }\n}\n\nstruct Database {\n    db: Arc&lt;Mutex&lt;HashMap&lt;u64, Person&gt;&gt;&gt;, // access from different threads\n}\n\nimpl Database {\n    pub fn new() -&gt; Database {\n        Database {\n            db: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    pub fn add_person(&amp;self, id: u64, person: Person) {\n        self.db.lock().unwrap().insert(id, person);\n    }\n\n    pub fn modify_person&lt;F&gt;(&amp;self, id: u64, f: F)\n    where\n        F: FnOnce(Option&lt;&amp;mut Person&gt;),\n    {\n        f(self.db.lock().unwrap().get_mut(&amp;id));\n    }\n\n    pub fn get_person(&amp;self, id: u64) -&gt; Option&lt;Person&gt; {\n        self.db.lock().unwrap().get(&amp;id).cloned()\n    }\n}\n</code></pre>\n"}], "owner": {"reputation": 81, "user_id": 1958483, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3351c7b67d284b1042b7cab03681cf08?s=128&d=identicon&r=PG", "display_name": "crocus", "link": "https://stackoverflow.com/users/1958483/crocus"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1748, "favorite_count": 1, "accepted_answer_id": 40853817, "answer_count": 2, "score": 4, "last_activity_date": 1523800998, "creation_date": 1480335766, "last_edit_date": 1523800998, "question_id": 40844243, "link": "https://stackoverflow.com/questions/40844243/in-memory-database-design", "title": "In memory database design", "body": "<p>I am trying to create an in-memory database using <code>HashMap</code>. I have a struct <code>Person</code>:</p>\n\n<pre><code>struct Person {\n    id: i64,\n    name: String,\n}\n\nimpl Person {\n    pub fn new(id: i64, name: &amp;str) -&gt; Person {\n        Person {\n            id: id,\n            name: name.to_string(),\n        }\n    }\n\n    pub fn set_name(&amp;mut self, name: &amp;str) {\n        self.name = name.to_string();\n    }\n}\n</code></pre>\n\n<p>And I have struct <code>Database</code>:</p>\n\n<pre><code>use std::collections::HashMap;\nuse std::sync::Arc;\nuse std::sync::Mutex;\n\nstruct Database {\n    db: Arc&lt;Mutex&lt;HashMap&lt;i64, Person&gt;&gt;&gt;,\n}\n\nimpl Database {\n    pub fn new() -&gt; Database {\n        Database {\n            db: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    pub fn add_person(&amp;mut self, id: i64, person: Person) {\n        self.db.lock().unwrap().insert(id, person);\n    }\n\n    pub fn get_person(&amp;self, id: i64) -&gt; Option&lt;&amp;mut Person&gt; {\n        self.db.lock().unwrap().get_mut(&amp;id)\n    }\n}\n</code></pre>\n\n<p>And code to use this database: </p>\n\n<pre><code>let mut db = Database::new();\ndb.add_person(1, Person::new(1, \"Bob\"));\n</code></pre>\n\n<p>I want to change <code>person</code>'s name: </p>\n\n<pre><code>let mut person = db.get_person(1).unwrap();\nperson.set_name(\"Bill\");\n</code></pre>\n\n<p>The <a href=\"https://play.rust-lang.org/?gist=b6bfec892ddb07bc7bd29888b5c6c54e&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">complete code in the Rust playground</a>.</p>\n\n<p>When compiling, I get a problem with Rust lifetimes:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0597]: borrowed value does not live long enough\n  --&gt; src/main.rs:39:9\n   |\n39 |         self.db.lock().unwrap().get_mut(&amp;id)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n40 |     }\n   |     - temporary value only lives until here\n   |\nnote: borrowed value must be valid for the anonymous lifetime #1 defined on the method body at 38:5...\n  --&gt; src/main.rs:38:5\n   |\n38 | /     pub fn get_person(&amp;self, id: i64) -&gt; Option&lt;&amp;mut Person&gt; {\n39 | |         self.db.lock().unwrap().get_mut(&amp;id)\n40 | |     }\n   | |_____^\n</code></pre>\n\n<p>How to implement this approach?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480306089, "post_id": 40836973, "comment_id": 68891211, "body": "See also <a href=\"http://stackoverflow.com/q/32641699/155423\">Connect SSH command to stdout</a> and <a href=\"http://stackoverflow.com/q/36865667/155423\">TCP tunnel over SSH in Rust</a> for tangentially related questions."}, {"owner": {"reputation": 51, "user_id": 580443, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dfbeae22b812a3a5a5e924772c31e51e?s=128&d=identicon&r=PG", "display_name": "mchapala", "link": "https://stackoverflow.com/users/580443/mchapala"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480308515, "post_id": 40836973, "comment_id": 68891795, "body": "@Shepmaster Thanks. Initially I started with ssh2-rs based on the above links but encountered issues with pem based authorization. So refactored the code to make of use std::process:Command"}], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 10, "last_activity_date": 1619113329, "last_edit_date": 1619113329, "creation_date": 1480305988, "answer_id": 40837026, "question_id": 40836973, "link": "https://stackoverflow.com/questions/40836973/unable-to-use-stdprocesscommand-no-such-file-or-directory/40837026#40837026", "title": "Unable to use std::process::Command - No such file or directory", "body": "<p>This appears to be a misunderstanding of how to use <code>std::process:Command</code>. <a href=\"https://doc.rust-lang.org/std/process/struct.Command.html#method.new\" rel=\"nofollow noreferrer\"><code>Command::new</code></a> takes <strong>just</strong> the program:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>fn new&lt;S: AsRef&lt;OsStr&gt;&gt;(program: S) -&gt; Command\n</code></pre>\n<p><a href=\"https://doc.rust-lang.org/std/process/struct.Command.html#method.arg\" rel=\"nofollow noreferrer\"><code>Command::arg</code></a> or <a href=\"https://doc.rust-lang.org/std/process/struct.Command.html#method.args\" rel=\"nofollow noreferrer\"><code>Command::args</code></a> are used to provide the arguments.</p>\n<p>You will want something like</p>\n<pre class=\"lang-rust prettyprint-override\"><code>Command::new(&quot;/usr/bin/ssh&quot;)\n    .args(&amp;[&quot;-i&quot;, &quot;/tmp/.ssh/25.pem&quot;, &quot;ubuntu@ip&quot;])\n    .spawn()\n</code></pre>\n"}], "owner": {"reputation": 51, "user_id": 580443, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dfbeae22b812a3a5a5e924772c31e51e?s=128&d=identicon&r=PG", "display_name": "mchapala", "link": "https://stackoverflow.com/users/580443/mchapala"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 719, "favorite_count": 0, "accepted_answer_id": 40837026, "answer_count": 1, "score": 2, "last_activity_date": 1619113329, "creation_date": 1480305582, "last_edit_date": 1610850423, "question_id": 40836973, "link": "https://stackoverflow.com/questions/40836973/unable-to-use-stdprocesscommand-no-such-file-or-directory", "title": "Unable to use std::process::Command - No such file or directory", "body": "<p>I am trying to use the following Rust code to connect to EC2 instances. </p>\n\n<pre><code>#[test]\nfn client_ssh_timeout2() {\n    match Command::new(\"/usr/bin/ssh -i /tmp/.ssh/25.pem ubuntu@ip\").spawn() {\n        Ok(_) =&gt; println!(\"Able to ssh\"),\n        Err(e) =&gt; println!(\"{:?}\", e),\n    };\n}\n</code></pre>\n\n<p>But I am getting the following error</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Error { repr: Os { code: 2, message: \"No such file or directory\" } }\n</code></pre>\n\n<p>Has anyone been able to use <code>std::process::Command</code> or any other Rust library to connect to EC2 instances using PEM files? I tried using ssh2-rs(libssh2) but couldn't connect to EC2 instances.</p>\n"}, {"tags": ["if-statement", "rust", "fold"], "answers": [{"comments": [{"owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "edited": false, "score": 0, "creation_date": 1480313060, "post_id": 40836898, "comment_id": 68893221, "body": "Thank you. I had no idea that if-statements behaved like that. Also I apologize about the lack of MCVE, I cleaned it up. On a related note, why does Rust allow single line if statements to lack <code>;</code> if they are not returning a value? For instance it <code>count</code> is a variable why would this compile: <code>if true {count = 1}</code>? Shouldn&#39;t you be required to add a semi-colon: <code>if true {count = 1;}</code>?"}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "edited": false, "score": 0, "creation_date": 1480340187, "post_id": 40836898, "comment_id": 68907999, "body": "@HiDefender <i>if they are not returning a value</i> \u2014 they <b>do</b> return a value - the value <code>()</code> of the type <code>()</code>. This is the empty tuple, sometimes called the &quot;unit type&quot;."}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 4, "last_activity_date": 1480338091, "last_edit_date": 1480338091, "creation_date": 1480304927, "answer_id": 40836898, "question_id": 40836385, "link": "https://stackoverflow.com/questions/40836385/using-if-inside-of-fold/40836898#40836898", "title": "Using if inside of fold", "body": "<p>What value are you attempting to use <strong>when the <code>if</code> condition is <code>false</code></strong>?</p>\n\n<p>That's what the compiler is telling you first. Because there's no <code>else</code> clause, the return type of the missing clause must be <code>()</code>. And since both the true and false branches of the <code>if</code> must have the same type, the true branch must return <code>()</code>. However, your true branch is trying to return a number.</p>\n\n<p>By adding the <code>;</code>, you made it so that both branches of the <code>if</code> returned <code>()</code>, which then failed because your <code>fold</code> is <em>supposed</em> to return an integer.</p>\n\n<p>One solution is to return a value in the <code>else</code> clause:</p>\n\n<pre><code>fn main() {\n    let domain = [(true, 1), (false, 2), (true, 3)];\n\n    let dom_count = domain.iter()\n        .fold(0, |count, &amp;(exists, _)| {\n            if exists {\n                count + 1\n            } else {\n                count\n            }\n        });\n\n    println!(\"dom_count: {}\", dom_count);\n}\n</code></pre>\n\n<p>Or</p>\n\n<pre><code>fn main() {\n    let domain = [(true, 1), (false, 2), (true, 3)];\n\n    let dom_count = domain.iter()\n        .fold(0, |count, &amp;(exists, _)| {\n            count + if exists {\n                1\n            } else {\n                0\n            }\n        });\n\n    println!(\"dom_count: {}\", dom_count);\n}\n</code></pre>\n\n<p>It's much more idiomatic to use <code>filter</code>:</p>\n\n<pre><code>fn main() {\n    let domain = [(true, 1), (false, 2), (true, 3)];\n\n    let dom_count = domain.iter()\n        .filter(|&amp;&amp;(exists, _)| exists)\n        .fold(0, |count, _| count + 1);\n\n    println!(\"dom_count: {}\", dom_count);\n}\n</code></pre>\n\n<p>And the act of counting the the number of items is already handled by <code>Iterator::count</code>:</p>\n\n<pre><code>fn main() {\n    let domain = [(true, 1), (false, 2), (true, 3)];\n\n    let dom_count = domain.iter().filter(|&amp;&amp;(exists, _)| exists).count();\n\n    println!(\"dom_count: {}\", dom_count);\n}\n</code></pre>\n"}], "owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 340, "favorite_count": 0, "accepted_answer_id": 40836898, "answer_count": 1, "score": -1, "last_activity_date": 1480338091, "creation_date": 1480300505, "last_edit_date": 1480312154, "question_id": 40836385, "link": "https://stackoverflow.com/questions/40836385/using-if-inside-of-fold", "title": "Using if inside of fold", "body": "<p>I need to count the length of a vector of <code>(bool, i32)</code> where if the <code>bool</code> is true I increment count. I'm using fold to do this:</p>\n\n<pre><code>fn main() {\n    let domain = [(true, 1), (false, 2), (true, 3)];\n    let dom_count = domain.iter()\n        .fold(0, |count, &amp;(exists, _)| if exists {count + 1});\n    println!(\"dom_count: {}\", dom_count);\n}\n</code></pre>\n\n<p>The compiler complained saying:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>.fold(0, |count, &amp;(exists, _)| if exists {count + 1})\n                               ^^^^^^^^^^^^^^^^^^^^^ expected (), found integral variable\n</code></pre>\n\n<p>So I added a <code>;</code> and got this:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>.fold(0, |count, &amp;(exists, _)| if exists {count + 1;})\n                               ^^^^^^^^^^^^^^^^^^^^^^ expected integral variable, found ()\n</code></pre>\n\n<p>How do you correctly use an <code>if</code> statement inside of <code>fold</code>?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 34083, "user_id": 1287251, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/IQkBy.png?s=128&g=1", "display_name": "Cornstalks", "link": "https://stackoverflow.com/users/1287251/cornstalks"}, "edited": false, "score": 0, "creation_date": 1480305193, "post_id": 40835396, "comment_id": 68891023, "body": "Desugaring the <code>for</code>-loop into its <code>loop { match ... {} }</code> equivalent and thinking of the pattern matching involved there makes the results make sense. Thanks! Earlier I tried printing the type (with the <code>let () = value;</code> trick) but was confused that it was a <code>u8</code>, but that&#39;s because I was expecting <code>&amp;mut value</code> to declare a mutable reference rather than act as a pattern. Thanks for the concise example and explanation!"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 1, "last_activity_date": 1480291538, "last_edit_date": 1495540798, "creation_date": 1480291538, "answer_id": 40835396, "question_id": 40834969, "link": "https://stackoverflow.com/questions/40834969/does-mut-do-anything-when-declaring-a-for-loop-variable/40835396#40835396", "title": "Does &amp;mut do anything when declaring a for loop variable?", "body": "<blockquote>\n  <p>Is <code>&amp;mut</code> here a no-op then?</p>\n</blockquote>\n\n<p>No, it's part of a pattern. <a href=\"https://stackoverflow.com/q/21747136/155423\">Print the type of <code>value</code></a>:</p>\n\n<pre><code>fn main() {\n    let mut array = &amp;mut [1u8, 2u8, 3u8];\n\n    for &amp;mut value in array {\n        let () = value;\n        // expected type `u8`\n    }\n\n    for value in array {\n        let () = value;\n        // expected type `&amp;mut u8`\n    }\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 34083, "user_id": 1287251, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/IQkBy.png?s=128&g=1", "display_name": "Cornstalks", "link": "https://stackoverflow.com/users/1287251/cornstalks"}, "edited": false, "score": 1, "creation_date": 1480305413, "post_id": 40835428, "comment_id": 68891071, "body": "This is a <i>fantastic</i> answer. Thank you for the thorough explanation and all the examples!"}], "tags": [], "owner": {"reputation": 11441, "user_id": 24817, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/233c279c012ebac792aaa805f966cbc7?s=128&d=identicon&r=PG", "display_name": "Steve Klabnik", "link": "https://stackoverflow.com/users/24817/steve-klabnik"}, "is_accepted": true, "score": 8, "last_activity_date": 1480294246, "last_edit_date": 1480294246, "creation_date": 1480291771, "answer_id": 40835428, "question_id": 40834969, "link": "https://stackoverflow.com/questions/40834969/does-mut-do-anything-when-declaring-a-for-loop-variable/40835428#40835428", "title": "Does &amp;mut do anything when declaring a for loop variable?", "body": "<p>So there's a few different things that's going on here. First, here's the answer:</p>\n\n<pre><code>fn main() {\n    let mut array = [1u8, 2u8, 3u8];\n    for value in &amp;mut array {\n        *value = 0; \n   }\n}\n</code></pre>\n\n<p>So. Where did you go wrong? Let's look at what <code>value</code> is, like this:</p>\n\n<pre><code>for &amp;mut value in array {\n    let () = value;\n}\n</code></pre>\n\n<p>This gives this error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>  = note: expected type `u8`\n  = note:    found type `()`\n</code></pre>\n\n<p>So here, <code>value</code> is a <code>u8</code>. But why? Well, let's try this one:</p>\n\n<pre><code>for value in array {\n    let () = value;\n}\n</code></pre>\n\n<p>This gives:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>  = note: expected type `&amp;mut u8`\n  = note:    found type `()`\n</code></pre>\n\n<p>So, <code>value</code> here is an <code>&amp;mut u8</code>, a reference into the array. So by saying <code>for &amp;mut value</code>, we're saying \"hey, this is going to be a mutable pointer to a <code>u8</code>. We'd like <code>value</code> to be the <code>u8</code> value that's pointed at. This is because <code>&amp;mut value</code> is a <em>pattern</em>, which binds against a <code>&amp;mut T</code> and binds <code>value</code> to the <code>T</code>.</p>\n\n<p>So, we remove the <code>&amp;mut</code>, since we don't want a copy of the value, we want to use it to modify what's pointed to. So that looks like this:</p>\n\n<pre><code>fn main() {\n    let mut array = &amp;mut [1u8, 2u8, 3u8];\n    for value in array {\n        *value = 0;\n    }\n}\n</code></pre>\n\n<p>This... compiles! Are we done? Well, let's try to print out <code>array</code>, just to be sure:</p>\n\n<pre><code>fn main() {\n    let mut array = &amp;mut [1u8, 2u8, 3u8];\n    for value in array {\n        *value = 0;\n    }\n\n    println!(\"{:?}\", array);\n}\n</code></pre>\n\n<p>This fails to compile:</p>\n\n<pre><code>error[E0382]: use of moved value: `array`\n --&gt; &lt;anon&gt;:7:22\n  |\n3 |     for value in array {\n  |                  ----- value moved here\n</code></pre>\n\n<p>We've destroyed <code>array</code> by iterating. Why's that? Well, when you loop over an array like this, you're saying you want to loop by owner. But that's <em>not</em> actually what we want; we want to loop by mutable reference.</p>\n\n<p>Arrays have a method to help with this:</p>\n\n<pre><code>fn main() {\n    let mut array = &amp;mut [1u8, 2u8, 3u8];\n    for value in array.iter_mut() {\n        *value = 0;\n    }\n\n    println!(\"{:?}\", array);\n}\n</code></pre>\n\n<p><code>iter_mut</code> will iterate by <code>&amp;mut T</code> rather than by <code>T</code>. So this works!</p>\n\n<p>One last thing, though:</p>\n\n<pre><code>let mut array = &amp;mut [1u8, 2u8, 3u8];\n</code></pre>\n\n<p>This says that <code>array</code> is a <code>&amp;mut [u8; 3]</code>, that is, a mutable reference to an array, not an array itself. This probably isn't what you actually want, and it's not neccesary with our code. So we can remove the <code>&amp;mut</code> bit:</p>\n\n<pre><code>let mut array = [1u8, 2u8, 3u8];\n</code></pre>\n\n<p>And now you're at our first code sample.</p>\n\n<p>Hope this helps!</p>\n"}], "owner": {"reputation": 34083, "user_id": 1287251, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.stack.imgur.com/IQkBy.png?s=128&g=1", "display_name": "Cornstalks", "link": "https://stackoverflow.com/users/1287251/cornstalks"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 441, "favorite_count": 0, "accepted_answer_id": 40835428, "answer_count": 2, "score": 2, "last_activity_date": 1480296610, "creation_date": 1480288065, "last_edit_date": 1480296610, "question_id": 40834969, "link": "https://stackoverflow.com/questions/40834969/does-mut-do-anything-when-declaring-a-for-loop-variable", "title": "Does &amp;mut do anything when declaring a for loop variable?", "body": "<p>Consider the following (dumb) program:</p>\n\n<pre><code>fn main() {\n    let mut array = &amp;mut [1u8, 2u8, 3u8];\n    for &amp;mut value in array {\n    }\n}\n</code></pre>\n\n<p>It compiles and runs okay (though warns about unused variables/unnecessary mutability, as expected). But what does <code>&amp;mut</code> do in the <code>for</code> statement?</p>\n\n<p>It doesn't seem to give you a mutable reference into the array, since trying to assign <code>value = 0;</code> results in the error:</p>\n\n<pre><code>error[E0384]: re-assignment of immutable variable `value`\n</code></pre>\n\n<p>Is <code>&amp;mut</code> here a no-op then?</p>\n"}, {"tags": ["rust", "static-linking", "dynamic-linking", "rust-cargo"], "answers": [{"comments": [{"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 1, "creation_date": 1480281372, "post_id": 40833794, "comment_id": 68885507, "body": "Maybe I&#39;m missing something but that doesn&#39;t seem to work. See my question edit."}, {"owner": {"reputation": 1721, "user_id": 4268862, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/daefd26c4e8c4ad64790330214dd26d1?s=128&d=identicon&r=PG", "display_name": "Lud", "link": "https://stackoverflow.com/users/4268862/lud"}, "reply_to_user": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 1, "creation_date": 1480282370, "post_id": 40833794, "comment_id": 68885831, "body": "Try to remove the prefix &quot;lib&quot;: <code>-l soundio</code>"}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "edited": false, "score": 0, "creation_date": 1480282811, "post_id": 40833794, "comment_id": 68885977, "body": "No effect, it&#39;s like it isn&#39;t even using the <code>.cargo&#47;config</code>. I suspect it is something to do with the <code>.libsoundio]</code> bit but there doesn&#39;t seem to be a way to get Cargo to print its build config so it is hard to debug!"}], "tags": [], "owner": {"reputation": 1721, "user_id": 4268862, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/daefd26c4e8c4ad64790330214dd26d1?s=128&d=identicon&r=PG", "display_name": "Lud", "link": "https://stackoverflow.com/users/4268862/lud"}, "is_accepted": false, "score": -1, "last_activity_date": 1480374057, "last_edit_date": 1480374057, "creation_date": 1480280094, "answer_id": 40833794, "question_id": 40833078, "link": "https://stackoverflow.com/questions/40833078/how-do-i-specify-the-linker-path-in-rust/40833794#40833794", "title": "How do I specify the linker path in Rust?", "body": "<p>With <code>rustc</code>, use <code>-L</code> and <code>-l</code>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ rustc --help\n...\n-L [KIND=]PATH      Add a directory to the library search path. The\n                    optional KIND can be one of dependency, crate, native,\n                    framework or all (the default).\n-l [KIND=]NAME      Link the generated crate(s) to the specified native\n                    library NAME. The optional KIND can be one of static,\n                    dylib, or framework. If omitted, dylib is assumed.\n...\n</code></pre>\n\n<p>Note, with <code>-l</code> you should discard the prefix <code>lib</code> and the extension <code>.a</code> of your static library: <code>-lsoundio</code></p>\n"}, {"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": false, "score": 16, "last_activity_date": 1480285300, "last_edit_date": 1480285300, "creation_date": 1480282452, "answer_id": 40834178, "question_id": 40833078, "link": "https://stackoverflow.com/questions/40833078/how-do-i-specify-the-linker-path-in-rust/40834178#40834178", "title": "How do I specify the linker path in Rust?", "body": "<p>As stated in the <a href=\"http://doc.crates.io/build-script.html#outputs-of-the-build-script\" rel=\"noreferrer\">documentation for a build script</a>:</p>\n\n<blockquote>\n  <p>All the lines printed to stdout by a build script [... starting] with <code>cargo:</code> is interpreted directly by Cargo [...] <code>rustc-link-search</code> indicates the specified value should be passed to the compiler as a <code>-L</code> flag.</p>\n</blockquote>\n\n<p>In your <strong>Cargo.toml</strong>:</p>\n\n<pre><code>[package]\nname = \"link-example\"\nversion = \"0.1.0\"\nauthors = [\"An Devloper &lt;an.devloper@example.com&gt;\"]\nbuild = \"build.rs\"\n</code></pre>\n\n<p>And your <strong>build.rs</strong>:</p>\n\n<pre><code>fn main() {\n    println!(r\"cargo:rustc-link-search=C:\\Rust\\linka\\libsoundio-1.1.0\\i686\");\n}\n</code></pre>\n\n<p>Note that your build script can use all the power of Rust and can output different values depending on target platform (e.g. 32- and 64-bit). </p>\n\n<p>Finally, your code:</p>\n\n<pre><code>extern crate libc;\n\nuse libc::c_char;\nuse std::ffi::CStr;\n\n#[link(name = \"soundio\")]\nextern {\n    fn soundio_version_string() -&gt; *const c_char;\n}\n\nfn main() {\n    let v = unsafe { CStr::from_ptr(soundio_version_string()) };\n    println!(\"{:?}\", v);\n}\n</code></pre>\n\n<p>The proof is in the pudding:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>$ cargo run\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target\\debug\\linka.exe`\n\"1.0.3\"\n</code></pre>\n\n<hr>\n\n<p>Ideally, you will create a <code>soundio-sys</code> package, using <a href=\"http://doc.crates.io/build-script.html#-sys-packages\" rel=\"noreferrer\">the convention for <code>*-sys</code> packages</a>. That simply has a build script that links to the appropriate libraries and exposes the C methods. It will use the <a href=\"http://doc.crates.io/build-script.html#the-links-manifest-key\" rel=\"noreferrer\">Cargo <code>links</code> key</a> to uniquely identify the native library and prevent linking to it multiple times. Other libraries can then include this new crate and not worry about those linking details.</p>\n"}, {"comments": [{"owner": {"reputation": 3591, "user_id": 338859, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/d0e95abdd0aed671ebd0920c16d393d4?s=128&d=identicon&r=PG", "display_name": "Envek", "link": "https://stackoverflow.com/users/338859/envek"}, "edited": false, "score": 0, "creation_date": 1495050196, "post_id": 40834356, "comment_id": 75093529, "body": "Thank you! How can I get name for my target (I&#39;m using Mac and Linux). Should I commit <code>.cargo&#47;config</code> into version control or should it be different for every developer?"}, {"owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "reply_to_user": {"reputation": 3591, "user_id": 338859, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/d0e95abdd0aed671ebd0920c16d393d4?s=128&d=identicon&r=PG", "display_name": "Envek", "link": "https://stackoverflow.com/users/338859/envek"}, "edited": false, "score": 0, "creation_date": 1495097593, "post_id": 40834356, "comment_id": 75111776, "body": "The target is set by rustup. Run <code>rustup show</code>. (Or you can override the default with something like <code>cargo --target blah</code>.) <code>.cargo&#47;config</code> should be in version control. However most people seem to use a non-empty <code>build.rs</code> to do this, rather than <code>.cargo&#47;config</code>."}], "tags": [], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "is_accepted": false, "score": 5, "last_activity_date": 1480285044, "last_edit_date": 1480285044, "creation_date": 1480283580, "answer_id": 40834356, "question_id": 40833078, "link": "https://stackoverflow.com/questions/40833078/how-do-i-specify-the-linker-path-in-rust/40834356#40834356", "title": "How do I specify the linker path in Rust?", "body": "<p>I found something that works OK: you can specify <code>links</code> in your <code>Cargo.toml</code>:</p>\n\n<pre><code>[package]\nlinks = \"libsoundio\"\nbuild = \"build.rs\"\n</code></pre>\n\n<p>This specifies that the project links to <code>libsoundio</code>. Now you can specify the search path and library name in the <code>.cargo/config</code> file:</p>\n\n<pre><code>[target.i686-pc-windows-gnu.libsoundio]\nrustc-link-search = [\"libsoundio-1.1.0/i686\"]\nrustc-link-lib = [\":libsoundio.a\"]\n\n[target.x86_64-pc-windows-gnu.libsoundio]\nrustc-link-search = [\"libsoundio-1.1.0/x86_64\"]\nrustc-link-lib = [\":libsoundio.a\"]\n</code></pre>\n\n<p>(The <code>:</code> prefix tells GCC to use the actual filename and not to do all its idiotic <code>lib</code>-prepending and extension magic.)</p>\n\n<p>You also need to create an empty <code>build.rs</code>:</p>\n\n<pre><code>fn main() {}\n</code></pre>\n\n<p>This file is never run, because the values in <code>.cargo/config</code> override its output, but for some reason Cargo still requires it - any time you use <code>links =</code> you have to have <code>build =</code>, even if it isn't used.</p>\n\n<p>Finally in <code>main.rs</code>:</p>\n\n<pre><code>#[link(name = \"libsoundio\")]\n#[link(name = \"ole32\")]\nextern {\n    fn soundio_version_string() -&gt; *const c_char;\n}\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 2086, "user_id": 1644618, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/e0b1b9b9e169f5e077d819493330a7c8?s=128&d=identicon&r=PG", "display_name": "yerlilbilgin", "link": "https://stackoverflow.com/users/1644618/yerlilbilgin"}, "edited": false, "score": 1, "creation_date": 1616800534, "post_id": 52017062, "comment_id": 118125800, "body": "Thanks a lot! This answer is underrated!"}], "tags": [], "owner": {"reputation": 590, "user_id": 507654, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/c36b6d3a9f80b1ee31cbd47ec45af3c6?s=128&d=identicon&r=PG", "display_name": "hbobenicio", "link": "https://stackoverflow.com/users/507654/hbobenicio"}, "is_accepted": false, "score": 7, "last_activity_date": 1535202443, "last_edit_date": 1535202443, "creation_date": 1535198039, "answer_id": 52017062, "question_id": 40833078, "link": "https://stackoverflow.com/questions/40833078/how-do-i-specify-the-linker-path-in-rust/52017062#52017062", "title": "How do I specify the linker path in Rust?", "body": "<p>Another possible way is <a href=\"https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-reads\" rel=\"noreferrer\">setting the <code>RUSTFLAGS</code></a> like:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>RUSTFLAGS='-L my/lib/location' cargo build # or cargo run\n</code></pre>\n\n<p>I don't know if this is the most organized and recommended approach, but it worked for my simple project.</p>\n"}], "owner": {"reputation": 67096, "user_id": 265521, "user_type": "registered", "accept_rate": 58, "profile_image": "https://www.gravatar.com/avatar/34a66330977044d70165288c56740d4b?s=128&d=identicon&r=PG", "display_name": "Timmmm", "link": "https://stackoverflow.com/users/265521/timmmm"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 15085, "favorite_count": 5, "answer_count": 4, "score": 14, "last_activity_date": 1535202443, "creation_date": 1480275418, "last_edit_date": 1480366800, "question_id": 40833078, "link": "https://stackoverflow.com/questions/40833078/how-do-i-specify-the-linker-path-in-rust", "title": "How do I specify the linker path in Rust?", "body": "<p>I'm trying to link a Rust program with <a href=\"http://libsound.io/\" rel=\"noreferrer\">libsoundio</a>. I'm using Windows and there's a GCC binary download available. I can link it like this if I put it in the same folder as my project:</p>\n\n<pre><code>#[link(name = \":libsoundio-1.1.0/i686/libsoundio.a\")]\n#[link(name = \"ole32\")]\nextern {\n    fn soundio_version_string() -&gt; *const c_char;\n}\n</code></pre>\n\n<p>But I really want to specify <code>#[link(name = \"libsoundio\")]</code> or even <code>#[link(name = \"soundio\")]</code>, and then provide a linker path somewhere else.</p>\n\n<p>Where can I specify that path?</p>\n\n<p>I tried the <code>rustc-link-search</code> suggestion as follows:</p>\n\n<pre><code>#[link(name = \"libsoundio\")]\n#[link(name = \"ole32\")]\nextern {\n    fn soundio_version_string() -&gt; *const c_char;\n}\n</code></pre>\n\n<p>And in <code>.cargo/config</code>:</p>\n\n<pre><code>[target.i686-pc-windows-gnu.libsoundio]\nrustc-link-search = [\"libsoundio-1.1.0/i686\"]\nrustc-link-lib = [\"libsoundio.a\"]\n\n[target.x86_64-pc-windows-gnu.libsoundio]\nrustc-link-search = [\"libsoundio-1.1.0/x86_64\"]\nrustc-link-lib = [\"libsoundio.a\"]\n</code></pre>\n\n<p>But it still only passes <code>\"-l\" \"libsoundio\"</code> to gcc and fails with the same <code>ld: cannot find -llibsoundio</code>. Am I missing something really obvious? The docs seem to suggest this should work.</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 3515, "user_id": 153133, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/d8f80701bcde5be0eb38f59fd604818b?s=128&d=identicon&r=PG", "display_name": "Crend King", "link": "https://stackoverflow.com/users/153133/crend-king"}, "edited": false, "score": 0, "creation_date": 1480317130, "post_id": 40829768, "comment_id": 68894760, "body": "I tried <code>s(ref bar) = f(&amp;my_struct2)</code>, but not as your answer. The combination of <code>&amp;</code> and <code>ref</code> seems to be double referencing, which I thought is wrong."}], "tags": [], "owner": {"reputation": 14973, "user_id": 128186, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/46c330659979615fe50c46f5f553b39f?s=128&d=identicon&r=PG", "display_name": "Arjan", "link": "https://stackoverflow.com/users/128186/arjan"}, "is_accepted": true, "score": 4, "last_activity_date": 1480257165, "last_edit_date": 1480257165, "creation_date": 1480255176, "answer_id": 40829768, "question_id": 40829552, "link": "https://stackoverflow.com/questions/40829552/how-to-destructure-tuple-struct-with-reference/40829768#40829768", "title": "How to destructure tuple struct with reference", "body": "<p>When you try to compile this, the Rust compiler will tell you how to fix the error with a nice message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0507]: cannot move out of borrowed content\n  --&gt; &lt;anon&gt;:11:9\n   |\n11 |     let &amp;s(bar) = f(&amp;my_struct2); // this does not work\n   |         ^^^---^\n   |         |  |\n   |         |  hint: to prevent move, use `ref bar` or `ref mut bar`\n   |         cannot move out of borrowed content\n</code></pre>\n\n<p>This is needed to tell the compiler that you only want a reference to the field in the struct; the default matching will perform a move and the original struct value will no longer be valid.</p>\n\n<p>Let's fix the example:</p>\n\n<pre><code>struct s(String);\n\nfn f(input: &amp;s) -&gt; &amp;s {\n    input\n}\n\nfn main() {\n    let my_struct1 = s(\"a\".to_owned());\n    let s(foo) = my_struct1;\n    let my_struct2 = s(\"b\".to_owned());\n    let &amp;s(ref bar) = f(&amp;my_struct2);\n}\n</code></pre>\n\n<p>Another way is to dereference first and drop the <code>&amp;</code>. I think this is preferred in Rust:</p>\n\n<pre><code>struct s(String);\n\nfn f(input: &amp;s) -&gt; &amp;s {\n    input\n}\n\nfn main() {\n    let my_struct1 = s(\"a\".to_owned());\n    let s(foo) = my_struct1;\n    let my_struct2 = s(\"b\".to_owned());\n    let s(ref bar) = *f(&amp;my_struct2);\n}\n</code></pre>\n"}], "owner": {"reputation": 3515, "user_id": 153133, "user_type": "registered", "accept_rate": 88, "profile_image": "https://www.gravatar.com/avatar/d8f80701bcde5be0eb38f59fd604818b?s=128&d=identicon&r=PG", "display_name": "Crend King", "link": "https://stackoverflow.com/users/153133/crend-king"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1357, "favorite_count": 0, "accepted_answer_id": 40829768, "answer_count": 1, "score": 1, "last_activity_date": 1480257195, "creation_date": 1480253633, "last_edit_date": 1480257195, "question_id": 40829552, "link": "https://stackoverflow.com/questions/40829552/how-to-destructure-tuple-struct-with-reference", "title": "How to destructure tuple struct with reference", "body": "<p>I'm trying to use the hyper library to make some requests. The <a href=\"http://hyper.rs/hyper/v0.9.12/hyper/header/struct.Headers.html#method.get\" rel=\"nofollow noreferrer\"><code>Headers::get()</code></a> method returns <code>Option&lt;&amp;H&gt;</code>, where <code>H</code> is a tuple struct with one field. I can use <code>if let Some()</code> to destructure the <code>Option</code>. But how do we destructure the <code>&amp;H</code>? Sure I could always access the field with <code>.0</code>, but I'm curious if Rust has a syntax to do this.</p>\n\n<pre><code>struct s(String);\n\nfn f(input: &amp;s) -&gt; &amp;s {\n    input\n}\n\nfn main() {\n    let my_struct1 = s(\"a\".to_owned());\n    let s(foo) = my_struct1;\n    let my_struct2 = s(\"b\".to_owned());\n    let &amp;s(bar) = f(&amp;my_struct2); // this does not work\n    let baz = &amp;my_struct2.0; // this works\n}\n</code></pre>\n"}, {"tags": ["openssl", "rust", "rust-cargo", "hyper"], "answers": [{"comments": [{"owner": {"reputation": 670, "user_id": 386991, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/2dba4ca7b639638aaf4039f98dee69f5?s=128&d=identicon&r=PG", "display_name": "Machisuji", "link": "https://stackoverflow.com/users/386991/machisuji"}, "edited": false, "score": 0, "creation_date": 1480250380, "post_id": 40824608, "comment_id": 68875864, "body": "Thanks! I just want to parse a posted JSON body. Ok I&#39;ll just have to drop params then and find something else to do that."}, {"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "reply_to_user": {"reputation": 670, "user_id": 386991, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/2dba4ca7b639638aaf4039f98dee69f5?s=128&d=identicon&r=PG", "display_name": "Machisuji", "link": "https://stackoverflow.com/users/386991/machisuji"}, "edited": false, "score": 1, "creation_date": 1480250827, "post_id": 40824608, "comment_id": 68876023, "body": "@Machisuji I created a <a href=\"https://github.com/iron/params/pull/31\" rel=\"nofollow noreferrer\">pull request</a> for params which should fix that."}, {"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "reply_to_user": {"reputation": 670, "user_id": 386991, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/2dba4ca7b639638aaf4039f98dee69f5?s=128&d=identicon&r=PG", "display_name": "Machisuji", "link": "https://stackoverflow.com/users/386991/machisuji"}, "edited": false, "score": 1, "creation_date": 1480440252, "post_id": 40824608, "comment_id": 68959452, "body": "@Machisuji it has been fixed, your original example is now working, as params 0.5.0 will be <a href=\"http://doc.crates.io/specifying-dependencies.html\" rel=\"nofollow noreferrer\">used automatically</a> now."}], "tags": [], "owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "is_accepted": true, "score": 4, "last_activity_date": 1480209379, "last_edit_date": 1480209379, "creation_date": 1480206738, "answer_id": 40824608, "question_id": 40824435, "link": "https://stackoverflow.com/questions/40824435/using-both-git2-and-hyper-openssl-linked-more-than-once/40824608#40824608", "title": "Using both git2 and hyper: openssl linked more than once", "body": "<p>The problem is the combination of params and openssl:</p>\n\n<pre><code>[dependencies]\nopenssl = \"0.9.1\"\nparams = \"0.5.0\"\n</code></pre>\n\n<p><a href=\"https://crates.io/crates/params/0.5.0\" rel=\"nofollow noreferrer\">params 0.5</a> requires multipart 0.8, with features <code>server</code>, but <a href=\"https://github.com/iron/params/blob/master/Cargo.toml\" rel=\"nofollow noreferrer\">without</a> <code>default-features = false</code>:</p>\n\n<pre><code>[dependencies.multipart]\nfeatures = [\"server\"]\nversion = \"0.8\"\n</code></pre>\n\n<p>That means <a href=\"https://crates.io/crates/multipart/0.8.1\" rel=\"nofollow noreferrer\">multipart 0.8</a> will also require <a href=\"https://crates.io/crates/hyper/0.9.12\" rel=\"nofollow noreferrer\">hyper 0.9</a>. And hyper (using the default features) requires openssl 0.7.</p>\n\n<p>There is a <a href=\"https://github.com/hyperium/hyper/issues/907\" rel=\"nofollow noreferrer\">ticket</a> in hyper to switch to a newer openssl version. </p>\n"}], "owner": {"reputation": 670, "user_id": 386991, "user_type": "registered", "accept_rate": 50, "profile_image": "https://www.gravatar.com/avatar/2dba4ca7b639638aaf4039f98dee69f5?s=128&d=identicon&r=PG", "display_name": "Machisuji", "link": "https://stackoverflow.com/users/386991/machisuji"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 277, "favorite_count": 1, "accepted_answer_id": 40824608, "answer_count": 1, "score": 4, "last_activity_date": 1480366811, "creation_date": 1480204908, "last_edit_date": 1495540911, "question_id": 40824435, "link": "https://stackoverflow.com/questions/40824435/using-both-git2-and-hyper-openssl-linked-more-than-once", "title": "Using both git2 and hyper: openssl linked more than once", "body": "<p>I'm trying to build something which is using both hyper and git2 at the same time. Now I've got a problem with openssl being linked twice. A tip by <a href=\"https://stackoverflow.com/users/155423/shepmaster\">shepmaster</a> lead me to Cargos <code>features</code> and I tried that but I'm still stuck.</p>\n\n<p>The precise error I'm getting upon <code>cargo build</code> is the following:</p>\n\n<pre><code>error: native library `openssl` is being linked to by more than one version of the same package, but it can only be linked once; try updating or pinning your dependencies to ensure that this package only shows up once\n\n  openssl-sys v0.7.17\n  openssl-sys v0.9.1\n</code></pre>\n\n<p>As far as I can tell openssl is required both by git2 and hyper. Does anyone have any idea what I'm doing wrong? Since I disabled the default features for hyper (and cookie for good measure) openssl should not be required by it anymore. I've looked through the lock file to see if <code>openssl</code> is required by anything else but I couldn't find anything. But I still get the error. Unfortunately cargo doesn't tell me where the dependency comes from.</p>\n\n<p>Here's my <code>Cargo.toml</code>'s dependency section and the lock file:</p>\n\n<pre><code>[dependencies]\nopenssl = \"0.9.1\"\nhoedown = \"5.0.0\"\niron = \"0.4.0\"\nwebbrowser = \"0.1.3\"\nrouter = \"0.4.0\"\nstaticfile = \"0.3.1\"\nclap = \"2.18.0\"\nlazy_static = \"0.2.2\"\nlinked-hash-map = \"0.3.0\"\nparams = \"0.5.0\"\ngit2 = \"0.6.1\"\n\n[dependencies.yaml-rust]\nversion = \"0.3.4\"\nfeatures = [\"preserve_order\"]\n\n[dependencies.hyper]\nversion = \"0.9.12\"\ndefault-features = false\n\n[dependencies.cookie]\nversion = \"0.2.5\"\ndefault-features = false\n</code></pre>\n\n<p>Here's the <a href=\"https://gist.github.com/machisuji/fea6186ea550277808b26aa75d652d2c\" rel=\"nofollow noreferrer\">Cargo.lock</a> in case that's of interest.</p>\n"}, {"tags": ["rust", "lifetime"], "comments": [{"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 2, "creation_date": 1480203993, "post_id": 40823559, "comment_id": 68867403, "body": "<code>impl&lt;&#39;a&gt; MyTrait for &amp;&#39;a MyStruct</code> makes more sense"}, {"owner": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 2, "creation_date": 1480204035, "post_id": 40823559, "comment_id": 68867408, "body": "See <a href=\"https://play.rust-lang.org/?gist=1dbba3c2cd3fe1aec9339aeeb0408a29&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">play.rust-lang.org/&hellip;</a>"}, {"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1480205749, "post_id": 40823559, "comment_id": 68867689, "body": "Thanks, that looks much better. However I don&#39;t quite understand why this works - it looks to me like you are saying that the trait is implemented by a reference to MyStruct, not by MyStruct itself? Is that some form of rust auto-dereferencing in action?"}, {"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "reply_to_user": {"reputation": 20827, "user_id": 2733851, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/MUOS4.png?s=128&g=1", "display_name": "mcarton", "link": "https://stackoverflow.com/users/2733851/mcarton"}, "edited": false, "score": 0, "creation_date": 1480206358, "post_id": 40823559, "comment_id": 68867781, "body": "Actually, this will cause code like this: <code>let obj: MyStruct = MyStruct { data : vec![] }; touch_all(&amp;mut obj);</code> to fail, as MyStruct does not implement the trait. So I&#39;d have to write <code>touch_all(&amp;mut &amp;obj)</code> which feels more than strange."}, {"owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "edited": false, "score": 3, "creation_date": 1480210178, "post_id": 40823559, "comment_id": 68868372, "body": "To clarify, <code>fn iter(&amp;&#39;a self)</code> in your original code, will borrow the containing type as long as it lives. That is why the borrow extends to the entire function. (You would also not been able to call <code>touch</code> twice - not even in the for-loop)."}, {"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 0, "creation_date": 1480215153, "post_id": 40823559, "comment_id": 68869146, "body": "Thanks, I think I&#39;m starting to understand - in touch_all, obj is borrowed for the duration of &#39;a, and since obj is used throughout &#39;a must be the entire duration of touch_all. The same timeline &#39;a is used as parameter to MyTrait, meaning iter() will borrow for the same duration, even though it wouldn&#39;t need to. So I&#39;d need to separate the lifetime of obj from the lifetime of the trait (as is the case for your implementation). Actually tried that before but ran into other errors, but at least it&#39;s clearer to me now."}], "owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 184, "favorite_count": 1, "answer_count": 0, "score": 2, "last_activity_date": 1480276576, "creation_date": 1480197324, "last_edit_date": 1480276576, "question_id": 40823559, "link": "https://stackoverflow.com/questions/40823559/lifetime-on-trait-returning-iterator", "title": "Lifetime on trait returning iterator", "body": "<p>I'm working with a trait requiring a function returning an iterator without consuming the object. The iterator itself returns copies of data values, not references. As the iterator implementation requires a reference to the object it is iterating over, I end up having to declare lots of lifetimes (more than I would have thought necessary, but could not get it to compile otherwise). I then run into trouble with borrow duration - a minimal \"working\" example is as follows:</p>\n\n<pre><code>pub trait MyTrait&lt;'a&gt; {\n    type IteratorType: Iterator&lt;Item=u32&gt;;\n    fn iter(&amp;'a self) -&gt; Self::IteratorType;\n    fn touch(&amp;'a mut self, value: u32);\n}\nstruct MyStruct {\n    data: Vec&lt;u32&gt;\n}\nstruct MyIterator&lt;'a&gt; {\n    structref: &amp;'a MyStruct,\n    next: usize,\n}\nimpl&lt;'a&gt; Iterator for MyIterator&lt;'a&gt; {\n    type Item = u32;\n    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {\n        if self.next &lt; self.structref.data.len() {\n            self.next += 1;\n            return Some(self.structref.data[self.next-1]);\n        } else {\n            return None;\n        }\n    }\n}\nimpl&lt;'a&gt; MyTrait&lt;'a&gt; for MyStruct {\n    type IteratorType = MyIterator&lt;'a&gt;;\n    fn iter(&amp;'a self) -&gt; Self::IteratorType {\n        return MyIterator { structref: &amp;self, next: 0 };\n    }\n    fn touch(&amp;'a mut self, value: u32) {\n    }\n}\nfn touch_all&lt;'a,T&gt;(obj: &amp;'a mut T) where T: MyTrait&lt;'a&gt; {\n    let data: Vec&lt;u32&gt; = obj.iter().collect();\n    for value in data {\n        obj.touch(value);\n    }\n}\n</code></pre>\n\n<p>Compiling this gives me the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0502]: cannot borrow `*obj` as mutable because it is also borrowed as immutable\n|\n39 |     let data: Vec&lt;u32&gt; = obj.iter().collect();\n|                          --- immutable borrow occurs here\n40 |     for value in data {\n41 |         obj.touch(value);\n|         ^^^ mutable borrow occurs here\n42 |     }\n43 | }\n| - immutable borrow ends here\n</code></pre>\n\n<p>By my limited understanding of lifetimes, I would have thought the immutable borrow only extends to the line where I make it - after all the iterator is consumed and I no longer hold any references to obj or data contained in it. Why does the lifetime of the borrow extend to the entire function, and how do I fix this?</p>\n\n<p>Here is a sequence of steps on how I arrived here - running the code should provide the associated compiler errors.</p>\n\n<ul>\n<li><a href=\"https://play.rust-lang.org/?gist=435bdbbdbf8d848491554b77d6585ee4&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">no explicit lifetimes</a></li>\n<li><a href=\"https://play.rust-lang.org/?gist=e37a4cf6a79ae336a585e8ed44320272&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">IteratorType needs lifetime</a></li>\n<li><a href=\"https://play.rust-lang.org/?gist=14919832cc7c634bb169bbafd48ea990&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Unconstrained lifetime parameter</a></li>\n</ul>\n\n<p>To clarify: I'd like to be able to make calls like this:</p>\n\n<pre><code>fn main() {\n    let obj: MyStruct = MyStruct { data : vec![] };\n    touch_all(&amp;mut obj);\n}\n</code></pre>\n\n<p>rather than having to call</p>\n\n<pre><code>    touch_all(&amp;mut &amp;obj);\n</code></pre>\n\n<p>which would be needed for the proposal by mcarton (1st and 2nd comment).</p>\n"}, {"tags": ["python", "path", "rust", "environment-variables"], "answers": [{"tags": [], "owner": {"reputation": 8404, "user_id": 243712, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/5347c683b6963f418d1b16c65917bf3f?s=128&d=identicon&r=PG", "display_name": "poolie", "link": "https://stackoverflow.com/users/243712/poolie"}, "is_accepted": true, "score": 3, "last_activity_date": 1480194992, "creation_date": 1480194992, "answer_id": 40823240, "question_id": 40823230, "link": "https://stackoverflow.com/questions/40823230/what-is-the-rust-equivalent-of-python-os-pathsep/40823240#40823240", "title": "What is the Rust equivalent of Python os.pathsep?", "body": "<p>There doesn't seem to be a constant for this, but Rust does provide <a href=\"https://doc.rust-lang.org/std/env/fn.split_paths.html\" rel=\"nofollow noreferrer\"><code>std:::env::split_paths</code></a> and <a href=\"https://doc.rust-lang.org/std/env/fn.join_paths.html\" rel=\"nofollow noreferrer\"><code>std::env::join_paths</code></a>.</p>\n"}], "owner": {"reputation": 8404, "user_id": 243712, "user_type": "registered", "accept_rate": 93, "profile_image": "https://www.gravatar.com/avatar/5347c683b6963f418d1b16c65917bf3f?s=128&d=identicon&r=PG", "display_name": "poolie", "link": "https://stackoverflow.com/users/243712/poolie"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 168, "favorite_count": 0, "accepted_answer_id": 40823240, "answer_count": 1, "score": 2, "last_activity_date": 1480194992, "creation_date": 1480194919, "question_id": 40823230, "link": "https://stackoverflow.com/questions/40823230/what-is-the-rust-equivalent-of-python-os-pathsep", "title": "What is the Rust equivalent of Python os.pathsep?", "body": "<p>Python has:</p>\n\n<blockquote>\n  <p><strong>os.pathsep</strong>: \n  The character conventionally used by the operating system to separate search path components (as in PATH), such as ':' for POSIX or ';' for Windows. Also available via <code>os.path</code>.</p>\n</blockquote>\n\n<p>Is there a similar os-specific definition in Rust?</p>\n"}, {"tags": ["build", "rust", "rust-cargo"], "comments": [{"owner": {"reputation": 6045, "user_id": 1036670, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/8d2dr.jpg?s=128&g=1", "display_name": "vitiral", "link": "https://stackoverflow.com/users/1036670/vitiral"}, "edited": false, "score": 0, "creation_date": 1480181868, "post_id": 40820960, "comment_id": 68861353, "body": "thanks for the dup tag, I wasn&#39;t thinking of looking up &quot;parallel&quot;!"}], "owner": {"reputation": 6045, "user_id": 1036670, "user_type": "registered", "accept_rate": 86, "profile_image": "https://i.stack.imgur.com/8d2dr.jpg?s=128&g=1", "display_name": "vitiral", "link": "https://stackoverflow.com/users/1036670/vitiral"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 17, "favorite_count": 0, "closed_date": 1480181189, "answer_count": 0, "score": 1, "last_activity_date": 1480182135, "creation_date": 1480180792, "last_edit_date": 1480182135, "question_id": 40820960, "link": "https://stackoverflow.com/questions/40820960/is-there-a-way-to-cache-nightly-and-stable-builds-separately-in-rust", "closed_reason": "Duplicate", "title": "Is there a way to cache nightly and stable builds separately in Rust?", "body": "<p>I am developing a Rust project and frequently do the following commands in series:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code># runs clippy on latest nightly\nrustup run nightly cargo clippy\n# run tests on stable\ncargo test\n</code></pre>\n\n<p>This causes my project to rebuild the full set of dependencies every time I build each. Is there a way to cache the builds separately?</p>\n"}, {"tags": ["arrays", "optimization", "rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1480172644, "post_id": 40818373, "comment_id": 68858469, "body": "<i>I believe the bottleneck [...]</i> \u2014 don&#39;t do that. <b>Measure and know</b>. We could certainly post answers that we &quot;believe&quot; are faster; do you think those would be useful?"}, {"owner": {"reputation": 4156, "user_id": 3072896, "user_type": "registered", "accept_rate": 77, "profile_image": "https://i.stack.imgur.com/WWVXA.png?s=128&g=1", "display_name": "Joe Thomas", "link": "https://stackoverflow.com/users/3072896/joe-thomas"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480179582, "post_id": 40818373, "comment_id": 68860544, "body": "I&#39;m just a beginner, heck I don&#39;t even know how to benchmark rust code. I would appreciate anything, but I think I found an answer."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 3, "creation_date": 1480180552, "post_id": 40818373, "comment_id": 68860887, "body": "Did you compile <a href=\"https://doc.rust-lang.org/stable/book/getting-started.html#building-for-release\" rel=\"nofollow noreferrer\">in release mode</a>? What is &quot;too slow&quot;? Did you read <a href=\"https://doc.rust-lang.org/stable/book/benchmark-tests.html\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i> chapter on benchmarking</a>?"}], "owner": {"reputation": 4156, "user_id": 3072896, "user_type": "registered", "accept_rate": 77, "profile_image": "https://i.stack.imgur.com/WWVXA.png?s=128&g=1", "display_name": "Joe Thomas", "link": "https://stackoverflow.com/users/3072896/joe-thomas"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 172, "favorite_count": 0, "answer_count": 0, "score": 1, "last_activity_date": 1480172481, "creation_date": 1480163665, "last_edit_date": 1480172481, "question_id": 40818373, "link": "https://stackoverflow.com/questions/40818373/best-way-to-store-and-retrieve-large-arrays-or-vectors-in-rust", "title": "Best way to store and retrieve large arrays (or vectors) in Rust?", "body": "<p>Is there a fast and efficient way in Rust to store and retrieve arrays from the file system? I believe the bottleneck in my code is the iteration part. Is there any way to make that faster? Here's part of the code:</p>\n\n<pre><code>match File::open(\"LOOKUP_CACHE.dat\") {\n    Ok(val) =&gt; {\n        // Since it exists, just load it into mem.\n        let mut s = String::new();\n        let mut a = val;\n        println!(\"COMMENT: Found a Lookup Cache, loading it..\");\n        a.read_to_string(&amp;mut s);\n        for (index, value) in s.split(\",\").enumerate() {\n            unsafe {\n                build::WON_TABLE[index as usize] = u8::from_str_radix(value,10).ok().unwrap();\n            }\n        }\n    }\n}\n</code></pre>\n\n<p>For context:</p>\n\n<pre><code>pub static mut WON_TABLE: &amp;'static mut [u8] = &amp;mut [0; 1000];\n</code></pre>\n"}, {"tags": ["string", "rust"], "comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 2, "creation_date": 1480156523, "post_id": 40817401, "comment_id": 68854346, "body": "Can&#39;t reproduce in the <a href=\"https://play.rust-lang.org/?gist=5e1f563dd638e1358f409e07c8d7931c&amp;version=stable&amp;backtrace=0\" rel=\"nofollow noreferrer\">Rust Playground</a>. Could you create a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>?"}, {"owner": {"reputation": 432, "user_id": 3381781, "user_type": "registered", "accept_rate": 47, "profile_image": "https://www.gravatar.com/avatar/b43561da313b4da4bde48ceb6d26b75f?s=128&d=identicon&r=PG&f=1", "display_name": "Masked Man", "link": "https://stackoverflow.com/users/3381781/masked-man"}, "reply_to_user": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 0, "creation_date": 1480157102, "post_id": 40817401, "comment_id": 68854484, "body": "Edited now. I added example."}], "answers": [{"comments": [{"owner": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 1, "creation_date": 1480163775, "post_id": 40818220, "comment_id": 68856114, "body": "I would advise against comparing to <code>&quot;Y\\n&quot;</code> because it will make the code more platform-dependent and it&#39;s likely to be a hidden source of confusion. <code>trim()</code> is definitely the way to go in my opinion, just like how the duplicate question&#39;s answer shows."}, {"owner": {"reputation": 6344, "user_id": 1960180, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ScAeW.png?s=128&g=1", "display_name": "Aaron D", "link": "https://stackoverflow.com/users/1960180/aaron-d"}, "reply_to_user": {"reputation": 10707, "user_id": 6650102, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/boCIP.jpg?s=128&g=1", "display_name": "Aurora0001", "link": "https://stackoverflow.com/users/6650102/aurora0001"}, "edited": false, "score": 1, "creation_date": 1480164216, "post_id": 40818220, "comment_id": 68856247, "body": "Thanks for pointing that out. Updated to clarify."}], "tags": [], "owner": {"reputation": 6344, "user_id": 1960180, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/ScAeW.png?s=128&g=1", "display_name": "Aaron D", "link": "https://stackoverflow.com/users/1960180/aaron-d"}, "is_accepted": true, "score": 1, "last_activity_date": 1480164197, "last_edit_date": 1480164197, "creation_date": 1480162568, "answer_id": 40818220, "question_id": 40817401, "link": "https://stackoverflow.com/questions/40817401/rust-string-is-not-a-string/40818220#40818220", "title": "Rust String is not a String", "body": "<p>As a general rule, when comparing Strings in Rust, it's better to turn the string into a <code>&amp;str</code> for comparison against a string literal, rather than converting the string literal into a <code>String</code>. The reason for this is that the latter requires object creation (allocating for a <code>String</code>), while the first doesn't, and so it's more efficient.</p>\n\n<p>The specific problem you are seeing here comes from the fact that your input does not have excess whitespace stripped. After the line</p>\n\n<pre><code>io::stdin().read_line(&amp;mut sure).expect(\"Failed\");\n</code></pre>\n\n<p>The value of <code>sure</code> is not <code>\"Y\"</code> as you might expect, but is actually <code>\"Y\\n\"</code> on Unix, or <code>\"Y\\r\\n\"</code> on Windows. You can compare this directly by modifying your comparison as so:</p>\n\n<pre><code>let surely = {sure.as_str() == \"Y\\n\"};\nprintln!(\"surely {} \", surely );\n</code></pre>\n\n<p>And you will see it return \"surely true\". However, this makes your code platform-dependent. Preferably, use the string method <a href=\"https://doc.rust-lang.org/std/string/struct.String.html#method.trim\" rel=\"nofollow noreferrer\"><code>String.trim()</code></a>, which will remove the trailing whitespace.</p>\n"}], "owner": {"reputation": 432, "user_id": 3381781, "user_type": "registered", "accept_rate": 47, "profile_image": "https://www.gravatar.com/avatar/b43561da313b4da4bde48ceb6d26b75f?s=128&d=identicon&r=PG&f=1", "display_name": "Masked Man", "link": "https://stackoverflow.com/users/3381781/masked-man"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 128, "favorite_count": 0, "closed_date": 1480164468, "accepted_answer_id": 40818220, "answer_count": 1, "score": 0, "last_activity_date": 1480164197, "creation_date": 1480156412, "last_edit_date": 1480162721, "question_id": 40817401, "link": "https://stackoverflow.com/questions/40817401/rust-string-is-not-a-string", "closed_reason": "Duplicate", "title": "Rust String is not a String", "body": "<p>I use String::from(\"string\") to get a String</p>\n\n<pre><code>let dog = String::from(\"dog\")\n</code></pre>\n\n<p>and</p>\n\n<pre><code>dog == String::from(\"dog\")\n</code></pre>\n\n<p>returns false. Even in pattern matching.</p>\n\n<pre><code>match dog.as_ref() {\n   \"dog\" =&gt; println!(\"Dog is a dog\"), //no output\n   _ =&gt; println!(\"Dog is not a dog\")\n}\n</code></pre>\n\n<p>What is wrong?</p>\n\n<p>Example </p>\n\n<pre><code>use std::io;\nfn main() {\n    let mut sure = String::from(\"\");\n    println!(\"Hello, world!\");\n    println!(\"Are you sure(Y/N)\"); \n    io::stdin().read_line(&amp;mut sure).expect(\"Failed\");\n    println!(\"sure {}\", sure ); \n    let surely = {sure == String::from(\"Y\")};\n    println!(\"surely {} \", surely ); //this line output is \"surely false\"\n    if surely {\n        dog_loop(\"HA\");\n    }\n}\n</code></pre>\n"}, {"tags": ["arrays", "rust", "mutability"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480172033, "post_id": 40817060, "comment_id": 68858286, "body": "I&#39;d &quot;expand&quot; on it by <b>don&#39;t do this</b>. Global variables are a <i>terrible</i> idea. If you are going to do it, you might as well do it in <a href=\"http://stackoverflow.com/q/27791532/155423\">a thread-safe manner</a>."}, {"owner": {"reputation": 4156, "user_id": 3072896, "user_type": "registered", "accept_rate": 77, "profile_image": "https://i.stack.imgur.com/WWVXA.png?s=128&g=1", "display_name": "Joe Thomas", "link": "https://stackoverflow.com/users/3072896/joe-thomas"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480172137, "post_id": 40817060, "comment_id": 68858321, "body": "You&#39;re everywhere!"}], "tags": [], "owner": {"reputation": 4156, "user_id": 3072896, "user_type": "registered", "accept_rate": 77, "profile_image": "https://i.stack.imgur.com/WWVXA.png?s=128&g=1", "display_name": "Joe Thomas", "link": "https://stackoverflow.com/users/3072896/joe-thomas"}, "is_accepted": false, "score": 2, "last_activity_date": 1480154188, "creation_date": 1480154188, "answer_id": 40817060, "question_id": 40816995, "link": "https://stackoverflow.com/questions/40816995/static-mutable-array-not-working-in-rust/40817060#40817060", "title": "Static mutable array not working in Rust", "body": "<p>I just figured out the answer. I have to also declare the variables inside the array as mutable. I do this by changing:</p>\n\n<pre><code>pub static mut WON_TABLE: &amp;'static [u8] = &amp;[0; 1000];\n</code></pre>\n\n<p>to:</p>\n\n<pre><code>pub static mut WON_TABLE: &amp;'static mut [u8] = &amp;mut [0; 1000];\n</code></pre>\n\n<p>I hope this answer is useful to people who have similar problems in the future. If anyone else can expand on this, it'd be great! :D</p>\n"}], "owner": {"reputation": 4156, "user_id": 3072896, "user_type": "registered", "accept_rate": 77, "profile_image": "https://i.stack.imgur.com/WWVXA.png?s=128&g=1", "display_name": "Joe Thomas", "link": "https://stackoverflow.com/users/3072896/joe-thomas"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 1143, "favorite_count": 0, "answer_count": 1, "score": 3, "last_activity_date": 1480172405, "creation_date": 1480153667, "last_edit_date": 1480172405, "question_id": 40816995, "link": "https://stackoverflow.com/questions/40816995/static-mutable-array-not-working-in-rust", "title": "Static mutable array not working in Rust", "body": "<p>I have a global static array that I declared as a lookup table in Rust. For some odd reason I can't assign values to elements. It looks like this:</p>\n\n<pre><code>pub static mut WON_TABLE: &amp;'static [u8] = &amp;[0; 1000];\n\nfn main () {\n    for mov in 0..1000 {\n        unsafe {\n            WON_TABLE[mov as usize] = some_analyzer_function(mov);\n        }\n    }\n}\n</code></pre>\n\n<p>For some reason this doesn't work and I keep getting the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error: cannot assign to immutable indexed content\n</code></pre>\n\n<p>Does anyone know why this is going on?</p>\n"}, {"tags": ["rust"], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480173133, "post_id": 40816703, "comment_id": 68858618, "body": "This answer is correct, but there <i>are</i> times where you&#39;d want to use <code>!</code> as a type. Further reading: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1216-bang-type.md\" rel=\"nofollow noreferrer\">RFC 1216</a> and the corresponding <a href=\"https://github.com/rust-lang/rust/issues/35121\" rel=\"nofollow noreferrer\">tracking issue</a>."}, {"owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480183037, "post_id": 40816703, "comment_id": 68861702, "body": "Note I didn&#39;t say <code>!</code> is unusable, only the struct isn&#39;t very useful (though it could be used to signal that code is never executed like <code>!</code> itself). I actually do like RFC 1216."}], "tags": [], "owner": {"reputation": 51497, "user_id": 49246, "user_type": "registered", "accept_rate": 73, "profile_image": "https://www.gravatar.com/avatar/c421b43470bb8d3c099c5a847e588549?s=128&d=identicon&r=PG", "display_name": "starblue", "link": "https://stackoverflow.com/users/49246/starblue"}, "is_accepted": true, "score": 5, "last_activity_date": 1480182436, "last_edit_date": 1480182436, "creation_date": 1480151176, "answer_id": 40816703, "question_id": 40815965, "link": "https://stackoverflow.com/questions/40815965/how-do-i-specify-a-generic-type-where-one-of-the-types-is-not-needed/40816703#40816703", "title": "How do I specify a generic type where one of the types is not needed?", "body": "<p><code>()</code> is the right choice.  It is a type with a single value (also named <code>()</code>), so it has a value, but contains no information.</p>\n\n<p><code>!</code> doesn't have any value, so if you put it in a struct the struct type doesn't have a value either and is basically unusable.</p>\n"}], "owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 196, "favorite_count": 0, "accepted_answer_id": 40816703, "answer_count": 1, "score": 4, "last_activity_date": 1480182436, "creation_date": 1480144759, "last_edit_date": 1480171819, "question_id": 40815965, "link": "https://stackoverflow.com/questions/40815965/how-do-i-specify-a-generic-type-where-one-of-the-types-is-not-needed", "title": "How do I specify a generic type where one of the types is not needed?", "body": "<p>I'm trying to use a generic datatype where one of the types is not needed (edge weights in a graph). I've been thinking to use the never type for this, which would look something like this:</p>\n\n<pre><code>#![feature(never_type)]\n\nstruct Foo&lt;T&gt; {\n    bar: T\n}\n\nimpl&lt;T&gt; Foo&lt;T&gt; {\n    fn foo(&amp;mut self, bar: T) {\n        self.bar = bar;\n    }\n}\n\nfn main() {\n    let mut foo: Foo&lt;!&gt; = Foo { bar: \"nada\" };\n    foo.foo(\"nada\");\n}\n</code></pre>\n\n<p>This obviously results in a type-mismatch for the <code>\"nada\"</code> placeholders, but just typing nothing will cause other errors. Is <code>!</code> the right type to use here, and if so, what's the correct syntax?</p>\n\n<p>I've gotten it to work using <code>()</code> instead of <code>!</code>, but I'm a bit unsure as to whether that's the proper choice of type. I believe in terms of efficiency it should make no difference, as <code>()</code> has no memory footprint?</p>\n"}, {"tags": ["rust", "closures", "borrow-checker", "borrowing"], "comments": [{"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 0, "creation_date": 1480152779, "post_id": 40814832, "comment_id": 68853436, "body": "Can you please provide a complete compilable (even with an error) example, preferably which will work on play.rust-lang.org?  It would be easier to be sure what error you&#39;re getting and where, and to suggest a fix."}], "answers": [{"comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 1, "creation_date": 1480172264, "post_id": 40817756, "comment_id": 68858354, "body": "Said another way, <code>Point</code> does not implement <a href=\"https://doc.rust-lang.org/std/marker/trait.Copy.html\" rel=\"nofollow noreferrer\"><code>Copy</code></a>. You could also use a temporary variable - <code>.map(|point| { let d = point.distance_to(&amp;origin); (point, d) })</code>."}], "tags": [], "owner": {"reputation": 988, "user_id": 6090592, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/3d5e40fcf8c369f36d04406528df52f2?s=128&d=identicon&r=PG&f=1", "display_name": "Djzin", "link": "https://stackoverflow.com/users/6090592/djzin"}, "is_accepted": true, "score": 1, "last_activity_date": 1480172152, "last_edit_date": 1480172152, "creation_date": 1480158830, "answer_id": 40817756, "question_id": 40814832, "link": "https://stackoverflow.com/questions/40814832/reuse-binding-in-rust-closure/40817756#40817756", "title": "Reuse binding in Rust closure", "body": "<p>I am presuming your <code>Point</code> struct looks like the following:</p>\n\n<pre><code>#[derive(Debug)]\nstruct Point(f64, f64);\n\nimpl Point {\n    fn new(x: f64, y: f64) -&gt; Self { Point(x, y) }\n    fn origin() -&gt; Self { Point(0.,0.) }\n    fn distance_to(&amp;self, other: &amp;Point) -&gt; f64 {\n        ((other.0 - self.0).powi(2) + (other.1 - self.1).powi(2)).sqrt()\n    }\n}\n</code></pre>\n\n<p>Now let's look at an even simpler example that will not compile:</p>\n\n<pre><code>let x = Point::new(2.5, 1.0);\nlet y = x;\nlet d = x.distance_to(&amp;y);\n</code></pre>\n\n<p>Which gives the error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0382]: use of moved value: `x`\n  --&gt; &lt;anon&gt;:15:13\n   |\n14 |     let y = x;\n   |         - value moved here\n15 |     let d = x.distance_to(&amp;y);\n   |             ^ value used here after move\n   |\n   = note: move occurs because `x` has type `Point`, which does not implement the `Copy` trait\n</code></pre>\n\n<p>Because <code>x</code> has been moved into <code>y</code>, it now can't have a reference taken in order to call the <code>distance_to</code> function.</p>\n\n<p>The important thing to note here is that order matters - if we swap the lines over we can call <code>distance_to</code> by borrowing <code>x</code>, the borrow will end and <em>then</em> <code>x</code> can be moved into <code>y</code>.</p>\n\n<pre><code>let x = Point(0., 0.);\nlet d = x.distance_to(&amp;y);\nlet y = x; // compiles\n</code></pre>\n\n<p>In your case, a very similar thing is happening when constructing the tuple. <code>point</code> gets moved into the tuple, and <em>then</em> tries to borrow it to form the second element. The simplest solution is to do the same thing as here: swap the order of the elements of the tuple.</p>\n\n<pre><code>let points_and_distances = points_in_grid\n    .map(|point| (point.distance_to(&amp;origin), point))\n    .collect::&lt;Vec&lt;(f64, Point)&gt;&gt;(); // compiles\n</code></pre>\n\n<p><a href=\"https://play.rust-lang.org/?gist=3b8ecd52fb0e1b7bee3b0b7ce89f539f&amp;version=stable&amp;backtrace=1\" rel=\"nofollow noreferrer\">Playground link</a></p>\n\n<p>N.B. if you want to retain the order:</p>\n\n<pre><code>.map(|(a, b)| (b, a))\n</code></pre>\n"}], "owner": {"reputation": 157, "user_id": 3342240, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/a7176b48e45597d3a8a206e2f358f497?s=128&d=identicon&r=PG&f=1", "display_name": "davenportw15", "link": "https://stackoverflow.com/users/3342240/davenportw15"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 201, "favorite_count": 0, "accepted_answer_id": 40817756, "answer_count": 1, "score": 1, "last_activity_date": 1480172152, "creation_date": 1480133487, "last_edit_date": 1480172111, "question_id": 40814832, "link": "https://stackoverflow.com/questions/40814832/reuse-binding-in-rust-closure", "title": "Reuse binding in Rust closure", "body": "<p>I am attempting to generate a <code>Vec&lt;(Point, f64)&gt;</code>:</p>\n\n<pre><code>let grid_size = 5;\n\nlet points_in_grid = (0..grid_size).flat_map(|x| {\n    (0..grid_size)\n        .map(|y| Point::new(f64::from(x), f64::from(y)))\n        .collect::&lt;Vec&lt;Point&gt;&gt;()\n});\n\nlet origin = Point::origin();\n\nlet points_and_distances = points_in_grid\n    .map(|point| (point, point.distance_to(&amp;origin)))\n    .collect::&lt;Vec&lt;(Point, f64)&gt;&gt;();\n</code></pre>\n\n<p>I get the following error: </p>\n\n<pre class=\"lang-none prettyprint-override\"><code>use of moved value: point\n</code></pre>\n\n<p>I understand that I cannot use <code>point</code> in both elements of the tuple, but when I attempt to store a reference, I get an error regarding lifetime.</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480130216, "post_id": 40814524, "comment_id": 68849302, "body": "Idiomatic Rust would have the function body be just <code>self.data.iter().map(|&amp;x| x)</code> \u2014 no <code>return</code>, no <code>;</code>."}], "answers": [{"comments": [{"owner": {"reputation": 7096, "user_id": 3990767, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/0a5741a212e3b0e6bd46a8a1e6d76a4a?s=128&d=identicon&r=PG", "display_name": "SOFe", "link": "https://stackoverflow.com/users/3990767/sofe"}, "edited": false, "score": 2, "creation_date": 1568596867, "post_id": 40814572, "comment_id": 102311536, "body": "None of the linked &quot;duplicates&quot; appear to cover the case of implementing a trait."}, {"owner": {"reputation": 5038, "user_id": 3579309, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/Wn5ES.jpg?s=128&g=1", "display_name": "lovasoa", "link": "https://stackoverflow.com/users/3579309/lovasoa"}, "edited": false, "score": 0, "creation_date": 1616949995, "post_id": 40814572, "comment_id": 118156881, "body": "The linked questions are about letting rust infer the return type of functions, which is not the same thing. The opinionated part of the response about Haskell is not quite appropriate in this context either. Actually rust is now working on implementing what the original poster wanted: <a href=\"https://github.com/rust-lang/rust/issues/63063\" rel=\"nofollow noreferrer\">github.com/rust-lang/rust/issues/63063</a>"}], "tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 2, "last_activity_date": 1480130488, "last_edit_date": 1495541233, "creation_date": 1480130178, "answer_id": 40814572, "question_id": 40814524, "link": "https://stackoverflow.com/questions/40814524/is-there-a-way-to-let-rust-infer-the-correct-type-for-an-associated-type/40814572#40814572", "title": "Is there a way to let Rust infer the correct type for an associated type?", "body": "<blockquote>\n  <p>Is there a way to let Rust derive the correct type for <code>WrapperIterator</code>?</p>\n</blockquote>\n\n<p>No. In fact, this is directly the opposite of what Rust does. You annotate function argument and return types, then the compiler can infer the types <em>inside</em> the method based on that.</p>\n\n<p>Inferring top-level types from the body of the method leads to terrible error messages that occur far away from the location that caused them. Haskell learned this the hard way, and now advocates that all top-level functions have explicit type signatures. Rust chose to never go down that path. See also <a href=\"https://stackoverflow.com/a/31612025/155423\">this answer</a>; while it talks about lifetimes, many of the same points hold.</p>\n\n<p>Your unasked question (how do I return this iterator) already has many duplicates:</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/q/25445761/155423\">Returning a closure from a function</a></li>\n<li><a href=\"https://stackoverflow.com/q/27535289/155423\">Correct way to return an Iterator?</a></li>\n<li><a href=\"https://stackoverflow.com/q/31904842/155423\">Return a map iterator which is using a closure in Rust</a></li>\n</ul>\n\n<p>Thank you for <em>not</em> asking yet another exact duplicate.</p>\n"}, {"tags": [], "owner": {"reputation": 5038, "user_id": 3579309, "user_type": "registered", "accept_rate": 70, "profile_image": "https://i.stack.imgur.com/Wn5ES.jpg?s=128&g=1", "display_name": "lovasoa", "link": "https://stackoverflow.com/users/3579309/lovasoa"}, "is_accepted": false, "score": 0, "last_activity_date": 1616951638, "last_edit_date": 1616951638, "creation_date": 1616950724, "answer_id": 66843936, "question_id": 40814524, "link": "https://stackoverflow.com/questions/40814524/is-there-a-way-to-let-rust-infer-the-correct-type-for-an-associated-type/66843936#66843936", "title": "Is there a way to let Rust infer the correct type for an associated type?", "body": "<p>Unfortunately, this is not yet possible in stable rust, but there is <a href=\"https://github.com/rust-lang/rust/issues/63063\" rel=\"nofollow noreferrer\">a plan</a> to introduce this feature. If you want to try the (currently unstable) feature, you can do so on rust nightly with <code>#![feature(min_type_alias_impl_trait)]</code>. You will have to add a type parameter to your trait :</p>\n<pre class=\"lang-rust prettyprint-override\"><code>#![feature(min_type_alias_impl_trait)]\n\ntrait WrapperTrait&lt;'a&gt; {\n    type WrapperIterator: Iterator&lt;Item = u32&gt; + 'a;\n    fn iter(&amp;'a self) -&gt; Self::WrapperIterator;\n}\n\nstruct Wrapper {\n    data: Vec&lt;u32&gt;,\n}\n\nimpl&lt;'a&gt; WrapperTrait&lt;'a&gt; for Wrapper {\n    type WrapperIterator = impl Iterator&lt;Item = u32&gt; + 'a;\n    fn iter(&amp;'a self) -&gt; Self::WrapperIterator {\n        self.data.iter().map(|&amp;x| x)\n    }\n}\n</code></pre>\n<p>playground link: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=a9434bcd32ea9c910fd0f9e329d17bd5\" rel=\"nofollow noreferrer\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=a9434bcd32ea9c910fd0f9e329d17bd5</a></p>\n<p>To do it without adding a lifetime parameter to the trait, one needs yet another unstable rust feature: Generic Associated Types.</p>\n<pre class=\"lang-rust prettyprint-override\"><code>#![feature(min_type_alias_impl_trait)]\n#![feature(generic_associated_types)]\n\ntrait WrapperTrait {\n    type WrapperIterator&lt;'a&gt;: Iterator&lt;Item = u32&gt;;\n    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::WrapperIterator&lt;'a&gt;;\n}\n\nstruct Wrapper {\n    data: Vec&lt;u32&gt;,\n}\n\nimpl WrapperTrait for Wrapper {\n    type WrapperIterator&lt;'a&gt; = impl Iterator&lt;Item = u32&gt;;\n    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::WrapperIterator&lt;'a&gt;{\n        self.data.iter().map(|&amp;x| x)\n    }\n}\n</code></pre>\n<p>playground: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=049c875b27a0e9e472d854e6218df267\" rel=\"nofollow noreferrer\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=049c875b27a0e9e472d854e6218df267</a></p>\n"}], "owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 892, "favorite_count": 0, "accepted_answer_id": 40814572, "answer_count": 2, "score": 5, "last_activity_date": 1616951638, "creation_date": 1480129512, "last_edit_date": 1480130827, "question_id": 40814524, "link": "https://stackoverflow.com/questions/40814524/is-there-a-way-to-let-rust-infer-the-correct-type-for-an-associated-type", "title": "Is there a way to let Rust infer the correct type for an associated type?", "body": "<p>I'm trying to create a trait which includes functions that return an iterator over some internal data, which can then be implemented by different structs. A minimal example is as follows:</p>\n\n<pre><code>trait WrapperTrait {\n    type WrapperIterator: Iterator&lt;Item=u32&gt;;\n    fn iter(&amp;self) -&gt; Self::WrapperIterator;\n}\nstruct Wrapper {\n    data: Vec&lt;u32&gt;\n}\nimpl WrapperTrait for Wrapper {\n    type WrapperIterator = ...;\n    fn iter(&amp;self) -&gt; Self::WrapperIterator {\n        return self.data.iter().map(|&amp;x| x);\n    }\n}\n</code></pre>\n\n<p>However, the type for <code>WrapperIterator</code> is rather complex - from an error message (created via type mismatch) I find it to be:</p>\n\n<pre><code>std::iter::Map&lt;std::slice::Iter&lt;'_, u32&gt;, [closure@borrow.rs:45:37: 45:43]&gt;\n</code></pre>\n\n<p>Is there a way to let Rust infer the correct type for <code>WrapperIterator</code>?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480123809, "post_id": 40813959, "comment_id": 68848391, "body": "Do you understand <a href=\"https://doc.rust-lang.org/stable/book/references-and-borrowing.html\" rel=\"nofollow noreferrer\"><i>what references are</i></a>? Do you understand how <a href=\"https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter\" rel=\"nofollow noreferrer\"><code>BTreeMap::iter</code></a> works? IMO, the error message is pretty straightforward \u2014 you&#39;ve said you are going to return one thing but you returned something else. What piece of information is missing that we can further clarify?"}, {"owner": {"reputation": 5520, "user_id": 2128319, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/be88209d2b01753efb0b1d43eff9bbfe?s=128&d=identicon&r=PG", "display_name": "neverfox", "link": "https://stackoverflow.com/users/2128319/neverfox"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480133624, "post_id": 40813959, "comment_id": 68849721, "body": "I didn&#39;t say I didn&#39;t understand the error message. What I don&#39;t understand is <i>why</i> what I&#39;ve written results in <code>Split&lt;&#39;_, &amp;K, &amp;V&gt;</code>. If it has to do with a subtlety that comes with using an iterator then, yes, that&#39;s beyond my level of Rust knowledge, and I would appreciate some insight. The best I was able to do before coming here was check that return types of everything but nothing indicates references would come into play. So somehow the compiler feels compelled out of some requirement to do this and I&#39;d like to understand why and how I can get what I want, if that&#39;s possible."}], "answers": [{"comments": [{"owner": {"reputation": 5520, "user_id": 2128319, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/be88209d2b01753efb0b1d43eff9bbfe?s=128&d=identicon&r=PG", "display_name": "neverfox", "link": "https://stackoverflow.com/users/2128319/neverfox"}, "edited": false, "score": 0, "creation_date": 1480180016, "post_id": 40816856, "comment_id": 68860703, "body": "Thanks for the clear explanation and for pointing towards a possible solution. You&#39;re right that it does make sense. I did check around for types in all the various methods I was using but I was misled by the docs saying <code>fn iter(&amp;self) -&gt; Iter&lt;K, V&gt;</code> so I was scratching my head. Now I know where I should have been looking."}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 5520, "user_id": 2128319, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/be88209d2b01753efb0b1d43eff9bbfe?s=128&d=identicon&r=PG", "display_name": "neverfox", "link": "https://stackoverflow.com/users/2128319/neverfox"}, "edited": false, "score": 1, "creation_date": 1480180378, "post_id": 40816856, "comment_id": 68860833, "body": "I do a lot of clicking through types in the online documentation! You learn all sorts of things."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 2, "last_activity_date": 1480171872, "last_edit_date": 1480171872, "creation_date": 1480152533, "answer_id": 40816856, "question_id": 40813959, "link": "https://stackoverflow.com/questions/40813959/mismatched-types-for-returned-struct-expected-k-v-found-k-v/40816856#40816856", "title": "Mismatched types for returned struct (expected &lt;K, V&gt;, found &lt;&amp;K, &amp;V&gt;)", "body": "<p>The references come from where you iterate on the child to build a new <code>BTreeMap</code>:</p>\n\n<pre><code>BTreeMap::from_iter(self.children.iter().take(data_b))\n</code></pre>\n\n<p>If you look at the <a href=\"https://doc.rust-lang.org/1.13.0/collections/btree_map/struct.Iter.html\" rel=\"nofollow noreferrer\">iterator returned by <code>BTreeMap::iter()</code></a>, the <code>Item</code> type is:</p>\n\n<pre><code>type Item = (&amp;'a K, &amp;'a V)\n</code></pre>\n\n<p>i.e. the iterator returns pairs of references to the contents.  This makes sense, because you don't want to move items out of the map when iterating, or rely on <code>Copy</code>.</p>\n\n<p>This is slightly different from e.g. <code>Vec::iter()</code>, being a pair of references rather than a reference to a pair.  This does make sense, as a reference to a pair would mean the container would have to actually contain those pairs internally (restricting the internal data structure).</p>\n\n<p>The simplest thing is to clone the key and value:</p>\n\n<pre><code>BTreeMap::from_iter(self.children.iter()\n                                 .map(|(&amp;a, &amp;b)| (a.clone(), b.clone()))\n                                 .take(data_b))\n</code></pre>\n"}], "owner": {"reputation": 5520, "user_id": 2128319, "user_type": "registered", "accept_rate": 70, "profile_image": "https://www.gravatar.com/avatar/be88209d2b01753efb0b1d43eff9bbfe?s=128&d=identicon&r=PG", "display_name": "neverfox", "link": "https://stackoverflow.com/users/2128319/neverfox"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 101, "favorite_count": 0, "accepted_answer_id": 40816856, "answer_count": 1, "score": 0, "last_activity_date": 1480171872, "creation_date": 1480122144, "last_edit_date": 1480135487, "question_id": 40813959, "link": "https://stackoverflow.com/questions/40813959/mismatched-types-for-returned-struct-expected-k-v-found-k-v", "title": "Mismatched types for returned struct (expected &lt;K, V&gt;, found &lt;&amp;K, &amp;V&gt;)", "body": "<p>Given the following code (which doesn't do much yet):</p>\n\n<pre><code>use std::collections::BTreeMap;\nuse std::iter::FromIterator;\n\ntrait Node&lt;K, V&gt; {\n    fn split(&amp;self) -&gt; Split&lt;K, V&gt;;\n}\n\n#[derive(Debug, Copy, Clone)]\npub struct Config {\n    data_b: usize,\n}\n\nstruct Split&lt;'a, K, V&gt; {\n    left: Box&lt;Node&lt;K, V&gt; + 'a&gt;,\n    right: Box&lt;Node&lt;K, V&gt; + 'a&gt;,\n}\n\n#[derive(Debug)]\npub struct DataNode&lt;K, V&gt; {\n    cfg: Config,\n    children: BTreeMap&lt;K, V&gt;,\n}\n\nimpl&lt;K: Clone + Ord, V: Clone&gt; Node&lt;K, V&gt; for DataNode&lt;K, V&gt; {\n    fn split(&amp;self) -&gt; Split&lt;K, V&gt; {\n        let data_b = self.cfg.data_b;\n\n        Split {\n            left: Box::new(DataNode {\n                cfg: self.cfg.clone(),\n                children: BTreeMap::from_iter(self.children.iter().take(data_b))\n            }),\n            right: Box::new(DataNode {\n                cfg: self.cfg.clone(),\n                children: BTreeMap::from_iter(self.children.iter().rev().take(data_b))\n            }),\n        }\n    }\n}\n</code></pre>\n\n<p>The compiler gives the following error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>error[E0308]: mismatched types\n  --&gt; lib.rs:68:9\n   |\n68 |         Split {\n   |         ^ expected type parameter, found &amp;K\n   |\n   = note: expected type `Split&lt;'_, K, V&gt;`\n   = note:    found type `Split&lt;'_, &amp;K, &amp;V&gt;`\n</code></pre>\n\n<p>I'm pretty new to Rust so I'm not sure what's causing this. To be absolutely clear, the question I'm having is <em>not</em> about what the error message <em>means</em>. Clearly, it means that I'm not returning the right type. The question is <em>why</em> does the compiler interpret this <code>Split {...}</code> code as code that returns <code>Split&lt;'_, &amp;K, &amp;V&gt;</code> when I expect it to be <code>Split&lt;'_, K, V&gt;</code>. Any insight is appreciated.</p>\n"}, {"tags": ["module", "rust", "constants"], "answers": [{"tags": [], "owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "is_accepted": true, "score": 1, "last_activity_date": 1480120819, "last_edit_date": 1495542651, "creation_date": 1480120819, "answer_id": 40813873, "question_id": 40813812, "link": "https://stackoverflow.com/questions/40813812/using-a-module-from-the-standard-library-works-in-my-crate-root-but-not-in-a-mo/40813873#40813873", "title": "Using a module from the standard library works in my crate root, but not in a module", "body": "<p>No need for separate files; here's a reproduction:</p>\n\n<pre><code>fn main() {}\n\nmod bar {\n    fn foo() {\n        println!(\"{}\", std::f64::NEG_INFINITY);\n    }\n}\n</code></pre>\n\n<p>At the root of your crate, the <code>std</code> crate has been automatically imported as part of <a href=\"https://stackoverflow.com/q/36384840/155423\">the prelude</a>. That inserts the <em>path</em> <code>std</code> starting from the root.</p>\n\n<p>Once you start writing code in a module, however, you are no longer at the root, and when you try to make use of an item, paths are relative by default. Thus, inside of <code>mod bar</code>, the path <code>std::f64::NEG_INFINITY</code> would be the absolute path <code>::bar::std::f64::NEG_INFINITY</code>, which doesn't exist.</p>\n\n<p>You can solve this in two main ways:</p>\n\n<ol>\n<li><p>Bring the path into scope by using the <code>use std;</code> statement. Note that <em>this</em> statement uses absolute paths by default, so <em>this</em> <code>std</code> is <code>::std</code>.</p></li>\n<li><p>Provide an absolute path at each usage: <code>println!(\"{}\", ::std::f64::NEG_INFINITY)</code>.</p></li>\n</ol>\n"}], "owner": {"reputation": 1498, "user_id": 6844327, "user_type": "registered", "accept_rate": 100, "profile_image": "https://i.stack.imgur.com/9fWJl.jpg?s=128&g=1", "display_name": "HiDefender", "link": "https://stackoverflow.com/users/6844327/hidefender"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 61, "favorite_count": 0, "accepted_answer_id": 40813873, "answer_count": 1, "score": 1, "last_activity_date": 1480120872, "creation_date": 1480120089, "last_edit_date": 1480120872, "question_id": 40813812, "link": "https://stackoverflow.com/questions/40813812/using-a-module-from-the-standard-library-works-in-my-crate-root-but-not-in-a-mo", "title": "Using a module from the standard library works in my crate root, but not in a module", "body": "<p>I can reference <code>std::f64::NEG_INFINITY</code> in my <code>main.rs</code> and there is no problem. However, if another module references the same constant, the compiler complains: <code>Use of undeclared type or module 'std::f64'</code>.</p>\n\n<p>Here is my <code>main.rs</code>:</p>\n\n<pre><code>mod bar;\n\nfn main() {\n    println!(\"{}\", std::f64::NEG_INFINITY);\n}\n</code></pre>\n\n<p>Here is my <code>bar.rs</code>:</p>\n\n<pre><code>fn foo() {\n    println!(\"{}\", std::f64::NEG_INFINITY);\n}\n</code></pre>\n\n<p><code>main.rs</code> and <code>bar.rs</code> are in the same folder.</p>\n\n<p>What am I doing wrong?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480112823, "post_id": 40810408, "comment_id": 68846083, "body": "I would suggest that you re-read <a href=\"https://doc.rust-lang.org/stable/book/references-and-borrowing.html#the-rules\" rel=\"nofollow noreferrer\"><i>The Rust Programming Language</i> chapter on references</a>. It is <i>vitally</i> important that you understand the restriction on mutable aliasing."}], "answers": [{"tags": [], "owner": {"reputation": 14451, "user_id": 33499, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/17c590aa4c56918b47c7ba5e39dba5d8?s=128&d=identicon&r=PG", "display_name": "wimh", "link": "https://stackoverflow.com/users/33499/wimh"}, "is_accepted": true, "score": 9, "last_activity_date": 1480099654, "creation_date": 1480099654, "answer_id": 40810883, "question_id": 40810408, "link": "https://stackoverflow.com/questions/40810408/how-to-clone-struct-with-a-mutable-reference/40810883#40810883", "title": "How to clone struct with a mutable reference", "body": "<p>It is possible to have <a href=\"https://doc.rust-lang.org/book/references-and-borrowing.html#the-rules\" rel=\"noreferrer\">multiple non-mutable references</a> to the same resource. So in the code which compiles, you will get two references to the same <code>MyStruct</code> when <code>MyStruct2</code> is cloned.:</p>\n\n<pre><code>#[derive(Clone)]\nstruct MyStruct {\n    val: usize,\n}\n\n#[derive(Clone)]\nstruct MyStruct2&lt;'a&gt; {\n    struct_reference: &amp;'a MyStruct\n}\n</code></pre>\n\n<p>However, it is only possible to have a single mutable reference to a resource. So it is not possible to automatically implement <code>Clone</code> for <code>MyStruct2</code>. You can implement it yourself, it will look like this:</p>\n\n<pre><code>impl&lt;'a&gt; Clone for MyStruct2&lt;'a&gt; {\n    fn clone(&amp;self) -&gt; MyStruct2&lt;'a&gt; {\n        // your code here\n    }\n}\n</code></pre>\n\n<p>But you still can't have two mutable references to the same <code>MyStruct</code>. \nYou also can't create a clone of <code>MyStruct</code> which lives long enough to return in the clone function. So you would have to modify your data structure to make this possible.</p>\n"}], "owner": {"reputation": 353, "user_id": 4522084, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/ccc498c02064892dab4d728d460a741b?s=128&d=identicon&r=PG&f=1", "display_name": "pdiffley", "link": "https://stackoverflow.com/users/4522084/pdiffley"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 2480, "favorite_count": 0, "accepted_answer_id": 40810883, "answer_count": 1, "score": 4, "last_activity_date": 1480112896, "creation_date": 1480097016, "last_edit_date": 1480112896, "question_id": 40810408, "link": "https://stackoverflow.com/questions/40810408/how-to-clone-struct-with-a-mutable-reference", "title": "How to clone struct with a mutable reference", "body": "<p>I have a struct containing a mutable reference (<code>MyStruct2</code>) that I need to clone, so I derived the <code>Clone</code> method for that struct:</p>\n\n<pre><code>#[derive(Clone)]\nstruct MyStruct {\n    val: usize,\n}\n\n#[derive(Clone)]\nstruct MyStruct2&lt;'a&gt; {\n    struct_reference: &amp;'a mut MyStruct\n}\n</code></pre>\n\n<p>However, when I compile this code, I get the following error message:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>src/main.rs:419:3: 419:37 error: the trait `core::clone::Clone` is not implemented for the type `&amp;mut MyStruct` [E0277]\nsrc/main.rs:419         struct_reference: &amp;'a mut MyStruct\n                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/main.rs:417:11: 417:16 note: in this expansion of #[derive_Clone] (defined in src/main.rs)\nsrc/main.rs:419:3: 419:37 help: run `rustc --explain E0277` to see a detailed explanation\nsrc/main.rs:419:3: 419:37 help: the following implementations were found:\nsrc/main.rs:419:3: 419:37 help:   &lt;MyStruct as core::clone::Clone&gt;\nsrc/main.rs:419:3: 419:37 note: required by `core::clone::Clone::clone`\nerror: aborting due to previous error\n</code></pre>\n\n<p>If I make the reference immutable, then the code compiles.</p>\n\n<pre><code>#[derive(Clone)]\nstruct MyStruct {\n    val: usize,\n}\n\n#[derive(Clone)]\nstruct MyStruct2&lt;'a&gt; {\n    struct_reference: &amp;'a MyStruct\n}\n</code></pre>\n\n<p>It seems that even though clone is derived for the struct <code>MyStruct</code>, it is not derived for a mutable reference to <code>MyStruct</code>.</p>\n\n<p>Is there a way to clone a mutable reference to a struct and to clone a struct containing a mutable reference?</p>\n"}, {"tags": ["multithreading", "rust"], "answers": [{"comments": [{"owner": {"reputation": 111, "user_id": 6940553, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dc5bc23aacbf15cbb492bf854c4fbdab?s=128&d=identicon&r=PG&f=1", "display_name": "Steve", "link": "https://stackoverflow.com/users/6940553/steve"}, "edited": false, "score": 0, "creation_date": 1480071324, "post_id": 40802672, "comment_id": 68827474, "body": "Thanks. How did you find the concrete type? The websocket API documentation did not mention it."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 0, "last_activity_date": 1480085413, "last_edit_date": 1480085413, "creation_date": 1480069420, "answer_id": 40802672, "question_id": 40798945, "link": "https://stackoverflow.com/questions/40798945/avoiding-closure-encapsulating-thread-variables-in-a-struct/40802672#40802672", "title": "Avoiding closure - encapsulating thread variables in a struct", "body": "<p>The error is telling you the immediate problem:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>46 |         sender:Sender,\n   |         ^^^^^^^^^^^^^ the trait `websocket::Sender` cannot be made into an object\n</code></pre>\n\n<p>First of all, a variable/field can't have a plain trait type (but <code>&amp;Trait</code> can be possible), but also the <code>websocket::Sender</code> trait is not <a href=\"http://huonw.github.io/blog/2015/01/object-safety/\" rel=\"nofollow noreferrer\">object safe</a>; it has generic methods which can't work dynamically (ie vtable methods have to have a fixed type).</p>\n\n<p>Instead, you have to have a concrete type (you could also make it a generic struct).</p>\n\n<p>It's not obvious what the right type is, so I like to get the compiler to tell me.  So first try the simplest possible:</p>\n\n<pre><code>    sender: (),\n</code></pre>\n\n<p>The compiler replies with some information:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>|                       ^^^^^^ expected (), found struct `websocket::client::Sender`\n</code></pre>\n\n<p>Ok, let's plug that in:</p>\n\n<pre><code>    sender: websocket::client::Sender,\n</code></pre>\n\n<p>That gives:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>46 |         sender: websocket::client::Sender,\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 type arguments, found 0\n</code></pre>\n\n<p>Ok, that's a generic type.  Next try:</p>\n\n<pre><code>    sender: websocket::client::Sender&lt;()&gt;,\n</code></pre>\n\n<p>Finally it gives us the real type:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>74 |                sender:sender,\n   |                       ^^^^^^ expected (), found enum `websocket::WebSocketStream`\n</code></pre>\n\n<p>So finally we can finish <code>SocketWriter</code>:</p>\n\n<pre><code>struct SocketWriter {\n    my_rx: mpsc::Receiver&lt;String&gt;,\n    sender: websocket::client::Sender&lt;websocket::WebSocketStream&gt;,\n}\n</code></pre>\n\n<p>There's a following compile error since the <code>connection</code> you get is a <code>Result&lt;&gt;</code> so you need to check for errors (it compiles if I change to <code>self.handshake(connection.unwrap())</code>, but that's obviously not the best practice.</p>\n"}], "owner": {"reputation": 111, "user_id": 6940553, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/dc5bc23aacbf15cbb492bf854c4fbdab?s=128&d=identicon&r=PG&f=1", "display_name": "Steve", "link": "https://stackoverflow.com/users/6940553/steve"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 103, "favorite_count": 0, "accepted_answer_id": 40802672, "answer_count": 1, "score": 0, "last_activity_date": 1480085413, "creation_date": 1480055262, "last_edit_date": 1480085358, "question_id": 40798945, "link": "https://stackoverflow.com/questions/40798945/avoiding-closure-encapsulating-thread-variables-in-a-struct", "title": "Avoiding closure - encapsulating thread variables in a struct", "body": "<p>I am writing a simple websocket server named BoltServer based on Rust websocket crate(Code is incomplete, I just started). I am using the example program as the base. However the example programs are not modular (having very long methods). So I am trying to break them up into structs and methods. I want to spawn two threads for each client. One sends messages and the other one receives messages. So here, I want to capture all variables used by the thread in a struct and then call the run method in the impl.</p>\n\n<pre><code>extern crate websocket;\nextern crate time;\nextern crate rustc_serialize;\n\npub mod ws {\n    use std::thread;\n    use std::sync::{Arc, Mutex};\n    use std::sync::mpsc;\n    use std::net::ToSocketAddrs;\n    use websocket;\n    use websocket::{Server, Message, Sender, Receiver};\n    use websocket::server::Connection;\n    use websocket::stream::WebSocketStream;\n    use std::str::from_utf8;\n\n    struct BoltUser {\n        user_id: u32,\n        my_tx: mpsc::Sender&lt;String&gt;,\n    }\n\n    struct Broadcaster {\n        my_rx: mpsc::Receiver&lt;String&gt;,\n    }\n    impl Broadcaster {\n        fn new(receiver: mpsc::Receiver&lt;String&gt;) -&gt; Broadcaster {\n            Broadcaster { my_rx: receiver }\n        }\n        fn run(self) {\n            while let Ok(msg) = self.my_rx.recv() {\n                println!(\"Broadcaster got message: {}\", msg);\n            }\n        }\n    }\n\n    struct SocketReader {}\n    impl SocketReader {\n        fn run(self) {}\n    }\n\n    struct SocketWriter {\n        my_rx: mpsc::Receiver&lt;String&gt;,\n        sender: Sender,\n    }\n    impl SocketWriter {\n        fn run(self) {\n            while let Ok(message) = self.my_rx.recv() {\n            }\n        }\n    }\n\n    pub struct BoltServer {\n        address: String,\n        connected_users: Arc&lt;Mutex&lt;Vec&lt;BoltUser&gt;&gt;&gt;,\n    }\n    impl BoltServer {\n        pub fn new(address: &amp;str) -&gt; BoltServer {\n            BoltServer {\n                address: address.to_string(),\n                connected_users: Arc::new(Mutex::new(vec![])),\n            }\n        }\n        fn handshake(&amp;mut self,\n                     connection: Connection&lt;WebSocketStream, WebSocketStream&gt;)\n                     -&gt; (SocketWriter, SocketReader) {\n            let request = connection.read_request().unwrap();\n            // println!(\"thread-&gt; Accepting request...\");\n            let response = request.accept();\n            let (mut sender, mut receiver) = response.send().unwrap().split();\n            let (user_tx, user_rx) = mpsc::channel::&lt;String&gt;();//Create a channel for writer\n            let socket_writer = SocketWriter {\n                my_rx: user_rx,\n                sender: sender,\n            };\n            let socket_reader = SocketReader {};\n            (socket_writer, socket_reader)\n        }\n        pub fn start(&amp;mut self) {\n            println!(\"Starting\");\n            let (broadcaster_tx, broadcaster_rx) = mpsc::channel::&lt;String&gt;();\n            let broadcaster = Broadcaster::new(broadcaster_rx);\n            let handle = thread::Builder::new()\n                .name(\"Broadcaster\".to_string())\n                .spawn(move || broadcaster.run());\n\n            let server = Server::bind(&amp;*self.address).unwrap();\n\n            let mut user_id: u32 = 0;\n\n            // Block and process connection request from a new client\n            for connection in server {\n                user_id = user_id + 1;//Create a new user id\n                let (socket_writer, socket_reader) = self.handshake(connection);\n                thread::Builder::new()\n                    .name(\"Socket writer\".to_string())\n                    .spawn(move || socket_writer.run());\n                thread::Builder::new()\n                    .name(\"Socket reader\".to_string())\n                    .spawn(move || socket_reader.run());\n            }\n\n            handle.unwrap().join();\n            println!(\"Finished\");\n        }\n    }\n}\n</code></pre>\n\n<p>The following code gives an idea of what I want to achieve.</p>\n\n<pre><code>// Block and process connection request from a new client\nfor connection in server {\n    user_id = user_id + 1;//Create a new user id\n    let (socket_writer, socket_reader) = self.handshake(connection);\n    thread::Builder::new().name(\"Socket writer\".to_string()).spawn(move || {\n        socket_writer.run()\n    });\n    thread::Builder::new().name(\"Socket reader\".to_string()).spawn(move || {\n        socket_reader.run()\n    });\n}\n</code></pre>\n\n<p>Here I am stuck in the handshake method. I am not able to initialize the <code>SocketWriter</code> struct with the sender that I am getting by calling the <code>split</code> method in the library. I am getting the following compilation error:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>    error[E0038]: the trait `websocket::Sender` cannot be made into an object\n  --&gt; src/lib.rs:46:9\n   |\n46 |         sender:Sender,\n   |         ^^^^^^^^^^^^^ the trait `websocket::Sender` cannot be made into an object\n   |\n   = note: method `send_dataframe` has generic type parameters\n   = note: method `send_message` has generic type parameters\n</code></pre>\n"}, {"tags": ["iterator", "rust"], "answers": [{"comments": [{"owner": {"reputation": 1356, "user_id": 4129373, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9c876091f11a4f9580e69a23ef9f7f08?s=128&d=identicon&r=PG", "display_name": "letmutx", "link": "https://stackoverflow.com/users/4129373/letmutx"}, "edited": false, "score": 0, "creation_date": 1480072113, "post_id": 40802305, "comment_id": 68827992, "body": "Thanks! Even <code>Iterator</code> is implemented on <code>List</code>, we still can&#39;t call <code>List</code> methods during iteration because <code>List</code> would be moved already, or did I get you wrong?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "reply_to_user": {"reputation": 1356, "user_id": 4129373, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9c876091f11a4f9580e69a23ef9f7f08?s=128&d=identicon&r=PG", "display_name": "letmutx", "link": "https://stackoverflow.com/users/4129373/letmutx"}, "edited": false, "score": 0, "creation_date": 1480072198, "post_id": 40802305, "comment_id": 68828049, "body": "That&#39;s true in a <code>for</code> loop, but it&#39;s also possible to use an iterator directly (calling <code>next</code>).  This isn&#39;t quite the best example of that principle."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 2, "creation_date": 1480088746, "post_id": 40802305, "comment_id": 68837642, "body": "The Iterator trait adds a lot of extension methods, so that&#39;s another reason to separate them cleanly. Maybe having a <code>.map()</code> method is awesome, but a <code>last()</code> that consumes the whole list not so much."}], "tags": [], "owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "is_accepted": true, "score": 1, "last_activity_date": 1480085026, "last_edit_date": 1480085026, "creation_date": 1480068347, "answer_id": 40802305, "question_id": 40797598, "link": "https://stackoverflow.com/questions/40797598/why-is-list-wrapped-in-intoiter/40802305#40802305", "title": "Why is List wrapped in IntoIter?", "body": "<p>Yes, technically <code>Iterator</code> could be implemented for <code>List</code> in this case.  This isn't generally true, since iterators might need different state that's not in the base container (e.g. a <code>Vec</code> iterator might need to store an index to the next item to iterate efficiently).</p>\n\n<p>One reason is that if the implementation changes in future and the <code>List</code> iterator would be better with extra state, it's possible to change the iterator struct without changing any callers.</p>\n\n<p>Another reason is that in Rust it's common to use types to narrow interfaces to reduce the chance of errors.  If you implement <code>Iterator</code> directly (and presumably <code>IntoIterator</code> to return <code>self</code>), then that leaves the possibility for the user to call other <code>List</code> methods during iteration, which is probably wrong.  Instead the iterator is a separate type, meaning that there's no possibility of someone pushing items on during iteration.  (Note that in a <code>for</code> loop it'd be hard to do this anyway due to the borrowing/move rules, but the general point is still there).</p>\n"}], "owner": {"reputation": 1356, "user_id": 4129373, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/9c876091f11a4f9580e69a23ef9f7f08?s=128&d=identicon&r=PG", "display_name": "letmutx", "link": "https://stackoverflow.com/users/4129373/letmutx"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 67, "favorite_count": 0, "accepted_answer_id": 40802305, "answer_count": 1, "score": 1, "last_activity_date": 1480085026, "creation_date": 1480047071, "question_id": 40797598, "link": "https://stackoverflow.com/questions/40797598/why-is-list-wrapped-in-intoiter", "title": "Why is List wrapped in IntoIter?", "body": "<p>In the book <a href=\"http://cglab.ca/~abeinges/blah/too-many-lists/book/\" rel=\"nofollow noreferrer\">Learning Rust With Entirely Too Many Linked Lists</a>, in the <a href=\"http://cglab.ca/~abeinges/blah/too-many-lists/book/second-into-iter.html\" rel=\"nofollow noreferrer\">implementation</a> of <code>IntoIter</code>, why is <code>List</code> wrapped in a tuple struct? Instead, <code>Iterator</code> could have been implemented for a <code>List</code>.</p>\n"}, {"tags": ["vector", "rust", "concatenation"], "comments": [{"owner": {"reputation": 239269, "user_id": 464709, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/0ab3363d257d780bd4c1f0c844b020a2?s=128&d=identicon&r=PG", "display_name": "Fr&#233;d&#233;ric Hamidi", "link": "https://stackoverflow.com/users/464709/fr%c3%a9d%c3%a9ric-hamidi"}, "edited": false, "score": 1, "creation_date": 1480013621, "post_id": 40792801, "comment_id": 68808292, "body": "Related, possible duplicate: <a href=\"http://stackoverflow.com/q/29998515/464709\">What&#39;s the idiomatic way to append a slice to a vector?</a>"}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1480014830, "post_id": 40792801, "comment_id": 68808766, "body": "The code in your question doesn&#39;t compile."}, {"owner": {"reputation": 20746, "user_id": 1233251, "user_type": "registered", "accept_rate": 90, "profile_image": "https://i.stack.imgur.com/cI9GF.png?s=128&g=1", "display_name": "E_net4 says don&#39;t copy that", "link": "https://stackoverflow.com/users/1233251/e-net4-says-dont-copy-that"}, "edited": false, "score": 1, "creation_date": 1480015586, "post_id": 40792801, "comment_id": 68809036, "body": "Can you be more specific? Do you want to produce a vector by consuming the other two, or just have an iterator over the concatenation?"}, {"owner": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 3, "creation_date": 1480019307, "post_id": 40792801, "comment_id": 68810333, "body": "What&#39;s wrong with <code>a.extend(b)</code>?"}, {"owner": {"reputation": 1161, "user_id": 1930997, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/006df319db6c5c1153eafd51dd01021e?s=128&d=identicon&r=PG", "display_name": "Dereckson", "link": "https://stackoverflow.com/users/1930997/dereckson"}, "reply_to_user": {"reputation": 102109, "user_id": 1600898, "user_type": "registered", "accept_rate": 78, "profile_image": "https://www.gravatar.com/avatar/01377f8b31f24b0265854666b29d0c03?s=128&d=identicon&r=PG", "display_name": "user4815162342", "link": "https://stackoverflow.com/users/1600898/user4815162342"}, "edited": false, "score": 0, "creation_date": 1537743155, "post_id": 40792801, "comment_id": 91883815, "body": "@user4815162342 Something not convenient with a.extend(b) is it doesn&#39;t return b, and as such ask slightly more complicated expressions in functional methods like map."}], "answers": [{"tags": [], "owner": {"reputation": 1721, "user_id": 4268862, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/daefd26c4e8c4ad64790330214dd26d1?s=128&d=identicon&r=PG", "display_name": "Lud", "link": "https://stackoverflow.com/users/4268862/lud"}, "is_accepted": true, "score": 113, "last_activity_date": 1493373089, "last_edit_date": 1493373089, "creation_date": 1480026232, "answer_id": 40795247, "question_id": 40792801, "link": "https://stackoverflow.com/questions/40792801/best-way-to-concatenate-vectors-in-rust/40795247#40795247", "title": "Best way to concatenate vectors in Rust", "body": "<p>The structure <code>std::vec::Vec</code> has method <a href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html#method.append\" rel=\"noreferrer\"><code>append()</code></a>:</p>\n\n<pre><code>fn append(&amp;mut self, other: &amp;mut Vec&lt;T&gt;)\n</code></pre>\n\n<blockquote>\n  <p>Moves all the elements of <code>other</code> into <code>Self</code>, leaving <code>other</code> empty.</p>\n</blockquote>\n\n<p>From your example, the following code will concatenate two vectors by <strong>mutating</strong> <code>a</code> and <code>b</code>: </p>\n\n<pre><code>fn main() {\n    let mut a = vec![1, 2, 3];\n    let mut b = vec![4, 5, 6];\n\n    a.append(&amp;mut b);\n\n    assert_eq!(a, [1, 2, 3, 4, 5, 6]);\n    assert_eq!(b, []);\n}\n</code></pre>\n\n<hr>\n\n<p>Alternatively, you can use <a href=\"https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod.extend\" rel=\"noreferrer\"><code>Extend::extend()</code></a> to append all elements of something that can be turned into an iterator (like <code>Vec</code>) to a given vector:</p>\n\n<pre><code>let mut a = vec![1, 2, 3];\nlet b = vec![4, 5, 6];\n\na.extend(b);\nassert_eq!(a, [1, 2, 3, 4, 5, 6]);\n// b is moved and can't be used anymore\n</code></pre>\n\n<p>Note that the vector <code>b</code> is moved instead of emptied. If your vectors contain elements that implement <a href=\"https://doc.rust-lang.org/stable/std/marker/trait.Copy.html\" rel=\"noreferrer\"><code>Copy</code></a>, you can pass an immutable reference to one vector to <code>extend()</code> instead in order to avoid the move. In that case the vector <code>b</code> is not changed:</p>\n\n<pre><code>let mut a = vec![1, 2, 3];\nlet b = vec![4, 5, 6];\n\na.extend(&amp;b);\nassert_eq!(a, [1, 2, 3, 4, 5, 6]);\nassert_eq!(b, [4, 5, 6]);\n</code></pre>\n"}, {"comments": [{"owner": {"reputation": 1694, "user_id": 2120073, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ef20c298c7ab54852752660b22d0abc4?s=128&d=identicon&r=PG", "display_name": "Damian Dziaduch", "link": "https://stackoverflow.com/users/2120073/damian-dziaduch"}, "edited": false, "score": 2, "creation_date": 1559903865, "post_id": 56490417, "comment_id": 99574167, "body": "What is the difference between consuming, cloning and coppying? I thought that there are only references (borrowing, yes?) and clones"}, {"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "reply_to_user": {"reputation": 1694, "user_id": 2120073, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/ef20c298c7ab54852752660b22d0abc4?s=128&d=identicon&r=PG", "display_name": "Damian Dziaduch", "link": "https://stackoverflow.com/users/2120073/damian-dziaduch"}, "edited": false, "score": 6, "creation_date": 1559904818, "post_id": 56490417, "comment_id": 99574607, "body": "@DamianDziaduch wow, that <b><i>broad</i></b>, you ask me to explain Rust ;) If you have experience you could understand the following: basically consume move the data so <code>a</code> and <code>b</code> are <b>not</b> available anymore, the result is free to do what it want. Reference just borrow both vector, so you need to keep their alive as long the result want to live. Clone and Copy are very close, the first one can be expensive, the second one should be cheap. They just use both vector as a source without need them latter, so the result become free to live as long as it want as well that <code>a</code> and <code>b</code>. Hope it&#39;s clear."}], "tags": [], "owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "is_accepted": false, "score": 35, "last_activity_date": 1559917154, "last_edit_date": 1559917154, "creation_date": 1559895065, "answer_id": 56490417, "question_id": 40792801, "link": "https://stackoverflow.com/questions/40792801/best-way-to-concatenate-vectors-in-rust/56490417#56490417", "title": "Best way to concatenate vectors in Rust", "body": "<blockquote>\n  <p>I can't make it in one line. <a href=\"https://stackoverflow.com/users/2120073/damian-dziaduch\">Damian Dziaduch</a></p>\n</blockquote>\n\n<p>It is possible to do it in one line by using <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain\" rel=\"noreferrer\"><code>chain()</code></a>:</p>\n\n<pre class=\"lang-rust prettyprint-override\"><code>let c: Vec&lt;i32&gt; = a.into_iter().chain(b.into_iter()).collect(); // Consumed\nlet c: Vec&lt;&amp;i32&gt; = a.iter().chain(b.iter()).collect(); // Referenced\nlet c: Vec&lt;i32&gt; = a.iter().cloned().chain(b.iter().cloned()).collect(); // Cloned\nlet c: Vec&lt;i32&gt; = a.iter().copied().chain(b.iter().copied()).collect(); // Copied\n</code></pre>\n\n<p>There are infinite ways.</p>\n"}, {"comments": [{"owner": {"reputation": 16936, "user_id": 7076153, "user_type": "registered", "accept_rate": 50, "profile_image": "https://i.stack.imgur.com/erPUC.png?s=128&g=1", "display_name": "Stargateur", "link": "https://stackoverflow.com/users/7076153/stargateur"}, "edited": false, "score": 1, "creation_date": 1605769303, "post_id": 63902932, "comment_id": 114754564, "body": "I see chain is still broken on this... that sad. your <code>bench_concat_iter_chain</code> do nothing, iterator are lazy"}], "tags": [], "owner": {"reputation": 392, "user_id": 12425329, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/SBtVX.jpg?s=128&g=1", "display_name": "Tianyi Shi", "link": "https://stackoverflow.com/users/12425329/tianyi-shi"}, "is_accepted": false, "score": 5, "last_activity_date": 1600176967, "last_edit_date": 1600176967, "creation_date": 1600176508, "answer_id": 63902932, "question_id": 40792801, "link": "https://stackoverflow.com/questions/40792801/best-way-to-concatenate-vectors-in-rust/63902932#63902932", "title": "Best way to concatenate vectors in Rust", "body": "<p>Regarding the performance, <a href=\"https://doc.rust-lang.org/std/primitive.slice.html#method.concat\" rel=\"noreferrer\"><code>slice::concat</code></a>, <code>append</code> and <code>extend</code> are about the same. If you don't need the results immediately, making it a chained iterator is the fastest; if you need to <code>collect()</code>, it is the slowest:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\n#[bench]\nfn bench_concat___init__(b: &amp;mut Bencher) {\n    b.iter(|| {\n        let mut x = vec![1i32; 100000];\n        let mut y = vec![2i32; 100000];\n    });\n}\n\n#[bench]\nfn bench_concat_append(b: &amp;mut Bencher) {\n    b.iter(|| {\n        let mut x = vec![1i32; 100000];\n        let mut y = vec![2i32; 100000];\n        x.append(&amp;mut y)\n    });\n}\n\n#[bench]\nfn bench_concat_extend(b: &amp;mut Bencher) {\n    b.iter(|| {\n        let mut x = vec![1i32; 100000];\n        let mut y = vec![2i32; 100000];\n        x.extend(y)\n    });\n}\n\n#[bench]\nfn bench_concat_concat(b: &amp;mut Bencher) {\n    b.iter(|| {\n        let mut x = vec![1i32; 100000];\n        let mut y = vec![2i32; 100000];\n        [x, y].concat()\n    });\n}\n\n#[bench]\nfn bench_concat_iter_chain(b: &amp;mut Bencher) {\n    b.iter(|| {\n        let mut x = vec![1i32; 100000];\n        let mut y = vec![2i32; 100000];\n        x.into_iter().chain(y.into_iter())\n    });\n}\n\n#[bench]\nfn bench_concat_iter_chain_collect(b: &amp;mut Bencher) {\n    b.iter(|| {\n        let mut x = vec![1i32; 100000];\n        let mut y = vec![2i32; 100000];\n        x.into_iter().chain(y.into_iter()).collect::&lt;Vec&lt;i32&gt;&gt;()\n    });\n}\n</code></pre>\n<pre><code>running 6 tests\ntest bench_concat___init__           ... bench:      27,261 ns/iter (+/- 3,129)\ntest bench_concat_append             ... bench:      52,820 ns/iter (+/- 9,243)\ntest bench_concat_concat             ... bench:      53,566 ns/iter (+/- 5,748)\ntest bench_concat_extend             ... bench:      53,920 ns/iter (+/- 7,329)\ntest bench_concat_iter_chain         ... bench:      26,901 ns/iter (+/- 1,306)\ntest bench_concat_iter_chain_collect ... bench:     190,334 ns/iter (+/- 16,107)\n</code></pre>\n"}], "owner": {"reputation": 4156, "user_id": 3072896, "user_type": "registered", "accept_rate": 77, "profile_image": "https://i.stack.imgur.com/WWVXA.png?s=128&g=1", "display_name": "Joe Thomas", "link": "https://stackoverflow.com/users/3072896/joe-thomas"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 56531, "favorite_count": 10, "accepted_answer_id": 40795247, "answer_count": 3, "score": 82, "last_activity_date": 1600176967, "creation_date": 1480012496, "last_edit_date": 1493382199, "question_id": 40792801, "link": "https://stackoverflow.com/questions/40792801/best-way-to-concatenate-vectors-in-rust", "title": "Best way to concatenate vectors in Rust", "body": "<p>Is it even possible to concatenate vectors in Rust? If so, is there an elegant way to do so? I have something like this:</p>\n\n<pre><code>let mut a = vec![1, 2, 3];\nlet b = vec![4, 5, 6];\n\nfor val in &amp;b {\n    a.push(val);\n}\n</code></pre>\n\n<p>Does anyone know of a better way?</p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1480005356, "post_id": 40791169, "comment_id": 68804707, "body": "Did you run the benchmark more than once?"}, {"owner": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1480005414, "post_id": 40791169, "comment_id": 68804736, "body": "Yes many times, same every time. Also thanks for the edit Chris, complete brain fart."}, {"owner": {"reputation": 7115, "user_id": 2347483, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/80792d6741e11aaa6bec5f80fcc30a9c?s=128&d=identicon&r=PG", "display_name": "Phylogenesis", "link": "https://stackoverflow.com/users/2347483/phylogenesis"}, "edited": false, "score": 0, "creation_date": 1480005453, "post_id": 40791169, "comment_id": 68804759, "body": "What happens if you swap the order of the tests?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1480005548, "post_id": 40791169, "comment_id": 68804804, "body": "Are you sure it&#39;s actually creating a vector and summing it at runtime rather than computing it at compile time?"}, {"owner": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "edited": false, "score": 0, "creation_date": 1480005748, "post_id": 40791169, "comment_id": 68804889, "body": "I&#39;ve tried running the tests independently(comment one out and run then swap) and I still get 9ns and 13ns. I&#39;m not certain whether it&#39;s computing at compile time or not. Does rust use a different method for a longer array?"}, {"owner": {"reputation": 10655, "user_id": 4529124, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/4P3eZ.png?s=128&g=1", "display_name": "Chris Emerson", "link": "https://stackoverflow.com/users/4529124/chris-emerson"}, "edited": false, "score": 1, "creation_date": 1480006191, "post_id": 40791169, "comment_id": 68805082, "body": "It&#39;s a shame the playground doesn&#39;t do benchmarks (for the convenient disassembly/MIR options)."}, {"owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1480006595, "post_id": 40791169, "comment_id": 68805280, "body": "@timlyo: Have you tried with an absurdly large array (like... 100,000 elements to start with)? Because if the optimizer is good, it can compute at compile-time that your sum is 0 (which is why inspecting the generated LLVM IR/assembly would be great). For reference, 9ns is 36 CPU cycles on a 4GHz processor, a 100,000 elements array cannot be added in 36 instructions, so would give away whether the compiler optimizes the sum out or not. Also, try 12, it&#39;s a multiple of 4, so more vectorization friendly than 10 or 50."}, {"owner": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "reply_to_user": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "edited": false, "score": 0, "creation_date": 1480007114, "post_id": 40791169, "comment_id": 68805524, "body": "@MatthieuM. added the results to the post, seems to be a definite sweet spot around 100"}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 1, "creation_date": 1480038153, "post_id": 40791169, "comment_id": 68815090, "body": "Your input is not black-boxed. The whole computation can be evaluated at compile time (will happen for short vecs)."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480084762, "post_id": 40791169, "comment_id": 68835411, "body": "Cannot reproduce with <code>rustc 1.15.0-nightly (ba872f270 2016-11-17)</code> \u2014 bench_10 -&gt; 2 ns/iter (+/- 0);  bench_100 -&gt; 5 ns/iter (+/- 0)."}], "owner": {"reputation": 1293, "user_id": 2249995, "user_type": "registered", "accept_rate": 100, "profile_image": "https://www.gravatar.com/avatar/7f53e653eca1eeefa2389227c066135c?s=128&d=identicon&r=PG", "display_name": "timlyo", "link": "https://stackoverflow.com/users/2249995/timlyo"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": false, "view_count": 148, "favorite_count": 0, "answer_count": 0, "score": 4, "last_activity_date": 1480084586, "creation_date": 1480005047, "last_edit_date": 1480084586, "question_id": 40791169, "link": "https://stackoverflow.com/questions/40791169/why-does-a-sum-of-a-larger-array-take-less-time", "title": "Why does a sum of a larger array take less time", "body": "<p>When <code>sum</code> is run on a vector with 100 elements it takes 9ns to complete, when run with 10 elements it takes 13ns. </p>\n\n<p>Demonstrated with the following code</p>\n\n<pre><code>#![feature(test)]\n\nextern crate test;\n\nuse test::{black_box, Bencher};\n\n#[bench]\nfn bench_10(b: &amp;mut Bencher){\n    let set: Vec&lt;u32&gt; = (0..10u32).collect();\n    b.iter(|| {\n        let result: u32 = set.iter().sum();\n        black_box(result) // So the compile doesn't optimise out function\n    })\n}\n\n#[bench]\nfn bench_100(b: &amp;mut Bencher){\n    let set: Vec&lt;u32&gt; = (0..100u32).collect();\n    b.iter(|| {\n        let result: u32 = set.iter().sum();\n        black_box(result)\n    })\n}\n</code></pre>\n\n<p>Results in this output with <code>cargo bench</code></p>\n\n<pre class=\"lang-none prettyprint-override\"><code>test sum::tests::bench_iter_10     ... bench:       13 ns/iter (+/- 1)\ntest sum::tests::bench_iter_100    ... bench:        9 ns/iter (+/- 1)\n</code></pre>\n\n<p>Some more results:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Elements | Time\n10       | 14ns\n12       | 14ns\n50       | 10ns\n80       | 11ns\n90       | 12ns\n100      | 9ns\n110      | 14ns\n120      | 13ns\n150      | 16ns\n10,000   | 913ns\n</code></pre>\n\n<p>Is there any reason behind this, or is it just something to be expected with the nightly builds? Tested with <code>rustc 1.15.0-nightly (3bf2be9ce 2016-11-22)</code></p>\n"}, {"tags": ["rust"], "comments": [{"owner": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1479980286, "post_id": 40782412, "comment_id": 68788161, "body": "Well, the most elegant way would probably be to just let <code>index</code> be <code>usize</code> - either from the beginning or later, by a shadowing <code>let</code> binding."}, {"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "reply_to_user": {"reputation": 15864, "user_id": 1870153, "user_type": "registered", "accept_rate": 88, "profile_image": "https://i.stack.imgur.com/juCKe.png?s=128&g=1", "display_name": "ljedrz", "link": "https://stackoverflow.com/users/1870153/ljedrz"}, "edited": false, "score": 0, "creation_date": 1479981325, "post_id": 40782412, "comment_id": 68788920, "body": "Don&#39;t see this as being more elegant as conversion on-the-fly. I&#39;m using plenty of different variables throughout my code, so it&#39;s not something that needs to be done only once."}, {"owner": {"reputation": 9443, "user_id": 3616050, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/yQfMD.png?s=128&g=1", "display_name": "bluss", "link": "https://stackoverflow.com/users/3616050/bluss"}, "edited": false, "score": 0, "creation_date": 1479994374, "post_id": 40782412, "comment_id": 68797921, "body": "If you implement both <code>Index&lt;usize&gt;</code> and <code>Index&lt;u32&gt;</code> for a custom data type, <code>let i = 1; foo[i]</code> becomes a type could not be inferred error."}, {"owner": {"reputation": 29662, "user_id": 432509, "user_type": "registered", "accept_rate": 47, "profile_image": "https://i.stack.imgur.com/2vl0v.png?s=128&g=1", "display_name": "ideasman42", "link": "https://stackoverflow.com/users/432509/ideasman42"}, "edited": false, "score": 0, "creation_date": 1480770606, "post_id": 40782412, "comment_id": 69106108, "body": "Possible duplicate of <a href=\"http://stackoverflow.com/questions/38888724/how-to-index-vectors-with-integer-types-besides-usize-without-explicit-cast\">How to index vectors with integer types (besides usize), without explicit cast?</a>"}], "answers": [{"comments": [{"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 0, "creation_date": 1479981106, "post_id": 40782755, "comment_id": 68788745, "body": "I&#39;m working with graphs with sometimes millions of vertices (but never more than 2^32), and for performance (particular memory usage) I prefer to store &quot;references&quot; to nodes as u32 rather than usize. So when traversing the graph I keep retrieving adjacent vertex &quot;references&quot;, which I then use to look up the actual vertex object in the Vec&lt;NodeType&gt; object. So no easy way of avoiding conversion, and I don&#39;t use iterators so much as retrieving specific elements."}, {"owner": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "reply_to_user": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 0, "creation_date": 1480084512, "post_id": 40782755, "comment_id": 68835277, "body": "@HenningKoehler sounds like you are reimplementing <a href=\"https://github.com/bluss/petgraph\" rel=\"nofollow noreferrer\">petgraph</a>."}, {"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "reply_to_user": {"reputation": 269539, "user_id": 155423, "user_type": "registered", "accept_rate": 90, "profile_image": "https://www.gravatar.com/avatar/419218774d04a581476ea1887a0921e0?s=128&d=identicon&r=PG", "display_name": "Shepmaster", "link": "https://stackoverflow.com/users/155423/shepmaster"}, "edited": false, "score": 0, "creation_date": 1480146938, "post_id": 40782755, "comment_id": 68852201, "body": "@Shepmaster that&#39;s pretty much true - mainly doing this to gain better control over the internals for improved performance (e.g. my own tarjan implementation runs 2.5 times as fast as petgraph&#39;s). Also helps me getting up to speed with rust fundamentals."}], "tags": [], "owner": {"reputation": 249985, "user_id": 147192, "user_type": "registered", "accept_rate": 80, "profile_image": "https://i.stack.imgur.com/E78Vj.png?s=128&g=1", "display_name": "Matthieu M.", "link": "https://stackoverflow.com/users/147192/matthieu-m"}, "is_accepted": false, "score": 7, "last_activity_date": 1479980544, "creation_date": 1479980544, "answer_id": 40782755, "question_id": 40782412, "link": "https://stackoverflow.com/questions/40782412/indexing-vector-by-a-32-bit-integer/40782755#40782755", "title": "Indexing vector by a 32-bit integer", "body": "<p>Without a clear use case it is difficult to recommend the best approach.</p>\n\n<p>There are basically two questions here:</p>\n\n<ul>\n<li>do you really need indexing?</li>\n<li>do you really need to use <code>u32</code> for indices?</li>\n</ul>\n\n<p>When using functional programming style, indexing is generally unnecessary as you operate on iterators instead. In this case, the fact that <code>Vec</code> only implements <code>Index</code> for <code>usize</code> really does not matter.</p>\n\n<p>If your algorithm really needs indexing, then why not use <code>usize</code>? There are many ways to convert from <code>u32</code> to <code>usize</code>, converting at the last moment possible is one possibility, but there are other sites where you could do the conversion, and if you find a chokepoint (or create it) you can get away with only a handful of conversions.</p>\n\n<p>At least, that's the YAGNI point of view.</p>\n\n<hr>\n\n<p>Personally, as a type freak, I tend to wrap things around a lot. I just like to add <em>semantic</em> information, because let's face it <code>Vec&lt;i32&gt;</code> just doesn't mean anything.</p>\n\n<p>Rust offers a simple way to create wrapper structures: <code>struct MyType(WrappedType);</code>. That's it.</p>\n\n<p>Once you have your own type, adding indexing is easy. There are several ways to add other operations:</p>\n\n<ul>\n<li>if only a few operations make sense, then adding explicitly is best.</li>\n<li>if many operations are necessary, and you do not mind exposing the fact that underneath is a <code>Vec&lt;X&gt;</code>, then you can expose it:\n\n<ul>\n<li>by making it public: <code>struct MyType(pub WrappedType);</code>, users can then call <code>.0</code> to access it.</li>\n<li>by implementing <code>AsRef</code> and <code>AsMut</code>, or creating a getter.</li>\n<li>by implementing <code>Deref</code> and <code>DerefMut</code> (which is implicit, make sure you really want to).</li>\n</ul></li>\n</ul>\n\n<p>Of course, breaking encapsulation can be annoying later, as it also prevents the maintenance of invariants, so I would consider it a last ditch solution.</p>\n"}, {"comments": [{"owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "edited": false, "score": 0, "creation_date": 1480017011, "post_id": 40788374, "comment_id": 68809487, "body": "I guess that&#39;s essentially a wrapper type - useful link though, much better if you don&#39;t have to reinvent the wheel."}], "tags": [], "owner": {"reputation": 22583, "user_id": 1103681, "user_type": "registered", "accept_rate": 56, "profile_image": "https://i.stack.imgur.com/rMUo3.png?s=128&g=1", "display_name": "oli_obk", "link": "https://stackoverflow.com/users/1103681/oli-obk"}, "is_accepted": false, "score": 4, "last_activity_date": 1479996167, "creation_date": 1479996167, "answer_id": 40788374, "question_id": 40782412, "link": "https://stackoverflow.com/questions/40782412/indexing-vector-by-a-32-bit-integer/40788374#40788374", "title": "Indexing vector by a 32-bit integer", "body": "<blockquote>\n  <p>I prefer to store \"references\" to nodes as u32 rather than usize. So when traversing the graph I keep retrieving adjacent vertex \"references\", which I then use to look up the actual vertex object in the Vec object</p>\n</blockquote>\n\n<p>So actually you don't want <code>u32</code>, because you will never do calculations on it, and <code>u32</code> easily allows you to do math. You want an index-type that can just do indexing but whose values are immutable otherwise.</p>\n\n<p>I suggest you implement something along the line of <a href=\"http://manishearth.github.io/rust-internals-docs/rustc_data_structures/indexed_vec/struct.IndexVec.html\" rel=\"nofollow noreferrer\"><code>rustc_data_structures::indexed_vec::IndexVec</code></a>.</p>\n\n<p>This custom <code>IndexVec</code> type is not only generic over the element type, but also over the index type, and thus allows you to use a <code>NodeId</code> newtype wrapper around <code>u32</code>. You'll never accidentally use a non-id <code>u32</code> to index, and you can use them just as easily as a <code>u32</code>. You don't even have to create any of these indices by calculating them from the vector length, instead the <code>push</code> method returns the index of the location where the element has just been inserted.</p>\n"}], "owner": {"reputation": 1788, "user_id": 2789560, "user_type": "registered", "accept_rate": 56, "profile_image": "https://www.gravatar.com/avatar/46a017cbbb040e568f0e4f6c595f46d1?s=128&d=identicon&r=PG&f=1", "display_name": "Henning Koehler", "link": "https://stackoverflow.com/users/2789560/henning-koehler"}, "delete_vote_count": 0, "reopen_vote_count": 0, "close_vote_count": 0, "is_answered": true, "view_count": 3024, "favorite_count": 0, "answer_count": 2, "score": 6, "last_activity_date": 1480084452, "creation_date": 1479979609, "last_edit_date": 1480084452, "question_id": 40782412, "link": "https://stackoverflow.com/questions/40782412/indexing-vector-by-a-32-bit-integer", "title": "Indexing vector by a 32-bit integer", "body": "<p>In Rust, vectors are indexed using <code>usize</code>, so when writing</p>\n\n<pre><code>let my_vec: Vec&lt;String&gt; = vec![\"Hello\", \"world\"];\nlet index: u32 = 0;\nprintln!(\"{}\", my_vec[index]);\n</code></pre>\n\n<p>you get an error, as index is expected to be of type <code>usize</code>. I'm aware that this can be fixed by explicitly converting index to <code>usize</code>:</p>\n\n<pre><code>my_vec[index as usize]\n</code></pre>\n\n<p>but this is tedious to write. Ideally I'd simply overload the <code>[]</code> operator by implementing</p>\n\n<pre><code>impl&lt;T&gt; std::ops::Index&lt;u32&gt; for Vec&lt;T&gt; { ... }\n</code></pre>\n\n<p>but that's impossible as Rust prohibits this (as neither the trait nor struct are local). The only alternative that I can see is to create a wrapper class for <code>Vec</code>, but that would mean having to write lots of function wrappers as well. Is there any more elegant way to address this?</p>\n"}]